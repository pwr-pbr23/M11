#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isOperand ( char x ) { return ( x >= ' a ' && x <= ' z ' ) || ( x >= ' A ' && x <= ' Z ' ) ; } string getInfix ( string exp ) { stack < string > s ; for ( int i = 0 ; exp [ i ] != ' \0' ; i ++ ) { if ( isOperand ( exp [ i ] ) ) { string op ( 1 , exp [ i ] ) ; s . push ( op ) ; } else { string op1 = s . top ( ) ; s . pop ( ) ; string op2 = s . top ( ) ; s . pop ( ) ; s . push ( " ( " + op2 + exp [ i ] + op1 + " ) " ) ; } } return s . top ( ) ; } int main ( ) { string exp = " ab * c + " ; cout << getInfix ( exp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left , * right ; node ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; int updatetree ( node * root ) { if ( ! root ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return root -> data ; int leftsum = updatetree ( root -> left ) ; int rightsum = updatetree ( root -> right ) ; root -> data += leftsum ; return root -> data + rightsum ; } void inorder ( node * node ) { if ( node == NULL ) return ; inorder ( node -> left ) ; cout << node -> data << " ▁ " ; inorder ( node -> right ) ; } int main ( ) { struct node * root = new node ( 1 ) ; root -> left = new node ( 2 ) ; root -> right = new node ( 3 ) ; root -> left -> left = new node ( 4 ) ; root -> left -> right = new node ( 5 ) ; root -> right -> right = new node ( 6 ) ; updatetree ( root ) ; cout << " Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ is : ▁ STRNEWLINE " ; inorder ( root ) ; return 0 ; }
#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; void calculateSpan ( int price [ ] , int n , int S [ ] ) { stack < int > st ; st . push ( 0 ) ; S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! st . empty ( ) && price [ st . top ( ) ] <= price [ i ] ) st . pop ( ) ; S [ i ] = ( st . empty ( ) ) ? ( i + 1 ) : ( i - st . top ( ) ) ; st . push ( i ) ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; void calculateSpan ( int A [ ] , int n , int ans [ ] ) { ans [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int counter = 1 ; while ( ( i - counter ) >= 0 && A [ i ] >= A [ i - counter ] ) { counter += ans [ i - counter ] ; } ans [ i ] = counter ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void mirror ( struct Node * node ) { if ( node == NULL ) return ; else { struct Node * temp ; mirror ( node -> left ) ; mirror ( node -> right ) ; temp = node -> left ; node -> left = node -> right ; node -> right = temp ; } } void inOrder ( struct Node * node ) { if ( node == NULL ) return ; inOrder ( node -> left ) ; cout << node -> data << " ▁ " ; inOrder ( node -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << " Inorder ▁ traversal ▁ of ▁ the ▁ constructed " << " ▁ tree ▁ is " << endl ; inOrder ( root ) ; mirror ( root ) ; cout << " Inorder traversal of the mirror tree " << " ▁ is ▁ STRNEWLINE " ; inOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void fillNext ( int next [ ] , int a [ ] , int n ) { stack < int > s ; s . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( ! s . empty ( ) ) { int cur = s . top ( ) ; if ( a [ cur ] < a [ i ] ) { next [ cur ] = i ; s . pop ( ) ; } else break ; } s . push ( i ) ; } while ( ! s . empty ( ) ) { int cur = s . top ( ) ; next [ cur ] = -1 ; s . pop ( ) ; } } void count ( int a [ ] , int dp [ ] , int n ) { int next [ n ] ; memset ( next , 0 , sizeof ( next ) ) ; fillNext ( next , a , n ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( next [ i ] == -1 ) dp [ i ] = 0 ; else dp [ i ] = 1 + dp [ next [ i ] ] ; } } int answerQuery ( int dp [ ] , int index ) { return dp [ index ] ; } int main ( ) { int a [ ] = { 3 , 4 , 2 , 7 , 5 , 8 , 10 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int dp [ n ] ; count ( a , dp , n ) ; cout << answerQuery ( dp , 3 ) << endl ; cout << answerQuery ( dp , 6 ) << endl ; cout << answerQuery ( dp , 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > no_NGN ( int arr [ ] , int n ) { vector < int > nxt ; stack < int > s ; nxt . push_back ( 0 ) ; s . push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ i ] >= arr [ s . top ( ) ] ) s . pop ( ) ; if ( s . empty ( ) ) nxt . push_back ( 0 ) ; else nxt . push_back ( nxt [ n - s . top ( ) - 1 ] + 1 ) ; s . push ( i ) ; } reverse ( nxt . begin ( ) , nxt . end ( ) ) ; return nxt ; } int main ( ) { int n = 8 ; int arr [ ] = { 3 , 4 , 2 , 7 , 5 , 8 , 10 , 6 } ; vector < int > nxt = no_NGN ( arr , n ) ; cout << nxt [ 3 ] << endl ; cout << nxt [ 6 ] << endl ; cout << nxt [ 1 ] << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE vector < int > nextGreaterInLeft ( int a [ ] , int n ) { vector < int > left_index ( MAX , 0 ) ; stack < int > s ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && a [ i ] > a [ s . top ( ) - 1 ] ) { int r = s . top ( ) ; s . pop ( ) ; left_index [ r - 1 ] = i + 1 ; } s . push ( i + 1 ) ; } return left_index ; } vector < int > nextGreaterInRight ( int a [ ] , int n ) { vector < int > right_index ( MAX , 0 ) ; stack < int > s ; for ( int i = 0 ; i < n ; ++ i ) { while ( ! s . empty ( ) && a [ i ] > a [ s . top ( ) - 1 ] ) { int r = s . top ( ) ; s . pop ( ) ; right_index [ r - 1 ] = i + 1 ; } s . push ( i + 1 ) ; } return right_index ; } int LRProduct ( int arr [ ] , int n ) { vector < int > left = nextGreaterInLeft ( arr , n ) ; vector < int > right = nextGreaterInRight ( arr , n ) ; int ans = -1 ; for ( int i = 1 ; i <= n ; i ++ ) { ans = max ( ans , left [ i ] * right [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 5 , 4 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 1 ] ) ; cout << LRProduct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <list> NEW_LINE using namespace std ; #define N  8 NEW_LINE bool MATRIX [ N ] [ N ] = { { 0 , 0 , 1 , 0 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 } } ; bool knows ( int a , int b ) { return MATRIX [ a ] [ b ] ; } int findCelebrity ( int n ) { int indegree [ n ] = { 0 } , outdegree [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x = knows ( i , j ) ; outdegree [ i ] += x ; indegree [ j ] += x ; } } for ( int i = 0 ; i < n ; i ++ ) if ( indegree [ i ] == n - 1 && outdegree [ i ] == 0 ) return i ; return -1 ; } int main ( ) { int n = 4 ; int id = findCelebrity ( n ) ; id == -1 ? cout << " No ▁ celebrity " : cout << " Celebrity ▁ ID ▁ " << id ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int precedence ( char op ) { if ( op == ' + ' op == ' - ' ) return 1 ; if ( op == ' * ' op == ' / ' ) return 2 ; return 0 ; } int applyOp ( int a , int b , char op ) { switch ( op ) { case ' + ' : return a + b ; case ' - ' : return a - b ; case ' * ' : return a * b ; case ' / ' : return a / b ; } } int evaluate ( string tokens ) { int i ; stack < int > values ; stack < char > ops ; for ( i = 0 ; i < tokens . length ( ) ; i ++ ) { if ( tokens [ i ] == ' ▁ ' ) continue ; else if ( tokens [ i ] == ' ( ' ) { ops . push ( tokens [ i ] ) ; } else if ( isdigit ( tokens [ i ] ) ) { int val = 0 ; while ( i < tokens . length ( ) && isdigit ( tokens [ i ] ) ) { val = ( val * 10 ) + ( tokens [ i ] - '0' ) ; i ++ ; } values . push ( val ) ; i -- ; } else if ( tokens [ i ] == ' ) ' ) { while ( ! ops . empty ( ) && ops . top ( ) != ' ( ' ) { int val2 = values . top ( ) ; values . pop ( ) ; int val1 = values . top ( ) ; values . pop ( ) ; char op = ops . top ( ) ; ops . pop ( ) ; values . push ( applyOp ( val1 , val2 , op ) ) ; } if ( ! ops . empty ( ) ) ops . pop ( ) ; } else { while ( ! ops . empty ( ) && precedence ( ops . top ( ) ) >= precedence ( tokens [ i ] ) ) { int val2 = values . top ( ) ; values . pop ( ) ; int val1 = values . top ( ) ; values . pop ( ) ; char op = ops . top ( ) ; ops . pop ( ) ; values . push ( applyOp ( val1 , val2 , op ) ) ; } ops . push ( tokens [ i ] ) ; } } while ( ! ops . empty ( ) ) { int val2 = values . top ( ) ; values . pop ( ) ; int val1 = values . top ( ) ; values . pop ( ) ; char op = ops . top ( ) ; ops . pop ( ) ; values . push ( applyOp ( val1 , val2 , op ) ) ; } return values . top ( ) ; } int main ( ) { cout << evaluate ( "10 ▁ + ▁ 2 ▁ * ▁ 6" ) << " STRNEWLINE " ; cout << evaluate ( "100 ▁ * ▁ 2 ▁ + ▁ 12" ) << " STRNEWLINE " ; cout << evaluate ( "100 ▁ * ▁ ( ▁ 2 ▁ + ▁ 12 ▁ ) " ) << " STRNEWLINE " ; cout << evaluate ( "100 ▁ * ▁ ( ▁ 2 ▁ + ▁ 12 ▁ ) ▁ / ▁ 14" ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void mirror ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { Node * curr = q . front ( ) ; q . pop ( ) ; swap ( curr -> left , curr -> right ) ; if ( curr -> left ) q . push ( curr -> left ) ; if ( curr -> right ) q . push ( curr -> right ) ; } } void inOrder ( struct Node * node ) { if ( node == NULL ) return ; inOrder ( node -> left ) ; cout << node -> data << " ▁ " ; inOrder ( node -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << " Inorder traversal of the " STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL " constructed tree is " ; inOrder ( root ) ; mirror ( root ) ; cout << " Inorder traversal of the " STRNEWLINE TABSYMBOL TABSYMBOL " mirror tree is " ; inOrder ( root ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE #include <stdlib.h> NEW_LINE #include <limits.h> NEW_LINE struct Stack { unsigned capacity ; int top ; int * array ; } ; struct Stack * createStack ( unsigned capacity ) { struct Stack * stack = ( struct Stack * ) malloc ( sizeof ( struct Stack ) ) ; stack -> capacity = capacity ; stack -> top = -1 ; stack -> array = ( int * ) malloc ( stack -> capacity * sizeof ( int ) ) ; return stack ; } int isFull ( struct Stack * stack ) { return ( stack -> top == stack -> capacity - 1 ) ; } int isEmpty ( struct Stack * stack ) { return ( stack -> top == -1 ) ; } void push ( struct Stack * stack , int item ) { if ( isFull ( stack ) ) return ; stack -> array [ ++ stack -> top ] = item ; } int pop ( struct Stack * stack ) { if ( isEmpty ( stack ) ) return INT_MIN ; return stack -> array [ stack -> top -- ] ; } void moveDisk ( char fromPeg , char toPeg , int disk ) { printf ( " Move ▁ the ▁ disk ▁ % d ▁ from ▁ \' % c \' ▁ to ▁ \' % c \' STRNEWLINE " , disk , fromPeg , toPeg ) ; } void moveDisksBetweenTwoPoles ( struct Stack * src , struct Stack * dest , char s , char d ) { int pole1TopDisk = pop ( src ) ; int pole2TopDisk = pop ( dest ) ; if ( pole1TopDisk == INT_MIN ) { push ( src , pole2TopDisk ) ; moveDisk ( d , s , pole2TopDisk ) ; } else if ( pole2TopDisk == INT_MIN ) { push ( dest , pole1TopDisk ) ; moveDisk ( s , d , pole1TopDisk ) ; } else if ( pole1TopDisk > pole2TopDisk ) { push ( src , pole1TopDisk ) ; push ( src , pole2TopDisk ) ; moveDisk ( d , s , pole2TopDisk ) ; } else { push ( dest , pole2TopDisk ) ; push ( dest , pole1TopDisk ) ; moveDisk ( s , d , pole1TopDisk ) ; } } void tohIterative ( int num_of_disks , struct Stack * src , struct Stack * aux , struct Stack * dest ) { int i , total_num_of_moves ; char s = ' S ' , d = ' D ' , a = ' A ' ; if ( num_of_disks % 2 == 0 ) { char temp = d ; d = a ; a = temp ; } total_num_of_moves = pow ( 2 , num_of_disks ) - 1 ; for ( i = num_of_disks ; i >= 1 ; i -- ) push ( src , i ) ; for ( i = 1 ; i <= total_num_of_moves ; i ++ ) { if ( i % 3 == 1 ) moveDisksBetweenTwoPoles ( src , dest , s , d ) ; else if ( i % 3 == 2 ) moveDisksBetweenTwoPoles ( src , aux , s , a ) ; else if ( i % 3 == 0 ) moveDisksBetweenTwoPoles ( aux , dest , a , d ) ; } } int main ( ) { unsigned num_of_disks = 3 ; struct Stack * src , * dest , * aux ; src = createStack ( num_of_disks ) ; aux = createStack ( num_of_disks ) ; dest = createStack ( num_of_disks ) ; tohIterative ( num_of_disks , src , aux , dest ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void deleteMid ( stack < char > & st , int n , int curr = 0 ) { if ( st . empty ( ) curr == n ) return ; char x = st . top ( ) ; st . pop ( ) ; deleteMid ( st , n , curr + 1 ) ; if ( curr != n / 2 ) st . push ( x ) ; } int main ( ) { stack < char > st ; st . push ( '1' ) ; st . push ( '2' ) ; st . push ( '3' ) ; st . push ( '4' ) ; st . push ( '5' ) ; st . push ( '6' ) ; st . push ( '7' ) ; deleteMid ( st , st . size ( ) ) ; while ( ! st . empty ( ) ) { char p = st . top ( ) ; st . pop ( ) ; cout << p << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; stack < int > sortStack ( stack < int > input ) { stack < int > tmpStack ; while ( ! input . empty ( ) ) { int tmp = input . top ( ) ; input . pop ( ) ; while ( ! tmpStack . empty ( ) && tmpStack . top ( ) < tmp ) { input . push ( tmpStack . top ( ) ) ; tmpStack . pop ( ) ; } tmpStack . push ( tmp ) ; } return tmpStack ; } void sortArrayUsingStacks ( int arr [ ] , int n ) { stack < int > input ; for ( int i = 0 ; i < n ; i ++ ) input . push ( arr [ i ] ) ; stack < int > tmpStack = sortStack ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = tmpStack . top ( ) ; tmpStack . pop ( ) ; } } int main ( ) { int arr [ ] = { 10 , 5 , 15 , 45 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArrayUsingStacks ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; void push ( Node * * head_ref , Node * node ) { node -> right = ( * head_ref ) ; node -> left = NULL ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> left = node ; ( * head_ref ) = node ; } void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> right ; } } void spiralLevelOrder ( Node * root ) { if ( root == NULL ) return ; deque < Node * > q ; q . push_front ( root ) ; stack < Node * > stk ; int level = 0 ; while ( ! q . empty ( ) ) { int nodeCount = q . size ( ) ; if ( level & 1 ) { while ( nodeCount > 0 ) { Node * node = q . front ( ) ; q . pop_front ( ) ; stk . push ( node ) ; if ( node -> left != NULL ) q . push_back ( node -> left ) ; if ( node -> right != NULL ) q . push_back ( node -> right ) ; nodeCount -- ; } } else { while ( nodeCount > 0 ) { Node * node = q . back ( ) ; q . pop_back ( ) ; stk . push ( node ) ; if ( node -> right != NULL ) q . push_front ( node -> right ) ; if ( node -> left != NULL ) q . push_front ( node -> left ) ; nodeCount -- ; } } level ++ ; } Node * head = NULL ; while ( ! stk . empty ( ) ) { push ( & head , stk . top ( ) ) ; stk . pop ( ) ; } cout << " Created ▁ DLL ▁ is : STRNEWLINE " ; printList ( head ) ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> left -> right = newNode ( 13 ) ; root -> right -> right -> left = newNode ( 14 ) ; spiralLevelOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverseWords ( string str ) { stack < char > st ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { if ( str [ i ] != ' ▁ ' ) st . push ( str [ i ] ) ; else { while ( st . empty ( ) == false ) { cout << st . top ( ) ; st . pop ( ) ; } cout << " ▁ " ; } } while ( st . empty ( ) == false ) { cout << st . top ( ) ; st . pop ( ) ; } } int main ( ) { string str = " Geeks ▁ for ▁ Geeks " ; reverseWords ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAXN  100005 NEW_LINE using namespace std ; void makeNext ( int arr [ ] , int n , int nextBig [ ] ) { stack < pair < int , int > > s ; for ( int i = n - 1 ; i >= 0 ; i -- ) { nextBig [ i ] = i ; while ( ! s . empty ( ) && s . top ( ) . first < arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) nextBig [ i ] = s . top ( ) . second ; s . push ( pair < int , int > ( arr [ i ] , i ) ) ; } } void makePrev ( int arr [ ] , int n , int prevBig [ ] ) { stack < pair < int , int > > s ; for ( int i = 0 ; i < n ; i ++ ) { prevBig [ i ] = -1 ; while ( ! s . empty ( ) && s . top ( ) . first < arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) prevBig [ i ] = s . top ( ) . second ; s . push ( pair < int , int > ( arr [ i ] , i ) ) ; } } int wrapper ( int arr [ ] , int n ) { int nextBig [ MAXN ] ; int prevBig [ MAXN ] ; int maxi [ MAXN ] ; int ans = 0 ; makePrev ( arr , n , prevBig ) ; makeNext ( arr , n , nextBig ) ; for ( int i = 0 ; i < n ; i ++ ) if ( nextBig [ i ] != i ) maxi [ nextBig [ i ] - i ] = max ( maxi [ nextBig [ i ] - i ] , i - prevBig [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) ans += maxi [ i ] ; return ans ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << wrapper ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int A [ ] , int N ) { stack < int > S ; int B_end = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! S . empty ( ) ) { int top = S . top ( ) ; while ( top == B_end + 1 ) { B_end = B_end + 1 ; S . pop ( ) ; if ( S . empty ( ) ) { break ; } top = S . top ( ) ; } if ( S . empty ( ) ) { S . push ( A [ i ] ) ; } else { top = S . top ( ) ; if ( A [ i ] < top ) { S . push ( A [ i ] ) ; } else { return false ; } } } else { S . push ( A [ i ] ) ; } } return true ; } int main ( ) { int A [ ] = { 4 , 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; check ( A , N ) ? cout << " YES " : cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMaxArea ( int hist [ ] , int n ) { stack < int > s ; int max_area = 0 ; int tp ; int area_with_top ; int i = 0 ; while ( i < n ) { if ( s . empty ( ) || hist [ s . top ( ) ] <= hist [ i ] ) s . push ( i ++ ) ; else { tp = s . top ( ) ; s . pop ( ) ; area_with_top = hist [ tp ] * ( s . empty ( ) ? i : i - s . top ( ) - 1 ) ; if ( max_area < area_with_top ) max_area = area_with_top ; } } while ( s . empty ( ) == false ) { tp = s . top ( ) ; s . pop ( ) ; area_with_top = hist [ tp ] * ( s . empty ( ) ? i : i - s . top ( ) - 1 ) ; if ( max_area < area_with_top ) max_area = area_with_top ; } return max_area ; } int main ( ) { int hist [ ] = { 6 , 2 , 5 , 4 , 5 , 1 , 6 } ; int n = sizeof ( hist ) / sizeof ( hist [ 0 ] ) ; cout << " Maximum ▁ area ▁ is ▁ " << getMaxArea ( hist , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod ) { if ( n == 1 ) { cout << " Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ " << from_rod << " ▁ to ▁ rod ▁ " << to_rod << endl ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; cout << " Move ▁ disk ▁ " << n << " ▁ from ▁ rod ▁ " << from_rod << " ▁ to ▁ rod ▁ " << to_rod << endl ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; } int main ( ) { int n = 4 ; towerOfHanoi ( n , ' A ' , ' C ' , ' B ' ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxLen ( string str ) { int n = str . length ( ) ; stack < int > stk ; stk . push ( -1 ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) stk . push ( i ) ; else { if ( ! stk . empty ( ) ) { stk . pop ( ) ; } if ( ! stk . empty ( ) ) result = max ( result , i - stk . top ( ) ) ; else stk . push ( i ) ; } } return result ; } int main ( ) { string str = " ( ( ( ) ( ) " ; cout << findMaxLen ( str ) << endl ; str = " ( ) ( ( ) ) ) ) ) " ; cout << findMaxLen ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  12 NEW_LINE using namespace std ; int dfs ( vector < int > tree [ N ] , int visit [ N ] , int * ans , int node ) { int num = 0 , temp = 0 ; visit [ node ] = 1 ; for ( int i = 0 ; i < tree [ node ] . size ( ) ; i ++ ) { if ( visit [ tree [ node ] [ i ] ] == 0 ) { temp = dfs ( tree , visit , ans , tree [ node ] [ i ] ) ; ( temp % 2 ) ? ( num += temp ) : ( ( * ans ) ++ ) ; } } return num + 1 ; } int minEdge ( vector < int > tree [ N ] , int n ) { int visit [ n + 2 ] ; int ans = 0 ; memset ( visit , 0 , sizeof visit ) ; dfs ( tree , visit , & ans , 1 ) ; return ans ; } int main ( ) { int n = 10 ; vector < int > tree [ n + 2 ] ; tree [ 1 ] . push_back ( 3 ) ; tree [ 3 ] . push_back ( 1 ) ; tree [ 1 ] . push_back ( 6 ) ; tree [ 6 ] . push_back ( 1 ) ; tree [ 1 ] . push_back ( 2 ) ; tree [ 2 ] . push_back ( 1 ) ; tree [ 3 ] . push_back ( 4 ) ; tree [ 4 ] . push_back ( 3 ) ; tree [ 6 ] . push_back ( 8 ) ; tree [ 8 ] . push_back ( 6 ) ; tree [ 2 ] . push_back ( 7 ) ; tree [ 7 ] . push_back ( 2 ) ; tree [ 2 ] . push_back ( 5 ) ; tree [ 5 ] . push_back ( 2 ) ; tree [ 4 ] . push_back ( 9 ) ; tree [ 9 ] . push_back ( 4 ) ; tree [ 4 ] . push_back ( 10 ) ; tree [ 10 ] . push_back ( 4 ) ; cout << minEdge ( tree , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxLen ( string s ) { if ( s . length ( ) <= 1 ) return 0 ; int curMax = 0 ; vector < int > longest ( s . size ( ) , 0 ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ) ' && i - longest [ i - 1 ] - 1 >= 0 && s [ i - longest [ i - 1 ] - 1 ] == ' ( ' ) { longest [ i ] = longest [ i - 1 ] + 2 + ( ( i - longest [ i - 1 ] - 2 >= 0 ) ? longest [ i - longest [ i - 1 ] - 2 ] : 0 ) ; curMax = max ( longest [ i ] , curMax ) ; } } return curMax ; } int main ( ) { string str = " ( ( ( ) ( ) " ; cout << findMaxLen ( str ) << endl ; str = " ( ) ( ( ) ) ) ) ) " ; cout << findMaxLen ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( string s , int n ) { int left = 0 , right = 0 , maxlength = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) left ++ ; else right ++ ; if ( left == right ) maxlength = max ( maxlength , 2 * right ) ; else if ( right > left ) left = right = 0 ; } left = right = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ( ' ) left ++ ; else right ++ ; if ( left == right ) maxlength = max ( maxlength , 2 * left ) ; else if ( left > right ) left = right = 0 ; } return maxlength ; } int main ( ) { cout << solve ( " ( ( ( ) ( ) ( ) ( ) ( ( ( ( ) ) " , 16 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; stack < char > s ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' } ' && ! s . empty ( ) ) { if ( s . top ( ) == ' { ' ) s . pop ( ) ; else s . push ( expr [ i ] ) ; } else s . push ( expr [ i ] ) ; } int red_len = s . size ( ) ; int n = 0 ; while ( ! s . empty ( ) && s . top ( ) == ' { ' ) { s . pop ( ) ; n ++ ; } return ( red_len / 2 + n % 2 ) ; } int main ( ) { string expr = " } } { { " ; cout << countMinReversals ( expr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 != 0 ) { return -1 ; } int left_brace = 0 , right_brace = 0 ; int ans ; for ( int i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) { left_brace ++ ; } else { if ( left_brace == 0 ) { right_brace ++ ; } else { left_brace -- ; } } } ans = ceil ( left_brace / 2 ) + ceil ( right_brace / 2 ) ; return ans ; } int main ( ) { string expr = " } } { { " ; cout << countMinReversals ( expr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkRedundancy ( string & str ) { stack < char > st ; for ( auto & ch : str ) { if ( ch == ' ) ' ) { char top = st . top ( ) ; st . pop ( ) ; bool flag = true ; while ( ! st . empty ( ) and top != ' ( ' ) { if ( top == ' + ' top == ' - ' top == ' * ' top == ' / ' ) flag = false ; top = st . top ( ) ; st . pop ( ) ; } if ( flag == true ) return true ; } else st . push ( ch ) ; } return false ; } void findRedundant ( string & str ) { bool ans = checkRedundancy ( str ) ; if ( ans == true ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; } int main ( ) { string str = " ( ( a + b ) ) " ; findRedundant ( str ) ; str = " ( a + ( b ) / c ) " ; findRedundant ( str ) ; str = " ( a + b * ( c - d ) ) " ; findRedundant ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; bool adjSign ( string s , int i ) { if ( i == 0 ) return true ; if ( s [ i - 1 ] == ' - ' ) return false ; return true ; } ; void eval ( string s , vector < int > & v , bool add ) { stack < bool > stk ; stk . push ( true ) ; int i = 0 ; while ( s [ i ] != ' \0' ) { if ( s [ i ] == ' + ' s [ i ] == ' - ' ) { i ++ ; continue ; } if ( s [ i ] == ' ( ' ) { if ( adjSign ( s , i ) ) stk . push ( stk . top ( ) ) ; else stk . push ( ! stk . top ( ) ) ; } else if ( s [ i ] == ' ) ' ) stk . pop ( ) ; else { if ( stk . top ( ) ) v [ s [ i ] - ' a ' ] += ( adjSign ( s , i ) ? add ? 1 : -1 : add ? -1 : 1 ) ; else v [ s [ i ] - ' a ' ] += ( adjSign ( s , i ) ? add ? -1 : 1 : add ? 1 : -1 ) ; } i ++ ; } } ; bool areSame ( string expr1 , string expr2 ) { vector < int > v ( MAX_CHAR , 0 ) ; eval ( expr1 , v , true ) ; eval ( expr2 , v , false ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( v [ i ] != 0 ) return false ; return true ; } int main ( ) { string expr1 = " - ( a + b + c ) " , expr2 = " - a - b - c " ; if ( areSame ( expr1 , expr2 ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void test ( string expression , int index ) { int i ; if ( expression [ index ] != ' [ ' ) { cout << expression << " , ▁ " << index << " : ▁ - 1 STRNEWLINE " ; return ; } stack < int > st ; for ( i = index ; i < expression . length ( ) ; i ++ ) { if ( expression [ i ] == ' [ ' ) st . push ( expression [ i ] ) ; else if ( expression [ i ] == ' ] ' ) { st . pop ( ) ; if ( st . empty ( ) ) { cout << expression << " , ▁ " << index << " : ▁ " << i << " STRNEWLINE " ; return ; } } } cout << expression << " , ▁ " << index << " : ▁ - 1 STRNEWLINE " ; } int main ( ) { test ( " [ ABC [ 23 ] ] [89 ] " , 0 ) ; test ( " [ ABC [ 23 ] ] [89 ] " , 4 ) ; test ( " [ ABC [ 23 ] ] [89 ] " , 9 ) ; test ( " [ ABC [ 23 ] ] [89 ] " , 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int key ) { struct Node * node = new Node ; node -> data = key ; node -> left = node -> right = NULL ; return node ; } void convertTree ( Node * root ) { if ( root == NULL ) return ; convertTree ( root -> left ) ; convertTree ( root -> right ) ; if ( root -> left != NULL && root -> right != NULL ) root -> data = ( root -> left -> data ) & ( root -> right -> data ) ; } void printInorder ( Node * root ) { if ( root == NULL ) return ; printInorder ( root -> left ) ; printf ( " % d ▁ " , root -> data ) ; printInorder ( root -> right ) ; } int main ( ) { Node * root = newNode ( 0 ) ; root -> left = newNode ( 1 ) ; root -> right = newNode ( 0 ) ; root -> left -> left = newNode ( 0 ) ; root -> left -> right = newNode ( 1 ) ; root -> right -> left = newNode ( 1 ) ; root -> right -> right = newNode ( 1 ) ; printf ( " Inorder traversal before conversion " printInorder ( root ) ; convertTree ( root ) ; printf ( " Inorder traversal after conversion " printInorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintMinNumberForPattern ( string arr ) { int curr_max = 0 ; int last_entry = 0 ; int j ; for ( int i = 0 ; i < arr . length ( ) ; i ++ ) { int noOfNextD = 0 ; switch ( arr [ i ] ) { case ' I ' : j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } if ( i == 0 ) { curr_max = noOfNextD + 2 ; cout << " ▁ " << ++ last_entry ; cout << " ▁ " << curr_max ; last_entry = curr_max ; } else { curr_max = curr_max + noOfNextD + 1 ; last_entry = curr_max ; cout << " ▁ " << last_entry ; } for ( int k = 0 ; k < noOfNextD ; k ++ ) { cout << " ▁ " << -- last_entry ; i ++ ; } break ; case ' D ' : if ( i == 0 ) { j = i + 1 ; while ( arr [ j ] == ' D ' && j < arr . length ( ) ) { noOfNextD ++ ; j ++ ; } curr_max = noOfNextD + 2 ; cout << " ▁ " << curr_max << " ▁ " << curr_max - 1 ; last_entry = curr_max - 1 ; } else { cout << " ▁ " << last_entry - 1 ; last_entry -- ; } break ; } } cout << endl ; } int main ( ) { PrintMinNumberForPattern ( " IDID " ) ; PrintMinNumberForPattern ( " I " ) ; PrintMinNumberForPattern ( " DD " ) ; PrintMinNumberForPattern ( " II " ) ; PrintMinNumberForPattern ( " DIDI " ) ; PrintMinNumberForPattern ( " IIDDD " ) ; PrintMinNumberForPattern ( " DDIDDIID " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLeast ( string arr ) { int min_avail = 1 , pos_of_I = 0 ; vector < int > v ; if ( arr [ 0 ] == ' I ' ) { v . push_back ( 1 ) ; v . push_back ( 2 ) ; min_avail = 3 ; pos_of_I = 1 ; } else { v . push_back ( 2 ) ; v . push_back ( 1 ) ; min_avail = 3 ; pos_of_I = 0 ; } for ( int i = 1 ; i < arr . length ( ) ; i ++ ) { if ( arr [ i ] == ' I ' ) { v . push_back ( min_avail ) ; min_avail ++ ; pos_of_I = i + 1 ; } else { v . push_back ( v [ i ] ) ; for ( int j = pos_of_I ; j <= i ; j ++ ) v [ j ] ++ ; min_avail ++ ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << " ▁ " ; cout << endl ; } int main ( ) { printLeast ( " IDID " ) ; printLeast ( " I " ) ; printLeast ( " DD " ) ; printLeast ( " II " ) ; printLeast ( " DIDI " ) ; printLeast ( " IIDDD " ) ; printLeast ( " DDIDDIID " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string getMinNumberForPattern ( string seq ) { int n = seq . length ( ) ; if ( n >= 9 ) return " - 1" ; string result ( n + 1 , ' ▁ ' ) ; int count = 1 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == n seq [ i ] == ' I ' ) { for ( int j = i - 1 ; j >= -1 ; j -- ) { result [ j + 1 ] = '0' + count ++ ; if ( j >= 0 && seq [ j ] == ' I ' ) break ; } } } return result ; } int main ( ) { string inputs [ ] = { " IDID " , " I " , " DD " , " II " , " DIDI " , " IIDDD " , " DDIDDIID " } ; for ( string input : inputs ) { cout << getMinNumberForPattern ( input ) << " STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findDuplicateparenthesis ( string str ) { stack < char > Stack ; for ( char ch : str ) { if ( ch == ' ) ' ) { char top = Stack . top ( ) ; Stack . pop ( ) ; int elementsInside = 0 ; while ( top != ' ( ' ) { elementsInside ++ ; top = Stack . top ( ) ; Stack . pop ( ) ; } if ( elementsInside < 1 ) { return 1 ; } } else Stack . push ( ch ) ; } return false ; } int main ( ) { string str = " ( ( ( a + ( b ) ) + ( c + d ) ) ) " ; if ( findDuplicateparenthesis ( str ) ) cout << " Duplicate ▁ Found ▁ " ; else cout << " No ▁ Duplicates ▁ Found ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nextGreater ( int arr [ ] , int n , int next [ ] , char order ) { stack < int > S ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! S . empty ( ) && ( ( order == ' G ' ) ? arr [ S . top ( ) ] <= arr [ i ] : arr [ S . top ( ) ] >= arr [ i ] ) ) S . pop ( ) ; if ( ! S . empty ( ) ) next [ i ] = S . top ( ) ; else next [ i ] = -1 ; S . push ( i ) ; } } void nextSmallerOfNextGreater ( int arr [ ] , int n ) { int NG [ n ] ; int RS [ n ] ; nextGreater ( arr , n , NG , ' G ' ) ; nextGreater ( arr , n , RS , ' S ' ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( NG [ i ] != -1 && RS [ NG [ i ] ] != -1 ) cout << arr [ RS [ NG [ i ] ] ] << " ▁ " ; else cout << " - 1" << " ▁ " ; } } int main ( ) { int arr [ ] = { 5 , 1 , 9 , 2 , 5 , 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nextSmallerOfNextGreater ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumber ( int n ) { int result = 0 ; stack < int > s ; for ( int i = 1 ; i <= 9 ; i ++ ) { if ( i <= n ) { s . push ( i ) ; result ++ ; } while ( ! s . empty ( ) ) { int tp = s . top ( ) ; s . pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . push ( x ) ; result ++ ; } } } } return result ; } int main ( ) { int n = 15 ; cout << countNumber ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int removeConsecutiveSame ( vector < string > v ) { int n = v . size ( ) ; for ( int i = 0 ; i < n - 1 ; ) { if ( v [ i ] . compare ( v [ i + 1 ] ) == 0 ) { v . erase ( v . begin ( ) + i ) ; v . erase ( v . begin ( ) + i ) ; if ( i > 0 ) i -- ; n = n - 2 ; } else i ++ ; } return v . size ( ) ; } int main ( ) { vector < string > v = { " tom " , " jerry " , " jerry " , " tom " } ; cout << removeConsecutiveSame ( v ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int removeConsecutiveSame ( vector < string > v ) { stack < string > st ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( st . empty ( ) ) st . push ( v [ i ] ) ; else { string str = st . top ( ) ; if ( str . compare ( v [ i ] ) == 0 ) st . pop ( ) ; else st . push ( v [ i ] ) ; } } return st . size ( ) ; } int main ( ) { vector < string > V = { " ab " , " aa " , " aa " , " bcd " , " ab " } ; cout << removeConsecutiveSame ( V ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string decode ( string str ) { stack < int > integerstack ; stack < char > stringstack ; string temp = " " , result = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int count = 0 ; if ( str [ i ] >= '0' && str [ i ] <= '9' ) { while ( str [ i ] >= '0' && str [ i ] <= '9' ) { count = count * 10 + str [ i ] - '0' ; i ++ ; } i -- ; integerstack . push ( count ) ; } else if ( str [ i ] == ' ] ' ) { temp = " " ; count = 0 ; if ( ! integerstack . empty ( ) ) { count = integerstack . top ( ) ; integerstack . pop ( ) ; } while ( ! stringstack . empty ( ) && stringstack . top ( ) != ' [ ' ) { temp = stringstack . top ( ) + temp ; stringstack . pop ( ) ; } if ( ! stringstack . empty ( ) && stringstack . top ( ) == ' [ ' ) stringstack . pop ( ) ; for ( int j = 0 ; j < count ; j ++ ) result = result + temp ; for ( int j = 0 ; j < result . length ( ) ; j ++ ) stringstack . push ( result [ j ] ) ; result = " " ; } else if ( str [ i ] == ' [ ' ) { if ( str [ i - 1 ] >= '0' && str [ i - 1 ] <= '9' ) stringstack . push ( str [ i ] ) ; else { stringstack . push ( str [ i ] ) ; integerstack . push ( 1 ) ; } } else stringstack . push ( str [ i ] ) ; } while ( ! stringstack . empty ( ) ) { result = stringstack . top ( ) + result ; stringstack . pop ( ) ; } return result ; } int main ( ) { string str = "3 [ b2 [ ca ] ] " ; cout << decode ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void printAncestors ( struct Node * root , int key ) { if ( root == NULL ) return ; stack < struct Node * > st ; while ( 1 ) { while ( root && root -> data != key ) { st . push ( root ) ; root = root -> left ; } if ( root && root -> data == key ) break ; if ( st . top ( ) -> right == NULL ) { root = st . top ( ) ; st . pop ( ) ; while ( ! st . empty ( ) && st . top ( ) -> right == root ) { root = st . top ( ) ; st . pop ( ) ; } } root = st . empty ( ) ? NULL : st . top ( ) -> right ; } while ( ! st . empty ( ) ) { cout << st . top ( ) -> data << " ▁ " ; st . pop ( ) ; } } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 8 ) ; root -> right -> right = newNode ( 9 ) ; root -> left -> left -> left = newNode ( 4 ) ; root -> left -> right -> right = newNode ( 6 ) ; root -> right -> right -> left = newNode ( 10 ) ; int key = 6 ; printAncestors ( root , key ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class StackWithMax { stack < int > mainStack ; stack < int > trackStack ; public : void push ( int x ) { mainStack . push ( x ) ; if ( mainStack . size ( ) == 1 ) { trackStack . push ( x ) ; return ; } if ( x > trackStack . top ( ) ) trackStack . push ( x ) ; else trackStack . push ( trackStack . top ( ) ) ; } int getMax ( ) { return trackStack . top ( ) ; } int pop ( ) { mainStack . pop ( ) ; trackStack . pop ( ) ; } } ; int main ( ) { StackWithMax s ; s . push ( 20 ) ; cout << s . getMax ( ) << endl ; s . push ( 10 ) ; cout << s . getMax ( ) << endl ; s . push ( 50 ) ; cout << s . getMax ( ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; stack < int > st ; void push_digits ( int number ) { while ( number != 0 ) { st . push ( number % 10 ) ; number = number / 10 ; } } int reverse_number ( int number ) { push_digits ( number ) ; int reverse = 0 ; int i = 1 ; while ( ! st . empty ( ) ) { reverse = reverse + ( st . top ( ) * i ) ; st . pop ( ) ; i = i * 10 ; } return reverse ; } int main ( ) { int number = 39997 ; cout << reverse_number ( number ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * temp = new struct Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } Node * flipBinaryTree ( Node * root ) { if ( root == NULL ) return root ; if ( root -> left == NULL && root -> right == NULL ) return root ; Node * flippedRoot = flipBinaryTree ( root -> left ) ; root -> left -> left = root -> right ; root -> left -> right = root ; root -> left = root -> right = NULL ; return flippedRoot ; } void printLevelOrder ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; while ( 1 ) { int nodeCount = q . size ( ) ; if ( nodeCount == 0 ) break ; while ( nodeCount > 0 ) { Node * node = q . front ( ) ; cout << node -> data << " ▁ " ; q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; nodeCount -- ; } cout << endl ; } } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 5 ) ; cout << " Level ▁ order ▁ traversal ▁ of ▁ given ▁ tree STRNEWLINE " ; printLevelOrder ( root ) ; root = flipBinaryTree ( root ) ; cout << " Level order traversal of the flipped " STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL " tree " printLevelOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool pairWiseConsecutive ( stack < int > s ) { stack < int > aux ; while ( ! s . empty ( ) ) { aux . push ( s . top ( ) ) ; s . pop ( ) ; } bool result = true ; while ( aux . size ( ) > 1 ) { int x = aux . top ( ) ; aux . pop ( ) ; int y = aux . top ( ) ; aux . pop ( ) ; if ( abs ( x - y ) != 1 ) result = false ; s . push ( x ) ; s . push ( y ) ; } if ( aux . size ( ) == 1 ) s . push ( aux . top ( ) ) ; return result ; } int main ( ) { stack < int > s ; s . push ( 4 ) ; s . push ( 5 ) ; s . push ( -2 ) ; s . push ( -3 ) ; s . push ( 11 ) ; s . push ( 10 ) ; s . push ( 5 ) ; s . push ( 6 ) ; s . push ( 20 ) ; if ( pairWiseConsecutive ( s ) ) cout << " Yes " << endl ; else cout << " No " << endl ; cout << " Stack ▁ content ▁ ( from ▁ top ) " " ▁ after ▁ function ▁ call STRNEWLINE " ; while ( s . empty ( ) == false ) { cout << s . top ( ) << " ▁ " ; s . pop ( ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char * simplify ( string str ) { int len = str . length ( ) ; char * res = new char ( len ) ; int index = 0 , i = 0 ; stack < int > s ; s . push ( 0 ) ; while ( i < len ) { if ( str [ i ] == ' + ' ) { if ( s . top ( ) == 1 ) res [ index ++ ] = ' - ' ; if ( s . top ( ) == 0 ) res [ index ++ ] = ' + ' ; } else if ( str [ i ] == ' - ' ) { if ( s . top ( ) == 1 ) res [ index ++ ] = ' + ' ; else if ( s . top ( ) == 0 ) res [ index ++ ] = ' - ' ; } else if ( str [ i ] == ' ( ' && i > 0 ) { if ( str [ i - 1 ] == ' - ' ) { int x = ( s . top ( ) == 1 ) ? 0 : 1 ; s . push ( x ) ; } else if ( str [ i - 1 ] == ' + ' ) s . push ( s . top ( ) ) ; } else if ( str [ i ] == ' ) ' ) s . pop ( ) ; else res [ index ++ ] = str [ i ] ; i ++ ; } return res ; } int main ( ) { string s1 = " a - ( b + c ) " ; string s2 = " a - ( b - c - ( d + e ) ) - f " ; cout << simplify ( s1 ) << endl ; cout << simplify ( s2 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define BOUND  4 NEW_LINE int top = -1 ; int length = 0 ; int * create_new ( int * a ) { int * new_a = new int [ length + BOUND ] ; for ( int i = 0 ; i < length ; i ++ ) new_a [ i ] = a [ i ] ; length += BOUND ; return new_a ; } int * push ( int * a , int element ) { if ( top == length - 1 ) a = create_new ( a ) ; a [ ++ top ] = element ; return a ; } void pop ( int * a ) { top -- ; } void display ( int * a ) { if ( top == -1 ) cout << " Stack ▁ is ▁ Empty " << endl ; else { cout << " Stack : ▁ " ; for ( int i = 0 ; i <= top ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; } } int main ( ) { int * a = create_new ( a ) ; a = push ( a , 1 ) ; a = push ( a , 2 ) ; a = push ( a , 3 ) ; a = push ( a , 4 ) ; display ( a ) ; a = push ( a , 5 ) ; a = push ( a , 6 ) ; display ( a ) ; a = push ( a , 7 ) ; a = push ( a , 8 ) ; display ( a ) ; a = push ( a , 9 ) ; display ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructBlanceArray ( int BOP [ ] , int BCP [ ] , char * str , int n ) { stack < int > stk ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) stk . push ( i ) ; else { if ( ! stk . empty ( ) ) { BCP [ i ] = 1 ; BOP [ stk . top ( ) ] = 1 ; stk . pop ( ) ; } else BCP [ i ] = 0 ; } } for ( int i = 1 ; i < n ; i ++ ) { BCP [ i ] += BCP [ i - 1 ] ; BOP [ i ] += BOP [ i - 1 ] ; } } int query ( int BOP [ ] , int BCP [ ] , int s , int e ) { if ( BOP [ s - 1 ] == BOP [ s ] ) { return ( BCP [ e ] - BOP [ s ] ) * 2 ; } else { return ( BCP [ e ] - BOP [ s ] + 1 ) * 2 ; } } int main ( ) { char str [ ] = " ( ) ) ( ( ) ) ( ( ) ) ( " ; int n = strlen ( str ) ; int BCP [ n + 1 ] = { 0 } ; int BOP [ n + 1 ] = { 0 } ; constructBlanceArray ( BOP , BCP , str , n ) ; int startIndex = 5 , endIndex = 11 ; cout << " Maximum ▁ Length ▁ Correct ▁ Bracket " " ▁ Subsequence ▁ between ▁ " << startIndex << " ▁ and ▁ " << endIndex << " ▁ = ▁ " << query ( BOP , BCP , startIndex , endIndex ) << endl ; startIndex = 4 , endIndex = 5 ; cout << " Maximum ▁ Length ▁ Correct ▁ Bracket " " ▁ Subsequence ▁ between ▁ " << startIndex << " ▁ and ▁ " << endIndex << " ▁ = ▁ " << query ( BOP , BCP , startIndex , endIndex ) << endl ; startIndex = 1 , endIndex = 5 ; cout << " Maximum ▁ Length ▁ Correct ▁ Bracket " " ▁ Subsequence ▁ between ▁ " << startIndex << " ▁ and ▁ " << endIndex << " ▁ = ▁ " << query ( BOP , BCP , startIndex , endIndex ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void heapify ( int arr [ ] , int n , int i ) { int largest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { swap ( arr [ i ] , arr [ largest ] ) ; heapify ( arr , n , largest ) ; } } void heapSort ( int arr [ ] , int n ) { for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { swap ( arr [ 0 ] , arr [ i ] ) ; heapify ( arr , i , 0 ) ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; heapSort ( arr , n ) ; cout << " Sorted ▁ array ▁ is ▁ STRNEWLINE " ; printArray ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void buildMaxHeap ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ ( i - 1 ) / 2 ] ) { int j = i ; while ( arr [ j ] > arr [ ( j - 1 ) / 2 ] ) { swap ( arr [ j ] , arr [ ( j - 1 ) / 2 ] ) ; j = ( j - 1 ) / 2 ; } } } } void heapSort ( int arr [ ] , int n ) { buildMaxHeap ( arr , n ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { swap ( arr [ 0 ] , arr [ i ] ) ; int j = 0 , index ; do { index = ( 2 * j + 1 ) ; if ( arr [ index ] < arr [ index + 1 ] && index < ( i - 1 ) ) index ++ ; if ( arr [ j ] < arr [ index ] && index < i ) swap ( arr [ j ] , arr [ index ] ) ; j = index ; } while ( index < i ) ; } } int main ( ) { int arr [ ] = { 10 , 20 , 15 , 17 , 9 , 21 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Given ▁ array : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; printf ( " STRNEWLINE STRNEWLINE " ) ; heapSort ( arr , n ) ; printf ( " Sorted ▁ array : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * temp = new struct Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } Node * flipBinaryTree ( Node * root ) { Node * curr = root ; Node * next = NULL ; Node * temp = NULL ; Node * prev = NULL ; while ( curr ) { next = curr -> left ; curr -> left = temp ; temp = curr -> right ; curr -> right = prev ; prev = curr ; curr = next ; } return prev ; } void printLevelOrder ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; while ( 1 ) { int nodeCount = q . size ( ) ; if ( nodeCount == 0 ) break ; while ( nodeCount > 0 ) { Node * node = q . front ( ) ; cout << node -> data << " ▁ " ; q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; nodeCount -- ; } cout << endl ; } } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 5 ) ; cout << " Level ▁ order ▁ traversal ▁ of ▁ given ▁ tree STRNEWLINE " ; printLevelOrder ( root ) ; root = flipBinaryTree ( root ) ; cout << " Level order traversal of the flipped " STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL " tree " printLevelOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE #define true  1 NEW_LINE #define false  0 NEW_LINE class node { public : int data ; node * left ; node * right ; } ; bool IsFoldableUtil ( node * n1 , node * n2 ) ; bool IsFoldable ( node * root ) { if ( root == NULL ) { return true ; } return IsFoldableUtil ( root -> left , root -> right ) ; } bool IsFoldableUtil ( node * n1 , node * n2 ) { if ( n1 == NULL && n2 == NULL ) { return true ; } if ( n1 == NULL n2 == NULL ) { return false ; } return IsFoldableUtil ( n1 -> left , n2 -> right ) && IsFoldableUtil ( n1 -> right , n2 -> left ) ; } node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int main ( void ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; if ( IsFoldable ( root ) == true ) { cout << " Tree ▁ is ▁ foldable " ; } else { cout << " Tree ▁ is ▁ not ▁ foldable " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int k ) { struct Node * node = new Node ; node -> data = k ; node -> right = node -> left = NULL ; return node ; } bool isHeap ( Node * root ) { queue < Node * > q ; q . push ( root ) ; bool nullish = false ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left ) { if ( nullish temp -> left -> data > = temp -> data ) { return false ; } q . push ( temp -> left ) ; } else { nullish = true ; } if ( temp -> right ) { if ( nullish temp -> right -> data > = temp -> data ) { return false ; } q . push ( temp -> right ) ; } else { nullish = true ; } } return true ; } int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 9 ) ; root -> right = newNode ( 8 ) ; root -> left -> left = newNode ( 7 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 4 ) ; root -> left -> left -> left = newNode ( 3 ) ; root -> left -> left -> right = newNode ( 2 ) ; root -> left -> right -> left = newNode ( 1 ) ; if ( isHeap ( root ) ) cout << " Given ▁ binary ▁ tree ▁ is ▁ a ▁ Heap STRNEWLINE " ; else cout << " Given ▁ binary ▁ tree ▁ is ▁ not ▁ a ▁ Heap STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; int isSumProperty ( struct node * node ) { int left_data = 0 , right_data = 0 ; if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return 1 ; else { if ( node -> left != NULL ) left_data = node -> left -> data ; if ( node -> right != NULL ) right_data = node -> right -> data ; if ( ( node -> data == left_data + right_data ) && isSumProperty ( node -> left ) && isSumProperty ( node -> right ) ) return 1 ; else return 0 ; } } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 2 ) ; if ( isSumProperty ( root ) ) cout << " The ▁ given ▁ tree ▁ satisfies ▁ " << " the ▁ children ▁ sum ▁ property ▁ " ; else cout << " The ▁ given ▁ tree ▁ does ▁ not ▁ satisfy ▁ " << " the ▁ children ▁ sum ▁ property ▁ " ; getchar ( ) ; return 0 ; }
#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE bool isHeap ( int arr [ ] , int i , int n ) { if ( i >= ( n - 2 ) / 2 ) return true ; if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) return true ; return false ; } int main ( ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) - 1 ; isHeap ( arr , 0 , n ) ? printf ( " Yes " ) : printf ( " No " ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE bool isHeap ( int arr [ ] , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; } int main ( ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; isHeap ( arr , n ) ? printf ( " Yes " ) : printf ( " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int arr [ ] , int n ) { priority_queue < int , vector < int > , greater < int > > pq ( arr , arr + n ) ; int res = 0 ; while ( pq . size ( ) > 1 ) { int first = pq . top ( ) ; pq . pop ( ) ; int second = pq . top ( ) ; pq . pop ( ) ; res += first + second ; pq . push ( first + second ) ; } return res ; } int main ( ) { int len [ ] = { 4 , 3 , 2 , 6 } ; int size = sizeof ( len ) / sizeof ( len [ 0 ] ) ; cout << " Total ▁ cost ▁ for ▁ connecting ▁ ropes ▁ is ▁ " << minCost ( len , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define n  4 NEW_LINE void mergeKArrays ( int arr [ ] [ n ] , int a , int output [ ] ) { int c = 0 ; for ( int i = 0 ; i < a ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) output [ c ++ ] = arr [ i ] [ j ] ; } sort ( output , output + n * a ) ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] [ n ] = { { 2 , 6 , 12 , 34 } , { 1 , 9 , 20 , 1000 } , { 23 , 34 , 90 , 2000 } } ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int output [ n * k ] ; mergeKArrays ( arr , 3 , output ) ; cout << " Merged ▁ array ▁ is ▁ " << endl ; printArray ( output , n * k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define n  4 NEW_LINE void mergeArrays ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 , int arr3 [ ] ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) arr3 [ k ++ ] = arr1 [ i ++ ] ; else arr3 [ k ++ ] = arr2 [ j ++ ] ; } while ( i < n1 ) arr3 [ k ++ ] = arr1 [ i ++ ] ; while ( j < n2 ) arr3 [ k ++ ] = arr2 [ j ++ ] ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; } void mergeKArrays ( int arr [ ] [ n ] , int i , int j , int output [ ] ) { if ( i == j ) { for ( int p = 0 ; p < n ; p ++ ) output [ p ] = arr [ i ] [ p ] ; return ; } if ( j - i == 1 ) { mergeArrays ( arr [ i ] , arr [ j ] , n , n , output ) ; return ; } int out1 [ n * ( ( ( i + j ) / 2 ) - i + 1 ) ] , out2 [ n * ( j - ( ( i + j ) / 2 ) ) ] ; mergeKArrays ( arr , i , ( i + j ) / 2 , out1 ) ; mergeKArrays ( arr , ( i + j ) / 2 + 1 , j , out2 ) ; mergeArrays ( out1 , out2 , n * ( ( ( i + j ) / 2 ) - i + 1 ) , n * ( j - ( ( i + j ) / 2 ) ) , output ) ; } int main ( ) { int arr [ ] [ n ] = { { 2 , 6 , 12 , 34 } , { 1 , 9 , 20 , 1000 } , { 23 , 34 , 90 , 2000 } } ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int output [ n * k ] ; mergeKArrays ( arr , 0 , 2 , output ) ; cout << " Merged ▁ array ▁ is ▁ " << endl ; printArray ( output , n * k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generate_derangement ( int N ) { int S [ N + 1 ] ; priority_queue < int , vector < int > , greater < int > > PQ ; for ( int i = 1 ; i <= N ; i ++ ) { S [ i ] = i ; PQ . push ( S [ i ] ) ; } int D [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { int d = PQ . top ( ) ; PQ . pop ( ) ; if ( d != S [ i ] i == N ) { D [ i ] = d ; } else { D [ i ] = PQ . top ( ) ; PQ . pop ( ) ; PQ . push ( d ) ; } } if ( D [ N ] == S [ N ] ) swap ( D [ N - 1 ] , D [ N ] ) ; for ( int i = 1 ; i <= N ; i ++ ) printf ( " % d ▁ " , D [ i ] ) ; printf ( " STRNEWLINE " ) ; } int main ( ) { generate_derangement ( 10 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void generate_derangement ( int N ) { int S [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int D [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N && i % N != 0 ) { int temp = D [ N ] ; D [ N ] = D [ N - 1 ] ; D [ N - 1 ] = temp ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) printf ( " % d ▁ " , D [ i ] ) ; printf ( " STRNEWLINE " ) ; } int main ( ) { generate_derangement ( 10 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLargest ( int seq [ ] , int N ) { int res [ N ] ; std :: priority_queue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) pq . push ( seq [ i ] ) ; for ( int i = 0 ; i < N ; i ++ ) { int d = pq . top ( ) ; pq . pop ( ) ; if ( d != seq [ i ] i == N - 1 ) { res [ i ] = d ; } else { res [ i ] = pq . top ( ) ; pq . pop ( ) ; pq . push ( d ) ; } } if ( res [ N - 1 ] == seq [ N - 1 ] ) { res [ N - 1 ] = res [ N - 2 ] ; res [ N - 2 ] = seq [ N - 1 ] ; } printf ( " Largest Derangement " for ( int i = 0 ; i < N ; i ++ ) printf ( " % d ▁ " , res [ i ] ) ; } int main ( ) { int seq [ ] = { 92 , 3 , 52 , 13 , 2 , 31 , 1 } ; int n = sizeof ( seq ) / sizeof ( seq [ 0 ] ) ; printLargest ( seq , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void heapify ( int arr [ ] , int n , int i ) { int smallest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] < arr [ smallest ] ) smallest = l ; if ( r < n && arr [ r ] < arr [ smallest ] ) smallest = r ; if ( smallest != i ) { swap ( arr [ i ] , arr [ smallest ] ) ; heapify ( arr , n , smallest ) ; } } void heapSort ( int arr [ ] , int n ) { for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { swap ( arr [ 0 ] , arr [ i ] ) ; heapify ( arr , i , 0 ) ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 4 , 6 , 3 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; heapSort ( arr , n ) ; cout << " Sorted ▁ array ▁ is ▁ STRNEWLINE " ; printArray ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; struct Key { int freq ; char ch ; bool operator< ( const Key & k ) const { return freq < k . freq ; } } ; void rearrangeString ( string str ) { int n = str . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; priority_queue < Key > pq ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int val = c - ' a ' ; if ( count [ val ] ) { pq . push ( Key { count [ val ] , c } ) ; } } str = " " ; Key prev { -1 , ' # ' } ; while ( ! pq . empty ( ) ) { Key k = pq . top ( ) ; pq . pop ( ) ; str = str + k . ch ; if ( prev . freq > 0 ) pq . push ( prev ) ; ( k . freq ) -- ; prev = k ; } if ( n != str . length ( ) ) cout << " ▁ Not ▁ valid ▁ String ▁ " << endl ; else cout << str << endl ; } int main ( ) { string str = " bbbaa " ; rearrangeString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int n = 7 ; void minheapify ( int a [ ] , int index ) { int small = index ; int l = 2 * index + 1 ; int r = 2 * index + 2 ; if ( l < n && a [ l ] < a [ small ] ) small = l ; if ( r < n && a [ r ] < a [ small ] ) small = r ; if ( small != index ) { swap ( a [ small ] , a [ index ] ) ; minheapify ( a , small ) ; } } int main ( ) { int i = 0 ; int k1 = 3 ; int k2 = 6 ; int a [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; int ans = 0 ; for ( i = ( n / 2 ) - 1 ; i >= 0 ; i -- ) { minheapify ( a , i ) ; } k1 -- ; k2 -- ; for ( i = 0 ; i <= k1 ; i ++ ) { a [ 0 ] = a [ n - 1 ] ; n -- ; minheapify ( a , 0 ) ; } for ( i = k1 + 1 ; i < k2 ; i ++ ) { ans += a [ 0 ] ; a [ 0 ] = a [ n - 1 ] ; n -- ; minheapify ( a , 0 ) ; } cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum ( int a [ ] , int n ) { sort ( a , a + n ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; } int main ( ) { int arr [ ] = { 5 , 3 , 0 , 7 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ required ▁ sum ▁ is ▁ " << minSum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } int sum ( Node * t ) { if ( t == NULL ) return 0 ; return t -> key + sum ( t -> left ) + sum ( t -> right ) ; } int uncoveredSumLeft ( Node * t ) { if ( t -> left == NULL && t -> right == NULL ) return t -> key ; if ( t -> left != NULL ) return t -> key + uncoveredSumLeft ( t -> left ) ; else return t -> key + uncoveredSumLeft ( t -> right ) ; } int uncoveredSumRight ( Node * t ) { if ( t -> left == NULL && t -> right == NULL ) return t -> key ; if ( t -> right != NULL ) return t -> key + uncoveredSumRight ( t -> right ) ; else return t -> key + uncoveredSumRight ( t -> left ) ; } int uncoverSum ( Node * t ) { int lb = 0 , rb = 0 ; if ( t -> left != NULL ) lb = uncoveredSumLeft ( t -> left ) ; if ( t -> right != NULL ) rb = uncoveredSumRight ( t -> right ) ; return t -> key + lb + rb ; } bool isSumSame ( Node * root ) { int sumUC = uncoverSum ( root ) ; int sumT = sum ( root ) ; return ( sumUC == ( sumT - sumUC ) ) ; } void inorder ( Node * root ) { if ( root ) { inorder ( root -> left ) ; printf ( " % d ▁ " , root -> key ) ; inorder ( root -> right ) ; } } int main ( ) { Node * root = newNode ( 8 ) ; root -> left = newNode ( 3 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 4 ) ; root -> left -> right -> right = newNode ( 7 ) ; root -> right = newNode ( 10 ) ; root -> right -> right = newNode ( 14 ) ; root -> right -> right -> left = newNode ( 13 ) ; if ( isSumSame ( root ) ) printf ( " Sum ▁ of ▁ covered ▁ and ▁ uncovered ▁ is ▁ same STRNEWLINE " ) ; else printf ( " Sum ▁ of ▁ covered ▁ and ▁ uncovered ▁ is ▁ not ▁ same STRNEWLINE " ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * prev , * next ; static Node * getnode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> prev = newNode -> next = NULL ; return newNode ; } } ; class Deque { Node * front ; Node * rear ; int Size ; public : Deque ( ) { front = rear = NULL ; Size = 0 ; } void insertFront ( int data ) ; void insertRear ( int data ) ; void deleteFront ( ) ; void deleteRear ( ) ; int getFront ( ) ; int getRear ( ) ; int size ( ) ; bool isEmpty ( ) ; void erase ( ) ; } ; bool Deque :: isEmpty ( ) { return ( front == NULL ) ; } int Deque :: size ( ) { return Size ; } void Deque :: insertFront ( int data ) { Node * newNode = Node :: getnode ( data ) ; if ( newNode == NULL ) cout << " OverFlow STRNEWLINE " ; else { if ( front == NULL ) rear = front = newNode ; else { newNode -> next = front ; front -> prev = newNode ; front = newNode ; } Size ++ ; } } void Deque :: insertRear ( int data ) { Node * newNode = Node :: getnode ( data ) ; if ( newNode == NULL ) cout << " OverFlow STRNEWLINE " ; else { if ( rear == NULL ) front = rear = newNode ; else { newNode -> prev = rear ; rear -> next = newNode ; rear = newNode ; } Size ++ ; } } void Deque :: deleteFront ( ) { if ( isEmpty ( ) ) cout << " UnderFlow STRNEWLINE " ; else { Node * temp = front ; front = front -> next ; if ( front == NULL ) rear = NULL ; else front -> prev = NULL ; free ( temp ) ; Size -- ; } } void Deque :: deleteRear ( ) { if ( isEmpty ( ) ) cout << " UnderFlow STRNEWLINE " ; else { Node * temp = rear ; rear = rear -> prev ; if ( rear == NULL ) front = NULL ; else rear -> next = NULL ; free ( temp ) ; Size -- ; } } int Deque :: getFront ( ) { if ( isEmpty ( ) ) return -1 ; return front -> data ; } int Deque :: getRear ( ) { if ( isEmpty ( ) ) return -1 ; return rear -> data ; } void Deque :: erase ( ) { rear = NULL ; while ( front != NULL ) { Node * temp = front ; front = front -> next ; free ( temp ) ; } Size = 0 ; } int main ( ) { Deque dq ; cout << " Insert ▁ element ▁ ' 5 ' ▁ at ▁ rear ▁ end STRNEWLINE " ; dq . insertRear ( 5 ) ; cout << " Insert ▁ element ▁ ' 10 ' ▁ at ▁ rear ▁ end STRNEWLINE " ; dq . insertRear ( 10 ) ; cout << " Rear ▁ end ▁ element : ▁ " << dq . getRear ( ) << endl ; dq . deleteRear ( ) ; cout << " After ▁ deleting ▁ rear ▁ element ▁ new ▁ rear " << " ▁ is : ▁ " << dq . getRear ( ) << endl ; cout << " Inserting ▁ element ▁ ' 15 ' ▁ at ▁ front ▁ end ▁ STRNEWLINE " ; dq . insertFront ( 15 ) ; cout << " Front ▁ end ▁ element : ▁ " << dq . getFront ( ) << endl ; cout << " Number ▁ of ▁ elements ▁ in ▁ Deque : ▁ " << dq . size ( ) << endl ; dq . deleteFront ( ) ; cout << " After ▁ deleting ▁ front ▁ element ▁ new ▁ " << " front ▁ is : ▁ " << dq . getFront ( ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } bool checkUtil ( struct Node * root , int level , int * leafLevel ) { if ( root == NULL ) return true ; if ( root -> left == NULL && root -> right == NULL ) { if ( * leafLevel == 0 ) { * leafLevel = level ; return true ; } return ( level == * leafLevel ) ; } return checkUtil ( root -> left , level + 1 , leafLevel ) && checkUtil ( root -> right , level + 1 , leafLevel ) ; } bool check ( struct Node * root ) { int level = 0 , leafLevel = 0 ; return checkUtil ( root , level , & leafLevel ) ; } int main ( ) { struct Node * root = newNode ( 12 ) ; root -> left = newNode ( 5 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 9 ) ; root -> left -> left -> left = newNode ( 1 ) ; root -> left -> right -> left = newNode ( 1 ) ; if ( check ( root ) ) cout << " Leaves ▁ are ▁ at ▁ same ▁ level STRNEWLINE " ; else cout << " Leaves ▁ are ▁ not ▁ at ▁ same ▁ level STRNEWLINE " ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int key ; vector < Node * > child ; Node ( int data ) { key = data ; } } ; int numberOfSiblings ( Node * root , int x ) { if ( root == NULL ) return 0 ; queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { Node * p = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < p -> child . size ( ) ; i ++ ) { if ( p -> child [ i ] -> key == x ) return p -> child . size ( ) - 1 ; q . push ( p -> child [ i ] ) ; } } } int main ( ) { Node * root = new Node ( 50 ) ; ( root -> child ) . push_back ( new Node ( 2 ) ) ; ( root -> child ) . push_back ( new Node ( 30 ) ) ; ( root -> child ) . push_back ( new Node ( 14 ) ) ; ( root -> child ) . push_back ( new Node ( 60 ) ) ; ( root -> child [ 0 ] -> child ) . push_back ( new Node ( 15 ) ) ; ( root -> child [ 0 ] -> child ) . push_back ( new Node ( 25 ) ) ; ( root -> child [ 0 ] -> child [ 1 ] -> child ) . push_back ( new Node ( 70 ) ) ; ( root -> child [ 0 ] -> child [ 1 ] -> child ) . push_back ( new Node ( 100 ) ) ; ( root -> child [ 1 ] -> child ) . push_back ( new Node ( 6 ) ) ; ( root -> child [ 1 ] -> child ) . push_back ( new Node ( 1 ) ) ; ( root -> child [ 2 ] -> child ) . push_back ( new Node ( 7 ) ) ; ( root -> child [ 2 ] -> child [ 0 ] -> child ) . push_back ( new Node ( 17 ) ) ; ( root -> child [ 2 ] -> child [ 0 ] -> child ) . push_back ( new Node ( 99 ) ) ; ( root -> child [ 2 ] -> child [ 0 ] -> child ) . push_back ( new Node ( 27 ) ) ; ( root -> child [ 3 ] -> child ) . push_back ( new Node ( 16 ) ) ; int x = 100 ; cout << numberOfSiblings ( root , x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ( ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int checkLevelLeafNode ( Node * root ) { if ( ! root ) return 1 ; queue < Node * > q ; q . push ( root ) ; int result = INT_MAX ; int level = 0 ; while ( ! q . empty ( ) ) { int size = q . size ( ) ; level += 1 ; while ( size > 0 ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left ) { q . push ( temp -> left ) ; if ( ! temp -> left -> right && ! temp -> left -> left ) { if ( result == INT_MAX ) result = level ; else if ( result != level ) return 0 ; } } if ( temp -> right ) { q . push ( temp -> right ) ; if ( ! temp -> right -> left && ! temp -> right -> right ) if ( result == INT_MAX ) result = level ; else if ( result != level ) return 0 ; } size -= 1 ; } } return 1 ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; int result = checkLevelLeafNode ( root ) ; if ( result ) cout << " All ▁ leaf ▁ nodes ▁ are ▁ at ▁ same ▁ level STRNEWLINE " ; else cout << " Leaf ▁ nodes ▁ not ▁ at ▁ same ▁ level STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_queue ( queue < int > q ) { while ( ! q . empty ( ) ) { cout << q . front ( ) << " ▁ " ; q . pop ( ) ; } cout << endl ; } int main ( ) { queue < int > q ; for ( int i = 0 ; i < 5 ; i ++ ) q . push ( i ) ; cout << " Elements ▁ of ▁ queue - " ; print_queue ( q ) ; int removedele = q . front ( ) ; q . pop ( ) ; cout << " removed ▁ element - " << removedele << endl ; print_queue ( q ) ; int head = q . front ( ) ; cout << " head ▁ of ▁ queue - " << head << endl ; int size = q . size ( ) ; cout << " Size ▁ of ▁ queue - " << size ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; stack < int > stack_push ( stack < int > stack ) { for ( int i = 0 ; i < 5 ; i ++ ) { stack . push ( i ) ; } return stack ; } stack < int > stack_pop ( stack < int > stack ) { cout << " Pop ▁ : " ; for ( int i = 0 ; i < 5 ; i ++ ) { int y = ( int ) stack . top ( ) ; stack . pop ( ) ; cout << ( y ) << endl ; } return stack ; } void stack_peek ( stack < int > stack ) { int element = ( int ) stack . top ( ) ; cout << " Element ▁ on ▁ stack ▁ top ▁ : ▁ " << element << endl ; } void stack_search ( stack < int > stack , int element ) { int pos = -1 , co = 0 ; while ( stack . size ( ) > 0 ) { co ++ ; if ( stack . top ( ) == element ) { pos = co ; break ; } stack . pop ( ) ; } if ( pos == -1 ) cout << " Element ▁ not ▁ found " << endl ; else cout << " Element ▁ is ▁ found ▁ at ▁ position ▁ " << pos << endl ; } int main ( ) { stack < int > stack ; stack = stack_push ( stack ) ; stack = stack_pop ( stack ) ; stack = stack_push ( stack ) ; stack_peek ( stack ) ; stack_search ( stack , 2 ) ; stack_search ( stack , 6 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printQueue ( queue < long long int > Queue ) { while ( ! Queue . empty ( ) ) { cout << Queue . front ( ) << " ▁ " ; Queue . pop ( ) ; } } void reverseQueue ( queue < long long int > & q ) { if ( q . empty ( ) ) return ; long long int data = q . front ( ) ; q . pop ( ) ; reverseQueue ( q ) ; q . push ( data ) ; } int main ( ) { queue < long long int > Queue ; Queue . push ( 56 ) ; Queue . push ( 27 ) ; Queue . push ( 30 ) ; Queue . push ( 45 ) ; Queue . push ( 85 ) ; Queue . push ( 92 ) ; Queue . push ( 58 ) ; Queue . push ( 80 ) ; Queue . push ( 90 ) ; Queue . push ( 100 ) ; reverseQueue ( Queue ) ; printQueue ( Queue ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minIndex ( queue < int > & q , int sortedIndex ) { int min_index = -1 ; int min_val = INT_MAX ; int n = q . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int curr = q . front ( ) ; q . pop ( ) ; if ( curr <= min_val && i <= sortedIndex ) { min_index = i ; min_val = curr ; } q . push ( curr ) ; } return min_index ; } void insertMinToRear ( queue < int > & q , int min_index ) { int min_val ; int n = q . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int curr = q . front ( ) ; q . pop ( ) ; if ( i != min_index ) q . push ( curr ) ; else min_val = curr ; } q . push ( min_val ) ; } void sortQueue ( queue < int > & q ) { for ( int i = 1 ; i <= q . size ( ) ; i ++ ) { int min_index = minIndex ( q , q . size ( ) - i ) ; insertMinToRear ( q , min_index ) ; } } int main ( ) { queue < int > q ; q . push ( 30 ) ; q . push ( 11 ) ; q . push ( 15 ) ; q . push ( 4 ) ; sortQueue ( q ) ; while ( q . empty ( ) == false ) { cout << q . front ( ) << " ▁ " ; q . pop ( ) ; } cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int x ) { struct Node * temp = new Node ; temp -> data = x ; temp -> left = temp -> right = NULL ; return temp ; } ; int count ( Node * root ) { if ( root == NULL ) return 0 ; return count ( root -> left ) + count ( root -> right ) + 1 ; } bool checkRec ( Node * root , int n ) { if ( root == NULL ) return false ; if ( count ( root ) == n - count ( root ) ) return true ; return checkRec ( root -> left , n ) || checkRec ( root -> right , n ) ; } bool check ( Node * root ) { int n = count ( root ) ; return checkRec ( root , n ) ; } int main ( ) { struct Node * root = newNode ( 5 ) ; root -> left = newNode ( 1 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 3 ) ; root -> right -> left = newNode ( 7 ) ; root -> right -> right = newNode ( 4 ) ; check ( root ) ? printf ( " YES " ) : printf ( " NO " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printKMax ( int arr [ ] , int n , int k ) { std :: deque < int > Qi ( k ) ; int i ; for ( i = 0 ; i < k ; ++ i ) { while ( ( ! Qi . empty ( ) ) && arr [ i ] >= arr [ Qi . back ( ) ] ) Qi . pop_back ( ) ; Qi . push_back ( i ) ; } for ( ; i < n ; ++ i ) { cout << arr [ Qi . front ( ) ] << " ▁ " ; while ( ( ! Qi . empty ( ) ) && Qi . front ( ) <= i - k ) Qi . pop_front ( ) ; while ( ( ! Qi . empty ( ) ) && arr [ i ] >= arr [ Qi . back ( ) ] ) Qi . pop_back ( ) ; Qi . push_back ( i ) ; } cout << arr [ Qi . front ( ) ] ; } int main ( ) { int arr [ ] = { 12 , 1 , 78 , 90 , 57 , 89 , 56 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printKMax ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int SumOfKsubArray ( int arr [ ] , int n , int k ) { int sum = 0 ; deque < int > S ( k ) , G ( k ) ; int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= arr [ i ] ) S . pop_back ( ) ; while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= arr [ i ] ) G . pop_back ( ) ; G . push_back ( i ) ; S . push_back ( i ) ; } for ( ; i < n ; i ++ ) { sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ; while ( ! S . empty ( ) && S . front ( ) <= i - k ) S . pop_front ( ) ; while ( ! G . empty ( ) && G . front ( ) <= i - k ) G . pop_front ( ) ; while ( ( ! S . empty ( ) ) && arr [ S . back ( ) ] >= arr [ i ] ) S . pop_back ( ) ; while ( ( ! G . empty ( ) ) && arr [ G . back ( ) ] <= arr [ i ] ) G . pop_back ( ) ; G . push_back ( i ) ; S . push_back ( i ) ; } sum += arr [ S . front ( ) ] + arr [ G . front ( ) ] ; return sum ; } int main ( ) { int arr [ ] = { 2 , 5 , -1 , 7 , -3 , -1 , -2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << SumOfKsubArray ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE #define M  4 NEW_LINE using namespace std ; void printDistance ( int mat [ N ] [ M ] ) { int ans [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) cout << ans [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int mat [ N ] [ M ] = { 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 } ; printDistance ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { bool flag ; for ( int i = 0 ; i < ( n - k + 1 ) ; i ++ ) { flag = false ; for ( int j = 0 ; j < k ; j ++ ) { if ( arr [ i + j ] < 0 ) { cout << arr [ i + j ] << " ▁ " ; flag = true ; break ; } } if ( ! flag ) cout << "0" << " ▁ " ; } } int main ( ) { int arr [ ] = { 12 , -1 , -7 , 8 , -15 , 30 , 16 , 28 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printFirstNegativeInteger ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFirstNegativeInteger ( int arr [ ] , int n , int k ) { deque < int > Di ; int i ; for ( i = 0 ; i < k ; i ++ ) if ( arr [ i ] < 0 ) Di . push_back ( i ) ; for ( ; i < n ; i ++ ) { if ( ! Di . empty ( ) ) cout << arr [ Di . front ( ) ] << " ▁ " ; else cout << "0" << " ▁ " ; while ( ( ! Di . empty ( ) ) && Di . front ( ) < ( i - k + 1 ) ) Di . pop_front ( ) ; if ( arr [ i ] < 0 ) Di . push_back ( i ) ; } if ( ! Di . empty ( ) ) cout << arr [ Di . front ( ) ] << " ▁ " ; else cout << "0" << " ▁ " ; } int main ( ) { int arr [ ] = { 12 , -1 , -7 , 8 , -15 , 30 , 16 , 28 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printFirstNegativeInteger ( arr , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printFirstNegativeInteger ( int arr [ ] , int k , int n ) { int firstNegativeIndex = 0 ; int firstNegativeElement ; for ( int i = k - 1 ; i < n ; i ++ ) { while ( ( firstNegativeIndex < i ) && ( firstNegativeIndex <= i - k arr [ firstNegativeIndex ] > 0 ) ) { firstNegativeIndex ++ ; } if ( arr [ firstNegativeIndex ] < 0 ) { firstNegativeElement = arr [ firstNegativeIndex ] ; } else { firstNegativeElement = 0 ; } cout << firstNegativeElement << " ▁ " ; } } int main ( ) { int arr [ ] = { 12 , -1 , -7 , 8 , -15 , 30 , 16 , 28 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printFirstNegativeInteger ( arr , k , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int data ; } ; bool areAnagrams ( Node * root1 , Node * root2 ) { if ( root1 == NULL && root2 == NULL ) return true ; if ( root1 == NULL root2 == NULL ) return false ; queue < Node * > q1 , q2 ; q1 . push ( root1 ) ; q2 . push ( root2 ) ; while ( 1 ) { int n1 = q1 . size ( ) , n2 = q2 . size ( ) ; if ( n1 != n2 ) return false ; if ( n1 == 0 ) break ; vector < int > curr_level1 , curr_level2 ; while ( n1 > 0 ) { Node * node1 = q1 . front ( ) ; q1 . pop ( ) ; if ( node1 -> left != NULL ) q1 . push ( node1 -> left ) ; if ( node1 -> right != NULL ) q1 . push ( node1 -> right ) ; n1 -- ; Node * node2 = q2 . front ( ) ; q2 . pop ( ) ; if ( node2 -> left != NULL ) q2 . push ( node2 -> left ) ; if ( node2 -> right != NULL ) q2 . push ( node2 -> right ) ; curr_level1 . push_back ( node1 -> data ) ; curr_level2 . push_back ( node2 -> data ) ; } sort ( curr_level1 . begin ( ) , curr_level1 . end ( ) ) ; sort ( curr_level2 . begin ( ) , curr_level2 . end ( ) ) ; if ( curr_level1 != curr_level2 ) return false ; } return true ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { struct Node * root1 = newNode ( 1 ) ; root1 -> left = newNode ( 3 ) ; root1 -> right = newNode ( 2 ) ; root1 -> right -> left = newNode ( 5 ) ; root1 -> right -> right = newNode ( 4 ) ; struct Node * root2 = newNode ( 1 ) ; root2 -> left = newNode ( 2 ) ; root2 -> right = newNode ( 3 ) ; root2 -> left -> left = newNode ( 4 ) ; root2 -> left -> right = newNode ( 5 ) ; areAnagrams ( root1 , root2 ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int search ( int arr [ ] , int strt , int end , int value ) { for ( int i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) return i ; } } Node * buildTree ( int in [ ] , int pre [ ] , int inStrt , int inEnd ) { static int preIndex = 0 ; if ( inStrt > inEnd ) return NULL ; Node * tNode = newNode ( pre [ preIndex ++ ] ) ; if ( inStrt == inEnd ) return tNode ; int inIndex = search ( in , inStrt , inEnd , tNode -> data ) ; tNode -> left = buildTree ( in , pre , inStrt , inIndex - 1 ) ; tNode -> right = buildTree ( in , pre , inIndex + 1 , inEnd ) ; return tNode ; } int checkPostorder ( Node * node , int postOrder [ ] , int index ) { if ( node == NULL ) return index ; index = checkPostorder ( node -> left , postOrder , index ) ; index = checkPostorder ( node -> right , postOrder , index ) ; if ( node -> data == postOrder [ index ] ) index ++ ; else return -1 ; return index ; } int main ( ) { int inOrder [ ] = { 4 , 2 , 5 , 1 , 3 } ; int preOrder [ ] = { 1 , 2 , 4 , 5 , 3 } ; int postOrder [ ] = { 4 , 5 , 2 , 3 , 1 } ; int len = sizeof ( inOrder ) / sizeof ( inOrder [ 0 ] ) ; Node * root = buildTree ( inOrder , preOrder , 0 , len - 1 ) ; int index = checkPostorder ( root , postOrder , 0 ) ; if ( index == len ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isChangeable ( int notes [ ] , int n ) { int fiveCount = 0 ; int tenCount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( notes [ i ] == 5 ) fiveCount ++ ; else if ( notes [ i ] == 10 ) { if ( fiveCount > 0 ) { fiveCount -- ; tenCount ++ ; } else return 0 ; } else { if ( fiveCount > 0 && tenCount > 0 ) { fiveCount -- ; tenCount -- ; } else if ( fiveCount >= 3 ) { fiveCount -= 3 ; } else return 0 ; } } return 1 ; } int main ( ) { int a [ ] = { 5 , 5 , 5 , 10 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isChangeable ( a , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE bool has [ MAX + 1 ] [ 2 ] ; bool search ( int X ) { if ( X >= 0 ) { if ( has [ X ] [ 0 ] == 1 ) return true ; else return false ; } X = abs ( X ) ; if ( has [ X ] [ 1 ] == 1 ) return true ; return false ; } void insert ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) has [ a [ i ] ] [ 0 ] = 1 ; else has [ abs ( a [ i ] ) ] [ 1 ] = 1 ; } } int main ( ) { int a [ ] = { -1 , 9 , -5 , -8 , -5 , -2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; insert ( a , n ) ; int X = -5 ; if ( search ( X ) == true ) cout << " Present " ; else cout << " Not ▁ Present " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isMinHeap ( int level [ ] , int n ) { for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; } int main ( ) { int level [ ] = { 10 , 15 , 14 , 25 , 30 } ; int n = sizeof ( level ) / sizeof ( level [ 0 ] ) ; if ( isMinHeap ( level , n ) ) cout << " True " ; else cout << " False " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDelete ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int max_freq = INT_MIN ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) max_freq = max ( max_freq , itr -> second ) ; return n - max_freq ; } int main ( ) { int arr [ ] = { 4 , 3 , 4 , 4 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minDelete ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperation ( int arr [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int max_count = 0 ; for ( auto i : hash ) if ( max_count < i . second ) max_count = i . second ; return ( n - max_count ) ; } int main ( ) { int arr [ ] = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperation ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDistance ( int arr [ ] , int n ) { unordered_map < int , int > mp ; int max_dist = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ i ] ] = i ; else max_dist = max ( max_dist , i - mp [ arr [ i ] ] ) ; } return max_dist ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 , 2 , 1 , 4 , 5 , 8 , 6 , 7 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxDistance ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkDuplicatesWithinK ( int arr [ ] , int n , int k ) { unordered_set < int > myset ; for ( int i = 0 ; i < n ; i ++ ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) return true ; myset . insert ( arr [ i ] ) ; if ( i >= k ) myset . erase ( arr [ i - k ] ) ; } return false ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkDuplicatesWithinK ( arr , n , 3 ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findDuplicates ( int arr [ ] , int len ) { bool ifPresent = false ; vector < int > al ; for ( int i = 0 ; i < len - 1 ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { auto it = std :: find ( al . begin ( ) , al . end ( ) , arr [ i ] ) ; if ( it != al . end ( ) ) { break ; } else { al . push_back ( arr [ i ] ) ; ifPresent = true ; } } } } if ( ifPresent == true ) { cout << " [ " << al [ 0 ] << " , ▁ " ; for ( int i = 1 ; i < al . size ( ) - 1 ; i ++ ) { cout << al [ i ] << " , ▁ " ; } cout << al [ al . size ( ) - 1 ] << " ] " ; } else { cout << " No ▁ duplicates ▁ present ▁ in ▁ arrays " ; } } int main ( ) { int arr [ ] = { 12 , 11 , 40 , 12 , 5 , 6 , 5 , 12 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findDuplicates ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left ; Node * right ; } ; Node * newNode ( int d ) { Node * temp = new Node ; temp -> data = d ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } bool isLeaf ( Node * root ) { if ( root == NULL ) return false ; if ( ! root -> left && ! root -> right ) return true ; return false ; } bool isSame ( Node * root1 , Node * root2 ) { stack < Node * > s1 ; stack < Node * > s2 ; s1 . push ( root1 ) ; s2 . push ( root2 ) ; while ( ! s1 . empty ( ) || ! s2 . empty ( ) ) { if ( s1 . empty ( ) || s2 . empty ( ) ) return false ; Node * temp1 = s1 . top ( ) ; s1 . pop ( ) ; while ( temp1 != NULL && ! isLeaf ( temp1 ) ) { if ( temp1 -> right ) s1 . push ( temp1 -> right ) ; if ( temp1 -> left ) s1 . push ( temp1 -> left ) ; temp1 = s1 . top ( ) ; s1 . pop ( ) ; } Node * temp2 = s2 . top ( ) ; s2 . pop ( ) ; while ( temp2 != NULL && ! isLeaf ( temp2 ) ) { if ( temp2 -> right ) s2 . push ( temp2 -> right ) ; if ( temp2 -> left ) s2 . push ( temp2 -> left ) ; temp2 = s2 . top ( ) ; s2 . pop ( ) ; } if ( ! temp1 && temp2 ) return false ; if ( temp1 && ! temp2 ) return false ; if ( temp1 && temp2 ) { return temp1 -> data == temp2 -> data ; } } return true ; } int main ( ) { Node * root1 = newNode ( 1 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 3 ) ; root1 -> left -> left = newNode ( 4 ) ; root1 -> right -> left = newNode ( 6 ) ; root1 -> right -> right = newNode ( 7 ) ; Node * root2 = newNode ( 0 ) ; root2 -> left = newNode ( 1 ) ; root2 -> right = newNode ( 5 ) ; root2 -> left -> right = newNode ( 4 ) ; root2 -> right -> left = newNode ( 6 ) ; root2 -> right -> right = newNode ( 7 ) ; if ( isSame ( root1 , root2 ) ) cout << " Same " ; else cout << " Not ▁ Same " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mostFrequent ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int max_count = 1 , res = arr [ 0 ] , curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } int main ( ) { int arr [ ] = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << mostFrequent ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallestSubsegment ( int a [ ] , int n ) { unordered_map < int , int > left ; unordered_map < int , int > count ; int mx = 0 ; int mn , strindex ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( count [ x ] == 0 ) { left [ x ] = i ; count [ x ] = 1 ; } else count [ x ] ++ ; if ( count [ x ] > mx ) { mx = count [ x ] ; mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } else if ( count [ x ] == mx && i - left [ x ] + 1 < mn ) { mn = i - left [ x ] + 1 ; strindex = left [ x ] ; } } for ( int i = strindex ; i < strindex + mn ; i ++ ) cout << a [ i ] << " ▁ " ; } int main ( ) { int A [ ] = { 1 , 2 , 2 , 2 , 1 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; smallestSubsegment ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findRepeatingNumber ( const int arr [ ] , int n ) { int sq = sqrt ( n ) ; int range = ( n / sq ) + 1 ; int count [ range ] = { 0 } ; for ( int i = 0 ; i <= n ; i ++ ) { count [ ( arr [ i ] - 1 ) / sq ] ++ ; } int selected_block = range - 1 ; for ( int i = 0 ; i < range - 1 ; i ++ ) { if ( count [ i ] > sq ) { selected_block = i ; break ; } } unordered_map < int , int > m ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( ( selected_block * sq ) < arr [ i ] ) && ( arr [ i ] <= ( ( selected_block + 1 ) * sq ) ) ) { m [ arr [ i ] ] ++ ; if ( m [ arr [ i ] ] > 1 ) return arr [ i ] ; } } return -1 ; } int main ( ) { const int arr [ ] = { 1 , 1 , 2 , 3 , 5 , 4 } ; int n = 5 ; cout << " One ▁ of ▁ the ▁ numbers ▁ repeated ▁ in " " ▁ the ▁ array ▁ is : ▁ " << findRepeatingNumber ( arr , n ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void top3Repeated ( int arr [ ] , int n ) { if ( n < 3 ) { cout << " Invalid ▁ Input " ; return ; } unordered_map < int , int > fre ; for ( int i = 0 ; i < n ; i ++ ) fre [ arr [ i ] ] ++ ; pair < int , int > x , y , z ; x . first = y . first = z . first = INT_MIN ; for ( auto curr : fre ) { if ( curr . second > x . first ) { z = y ; y = x ; x . first = curr . second ; x . second = curr . first ; } else if ( curr . second > y . first ) { z = y ; y . first = curr . second ; y . second = curr . first ; } else if ( curr . second > z . first ) { z . first = curr . second ; z . second = curr . first ; } } cout << " Three ▁ largest ▁ elements ▁ are ▁ " << x . second << " ▁ " << y . second << " ▁ " << z . second ; } int main ( ) { int arr [ ] = { 3 , 4 , 2 , 3 , 16 , 3 , 15 , 16 , 15 , 15 , 16 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; top3Repeated ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void groupElements ( int arr [ ] , int n ) { bool * visited = new bool [ n ] ; for ( int i = 0 ; i < n ; i ++ ) visited [ i ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { cout << arr [ i ] << " ▁ " ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { cout << arr [ i ] << " ▁ " ; visited [ j ] = true ; } } } } delete [ ] visited ; } int main ( ) { int arr [ ] = { 4 , 6 , 9 , 2 , 3 , 4 , 9 , 6 , 10 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; groupElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( set1 [ i ] == set2 [ j ] ) return false ; return true ; } int main ( ) { int set1 [ ] = { 12 , 34 , 11 , 9 , 3 } ; int set2 [ ] = { 7 , 2 , 1 , 5 } ; int m = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int n = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; areDisjoint ( set1 , set2 , m , n ) ? cout << " Yes " : cout << " ▁ No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) { sort ( set1 , set1 + m ) ; sort ( set2 , set2 + n ) ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( set1 [ i ] < set2 [ j ] ) i ++ ; else if ( set2 [ j ] < set1 [ i ] ) j ++ ; else return false ; } return true ; } int main ( ) { int set1 [ ] = { 12 , 34 , 11 , 9 , 3 } ; int set2 [ ] = { 7 , 2 , 1 , 5 } ; int m = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int n = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; areDisjoint ( set1 , set2 , m , n ) ? cout << " Yes " : cout << " ▁ No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areDisjoint ( int set1 [ ] , int set2 [ ] , int n1 , int n2 ) { set < int > myset ; for ( int i = 0 ; i < n1 ; i ++ ) myset . insert ( set1 [ i ] ) ; for ( int i = 0 ; i < n2 ; i ++ ) if ( myset . find ( set2 [ i ] ) != myset . end ( ) ) return false ; return true ; } int main ( ) { int set1 [ ] = { 10 , 5 , 3 , 4 , 6 } ; int set2 [ ] = { 8 , 7 , 9 , 3 } ; int n1 = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int n2 = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; if ( areDisjoint ( set1 , set2 , n1 , n2 ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int A [ ] , int B [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) { hash [ A [ i ] ] ++ ; hash [ B [ i ] ] ++ ; } int sum = 0 ; for ( auto x : hash ) if ( x . second == 1 ) sum += x . first ; return sum ; } int main ( ) { int A [ ] = { 5 , 4 , 9 , 2 , 3 } ; int B [ ] = { 2 , 8 , 7 , 6 , 3 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << findSum ( A , B , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) cout << a [ i ] << " ▁ " ; } } int main ( ) { int a [ ] = { 1 , 2 , 6 , 3 , 4 , 5 } ; int b [ ] = { 2 , 4 , 3 , 1 , 0 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 1 ] ) ; findMissing ( a , b , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areEqual ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { if ( n != m ) return false ; sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + m ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } int main ( ) { int arr1 [ ] = { 3 , 5 , 2 , 5 , 2 } ; int arr2 [ ] = { 2 , 3 , 5 , 5 , 2 } ; int n = sizeof ( arr1 ) / sizeof ( int ) ; int m = sizeof ( arr2 ) / sizeof ( int ) ; if ( areEqual ( arr1 , arr2 , n , m ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_maximum ( int a [ ] , int n , int k ) { unordered_map < int , int > b ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; int d = min ( 1 + i , n - i ) ; if ( b . find ( x ) == b . end ( ) ) b [ x ] = d ; else b [ x ] = min ( d , b [ x ] ) ; } int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int x = a [ i ] ; if ( x != k - x && b . find ( k - x ) != b . end ( ) ) ans = min ( max ( b [ x ] , b [ k - x ] ) , ans ) ; } return ans ; } int main ( ) { int a [ ] = { 3 , 5 , 8 , 6 , 7 } ; int K = 11 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << find_maximum ( a , n , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isProduct ( int arr [ ] , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; } int main ( ) { int arr [ ] = { 10 , 20 , 9 , 40 } ; int x = 400 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isProduct ( arr , n , x ) ? cout << " Yesn " : cout << " Non " ; x = 190 ; isProduct ( arr , n , x ) ? cout << " Yesn " : cout << " Non " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isProduct ( int arr [ ] , int n , int x ) { if ( n < 2 ) return false ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { if ( x == 0 ) return true ; else continue ; } if ( x % arr [ i ] == 0 ) { if ( s . find ( x / arr [ i ] ) != s . end ( ) ) return true ; s . insert ( arr [ i ] ) ; } } return false ; } int main ( ) { int arr [ ] = { 10 , 20 , 9 , 40 } ; int x = 400 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isProduct ( arr , n , x ) ? cout << " Yes STRNEWLINE " : cout << " Non " ; x = 190 ; isProduct ( arr , n , x ) ? cout << " Yes STRNEWLINE " : cout << " Non " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { sort ( arr , arr + n ) ; int * ptr = lower_bound ( arr , arr + n , low ) ; int index = ptr - arr ; int i = index , x = low ; while ( i < n && x <= high ) { if ( arr [ i ] != x ) cout << x << " ▁ " ; else i ++ ; x ++ ; } while ( x <= high ) cout << x ++ << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { bool points_of_range [ high - low + 1 ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) { if ( low <= arr [ i ] && arr [ i ] <= high ) points_of_range [ arr [ i ] - low ] = true ; } for ( int x = 0 ; x <= high - low ; x ++ ) { if ( points_of_range [ x ] == false ) cout << low + x << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissing ( int arr [ ] , int n , int low , int high ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; for ( int x = low ; x <= high ; x ++ ) if ( s . find ( x ) == s . end ( ) ) cout << x << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int low = 1 , high = 10 ; printMissing ( arr , n , low , high ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( int a [ ] , int b [ ] , int k , int n1 , int n2 ) { unordered_set < int > s ; for ( int i = 0 ; i < n2 ; i ++ ) s . insert ( b [ i ] ) ; int missing = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( s . find ( a [ i ] ) == s . end ( ) ) missing ++ ; if ( missing == k ) return a [ i ] ; } return -1 ; } int main ( ) { int a [ ] = { 0 , 2 , 4 , 6 , 8 , 10 , 12 , 14 , 15 } ; int b [ ] = { 4 , 10 , 6 , 8 , 12 } ; int n1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int n2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; int k = 3 ; cout << find ( a , b , k , n1 , n2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int key ; struct Node * left , * right ; } ; int findADepth ( Node * node ) { int d = 0 ; while ( node != NULL ) { d ++ ; node = node -> left ; } return d ; } bool isPerfectRec ( struct Node * root , int d , int level = 0 ) { if ( root == NULL ) return true ; if ( root -> left == NULL && root -> right == NULL ) return ( d == level + 1 ) ; if ( root -> left == NULL root -> right == NULL ) return false ; return isPerfectRec ( root -> left , d , level + 1 ) && isPerfectRec ( root -> right , d , level + 1 ) ; } bool isPerfect ( Node * root ) { int d = findADepth ( root ) ; return isPerfectRec ( root , d ) ; } struct Node * newNode ( int k ) { struct Node * node = new Node ; node -> key = k ; node -> right = node -> left = NULL ; return node ; } int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> left = newNode ( 40 ) ; root -> left -> right = newNode ( 50 ) ; root -> right -> left = newNode ( 60 ) ; root -> right -> right = newNode ( 70 ) ; if ( isPerfect ( root ) ) printf ( " Yes STRNEWLINE " ) ; else printf ( " No STRNEWLINE " ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findGreatest ( int arr [ ] , int n ) { int result = -1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result , arr [ i ] ) ; return result ; } int main ( ) { int arr [ ] = { 30 , 10 , 9 , 3 , 35 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findGreatest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findGreatest ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; sort ( arr , arr + n ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 0 ; j < i && arr [ j ] <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 ) { int result = arr [ i ] / arr [ j ] ; if ( result != arr [ j ] && m [ result ] > 0 ) return arr [ i ] ; else if ( result == arr [ j ] && m [ result ] > 1 ) return arr [ i ] ; } } } return -1 ; } int main ( ) { int arr [ ] = { 17 , 2 , 1 , 15 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findGreatest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int subset ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int res = 0 ; for ( auto x : mp ) res = max ( res , x . second ) ; return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minRemove ( int a [ ] , int b [ ] , int n , int m ) { unordered_map < int , int > countA , countB ; for ( int i = 0 ; i < n ; i ++ ) countA [ a [ i ] ] ++ ; for ( int i = 0 ; i < m ; i ++ ) countB [ b [ i ] ] ++ ; int res = 0 ; for ( auto x : countA ) if ( countB . find ( x . first ) != countB . end ( ) ) res += min ( x . second , countB [ x . first ] ) ; return res ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 } ; int b [ ] = { 2 , 3 , 4 , 5 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << minRemove ( a , b , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct item { string name ; int price ; } ; bool compare ( struct item a , struct item b ) { return ( a . name . compare ( b . name ) <= 0 ) ; } int binary_search ( item list2 [ ] , int low , int high , string str ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( list2 [ mid ] . name . compare ( str ) == 0 ) return list2 [ mid ] . price ; else if ( list2 [ mid ] . name . compare ( str ) < 0 ) low = mid + 1 ; else high = mid - 1 ; } return -1 ; } int countItems ( item list1 [ ] , int m , item list2 [ ] , int n ) { sort ( list2 , list2 + n , compare ) ; int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int r = binary_search ( list2 , 0 , n - 1 , list1 [ i ] . name ) ; if ( ( r != -1 ) && ( r != list1 [ i ] . price ) ) count ++ ; } return count ; } int main ( ) { item list1 [ ] = { { " apple " , 60 } , { " bread " , 20 } , { " wheat " , 50 } , { " oil " , 30 } } ; item list2 [ ] = { { " milk " , 20 } , { " bread " , 15 } , { " wheat " , 40 } , { " apple " , 60 } } ; int m = sizeof ( list1 ) / sizeof ( list1 [ 0 ] ) ; int n = sizeof ( list2 ) / sizeof ( list2 [ 0 ] ) ; cout << " Count ▁ = ▁ " << countItems ( list1 , m , list2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct item { string name ; int price ; } ; int countItems ( item list1 [ ] , int m , item list2 [ ] , int n ) { unordered_map < string , int > um ; int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) um [ list1 [ i ] . name ] = list1 [ i ] . price ; for ( int i = 0 ; i < n ; i ++ ) if ( ( um . find ( list2 [ i ] . name ) != um . end ( ) ) && ( um [ list2 [ i ] . name ] != list2 [ i ] . price ) ) count ++ ; return count ; } int main ( ) { item list1 [ ] = { { " apple " , 60 } , { " bread " , 20 } , { " wheat " , 50 } , { " oil " , 30 } } ; item list2 [ ] = { { " milk " , 20 } , { " bread " , 15 } , { " wheat " , 40 } , { " apple " , 60 } } ; int m = sizeof ( list1 ) / sizeof ( list1 [ 0 ] ) ; int n = sizeof ( list2 ) / sizeof ( list2 [ 0 ] ) ; cout << " Count ▁ = ▁ " << countItems ( list1 , m , list2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find ( vector < string > list1 , vector < string > list2 ) { vector < string > res ; int max_possible_sum = list1 . size ( ) + list2 . size ( ) - 2 ; for ( int sum = 0 ; sum <= max_possible_sum ; sum ++ ) { for ( int i = 0 ; i <= sum ; i ++ ) if ( i < list1 . size ( ) && ( sum - i ) < list2 . size ( ) && list1 [ i ] == list2 [ sum - i ] ) res . push_back ( list1 [ i ] ) ; if ( res . size ( ) > 0 ) break ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; } int main ( ) { vector < string > list1 ; list1 . push_back ( " GeeksforGeeks " ) ; list1 . push_back ( " Udemy " ) ; list1 . push_back ( " Coursera " ) ; list1 . push_back ( " edX " ) ; vector < string > list2 ; list2 . push_back ( " Codecademy " ) ; list2 . push_back ( " Khan ▁ Academy " ) ; list2 . push_back ( " GeeksforGeeks " ) ; find ( list1 , list2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find ( vector < string > list1 , vector < string > list2 ) { unordered_map < string , int > map ; for ( int i = 0 ; i < list1 . size ( ) ; i ++ ) map [ list1 [ i ] ] = i ; vector < string > res ; int minsum = INT_MAX ; for ( int j = 0 ; j < list2 . size ( ) ; j ++ ) { if ( map . count ( list2 [ j ] ) ) { int sum = j + map [ list2 [ j ] ] ; if ( sum < minsum ) { minsum = sum ; res . clear ( ) ; res . push_back ( list2 [ j ] ) ; } else if ( sum == minsum ) res . push_back ( list2 [ j ] ) ; } } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; } int main ( ) { vector < string > list1 ; list1 . push_back ( " GeeksforGeeks " ) ; list1 . push_back ( " Udemy " ) ; list1 . push_back ( " Coursera " ) ; list1 . push_back ( " edX " ) ; vector < string > list2 ; list2 . push_back ( " Codecademy " ) ; list2 . push_back ( " Khan ▁ Academy " ) ; list2 . push_back ( " GeeksforGeeks " ) ; find ( list1 , list2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( char k ) { struct Node * node = new Node ; node -> key = k ; node -> right = node -> left = NULL ; return node ; } bool isFullTree ( struct Node * root ) { if ( root == NULL ) return true ; if ( root -> left == NULL && root -> right == NULL ) return true ; if ( ( root -> left ) && ( root -> right ) ) return ( isFullTree ( root -> left ) && isFullTree ( root -> right ) ) ; return false ; } int main ( ) { struct Node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> right = newNode ( 40 ) ; root -> left -> left = newNode ( 50 ) ; root -> right -> left = newNode ( 60 ) ; root -> right -> right = newNode ( 70 ) ; root -> left -> left -> left = newNode ( 80 ) ; root -> left -> left -> right = newNode ( 90 ) ; root -> left -> right -> left = newNode ( 80 ) ; root -> left -> right -> right = newNode ( 90 ) ; root -> right -> left -> left = newNode ( 80 ) ; root -> right -> left -> right = newNode ( 90 ) ; root -> right -> right -> left = newNode ( 80 ) ; root -> right -> right -> right = newNode ( 90 ) ; if ( isFullTree ( root ) ) cout << " The ▁ Binary ▁ Tree ▁ is ▁ full STRNEWLINE " ; else cout << " The ▁ Binary ▁ Tree ▁ is ▁ not ▁ full STRNEWLINE " ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairsCount ( int arr [ ] , int n , int sum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 , -1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; cout << " Count ▁ of ▁ pairs ▁ is ▁ " << getPairsCount ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return newNode ; } bool isFullBinaryTree ( Node * root ) { if ( ! root ) return true ; queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { Node * node = q . front ( ) ; q . pop ( ) ; if ( node -> left == NULL && node -> right == NULL ) continue ; if ( node -> left == NULL node -> right == NULL ) return false ; q . push ( node -> left ) ; q . push ( node -> right ) ; } return true ; } int main ( ) { Node * root = getNode ( 1 ) ; root -> left = getNode ( 2 ) ; root -> right = getNode ( 3 ) ; root -> left -> left = getNode ( 4 ) ; root -> left -> right = getNode ( 5 ) ; if ( isFullBinaryTree ( root ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairsCount ( int arr [ ] , int n , int sum ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twice_count += m [ sum - arr [ i ] ] ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 , -1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; cout << " Count ▁ of ▁ pairs ▁ is ▁ " << getPairsCount ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int arr2 [ ] = { 2 , 3 , 5 , 8 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int x = 10 ; cout << " Count ▁ = ▁ " << countPairs ( arr1 , arr2 , m , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPresent ( int arr [ ] , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; } int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int value = x - arr1 [ i ] ; if ( isPresent ( arr2 , 0 , n - 1 , value ) ) count ++ ; } return count ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int arr2 [ ] = { 2 , 3 , 5 , 8 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int x = 10 ; cout << " Count ▁ = ▁ " << countPairs ( arr1 , arr2 , m , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; unordered_set < int > us ; for ( int i = 0 ; i < m ; i ++ ) us . insert ( arr1 [ i ] ) ; for ( int j = 0 ; j < n ; j ++ ) if ( us . find ( x - arr2 [ j ] ) != us . end ( ) ) count ++ ; return count ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int arr2 [ ] = { 2 , 3 , 5 , 8 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int x = 10 ; cout << " Count ▁ = ▁ " << countPairs ( arr1 , arr2 , m , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int arr2 [ ] = { 2 , 3 , 5 , 8 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int x = 10 ; cout << " Count ▁ = ▁ " << countPairs ( arr1 , arr2 , m , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPresent ( int arr [ ] , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; } int countQuadruples ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int arr4 [ ] , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) { int T = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; if ( isPresent ( arr4 , 0 , n , x - T ) ) count ++ ; } return count ; } int main ( ) { int arr1 [ ] = { 1 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 7 , 8 } ; int arr3 [ ] = { 1 , 4 , 6 , 10 } ; int arr4 [ ] = { 2 , 4 , 7 , 8 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int x = 30 ; cout << " Count ▁ = ▁ " << countQuadruples ( arr1 , arr2 , arr3 , arr4 , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr1 [ ] , int arr2 [ ] , int n , int value ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < n && r >= 0 ) { int sum = arr1 [ l ] + arr2 [ r ] ; if ( sum == value ) { l ++ , r -- ; count ++ ; } else if ( sum > value ) r -- ; else l ++ ; } return count ; } int countQuadruples ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int arr4 [ ] , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int p_sum = arr1 [ i ] + arr2 [ j ] ; count += countPairs ( arr3 , arr4 , n , x - p_sum ) ; } return count ; } int main ( ) { int arr1 [ ] = { 1 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 7 , 8 } ; int arr3 [ ] = { 1 , 4 , 6 , 10 } ; int arr4 [ ] = { 2 , 4 , 7 , 8 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int x = 30 ; cout << " Count ▁ = ▁ " << countQuadruples ( arr1 , arr2 , arr3 , arr4 , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countQuadruples ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int arr4 [ ] , int n , int x ) { int count = 0 ; unordered_map < int , int > um ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) um [ arr1 [ i ] + arr2 [ j ] ] ++ ; for ( int k = 0 ; k < n ; k ++ ) for ( int l = 0 ; l < n ; l ++ ) { int p_sum = arr3 [ k ] + arr4 [ l ] ; if ( um . find ( x - p_sum ) != um . end ( ) ) count += um [ x - p_sum ] ; } return count ; } int main ( ) { int arr1 [ ] = { 1 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 7 , 8 } ; int arr3 [ ] = { 1 , 4 , 6 , 10 } ; int arr4 [ ] = { 2 , 4 , 7 , 8 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int x = 30 ; cout << " Count ▁ = ▁ " << countQuadruples ( arr1 , arr2 , arr3 , arr4 , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; } int main ( ) { int arr [ ] = { 6 , 2 , 4 , 12 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int n ) { int result = 0 ; set < int > Hash ; for ( int i = 0 ; i < n ; i ++ ) Hash . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; if ( Hash . find ( product ) != Hash . end ( ) ) result ++ ; } } return result ; } int main ( ) { int arr [ ] = { 6 , 2 , 4 , 12 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) cout << arr1 [ i ] << " ▁ " << arr2 [ j ] << endl ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 , 7 , 5 , 4 } ; int arr2 [ ] = { 0 , 7 , 4 , 3 , 2 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( int ) ; int m = sizeof ( arr2 ) / sizeof ( int ) ; int x = 8 ; findPairs ( arr1 , arr2 , n , m , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int key ) { Node * node = new Node ; node -> key = key ; node -> left = node -> right = NULL ; return ( node ) ; } bool isBalancedUtil ( Node * root , int & maxh , int & minh ) { if ( root == NULL ) { maxh = minh = 0 ; return true ; } int lmxh , lmnh ; int rmxh , rmnh ; if ( isBalancedUtil ( root -> left , lmxh , lmnh ) == false ) return false ; if ( isBalancedUtil ( root -> right , rmxh , rmnh ) == false ) return false ; maxh = max ( lmxh , rmxh ) + 1 ; minh = min ( lmnh , rmnh ) + 1 ; if ( maxh <= 2 * minh ) return true ; return false ; } bool isBalanced ( Node * root ) { int maxh , minh ; return isBalancedUtil ( root , maxh , minh ) ; } int main ( ) { Node * root = newNode ( 10 ) ; root -> left = newNode ( 5 ) ; root -> right = newNode ( 100 ) ; root -> right -> left = newNode ( 50 ) ; root -> right -> right = newNode ( 150 ) ; root -> right -> left -> left = newNode ( 40 ) ; isBalanced ( root ) ? cout << " Balanced " : cout << " Not ▁ Balanced " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countFreq ( int a [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ a [ i ] ] ++ ; int cumul = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumul += hm [ a [ i ] ] ; if ( hm [ a [ i ] ] ) { cout << a [ i ] << " - > " << cumul << endl ; } hm [ a [ i ] ] = 0 ; } } int main ( ) { int a [ ] = { 1 , 3 , 2 , 4 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; countFreq ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPair ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { cout << arr [ i ] << " ▁ " << arr [ j ] << endl ; found = true ; } } } } if ( found == false ) cout << " Not ▁ exist " << endl ; } int main ( ) { int arr [ ] = { 10 , 4 , 8 , 13 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPair ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool printPairs ( int arr [ ] , int n , int k ) { bool isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << " ▁ " ; isPairFound = true ; } } } return isPairFound ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; if ( printPairs ( arr , n , k ) == false ) cout << " No ▁ such ▁ pair ▁ exists " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findDivisors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) v . push_back ( i ) ; else { v . push_back ( i ) ; v . push_back ( n / i ) ; } } } return v ; } bool printPairs ( int arr [ ] , int n , int k ) { unordered_map < int , bool > occ ; for ( int i = 0 ; i < n ; i ++ ) occ [ arr [ i ] ] = true ; bool isPairFound = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( occ [ k ] && k < arr [ i ] ) { cout << " ( " << k << " , ▁ " << arr [ i ] << " ) ▁ " ; isPairFound = true ; } if ( arr [ i ] >= k ) { vector < int > v = findDivisors ( arr [ i ] - k ) ; for ( int j = 0 ; j < v . size ( ) ; j ++ ) { if ( arr [ i ] % v [ j ] == k && arr [ i ] != v [ j ] && occ [ v [ j ] ] ) { cout << " ( " << arr [ i ] << " , ▁ " << v [ j ] << " ) ▁ " ; isPairFound = true ; } } v . clear ( ) ; } } return isPairFound ; } int main ( ) { int arr [ ] = { 3 , 1 , 2 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; if ( printPairs ( arr , n , k ) == false ) cout << " No ▁ such ▁ pair ▁ exists " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void convert ( int arr [ ] , int n ) { int temp [ n ] ; memcpy ( temp , arr , n * sizeof ( int ) ) ; sort ( temp , temp + n ) ; unordered_map < int , int > umap ; int val = 0 ; for ( int i = 0 ; i < n ; i ++ ) umap [ temp [ i ] ] = val ++ ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = umap [ arr [ i ] ] ; } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 10 , 20 , 15 , 12 , 11 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Given ▁ Array ▁ is ▁ STRNEWLINE " ; printArr ( arr , n ) ; convert ( arr , n ) ; cout << " Converted Array is " ; printArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ASCII_SIZE  256 NEW_LINE using namespace std ; char getMaxOccuringChar ( char * str ) { int count [ ASCII_SIZE ] = { 0 } ; int len = strlen ( str ) ; int max = 0 ; char result ; for ( int i = 0 ; i < len ; i ++ ) { count [ str [ i ] ] ++ ; if ( max < count [ str [ i ] ] ) { max = count [ str [ i ] ] ; result = str [ i ] ; } } return result ; } int main ( ) { char str [ ] = " sample ▁ string " ; cout << " Max ▁ occurring ▁ character ▁ is ▁ " << getMaxOccuringChar ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_CHAR  26 NEW_LINE string getKey ( string & str ) { bool visited [ MAX_CHAR ] = { false } ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) visited [ str [ j ] - ' a ' ] = true ; string key = " " ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) if ( visited [ j ] ) key = key + ( char ) ( ' a ' + j ) ; return key ; } void wordsWithSameCharSet ( string words [ ] , int n ) { unordered_map < string , vector < int > > Hash ; for ( int i = 0 ; i < n ; i ++ ) { string key = getKey ( words [ i ] ) ; Hash [ key ] . push_back ( i ) ; } for ( auto it = Hash . begin ( ) ; it != Hash . end ( ) ; it ++ ) { for ( auto v = ( * it ) . second . begin ( ) ; v != ( * it ) . second . end ( ) ; v ++ ) cout << words [ * v ] << " , ▁ " ; cout << endl ; } } int main ( ) { string words [ ] = { " may " , " student " , " students " , " dog " , " studentssess " , " god " , " cat " , " act " , " tab " , " bat " , " flow " , " wolf " , " lambs " , " amy " , " yam " , " balms " , " looped " , " poodle " } ; int n = sizeof ( words ) / sizeof ( words [ 0 ] ) ; wordsWithSameCharSet ( words , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string secMostRepeated ( vector < string > seq ) { unordered_map < string , int > occ ; for ( int i = 0 ; i < seq . size ( ) ; i ++ ) occ [ seq [ i ] ] ++ ; int first_max = INT_MIN , sec_max = INT_MIN ; for ( auto it = occ . begin ( ) ; it != occ . end ( ) ; it ++ ) { if ( it -> second > first_max ) { sec_max = first_max ; first_max = it -> second ; } else if ( it -> second > sec_max && it -> second != first_max ) sec_max = it -> second ; } for ( auto it = occ . begin ( ) ; it != occ . end ( ) ; it ++ ) if ( it -> second == sec_max ) return it -> first ; } int main ( ) { vector < string > seq = { " ccc " , " aaa " , " ccc " , " ddd " , " aaa " , " aaa " } ; cout << secMostRepeated ( seq ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } bool checkDupUtil ( Node * root , unordered_set < int > & s ) { if ( root == NULL ) return false ; if ( s . find ( root -> data ) != s . end ( ) ) return true ; s . insert ( root -> data ) ; return checkDupUtil ( root -> left , s ) || checkDupUtil ( root -> right , s ) ; } bool checkDup ( struct Node * root ) { unordered_set < int > s ; return checkDupUtil ( root , s ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; if ( checkDup ( root ) ) printf ( " Yes " ) ; else printf ( " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct et { char value ; et * left , * right ; } ; bool isOperator ( char c ) { if ( c == ' + ' c == ' - ' c == ' * ' c == ' / ' c == ' ^ ' ) return true ; return false ; } void inorder ( et * t ) { if ( t ) { inorder ( t -> left ) ; printf ( " % c ▁ " , t -> value ) ; inorder ( t -> right ) ; } } et * newNode ( char v ) { et * temp = new et ; temp -> left = temp -> right = NULL ; temp -> value = v ; return temp ; } ; et * constructTree ( char postfix [ ] ) { stack < et * > st ; et * t , * t1 , * t2 ; for ( int i = 0 ; i < strlen ( postfix ) ; i ++ ) { if ( ! isOperator ( postfix [ i ] ) ) { t = newNode ( postfix [ i ] ) ; st . push ( t ) ; } else { t = newNode ( postfix [ i ] ) ; t1 = st . top ( ) ; st . pop ( ) ; t2 = st . top ( ) ; st . pop ( ) ; t -> right = t1 ; t -> left = t2 ; st . push ( t ) ; } } t = st . top ( ) ; st . pop ( ) ; return t ; } int main ( ) { char postfix [ ] = " ab + ef * g * - " ; et * r = constructTree ( postfix ) ; printf ( " infix ▁ expression ▁ is ▁ STRNEWLINE " ) ; inorder ( r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestKFreq ( int a [ ] , int n , int k ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ a [ i ] ] ++ ; int res = INT_MAX ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; ++ it ) if ( it -> second == k ) res = min ( res , it -> first ) ; return ( res != INT_MAX ) ? res : -1 ; } int main ( ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = sizeof ( arr ) / ( sizeof ( arr [ 0 ] ) ) ; cout << smallestKFreq ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) { int min = -1 ; set < int > myset ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( myset . find ( arr [ i ] ) != myset . end ( ) ) min = i ; else myset . insert ( arr [ i ] ) ; } if ( min != -1 ) cout << " The ▁ first ▁ repeating ▁ element ▁ is ▁ " << arr [ min ] ; else cout << " There ▁ are ▁ no ▁ repeating ▁ elements " ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printFirstRepeating ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFirstRepeating ( int arr [ ] , int n ) { int k = 0 ; int max = n ; for ( int i = 0 ; i < n ; i ++ ) if ( max < arr [ i ] ) max = arr [ i ] ; int a [ max + 1 ] = { } ; int b [ max + 1 ] = { } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ arr [ i ] ] ) { b [ arr [ i ] ] = 1 ; k = 1 ; continue ; } else a [ arr [ i ] ] = i ; } if ( k == 0 ) cout << " No ▁ repeating ▁ element ▁ found " << endl ; else { int min = max + 1 ; for ( int i = 0 ; i < max + 1 ; i ++ ) if ( a [ i ] && min > a [ i ] && b [ i ] ) min = a [ i ] ; cout << arr [ min ] ; } cout << endl ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 4 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printFirstRepeating ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) sum = sum + arr [ i ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const char MARKER = ' $ ' ; struct Node { char key ; Node * left , * right ; } ; Node * newNode ( char key ) { Node * node = new Node ; node -> key = key ; node -> left = node -> right = NULL ; return node ; } unordered_set < string > subtrees ; string dupSubUtil ( Node * root ) { string s = " " ; if ( root == NULL ) return s + MARKER ; string lStr = dupSubUtil ( root -> left ) ; if ( lStr . compare ( s ) == 0 ) return s ; string rStr = dupSubUtil ( root -> right ) ; if ( rStr . compare ( s ) == 0 ) return s ; s = s + root -> key + lStr + rStr ; if ( s . length ( ) > 3 && subtrees . find ( s ) != subtrees . end ( ) ) return " " ; subtrees . insert ( s ) ; return s ; } int main ( ) { Node * root = newNode ( ' A ' ) ; root -> left = newNode ( ' B ' ) ; root -> right = newNode ( ' C ' ) ; root -> left -> left = newNode ( ' D ' ) ; root -> left -> right = newNode ( ' E ' ) ; root -> right -> right = newNode ( ' B ' ) ; root -> right -> right -> right = newNode ( ' E ' ) ; root -> right -> right -> left = newNode ( ' D ' ) ; string str = dupSubUtil ( root ) ; ( str . compare ( " " ) == 0 ) ? cout << " ▁ Yes ▁ " : cout << " ▁ No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return -1 ; } int main ( ) { int arr [ ] = { 9 , 4 , 9 , 6 , 7 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << firstNonRepeating ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstNonRepeating ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( mp [ arr [ i ] ] == 1 ) return arr [ i ] ; return -1 ; } int main ( ) { int arr [ ] = { 9 , 4 , 9 , 6 , 7 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << firstNonRepeating ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void firstNonRepeating ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; for ( auto x : mp ) if ( x . second == 1 ) cout << x . first << " ▁ " ; } int main ( ) { int arr [ ] = { 9 , 4 , 9 , 6 , 7 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; firstNonRepeating ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printKDistinct ( int arr [ ] , int n , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ j ] == arr [ i ] ) break ; if ( j == n ) dist_count ++ ; if ( dist_count == k ) return arr [ i ] ; } return -1 ; } int main ( ) { int ar [ ] = { 1 , 2 , 1 , 3 , 4 , 2 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; int k = 2 ; cout << printKDistinct ( ar , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPairs ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] ) == abs ( arr [ j ] ) ) v . push_back ( abs ( arr [ i ] ) ) ; if ( v . size ( ) == 0 ) return ; sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << - v [ i ] << " ▁ " << v [ i ] ; } int main ( ) { int arr [ ] = { 4 , 8 , 9 , -4 , 1 , -1 , -8 , -9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canPairs ( int arr [ ] , int n , int k ) { if ( n & 1 ) return false ; unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ ( ( arr [ i ] % k ) + k ) % k ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { int rem = ( ( arr [ i ] % k ) + k ) % k ; if ( 2 * rem == k ) { if ( freq [ rem ] % 2 != 0 ) return false ; } else if ( rem == 0 ) { if ( freq [ rem ] & 1 ) return false ; } else if ( freq [ rem ] != freq [ k - rem ] ) return false ; } return true ; } int main ( ) { int arr [ ] = { 92 , 75 , 65 , 48 , 45 , 35 } ; int k = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; canPairs ( arr , n , k ) ? cout << " True " : cout << " False " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void subarrayDivisibleByK ( int arr [ ] , int n , int k ) { map < int , int > mp ; int s = 0 , e = 0 , maxs = 0 , maxe = 0 ; mp [ arr [ 0 ] % k ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] -- ; s ++ ; } mp [ mod ] ++ ; e ++ ; if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e ; maxs = s ; } } cout << " The ▁ maximum ▁ size ▁ is ▁ " << maxe - maxs + 1 << " ▁ and ▁ " " the ▁ subarray ▁ is ▁ as ▁ follows STRNEWLINE " ; for ( int i = maxs ; i <= maxe ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int k = 3 ; int arr [ ] = { 5 , 10 , 15 , 20 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; subarrayDivisibleByK ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { unordered_set < int > s ; for ( int i = 0 ; i < n1 ; i ++ ) s . insert ( a1 [ i ] ) ; for ( int i = 0 ; i < n2 ; i ++ ) { for ( int j = 0 ; j < n3 ; j ++ ) { if ( s . find ( sum - a2 [ i ] - a3 [ j ] ) != s . end ( ) ) return true ; } } return false ; } int main ( ) { int a1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int a2 [ ] = { 2 , 3 , 6 , 1 , 2 } ; int a3 [ ] = { 3 , 2 , 4 , 5 , 6 } ; int sum = 9 ; int n1 = sizeof ( a1 ) / sizeof ( a1 [ 0 ] ) ; int n2 = sizeof ( a2 ) / sizeof ( a2 [ 0 ] ) ; int n3 = sizeof ( a3 ) / sizeof ( a3 [ 0 ] ) ; findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPairs ( int arr [ ] , int n ) { map < int , pair < int , int > > Hash ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int sum = arr [ i ] + arr [ j ] ; if ( Hash . find ( sum ) == Hash . end ( ) ) Hash [ sum ] = make_pair ( i , j ) ; else { pair < int , int > pp = Hash [ sum ] ; cout << " ( " << arr [ pp . first ] << " , ▁ " << arr [ pp . second ] << " ) ▁ and ▁ ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) n " ; return true ; } } } cout << " No ▁ pairs ▁ found " ; return false ; } int main ( ) { int arr [ ] = { 3 , 4 , 7 , 1 , 2 , 9 , 8 } ; int n = sizeof arr / sizeof arr [ 0 ] ; findPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; int areMirror ( Node * a , Node * b ) { if ( a == NULL && b == NULL ) return true ; if ( a == NULL b == NULL ) return false ; return a -> data == b -> data && areMirror ( a -> left , b -> right ) && areMirror ( a -> right , b -> left ) ; } Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( ) { Node * a = newNode ( 1 ) ; Node * b = newNode ( 1 ) ; a -> left = newNode ( 2 ) ; a -> right = newNode ( 3 ) ; a -> left -> left = newNode ( 4 ) ; a -> left -> right = newNode ( 5 ) ; b -> left = newNode ( 3 ) ; b -> right = newNode ( 2 ) ; b -> right -> left = newNode ( 5 ) ; b -> right -> right = newNode ( 4 ) ; areMirror ( a , b ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLen ( int arr [ ] , int n ) { unordered_map < int , int > presum ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] == 0 && max_len == 0 ) max_len = 1 ; if ( sum == 0 ) max_len = i + 1 ; if ( presum . find ( sum ) != presum . end ( ) ) { max_len = max ( max_len , i - presum [ sum ] ) ; } else { presum [ sum ] = i ; } } return max_len ; } int main ( ) { int arr [ ] = { 15 , -2 , 2 , -8 , 1 , 7 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Length ▁ of ▁ the ▁ longest ▁ 0 ▁ sum ▁ subarray ▁ is ▁ " << maxLen ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubsequence ( int a [ ] , int n ) { unordered_map < int , int > mp ; int dp [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( a [ i ] - 1 ) != mp . end ( ) ) { int lastIndex = mp [ a [ i ] - 1 ] - 1 ; dp [ i ] = 1 + dp [ lastIndex ] ; } else dp [ i ] = 1 ; mp [ a [ i ] ] = i + 1 ; maximum = max ( maximum , dp [ i ] ) ; } return maximum ; } int main ( ) { int a [ ] = { 3 , 10 , 3 , 11 , 4 , 5 , 6 , 7 , 8 , 12 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << longestSubsequence ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longLenSub ( int arr [ ] , int n ) { unordered_map < int , int > um ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( um . find ( arr [ i ] - 1 ) != um . end ( ) && len < um [ arr [ i ] - 1 ] ) len = um [ arr [ i ] - 1 ] ; if ( um . find ( arr [ i ] + 1 ) != um . end ( ) && len < um [ arr [ i ] + 1 ] ) len = um [ arr [ i ] + 1 ] ; um [ arr [ i ] ] = len + 1 ; if ( longLen < um [ arr [ i ] ] ) longLen = um [ arr [ i ] ] ; } return longLen ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Longest ▁ length ▁ subsequence ▁ = ▁ " << longLenSub ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLongestConseqSubseq ( int arr [ ] , int n ) { int ans = 0 , count = 0 ; sort ( arr , arr + n ) ; vector < int > v ; v . push_back ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) v . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( i > 0 && v [ i ] == v [ i - 1 ] + 1 ) count ++ ; else count = 1 ; ans = max ( ans , count ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << " Length ▁ of ▁ the ▁ Longest ▁ contiguous ▁ subsequence ▁ " " is ▁ " << findLongestConseqSubseq ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLongestConseqSubseq ( int arr [ ] , int n ) { unordered_set < int > S ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) S . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . find ( arr [ i ] - 1 ) == S . end ( ) ) { int j = arr [ i ] ; while ( S . find ( j ) != S . end ( ) ) j ++ ; ans = max ( ans , j - arr [ i ] ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 9 , 3 , 10 , 4 , 20 , 2 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << " Length ▁ of ▁ the ▁ Longest ▁ contiguous ▁ subsequence ▁ " " is ▁ " << findLongestConseqSubseq ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLongestConseqSubseq ( int arr [ ] , int N ) { priority_queue < int , vector < int > , greater < int > > pq ; for ( int i = 0 ; i < N ; i ++ ) { pq . push ( arr [ i ] ) ; } int prev = pq . top ( ) ; pq . pop ( ) ; int c = 1 ; int max = 1 ; while ( ! pq . empty ( ) ) { if ( pq . top ( ) - prev > 1 ) { c = 1 ; prev = pq . top ( ) ; pq . pop ( ) ; } else if ( pq . top ( ) - prev == 0 ) { prev = pq . top ( ) ; pq . pop ( ) ; } else { c ++ ; prev = pq . top ( ) ; pq . pop ( ) ; } if ( max < c ) { max = c ; } } return max ; } int main ( ) { int arr [ ] = { 1 , 9 , 3 , 10 , 4 , 20 , 2 } ; int n = 7 ; cout << " Length ▁ of ▁ the ▁ Longest ▁ consecutive ▁ subsequence ▁ " " is ▁ " << findLongestConseqSubseq ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLIS ( int A [ ] , int n ) { unordered_map < int , int > hash ; int LIS_size = 1 ; int LIS_index = 0 ; hash [ A [ 0 ] ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { hash [ A [ i ] ] = hash [ A [ i ] - 1 ] + 1 ; if ( LIS_size < hash [ A [ i ] ] ) { LIS_size = hash [ A [ i ] ] ; LIS_index = A [ i ] ; } } cout << " LIS _ size ▁ = ▁ " << LIS_size << " STRNEWLINE " ; cout << " LIS ▁ : ▁ " ; int start = LIS_index - LIS_size + 1 ; while ( start <= LIS_index ) { cout << start << " ▁ " ; start ++ ; } } int main ( ) { int A [ ] = { 2 , 5 , 3 , 7 , 4 , 8 , 5 , 13 , 6 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findLIS ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubsets ( int arr [ ] , int n ) { unordered_set < int > us ; int even_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) us . insert ( arr [ i ] ) ; unordered_set < int > :: iterator itr ; even_count = us . size ( ) ; return ( pow ( 2 , even_count ) - 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 9 , 2 , 6 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Number ▁ of ▁ subsets ▁ = ▁ " << countSubsets ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWindowDistinct ( int win [ ] , int k ) { int dist_count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( win [ i ] == win [ j ] ) break ; if ( j == i ) dist_count ++ ; } return dist_count ; } void countDistinct ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i <= n - k ; i ++ ) cout << countWindowDistinct ( arr + i , k ) << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 3 , 4 , 2 , 3 } , k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countDistinct ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * temp = new Node ( ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } string areMirrors ( Node * root1 , Node * root2 ) { stack < Node * > st1 , st2 ; while ( 1 ) { while ( root1 && root2 ) { if ( root1 -> data != root2 -> data ) return " No " ; st1 . push ( root1 ) ; st2 . push ( root2 ) ; root1 = root1 -> left ; root2 = root2 -> right ; } if ( ! ( root1 == NULL && root2 == NULL ) ) return " No " ; if ( ! st1 . empty ( ) && ! st2 . empty ( ) ) { root1 = st1 . top ( ) ; root2 = st2 . top ( ) ; st1 . pop ( ) ; st2 . pop ( ) ; root1 = root1 -> right ; root2 = root2 -> left ; } else break ; } return " Yes " ; } int main ( ) { Node * root1 = newNode ( 1 ) ; root1 -> left = newNode ( 3 ) ; root1 -> right = newNode ( 2 ) ; root1 -> right -> left = newNode ( 5 ) ; root1 -> right -> right = newNode ( 4 ) ; Node * root2 = newNode ( 1 ) ; root2 -> left = newNode ( 2 ) ; root2 -> right = newNode ( 3 ) ; root2 -> left -> left = newNode ( 4 ) ; root2 -> left -> right = newNode ( 5 ) ; cout << areMirrors ( root1 , root2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int returnMaxSum ( int A [ ] , int B [ ] , int n ) { unordered_set < int > mp ; int result = 0 ; int curr_sum = 0 , curr_begin = 0 ; for ( int i = 0 ; i < n ; ++ i ) { while ( mp . find ( A [ i ] ) != mp . end ( ) ) { mp . erase ( A [ curr_begin ] ) ; curr_sum -= B [ curr_begin ] ; curr_begin ++ ; } mp . insert ( A [ i ] ) ; curr_sum += B [ i ] ; result = max ( result , curr_sum ) ; } return result ; } int main ( ) { int A [ ] = { 0 , 1 , 2 , 3 , 0 , 1 , 4 } ; int B [ ] = { 9 , 8 , 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << returnMaxSum ( A , B , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class myStructure { vector < int > arr ; map < int , int > Map ; public : void add ( int x ) { if ( Map . find ( x ) != Map . end ( ) ) return ; int index = arr . size ( ) ; arr . push_back ( x ) ; Map . insert ( std :: pair < int , int > ( x , index ) ) ; } void remove ( int x ) { if ( Map . find ( x ) == Map . end ( ) ) return ; int index = Map . at ( x ) ; Map . erase ( x ) ; int last = arr . size ( ) - 1 ; swap ( arr [ index ] , arr [ last ] ) ; arr . pop_back ( ) ; Map . at ( arr [ index ] ) = index ; } int getRandom ( ) { srand ( time ( NULL ) ) ; int random_index = rand ( ) % arr . size ( ) ; return arr . at ( random_index ) ; } int search ( int x ) { if ( Map . find ( x ) != Map . end ( ) ) return Map . at ( x ) ; return -1 ; } } ; int main ( ) { myStructure ds ; ds . add ( 10 ) ; ds . add ( 20 ) ; ds . add ( 30 ) ; ds . add ( 40 ) ; cout << ds . search ( 30 ) << endl ; ds . remove ( 20 ) ; ds . add ( 50 ) ; cout << ds . search ( 50 ) << endl ; cout << ds . getRandom ( ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { int max = * max_element ( arr , arr + n ) ; int min = * min_element ( arr , arr + n ) ; int m = max - min + 1 ; if ( m > n ) return false ; bool visited [ m ] ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < n ; i ++ ) visited [ arr [ i ] - min ] = true ; for ( int i = 0 ; i < m ; i ++ ) if ( visited [ i ] == false ) return false ; return true ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areElementsContiguous ( int arr [ ] , int n ) { unordered_set < int > us ; for ( int i = 0 ; i < n ; i ++ ) us . insert ( arr [ i ] ) ; int count = 1 ; int curr_ele = arr [ 0 ] - 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele -- ; } curr_ele = arr [ 0 ] + 1 ; while ( us . find ( curr_ele ) != us . end ( ) ) { count ++ ; curr_ele ++ ; } return ( count == ( int ) ( us . size ( ) ) ) ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areElementsContiguous ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void subArraySum ( int arr [ ] , int n , int sum ) { unordered_map < int , int > map ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum = curr_sum + arr [ i ] ; if ( curr_sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << 0 << " ▁ to ▁ " << i << endl ; return ; } if ( map . find ( curr_sum - sum ) != map . end ( ) ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << map [ curr_sum - sum ] + 1 << " ▁ to ▁ " << i << endl ; return ; } map [ curr_sum ] = i ; } cout << " No ▁ subarray ▁ with ▁ given ▁ sum ▁ exists " ; } int main ( ) { int arr [ ] = { 10 , 2 , -2 , -20 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = -10 ; subArraySum ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int identicalTrees ( node * a , node * b ) { if ( a == NULL && b == NULL ) return 1 ; if ( a != NULL && b != NULL ) { return ( a -> data == b -> data && identicalTrees ( a -> left , b -> left ) && identicalTrees ( a -> right , b -> right ) ) ; } return 0 ; } int main ( ) { node * root1 = newNode ( 1 ) ; node * root2 = newNode ( 1 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 3 ) ; root1 -> left -> left = newNode ( 4 ) ; root1 -> left -> right = newNode ( 5 ) ; root2 -> left = newNode ( 2 ) ; root2 -> right = newNode ( 3 ) ; root2 -> left -> left = newNode ( 4 ) ; root2 -> left -> right = newNode ( 5 ) ; if ( identicalTrees ( root1 , root2 ) ) cout << " Both ▁ tree ▁ are ▁ identical . " ; else cout << " Trees ▁ are ▁ not ▁ identical . " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minInsertion ( string str ) { int n = str . length ( ) ; int res = 0 ; int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( count [ i ] % 2 == 1 ) res ++ ; return ( res == 0 ) ? 0 : res - 1 ; } int main ( ) { string str = " geeksforgeeks " ; cout << minInsertion ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxdiff ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( freq [ arr [ i ] ] > freq [ arr [ j ] ] && arr [ i ] > arr [ j ] ) ans = max ( ans , freq [ arr [ i ] ] - freq [ arr [ j ] ] ) ; else if ( freq [ arr [ i ] ] < freq [ arr [ j ] ] && arr [ i ] < arr [ j ] ) ans = max ( ans , freq [ arr [ j ] ] - freq [ arr [ i ] ] ) ; } } return ans ; } int main ( ) { int arr [ ] = { 3 , 1 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxdiff ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxdiff ( int arr [ ] , int n ) { unordered_map < int , int > freq ; int dist [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . find ( arr [ i ] ) == freq . end ( ) ) dist [ j ++ ] = arr [ i ] ; freq [ arr [ i ] ] ++ ; } sort ( dist , dist + j ) ; int min_freq = n + 1 ; int ans = 0 ; for ( int i = 0 ; i < j ; i ++ ) { int cur_freq = freq [ dist [ i ] ] ; ans = max ( ans , cur_freq - min_freq ) ; min_freq = min ( min_freq , cur_freq ) ; } return ans ; } int main ( ) { int arr [ ] = { 3 , 1 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxdiff ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = max ( max_count , count ) ; min_count = min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 4 , 1 , 1 , 7 , 7 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findDiff ( arr , n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDiff ( int arr [ ] , int n ) { unordered_map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ arr [ i ] ] ++ ; int max_count = 0 , min_count = n ; for ( auto x : hm ) { max_count = max ( max_count , x . second ) ; min_count = min ( min_count , x . second ) ; } return ( max_count - min_count ) ; } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 4 , 1 , 1 , 7 , 7 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findDiff ( arr , n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; bool areIdentical ( Node * root1 , Node * root2 ) { if ( root1 == NULL && root2 == NULL ) return true ; if ( root1 == NULL ) return false ; if ( root2 == NULL ) return false ; queue < Node * > q1 , q2 ; q1 . push ( root1 ) ; q2 . push ( root2 ) ; while ( ! q1 . empty ( ) && ! q2 . empty ( ) ) { Node * n1 = q1 . front ( ) ; Node * n2 = q2 . front ( ) ; if ( n1 -> data != n2 -> data ) return false ; q1 . pop ( ) , q2 . pop ( ) ; if ( n1 -> left && n2 -> left ) { q1 . push ( n1 -> left ) ; q2 . push ( n2 -> left ) ; } else if ( n1 -> left n2 -> left ) return false ; if ( n1 -> right && n2 -> right ) { q1 . push ( n1 -> right ) ; q2 . push ( n2 -> right ) ; } else if ( n1 -> right n2 -> right ) return false ; } return true ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root1 = newNode ( 1 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 3 ) ; root1 -> left -> left = newNode ( 4 ) ; root1 -> left -> right = newNode ( 5 ) ; Node * root2 = newNode ( 1 ) ; root2 -> left = newNode ( 2 ) ; root2 -> right = newNode ( 3 ) ; root2 -> left -> left = newNode ( 4 ) ; root2 -> left -> right = newNode ( 5 ) ; areIdentical ( root1 , root2 ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDiff ( int arr [ ] , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { bool isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return abs ( SubsetSum_1 - SubsetSum_2 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , -3 , 3 , -2 , -2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ Difference ▁ = ▁ " << maxDiff ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDiff ( int arr [ ] , int n ) { int result = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += abs ( arr [ n - 1 ] ) ; return result ; } int main ( ) { int arr [ ] = { 4 , 2 , -3 , 3 , -2 , -2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ Difference ▁ = ▁ " << maxDiff ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDiff ( int arr [ ] , int n ) { unordered_map < int , int > hashPositive ; unordered_map < int , int > hashNegative ; int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] > 0 ) hashPositive [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] > 0 && hashPositive [ arr [ i ] ] == 1 ) SubsetSum_1 += arr [ i ] ; for ( int i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] < 0 ) hashNegative [ abs ( arr [ i ] ) ] ++ ; for ( int i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] < 0 && hashNegative [ abs ( arr [ i ] ) ] == 1 ) SubsetSum_2 += arr [ i ] ; return abs ( SubsetSum_1 - SubsetSum_2 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , -3 , 3 , -2 , -2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ Difference ▁ = ▁ " << maxDiff ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; for ( int i = 0 ; i < n ; i ++ ) { unordered_set < int > s ; int j ; for ( j = i ; j < n ; j ++ ) { s . insert ( arr [ j ] ) ; if ( s . size ( ) == k ) { if ( ( j - i ) < ( r - l ) ) { r = j ; l = i ; } break ; } } if ( j == n ) break ; } if ( l == 0 && r == n ) cout << " Invalid ▁ k " ; else cout << l << " ▁ " << r ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; minRange ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minRange ( int arr [ ] , int n , int k ) { int l = 0 , r = n ; int j = -1 ; map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n ) { j ++ ; if ( hm . size ( ) < k ) hm [ arr [ j ] ] ++ ; if ( hm . size ( ) == k && ( ( r - l ) >= ( j - i ) ) ) { l = i ; r = j ; break ; } } if ( hm . size ( ) < k ) break ; while ( hm . size ( ) == k ) { if ( hm [ arr [ i ] ] == 1 ) hm . erase ( arr [ i ] ) ; else hm [ arr [ i ] ] -- ; i ++ ; if ( hm . size ( ) == k && ( r - l ) >= ( j - i ) ) { l = i ; r = j ; } } if ( hm [ arr [ i ] ] == 1 ) hm . erase ( arr [ i ] ) ; else hm [ arr [ i ] ] -- ; } if ( l == 0 && r == n ) cout << " Invalid ▁ k " << endl ; else cout << l << " ▁ " << r << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 2 , 3 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; minRange ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int a [ ] , int n ) { unordered_map < int , int > cnt ; int ans = 0 , pre_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( i * a [ i ] ) - pre_sum ; pre_sum += a [ i ] ; if ( cnt [ a [ i ] - 1 ] ) ans -= cnt [ a [ i ] - 1 ] ; if ( cnt [ a [ i ] + 1 ] ) ans += cnt [ a [ i ] + 1 ] ; cnt [ a [ i ] ] ++ ; } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 1 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << sum ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int a [ ] , int n ) { sort ( a , a + n ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << calculate ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int a [ ] , int n ) { int * maximum = max_element ( a , a + n ) ; int frequency [ * maximum + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } int answer = 0 ; for ( int i = 0 ; i < ( * maximum ) + 1 ; i ++ ) { answer = answer + frequency [ i ] * ( frequency [ i ] - 1 ) ; } return answer / 2 ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << ( calculate ( a , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubarrWithEqualZeroAndOne ( int arr [ ] , int n ) { unordered_map < int , int > um ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += ( arr [ i ] == 0 ) ? -1 : arr [ i ] ; um [ curr_sum ] ++ ; } int count = 0 ; for ( auto itr = um . begin ( ) ; itr != um . end ( ) ; itr ++ ) { if ( itr -> second > 1 ) count += ( ( itr -> second * ( itr -> second - 1 ) ) / 2 ) ; } if ( um . find ( 0 ) != um . end ( ) ) count += um [ 0 ] ; return count ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ = ▁ " << countSubarrWithEqualZeroAndOne ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lenOfLongSubarr ( int arr [ ] , int n ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] == 0 ? -1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - 1 ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Length ▁ = ▁ " << lenOfLongSubarr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printAllAPTriplets ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cout << arr [ i ] - diff << " ▁ " << arr [ i ] << " ▁ " << arr [ j ] << endl ; } s . insert ( arr [ i ] ) ; } } int main ( ) { int arr [ ] = { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAllAPTriplets ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newnode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } bool existPathUtil ( struct Node * root , int arr [ ] , int n , int index ) { if ( root == NULL or index == n ) return false ; if ( root -> left == NULL && root -> right == NULL ) { if ( ( root -> data == arr [ index ] ) && ( index == n - 1 ) ) return true ; return false ; } return ( ( index < n ) && ( root -> data == arr [ index ] ) && ( existPathUtil ( root -> left , arr , n , index + 1 ) || existPathUtil ( root -> right , arr , n , index + 1 ) ) ) ; } bool existPath ( struct Node * root , int arr [ ] , int n , int index ) { if ( ! root ) return ( n == 0 ) ; return existPathUtil ( root , arr , n , 0 ) ; } int main ( ) { int arr [ ] = { 5 , 8 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; struct Node * root = newnode ( 5 ) ; root -> left = newnode ( 3 ) ; root -> right = newnode ( 8 ) ; root -> left -> left = newnode ( 2 ) ; root -> left -> right = newnode ( 4 ) ; root -> left -> left -> left = newnode ( 1 ) ; root -> right -> left = newnode ( 6 ) ; root -> right -> left -> right = newnode ( 7 ) ; existPath ( root , arr , n , 0 ) ? cout << " Path ▁ Exists " : cout << " Path ▁ does ▁ not ▁ Exist " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int arr [ ] , int n , int m ) { unordered_map < int , int > occ ; for ( int i = 0 ; i < n ; i ++ ) occ [ arr [ i ] ] = i ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ i ] * arr [ j ] <= m ) && ( arr [ i ] * arr [ j ] != 0 ) && ( m % ( arr [ i ] * arr [ j ] ) == 0 ) ) { int check = m / ( arr [ i ] * arr [ j ] ) ; auto it = occ . find ( check ) ; if ( check != arr [ i ] && check != arr [ j ] && it != occ . end ( ) && it -> second > i && it -> second > j ) count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 24 ; cout << countTriplets ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int ans = 0 ; for ( auto it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) { int count = it -> second ; ans += ( count * ( count - 1 ) ) / 2 ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define p  101 NEW_LINE #define MOD  1000000007 NEW_LINE struct Query { int L , R ; } ; bool isPalindrome ( string str , int L , int R ) { while ( R > L ) if ( str [ L ++ ] != str [ R -- ] ) return ( false ) ; return ( true ) ; } unsigned long long int modPow ( unsigned long long int base , unsigned long long int exponent ) { if ( exponent == 0 ) return 1 ; if ( exponent == 1 ) return base ; unsigned long long int temp = modPow ( base , exponent / 2 ) ; if ( exponent % 2 == 0 ) return ( temp % MOD * temp % MOD ) % MOD ; else return ( ( ( temp % MOD * temp % MOD ) % MOD ) * base % MOD ) % MOD ; } unsigned long long int findMMI ( unsigned long long int n ) { return modPow ( n , MOD - 2 ) ; } void computePrefixHash ( string str , int n , unsigned long long int prefix [ ] , unsigned long long int power [ ] ) { prefix [ 0 ] = 0 ; prefix [ 1 ] = str [ 0 ] ; for ( int i = 2 ; i <= n ; i ++ ) prefix [ i ] = ( prefix [ i - 1 ] % MOD + ( str [ i - 1 ] % MOD * power [ i - 1 ] % MOD ) % MOD ) % MOD ; return ; } void computeSuffixHash ( string str , int n , unsigned long long int suffix [ ] , unsigned long long int power [ ] ) { suffix [ 0 ] = 0 ; suffix [ 1 ] = str [ n - 1 ] ; for ( int i = n - 2 , j = 2 ; i >= 0 && j <= n ; i -- , j ++ ) suffix [ j ] = ( suffix [ j - 1 ] % MOD + ( str [ i ] % MOD * power [ j - 1 ] % MOD ) % MOD ) % MOD ; return ; } void queryResults ( string str , Query q [ ] , int m , int n , unsigned long long int prefix [ ] , unsigned long long int suffix [ ] , unsigned long long int power [ ] ) { for ( int i = 0 ; i <= m - 1 ; i ++ ) { int L = q [ i ] . L ; int R = q [ i ] . R ; unsigned long long hash_LR = ( ( prefix [ R + 1 ] - prefix [ L ] + MOD ) % MOD * findMMI ( power [ L ] ) % MOD ) % MOD ; unsigned long long reverse_hash_LR = ( ( suffix [ n - L ] - suffix [ n - R - 1 ] + MOD ) % MOD * findMMI ( power [ n - R - 1 ] ) % MOD ) % MOD ; if ( hash_LR == reverse_hash_LR ) { if ( isPalindrome ( str , L , R ) == true ) printf ( " The ▁ Substring ▁ [ % d ▁ % d ] ▁ is ▁ a ▁ " " palindrome STRNEWLINE " , L , R ) ; else printf ( " The ▁ Substring ▁ [ % d ▁ % d ] ▁ is ▁ not ▁ a ▁ " " palindrome STRNEWLINE " , L , R ) ; } else printf ( " The ▁ Substring ▁ [ % d ▁ % d ] ▁ is ▁ not ▁ a ▁ " " palindrome STRNEWLINE " , L , R ) ; } return ; } void computePowers ( unsigned long long int power [ ] , int n ) { power [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) power [ i ] = ( power [ i - 1 ] % MOD * p % MOD ) % MOD ; return ; } int main ( ) { string str = " abaaabaaaba " ; int n = str . length ( ) ; unsigned long long int power [ n + 1 ] ; computePowers ( power , n ) ; unsigned long long int prefix [ n + 1 ] , suffix [ n + 1 ] ; computePrefixHash ( str , n , prefix , power ) ; computeSuffixHash ( str , n , suffix , power ) ; Query q [ ] = { { 0 , 10 } , { 5 , 8 } , { 2 , 5 } , { 5 , 9 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; queryResults ( str , q , m , n , prefix , suffix , power ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; } int getLevel ( Node * root , Node * node , int level ) { if ( root == NULL ) return 0 ; if ( root == node ) return level ; int downlevel = getLevel ( root -> left , node , level + 1 ) ; if ( downlevel != 0 ) return downlevel ; return getLevel ( root -> right , node , level + 1 ) ; } void printGivenLevel ( Node * root , Node * node , int level ) { if ( root == NULL level < 2 ) return ; if ( level == 2 ) { if ( root -> left == node root -> right == node ) return ; if ( root -> left ) cout << root -> left -> data << " ▁ " ; if ( root -> right ) cout << root -> right -> data ; } else if ( level > 2 ) { printGivenLevel ( root -> left , node , level - 1 ) ; printGivenLevel ( root -> right , node , level - 1 ) ; } } void printCousins ( Node * root , Node * node ) { int level = getLevel ( root , node , 1 ) ; printGivenLevel ( root , node , level ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; printCousins ( root , root -> left -> right ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int ptr [ 501 ] ; void findSmallestRange ( int arr [ ] [ N ] , int n , int k ) { int i , minval , maxval , minrange , minel , maxel , flag , minind ; for ( i = 0 ; i <= k ; i ++ ) ptr [ i ] = 0 ; minrange = INT_MAX ; while ( 1 ) { minind = -1 ; minval = INT_MAX ; maxval = INT_MIN ; flag = 0 ; for ( i = 0 ; i < k ; i ++ ) { if ( ptr [ i ] == n ) { flag = 1 ; break ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] < minval ) { minind = i ; minval = arr [ i ] [ ptr [ i ] ] ; } if ( ptr [ i ] < n && arr [ i ] [ ptr [ i ] ] > maxval ) { maxval = arr [ i ] [ ptr [ i ] ] ; } } if ( flag ) break ; ptr [ minind ] ++ ; if ( ( maxval - minval ) < minrange ) { minel = minval ; maxel = maxval ; minrange = maxel - minel ; } } printf ( " The ▁ smallest ▁ range ▁ is ▁ [ % d , ▁ % d ] STRNEWLINE " , minel , maxel ) ; } int main ( ) { int arr [ ] [ N ] = { { 4 , 7 , 9 , 12 , 15 } , { 0 , 8 , 10 , 14 , 20 } , { 6 , 12 , 16 , 30 , 50 } } ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSmallestRange ( arr , N , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNum ( int arr [ ] , int n ) { int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; } int main ( ) { int arr [ ] = { 3 , 5 , 8 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countNum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNum ( int arr [ ] , int n ) { unordered_set < int > s ; int count = 0 , maxm = INT_MIN , minm = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( arr [ i ] ) ; if ( arr [ i ] < minm ) minm = arr [ i ] ; if ( arr [ i ] > maxm ) maxm = arr [ i ] ; } for ( int i = minm ; i <= maxm ; i ++ ) if ( s . find ( arr [ i ] ) == s . end ( ) ) count ++ ; return count ; } int main ( ) { int arr [ ] = { 3 , 5 , 8 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countNum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAXN  11 NEW_LINE #define ver  2 NEW_LINE int hashtable [ ver ] [ MAXN ] ; int pos [ ver ] ; void initTable ( ) { for ( int j = 0 ; j < MAXN ; j ++ ) for ( int i = 0 ; i < ver ; i ++ ) hashtable [ i ] [ j ] = INT_MIN ; } int hash ( int function , int key ) { switch ( function ) { case 1 : return key % MAXN ; case 2 : return ( key / MAXN ) % MAXN ; } } void place ( int key , int tableID , int cnt , int n ) { if ( cnt == n ) { printf ( " % d ▁ unpositioned STRNEWLINE " , key ) ; printf ( " Cycle ▁ present . ▁ REHASH . STRNEWLINE " ) ; return ; } for ( int i = 0 ; i < ver ; i ++ ) { pos [ i ] = hash ( i + 1 , key ) ; if ( hashtable [ i ] [ pos [ i ] ] == key ) return ; } if ( hashtable [ tableID ] [ pos [ tableID ] ] != INT_MIN ) { int dis = hashtable [ tableID ] [ pos [ tableID ] ] ; hashtable [ tableID ] [ pos [ tableID ] ] = key ; place ( dis , ( tableID + 1 ) % ver , cnt + 1 , n ) ; } else hashtable [ tableID ] [ pos [ tableID ] ] = key ; } void printTable ( ) { printf ( " Final ▁ hash ▁ tables : STRNEWLINE " ) ; for ( int i = 0 ; i < ver ; i ++ , printf ( " STRNEWLINE " ) ) for ( int j = 0 ; j < MAXN ; j ++ ) ( hashtable [ i ] [ j ] == INT_MIN ) ? printf ( " - ▁ " ) : printf ( " % d ▁ " , hashtable [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } void cuckoo ( int keys [ ] , int n ) { initTable ( ) ; for ( int i = 0 , cnt = 0 ; i < n ; i ++ , cnt = 0 ) place ( keys [ i ] , 0 , cnt , n ) ; printTable ( ) ; } int main ( ) { int keys_1 [ ] = { 20 , 50 , 53 , 75 , 100 , 67 , 105 , 3 , 36 , 39 } ; int n = sizeof ( keys_1 ) / sizeof ( int ) ; cuckoo ( keys_1 , n ) ; int keys_2 [ ] = { 20 , 50 , 53 , 75 , 100 , 67 , 105 , 3 , 36 , 39 , 6 } ; int m = sizeof ( keys_2 ) / sizeof ( int ) ; cuckoo ( keys_2 , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDistictSubarray ( int arr [ ] , int n ) { unordered_map < int , int > vis ; for ( int i = 0 ; i < n ; ++ i ) vis [ arr [ i ] ] = 1 ; int k = vis . size ( ) ; vis . clear ( ) ; int ans = 0 , right = 0 , window = 0 ; for ( int left = 0 ; left < n ; ++ left ) { while ( right < n && window < k ) { ++ vis [ arr [ right ] ] ; if ( vis [ arr [ right ] ] == 1 ) ++ window ; ++ right ; } if ( window == k ) ans += ( n - right + 1 ) ; -- vis [ arr [ left ] ] ; if ( vis [ arr [ left ] ] == 0 ) -- window ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 1 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDistictSubarray ( arr , n ) << " n " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubarrays ( int arr [ ] , int n ) { int difference = 0 ; int ans = 0 ; int hash_positive [ n + 1 ] , hash_negative [ n + 1 ] ; fill_n ( hash_positive , n + 1 , 0 ) ; fill_n ( hash_negative , n + 1 , 0 ) ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 == 1 ) difference ++ ; else difference -- ; if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; } int main ( ) { int arr [ ] = { 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays " " ▁ are ▁ " << countSubarrays ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; void printArray ( int [ ] , int ) ; void printPathsRecur ( node * , int [ ] , int ) ; node * newNode ( int ) ; void printPaths ( node * ) ; void printPaths ( node * node ) { int path [ 1000 ] ; printPathsRecur ( node , path , 0 ) ; } void printPathsRecur ( node * node , int path [ ] , int pathLen ) { if ( node == NULL ) return ; path [ pathLen ] = node -> data ; pathLen ++ ; if ( node -> left == NULL && node -> right == NULL ) { printArray ( path , pathLen ) ; } else { printPathsRecur ( node -> left , path , pathLen ) ; printPathsRecur ( node -> right , path , pathLen ) ; } } node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } void printArray ( int ints [ ] , int len ) { int i ; for ( i = 0 ; i < len ; i ++ ) { cout << ints [ i ] << " ▁ " ; } cout << endl ; } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printPaths ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinctIds ( int arr [ ] , int n , int mi ) { unordered_map < int , int > m ; vector < pair < int , int > > v ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) v . push_back ( make_pair ( it -> second , it -> first ) ) ; sort ( v . begin ( ) , v . end ( ) ) ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( v [ i ] . first <= mi ) { mi -= v [ i ] . first ; count ++ ; } else return size - count ; } return size - count ; } int main ( ) { int arr [ ] = { 2 , 3 , 1 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 3 ; cout << distinctIds ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLongestConseqSubseq ( int arr [ ] , int n ) { unordered_set < int > S ; for ( int i = 0 ; i < n ; i ++ ) S . insert ( arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . find ( arr [ i ] - 1 ) == S . end ( ) ) { int j = arr [ i ] ; while ( S . find ( j ) != S . end ( ) ) j ++ ; ans = max ( ans , j - arr [ i ] ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 94 , 93 , 1000 , 5 , 92 , 78 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findLongestConseqSubseq ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLargestd ( int S [ ] , int n ) { bool found = false ; sort ( S , S + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; for ( int k = j + 1 ; k < n ; k ++ ) { if ( i == k ) continue ; for ( int l = k + 1 ; l < n ; l ++ ) { if ( i == l ) continue ; if ( S [ i ] == S [ j ] + S [ k ] + S [ l ] ) { found = true ; return S [ i ] ; } } } } } if ( found == false ) return INT_MIN ; } int main ( ) { int S [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; int ans = findLargestd ( S , n ) ; if ( ans == INT_MIN ) cout << " No ▁ Solution " << endl ; else cout << " Largest ▁ d ▁ such ▁ that ▁ a ▁ + ▁ b ▁ + ▁ " << " c ▁ = ▁ d ▁ is ▁ " << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFourElements ( int arr [ ] , int n ) { unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp [ arr [ i ] + arr [ j ] ] = { i , j } ; int d = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int abs_diff = abs ( arr [ i ] - arr [ j ] ) ; if ( mp . find ( abs_diff ) != mp . end ( ) ) { pair < int , int > p = mp [ abs_diff ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) d = max ( d , max ( arr [ i ] , arr [ j ] ) ) ; } } } return d ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int res = findFourElements ( arr , n ) ; if ( res == INT_MIN ) cout << " No ▁ Solution . " ; else cout << res ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int findSubarraySum ( int arr [ ] , int n ) { int i , j ; long long int cArray [ n + 1 ] = { 0 } ; for ( i = 0 ; i < n ; i ++ ) cArray [ i + 1 ] = cArray [ i ] + arr [ i ] ; vector < long long int > subArrSum ; for ( i = 1 ; i <= n ; i ++ ) for ( j = i ; j <= n ; j ++ ) subArrSum . push_back ( cArray [ j ] - cArray [ i - 1 ] ) ; sort ( subArrSum . begin ( ) , subArrSum . end ( ) ) ; long long totalSum = 0 ; for ( i = 0 ; i < subArrSum . size ( ) - 1 ; i ++ ) { if ( subArrSum [ i ] == subArrSum [ i + 1 ] ) { j = i + 1 ; while ( subArrSum [ j ] == subArrSum [ i ] && j < subArrSum . size ( ) ) { subArrSum [ j ] = 0 ; j ++ ; } subArrSum [ i ] = 0 ; } } for ( i = 0 ; i < subArrSum . size ( ) ; i ++ ) totalSum += subArrSum [ i ] ; return totalSum ; } int main ( ) { int arr [ ] = { 3 , 2 , 3 , 1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSubarraySum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int findSubarraySum ( int arr [ ] , int n ) { int res = 0 ; unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; m [ sum ] ++ ; } } for ( auto x : m ) if ( x . second == 1 ) res += x . first ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 3 , 1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSubarraySum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int recaman ( int n ) { int arr [ n ] ; arr [ 0 ] = 0 ; printf ( " % d , ▁ " , arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; printf ( " % d , ▁ " , arr [ i ] ) ; } } int main ( ) { int n = 17 ; recaman ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int height ( Node * root , int & ans , Node * ( & k ) , int & lh , int & rh , int & f ) { if ( root == NULL ) return 0 ; int left_height = height ( root -> left , ans , k , lh , rh , f ) ; int right_height = height ( root -> right , ans , k , lh , rh , f ) ; if ( ans < 1 + left_height + right_height ) { ans = 1 + left_height + right_height ; k = root ; lh = left_height ; rh = right_height ; } return 1 + max ( left_height , right_height ) ; } void printArray ( int ints [ ] , int len , int f ) { int i ; if ( f == 0 ) { for ( i = len - 1 ; i >= 0 ; i -- ) { printf ( " % d ▁ " , ints [ i ] ) ; } } else if ( f == 1 ) { for ( i = 0 ; i < len ; i ++ ) { printf ( " % d ▁ " , ints [ i ] ) ; } } } void printPathsRecur ( Node * node , int path [ ] , int pathLen , int max , int & f ) { if ( node == NULL ) return ; path [ pathLen ] = node -> data ; pathLen ++ ; if ( node -> left == NULL && node -> right == NULL ) { if ( pathLen == max && ( f == 0 f == 1 ) ) { printArray ( path , pathLen , f ) ; f = 2 ; } } else { printPathsRecur ( node -> left , path , pathLen , max , f ) ; printPathsRecur ( node -> right , path , pathLen , max , f ) ; } } void diameter ( Node * root ) { if ( root == NULL ) return ; int ans = INT_MIN , lh = 0 , rh = 0 ; int f = 0 ; Node * k ; int height_of_tree = height ( root , ans , k , lh , rh , f ) ; int lPath [ 100 ] , pathlen = 0 ; printPathsRecur ( k -> left , lPath , pathlen , lh , f ) ; printf ( " % d ▁ " , k -> data ) ; int rPath [ 100 ] ; f = 1 ; printPathsRecur ( k -> right , rPath , pathlen , rh , f ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> left = newNode ( 6 ) ; root -> left -> right -> right = newNode ( 7 ) ; root -> left -> left -> right = newNode ( 8 ) ; root -> left -> left -> right -> left = newNode ( 9 ) ; diameter ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void recaman ( int n ) { if ( n <= 0 ) return ; printf ( " % d , ▁ " , 0 ) ; unordered_set < int > s ; s . insert ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . find ( curr ) != s . end ( ) ) curr = prev + i ; s . insert ( curr ) ; printf ( " % d , ▁ " , curr ) ; prev = curr ; } } int main ( ) { int n = 17 ; recaman ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findFibSubset ( int arr [ ] , int n ) { int max = * std :: max_element ( arr , arr + n ) ; int a = 0 , b = 1 ; unordered_set < int > hash ; hash . insert ( a ) ; hash . insert ( b ) ; while ( b < max ) { int c = a + b ; a = b ; b = c ; hash . insert ( b ) ; } for ( int i = 0 ; i < n ; i ++ ) if ( hash . find ( arr [ i ] ) != hash . end ( ) ) printf ( " % d ▁ " , arr [ i ] ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 8 , 5 , 20 , 1 , 40 , 13 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findFibSubset ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDiv ( int x ) { int sum = 1 ; for ( int i = 2 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { sum += i ; if ( x / i != i ) sum += x / i ; } } return sum ; } bool isAmicable ( int a , int b ) { return ( sumOfDiv ( a ) == b && sumOfDiv ( b ) == a ) ; } int countPairs ( int arr [ ] , int n ) { unordered_set < int > s ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( sumOfDiv ( arr [ i ] ) ) != s . end ( ) ) { int sum = sumOfDiv ( arr [ i ] ) ; if ( isAmicable ( arr [ i ] , sum ) ) count ++ ; } } return count / 2 ; } int main ( ) { int arr1 [ ] = { 220 , 284 , 1184 , 1210 , 2 , 5 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << countPairs ( arr1 , n1 ) << endl ; int arr2 [ ] = { 2620 , 2924 , 5020 , 5564 , 6232 , 6368 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << countPairs ( arr2 , n2 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findArea ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int dimension [ 2 ] = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 4 , 6 , 6 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findArea ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findArea ( int arr [ ] , int n ) { unordered_set < int > s ; int first = 0 , second = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; continue ; } if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } return ( first * second ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 4 , 6 , 6 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findArea ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void printTopToBottomPath ( Node * curr , map < Node * , Node * > parent ) { stack < Node * > stk ; while ( curr ) { stk . push ( curr ) ; curr = parent [ curr ] ; } while ( ! stk . empty ( ) ) { curr = stk . top ( ) ; stk . pop ( ) ; cout << curr -> data << " ▁ " ; } cout << endl ; } void printRootToLeaf ( Node * root ) { if ( root == NULL ) return ; stack < Node * > nodeStack ; nodeStack . push ( root ) ; map < Node * , Node * > parent ; parent [ root ] = NULL ; while ( ! nodeStack . empty ( ) ) { Node * current = nodeStack . top ( ) ; nodeStack . pop ( ) ; if ( ! ( current -> left ) && ! ( current -> right ) ) printTopToBottomPath ( current , parent ) ; if ( current -> right ) { parent [ current -> right ] = current ; nodeStack . push ( current -> right ) ; } if ( current -> left ) { parent [ current -> left ] = current ; nodeStack . push ( current -> left ) ; } } } int main ( ) { Node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 2 ) ; printRootToLeaf ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int playGame ( int arr [ ] , int n ) { unordered_set < int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash . insert ( arr [ i ] ) ; return ( hash . size ( ) % 2 == 0 ? 1 : 2 ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 2 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Player ▁ " << playGame ( arr , n ) << " ▁ Wins " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longLenStrictBitonicSub ( int arr [ ] , int n ) { unordered_map < int , int > inc , dcr ; int len_inc [ n ] , len_dcr [ n ] ; int longLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = 0 ; if ( inc . find ( arr [ i ] - 1 ) != inc . end ( ) ) len = inc [ arr [ i ] - 1 ] ; inc [ arr [ i ] ] = len_inc [ i ] = len + 1 ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { int len = 0 ; if ( dcr . find ( arr [ i ] - 1 ) != dcr . end ( ) ) len = dcr [ arr [ i ] - 1 ] ; dcr [ arr [ i ] ] = len_dcr [ i ] = len + 1 ; } for ( int i = 0 ; i < n ; i ++ ) if ( longLen < ( len_inc [ i ] + len_dcr [ i ] - 1 ) ) longLen = len_inc [ i ] + len_dcr [ i ] - 1 ; return longLen ; } int main ( ) { int arr [ ] = { 1 , 5 , 2 , 3 , 4 , 5 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Longest ▁ length ▁ strict ▁ bitonic ▁ subsequence ▁ = ▁ " << longLenStrictBitonicSub ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lastSeenElement ( int a [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ a [ i ] ] = i ; int res_ind = INT_MAX , res ; for ( auto x : hash ) { if ( x . second < res_ind ) { res_ind = x . second ; res = x . first ; } } return res ; } int main ( ) { int a [ ] = { 2 , 1 , 2 , 2 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << lastSeenElement ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int arr [ ] , int size ) ; void swap ( int arr [ ] , int fi , int si , int d ) ; void leftRotate ( int arr [ ] , int d , int n ) { if ( d == 0 d == n ) return ; if ( n - d == d ) { swap ( arr , 0 , n - d , d ) ; return ; } if ( d < n - d ) { swap ( arr , 0 , n - d , d ) ; leftRotate ( arr , d , n - d ) ; } else { swap ( arr , 0 , d , n - d ) ; leftRotate ( arr + n - d , 2 * d - n , d ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } void swap ( int arr [ ] , int fi , int si , int d ) { int i , temp ; for ( i = 0 ; i < d ; i ++ ) { temp = arr [ fi + i ] ; arr [ fi + i ] = arr [ si + i ] ; arr [ si + i ] = temp ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; leftRotate ( arr , 2 , 7 ) ; printArray ( arr , 7 ) ; return 0 ; }
void leftRotate ( int arr [ ] , int d , int n ) { int i , j ; if ( d == 0 d == n ) return ; i = d ; j = n - d ; while ( i != j ) { if ( i < j ) { swap ( arr , d - i , d + j - i , i ) ; j -= i ; } else { swap ( arr , d - i , d , j ) ; i -= j ; } } swap ( arr , d - i , d , i ) ; }
#include <iostream> NEW_LINE using namespace std ; void rotate ( int arr [ ] , int n ) { int i = 0 , j = n - 1 ; while ( i != j ) { swap ( arr [ i ] , arr [ j ] ) ; i ++ ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } , i ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Given ▁ array ▁ is ▁ STRNEWLINE " ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; rotate ( arr , n ) ; cout << " Rotated array is " ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pairsInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; } int main ( ) { int arr [ ] = { 11 , 15 , 6 , 7 , 9 , 10 } ; int sum = 16 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << pairsInSortedRotated ( arr , n , sum ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n ) { int arrSum = 0 ; int currVal = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arrSum = arrSum + arr [ i ] ; currVal = currVal + ( i * arr [ i ] ) ; } int maxVal = currVal ; for ( int j = 1 ; j < n ; j ++ ) { currVal = currVal + arrSum - n * arr [ n - j ] ; if ( currVal > maxVal ) maxVal = currVal ; } return maxVal ; } int main ( void ) { int arr [ ] = { 10 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Max sum is " return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; void printOddNodes ( Node * root , bool isOdd = true ) { if ( root == NULL ) return ; if ( isOdd ) cout << root -> data << " ▁ " ; printOddNodes ( root -> left , ! isOdd ) ; printOddNodes ( root -> right , ! isOdd ) ; } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printOddNodes ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = max ( res , curr_sum ) ; } return res ; } int main ( ) { int arr [ ] = { 8 , 3 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = max ( res , next_val ) ; } return res ; } int main ( ) { int arr [ ] = { 8 , 3 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRotations ( int arr [ ] , int n ) { int min = arr [ 0 ] , min_index ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; } int main ( ) { int arr [ ] = { 15 , 18 , 2 , 3 , 6 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countRotations ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRotations ( int arr [ ] , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; } int main ( ) { int arr [ ] = { 15 , 18 , 2 , 3 , 6 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countRotations ( arr , 0 , n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void preprocess ( int arr [ ] , int n , int temp [ ] ) { for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = temp [ i + n ] = arr [ i ] ; } void leftRotate ( int arr [ ] , int n , int k , int temp [ ] ) { int start = k % n ; for ( int i = start ; i < start + n ; i ++ ) cout << temp [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int temp [ 2 * n ] ; preprocess ( arr , n , temp ) ; int k = 2 ; leftRotate ( arr , n , k , temp ) ; k = 3 ; leftRotate ( arr , n , k , temp ) ; k = 4 ; leftRotate ( arr , n , k , temp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void reverseArray ( int arr [ ] , int start , int end ) { while ( start < end ) { std :: swap ( arr [ start ] , arr [ end ] ) ; start ++ ; end -- ; } } void rightRotate ( int arr [ ] , int d , int n ) { reverseArray ( arr , 0 , n - 1 ) ; reverseArray ( arr , 0 , d - 1 ) ; reverseArray ( arr , d , n - 1 ) ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) std :: cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; rightRotate ( arr , k , n ) ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; void printOddNodes ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; bool isOdd = true ; while ( 1 ) { int nodeCount = q . size ( ) ; if ( nodeCount == 0 ) break ; while ( nodeCount > 0 ) { Node * node = q . front ( ) ; if ( isOdd ) cout << node -> data << " ▁ " ; q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; nodeCount -- ; } isOdd = ! isOdd ; } } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printOddNodes ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxHamming ( int arr [ ] , int n ) { int brr [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxHamming ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void leftRotate ( int arr [ ] , int n , int k ) { int mod = k % n ; for ( int i = 0 ; i < n ; i ++ ) cout << ( arr [ ( mod + i ) % n ] ) << " ▁ " ; cout << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; leftRotate ( arr , n , k ) ; k = 3 ; leftRotate ( arr , n , k ) ; k = 4 ; leftRotate ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void leftRotate ( int arr [ ] , int k , int n ) { rotate ( arr , arr + ( k % n ) , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; leftRotate ( arr , k , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findElement ( int arr [ ] , int ranges [ ] [ 2 ] , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } } return arr [ index ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int rotations = 2 ; int ranges [ rotations ] [ 2 ] = { { 0 , 2 } , { 0 , 3 } } ; int index = 1 ; cout << findElement ( arr , ranges , rotations , index ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } } int main ( ) { int arr [ ] = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int position = 2 ; splitArr ( arr , 6 , position ) ; for ( int i = 0 ; i < n ; ++ i ) printf ( " % d ▁ " , arr [ i ] ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void fixArray ( int ar [ ] , int n ) { int i , j , temp ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( ar [ j ] == i ) { temp = ar [ j ] ; ar [ j ] = ar [ i ] ; ar [ i ] = temp ; break ; } } } for ( i = 0 ; i < n ; i ++ ) { if ( ar [ i ] != i ) { ar [ i ] = -1 ; } } cout << " Array ▁ after ▁ Rearranging " << endl ; for ( i = 0 ; i < n ; i ++ ) { cout << ar [ i ] << " ▁ " ; } } int main ( ) { int n , ar [ ] = { -1 , -1 , 6 , 1 , 9 , 3 , 2 , -1 , 4 , -1 } ; n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; fixArray ( ar , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void findFullNode ( Node * root ) { if ( root != NULL ) { findFullNode ( root -> left ) ; if ( root -> left != NULL && root -> right != NULL ) cout << root -> data << " ▁ " ; findFullNode ( root -> right ) ; } } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; findFullNode ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeArr ( int arr [ ] , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int tempArr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; sort ( tempArr , tempArr + n ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrangeArr ( arr , size ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } int main ( ) { int arr [ ] = { 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pushZerosToEnd ( arr , n ) ; cout << " Array ▁ after ▁ pushing ▁ all ▁ zeros ▁ to ▁ end ▁ of ▁ array ▁ : STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void moveZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) swap ( arr [ count ++ ] , arr [ i ] ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 0 , 1 , 9 , 8 , 4 , 0 , 0 , 2 , 7 , 0 , 6 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Original ▁ array : ▁ " ; printArray ( arr , n ) ; moveZerosToEnd ( arr , n ) ; cout << " Modified array : " printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int key ) { Node * node = new Node ; node -> key = key ; node -> left = node -> right = NULL ; return ( node ) ; } int addBT ( Node * root ) { if ( root == NULL ) return 0 ; return ( root -> key + addBT ( root -> left ) + addBT ( root -> right ) ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; int sum = addBT ( root ) ; cout << " Sum ▁ of ▁ all ▁ the ▁ elements ▁ is : ▁ " << sum << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minSwap ( int * arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = min ( ans , bad ) ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 6 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << minSwap ( arr , n , k ) << " STRNEWLINE " ; int arr1 [ ] = { 2 , 7 , 9 , 5 , 8 , 7 , 4 } ; n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; k = 5 ; cout << minSwap ( arr1 , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void pushZerosToEnd ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 0 ) arr [ count ++ ] = arr [ i ] ; while ( count < n ) arr [ count ++ ] = 0 ; } void modifyAndRearrangeArr ( int arr [ ] , int n ) { if ( n == 1 ) return ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( arr [ i ] != 0 ) && ( arr [ i ] == arr [ i + 1 ] ) ) { arr [ i ] = 2 * arr [ i ] ; arr [ i + 1 ] = 0 ; i ++ ; } } pushZerosToEnd ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 0 , 2 , 2 , 2 , 0 , 6 , 6 , 0 , 0 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Original ▁ array : ▁ " ; printArray ( arr , n ) ; modifyAndRearrangeArr ( arr , n ) ; cout << " Modified array : " printArray ( arr , n ) ; return 0 ; }
void swap ( int & a , int & b ) { a = b + a - ( b = a ) ; } void shiftAllZeroToLeft ( int array [ ] , int n ) { int lastSeenNonZero = 0 ; for ( index = 0 ; index < n ; index ++ ) { if ( array [ index ] != 0 ) { swap ( array [ index ] , array [ lastSeenNonZero ] ) ; lastSeenNonZero ++ ; } } }
#include <iostream> NEW_LINE using namespace std ; void reorder ( int arr [ ] , int index [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } } int main ( ) { int arr [ ] = { 50 , 40 , 70 , 60 , 90 } ; int index [ ] = { 3 , 0 , 4 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; reorder ( arr , index , n ) ; cout << " Reordered ▁ array ▁ is : ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << " Modified Index array is : " for ( int i = 0 ; i < n ; i ++ ) cout << index [ i ] << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void reorder ( int arr [ ] , int index [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( index [ i ] != i ) { int oldTargetI = index [ index [ i ] ] ; char oldTargetE = arr [ index [ i ] ] ; arr [ index [ i ] ] = arr [ i ] ; index [ index [ i ] ] = index [ i ] ; index [ i ] = oldTargetI ; arr [ i ] = oldTargetE ; } } } int main ( ) { int arr [ ] = { 50 , 40 , 70 , 60 , 90 } ; int index [ ] = { 3 , 0 , 4 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; reorder ( arr , index , n ) ; cout << " Reordered ▁ array ▁ is : ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << " Modified Index array is : " for ( int i = 0 ; i < n ; i ++ ) cout << index [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int heapSize ; void swap ( int & a , int & b ) { int temp = a ; a = b ; b = temp ; } void heapify ( int arr [ ] , int index [ ] , int i ) { int largest = i ; int left = 2 * i + 1 ; int right = 2 * i + 2 ; if ( left < heapSize && index [ left ] > index [ largest ] ) { largest = left ; } if ( right < heapSize && index [ right ] > index [ largest ] ) { largest = right ; } if ( largest != i ) { swap ( arr [ largest ] , arr [ i ] ) ; swap ( index [ largest ] , index [ i ] ) ; heapify ( arr , index , largest ) ; } } void heapSort ( int arr [ ] , int index [ ] , int n ) { for ( int i = ( n - 1 ) / 2 ; i >= 0 ; i -- ) { heapify ( arr , index , i ) ; } for ( int i = n - 1 ; i > 0 ; i -- ) { swap ( index [ 0 ] , index [ i ] ) ; swap ( arr [ 0 ] , arr [ i ] ) ; heapSize -- ; heapify ( arr , index , 0 ) ; } } int main ( ) { int arr [ ] = { 50 , 40 , 70 , 60 , 90 } ; int index [ ] = { 3 , 0 , 4 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; heapSize = n ; heapSort ( arr , index , n ) ; cout << " Reordered ▁ array ▁ is : ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << " Modified Index array is : " for ( int i = 0 ; i < n ; i ++ ) cout << index [ i ] << " ▁ " ; return 0 ; }
#include <stdio.h> NEW_LINE void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; printf ( " STRNEWLINE " ) ; } void RearrangePosNeg ( int arr [ ] , int n ) { int key , j ; for ( int i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; if ( key > 0 ) continue ; j = i - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return newNode ; } void sumOfParentOfX ( Node * root , int & sum , int x ) { if ( ! root ) return ; if ( ( root -> left && root -> left -> data == x ) || ( root -> right && root -> right -> data == x ) ) sum += root -> data ; sumOfParentOfX ( root -> left , sum , x ) ; sumOfParentOfX ( root -> right , sum , x ) ; } int sumOfParentOfXUtil ( Node * root , int x ) { int sum = 0 ; sumOfParentOfX ( root , sum , x ) ; return sum ; } int main ( ) { Node * root = getNode ( 4 ) ; root -> left = getNode ( 2 ) ; root -> right = getNode ( 5 ) ; root -> left -> left = getNode ( 7 ) ; root -> left -> right = getNode ( 2 ) ; root -> right -> left = getNode ( 2 ) ; root -> right -> right = getNode ( 3 ) ; int x = 2 ; cout << " Sum ▁ = ▁ " << sumOfParentOfXUtil ( root , x ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void RearrangePosNeg ( int arr [ ] , int n ) { int i = 0 ; int j = n - 1 ; while ( true ) { while ( arr [ i ] < 0 && i < n ) i ++ ; while ( arr [ j ] > 0 && j >= 0 ) j -- ; if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } else break ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeNaive ( int arr [ ] , int n ) { int temp [ n ] , i ; for ( i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] = i ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) cout << ( " % d ▁ " , arr [ i ] ) ; cout << ( " STRNEWLINE " ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 0 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( " Given ▁ array ▁ is ▁ STRNEWLINE " ) ; printArray ( arr , n ) ; rearrangeNaive ( arr , n ) ; cout << ( " Modified ▁ array ▁ is ▁ STRNEWLINE " ) ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrange ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ arr [ i ] % n ] += i * n ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] /= n ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 2 , 0 , 1 , 4 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Given ▁ array ▁ is ▁ : ▁ " << endl ; printArray ( arr , n ) ; rearrange ( arr , n ) ; cout << " Modified ▁ array ▁ is ▁ : " << endl ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrange ( int arr [ ] , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Original ▁ Arrayn " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; rearrange ( arr , n ) ; cout << " Modified Array " for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrange ( int arr [ ] , int n ) { int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { if ( i != j ) swap ( arr [ i ] , arr [ j ] ) ; j ++ ; } } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; } int main ( ) { int arr [ ] = { -1 , 2 , -3 , 4 , 5 , 6 , -7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrange ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void rearrange ( int * arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && arr [ i ] > arr [ i + 1 ] ) swap ( arr [ i ] , arr [ i + 1 ] ) ; if ( i % 2 != 0 && arr [ i ] < arr [ i + 1 ] ) swap ( arr [ i ] , arr [ i + 1 ] ) ; } } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 6 , 4 , 2 , 1 , 8 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Before ▁ rearranging : ▁ STRNEWLINE " ; printArray ( arr , n ) ; rearrange ( arr , n ) ; cout << " After ▁ rearranging : ▁ STRNEWLINE " ; printArray ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void arrayEvenAndOdd ( int arr [ ] , int n ) { int a [ n ] , ind = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { a [ ind ] = arr [ i ] ; ind ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { a [ ind ] = arr [ i ] ; ind ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " ▁ " ; } cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 , 7 , 6 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( int ) ; arrayEvenAndOdd ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = -1 , j = 0 ; int t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; swap ( arr [ i ] , arr [ j ] ) ; } j ++ ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 , 7 , 6 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( int ) ; arrayEvenAndOdd ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( char k ) { Node * node = new Node ; node -> key = k ; node -> right = node -> left = NULL ; return node ; } void leftLeavesSumRec ( Node * root , bool isleft , int * sum ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right && isleft ) * sum += root -> key ; leftLeavesSumRec ( root -> left , 1 , sum ) ; leftLeavesSumRec ( root -> right , 0 , sum ) ; } int leftLeavesSum ( Node * root ) { int sum = 0 ; leftLeavesSumRec ( root , 0 , & sum ) ; return sum ; } int main ( ) { int sum = 0 ; struct Node * root = newNode ( 20 ) ; root -> left = newNode ( 9 ) ; root -> right = newNode ( 49 ) ; root -> right -> left = newNode ( 23 ) ; root -> right -> right = newNode ( 52 ) ; root -> right -> right -> left = newNode ( 50 ) ; root -> left -> left = newNode ( 5 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> right = newNode ( 12 ) ; cout << " Sum ▁ of ▁ left ▁ leaves ▁ is ▁ " << leftLeavesSum ( root ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } bool isMirror ( struct Node * root1 , struct Node * root2 ) { if ( root1 == NULL && root2 == NULL ) return true ; if ( root1 && root2 && root1 -> key == root2 -> key ) return isMirror ( root1 -> left , root2 -> right ) && isMirror ( root1 -> right , root2 -> left ) ; return false ; } bool isSymmetric ( struct Node * root ) { return isMirror ( root , root ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 3 ) ; if ( isSymmetric ( root ) ) cout << " Symmetric " ; else cout << " Not ▁ symmetric " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct HeapNode { int val ; int r ; int c ; } ; void swap ( HeapNode * x , HeapNode * y ) { HeapNode z = * x ; * x = * y ; * y = z ; } void minHeapify ( HeapNode harr [ ] , int i , int heap_size ) { int l = i * 2 + 1 ; int r = i * 2 + 2 ; if ( l < heap_size && r < heap_size && harr [ l ] . val < harr [ i ] . val && harr [ r ] . val < harr [ i ] . val ) { HeapNode temp = harr [ r ] ; harr [ r ] = harr [ i ] ; harr [ i ] = harr [ l ] ; harr [ l ] = temp ; minHeapify ( harr , l , heap_size ) ; minHeapify ( harr , r , heap_size ) ; } if ( l < heap_size && harr [ l ] . val < harr [ i ] . val ) { HeapNode temp = harr [ i ] ; harr [ i ] = harr [ l ] ; harr [ l ] = temp ; minHeapify ( harr , l , heap_size ) ; } } int kthSmallest ( int mat [ 4 ] [ 4 ] , int n , int k ) { if ( k < 0 && k >= n * n ) return INT_MAX ; HeapNode harr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) harr [ i ] = { mat [ 0 ] [ i ] , 0 , i } ; HeapNode hr ; for ( int i = 0 ; i < k ; i ++ ) { hr = harr [ 0 ] ; int nextval = ( hr . r < ( n - 1 ) ) ? mat [ hr . r + 1 ] [ hr . c ] : INT_MAX ; harr [ 0 ] = { nextval , ( hr . r ) + 1 , hr . c } ; minHeapify ( harr , 0 , n ) ; } return hr . val ; } int main ( ) { int mat [ 4 ] [ 4 ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 25 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , } ; cout << "7th ▁ smallest ▁ element ▁ is ▁ " << kthSmallest ( mat , 4 , 7 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largest ( int arr [ ] , int n ) { int i ; int max = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; } int main ( ) { int arr [ ] = { 10 , 324 , 45 , 90 , 9808 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Largest ▁ in ▁ given ▁ array ▁ is ▁ " << largest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; if ( count >= 2 ) cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElements ( int arr [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) second = arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < second ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 2 , -6 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int key ; Node * left , * right ; Node ( int key_ ) { key = key_ ; left = NULL ; right = NULL ; } } ; int sumOfLeftLeaves ( Node * root ) { if ( root == NULL ) return 0 ; stack < Node * > stack_ ; stack_ . push ( root ) ; int sum = 0 ; while ( stack_ . size ( ) > 0 ) { Node * currentNode = stack_ . top ( ) ; stack_ . pop ( ) ; if ( currentNode -> left != NULL ) { stack_ . push ( currentNode -> left ) ; if ( currentNode -> left -> left == NULL && currentNode -> left -> right == NULL ) { sum = sum + currentNode -> left -> key ; } } if ( currentNode -> right != NULL ) stack_ . push ( currentNode -> right ) ; } return sum ; } int main ( ) { Node * root = new Node ( 20 ) ; root -> left = new Node ( 9 ) ; root -> right = new Node ( 49 ) ; root -> right -> left = new Node ( 23 ) ; root -> right -> right = new Node ( 52 ) ; root -> right -> right -> left = new Node ( 50 ) ; root -> left -> left = new Node ( 5 ) ; root -> left -> right = new Node ( 12 ) ; root -> left -> right -> right = new Node ( 12 ) ; cout << " Sum ▁ of ▁ left ▁ leaves ▁ is ▁ " << sumOfLeftLeaves ( root ) << endl ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void printSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; printSmall ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void kSmallestPair ( int arr1 [ ] , int n1 , int arr2 [ ] , int n2 , int k ) { if ( k > n1 * n2 ) { cout << " k ▁ pairs ▁ don ' t ▁ exist " ; return ; } int index2 [ n1 ] ; memset ( index2 , 0 , sizeof ( index2 ) ) ; while ( k > 0 ) { int min_sum = INT_MAX ; int min_index = 0 ; for ( int i1 = 0 ; i1 < n1 ; i1 ++ ) { if ( index2 [ i1 ] < n2 && arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] < min_sum ) { min_index = i1 ; min_sum = arr1 [ i1 ] + arr2 [ index2 [ i1 ] ] ; } } cout << " ( " << arr1 [ min_index ] << " , ▁ " << arr2 [ index2 [ min_index ] ] << " ) ▁ " ; index2 [ min_index ] ++ ; k -- ; } } int main ( ) { int arr1 [ ] = { 1 , 3 , 11 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int arr2 [ ] = { 2 , 4 , 8 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int k = 4 ; kSmallestPair ( arr1 , n1 , arr2 , n2 , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int * a , int n , int mid ) { int res = 0 ; for ( int i = 0 ; i < n ; ++ i ) res += upper_bound ( a + i , a + n , a [ i ] + mid ) - ( a + i + 1 ) ; return res ; } int kthDiff ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; int low = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i <= n - 2 ; ++ i ) low = min ( low , a [ i + 1 ] - a [ i ] ) ; int high = a [ n - 1 ] - a [ 0 ] ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( countPairs ( a , n , mid ) < k ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { int k = 3 ; int a [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << kthDiff ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } sort ( arr , arr + arr_size ) ; for ( i = arr_size - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] != arr [ arr_size - 1 ] ) { printf ( " The ▁ second ▁ largest ▁ element ▁ is ▁ % d STRNEWLINE " , arr [ i ] ) ; return ; } } printf ( " There ▁ is ▁ no ▁ second ▁ largest ▁ element STRNEWLINE " ) ; } int main ( ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2largest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int key ; Node * left , * right ; Node ( int key_ ) { key = key_ ; left = NULL ; right = NULL ; } } ; int sumOfLeftLeaves ( Node * root ) { if ( root == NULL ) return 0 ; queue < pair < Node * , bool > > q ; q . push ( { root , 0 } ) ; int sum = 0 ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) . first ; bool is_left_child = q . front ( ) . second ; q . pop ( ) ; if ( ! temp -> left && ! temp -> right && is_left_child ) sum = sum + temp -> key ; if ( temp -> left ) { q . push ( { temp -> left , 1 } ) ; } if ( temp -> right ) { q . push ( { temp -> right , 0 } ) ; } } return sum ; } int main ( ) { Node * root = new Node ( 20 ) ; root -> left = new Node ( 9 ) ; root -> right = new Node ( 49 ) ; root -> right -> left = new Node ( 23 ) ; root -> right -> right = new Node ( 52 ) ; root -> right -> right -> left = new Node ( 50 ) ; root -> left -> left = new Node ( 5 ) ; root -> left -> right = new Node ( 12 ) ; root -> left -> right -> right = new Node ( 12 ) ; cout << " Sum ▁ of ▁ left ▁ leaves ▁ is ▁ " << sumOfLeftLeaves ( root ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSmallestMissinginSortedArray ( vector < int > arr ) { if ( arr [ 0 ] != 0 ) return 0 ; if ( arr [ arr . size ( ) - 1 ] == arr . size ( ) - 1 ) return arr . size ( ) ; int first = arr [ 0 ] ; return findFirstMissing ( arr , 0 , arr . size ( ) - 1 , first ) ; } int findFirstMissing ( vector < int > arr , int start , int end , int first ) { if ( start < end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] != mid + first ) return findFirstMissing ( arr , start , mid , first ) ; else return findFirstMissing ( arr , mid + 1 , end , first ) ; } return start + first ; } int main ( ) { vector < int > arr = { 0 , 1 , 2 , 3 , 4 , 5 , 7 } ; int n = arr . size ( ) ; cout << " First ▁ Missing ▁ element ▁ is ▁ : ▁ " << findSmallestMissinginSortedArray ( arr ) ; }
#include <iostream> NEW_LINE using namespace std ; struct Pair { int min ; int max ; } ; struct Pair getMinMax ( int arr [ ] , int n ) { struct Pair minmax ; int i ; if ( n == 1 ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 0 ] ; return minmax ; } if ( arr [ 0 ] > arr [ 1 ] ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 1 ] ; } else { minmax . max = arr [ 1 ] ; minmax . min = arr [ 0 ] ; } for ( i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > minmax . max ) minmax . max = arr [ i ] ; else if ( arr [ i ] < minmax . min ) minmax . min = arr [ i ] ; } return minmax ; } int main ( ) { int arr [ ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int arr_size = 6 ; struct Pair minmax = getMinMax ( arr , arr_size ) ; cout << " Minimum ▁ element ▁ is ▁ " << minmax . min << endl ; cout << " Maximum ▁ element ▁ is ▁ " << minmax . max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumNodes ( int l ) { int leafNodeCount = pow ( 2 , l - 1 ) ; vector < int > vec [ l ] ; for ( int i = 1 ; i <= leafNodeCount ; i ++ ) vec [ l - 1 ] . push_back ( i ) ; for ( int i = l - 2 ; i >= 0 ; i -- ) { int k = 0 ; while ( k < vec [ i + 1 ] . size ( ) - 1 ) { vec [ i ] . push_back ( vec [ i + 1 ] [ k ] + vec [ i + 1 ] [ k + 1 ] ) ; k += 2 ; } } int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < vec [ i ] . size ( ) ; j ++ ) sum += vec [ i ] [ j ] ; } return sum ; } int main ( ) { int l = 3 ; cout << sumNodes ( l ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct Pair { int min ; int max ; } ; struct Pair getMinMax ( int arr [ ] , int n ) { struct Pair minmax ; int i ; if ( n % 2 == 0 ) { if ( arr [ 0 ] > arr [ 1 ] ) { minmax . max = arr [ 0 ] ; minmax . min = arr [ 1 ] ; } else { minmax . min = arr [ 0 ] ; minmax . max = arr [ 1 ] ; } i = 2 ; } else { minmax . min = arr [ 0 ] ; minmax . max = arr [ 0 ] ; i = 1 ; } while ( i < n - 1 ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] > minmax . max ) minmax . max = arr [ i ] ; if ( arr [ i + 1 ] < minmax . min ) minmax . min = arr [ i + 1 ] ; } else { if ( arr [ i + 1 ] > minmax . max ) minmax . max = arr [ i + 1 ] ; if ( arr [ i ] < minmax . min ) minmax . min = arr [ i ] ; } i += 2 ; } return minmax ; } int main ( ) { int arr [ ] = { 1000 , 11 , 445 , 1 , 330 , 3000 } ; int arr_size = 6 ; Pair minmax = getMinMax ( arr , arr_size ) ; cout << " nMinimum ▁ element ▁ is ▁ " << minmax . min << endl ; cout << " nMaximum ▁ element ▁ is ▁ " << minmax . max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Query { int L , R ; } ; void printQuerySums ( int a [ ] , int n , Query q [ ] , int m ) { for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] . L , R = q [ i ] . R ; int sum = 0 ; for ( int j = L ; j <= R ; j ++ ) sum += a [ j ] ; cout << " Sum ▁ of ▁ [ " << L << " , ▁ " << R << " ] ▁ is ▁ " << sum << endl ; } } int main ( ) { int a [ ] = { 1 , 1 , 2 , 1 , 3 , 4 , 5 , 2 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Query q [ ] = { { 0 , 4 } , { 1 , 3 } , { 2 , 4 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; printQuerySums ( a , n , q , m ) ; return 0 ; }
#include " iostream " NEW_LINE #include " math . h " NEW_LINE using namespace std ; #define MAXN  10000 NEW_LINE #define SQRSIZE  100 NEW_LINE int arr [ MAXN ] ; int block [ SQRSIZE ] ; int blk_sz ; void update ( int idx , int val ) { int blockNumber = idx / blk_sz ; block [ blockNumber ] += val - arr [ idx ] ; arr [ idx ] = val ; } int query ( int l , int r ) { int sum = 0 ; while ( l < r and l % blk_sz != 0 and l != 0 ) { sum += arr [ l ] ; l ++ ; } while ( l + blk_sz <= r ) { sum += block [ l / blk_sz ] ; l += blk_sz ; } while ( l <= r ) { sum += arr [ l ] ; l ++ ; } return sum ; } void preprocess ( int input [ ] , int n ) { int blk_idx = -1 ; blk_sz = sqrt ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = input [ i ] ; if ( i % blk_sz == 0 ) { blk_idx ++ ; } block [ blk_idx ] += arr [ i ] ; } } int main ( ) { int input [ ] = { 1 , 5 , 2 , 4 , 6 , 1 , 3 , 5 , 7 , 10 } ; int n = sizeof ( input ) / sizeof ( input [ 0 ] ) ; preprocess ( input , n ) ; cout << " query ( 3,8 ) ▁ : ▁ " << query ( 3 , 8 ) << endl ; cout << " query ( 1,6 ) ▁ : ▁ " << query ( 1 , 6 ) << endl ; update ( 8 , 0 ) ; cout << " query ( 8,8 ) ▁ : ▁ " << query ( 8 , 8 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  500 NEW_LINE int lookup [ MAX ] [ MAX ] ; void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( lookup [ i ] [ j - 1 ] < lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } } int query ( int L , int R ) { int j = ( int ) log2 ( R - L + 1 ) ; if ( lookup [ L ] [ j ] <= lookup [ R - ( 1 << j ) + 1 ] [ j ] ) return lookup [ L ] [ j ] ; else return lookup [ R - ( 1 << j ) + 1 ] [ j ] ; } int main ( ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; buildSparseTable ( a , n ) ; cout << query ( 0 , 4 ) << endl ; cout << query ( 4 , 7 ) << endl ; cout << query ( 7 , 8 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  500 NEW_LINE int table [ MAX ] [ MAX ] ; void buildSparseTable ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) table [ i ] [ 0 ] = arr [ i ] ; for ( int j = 1 ; j <= n ; j ++ ) for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) table [ i ] [ j ] = __gcd ( table [ i ] [ j - 1 ] , table [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } int query ( int L , int R ) { int j = ( int ) log2 ( R - L + 1 ) ; return __gcd ( table [ L ] [ j ] , table [ R - ( 1 << j ) + 1 ] [ j ] ) ; } int main ( ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; buildSparseTable ( a , n ) ; cout << query ( 0 , 2 ) << endl ; cout << query ( 1 , 3 ) << endl ; cout << query ( 4 , 5 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  500 NEW_LINE int lookup [ MAX ] [ MAX ] ; struct Query { int L , R ; } ; void preprocess ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ i ] = i ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ lookup [ i ] [ j - 1 ] ] < arr [ j ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = j ; } } void RMQ ( int arr [ ] , int n , Query q [ ] , int m ) { preprocess ( arr , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] . L , R = q [ i ] . R ; cout << " Minimum ▁ of ▁ [ " << L << " , ▁ " << R << " ] ▁ is ▁ " << arr [ lookup [ L ] [ R ] ] << endl ; } } int main ( ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Query q [ ] = { { 0 , 4 } , { 4 , 7 } , { 7 , 8 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; RMQ ( a , n , q , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  500 NEW_LINE int lookup [ MAX ] [ MAX ] ; struct Query { int L , R ; } ; void preprocess ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = i ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( arr [ lookup [ i ] [ j - 1 ] ] < arr [ lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } } int query ( int arr [ ] , int L , int R ) { int j = ( int ) log2 ( R - L + 1 ) ; if ( arr [ lookup [ L ] [ j ] ] <= arr [ lookup [ R - ( 1 << j ) + 1 ] [ j ] ] ) return arr [ lookup [ L ] [ j ] ] ; else return arr [ lookup [ R - ( 1 << j ) + 1 ] [ j ] ] ; } void RMQ ( int arr [ ] , int n , Query q [ ] , int m ) { preprocess ( arr , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] . L , R = q [ i ] . R ; cout << " Minimum ▁ of ▁ [ " << L << " , ▁ " << R << " ] ▁ is ▁ " << query ( arr , L , R ) << endl ; } } int main ( ) { int a [ ] = { 7 , 2 , 3 , 0 , 5 , 10 , 3 , 12 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Query q [ ] = { { 0 , 4 } , { 4 , 7 } , { 7 , 8 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; RMQ ( a , n , q , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumNodes ( int l ) { int leafNodeCount = pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; int sum = sumLastLevel * l ; return sum ; } int main ( ) { int l = 3 ; cout << sumNodes ( l ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void add ( int arr [ ] , int N , int lo , int hi , int val ) { arr [ lo ] += val ; if ( hi != N - 1 ) arr [ hi + 1 ] -= val ; } void updateArray ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) arr [ i ] += arr [ i - 1 ] ; } void printArr ( int arr [ ] , int N ) { updateArray ( arr , N ) ; for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int N = 6 ; int arr [ N ] = { 0 } ; add ( arr , N , 0 , 2 , 100 ) ; add ( arr , N , 1 , 5 , 100 ) ; add ( arr , N , 2 , 3 , 100 ) ; printArr ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int * st ; int constructST ( int arr [ ] , int ss , int se , int si ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return st [ si ] ; } int mid = ss + ( se - ss ) / 2 ; st [ si ] = __gcd ( constructST ( arr , ss , mid , si * 2 + 1 ) , constructST ( arr , mid + 1 , se , si * 2 + 2 ) ) ; return st [ si ] ; } int * constructSegmentTree ( int arr [ ] , int n ) { int height = ( int ) ( ceil ( log2 ( n ) ) ) ; int size = 2 * ( int ) pow ( 2 , height ) - 1 ; st = new int [ size ] ; constructST ( arr , 0 , n - 1 , 0 ) ; return st ; } int findGcd ( int ss , int se , int qs , int qe , int si ) { if ( ss > qe se < qs ) return 0 ; if ( qs <= ss && qe >= se ) return st [ si ] ; int mid = ss + ( se - ss ) / 2 ; return __gcd ( findGcd ( ss , mid , qs , qe , si * 2 + 1 ) , findGcd ( mid + 1 , se , qs , qe , si * 2 + 2 ) ) ; } int findRangeGcd ( int ss , int se , int arr [ ] , int n ) { if ( ss < 0 se > n -1 ss > se ) { cout << " Invalid ▁ Arguments " << " STRNEWLINE " ; return - 1 ; } return findGcd ( 0 , n - 1 , ss , se , 0 ) ; } int main ( ) { int a [ ] = { 2 , 3 , 6 , 9 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; constructSegmentTree ( a , n ) ; int l = 1 ; int r = 3 ; cout << " GCD ▁ of ▁ the ▁ given ▁ range ▁ is : " ; cout << findRangeGcd ( l , r , a , n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void FillPrefixSuffix ( int prefix [ ] , int arr [ ] , int suffix [ ] , int n ) { prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = __gcd ( prefix [ i - 1 ] , arr [ i ] ) ; suffix [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix [ i ] = __gcd ( suffix [ i + 1 ] , arr [ i ] ) ; } int GCDoutsideRange ( int l , int r , int prefix [ ] , int suffix [ ] , int n ) { if ( l == 0 ) return suffix [ r + 1 ] ; if ( r == n - 1 ) return prefix [ l - 1 ] ; return __gcd ( prefix [ l - 1 ] , suffix [ r + 1 ] ) ; } int main ( ) { int arr [ ] = { 2 , 6 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int prefix [ n ] , suffix [ n ] ; FillPrefixSuffix ( prefix , arr , suffix , n ) ; int l = 0 , r = 0 ; cout << GCDoutsideRange ( l , r , prefix , suffix , n ) << endl ; l = 1 ; r = 1 ; cout << GCDoutsideRange ( l , r , prefix , suffix , n ) << endl ; l = 1 ; r = 2 ; cout << GCDoutsideRange ( l , r , prefix , suffix , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10001 ; void update ( int idx , int blk , int val , int bit [ ] [ MAX ] ) { for ( ; idx < MAX ; idx += ( idx & - idx ) ) bit [ blk ] [ idx ] += val ; } int query ( int l , int r , int k , int arr [ ] , int blk_sz , int bit [ ] [ MAX ] ) { int sum = 0 ; while ( l < r && l % blk_sz != 0 && l != 0 ) { if ( arr [ l ] <= k ) sum ++ ; l ++ ; } while ( l + blk_sz <= r ) { int idx = k ; for ( ; idx > 0 ; idx -= idx & - idx ) sum += bit [ l / blk_sz ] [ idx ] ; l += blk_sz ; } while ( l <= r ) { if ( arr [ l ] <= k ) sum ++ ; l ++ ; } return sum ; } void preprocess ( int arr [ ] , int blk_sz , int n , int bit [ ] [ MAX ] ) { for ( int i = 0 ; i < n ; i ++ ) update ( arr [ i ] , i / blk_sz , 1 , bit ) ; } void preprocessUpdate ( int i , int v , int blk_sz , int arr [ ] , int bit [ ] [ MAX ] ) { update ( arr [ i ] , i / blk_sz , -1 , bit ) ; update ( v , i / blk_sz , 1 , bit ) ; arr [ i ] = v ; } int main ( ) { int arr [ ] = { 5 , 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int blk_sz = sqrt ( n ) ; int bit [ blk_sz + 1 ] [ MAX ] ; memset ( bit , 0 , sizeof ( bit ) ) ; preprocess ( arr , blk_sz , n , bit ) ; cout << query ( 1 , 3 , 1 , arr , blk_sz , bit ) << endl ; preprocessUpdate ( 3 , 10 , blk_sz , arr , bit ) ; cout << query ( 3 , 3 , 4 , arr , blk_sz , bit ) << endl ; preprocessUpdate ( 2 , 1 , blk_sz , arr , bit ) ; preprocessUpdate ( 0 , 2 , blk_sz , arr , bit ) ; cout << query ( 0 , 4 , 5 , arr , blk_sz , bit ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 9 , 10 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int i = 1 , j = 4 ; cout << countInRange ( arr , n , i , j ) << endl ; i = 9 , j = 12 ; cout << countInRange ( arr , n , i , j ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void precompute ( int arr [ ] , int n , int pre [ ] ) { memset ( pre , 0 , n * sizeof ( int ) ) ; pre [ n - 1 ] = arr [ n - 1 ] * pow ( 2 , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) pre [ i ] = pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ; } int decimalOfSubarr ( int arr [ ] , int l , int r , int n , int pre [ ] ) { if ( r != n - 1 ) return ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ; return pre [ l ] / ( 1 << ( n - 1 - r ) ) ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int pre [ n ] ; precompute ( arr , n , pre ) ; cout << decimalOfSubarr ( arr , 2 , 4 , n , pre ) << endl ; cout << decimalOfSubarr ( arr , 4 , 5 , n , pre ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int answerQuery ( int a [ ] , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int l = 1 , r = 4 ; cout << answerQuery ( a , n , l , r ) << endl ; l = 2 , r = 4 ; cout << answerQuery ( a , n , l , r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  2147483647 NEW_LINE int one [ 100001 ] [ 32 ] ; void make_prefix ( int A [ ] , int n ) { for ( int j = 0 ; j < 32 ; j ++ ) one [ 0 ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int a = A [ i - 1 ] ; for ( int j = 0 ; j < 32 ; j ++ ) { int x = pow ( 2 , j ) ; if ( a & x ) one [ i ] [ j ] = 1 + one [ i - 1 ] [ j ] ; else one [ i ] [ j ] = one [ i - 1 ] [ j ] ; } } } int Solve ( int L , int R ) { int l = L , r = R ; int tot_bits = r - l + 1 ; int X = MAX ; for ( int i = 0 ; i < 31 ; i ++ ) { int x = one [ r ] [ i ] - one [ l - 1 ] [ i ] ; if ( x >= tot_bits - x ) { int ith_bit = pow ( 2 , i ) ; X = X ^ ith_bit ; } } return X ; } int main ( ) { int n = 5 , q = 3 ; int A [ ] = { 210 , 11 , 48 , 22 , 133 } ; int L [ ] = { 1 , 4 , 2 } , R [ ] = { 3 , 14 , 4 } ; make_prefix ( A , n ) ; for ( int j = 0 ; j < q ; j ++ ) cout << Solve ( L [ j ] , R [ j ] ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void record_sum ( int record [ ] , int l , int r , int n , int adder ) { for ( int i = l ; i <= r ; i ++ ) record [ i ] += adder ; } int main ( ) { int n = 5 , m = 5 ; int arr [ n ] ; memset ( arr , 0 , sizeof arr ) ; int query [ 5 ] [ 3 ] = { { 1 , 1 , 2 } , { 1 , 4 , 5 } , { 2 , 1 , 2 } , { 2 , 1 , 3 } , { 2 , 3 , 4 } } ; int record [ m ] ; memset ( record , 0 , sizeof record ) ; for ( int i = m - 1 ; i >= 0 ; i -- ) { if ( query [ i ] [ 0 ] == 2 ) record_sum ( record , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , m , record [ i ] + 1 ) ; else record_sum ( record , i , i , m , 1 ) ; } for ( int i = 0 ; i < m ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) record_sum ( arr , query [ i ] [ 1 ] - 1 , query [ i ] [ 2 ] - 1 , n , record [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << ' ▁ ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define max  10000 NEW_LINE using namespace std ; void update ( int arr [ ] , int l ) { arr [ l ] += arr [ l - 1 ] ; } void record_func ( int block_size , int block [ ] , int record [ ] , int l , int r , int value ) { while ( l < r && l % block_size != 0 && l != 0 ) { record [ l ] += value ; l ++ ; } while ( l + block_size <= r + 1 ) { block [ l / block_size ] += value ; l += block_size ; } while ( l <= r ) { record [ l ] += value ; l ++ ; } } void print ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int n = 5 , m = 5 ; int arr [ n ] , record [ m ] ; int block_size = sqrt ( m ) ; int block [ max ] ; int command [ 5 ] [ 3 ] = { { 1 , 1 , 2 } , { 1 , 4 , 5 } , { 2 , 1 , 2 } , { 2 , 1 , 3 } , { 2 , 3 , 4 } } ; memset ( arr , 0 , sizeof arr ) ; memset ( record , 0 , sizeof record ) ; memset ( block , 0 , sizeof block ) ; for ( int i = m - 1 ; i >= 0 ; i -- ) { if ( command [ i ] [ 0 ] == 2 ) { int x = i / ( block_size ) ; record_func ( block_size , block , record , command [ i ] [ 1 ] - 1 , command [ i ] [ 2 ] - 1 , ( block [ x ] + record [ i ] + 1 ) ) ; } else record [ i ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { int check = ( i / block_size ) ; record [ i ] += block [ check ] ; } for ( int i = 0 ; i < m ; i ++ ) { if ( command [ i ] [ 0 ] == 1 ) { arr [ command [ i ] [ 1 ] - 1 ] += record [ i ] ; if ( ( command [ i ] [ 2 ] - 1 ) < n - 1 ) arr [ ( command [ i ] [ 2 ] ) ] -= record [ i ] ; } } for ( int i = 1 ; i < n ; i ++ ) update ( arr , i ) ; print ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void updateBIT ( int BITree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] = ( val + BITree [ index ] ) ; index = ( index + ( index & ( - index ) ) ) ; } return ; } int * constructBITree ( int n ) { int * BITree = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BITree [ i ] = 0 ; return BITree ; } int getSum ( int BITree [ ] , int index ) { int sum = 0 ; index = index + 1 ; while ( index > 0 ) { sum = ( sum + BITree [ index ] ) ; index -= index & ( - index ) ; } return sum ; } void update ( int BITree [ ] , int l , int r , int n , int val ) { updateBIT ( BITree , n , l , val ) ; updateBIT ( BITree , n , r + 1 , - val ) ; return ; } int main ( ) { int n = 5 , m = 5 ; int temp [ 15 ] = { 1 , 1 , 2 , 1 , 4 , 5 , 2 , 1 , 2 , 2 , 1 , 3 , 2 , 3 , 4 } ; int q [ 5 ] [ 3 ] ; int j = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { q [ i ] [ 0 ] = temp [ j ++ ] ; q [ i ] [ 1 ] = temp [ j ++ ] ; q [ i ] [ 2 ] = temp [ j ++ ] ; } int * BITree = constructBITree ( m ) ; int * BITree2 = constructBITree ( n ) ; for ( int i = 1 ; i <= m ; i ++ ) cin >> q [ i ] [ 0 ] >> q [ i ] [ 1 ] >> q [ i ] [ 2 ] ; for ( int i = m ; i >= 1 ; i -- ) if ( q [ i ] [ 0 ] == 2 ) update ( BITree , q [ i ] [ 1 ] - 1 , q [ i ] [ 2 ] - 1 , m , 1 ) ; for ( int i = m ; i >= 1 ; i -- ) { if ( q [ i ] [ 0 ] == 2 ) { long int val = getSum ( BITree , i - 1 ) ; update ( BITree , q [ i ] [ 1 ] - 1 , q [ i ] [ 2 ] - 1 , m , val ) ; } } for ( int i = m ; i >= 1 ; i -- ) { if ( q [ i ] [ 0 ] == 1 ) { long int val = getSum ( BITree , i - 1 ) ; update ( BITree2 , q [ i ] [ 1 ] - 1 , q [ i ] [ 2 ] - 1 , n , ( val + 1 ) ) ; } } for ( int i = 1 ; i <= n ; i ++ ) cout << ( getSum ( BITree2 , i - 1 ) ) << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Query { int L , R , X ; } ; const int maxn = 100 ; int root [ maxn ] ; int find ( int x ) { return x == root [ x ] ? x : root [ x ] = find ( root [ x ] ) ; } int uni ( int x , int y ) { int p = find ( x ) , q = find ( y ) ; if ( p != q ) { root [ p ] = root [ q ] ; } } void initialize ( int a [ ] , int n , Query q [ ] , int m ) { for ( int i = 0 ; i < n ; i ++ ) root [ i ] = i ; for ( int i = 1 ; i < n ; i ++ ) if ( a [ i ] == a [ i - 1 ] ) uni ( i , i - 1 ) ; } int main ( ) { int a [ ] = { 1 , 1 , 5 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Query q [ ] = { { 0 , 2 , 2 } , { 1 , 4 , 1 } , { 2 , 4 , 5 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; initialize ( a , n , q , m ) ; for ( int i = 0 ; i < m ; i ++ ) { int flag = 0 ; int l = q [ i ] . L , r = q [ i ] . R , x = q [ i ] . X ; int p = r ; while ( p >= l ) { if ( a [ p ] == x ) { flag = 1 ; break ; } p = find ( p ) - 1 ; } if ( flag != 0 ) cout << x << " ▁ exists ▁ between ▁ [ " << l << " , ▁ " << r << " ] ▁ " << endl ; else cout << x << " ▁ does ▁ not ▁ exist ▁ between ▁ [ " << l << " , ▁ " << r << " ] ▁ " << endl ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solveQuery ( int start , int end , int arr [ ] ) { unordered_map < int , int > frequency ; for ( int i = start ; i <= end ; i ++ ) frequency [ arr [ i ] ] ++ ; int count = 0 ; for ( auto x : frequency ) if ( x . first == x . second ) count ++ ; return count ; } int main ( ) { int A [ ] = { 1 , 2 , 2 , 3 , 3 , 3 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int queries [ ] [ 3 ] = { { 0 , 1 } , { 1 , 1 } , { 0 , 2 } , { 1 , 3 } , { 3 , 5 } , { 0 , 5 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) { int start = queries [ i ] [ 0 ] ; int end = queries [ i ] [ 1 ] ; cout << " Answer ▁ for ▁ Query ▁ " << ( i + 1 ) << " ▁ = ▁ " << solveQuery ( start , end , A ) << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int answer_query ( int a [ ] , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; } int main ( ) { int a [ ] = { 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int L , R ; L = 1 ; R = 8 ; cout << answer_query ( a , n , L , R ) << endl ; L = 0 ; R = 4 ; cout << answer_query ( a , n , L , R ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; map < int , int > grid ; struct Node * newNode ( int data ) { struct Node * Node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; Node -> data = data ; Node -> left = Node -> right = NULL ; return Node ; } void addConsideringGrid ( Node * root , int level , int index ) { if ( root == NULL ) return ; grid [ level - index ] += ( root -> data ) ; addConsideringGrid ( root -> left , level + 1 , index - 1 ) ; addConsideringGrid ( root -> right , level + 1 , index + 1 ) ; } vector < int > diagonalSum ( Node * root ) { grid . clear ( ) ; addConsideringGrid ( root , 0 , 0 ) ; vector < int > ans ; for ( auto x : grid ) { ans . push_back ( x . second ) ; } return ans ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 9 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 5 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> left -> left = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 11 ) ; root -> left -> left -> right = newNode ( 10 ) ; vector < int > v = diagonalSum ( root ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1000 ; int prefixans [ N ] ; int countIndex ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == a [ i + 1 ] ) prefixans [ i ] = 1 ; if ( i != 0 ) prefixans [ i ] += prefixans [ i - 1 ] ; } } int answer_query ( int l , int r ) { if ( l == 0 ) return prefixans [ r - 1 ] ; else return prefixans [ r - 1 ] - prefixans [ l - 1 ] ; } int main ( ) { int a [ ] = { 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; countIndex ( a , n ) ; int L , R ; L = 1 ; R = 8 ; cout << answer_query ( L , R ) << endl ; L = 0 ; R = 4 ; cout << answer_query ( L , R ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int repeated_digit ( int n ) { unordered_set < int > s ; while ( n != 0 ) { int d = n % 10 ; if ( s . find ( d ) != s . end ( ) ) { return 0 ; } s . insert ( d ) ; n = n / 10 ; } return 1 ; } int calculate ( int L , int R ) { int answer = 0 ; for ( int i = L ; i < R + 1 ; ++ i ) { answer = answer + repeated_digit ( i ) ; } return answer ; } int main ( ) { int L = 1 , R = 100 ; cout << calculate ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MAX = 1000 ; vector < int > Prefix = { 0 } ; int repeated_digit ( int n ) { unordered_set < int > a ; int d ; while ( n != 0 ) { d = n % 10 ; if ( a . find ( d ) != a . end ( ) ) return 0 ; a . insert ( d ) ; n = n / 10 ; } return 1 ; } void pre_calculation ( int MAX ) { Prefix . push_back ( repeated_digit ( 1 ) ) ; for ( int i = 2 ; i < MAX + 1 ; i ++ ) Prefix . push_back ( repeated_digit ( i ) + Prefix [ i - 1 ] ) ; } int calculate ( int L , int R ) { return Prefix [ R ] - Prefix [ L - 1 ] ; } int main ( ) { int L = 1 , R = 100 ; pre_calculation ( MAX ) ; cout << calculate ( L , R ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > initializeDiffArray ( vector < int > & A ) { int n = A . size ( ) ; vector < int > D ( n + 1 ) ; D [ 0 ] = A [ 0 ] , D [ n ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) D [ i ] = A [ i ] - A [ i - 1 ] ; return D ; } void update ( vector < int > & D , int l , int r , int x ) { D [ l ] += x ; D [ r + 1 ] -= x ; } int printArray ( vector < int > & A , vector < int > & D ) { for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( i == 0 ) A [ i ] = D [ i ] ; else A [ i ] = D [ i ] + A [ i - 1 ] ; cout << A [ i ] << " ▁ " ; } cout << endl ; } int main ( ) { vector < int > A { 10 , 5 , 20 , 40 } ; vector < int > D = initializeDiffArray ( A ) ; update ( D , 0 , 1 , 10 ) ; printArray ( A , D ) ; update ( D , 1 , 3 , 20 ) ; update ( D , 2 , 2 , 30 ) ; printArray ( A , D ) ; return 0 ; }
#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } int main ( ) { int a [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int max_sum = maxSubArraySum ( a , n ) ; cout << " Maximum ▁ contiguous ▁ sum ▁ is ▁ " << max_sum ; return 0 ; }
#include <climits> NEW_LINE int maxSubarraySum ( int arr [ ] , int size ) { int max_ending_here = 0 , max_so_far = INT_MIN ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] <= max_ending_here + arr [ i ] ) { max_ending_here += arr [ i ] ; } else { max_ending_here = arr [ i ] ; } if ( max_ending_here > max_so_far ) max_so_far = max_ending_here ; } return max_so_far ; }
#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } cout << " Maximum ▁ contiguous ▁ sum ▁ is ▁ " << max_so_far << endl ; cout << " Starting ▁ index ▁ " << start << endl << " Ending ▁ index ▁ " << end << endl ; } int main ( ) { int a [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int max_sum = maxSubArraySum ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int main ( ) { int price [ ] = { 2 , 30 , 15 , 10 , 8 , 25 , 80 } ; int n = 7 ; int profit = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int sub = price [ i ] - price [ i - 1 ] ; if ( sub > 0 ) profit += sub ; } cout << " Maximum ▁ Profit = " << profit ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newnode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } bool printPathUtil ( Node * node , unordered_set < int > & s , int root_data ) { if ( node == NULL ) return false ; int rem = root_data - node -> data ; if ( s . find ( rem ) != s . end ( ) ) return true ; s . insert ( node -> data ) ; bool res = printPathUtil ( node -> left , s , root_data ) || printPathUtil ( node -> right , s , root_data ) ; s . erase ( node -> data ) ; return res ; } bool isPathSum ( Node * root ) { unordered_set < int > s ; return printPathUtil ( root -> left , s , root -> data ) || printPathUtil ( root -> right , s , root -> data ) ; } int main ( ) { struct Node * root = newnode ( 8 ) ; root -> left = newnode ( 5 ) ; root -> right = newnode ( 4 ) ; root -> left -> left = newnode ( 9 ) ; root -> left -> right = newnode ( 7 ) ; root -> left -> right -> left = newnode ( 1 ) ; root -> left -> right -> right = newnode ( 12 ) ; root -> left -> right -> right -> right = newnode ( 2 ) ; root -> right -> right = newnode ( 11 ) ; root -> right -> right -> left = newnode ( 3 ) ; isPathSum ( root ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinAvgSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } cout << " Subarray ▁ between ▁ [ " << res_index << " , ▁ " << res_index + k - 1 << " ] ▁ has ▁ minimum ▁ average " ; } int main ( ) { int arr [ ] = { 3 , 7 , 90 , 20 , 10 , 50 , 40 } ; int k = 3 ; int n = sizeof arr / sizeof arr [ 0 ] ; findMinAvgSubarray ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minJumps ( int arr [ ] , int n ) { int * jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = INT_MAX ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = INT_MAX ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != INT_MAX ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 6 , 1 , 0 , 9 } ; int size = sizeof ( arr ) / sizeof ( int ) ; cout << " Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach " << " ▁ end ▁ is ▁ " << minJumps ( arr , size ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int smallestSubWithSum ( int arr [ ] , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; } int main ( ) { int arr1 [ ] = { 1 , 4 , 45 , 6 , 10 , 19 } ; int x = 51 ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int res1 = smallestSubWithSum ( arr1 , n1 , x ) ; ( res1 == n1 + 1 ) ? cout << " Not ▁ possible STRNEWLINE " : cout << res1 << endl ; int arr2 [ ] = { 1 , 10 , 5 , 2 , 7 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; x = 9 ; int res2 = smallestSubWithSum ( arr2 , n2 , x ) ; ( res2 == n2 + 1 ) ? cout << " Not ▁ possible STRNEWLINE " : cout << res2 << endl ; int arr3 [ ] = { 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; x = 280 ; int res3 = smallestSubWithSum ( arr3 , n3 , x ) ; ( res3 == n3 + 1 ) ? cout << " Not ▁ possible STRNEWLINE " : cout << res3 << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return newNode ; } void sumOfLongRootToLeafPath ( Node * root , int sum , int len , int & maxLen , int & maxSum ) { if ( ! root ) { if ( maxLen < len ) { maxLen = len ; maxSum = sum ; } else if ( maxLen == len && maxSum < sum ) maxSum = sum ; return ; } sumOfLongRootToLeafPath ( root -> left , sum + root -> data , len + 1 , maxLen , maxSum ) ; sumOfLongRootToLeafPath ( root -> right , sum + root -> data , len + 1 , maxLen , maxSum ) ; } int sumOfLongRootToLeafPathUtil ( Node * root ) { if ( ! root ) return 0 ; int maxSum = INT_MIN , maxLen = 0 ; sumOfLongRootToLeafPath ( root , 0 , 0 , maxLen , maxSum ) ; return maxSum ; } int main ( ) { Node * root = getNode ( 4 ) ; root -> left = getNode ( 2 ) ; root -> right = getNode ( 5 ) ; root -> left -> left = getNode ( 7 ) ; root -> left -> right = getNode ( 1 ) ; root -> right -> left = getNode ( 2 ) ; root -> right -> right = getNode ( 3 ) ; root -> left -> right -> left = getNode ( 6 ) ; cout << " Sum ▁ = ▁ " << sumOfLongRootToLeafPathUtil ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int * csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } delete [ ] csum ; return max_end - k + 1 ; } int main ( ) { int arr [ ] = { 1 , 12 , -5 , -6 , 50 , 3 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ maximum ▁ average ▁ subarray ▁ of ▁ " " length ▁ " << k << " ▁ begins ▁ at ▁ index ▁ " << findMaxAverage ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return -1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } int main ( ) { int arr [ ] = { 1 , 12 , -5 , -6 , 50 , 3 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ maximum ▁ average ▁ subarray ▁ of ▁ " " length ▁ " << k << " ▁ begins ▁ at ▁ index ▁ " << findMaxAverage ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinOperations ( unsigned int target [ ] , int n ) { int result = 0 ; while ( 1 ) { int zero_count = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( target [ i ] & 1 ) break ; else if ( target [ i ] == 0 ) zero_count ++ ; } if ( zero_count == n ) return result ; if ( i == n ) { for ( int j = 0 ; j < n ; j ++ ) target [ j ] = target [ j ] / 2 ; result ++ ; } for ( int j = i ; j < n ; j ++ ) { if ( target [ j ] & 1 ) { target [ j ] -- ; result ++ ; } } } } int main ( ) { unsigned int arr [ ] = { 16 , 16 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ steps ▁ required ▁ to ▁ " " get ▁ the ▁ given ▁ target ▁ array ▁ is ▁ " << countMinOperations ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinOps ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 , j = n - 1 ; i <= j ; ) { if ( arr [ i ] == arr [ j ] ) { i ++ ; j -- ; } else if ( arr [ i ] > arr [ j ] ) { j -- ; arr [ j ] += arr [ j + 1 ] ; ans ++ ; } else { i ++ ; arr [ i ] += arr [ i - 1 ] ; ans ++ ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 4 , 5 , 9 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ minimum ▁ operations ▁ is ▁ " << findMinOps ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSmallest ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 4 , 5 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << findSmallest ( arr1 , n1 ) << endl ; int arr2 [ ] = { 1 , 2 , 6 , 10 , 11 , 15 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << findSmallest ( arr2 , n2 ) << endl ; int arr3 [ ] = { 1 , 1 , 1 , 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << findSmallest ( arr3 , n3 ) << endl ; int arr4 [ ] = { 1 , 1 , 3 , 4 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << findSmallest ( arr4 , n4 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDiff ( int arr [ ] , int n ) { int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] ) ; return diff ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 19 , 18 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ difference ▁ is ▁ " << findMinDiff ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDiff ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 19 , 18 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ difference ▁ is ▁ " << findMinDiff ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int a = 2 , b = 10 ; int size = abs ( b - a ) + 1 ; int * array = new int [ size ] ; for ( int i = a ; i <= b ; i ++ ) if ( i % 2 == 0 i % 5 == 0 ) array [ i - a ] = 1 ; cout << " MULTIPLES ▁ of ▁ 2 ▁ and ▁ 5 : STRNEWLINE " ; for ( int i = a ; i <= b ; i ++ ) if ( array [ i - a ] == 1 ) cout << i << " ▁ " ; return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int max ( int l , int r ) { return ( l > r ? l : r ) ; } struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void print ( struct Node * root ) { if ( root != NULL ) { print ( root -> left ) ; printf ( " % d ▁ " , root -> data ) ; print ( root -> right ) ; } } struct Node * pruneUtil ( struct Node * root , int k , int * sum ) { if ( root == NULL ) return NULL ; int lsum = * sum + ( root -> data ) ; int rsum = lsum ; root -> left = pruneUtil ( root -> left , k , & lsum ) ; root -> right = pruneUtil ( root -> right , k , & rsum ) ; * sum = max ( lsum , rsum ) ; if ( * sum < k ) { free ( root ) ; root = NULL ; } return root ; } struct Node * prune ( struct Node * root , int k ) { int sum = 0 ; return pruneUtil ( root , k , & sum ) ; } int main ( ) { int k = 45 ; struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 12 ) ; root -> right -> right -> left = newNode ( 10 ) ; root -> right -> right -> left -> right = newNode ( 11 ) ; root -> left -> left -> right -> left = newNode ( 13 ) ; root -> left -> left -> right -> right = newNode ( 14 ) ; root -> left -> left -> right -> right -> left = newNode ( 15 ) ; printf ( " Tree ▁ before ▁ truncation STRNEWLINE " ) ; print ( root ) ; root = prune ( root , k ) ; printf ( " Tree after truncation " print ( root ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; Node ( int data ) { this -> data = data ; left = right = NULL ; } } ; void printPostorder ( struct Node * node ) { if ( node == NULL ) return ; printPostorder ( node -> left ) ; printPostorder ( node -> right ) ; cout << node -> data << " ▁ " ; } void printInorder ( struct Node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; cout << node -> data << " ▁ " ; printInorder ( node -> right ) ; } void printPreorder ( struct Node * node ) { if ( node == NULL ) return ; cout << node -> data << " ▁ " ; printPreorder ( node -> left ) ; printPreorder ( node -> right ) ; } int main ( ) { struct Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> left -> left = new Node ( 4 ) ; root -> left -> right = new Node ( 5 ) ; cout << " Preorder traversal of binary tree is " ; printPreorder ( root ) ; cout << " Inorder traversal of binary tree is " ; printInorder ( root ) ; cout << " Postorder traversal of binary tree is " ; printPostorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkbit ( int array [ ] , int index ) { return array [ index >> 5 ] & ( 1 << ( index & 31 ) ) ; } void setbit ( int array [ ] , int index ) { array [ index >> 5 ] |= ( 1 << ( index & 31 ) ) ; } int main ( ) { int a = 2 , b = 10 ; int size = abs ( b - a ) ; size = ceil ( size / 32 ) ; int * array = new int [ size ] ; for ( int i = a ; i <= b ; i ++ ) if ( i % 2 == 0 i % 5 == 0 ) setbit ( array , i - a ) ; cout << " MULTIPLES ▁ of ▁ 2 ▁ and ▁ 5 : STRNEWLINE " ; for ( int i = a ; i <= b ; i ++ ) if ( checkbit ( array , i - a ) ) cout << i << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestCommonSum ( bool arr1 [ ] , bool arr2 [ ] , int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; } int main ( ) { bool arr1 [ ] = { 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; bool arr2 [ ] = { 1 , 1 , 1 , 1 , 1 , 0 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << " Length ▁ of ▁ the ▁ longest ▁ common ▁ span ▁ with ▁ same ▁ " " sum ▁ is ▁ " << longestCommonSum ( arr1 , arr2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestCommonSum ( bool arr1 [ ] , bool arr2 [ ] , int n ) { int arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr1 [ i ] - arr2 [ i ] ; unordered_map < int , int > hM ; int sum = 0 ; int max_len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 0 ) max_len = i + 1 ; if ( hM . find ( sum ) != hM . end ( ) ) max_len = max ( max_len , i - hM [ sum ] ) ; else hM [ sum ] = i ; } return max_len ; } int main ( ) { bool arr1 [ ] = { 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; bool arr2 [ ] = { 1 , 1 , 1 , 1 , 1 , 0 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << longestCommonSum ( arr1 , arr2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrange ( int arr [ ] , int n , int x ) { multimap < int , int > m ; multimap < int , int > :: iterator it ; for ( int i = 0 ; i < n ; i ++ ) m . insert ( make_pair ( abs ( x - arr [ i ] ) , arr [ i ] ) ) ; int i = 0 ; for ( it = m . begin ( ) ; it != m . end ( ) ; it ++ ) arr [ i ++ ] = ( * it ) . second ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 9 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 7 ; rearrange ( arr , n , x ) ; printArray ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void swap ( int * x , int * y ) { int temp = * x ; * x = * y ; * y = temp ; } void sortInWave ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i += 2 ) { if ( i > 0 && arr [ i - 1 ] > arr [ i ] ) swap ( & arr [ i ] , & arr [ i - 1 ] ) ; if ( i < n - 1 && arr [ i ] < arr [ i + 1 ] ) swap ( & arr [ i ] , & arr [ i + 1 ] ) ; } } int main ( ) { int arr [ ] = { 10 , 90 , 49 , 2 , 1 , 5 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortInWave ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void print ( struct Node * root ) { if ( root != NULL ) { print ( root -> left ) ; cout << root -> data << " ▁ " ; print ( root -> right ) ; } } struct Node * prune ( struct Node * root , int sum ) { if ( root == NULL ) return NULL ; root -> left = prune ( root -> left , sum - root -> data ) ; root -> right = prune ( root -> right , sum - root -> data ) ; if ( root -> left == NULL && root -> right == NULL ) { if ( root -> data < sum ) { free ( root ) ; return NULL ; } } return root ; } int main ( ) { int k = 45 ; struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 12 ) ; root -> right -> right -> left = newNode ( 10 ) ; root -> right -> right -> left -> right = newNode ( 11 ) ; root -> left -> left -> right -> left = newNode ( 13 ) ; root -> left -> left -> right -> right = newNode ( 14 ) ; root -> left -> left -> right -> right -> left = newNode ( 15 ) ; cout << " Tree ▁ before ▁ truncation STRNEWLINE " ; print ( root ) ; root = prune ( root , k ) ; cout << " Tree after truncation " ; print ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { if ( A [ i ] != i + 1 ) swap ( A [ i ] , A [ i + 1 ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; } int main ( ) { int A [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; bool B [ ] = { 0 , 1 , 1 , 1 , 0 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( sortedAfterSwap ( A , B , n ) ) cout << " A ▁ can ▁ be ▁ sorted STRNEWLINE " ; else cout << " A ▁ can ▁ not ▁ be ▁ sorted STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else { type0 ++ ; } } } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , n ) ; for ( int a : arr ) cout << a << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool compare ( int x , int y ) { return abs ( x ) < abs ( y ) ; } void findMinSum ( int arr [ ] , int n ) { sort ( arr , arr + n , compare ) ; int min = INT_MAX , x , y ; for ( int i = 1 ; i < n ; i ++ ) { if ( abs ( arr [ i - 1 ] + arr [ i ] ) <= min ) { min = abs ( arr [ i - 1 ] + arr [ i ] ) ; x = i - 1 ; y = i ; } } cout << " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ " << arr [ x ] << " ▁ and ▁ " << arr [ y ] ; } int main ( ) { int arr [ ] = { 1 , 60 , -10 , 70 , -80 , 85 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMinSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool increasing ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] >= a [ i + 1 ] ) return false ; return true ; } bool decreasing ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] < a [ i + 1 ] ) return false ; return true ; } int shortestUnsorted ( int a [ ] , int n ) { if ( increasing ( a , n ) == true || decreasing ( a , n ) == true ) return 0 ; else return 3 ; } int main ( ) { int ar [ ] = { 7 , 9 , 10 , 8 , 11 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << shortestUnsorted ( ar , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new ( struct Node ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int max ( int a , int b ) { return ( a >= b ) ? a : b ; } int maxPathSumUtil ( struct Node * root , int & res ) { if ( root == NULL ) return 0 ; if ( ! root -> left && ! root -> right ) return root -> data ; int ls = maxPathSumUtil ( root -> left , res ) ; int rs = maxPathSumUtil ( root -> right , res ) ; if ( root -> left && root -> right ) { res = max ( res , ls + rs + root -> data ) ; return max ( ls , rs ) + root -> data ; } return ( ! root -> left ) ? rs + root -> data : ls + root -> data ; } int maxPathSum ( struct Node * root ) { int res = INT_MIN ; int val = maxPathSumUtil ( root , res ) ; if ( res == INT_MIN ) { return val ; } return res ; } int main ( ) { struct Node * root = newNode ( -15 ) ; root -> left = newNode ( 5 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( -8 ) ; root -> left -> right = newNode ( 1 ) ; root -> left -> left -> left = newNode ( 2 ) ; root -> left -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 3 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> right = newNode ( 0 ) ; root -> right -> right -> right -> left = newNode ( 4 ) ; root -> right -> right -> right -> right = newNode ( -1 ) ; root -> right -> right -> right -> right -> left = newNode ( 10 ) ; cout << " Max ▁ pathSum ▁ of ▁ the ▁ given ▁ binary ▁ tree ▁ is ▁ " << maxPathSum ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSwaps ( int arr [ ] , int n ) { pair < int , int > arrPos [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arrPos [ i ] . first = arr [ i ] ; arrPos [ i ] . second = i ; } sort ( arrPos , arrPos + n ) ; vector < bool > vis ( n , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] arrPos [ i ] . second == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = 1 ; j = arrPos [ j ] . second ; cycle_size ++ ; } if ( cycle_size > 0 ) { ans += ( cycle_size - 1 ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 4 , 3 , 2 } ; int n = ( sizeof ( arr ) / sizeof ( int ) ) ; cout << minSwaps ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } int indexOf ( vector < int > & arr , int ele ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] == ele ) { return i ; } } return -1 ; } int minSwaps ( vector < int > arr , int N ) { int ans = 0 ; vector < int > temp ( arr . begin ( ) , arr . end ( ) ) ; sort ( temp . begin ( ) , temp . end ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != temp [ i ] ) { ans ++ ; swap ( arr , i , indexOf ( arr , temp [ i ] ) ) ; } } return ans ; } int main ( ) { vector < int > a = { 101 , 758 , 315 , 730 , 472 , 619 , 460 , 479 } ; int n = a . size ( ) ; cout << minSwaps ( a , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( vector < int > & arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } int minSwaps ( vector < int > arr , int N ) { int ans = 0 ; vector < int > temp = arr ; map < int , int > h ; sort ( temp . begin ( ) , temp . end ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { h [ arr [ i ] ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != temp [ i ] ) { ans ++ ; int init = arr [ i ] ; swap ( arr , i , h [ temp [ i ] ] ) ; h [ init ] = h [ temp [ i ] ] ; h [ temp [ i ] ] = i ; } } return ans ; } int main ( ) { vector < int > a = { 101 , 758 , 315 , 730 , 472 , 619 , 460 , 479 } ; int n = a . size ( ) ; cout << minSwaps ( a , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) cout << arr1 [ i ++ ] << " ▁ " ; else if ( arr2 [ j ] < arr1 [ i ] ) cout << arr2 [ j ++ ] << " ▁ " ; else { cout << arr2 [ j ++ ] << " ▁ " ; i ++ ; } } while ( i < m ) cout << arr1 [ i ++ ] << " ▁ " ; while ( j < n ) cout << arr2 [ j ++ ] << " ▁ " ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printUnion ( arr1 , arr2 , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { cout << arr2 [ j ] << " ▁ " ; i ++ ; j ++ ; } } } int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printIntersection ( arr1 , arr2 , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUnion ( int * a , int n , int * b , int m ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp . insert ( { a [ i ] , i } ) ; for ( int i = 0 ; i < m ; i ++ ) mp . insert ( { b [ i ] , i } ) ; cout << " The ▁ union ▁ set ▁ of ▁ both ▁ arrays ▁ is ▁ : " << endl ; for ( auto itr = mp . begin ( ) ; itr != mp . end ( ) ; itr ++ ) cout << itr -> first << " ▁ " ; } int main ( ) { int a [ 7 ] = { 1 , 2 , 5 , 6 , 2 , 3 , 5 } ; int b [ 9 ] = { 2 , 4 , 5 , 6 , 8 , 9 , 4 , 6 , 5 } ; printUnion ( a , 7 , b , 9 ) ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int l , int r , int x ) ; void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { if ( m > n ) { int * tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } sort ( arr1 , arr1 + m ) ; for ( int i = 0 ; i < m ; i ++ ) cout << arr1 [ i ] << " ▁ " ; for ( int i = 0 ; i < n ; i ++ ) if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == -1 ) cout << arr2 [ i ] << " ▁ " ; } void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { if ( m > n ) { int * tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } sort ( arr1 , arr1 + m ) ; for ( int i = 0 ; i < n ; i ++ ) if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != -1 ) cout << arr2 [ i ] << " ▁ " ; } int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; } int main ( ) { int arr1 [ ] = { 7 , 1 , 5 , 2 , 3 , 6 } ; int arr2 [ ] = { 3 , 8 , 6 , 20 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << " Union ▁ of ▁ two ▁ arrays ▁ is ▁ n " ; printUnion ( arr1 , arr2 , m , n ) ; cout << " nIntersection ▁ of ▁ two ▁ arrays ▁ is ▁ n " ; printIntersection ( arr1 , arr2 , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; bool printPath ( node * root , node * target_leaf ) { if ( root == NULL ) return false ; if ( root == target_leaf || printPath ( root -> left , target_leaf ) || printPath ( root -> right , target_leaf ) ) { cout << root -> data << " ▁ " ; return true ; } return false ; } void getTargetLeaf ( node * Node , int * max_sum_ref , int curr_sum , node * * target_leaf_ref ) { if ( Node == NULL ) return ; curr_sum = curr_sum + Node -> data ; if ( Node -> left == NULL && Node -> right == NULL ) { if ( curr_sum > * max_sum_ref ) { * max_sum_ref = curr_sum ; * target_leaf_ref = Node ; } } getTargetLeaf ( Node -> left , max_sum_ref , curr_sum , target_leaf_ref ) ; getTargetLeaf ( Node -> right , max_sum_ref , curr_sum , target_leaf_ref ) ; } int maxSumPath ( node * Node ) { if ( Node == NULL ) return 0 ; node * target_leaf ; int max_sum = INT_MIN ; getTargetLeaf ( Node , & max_sum , 0 , & target_leaf ) ; printPath ( Node , target_leaf ) ; return max_sum ; } node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { node * root = NULL ; root = newNode ( 10 ) ; root -> left = newNode ( -2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( -4 ) ; cout << " Following ▁ are ▁ the ▁ nodes ▁ on ▁ the ▁ maximum ▁ " " sum ▁ path ▁ STRNEWLINE " ; int sum = maxSumPath ( root ) ; cout << " Sum of the nodes is " return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void intersection ( int a [ ] , int b [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) { j ++ ; } else if ( b [ j ] > a [ i ] ) { i ++ ; } else { cout << a [ i ] << " ▁ " ; i ++ ; j ++ ; } } } int main ( ) { int a [ ] = { 1 , 3 , 2 , 3 , 3 , 4 , 5 , 5 , 6 } ; int b [ ] = { 3 , 3 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; sort ( a , a + n ) ; sort ( b , b + m ) ; intersection ( a , b , n , m ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUnion ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { set < int > hs ; for ( int i = 0 ; i < n1 ; i ++ ) hs . insert ( arr1 [ i ] ) ; for ( int i = 0 ; i < n2 ; i ++ ) hs . insert ( arr2 [ i ] ) ; for ( auto it = hs . begin ( ) ; it != hs . end ( ) ; it ++ ) cout << * it << " ▁ " ; cout << endl ; } void printIntersection ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { set < int > hs ; for ( int i = 0 ; i < n1 ; i ++ ) hs . insert ( arr1 [ i ] ) ; for ( int i = 0 ; i < n2 ; i ++ ) if ( hs . find ( arr2 [ i ] ) != hs . end ( ) ) cout << arr2 [ i ] << " ▁ " ; } int main ( ) { int arr1 [ ] = { 7 , 1 , 5 , 2 , 3 , 6 } ; int arr2 [ ] = { 3 , 8 , 6 , 20 , 7 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printUnion ( arr1 , arr2 , n1 , n2 ) ; printIntersection ( arr1 , arr2 , n1 , n2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void sortArr ( int arr [ ] , int n ) { int i , cnt0 = 0 , cnt1 = 0 , cnt2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { switch ( arr [ i ] ) { case 0 : cnt0 ++ ; break ; case 1 : cnt1 ++ ; break ; case 2 : cnt2 ++ ; break ; } } i = 0 ; while ( cnt0 > 0 ) { arr [ i ++ ] = 0 ; cnt0 -- ; } while ( cnt1 > 0 ) { arr [ i ++ ] = 1 ; cnt1 -- ; } while ( cnt2 > 0 ) { arr [ i ++ ] = 2 ; cnt2 -- ; } printArr ( arr , n ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; sortArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CountTriangles ( vector < int > A ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; int count = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int l = 0 , r = i - 1 ; while ( l < r ) { if ( A [ l ] + A [ r ] > A [ i ] ) { count += r - l ; r -- ; } else l ++ ; } } cout << " No ▁ of ▁ possible ▁ solutions : ▁ " << count ; } int main ( ) { vector < int > A = { 4 , 3 , 5 , 7 , 6 } ; CountTriangles ( A ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * temp = new struct node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int sumOfGrandChildren ( node * node ) ; int getMaxSum ( node * node ) ; int getMaxSumUtil ( node * node , map < struct node * , int > & mp ) ; int sumOfGrandChildren ( node * node , map < struct node * , int > & mp ) { int sum = 0 ; if ( node -> left ) sum += getMaxSumUtil ( node -> left -> left , mp ) + getMaxSumUtil ( node -> left -> right , mp ) ; if ( node -> right ) sum += getMaxSumUtil ( node -> right -> left , mp ) + getMaxSumUtil ( node -> right -> right , mp ) ; return sum ; } int getMaxSumUtil ( node * node , map < struct node * , int > & mp ) { if ( node == NULL ) return 0 ; if ( mp . find ( node ) != mp . end ( ) ) return mp [ node ] ; int incl = node -> data + sumOfGrandChildren ( node , mp ) ; int excl = getMaxSumUtil ( node -> left , mp ) + getMaxSumUtil ( node -> right , mp ) ; mp [ node ] = max ( incl , excl ) ; return mp [ node ] ; } int getMaxSum ( node * node ) { if ( node == NULL ) return 0 ; map < struct node * , int > mp ; return getMaxSumUtil ( node , mp ) ; } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 1 ) ; cout << getMaxSum ( root ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE long long countPairsBruteForce ( long long X [ ] , long long Y [ ] , long long m , long long n ) { long long ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( pow ( X [ i ] , Y [ j ] ) > pow ( Y [ j ] , X [ i ] ) ) ans ++ ; return ans ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int x , int Y [ ] , int n , int NoOfY [ ] ) { if ( x == 0 ) return 0 ; if ( x == 1 ) return NoOfY [ 0 ] ; int * idx = upper_bound ( Y , Y + n , x ) ; int ans = ( Y + n ) - idx ; ans += ( NoOfY [ 0 ] + NoOfY [ 1 ] ) ; if ( x == 2 ) ans -= ( NoOfY [ 3 ] + NoOfY [ 4 ] ) ; if ( x == 3 ) ans += NoOfY [ 2 ] ; return ans ; } int countPairs ( int X [ ] , int Y [ ] , int m , int n ) { int NoOfY [ 5 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) if ( Y [ i ] < 5 ) NoOfY [ Y [ i ] ] ++ ; sort ( Y , Y + n ) ; int total_pairs = 0 ; for ( int i = 0 ; i < m ; i ++ ) total_pairs += count ( X [ i ] , Y , n , NoOfY ) ; return total_pairs ; } int main ( ) { int X [ ] = { 2 , 1 , 6 } ; int Y [ ] = { 1 , 5 } ; int m = sizeof ( X ) / sizeof ( X [ 0 ] ) ; int n = sizeof ( Y ) / sizeof ( Y [ 0 ] ) ; cout << " Total ▁ pairs ▁ = ▁ " << countPairs ( X , Y , m , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " << countPairsWithDiffK ( arr , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return -1 ; } int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 , i ; sort ( arr , arr + n ) ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != -1 ) count ++ ; return count ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " << countPairsWithDiffK ( arr , n , k ) ; return 0 ; }
#define MAX  100000 NEW_LINE int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; bool hashmap [ MAX ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) hashmap [ arr [ i ] ] = true ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; if ( x - k >= 0 && hashmap [ x - k ] ) count ++ ; if ( x + k < MAX && hashmap [ x + k ] ) count ++ ; hashmap [ x ] = false ; } return count ; }
#include <iostream> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ; sort ( arr , arr + n ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " << countPairsWithDiffK ( arr , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; class Node { public : int data ; Node * left , * right ; Node ( int data ) { this -> data = data ; left = NULL ; right = NULL ; } } ; pair < int , int > maxSumHelper ( Node * root ) { if ( root == NULL ) { pair < int , int > sum ( 0 , 0 ) ; return sum ; } pair < int , int > sum1 = maxSumHelper ( root -> left ) ; pair < int , int > sum2 = maxSumHelper ( root -> right ) ; pair < int , int > sum ; sum . first = sum1 . second + sum2 . second + root -> data ; sum . second = max ( sum1 . first , sum1 . second ) + max ( sum2 . first , sum2 . second ) ; return sum ; } int maxSum ( Node * root ) { pair < int , int > res = maxSumHelper ( root ) ; return max ( res . first , res . second ) ; } int main ( ) { Node * root = new Node ( 10 ) ; root -> left = new Node ( 1 ) ; root -> left -> left = new Node ( 2 ) ; root -> left -> left -> left = new Node ( 1 ) ; root -> left -> right = new Node ( 3 ) ; root -> left -> right -> left = new Node ( 4 ) ; root -> left -> right -> right = new Node ( 5 ) ; cout << maxSum ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; } int main ( ) { int pair [ ] = { 15 , 13 , 11 , 10 , 12 , 10 , 9 , 8 , 7 , 5 } ; int n = 5 ; int arr [ n ] ; constructArr ( arr , pair , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void merge ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = ar1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && ar1 [ j ] > ar2 [ i ] ; j -- ) ar1 [ j + 1 ] = ar1 [ j ] ; if ( j != m - 2 last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } } int main ( ) { int ar1 [ ] = { 1 , 5 , 9 , 10 , 15 , 20 } ; int ar2 [ ] = { 2 , 3 , 8 , 13 } ; int m = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; merge ( ar1 , ar2 , m , n ) ; cout << " After ▁ Merging ▁ nFirst ▁ Array : ▁ " ; for ( int i = 0 ; i < m ; i ++ ) cout << ar1 [ i ] << " ▁ " ; cout << " nSecond ▁ Array : ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << ar2 [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void merge ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 , k = n - 1 ; while ( i <= k and j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else { swap ( arr2 [ j ++ ] , arr1 [ k -- ] ) ; } } sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + m ) ; } int main ( ) { int ar1 [ ] = { 1 , 5 , 9 , 10 , 15 , 20 } ; int ar2 [ ] = { 2 , 3 , 8 , 13 } ; int m = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; merge ( ar1 , ar2 , m , n ) ; cout << " After ▁ Merging ▁ STRNEWLINE First ▁ Array : ▁ " ; for ( int i = 0 ; i < m ; i ++ ) cout << ar1 [ i ] << " ▁ " ; cout << " Second Array : " for ( int i = 0 ; i < n ; i ++ ) cout << ar2 [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { sort ( arr1 , arr1 + n1 ) ; sort ( arr2 , arr2 + n2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; } int main ( ) { int arr1 [ ] = { 10 , 2 , 3 , 6 , 4 , 1 } ; int arr2 [ ] = { 5 , 1 , 4 , 2 , 6 , 9 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n2 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << minMaxProduct ( arr1 , arr2 , n1 , n2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; } int main ( ) { int arr1 [ ] = { 10 , 2 , 3 , 6 , 4 , 1 } ; int arr2 [ ] = { 5 , 1 , 4 , 2 , 6 , 9 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n2 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << minMaxProduct ( arr1 , arr2 , n1 , n2 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; arr [ n ] = key ; return ( n + 1 ) ; } int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; cout << " Before Insertion : " for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; n = insertSorted ( arr , n , key , capacity ) ; cout << " After Insertion : " for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } int deleteElement ( int arr [ ] , int n , int key ) { int pos = findElement ( arr , n , key ) ; if ( pos == - 1 ) { cout << " Element ▁ not ▁ found " ; return n ; } int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; } int main ( ) { int i ; int arr [ ] = { 10 , 50 , 30 , 40 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; cout << " Array ▁ before ▁ deletion STRNEWLINE " ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; n = deleteElement ( arr , n , key ) ; cout << " Array after deletion " ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; Node ( int item ) { data = item ; } } ; int getSum ( Node * root ) ; int getSumAlternate ( Node * root ) { if ( root == NULL ) return 0 ; int sum = root -> data ; if ( root -> left != NULL ) { sum += getSum ( root -> left -> left ) ; sum += getSum ( root -> left -> right ) ; } if ( root -> right != NULL ) { sum += getSum ( root -> right -> left ) ; sum += getSum ( root -> right -> right ) ; } return sum ; } int getSum ( Node * root ) { if ( root == NULL ) return 0 ; return max ( getSumAlternate ( root ) , ( getSumAlternate ( root -> left ) + getSumAlternate ( root -> right ) ) ) ; } int main ( ) { Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> right -> left = new Node ( 4 ) ; root -> right -> left -> right = new Node ( 5 ) ; root -> right -> left -> right -> left = new Node ( 6 ) ; cout << ( getSum ( root ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int insertSorted ( int arr [ ] , int n , int key , int capacity ) { if ( n >= capacity ) return n ; int i ; for ( i = n - 1 ; ( i >= 0 && arr [ i ] > key ) ; i -- ) arr [ i + 1 ] = arr [ i ] ; arr [ i + 1 ] = key ; return ( n + 1 ) ; } int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; cout << " Before Insertion : " for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; n = insertSorted ( arr , n , key , capacity ) ; cout << " After Insertion : " for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int low , int high , int key ) ; int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } int deleteElement ( int arr [ ] , int n , int key ) { int pos = binarySearch ( arr , 0 , n - 1 , key ) ; if ( pos == -1 ) { cout << " Element ▁ not ▁ found " ; return n ; } int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; } int main ( ) { int i ; int arr [ ] = { 10 , 20 , 30 , 40 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; cout << " Array ▁ before ▁ deletion STRNEWLINE " ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; n = deleteElement ( arr , n , key ) ; cout << " Array after deletion " ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCommon ( int ar1 [ ] , int ar2 [ ] , int ar3 [ ] , int n1 , int n2 , int n3 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 && k < n3 ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { cout << ar1 [ i ] << " ▁ " ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } } int main ( ) { int ar1 [ ] = { 1 , 5 , 10 , 20 , 40 , 80 } ; int ar2 [ ] = { 6 , 7 , 20 , 80 , 100 } ; int ar3 [ ] = { 3 , 4 , 15 , 20 , 30 , 70 , 80 , 120 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; int n3 = sizeof ( ar3 ) / sizeof ( ar3 [ 0 ] ) ; cout << " Common ▁ Elements ▁ are ▁ " ; findCommon ( ar1 , ar2 , ar3 , n1 , n2 , n3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; } int findPos ( int arr [ ] , int key ) { int l = 0 , h = 1 ; int val = arr [ 0 ] ; while ( val < key ) { l = h ; h = 2 * h ; val = arr [ h ] ; } return binarySearch ( arr , l , h , key ) ; } int main ( ) { int arr [ ] = { 3 , 5 , 7 , 9 , 10 , 90 , 100 , 130 , 140 , 160 , 170 } ; int ans = findPos ( arr , 10 ) ; if ( ans == -1 ) cout << " Element ▁ not ▁ found " ; else cout << " Element ▁ found ▁ at ▁ index ▁ " << ans ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findSingle ( int ar [ ] , int ar_size ) { int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; } int main ( ) { int ar [ ] = { 2 , 3 , 5 , 4 , 5 , 3 , 4 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << " Element ▁ occurring ▁ once ▁ is ▁ " << findSingle ( ar , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int singleNumber ( int nums [ ] , int n ) { map < int , int > m ; long sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( m [ nums [ i ] ] == 0 ) { sum1 += nums [ i ] ; m [ nums [ i ] ] ++ ; } sum2 += nums [ i ] ; } return 2 * ( sum1 ) - sum2 ; } int main ( ) { int a [ ] = { 2 , 3 , 5 , 4 , 5 , 3 , 4 } ; int n = 7 ; cout << singleNumber ( a , n ) << " STRNEWLINE " ; int b [ ] = { 15 , 18 , 16 , 18 , 16 , 15 , 89 } ; cout << singleNumber ( b , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPresent ( int B [ ] , int m , int x ) { for ( int i = 0 ; i < m ; i ++ ) if ( B [ i ] == x ) return true ; return false ; } int findMaxSubarraySumUtil ( int A [ ] , int B [ ] , int n , int m ) { int max_so_far = INT_MIN , curr_max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPresent ( B , m , A [ i ] ) ) { curr_max = 0 ; continue ; } curr_max = max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; } void findMaxSubarraySum ( int A [ ] , int B [ ] , int n , int m ) { int maxSubarraySum = findMaxSubarraySumUtil ( A , B , n , m ) ; if ( maxSubarraySum == INT_MIN ) { cout << " Maximum ▁ Subarray ▁ Sum ▁ cant ▁ be ▁ found " << endl ; } else { cout << " The ▁ Maximum ▁ Subarray ▁ Sum ▁ = ▁ " << maxSubarraySum << endl ; } } int main ( ) { int A [ ] = { 3 , 4 , 5 , -4 , 6 } ; int B [ ] = { 1 , 8 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int m = sizeof ( B ) / sizeof ( B [ 0 ] ) ; findMaxSubarraySum ( A , B , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSubarraySumUtil ( int A [ ] , int B [ ] , int n , int m ) { int max_so_far = INT_MIN , curr_max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( binary_search ( B , B + m , A [ i ] ) ) { curr_max = 0 ; continue ; } curr_max = max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; } void findMaxSubarraySum ( int A [ ] , int B [ ] , int n , int m ) { sort ( B , B + m ) ; int maxSubarraySum = findMaxSubarraySumUtil ( A , B , n , m ) ; if ( maxSubarraySum == INT_MIN ) { cout << " Maximum ▁ subarray ▁ sum ▁ cant ▁ be ▁ found " << endl ; } else { cout << " The ▁ Maximum ▁ subarray ▁ sum ▁ = ▁ " << maxSubarraySum << endl ; } } int main ( ) { int A [ ] = { 3 , 4 , 5 , -4 , 6 } ; int B [ ] = { 1 , 8 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int m = sizeof ( B ) / sizeof ( B [ 0 ] ) ; findMaxSubarraySum ( A , B , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSubarraySum ( vector < int > A , vector < int > B ) { unordered_map < int , int > m ; for ( int i = 0 ; i < B . size ( ) ; i ++ ) { m [ B [ i ] ] = 1 ; } int max_so_far = INT_MIN ; int currmax = 0 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( currmax < 0 m [ A [ i ] ] == 1 ) { currmax = 0 ; continue ; } currmax = max ( A [ i ] , A [ i ] + currmax ) ; if ( max_so_far < currmax ) { max_so_far = currmax ; } } return max_so_far ; } int main ( ) { vector < int > a = { 3 , 4 , 5 , -4 , 6 } ; vector < int > b = { 1 , 8 , 5 } ; cout << findMaxSubarraySum ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int prefix_sum = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) prefix_sum += arr [ j ] ; int suffix_sum = arr [ i ] ; for ( int j = n - 1 ; j > i ; j -- ) suffix_sum += arr [ j ] ; if ( prefix_sum == suffix_sum ) res = max ( res , prefix_sum ) ; } return res ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printVector ( const vector < int > & v , int i ) { for ( int j = i ; j < v . size ( ) ; j ++ ) cout << v [ j ] << " ▁ " ; cout << endl ; } struct Node { int data ; Node * left , * right ; Node ( int x ) { data = x ; left = right = NULL ; } } ; void printKPathUtil ( Node * root , vector < int > & path , int k ) { if ( ! root ) return ; path . push_back ( root -> data ) ; printKPathUtil ( root -> left , path , k ) ; printKPathUtil ( root -> right , path , k ) ; int f = 0 ; for ( int j = path . size ( ) - 1 ; j >= 0 ; j -- ) { f += path [ j ] ; if ( f == k ) printVector ( path , j ) ; } path . pop_back ( ) ; } void printKPath ( Node * root , int k ) { vector < int > path ; printKPathUtil ( root , path , k ) ; } int main ( ) { Node * root = new Node ( 1 ) ; root -> left = new Node ( 3 ) ; root -> left -> left = new Node ( 2 ) ; root -> left -> right = new Node ( 1 ) ; root -> left -> right -> left = new Node ( 1 ) ; root -> right = new Node ( -1 ) ; root -> right -> left = new Node ( 4 ) ; root -> right -> left -> left = new Node ( 1 ) ; root -> right -> left -> right = new Node ( 2 ) ; root -> right -> right = new Node ( 5 ) ; root -> right -> right -> right = new Node ( 2 ) ; int k = 5 ; printKPath ( root , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int preSum [ n ] ; int suffSum [ n ] ; int ans = INT_MIN ; preSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) preSum [ i ] = preSum [ i - 1 ] + arr [ i ] ; suffSum [ n - 1 ] = arr [ n - 1 ] ; if ( preSum [ n - 1 ] == suffSum [ n - 1 ] ) ans = max ( ans , preSum [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffSum [ i ] = suffSum [ i + 1 ] + arr [ i ] ; if ( suffSum [ i ] == preSum [ i ] ) ans = max ( ans , preSum [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] , int n ) { int sum = accumulate ( arr , arr + n , 0 ) ; int prefix_sum = 0 , res = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum += arr [ i ] ; if ( prefix_sum == sum ) res = max ( res , prefix_sum ) ; sum -= arr [ i ] ; } return res ; } int main ( ) { int arr [ ] = { -2 , 5 , 3 , 1 , 2 , 6 , -4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int equilibrium ( int a [ ] , int n ) { if ( n == 1 ) return ( 0 ) ; int forward [ n ] = { 0 } ; int rev [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( i ) { forward [ i ] = forward [ i - 1 ] + a [ i ] ; } else { forward [ i ] = a [ i ] ; } } for ( int i = n - 1 ; i > 0 ; i -- ) { if ( i <= n - 2 ) { rev [ i ] = rev [ i + 1 ] + a [ i ] ; } else { rev [ i ] = a [ i ] ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( forward [ i ] == rev [ i ] ) { return i ; } } return -1 ; } int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " First ▁ Point ▁ of ▁ equilibrium ▁ is ▁ at ▁ index ▁ " << equilibrium ( arr , n ) << " STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printLeaders ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printLeaders ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printLeaders ( int arr [ ] , int size ) { int max_from_right = arr [ size - 1 ] ; cout << max_from_right << " ▁ " ; for ( int i = size - 2 ; i >= 0 ; i -- ) { if ( max_from_right < arr [ i ] ) { max_from_right = arr [ i ] ; cout << max_from_right << " ▁ " ; } } } int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printLeaders ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMajority ( int arr [ ] , int n ) { int maxCount = 0 ; int index = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count > maxCount ) { maxCount = count ; index = i ; } } if ( maxCount > n / 2 ) cout << arr [ index ] << endl ; else cout << " No ▁ Majority ▁ Element " << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int key ; int c = 0 ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> c = 1 ; temp -> left = temp -> right = NULL ; return temp ; } struct node * insert ( struct node * node , int key , int & ma ) { if ( node == NULL ) { if ( ma == 0 ) ma = 1 ; return newNode ( key ) ; } if ( key < node -> key ) node -> left = insert ( node -> left , key , ma ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key , ma ) ; else node -> c ++ ; ma = max ( ma , node -> c ) ; return node ; } void inorder ( struct node * root , int s ) { if ( root != NULL ) { inorder ( root -> left , s ) ; if ( root -> c > ( s / 2 ) ) printf ( " % d ▁ STRNEWLINE " , root -> key ) ; inorder ( root -> right , s ) ; } } int main ( ) { int a [ ] = { 1 , 3 , 3 , 3 , 2 } ; int size = ( sizeof ( a ) ) / sizeof ( a [ 0 ] ) ; struct node * root = NULL ; int ma = 0 ; for ( int i = 0 ; i < size ; i ++ ) { root = insert ( root , a [ i ] , ma ) ; } if ( ma > ( size / 2 ) ) inorder ( root , size ) ; else cout << " No ▁ majority ▁ element STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMajority ( int arr [ ] , int size ) { unordered_map < int , int > m ; for ( int i = 0 ; i < size ; i ++ ) m [ arr [ i ] ] ++ ; int count = 0 ; for ( auto i : m ) { if ( i . second > size / 2 ) { count = 1 ; cout << " Majority ▁ found ▁ : - ▁ " << i . first << endl ; break ; } } if ( count == 0 ) cout << " No ▁ Majority ▁ element " << endl ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int _binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( ( mid == 0 x > arr [ mid - 1 ] ) && ( arr [ mid ] == x ) ) return mid ; else if ( x > arr [ mid ] ) return _binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return _binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return -1 ; } bool isMajority ( int arr [ ] , int n , int x ) { int i = _binarySearch ( arr , 0 , n - 1 , x ) ; if ( i == -1 ) return false ; if ( ( ( i + n / 2 ) <= ( n - 1 ) ) && arr [ i + n / 2 ] == x ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajority ( arr , n , x ) ) cout << x << " ▁ appears ▁ more ▁ than ▁ " << n / 2 << " ▁ times ▁ in ▁ arr [ ] " << endl ; else cout << x << " ▁ does ▁ not ▁ appear ▁ more ▁ than " << n / 2 << " ▁ times ▁ in ▁ arr [ ] " << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isMajorityElement ( int arr [ ] , int n , int key ) { if ( arr [ n / 2 ] == key ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 3 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; if ( isMajorityElement ( arr , n , x ) ) cout << x << " ▁ appears ▁ more ▁ than ▁ " << n / 2 << " ▁ times ▁ in ▁ arr [ ] " << endl ; else cout << x << " ▁ does ▁ not ▁ appear ▁ more ▁ than " << n / 2 << " ▁ times ▁ in ▁ arr [ ] " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isMajority ( int a [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ a [ i ] ] ++ ; for ( auto x : mp ) if ( x . second >= n / 2 ) return true ; return false ; } int main ( ) { int a [ ] = { 2 , 3 , 9 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isMajority ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPairSum ( int A [ ] , int N , int X ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; if ( A [ i ] + A [ j ] == X ) return true ; if ( A [ i ] + A [ j ] > X ) break ; } } return false ; } int main ( ) { int arr [ ] = { 3 , 5 , 9 , 2 , 8 , 10 , 11 } ; int val = 17 ; int arrSize = * ( & arr + 1 ) - arr ; sort ( arr , arr + arrSize ) ; cout << isPairSum ( arr , arrSize , val ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int isPairSum ( int A [ ] , int N , int X ) { int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( A [ i ] + A [ j ] == X ) return 1 ; else if ( A [ i ] + A [ j ] < X ) i ++ ; else j -- ; } return 0 ; } int main ( ) { int arr [ ] = { 3 , 5 , 9 , 2 , 8 , 10 , 11 } ; int val = 17 ; int arrSize = * ( & arr + 1 ) - arr ; cout << ( bool ) isPairSum ( arr , arrSize , val ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; Node ( int data ) { this -> data = data ; left = right = NULL ; } } ; void inOrder ( struct Node * root ) { stack < Node * > s ; Node * curr = root ; while ( curr != NULL || s . empty ( ) == false ) { while ( curr != NULL ) { s . push ( curr ) ; curr = curr -> left ; } curr = s . top ( ) ; s . pop ( ) ; cout << curr -> data << " ▁ " ; curr = curr -> right ; } } int main ( ) { struct Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> left -> left = new Node ( 4 ) ; root -> left -> right = new Node ( 5 ) ; inOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return newNode ; } int countSubtreesWithSumX ( Node * root , int & count , int x ) { if ( ! root ) return 0 ; int ls = countSubtreesWithSumX ( root -> left , count , x ) ; int rs = countSubtreesWithSumX ( root -> right , count , x ) ; int sum = ls + rs + root -> data ; if ( sum == x ) count ++ ; return sum ; } int countSubtreesWithSumXUtil ( Node * root , int x ) { if ( ! root ) return 0 ; int count = 0 ; int ls = countSubtreesWithSumX ( root -> left , count , x ) ; int rs = countSubtreesWithSumX ( root -> right , count , x ) ; if ( ( ls + rs + root -> data ) == x ) count ++ ; return count ; } int main ( ) { Node * root = getNode ( 5 ) ; root -> left = getNode ( -10 ) ; root -> right = getNode ( 3 ) ; root -> left -> left = getNode ( 9 ) ; root -> left -> right = getNode ( 8 ) ; root -> right -> left = getNode ( -4 ) ; root -> right -> right = getNode ( 7 ) ; int x = 7 ; cout << " Count ▁ = ▁ " << countSubtreesWithSumXUtil ( root , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return newNode ; } int countSubtreesWithSumXUtil ( Node * root , int x ) { static int count = 0 ; static Node * ptr = root ; int l = 0 , r = 0 ; if ( root == NULL ) return 0 ; l += countSubtreesWithSumXUtil ( root -> left , x ) ; r += countSubtreesWithSumXUtil ( root -> right , x ) ; if ( l + r + root -> data == x ) count ++ ; if ( ptr != root ) return l + root -> data + r ; return count ; } int main ( ) { Node * root = getNode ( 5 ) ; root -> left = getNode ( -10 ) ; root -> right = getNode ( 3 ) ; root -> left -> left = getNode ( 9 ) ; root -> left -> right = getNode ( 8 ) ; root -> right -> left = getNode ( -4 ) ; root -> right -> right = getNode ( 7 ) ; int x = 7 ; cout << " Count ▁ = ▁ " << countSubtreesWithSumXUtil ( root , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum = 0 , max_level = INT_MIN ; struct Node { int d ; Node * l ; Node * r ; } ; Node * createNode ( int d ) { Node * node ; node = new Node ; node -> d = d ; node -> l = NULL ; node -> r = NULL ; return node ; } void sumOfNodesAtMaxDepth ( Node * ro , int level ) { if ( ro == NULL ) return ; if ( level > max_level ) { sum = ro -> d ; max_level = level ; } else if ( level == max_level ) { sum = sum + ro -> d ; } sumOfNodesAtMaxDepth ( ro -> l , level + 1 ) ; sumOfNodesAtMaxDepth ( ro -> r , level + 1 ) ; } int main ( ) { Node * root ; root = createNode ( 1 ) ; root -> l = createNode ( 2 ) ; root -> r = createNode ( 3 ) ; root -> l -> l = createNode ( 4 ) ; root -> l -> r = createNode ( 5 ) ; root -> r -> l = createNode ( 6 ) ; root -> r -> r = createNode ( 7 ) ; sumOfNodesAtMaxDepth ( root , 0 ) ; cout << sum ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; Node ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; int sumMaxLevelRec ( Node * node , int max ) { if ( node == NULL ) return 0 ; if ( max == 1 ) return node -> data ; return sumMaxLevelRec ( node -> left , max - 1 ) + sumMaxLevelRec ( node -> right , max - 1 ) ; } int maxDepth ( Node * node ) { if ( node == NULL ) return 0 ; return 1 + max ( maxDepth ( node -> left ) , maxDepth ( node -> right ) ) ; } int sumMaxLevel ( Node * root ) { int MaxDepth = maxDepth ( root ) ; return sumMaxLevelRec ( root , MaxDepth ) ; } int main ( ) { Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> left -> left = new Node ( 4 ) ; root -> left -> right = new Node ( 5 ) ; root -> right -> left = new Node ( 6 ) ; root -> right -> right = new Node ( 7 ) ; cout << ( sumMaxLevel ( root ) ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ( ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int evenOddLevelDifference ( Node * root ) { if ( ! root ) return 0 ; queue < Node * > q ; q . push ( root ) ; int level = 0 ; int evenSum = 0 , oddSum = 0 ; while ( ! q . empty ( ) ) { int size = q . size ( ) ; level += 1 ; while ( size > 0 ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( level % 2 == 0 ) evenSum += temp -> data ; else oddSum += temp -> data ; if ( temp -> left ) { q . push ( temp -> left ) ; } if ( temp -> right ) { q . push ( temp -> right ) ; } size -= 1 ; } } return ( oddSum - evenSum ) ; } int main ( ) { Node * root = newNode ( 5 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 3 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 7 ) ; int result = evenOddLevelDifference ( root ) ; cout << " diffence ▁ between ▁ sums ▁ is ▁ : : ▁ " ; cout << result << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left , * right ; } ; node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = Node -> right = NULL ; return ( Node ) ; } int getLevelDiff ( node * root ) { if ( root == NULL ) return 0 ; return root -> data - getLevelDiff ( root -> left ) - getLevelDiff ( root -> right ) ; } int main ( ) { node * root = newNode ( 5 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 3 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 7 ) ; cout << getLevelDiff ( root ) << " ▁ is ▁ the ▁ required ▁ difference STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int maxSum ( vector < int > arr , int n ) { int max_ending_here = INT_MIN ; int max_so_far = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_ending_here < 0 ) max_ending_here = arr [ i ] ; else max_ending_here += arr [ i ] ; max_so_far = max ( max_so_far , max_ending_here ) ; } return max_so_far ; } int maxSpiralSum ( Node * root ) { if ( root == NULL ) return 0 ; stack < Node * > s1 ; stack < Node * > s2 ; vector < int > arr ; s1 . push ( root ) ; while ( ! s1 . empty ( ) || ! s2 . empty ( ) ) { while ( ! s1 . empty ( ) ) { Node * temp = s1 . top ( ) ; s1 . pop ( ) ; arr . push_back ( temp -> data ) ; if ( temp -> right ) s2 . push ( temp -> right ) ; if ( temp -> left ) s2 . push ( temp -> left ) ; } while ( ! s2 . empty ( ) ) { Node * temp = s2 . top ( ) ; s2 . pop ( ) ; arr . push_back ( temp -> data ) ; if ( temp -> left ) s1 . push ( temp -> left ) ; if ( temp -> right ) s1 . push ( temp -> right ) ; } } return maxSum ( arr , arr . size ( ) ) ; } int main ( ) { Node * root = newNode ( -2 ) ; root -> left = newNode ( -3 ) ; root -> right = newNode ( 4 ) ; root -> left -> left = newNode ( 5 ) ; root -> left -> right = newNode ( 1 ) ; root -> right -> left = newNode ( -2 ) ; root -> right -> right = newNode ( -1 ) ; root -> left -> left -> left = newNode ( -3 ) ; root -> right -> right -> right = newNode ( 2 ) ; cout << " Maximum ▁ Spiral ▁ Sum ▁ = ▁ " << maxSpiralSum ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ( ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void leafSum ( Node * root , int & sum ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) sum += root -> data ; leafSum ( root -> left , sum ) ; leafSum ( root -> right , sum ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right = newNode ( 3 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 8 ) ; int sum = 0 ; leafSum ( root , sum ) ; cout << sum << endl ; return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct tNode { int data ; struct tNode * left ; struct tNode * right ; } ; void MorrisTraversal ( struct tNode * root ) { struct tNode * current , * pre ; if ( root == NULL ) return ; current = root ; while ( current != NULL ) { if ( current -> left == NULL ) { printf ( " % d ▁ " , current -> data ) ; current = current -> right ; } else { pre = current -> left ; while ( pre -> right != NULL && pre -> right != current ) pre = pre -> right ; if ( pre -> right == NULL ) { pre -> right = current ; current = current -> left ; } else { pre -> right = NULL ; printf ( " % d ▁ " , current -> data ) ; current = current -> right ; } } } } struct tNode * newtNode ( int data ) { struct tNode * node = new tNode ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct tNode * root = newtNode ( 1 ) ; root -> left = newtNode ( 2 ) ; root -> right = newtNode ( 3 ) ; root -> left -> left = newtNode ( 4 ) ; root -> left -> right = newtNode ( 5 ) ; MorrisTraversal ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return newNode ; } int sumOfLeafNodesAtMinLevel ( Node * root ) { if ( ! root ) return 0 ; if ( ! root -> left && ! root -> right ) return root -> data ; queue < Node * > q ; int sum = 0 ; bool f = 0 ; q . push ( root ) ; while ( f == 0 ) { int nc = q . size ( ) ; while ( nc -- ) { Node * top = q . front ( ) ; q . pop ( ) ; if ( ! top -> left && ! top -> right ) { sum += top -> data ; f = 1 ; } else { if ( top -> left ) q . push ( top -> left ) ; if ( top -> right ) q . push ( top -> right ) ; } } } return sum ; } int main ( ) { Node * root = getNode ( 1 ) ; root -> left = getNode ( 2 ) ; root -> right = getNode ( 3 ) ; root -> left -> left = getNode ( 4 ) ; root -> left -> right = getNode ( 5 ) ; root -> right -> left = getNode ( 6 ) ; root -> right -> right = getNode ( 7 ) ; root -> left -> right -> left = getNode ( 8 ) ; root -> right -> left -> right = getNode ( 9 ) ; cout << " Sum ▁ = ▁ " << sumOfLeafNodesAtMinLevel ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE class node { public : int data ; node * left ; node * right ; } ; bool hasPathSum ( node * Node , int sum ) { if ( Node == NULL ) { return ( sum == 0 ) ; } else { bool ans = 0 ; int subSum = sum - Node -> data ; if ( subSum == 0 && Node -> left == NULL && Node -> right == NULL ) return 1 ; if ( Node -> left ) ans = ans || hasPathSum ( Node -> left , subSum ) ; if ( Node -> right ) ans = ans || hasPathSum ( Node -> right , subSum ) ; return ans ; } } node * newnode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int main ( ) { int sum = 21 ; node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; root -> left -> right = newnode ( 5 ) ; root -> right -> left = newnode ( 2 ) ; if ( hasPathSum ( root , sum ) ) cout << " There ▁ is ▁ a ▁ root - to - leaf ▁ path ▁ with ▁ sum ▁ " << sum ; else cout << " There ▁ is ▁ no ▁ root - to - leaf ▁ path ▁ with ▁ sum ▁ " << sum ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left , * right ; } ; node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = Node -> right = NULL ; return ( Node ) ; } int treePathsSumUtil ( node * root , int val ) { if ( root == NULL ) return 0 ; val = ( val * 10 + root -> data ) ; if ( root -> left == NULL && root -> right == NULL ) return val ; return treePathsSumUtil ( root -> left , val ) + treePathsSumUtil ( root -> right , val ) ; } int treePathsSum ( node * root ) { return treePathsSumUtil ( root , 0 ) ; } int main ( ) { node * root = newNode ( 6 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 2 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 4 ) ; root -> left -> right -> left = newNode ( 7 ) ; root -> left -> right -> right = newNode ( 4 ) ; cout << " Sum ▁ of ▁ all ▁ paths ▁ is ▁ " << treePathsSum ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * new_node = new Node ; new_node -> data = data ; new_node -> left = new_node -> right = NULL ; return new_node ; } void inorder ( Node * node ) { if ( ! node ) return ; inorder ( node -> left ) ; printf ( " % d ▁ " , node -> data ) ; inorder ( node -> right ) ; } Node * MergeTrees ( Node * t1 , Node * t2 ) { if ( ! t1 ) return t2 ; if ( ! t2 ) return t1 ; t1 -> data += t2 -> data ; t1 -> left = MergeTrees ( t1 -> left , t2 -> left ) ; t1 -> right = MergeTrees ( t1 -> right , t2 -> right ) ; return t1 ; } int main ( ) { Node * root1 = newNode ( 1 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 3 ) ; root1 -> left -> left = newNode ( 4 ) ; root1 -> left -> right = newNode ( 5 ) ; root1 -> right -> right = newNode ( 6 ) ; Node * root2 = newNode ( 4 ) ; root2 -> left = newNode ( 1 ) ; root2 -> right = newNode ( 7 ) ; root2 -> left -> left = newNode ( 3 ) ; root2 -> right -> left = newNode ( 2 ) ; root2 -> right -> right = newNode ( 6 ) ; Node * root3 = MergeTrees ( root1 , root2 ) ; printf ( " The ▁ Merged ▁ Binary ▁ Tree ▁ is : STRNEWLINE " ) ; inorder ( root3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct snode { Node * l , * r ; } ; Node * newNode ( int data ) { Node * new_node = new Node ; new_node -> data = data ; new_node -> left = new_node -> right = NULL ; return new_node ; } void inorder ( Node * node ) { if ( ! node ) return ; inorder ( node -> left ) ; printf ( " % d ▁ " , node -> data ) ; inorder ( node -> right ) ; } Node * MergeTrees ( Node * t1 , Node * t2 ) { if ( ! t1 ) return t2 ; if ( ! t2 ) return t1 ; stack < snode > s ; snode temp ; temp . l = t1 ; temp . r = t2 ; s . push ( temp ) ; snode n ; while ( ! s . empty ( ) ) { n = s . top ( ) ; s . pop ( ) ; if ( n . l == NULL n . r == NULL ) continue ; n . l -> data += n . r -> data ; if ( n . l -> left == NULL ) n . l -> left = n . r -> left ; else { snode t ; t . l = n . l -> left ; t . r = n . r -> left ; s . push ( t ) ; } if ( n . l -> right == NULL ) n . l -> right = n . r -> right ; else { snode t ; t . l = n . l -> right ; t . r = n . r -> right ; s . push ( t ) ; } } return t1 ; } int main ( ) { Node * root1 = newNode ( 1 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 3 ) ; root1 -> left -> left = newNode ( 4 ) ; root1 -> left -> right = newNode ( 5 ) ; root1 -> right -> right = newNode ( 6 ) ; Node * root2 = newNode ( 4 ) ; root2 -> left = newNode ( 1 ) ; root2 -> right = newNode ( 7 ) ; root2 -> left -> left = newNode ( 3 ) ; root2 -> right -> left = newNode ( 2 ) ; root2 -> right -> right = newNode ( 6 ) ; Node * root3 = MergeTrees ( root1 , root2 ) ; printf ( " The ▁ Merged ▁ Binary ▁ Tree ▁ is : STRNEWLINE " ) ; inorder ( root3 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int search ( int arr [ ] , int x , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; } void printPostOrder ( int in [ ] , int pre [ ] , int n ) { int root = search ( in , pre [ 0 ] , n ) ; if ( root != 0 ) printPostOrder ( in , pre + 1 , root ) ; if ( root != n - 1 ) printPostOrder ( in + root + 1 , pre + root + 1 , n - root - 1 ) ; cout << pre [ 0 ] << " ▁ " ; } int main ( ) { int in [ ] = { 4 , 2 , 5 , 1 , 3 , 6 } ; int pre [ ] = { 1 , 2 , 4 , 5 , 3 , 6 } ; int n = sizeof ( in ) / sizeof ( in [ 0 ] ) ; cout << " Postorder ▁ traversal ▁ " << endl ; printPostOrder ( in , pre , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int key ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } struct Node * findLCA ( struct Node * root , int n1 , int n2 ) { if ( root == NULL ) return NULL ; if ( root -> key == n1 root -> key == n2 ) return root ; Node * left_lca = findLCA ( root -> left , n1 , n2 ) ; Node * right_lca = findLCA ( root -> right , n1 , n2 ) ; if ( left_lca && right_lca ) return root ; return ( left_lca != NULL ) ? left_lca : right_lca ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; cout << " LCA ( 4 , ▁ 5 ) ▁ = ▁ " << findLCA ( root , 4 , 5 ) -> key ; cout << " nLCA ( 4 , ▁ 6 ) ▁ = ▁ " << findLCA ( root , 4 , 6 ) -> key ; cout << " nLCA ( 3 , ▁ 4 ) ▁ = ▁ " << findLCA ( root , 3 , 4 ) -> key ; cout << " nLCA ( 2 , ▁ 4 ) ▁ = ▁ " << findLCA ( root , 2 , 4 ) -> key ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int key ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } struct Node * findLCAUtil ( struct Node * root , int n1 , int n2 , bool & v1 , bool & v2 ) { if ( root == NULL ) return NULL ; if ( root -> key == n1 ) { v1 = true ; return root ; } if ( root -> key == n2 ) { v2 = true ; return root ; } Node * left_lca = findLCAUtil ( root -> left , n1 , n2 , v1 , v2 ) ; Node * right_lca = findLCAUtil ( root -> right , n1 , n2 , v1 , v2 ) ; if ( left_lca && right_lca ) return root ; return ( left_lca != NULL ) ? left_lca : right_lca ; } bool find ( Node * root , int k ) { if ( root == NULL ) return false ; if ( root -> key == k || find ( root -> left , k ) || find ( root -> right , k ) ) return true ; return false ; } Node * findLCA ( Node * root , int n1 , int n2 ) { bool v1 = false , v2 = false ; Node * lca = findLCAUtil ( root , n1 , n2 , v1 , v2 ) ; if ( v1 && v2 || v1 && find ( lca , n2 ) || v2 && find ( lca , n1 ) ) return lca ; return NULL ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; Node * lca = findLCA ( root , 4 , 5 ) ; if ( lca != NULL ) cout << " LCA ( 4 , ▁ 5 ) ▁ = ▁ " << lca -> key ; else cout << " Keys ▁ are ▁ not ▁ present ▁ " ; lca = findLCA ( root , 4 , 10 ) ; if ( lca != NULL ) cout << " nLCA ( 4 , ▁ 10 ) ▁ = ▁ " << lca -> key ; else cout << " nKeys ▁ are ▁ not ▁ present ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { Node * left , * right , * parent ; int key ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> parent = temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) { node -> left = insert ( node -> left , key ) ; node -> left -> parent = node ; } else if ( key > node -> key ) { node -> right = insert ( node -> right , key ) ; node -> right -> parent = node ; } return node ; } int depth ( Node * node ) { int d = -1 ; while ( node ) { ++ d ; node = node -> parent ; } return d ; } Node * LCA ( Node * n1 , Node * n2 ) { int d1 = depth ( n1 ) , d2 = depth ( n2 ) ; int diff = d1 - d2 ; if ( diff < 0 ) { Node * temp = n1 ; n1 = n2 ; n2 = temp ; diff = - diff ; } while ( diff -- ) n1 = n1 -> parent ; while ( n1 && n2 ) { if ( n1 == n2 ) return n1 ; n1 = n1 -> parent ; n2 = n2 -> parent ; } return NULL ; } int main ( void ) { Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 22 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; Node * n1 = root -> left -> right -> left ; Node * n2 = root -> right ; Node * lca = LCA ( n1 , n2 ) ; printf ( " LCA ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d ▁ STRNEWLINE " , n1 -> key , n2 -> key , lca -> key ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define sz ( x )  x.size() NEW_LINE #define pb  push_back NEW_LINE #define left  2 * i + 1 NEW_LINE #define right  2 * i + 2 NEW_LINE using namespace std ; const int maxn = 100005 ; vector < vector < int > > g ( maxn ) ; int level [ maxn ] ; vector < int > e ; vector < int > l ; int h [ maxn ] ; int st [ 5 * maxn ] ; void add_edge ( int u , int v ) { g [ u ] . pb ( v ) ; g [ v ] . pb ( u ) ; } void leveling ( int src ) { for ( int i = 0 ; i < sz ( g [ src ] ) ; i ++ ) { int des = g [ src ] [ i ] ; if ( ! level [ des ] ) { level [ des ] = level [ src ] + 1 ; leveling ( des ) ; } } } bool visited [ maxn ] ; void dfs ( int src ) { e . pb ( src ) ; visited [ src ] = 1 ; for ( int i = 0 ; i < sz ( g [ src ] ) ; i ++ ) { int des = g [ src ] [ i ] ; if ( ! visited [ des ] ) { dfs ( des ) ; e . pb ( src ) ; } } } void setting_l ( int n ) { for ( int i = 0 ; i < sz ( e ) ; i ++ ) l . pb ( level [ e [ i ] ] ) ; } void setting_h ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) h [ i ] = -1 ; for ( int i = 0 ; i < sz ( e ) ; i ++ ) { if ( h [ e [ i ] ] == -1 ) h [ e [ i ] ] = i ; } } int RMQ ( int ss , int se , int qs , int qe , int i ) { if ( ss > se ) return -1 ; if ( se < qs qe < ss ) return -1 ; if ( qs <= ss && se <= qe ) return st [ i ] ; int mid = ( ss + se ) >> 1 ; int st = RMQ ( ss , mid , qs , qe , left ) ; int en = RMQ ( mid + 1 , se , qs , qe , right ) ; if ( st != -1 && en != -1 ) { if ( l [ st ] < l [ en ] ) return st ; return en ; } else if ( st != -1 ) return st ; else if ( en != -1 ) return en ; } void SegmentTreeConstruction ( int ss , int se , int i ) { if ( ss > se ) return ; if ( ss == se ) { st [ i ] = ss ; return ; } int mid = ( ss + se ) >> 1 ; SegmentTreeConstruction ( ss , mid , left ) ; SegmentTreeConstruction ( mid + 1 , se , right ) ; if ( l [ st [ left ] ] < l [ st [ right ] ] ) st [ i ] = st [ left ] ; else st [ i ] = st [ right ] ; } int LCA ( int x , int y ) { if ( h [ x ] > h [ y ] ) swap ( x , y ) ; return e [ RMQ ( 0 , sz ( l ) - 1 , h [ x ] , h [ y ] , 0 ) ] ; } int main ( ) { ios :: sync_with_stdio ( 0 ) ; int n = 15 , q = 5 ; add_edge ( 1 , 2 ) ; add_edge ( 1 , 3 ) ; add_edge ( 1 , 4 ) ; add_edge ( 3 , 5 ) ; add_edge ( 4 , 6 ) ; add_edge ( 5 , 7 ) ; add_edge ( 5 , 8 ) ; add_edge ( 5 , 9 ) ; add_edge ( 7 , 10 ) ; add_edge ( 7 , 11 ) ; add_edge ( 7 , 12 ) ; add_edge ( 9 , 13 ) ; add_edge ( 9 , 14 ) ; add_edge ( 12 , 15 ) ; level [ 1 ] = 1 ; leveling ( 1 ) ; dfs ( 1 ) ; setting_l ( n ) ; setting_h ( n ) ; SegmentTreeConstruction ( 0 , sz ( l ) - 1 , 0 ) ; cout << LCA ( 10 , 15 ) << endl ; cout << LCA ( 11 , 14 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int key ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } struct Node * findLCA ( struct Node * root , int n1 , int n2 ) { if ( root == NULL ) return NULL ; if ( root -> key == n1 root -> key == n2 ) return root ; Node * left_lca = findLCA ( root -> left , n1 , n2 ) ; Node * right_lca = findLCA ( root -> right , n1 , n2 ) ; if ( left_lca && right_lca ) return root ; return ( left_lca != NULL ) ? left_lca : right_lca ; } bool printAncestors ( struct Node * root , int target ) { if ( root == NULL ) return false ; if ( root -> key == target ) { cout << root -> key << " ▁ " ; return true ; } if ( printAncestors ( root -> left , target ) || printAncestors ( root -> right , target ) ) { cout << root -> key << " ▁ " ; return true ; } return false ; } bool findCommonNodes ( struct Node * root , int first , int second ) { struct Node * LCA = findLCA ( root , first , second ) ; if ( LCA == NULL ) return false ; printAncestors ( root , LCA -> key ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> right -> left -> left = newNode ( 9 ) ; root -> right -> left -> right = newNode ( 10 ) ; if ( findCommonNodes ( root , 9 , 7 ) == false ) cout << " No ▁ Common ▁ nodes " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int k ) { Node * temp = new Node ; temp -> key = k ; temp -> left = temp -> right = NULL ; return temp ; } #define V  9			 NEW_LINE int euler [ 2 * V - 1 ] ; int level [ 2 * V - 1 ] ; int firstOccurrence [ V + 1 ] ; int ind ; int Log2 ( int x ) { int ans = 0 ; while ( x >>= 1 ) ans ++ ; return ans ; } int RMQUtil ( int index , int ss , int se , int qs , int qe , int * st ) { if ( qs <= ss && qe >= se ) return st [ index ] ; else if ( se < qs ss > qe ) return -1 ; int mid = ( ss + se ) / 2 ; int q1 = RMQUtil ( 2 * index + 1 , ss , mid , qs , qe , st ) ; int q2 = RMQUtil ( 2 * index + 2 , mid + 1 , se , qs , qe , st ) ; if ( q1 == -1 ) return q2 ; else if ( q2 == -1 ) return q1 ; return ( level [ q1 ] < level [ q2 ] ) ? q1 : q2 ; } int RMQ ( int * st , int n , int qs , int qe ) { if ( qs < 0 qe > n -1 qs > qe ) { printf ( " Invalid ▁ Input " ) ; return - 1 ; } return RMQUtil ( 0 , 0 , n - 1 , qs , qe , st ) ; } void constructSTUtil ( int si , int ss , int se , int arr [ ] , int * st ) { if ( ss == se ) st [ si ] = ss ; else { int mid = ( ss + se ) / 2 ; constructSTUtil ( si * 2 + 1 , ss , mid , arr , st ) ; constructSTUtil ( si * 2 + 2 , mid + 1 , se , arr , st ) ; if ( arr [ st [ 2 * si + 1 ] ] < arr [ st [ 2 * si + 2 ] ] ) st [ si ] = st [ 2 * si + 1 ] ; else st [ si ] = st [ 2 * si + 2 ] ; } } int * constructST ( int arr [ ] , int n ) { int x = Log2 ( n ) + 1 ; int max_size = 2 * ( 1 << x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( 0 , 0 , n - 1 , arr , st ) ; return st ; } void eulerTour ( Node * root , int l ) { if ( root ) { euler [ ind ] = root -> key ; level [ ind ] = l ; ind ++ ; if ( firstOccurrence [ root -> key ] == -1 ) firstOccurrence [ root -> key ] = ind - 1 ; if ( root -> left ) { eulerTour ( root -> left , l + 1 ) ; euler [ ind ] = root -> key ; level [ ind ] = l ; ind ++ ; } if ( root -> right ) { eulerTour ( root -> right , l + 1 ) ; euler [ ind ] = root -> key ; level [ ind ] = l ; ind ++ ; } } } int findLCA ( Node * root , int u , int v ) { memset ( firstOccurrence , -1 , sizeof ( int ) * ( V + 1 ) ) ; ind = 0 ; eulerTour ( root , 0 ) ; int * st = constructST ( level , 2 * V - 1 ) ; if ( firstOccurrence [ u ] > firstOccurrence [ v ] ) std :: swap ( u , v ) ; int qs = firstOccurrence [ u ] ; int qe = firstOccurrence [ v ] ; int index = RMQ ( st , 2 * V - 1 , qs , qe ) ; return euler [ index ] ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> right -> left = newNode ( 8 ) ; root -> left -> right -> right = newNode ( 9 ) ; int u = 4 , v = 9 ; printf ( " The ▁ LCA ▁ of ▁ node ▁ % d ▁ and ▁ node ▁ % d ▁ is ▁ node ▁ % d . STRNEWLINE " , u , v , findLCA ( root , u , v ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int preIndex = 0 ; int search ( int arr [ ] , int startIn , int endIn , int data ) { int i = 0 ; for ( i = startIn ; i < endIn ; i ++ ) { if ( arr [ i ] == data ) { return i ; } } return i ; } void printPost ( int arr [ ] , int pre [ ] , int inStrt , int inEnd ) { if ( inStrt > inEnd ) { return ; } int inIndex = search ( arr , inStrt , inEnd , pre [ preIndex ++ ] ) ; printPost ( arr , pre , inStrt , inIndex - 1 ) ; printPost ( arr , pre , inIndex + 1 , inEnd ) ; cout << arr [ inIndex ] << " ▁ " ; } int main ( ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 , 6 } ; int pre [ ] = { 1 , 2 , 4 , 5 , 3 , 6 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPost ( arr , pre , 0 , len - 1 ) ; }
struct node { int data ; struct node * left ; struct node * right ; } ;
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } int maxDiffUtil ( Node * t , int * res ) { if ( t == NULL ) return INT_MAX ; if ( t -> left == NULL && t -> right == NULL ) return t -> key ; int val = min ( maxDiffUtil ( t -> left , res ) , maxDiffUtil ( t -> right , res ) ) ; * res = max ( * res , t -> key - val ) ; return min ( val , t -> key ) ; } int maxDiff ( Node * root ) { int res = INT_MIN ; maxDiffUtil ( root , & res ) ; return res ; } void inorder ( Node * root ) { if ( root ) { inorder ( root -> left ) ; printf ( " % d ▁ " , root -> key ) ; inorder ( root -> right ) ; } } int main ( ) { Node * root ; root = newNode ( 8 ) ; root -> left = newNode ( 3 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 4 ) ; root -> left -> right -> right = newNode ( 7 ) ; root -> right = newNode ( 10 ) ; root -> right -> right = newNode ( 14 ) ; root -> right -> right -> left = newNode ( 13 ) ; printf ( " Maximum ▁ difference ▁ between ▁ a ▁ node ▁ and " " ▁ its ▁ ancestor ▁ is ▁ : ▁ % d STRNEWLINE " , maxDiff ( root ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool v1 = false , v2 = false ; struct Node { int data ; Node * left , * right ; } ; struct Node * getNode ( int data ) { struct Node * newNode = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return newNode ; } struct Node * findLCAUtil ( struct Node * root , int n1 , int n2 , bool & v1 , bool & v2 ) { if ( root == NULL ) return NULL ; if ( root -> data == n1 ) { v1 = true ; return root ; } if ( root -> data == n2 ) { v2 = true ; return root ; } Node * left_lca = findLCAUtil ( root -> left , n1 , n2 , v1 , v2 ) ; Node * right_lca = findLCAUtil ( root -> right , n1 , n2 , v1 , v2 ) ; if ( left_lca && right_lca ) return root ; return ( left_lca != NULL ) ? left_lca : right_lca ; } bool find ( Node * root , int k ) { if ( root == NULL ) return false ; if ( root -> data == k || find ( root -> left , k ) || find ( root -> right , k ) ) return true ; return false ; } Node * findLCA ( Node * root , int n1 , int n2 ) { Node * lca = findLCAUtil ( root , n1 , n2 , v1 , v2 ) ; if ( v1 && v2 || v1 && find ( lca , n2 ) || v2 && find ( lca , n1 ) ) return lca ; return NULL ; } bool hasPath ( Node * root , vector < int > & arr , int x ) { if ( ! root ) return false ; arr . push_back ( root -> data ) ; if ( root -> data == x ) return true ; if ( hasPath ( root -> left , arr , x ) || hasPath ( root -> right , arr , x ) ) return true ; arr . pop_back ( ) ; return false ; } void printCommonPath ( Node * root , int n1 , int n2 ) { vector < int > arr ; Node * lca = findLCA ( root , n1 , n2 ) ; if ( lca ) { if ( hasPath ( root , arr , lca -> data ) ) { for ( int i = 0 ; i < arr . size ( ) - 1 ; i ++ ) cout << arr [ i ] << " - > " ; cout << arr [ arr . size ( ) - 1 ] ; } } else cout << " No ▁ Common ▁ Path " ; } int main ( ) { struct Node * root = getNode ( 1 ) ; root -> left = getNode ( 2 ) ; root -> right = getNode ( 3 ) ; root -> left -> left = getNode ( 4 ) ; root -> left -> right = getNode ( 5 ) ; root -> right -> left = getNode ( 6 ) ; root -> right -> right = getNode ( 7 ) ; root -> left -> right -> left = getNode ( 8 ) ; root -> right -> left -> right = getNode ( 9 ) ; int n1 = 4 , n2 = 8 ; printCommonPath ( root , n1 , n2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( vector < int > g [ ] , int u , int parent , int timeIn [ ] , int timeOut [ ] , int & cnt ) { timeIn [ u ] = cnt ++ ; for ( int i = 0 ; i < g [ u ] . size ( ) ; i ++ ) { int v = g [ u ] [ i ] ; if ( v != parent ) dfs ( g , v , u , timeIn , timeOut , cnt ) ; } timeOut [ u ] = cnt ++ ; } void preProcess ( int edges [ ] [ 2 ] , int V , int timeIn [ ] , int timeOut [ ] ) { vector < int > g [ V ] ; for ( int i = 0 ; i < V - 1 ; i ++ ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; g [ u ] . push_back ( v ) ; g [ v ] . push_back ( u ) ; } int cnt = 0 ; dfs ( g , 0 , -1 , timeIn , timeOut , cnt ) ; } string isAncestor ( int u , int v , int timeIn [ ] , int timeOut [ ] ) { bool b = ( timeIn [ u ] <= timeIn [ v ] && timeOut [ v ] <= timeOut [ u ] ) ; return ( b ? " yes " : " no " ) ; } int main ( ) { int edges [ ] [ 2 ] = { { 0 , 1 } , { 0 , 2 } , { 1 , 3 } , { 1 , 4 } , { 2 , 5 } , { 4 , 6 } , { 5 , 7 } } ; int E = sizeof ( edges ) / sizeof ( edges [ 0 ] ) ; int V = E + 1 ; int timeIn [ V ] , timeOut [ V ] ; preProcess ( edges , V , timeIn , timeOut ) ; int u = 1 ; int v = 6 ; cout << isAncestor ( u , v , timeIn , timeOut ) << endl ; u = 1 ; v = 7 ; cout << isAncestor ( u , v , timeIn , timeOut ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; struct Node * getNode ( int data ) { struct Node * newNode = new Node ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return newNode ; } bool hasPath ( Node * root , vector < int > & arr , int x ) { if ( ! root ) return false ; arr . push_back ( root -> data ) ; if ( root -> data == x ) return true ; if ( hasPath ( root -> left , arr , x ) || hasPath ( root -> right , arr , x ) ) return true ; arr . pop_back ( ) ; return false ; } void printPath ( Node * root , int x ) { vector < int > arr ; if ( hasPath ( root , arr , x ) ) { for ( int i = 0 ; i < arr . size ( ) - 1 ; i ++ ) cout << arr [ i ] << " - > " ; cout << arr [ arr . size ( ) - 1 ] ; } else cout << " No ▁ Path " ; } int main ( ) { struct Node * root = getNode ( 1 ) ; root -> left = getNode ( 2 ) ; root -> right = getNode ( 3 ) ; root -> left -> left = getNode ( 4 ) ; root -> left -> right = getNode ( 5 ) ; root -> right -> left = getNode ( 6 ) ; root -> right -> right = getNode ( 7 ) ; int x = 5 ; printPath ( root , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; bool printAncestors ( struct node * root , int target ) { if ( root == NULL ) return false ; if ( root -> data == target ) return true ; if ( printAncestors ( root -> left , target ) || printAncestors ( root -> right , target ) ) { cout << root -> data << " ▁ " ; return true ; } return false ; } struct node * newnode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newnode ( 1 ) ; root -> left = newnode ( 2 ) ; root -> right = newnode ( 3 ) ; root -> left -> left = newnode ( 4 ) ; root -> left -> right = newnode ( 5 ) ; root -> left -> left -> left = newnode ( 7 ) ; printAncestors ( root , 7 ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * temp = NULL ; Node * kthAncestorDFS ( Node * root , int node , int & k ) { if ( ! root ) return NULL ; if ( root -> data == node || ( temp = kthAncestorDFS ( root -> left , node , k ) ) || ( temp = kthAncestorDFS ( root -> right , node , k ) ) ) { if ( k > 0 ) k -- ; else if ( k == 0 ) { cout << " Kth ▁ ancestor ▁ is : ▁ " << root -> data ; return NULL ; } return root ; } } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; int k = 2 ; int node = 5 ; Node * parent = kthAncestorDFS ( root , node , k ) ; if ( parent ) cout << " - 1" ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } void EncodeSuccinct ( Node * root , list < bool > & struc , list < int > & data ) { if ( root == NULL ) { struc . push_back ( 0 ) ; return ; } struc . push_back ( 1 ) ; data . push_back ( root -> key ) ; EncodeSuccinct ( root -> left , struc , data ) ; EncodeSuccinct ( root -> right , struc , data ) ; } Node * DecodeSuccinct ( list < bool > & struc , list < int > & data ) { if ( struc . size ( ) <= 0 ) return NULL ; bool b = struc . front ( ) ; struc . pop_front ( ) ; if ( b == 1 ) { int key = data . front ( ) ; data . pop_front ( ) ; Node * root = newNode ( key ) ; root -> left = DecodeSuccinct ( struc , data ) ; root -> right = DecodeSuccinct ( struc , data ) ; return root ; } return NULL ; } void preorder ( Node * root ) { if ( root ) { cout << " key : ▁ " << root -> key ; if ( root -> left ) cout << " ▁ | ▁ left ▁ child : ▁ " << root -> left -> key ; if ( root -> right ) cout << " ▁ | ▁ right ▁ child : ▁ " << root -> right -> key ; cout << endl ; preorder ( root -> left ) ; preorder ( root -> right ) ; } } int main ( ) { Node * root = newNode ( 10 ) ; root -> left = newNode ( 20 ) ; root -> right = newNode ( 30 ) ; root -> left -> left = newNode ( 40 ) ; root -> left -> right = newNode ( 50 ) ; root -> right -> right = newNode ( 70 ) ; cout << " Given ▁ Tree STRNEWLINE " ; preorder ( root ) ; list < bool > struc ; list < int > data ; EncodeSuccinct ( root , struc , data ) ; cout << " Encoded Tree " cout << " Structure ▁ List STRNEWLINE " ; list < bool > :: iterator si ; for ( si = struc . begin ( ) ; si != struc . end ( ) ; ++ si ) cout << * si << " ▁ " ; cout << " Data List " list < int > :: iterator di ; for ( di = data . begin ( ) ; di != data . end ( ) ; ++ di ) cout << * di << " ▁ " ; Node * newroot = DecodeSuccinct ( struc , data ) ; cout << " Preorder traversal of decoded tree " ; preorder ( newroot ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void update ( int arr [ ] , int l , int r , int val ) { arr [ l ] += val ; arr [ r + 1 ] -= val ; } int getElement ( int arr [ ] , int i ) { int res = 0 ; for ( int j = 0 ; j <= i ; j ++ ) res += arr [ j ] ; return res ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int l = 2 , r = 4 , val = 2 ; update ( arr , l , r , val ) ; int index = 4 ; cout << " Element ▁ at ▁ index ▁ " << index << " ▁ is ▁ " << getElement ( arr , index ) << endl ; l = 0 , r = 3 , val = 4 ; update ( arr , l , r , val ) ; index = 3 ; cout << " Element ▁ at ▁ index ▁ " << index << " ▁ is ▁ " << getElement ( arr , index ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void updateBIT ( int BITree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } } int * constructBITree ( int arr [ ] , int n ) { int * BITree = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BITree [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) updateBIT ( BITree , n , i , arr [ i ] ) ; return BITree ; } int getSum ( int BITree [ ] , int index ) { int sum = 0 ; index = index + 1 ; while ( index > 0 ) { sum += BITree [ index ] ; index -= index & ( - index ) ; } return sum ; } void update ( int BITree [ ] , int l , int r , int n , int val ) { updateBIT ( BITree , n , l , val ) ; updateBIT ( BITree , n , r + 1 , - val ) ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * BITree = constructBITree ( arr , n ) ; int l = 2 , r = 4 , val = 2 ; update ( BITree , l , r , n , val ) ; int index = 4 ; cout << " Element ▁ at ▁ index ▁ " << index << " ▁ is ▁ " << getSum ( BITree , index ) << " STRNEWLINE " ; l = 0 , r = 3 , val = 4 ; update ( BITree , l , r , n , val ) ; index = 3 ; cout << " Element ▁ at ▁ index ▁ " << index << " ▁ is ▁ " << getSum ( BITree , index ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int preIndex = 0 ; void printPost ( int in [ ] , int pre [ ] , int inStrt , int inEnd , map < int , int > hm ) { if ( inStrt > inEnd ) return ; int inIndex = hm [ pre [ preIndex ++ ] ] ; printPost ( in , pre , inStrt , inIndex - 1 , hm ) ; printPost ( in , pre , inIndex + 1 , inEnd , hm ) ; cout << in [ inIndex ] << " ▁ " ; } void printPostMain ( int in [ ] , int pre [ ] , int n ) { map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) hm [ in [ i ] ] = i ; printPost ( in , pre , 0 , n - 1 , hm ) ; } int main ( ) { int in [ ] = { 4 , 2 , 5 , 1 , 3 , 6 } ; int pre [ ] = { 1 , 2 , 4 , 5 , 3 , 6 } ; int n = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; printPostMain ( in , pre , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; bool isIsomorphic ( node * n1 , node * n2 ) { if ( n1 == NULL && n2 == NULL ) return true ; if ( n1 == NULL n2 == NULL ) return false ; if ( n1 -> data != n2 -> data ) return false ; return ( isIsomorphic ( n1 -> left , n2 -> left ) && isIsomorphic ( n1 -> right , n2 -> right ) ) || ( isIsomorphic ( n1 -> left , n2 -> right ) && isIsomorphic ( n1 -> right , n2 -> left ) ) ; } node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return ( temp ) ; } int main ( ) { struct node * n1 = newNode ( 1 ) ; n1 -> left = newNode ( 2 ) ; n1 -> right = newNode ( 3 ) ; n1 -> left -> left = newNode ( 4 ) ; n1 -> left -> right = newNode ( 5 ) ; n1 -> right -> left = newNode ( 6 ) ; n1 -> left -> right -> left = newNode ( 7 ) ; n1 -> left -> right -> right = newNode ( 8 ) ; struct node * n2 = newNode ( 1 ) ; n2 -> left = newNode ( 3 ) ; n2 -> right = newNode ( 2 ) ; n2 -> right -> left = newNode ( 4 ) ; n2 -> right -> right = newNode ( 5 ) ; n2 -> left -> right = newNode ( 6 ) ; n2 -> right -> right -> left = newNode ( 8 ) ; n2 -> right -> right -> right = newNode ( 7 ) ; if ( isIsomorphic ( n1 , n2 ) == true ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fastPow ( int N , int K ) { if ( K == 0 ) return 1 ; int temp = fastPow ( N , K / 2 ) ; if ( K % 2 == 0 ) return temp * temp ; else return N * temp * temp ; } int countWays ( int N , int K ) { return K * fastPow ( K - 1 , N - 1 ) ; } int main ( ) { int N = 3 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * newNode = new Node ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return ( newNode ) ; } Node * deleteLeaves ( Node * root , int x ) { if ( root == NULL ) return nullptr ; root -> left = deleteLeaves ( root -> left , x ) ; root -> right = deleteLeaves ( root -> right , x ) ; if ( root -> data == x && root -> left == NULL && root -> right == NULL ) { return nullptr ; } return root ; } void inorder ( Node * root ) { if ( root == NULL ) return ; inorder ( root -> left ) ; cout << root -> data << " ▁ " ; inorder ( root -> right ) ; } int main ( void ) { struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 10 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 1 ) ; root -> right -> right = newNode ( 3 ) ; root -> right -> right -> left = newNode ( 3 ) ; root -> right -> right -> right = newNode ( 3 ) ; deleteLeaves ( root , 3 ) ; cout << " Inorder ▁ traversal ▁ after ▁ deletion ▁ : ▁ " ; inorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; void _deleteTree ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { Node * node = q . front ( ) ; q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; free ( node ) ; } } void deleteTree ( Node * * node_ref ) { _deleteTree ( * node_ref ) ; * node_ref = NULL ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 15 ) ; root -> left = newNode ( 10 ) ; root -> right = newNode ( 20 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( 12 ) ; root -> right -> left = newNode ( 16 ) ; root -> right -> right = newNode ( 25 ) ; deleteTree ( & root ) ; return 0 ; }
#include <iostream> NEW_LINE #include <queue> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int sizeoftree ( Node * root ) { if ( root == NULL ) return 0 ; queue < Node * > q ; int count = 1 ; q . push ( root ) ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; if ( temp -> left ) { count ++ ; q . push ( temp -> left ) ; } if ( temp -> right ) { count ++ ; q . push ( temp -> right ) ; } q . pop ( ) ; } return count ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << " Size ▁ of ▁ the ▁ tree ▁ is ▁ " << sizeoftree ( root ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; int maxDepth ( node * node ) { if ( node == NULL ) return 0 ; else { int lDepth = maxDepth ( node -> left ) ; int rDepth = maxDepth ( node -> right ) ; if ( lDepth > rDepth ) return ( lDepth + 1 ) ; else return ( rDepth + 1 ) ; } } node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << " Height ▁ of ▁ tree ▁ is ▁ " << maxDepth ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPostOrderUtil ( int pre [ ] , int n , int minval , int maxval , int & preIndex ) { if ( preIndex == n ) return ; if ( pre [ preIndex ] < minval pre [ preIndex ] > maxval ) { return ; } int val = pre [ preIndex ] ; preIndex ++ ; findPostOrderUtil ( pre , n , minval , val , preIndex ) ; findPostOrderUtil ( pre , n , val , maxval , preIndex ) ; cout << val << " ▁ " ; } void findPostOrder ( int pre [ ] , int n ) { int preIndex = 0 ; findPostOrderUtil ( pre , n , INT_MIN , INT_MAX , preIndex ) ; } int main ( ) { int pre [ ] = { 40 , 30 , 35 , 80 , 100 } ; int n = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; findPostOrder ( pre , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; int heightOfTreeUtil ( Node * root , bool isEven ) { if ( ! root ) return 0 ; if ( ! root -> left && ! root -> right ) { if ( isEven ) return 1 ; else return 0 ; } int left = heightOfTreeUtil ( root -> left , ! isEven ) ; int right = heightOfTreeUtil ( root -> right , ! isEven ) ; if ( left == 0 && right == 0 ) return 0 ; return ( 1 + max ( left , right ) ) ; } struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int heightOfTree ( Node * root ) { return heightOfTreeUtil ( root , false ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> right -> left = newNode ( 6 ) ; cout << " Height ▁ of ▁ tree ▁ is ▁ " << heightOfTree ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; int height ( node * node ) ; bool isBalanced ( node * root ) { int lh ; int rh ; if ( root == NULL ) return 1 ; lh = height ( root -> left ) ; rh = height ( root -> right ) ; if ( abs ( lh - rh ) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ) ) return 1 ; return 0 ; } int max ( int a , int b ) { return ( a >= b ) ? a : b ; } int height ( node * node ) { if ( node == NULL ) return 0 ; return 1 + max ( height ( node -> left ) , height ( node -> right ) ) ; } node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> left -> left = newNode ( 8 ) ; if ( isBalanced ( root ) ) cout << " Tree ▁ is ▁ balanced " ; else cout << " Tree ▁ is ▁ not ▁ balanced " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return node ; } bool isLeaf ( Node * node ) { return node -> left && node -> left -> right == node && node -> right && node -> right -> left == node ; } int maxDepth ( Node * node ) { if ( node == NULL ) return 0 ; if ( isLeaf ( node ) ) return 1 ; return 1 + max ( maxDepth ( node -> left ) , maxDepth ( node -> right ) ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> left -> left = newNode ( 6 ) ; Node * L1 = root -> left -> left -> left ; Node * L2 = root -> left -> right ; Node * L3 = root -> right ; L1 -> right = L2 , L2 -> right = L3 , L3 -> right = L1 ; L3 -> left = L2 , L2 -> left = L1 , L1 -> left = L3 ; cout << " Height ▁ of ▁ tree ▁ is ▁ " << maxDepth ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } int height ( struct node * node ) { if ( node == NULL ) return 0 ; return 1 + max ( height ( node -> left ) , height ( node -> right ) ) ; } int diameter ( struct node * tree ) { if ( tree == NULL ) return 0 ; int lheight = height ( tree -> left ) ; int rheight = height ( tree -> right ) ; int ldiameter = diameter ( tree -> left ) ; int rdiameter = diameter ( tree -> right ) ; return max ( lheight + rheight + 1 , max ( ldiameter , rdiameter ) ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << " Diameter ▁ of ▁ the ▁ given ▁ binary ▁ tree ▁ is ▁ " << diameter ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int diameterOpt ( struct node * root , int * height ) { int lh = 0 , rh = 0 ; int ldiameter = 0 , rdiameter = 0 ; if ( root == NULL ) { * height = 0 ; return 0 ; } ldiameter = diameterOpt ( root -> left , & lh ) ; rdiameter = diameterOpt ( root -> right , & rh ) ; * height = max ( lh , rh ) + 1 ; return max ( lh + rh + 1 , max ( ldiameter , rdiameter ) ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; int height = 0 ; cout << " Diameter ▁ of ▁ the ▁ given ▁ binary ▁ tree ▁ is ▁ " << diameterOpt ( root , & height ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; int height ( Node * root , int & ans ) { if ( root == NULL ) return 0 ; int left_height = height ( root -> left , ans ) ; int right_height = height ( root -> right , ans ) ; ans = max ( ans , 1 + left_height + right_height ) ; return 1 + max ( left_height , right_height ) ; } int diameter ( Node * root ) { if ( root == NULL ) return 0 ; int ans = INT_MIN ; height ( root , ans ) ; return ans ; } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( " Diameter ▁ is ▁ % d STRNEWLINE " , diameter ( root ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructTree ( int n , int d , int h ) { if ( d == 1 ) { if ( n == 2 && h == 1 ) { cout << "1 ▁ 2" << endl ; return ; } cout << " - 1" << endl ; return ; } if ( d > 2 * h ) { cout << " - 1" << endl ; return ; } for ( int i = 1 ; i <= h ; i ++ ) cout << i << " ▁ " << i + 1 << endl ; if ( d > h ) { cout << "1" << " ▁ " << h + 2 << endl ; for ( int i = h + 2 ; i <= d ; i ++ ) { cout << i << " ▁ " << i + 1 << endl ; } } for ( int i = d + 1 ; i < n ; i ++ ) { int k = 1 ; if ( d == h ) k = 2 ; cout << k << " ▁ " << i + 1 << endl ; } } int main ( ) { int n = 5 , d = 3 , h = 2 ; constructTree ( n , d , h ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ( ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } Node * getDeepestRightLeafNode ( Node * root ) { if ( ! root ) return NULL ; queue < Node * > q ; q . push ( root ) ; Node * result = NULL ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left ) { q . push ( temp -> left ) ; } if ( temp -> right ) { q . push ( temp -> right ) ; if ( ! temp -> right -> left && ! temp -> right -> right ) result = temp -> right ; } } return result ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; root -> right -> right -> right -> right = newNode ( 10 ) ; Node * result = getDeepestRightLeafNode ( root ) ; if ( result ) cout << " Deepest ▁ Right ▁ Leaf ▁ Node ▁ : : ▁ " << result -> data << endl ; else cout << " No ▁ result , ▁ right ▁ leaf ▁ not ▁ found STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } bool isleaf ( Node * curr_node ) { return ( curr_node -> left == NULL && curr_node -> right == NULL ) ; } int deepestOddLevelDepthUtil ( Node * curr_node , int curr_level ) { if ( curr_node == NULL ) return 0 ; curr_level += 1 ; if ( curr_level % 2 != 0 && isleaf ( curr_node ) ) return curr_level ; return max ( deepestOddLevelDepthUtil ( curr_node -> left , curr_level ) , deepestOddLevelDepthUtil ( curr_node -> right , curr_level ) ) ; } int deepestOddLevelDepth ( Node * curr_node ) { return deepestOddLevelDepthUtil ( curr_node , 0 ) ; } int main ( ) { Node * root = newNode ( 10 ) ; root -> left = newNode ( 28 ) ; root -> right = newNode ( 13 ) ; root -> right -> left = newNode ( 14 ) ; root -> right -> right = newNode ( 15 ) ; root -> right -> right -> left = newNode ( 23 ) ; root -> right -> right -> right = newNode ( 24 ) ; cout << deepestOddLevelDepth ( root ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max ( int x , int y ) { return ( x > y ) ? x : y ; } struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int depthOfOddLeafUtil ( struct Node * root , int level ) { if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL && level & 1 ) return level ; return max ( depthOfOddLeafUtil ( root -> left , level + 1 ) , depthOfOddLeafUtil ( root -> right , level + 1 ) ) ; } int depthOfOddLeaf ( struct Node * root ) { int level = 1 , depth = 0 ; return depthOfOddLeafUtil ( root , level ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; root -> right -> right -> right -> right = newNode ( 10 ) ; root -> right -> right -> right -> right -> left = newNode ( 11 ) ; cout << depthOfOddLeaf ( root ) << " ▁ is ▁ the ▁ required ▁ depth " ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ( ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int maxOddLevelDepth ( Node * root ) { if ( ! root ) return 0 ; queue < Node * > q ; q . push ( root ) ; int result = INT_MAX ; int level = 0 ; while ( ! q . empty ( ) ) { int size = q . size ( ) ; level += 1 ; while ( size > 0 ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( ! temp -> left && ! temp -> right && ( level % 2 != 0 ) ) { result = level ; } if ( temp -> left ) { q . push ( temp -> left ) ; } if ( temp -> right ) { q . push ( temp -> right ) ; } size -= 1 ; } } return result ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; root -> right -> right -> right -> right = newNode ( 10 ) ; root -> right -> right -> right -> right -> left = newNode ( 11 ) ; int result = maxOddLevelDepth ( root ) ; if ( result == INT_MAX ) cout << " No ▁ leaf ▁ node ▁ at ▁ odd ▁ level STRNEWLINE " ; else cout << result ; cout << " ▁ is ▁ the ▁ required ▁ depth ▁ " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void find ( Node * root , int level , int & maxLevel , int & res ) { if ( root != NULL ) { find ( root -> left , ++ level , maxLevel , res ) ; if ( level > maxLevel ) { res = root -> data ; maxLevel = level ; } find ( root -> right , level , maxLevel , res ) ; } } int deepestNode ( Node * root ) { int res = -1 ; int maxLevel = -1 ; find ( root , 0 , maxLevel , res ) ; return res ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; cout << deepestNode ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * left , * right ; Node ( int key ) { data = key ; left = NULL ; right = NULL ; } } ; int height ( Node * root ) { if ( ! root ) return 0 ; int leftHt = height ( root -> left ) ; int rightHt = height ( root -> right ) ; return max ( leftHt , rightHt ) + 1 ; } void deepestNode ( Node * root , int levels ) { if ( ! root ) return ; if ( levels == 1 ) cout << root -> data ; else if ( levels > 1 ) { deepestNode ( root -> left , levels - 1 ) ; deepestNode ( root -> right , levels - 1 ) ; } } int main ( ) { Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> left -> left = new Node ( 4 ) ; root -> right -> left = new Node ( 5 ) ; root -> right -> right = new Node ( 6 ) ; root -> right -> left -> right = new Node ( 7 ) ; root -> right -> right -> right = new Node ( 8 ) ; root -> right -> left -> right -> left = new Node ( 9 ) ; int levels = height ( root ) ; deepestNode ( root , levels ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ( ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } Node * getDeepestLeftLeafNode ( Node * root ) { if ( ! root ) return NULL ; queue < Node * > q ; q . push ( root ) ; Node * result = NULL ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left ) { q . push ( temp -> left ) ; if ( ! temp -> left -> left && ! temp -> left -> right ) result = temp -> left ; } if ( temp -> right ) q . push ( temp -> right ) ; } return result ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; root -> right -> right -> right -> right = newNode ( 10 ) ; Node * result = getDeepestLeftLeafNode ( root ) ; if ( result ) cout << " Deepest ▁ Left ▁ Leaf ▁ Node ▁ : : ▁ " << result -> data << endl ; else cout << " No ▁ result , ▁ left ▁ leaf ▁ not ▁ found STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( int item ) { struct Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } void preorder ( Node * root ) { if ( root != NULL ) { printf ( " % d ▁ " , root -> key ) ; preorder ( root -> left ) ; preorder ( root -> right ) ; } } vector < Node * > getTrees ( int arr [ ] , int start , int end ) { vector < Node * > trees ; if ( start > end ) { trees . push_back ( NULL ) ; return trees ; } for ( int i = start ; i <= end ; i ++ ) { vector < Node * > ltrees = getTrees ( arr , start , i - 1 ) ; vector < Node * > rtrees = getTrees ( arr , i + 1 , end ) ; for ( int j = 0 ; j < ltrees . size ( ) ; j ++ ) { for ( int k = 0 ; k < rtrees . size ( ) ; k ++ ) { Node * node = newNode ( arr [ i ] ) ; node -> left = ltrees [ j ] ; node -> right = rtrees [ k ] ; trees . push_back ( node ) ; } } } return trees ; } int main ( ) { int in [ ] = { 4 , 5 , 7 } ; int n = sizeof ( in ) / sizeof ( in [ 0 ] ) ; vector < Node * > trees = getTrees ( in , 0 , n - 1 ) ; cout << " Preorder ▁ traversals ▁ of ▁ different ▁ " << " possible ▁ Binary ▁ Trees ▁ are ▁ STRNEWLINE " ; for ( int i = 0 ; i < trees . size ( ) ; i ++ ) { preorder ( trees [ i ] ) ; printf ( " STRNEWLINE " ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int val ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> val = data ; temp -> left = temp -> right = NULL ; return temp ; } void deepestLeftLeafUtil ( Node * root , int lvl , int * maxlvl , bool isLeft , Node * * resPtr ) { if ( root == NULL ) return ; if ( isLeft && ! root -> left && ! root -> right && lvl > * maxlvl ) { * resPtr = root ; * maxlvl = lvl ; return ; } deepestLeftLeafUtil ( root -> left , lvl + 1 , maxlvl , true , resPtr ) ; deepestLeftLeafUtil ( root -> right , lvl + 1 , maxlvl , false , resPtr ) ; } Node * deepestLeftLeaf ( Node * root ) { int maxlevel = 0 ; Node * result = NULL ; deepestLeftLeafUtil ( root , 0 , & maxlevel , false , & result ) ; return result ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; root -> right -> right -> right -> right = newNode ( 10 ) ; Node * result = deepestLeftLeaf ( root ) ; if ( result ) cout << " The ▁ deepest ▁ left ▁ child ▁ is ▁ " << result -> val ; else cout << " There ▁ is ▁ no ▁ left ▁ leaf ▁ in ▁ the ▁ given ▁ tree " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct qItem { Node * node ; int depth ; } ; int minDepth ( Node * root ) { if ( root == NULL ) return 0 ; queue < qItem > q ; qItem qi = { root , 1 } ; q . push ( qi ) ; while ( q . empty ( ) == false ) { qi = q . front ( ) ; q . pop ( ) ; Node * node = qi . node ; int depth = qi . depth ; if ( node -> left == NULL && node -> right == NULL ) return depth ; if ( node -> left != NULL ) { qi . node = node -> left ; qi . depth = depth + 1 ; q . push ( qi ) ; } if ( node -> right != NULL ) { qi . node = node -> right ; qi . depth = depth + 1 ; q . push ( qi ) ; } } return 0 ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << minDepth ( root ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; Node ( int k ) { data = k ; left = right = NULL ; } } ; int minimumDepth ( Node * root , int level ) { if ( root == NULL ) return level ; level ++ ; return min ( minimumDepth ( root -> left , level ) , minimumDepth ( root -> right , level ) ) ; } int main ( ) { Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> left -> left = new Node ( 4 ) ; root -> left -> right = new Node ( 5 ) ; cout << minimumDepth ( root , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void replaceNode ( struct Node * node , int level = 0 ) { if ( node == NULL ) return ; node -> data = level ; replaceNode ( node -> left , level + 1 ) ; replaceNode ( node -> right , level + 1 ) ; } void printInorder ( struct Node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; cout << node -> data << " ▁ " ; printInorder ( node -> right ) ; } int main ( ) { struct Node * root = new struct Node ; root = newNode ( 3 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; cout << " Before ▁ Replacing ▁ Nodes STRNEWLINE " ; printInorder ( root ) ; replaceNode ( root ) ; cout << endl ; cout << " After ▁ Replacing ▁ Nodes STRNEWLINE " ; printInorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; int getWidth ( node * root , int level ) ; int height ( node * node ) ; node * newNode ( int data ) ; int getMaxWidth ( node * root ) { int maxWidth = 0 ; int width ; int h = height ( root ) ; int i ; for ( i = 1 ; i <= h ; i ++ ) { width = getWidth ( root , i ) ; if ( width > maxWidth ) maxWidth = width ; } return maxWidth ; } int getWidth ( node * root , int level ) { if ( root == NULL ) return 0 ; if ( level == 1 ) return 1 ; else if ( level > 1 ) return getWidth ( root -> left , level - 1 ) + getWidth ( root -> right , level - 1 ) ; } int height ( node * node ) { if ( node == NULL ) return 0 ; else { int lHeight = height ( node -> left ) ; int rHeight = height ( node -> right ) ; return ( lHeight > rHeight ) ? ( lHeight + 1 ) : ( rHeight + 1 ) ; } } node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ; cout << " Maximum ▁ width ▁ is ▁ " << getMaxWidth ( root ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; int maxWidth ( struct Node * root ) { if ( root == NULL ) return 0 ; int result = 0 ; queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { int count = q . size ( ) ; result = max ( count , result ) ; while ( count -- ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left != NULL ) q . push ( temp -> left ) ; if ( temp -> right != NULL ) q . push ( temp -> right ) ; } } return result ; } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ; cout << " Maximum ▁ width ▁ is ▁ " << maxWidth ( root ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; int height ( node * node ) ; node * newNode ( int data ) ; void getMaxWidthRecur ( node * root , int count [ ] , int level ) ; int getMax ( int arr [ ] , int n ) ; int getMaxWidth ( node * root ) { int width ; int h = height ( root ) ; int * count = new int [ h ] ; int level = 0 ; getMaxWidthRecur ( root , count , level ) ; return getMax ( count , h ) ; } void getMaxWidthRecur ( node * root , int count [ ] , int level ) { if ( root ) { count [ level ] ++ ; getMaxWidthRecur ( root -> left , count , level + 1 ) ; getMaxWidthRecur ( root -> right , count , level + 1 ) ; } } int height ( node * node ) { if ( node == NULL ) return 0 ; else { int lHeight = height ( node -> left ) ; int rHeight = height ( node -> right ) ; return ( lHeight > rHeight ) ? ( lHeight + 1 ) : ( rHeight + 1 ) ; } } node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 6 ) ; root -> right -> right -> right = newNode ( 7 ) ; cout << " Maximum ▁ width ▁ is ▁ " << getMaxWidth ( root ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; void lengthUtil ( Node * root , int & maximum , int & minimum , int curr = 0 ) { if ( root == NULL ) return ; lengthUtil ( root -> left , maximum , minimum , curr - 1 ) ; if ( minimum > curr ) minimum = curr ; if ( maximum < curr ) maximum = curr ; lengthUtil ( root -> right , maximum , minimum , curr + 1 ) ; } int getLength ( Node * root ) { int maximum = 0 , minimum = 0 ; lengthUtil ( root , maximum , minimum , 0 ) ; return ( abs ( minimum ) + maximum ) + 1 ; } Node * newNode ( int data ) { Node * curr = new Node ; curr -> data = data ; curr -> left = curr -> right = NULL ; return curr ; } int main ( ) { Node * root = newNode ( 7 ) ; root -> left = newNode ( 6 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 2 ) ; root -> right -> right = newNode ( 1 ) ; cout << getLength ( root ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * left , * right ; Node ( int data_new ) { data = data_new ; left = right = NULL ; } } ; void fillSet ( Node * root , unordered_set < int > & s , int hd ) { if ( ! root ) return ; fillSet ( root -> left , s , hd - 1 ) ; s . insert ( hd ) ; fillSet ( root -> right , s , hd + 1 ) ; } int verticalWidth ( Node * root ) { unordered_set < int > s ; fillSet ( root , s , 0 ) ; return s . size ( ) ; } int main ( ) { Node * root = NULL ; root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> left -> left = new Node ( 4 ) ; root -> left -> right = new Node ( 5 ) ; root -> right -> left = new Node ( 6 ) ; root -> right -> right = new Node ( 7 ) ; root -> right -> left -> right = new Node ( 8 ) ; root -> right -> right -> right = new Node ( 9 ) ; cout << verticalWidth ( root ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } int isSorted ( Node * root ) { int prevMax = INT_MIN ; int minval ; int maxval ; int levelSize ; queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { levelSize = q . size ( ) ; minval = INT_MAX ; maxval = INT_MIN ; while ( levelSize > 0 ) { root = q . front ( ) ; q . pop ( ) ; levelSize -- ; minval = min ( minval , root -> key ) ; maxval = max ( maxval , root -> key ) ; if ( root -> left ) q . push ( root -> left ) ; if ( root -> right ) q . push ( root -> right ) ; } if ( minval <= prevMax ) return 0 ; prevMax = maxval ; } return 1 ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 8 ) ; root -> left -> right -> right = newNode ( 9 ) ; root -> left -> right -> left -> left = newNode ( 12 ) ; root -> left -> right -> right -> right = newNode ( 10 ) ; if ( isSorted ( root ) ) cout << " Sorted " ; else cout << " Not ▁ sorted " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; int hd ; Node * left , * right ; Node ( int key ) { data = key ; hd = INT_MAX ; left = right = NULL ; } } ; void bottomView ( Node * root ) { if ( root == NULL ) return ; int hd = 0 ; map < int , int > m ; queue < Node * > q ; root -> hd = hd ; q . push ( root ) ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; hd = temp -> hd ; m [ hd ] = temp -> data ; if ( temp -> left != NULL ) { temp -> left -> hd = hd - 1 ; q . push ( temp -> left ) ; } if ( temp -> right != NULL ) { temp -> right -> hd = hd + 1 ; q . push ( temp -> right ) ; } } for ( auto i = m . begin ( ) ; i != m . end ( ) ; ++ i ) cout << i -> second << " ▁ " ; } int main ( ) { Node * root = new Node ( 20 ) ; root -> left = new Node ( 8 ) ; root -> right = new Node ( 22 ) ; root -> left -> left = new Node ( 5 ) ; root -> left -> right = new Node ( 3 ) ; root -> right -> left = new Node ( 4 ) ; root -> right -> right = new Node ( 25 ) ; root -> left -> right -> left = new Node ( 10 ) ; root -> left -> right -> right = new Node ( 14 ) ; cout << " Bottom ▁ view ▁ of ▁ the ▁ given ▁ binary ▁ tree ▁ : STRNEWLINE " ; bottomView ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <map> NEW_LINE using namespace std ; struct Node { int data ; int hd ; Node * left , * right ; Node ( int key ) { data = key ; hd = INT_MAX ; left = right = NULL ; } } ; void printBottomViewUtil ( Node * root , int curr , int hd , map < int , pair < int , int > > & m ) { if ( root == NULL ) return ; if ( m . find ( hd ) == m . end ( ) ) { m [ hd ] = make_pair ( root -> data , curr ) ; } else { pair < int , int > p = m [ hd ] ; if ( p . second <= curr ) { m [ hd ] . second = curr ; m [ hd ] . first = root -> data ; } } printBottomViewUtil ( root -> left , curr + 1 , hd - 1 , m ) ; printBottomViewUtil ( root -> right , curr + 1 , hd + 1 , m ) ; } void printBottomView ( Node * root ) { map < int , pair < int , int > > m ; printBottomViewUtil ( root , 0 , 0 , m ) ; map < int , pair < int , int > > :: iterator it ; for ( it = m . begin ( ) ; it != m . end ( ) ; ++ it ) { pair < int , int > p = it -> second ; cout << p . first << " ▁ " ; } } int main ( ) { Node * root = new Node ( 20 ) ; root -> left = new Node ( 8 ) ; root -> right = new Node ( 22 ) ; root -> left -> left = new Node ( 5 ) ; root -> left -> right = new Node ( 3 ) ; root -> right -> left = new Node ( 4 ) ; root -> right -> right = new Node ( 25 ) ; root -> left -> right -> left = new Node ( 10 ) ; root -> left -> right -> right = new Node ( 14 ) ; cout << " Bottom ▁ view ▁ of ▁ the ▁ given ▁ binary ▁ tree ▁ : STRNEWLINE " ; printBottomView ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; unsigned int getLeafCount ( struct node * node ) { if ( node == NULL ) return 0 ; if ( node -> left == NULL && node -> right == NULL ) return 1 ; else return getLeafCount ( node -> left ) + getLeafCount ( node -> right ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << " Leaf ▁ count ▁ of ▁ the ▁ tree ▁ is ▁ : ▁ " << getLeafCount ( root ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; unsigned int getLeafCount ( struct Node * node ) { if ( ! node ) return 0 ; queue < Node * > q ; int count = 0 ; q . push ( node ) ; while ( ! q . empty ( ) ) { struct Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left != NULL ) q . push ( temp -> left ) ; if ( temp -> right != NULL ) q . push ( temp -> right ) ; if ( temp -> left == NULL && temp -> right == NULL ) count ++ ; } return count ; } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << getLeafCount ( root ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; int countLeaves ( struct node * node ) { if ( node == NULL ) { return 0 ; } if ( node -> left == NULL && node -> right == NULL ) { return 1 ; } return countLeaves ( node -> left ) + countLeaves ( node -> right ) ; } struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << countLeaves ( root ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int countNonleaf ( struct Node * root ) { if ( root == NULL || ( root -> left == NULL && root -> right == NULL ) ) return 0 ; return 1 + countNonleaf ( root -> left ) + countNonleaf ( root -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << countNonleaf ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; unsigned int gethalfCount ( struct Node * node ) { if ( ! node ) return 0 ; queue < Node * > q ; q . push ( node ) ; int count = 0 ; while ( ! q . empty ( ) ) { struct Node * temp = q . front ( ) ; q . pop ( ) ; if ( ! temp -> left && temp -> right temp -> left && ! temp -> right ) count ++ ; if ( temp -> left != NULL ) q . push ( temp -> left ) ; if ( temp -> right != NULL ) q . push ( temp -> right ) ; } return count ; } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( void ) { struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; cout << gethalfCount ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; unsigned int gethalfCount ( struct Node * root ) { if ( root == NULL ) return 0 ; int res = 0 ; if ( ( root -> left == NULL && root -> right != NULL ) || ( root -> left != NULL && root -> right == NULL ) ) res ++ ; res += ( gethalfCount ( root -> left ) + gethalfCount ( root -> right ) ) ; return res ; } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( void ) { struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; cout << gethalfCount ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; unsigned int getfullCount ( struct Node * node ) { if ( ! node ) return 0 ; queue < Node * > q ; q . push ( node ) ; int count = 0 ; while ( ! q . empty ( ) ) { struct Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left && temp -> right ) count ++ ; if ( temp -> left != NULL ) q . push ( temp -> left ) ; if ( temp -> right != NULL ) q . push ( temp -> right ) ; } return count ; } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( void ) { struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; cout << getfullCount ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; unsigned int getfullCount ( struct Node * root ) { if ( root == NULL ) return 0 ; int res = 0 ; if ( root -> left && root -> right ) res ++ ; res += ( getfullCount ( root -> left ) + getfullCount ( root -> right ) ) ; return res ; } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( void ) { struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; cout << getfullCount ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right , * nextRight ; } ; void connect ( struct Node * root ) { queue < Node * > q ; q . push ( root ) ; q . push ( NULL ) ; while ( ! q . empty ( ) ) { Node * p = q . front ( ) ; q . pop ( ) ; if ( p != NULL ) { p -> nextRight = q . front ( ) ; if ( p -> left ) q . push ( p -> left ) ; if ( p -> right ) q . push ( p -> right ) ; } else if ( ! q . empty ( ) ) q . push ( NULL ) ; } } struct Node * newnode ( int data ) { struct Node * node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; node -> data = data ; node -> left = node -> right = node -> nextRight = NULL ; return ( node ) ; } int main ( ) { struct Node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 2 ) ; root -> left -> left = newnode ( 3 ) ; root -> right -> right = newnode ( 90 ) ; connect ( root ) ; printf ( " Following ▁ are ▁ populated ▁ nextRight ▁ pointers ▁ in ▁ STRNEWLINE " " the ▁ tree ▁ ( -1 ▁ is ▁ printed ▁ if ▁ there ▁ is ▁ no ▁ nextRight ) ▁ STRNEWLINE " ) ; printf ( " nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE " , root -> data , root -> nextRight ? root -> nextRight -> data : -1 ) ; printf ( " nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE " , root -> left -> data , root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) ; printf ( " nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE " , root -> right -> data , root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) ; printf ( " nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE " , root -> left -> left -> data , root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) ; printf ( " nextRight ▁ of ▁ % d ▁ is ▁ % d ▁ STRNEWLINE " , root -> right -> right -> data , root -> right -> right -> nextRight ? root -> right -> right -> nextRight -> data : -1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; node * nextRight ; node ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; this -> nextRight = NULL ; } } ; node * getNextRight ( node * p ) { node * temp = p -> nextRight ; while ( temp != NULL ) { if ( temp -> left != NULL ) return temp -> left ; if ( temp -> right != NULL ) return temp -> right ; temp = temp -> nextRight ; } return NULL ; } void connectRecur ( node * p ) { node * temp ; if ( ! p ) return ; p -> nextRight = NULL ; while ( p != NULL ) { node * q = p ; while ( q != NULL ) { if ( q -> left ) { if ( q -> right ) q -> left -> nextRight = q -> right ; else q -> left -> nextRight = getNextRight ( q ) ; } if ( q -> right ) q -> right -> nextRight = getNextRight ( q ) ; q = q -> nextRight ; } if ( p -> left ) p = p -> left ; else if ( p -> right ) p = p -> right ; else p = getNextRight ( p ) ; } } int main ( ) { node * root = new node ( 10 ) ; root -> left = new node ( 8 ) ; root -> right = new node ( 2 ) ; root -> left -> left = new node ( 3 ) ; root -> right -> right = new node ( 90 ) ; connectRecur ( root ) ; cout << " Following ▁ are ▁ populated ▁ nextRight ▁ pointers ▁ in ▁ the ▁ tree " " ▁ ( -1 ▁ is ▁ printed ▁ if ▁ there ▁ is ▁ no ▁ nextRight ) ▁ STRNEWLINE " ; cout << " nextRight ▁ of ▁ " << root -> data << " ▁ is ▁ " << ( root -> nextRight ? root -> nextRight -> data : -1 ) << endl ; cout << " nextRight ▁ of ▁ " << root -> left -> data << " ▁ is ▁ " << ( root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) << endl ; cout << " nextRight ▁ of ▁ " << root -> right -> data << " ▁ is ▁ " << ( root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) << endl ; cout << " nextRight ▁ of ▁ " << root -> left -> left -> data << " ▁ is ▁ " << ( root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) << endl ; cout << " nextRight ▁ of ▁ " << root -> right -> right -> data << " ▁ is ▁ " << ( root -> right -> right -> nextRight ? root -> right -> right -> nextRight -> data : -1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; node * nextRight ; node ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; this -> nextRight = NULL ; } } ; void connectRecur ( node * p ) ; void connect ( node * p ) { p -> nextRight = NULL ; connectRecur ( p ) ; } void connectRecur ( node * p ) { if ( ! p ) return ; if ( p -> left ) p -> left -> nextRight = p -> right ; if ( p -> right ) p -> right -> nextRight = ( p -> nextRight ) ? p -> nextRight -> left : NULL ; connectRecur ( p -> left ) ; connectRecur ( p -> right ) ; } int main ( ) { node * root = new node ( 10 ) ; root -> left = new node ( 8 ) ; root -> right = new node ( 2 ) ; root -> left -> left = new node ( 3 ) ; connect ( root ) ; cout << " Following ▁ are ▁ populated ▁ nextRight ▁ pointers ▁ in ▁ the ▁ tree " " ▁ ( -1 ▁ is ▁ printed ▁ if ▁ there ▁ is ▁ no ▁ nextRight ) STRNEWLINE " ; cout << " nextRight ▁ of ▁ " << root -> data << " ▁ is ▁ " << ( root -> nextRight ? root -> nextRight -> data : -1 ) << endl ; cout << " nextRight ▁ of ▁ " << root -> left -> data << " ▁ is ▁ " << ( root -> left -> nextRight ? root -> left -> nextRight -> data : -1 ) << endl ; cout << " nextRight ▁ of ▁ " << root -> right -> data << " ▁ is ▁ " << ( root -> right -> nextRight ? root -> right -> nextRight -> data : -1 ) << endl ; cout << " nextRight ▁ of ▁ " << root -> left -> left -> data << " ▁ is ▁ " << ( root -> left -> left -> nextRight ? root -> left -> left -> nextRight -> data : -1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int maxNodeLevel ( Node * root ) { if ( root == NULL ) return -1 ; queue < Node * > q ; q . push ( root ) ; int level = 0 ; int max = INT_MIN ; int level_no = 0 ; while ( 1 ) { int NodeCount = q . size ( ) ; if ( NodeCount == 0 ) break ; if ( NodeCount > max ) { max = NodeCount ; level_no = level ; } while ( NodeCount > 0 ) { Node * Node = q . front ( ) ; q . pop ( ) ; if ( Node -> left != NULL ) q . push ( Node -> left ) ; if ( Node -> right != NULL ) q . push ( Node -> right ) ; NodeCount -- ; } level ++ ; } return level_no ; } int main ( ) { struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 1 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> right = newNode ( 8 ) ; root -> left -> right -> left = newNode ( 5 ) ; printf ( " Level ▁ having ▁ maximum ▁ number ▁ of ▁ Nodes ▁ : ▁ % d " , maxNodeLevel ( root ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void largestValueInEachLevel ( Node * root ) { if ( ! root ) return ; queue < Node * > q ; int nc , max ; q . push ( root ) ; while ( 1 ) { nc = q . size ( ) ; if ( nc == 0 ) break ; max = INT_MIN ; while ( nc -- ) { Node * front = q . front ( ) ; q . pop ( ) ; if ( max < front -> data ) max = front -> data ; if ( front -> left ) q . push ( front -> left ) ; if ( front -> right ) q . push ( front -> right ) ; } cout << max << " ▁ " ; } } int main ( ) { Node * root = NULL ; root = newNode ( 4 ) ; root -> left = newNode ( 9 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 7 ) ; largestValueInEachLevel ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; node * next ; } ; void populateNext ( node * p ) { static node * next = NULL ; if ( p ) { populateNext ( p -> right ) ; p -> next = next ; next = p ; populateNext ( p -> left ) ; } } node * newnode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; Node -> next = NULL ; return ( Node ) ; } int main ( ) { node * root = newnode ( 10 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 12 ) ; root -> left -> left = newnode ( 3 ) ; populateNext ( root ) ; node * ptr = root -> left -> left ; while ( ptr ) { cout << " Next ▁ of ▁ " << ptr -> data << " ▁ is ▁ " << ( ptr -> next ? ptr -> next -> data : -1 ) << endl ; ptr = ptr -> next ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define INT_MAX  10e6 NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; int heightoftree ( Node * root ) { if ( root == NULL ) return 0 ; int left = heightoftree ( root -> left ) ; int right = heightoftree ( root -> right ) ; return ( ( left > right ? left : right ) + 1 ) ; } void printPerLevelMinimum ( Node * root , vector < int > & res , int level ) { if ( root != NULL ) { printPerLevelMinimum ( root -> left , res , level + 1 ) ; if ( root -> data < res [ level ] ) res [ level ] = root -> data ; printPerLevelMinimum ( root -> right , res , level + 1 ) ; } } void perLevelMinimumUtility ( Node * root ) { int n = heightoftree ( root ) , i ; vector < int > res ( n , INT_MAX ) ; printPerLevelMinimum ( root , res , 0 ) ; cout << " Every ▁ level ▁ minimum ▁ is STRNEWLINE " ; for ( i = 0 ; i < n ; i ++ ) { cout << " level ▁ " << i << " ▁ min ▁ is ▁ = ▁ " << res [ i ] << " STRNEWLINE " ; } } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 7 ) ; root -> left = newNode ( 6 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 2 ) ; root -> right -> right = newNode ( 1 ) ; perLevelMinimumUtility ( root ) ; return 0 ; }
#include <iostream> NEW_LINE #include <queue> NEW_LINE #include <vector> NEW_LINE #define INT_MAX  10e6 NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; int heightoftree ( Node * root ) { if ( root == NULL ) return 0 ; int left = heightoftree ( root -> left ) ; int right = heightoftree ( root -> right ) ; return ( ( left > right ? left : right ) + 1 ) ; } void printPerLevelMinimum ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; q . push ( NULL ) ; int min = INT_MAX ; int level = 0 ; while ( q . empty ( ) == false ) { Node * node = q . front ( ) ; q . pop ( ) ; if ( node == NULL ) { cout << " level ▁ " << level << " ▁ min ▁ is ▁ = ▁ " << min << " STRNEWLINE " ; if ( q . empty ( ) ) break ; q . push ( NULL ) ; level ++ ; min = INT_MAX ; continue ; } if ( min > node -> data ) min = node -> data ; if ( node -> left != NULL ) { q . push ( node -> left ) ; } if ( node -> right != NULL ) { q . push ( node -> right ) ; } } } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 7 ) ; root -> left = newNode ( 6 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 2 ) ; root -> right -> right = newNode ( 1 ) ; cout << " Every ▁ Level ▁ minimum ▁ is " << " STRNEWLINE " ; printPerLevelMinimum ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; int getLevelUtil ( struct node * node , int data , int level ) { if ( node == NULL ) return 0 ; if ( node -> data == data ) return level ; int downlevel = getLevelUtil ( node -> left , data , level + 1 ) ; if ( downlevel != 0 ) return downlevel ; downlevel = getLevelUtil ( node -> right , data , level + 1 ) ; return downlevel ; } int getLevel ( struct node * node , int data ) { return getLevelUtil ( node , data , 1 ) ; } struct node * newNode ( int data ) { struct node * temp = new struct node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { struct node * root = new struct node ; int x ; root = newNode ( 3 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; for ( x = 1 ; x <= 5 ; x ++ ) { int level = getLevel ( root , x ) ; if ( level ) cout << " Level ▁ of ▁ " << x << " ▁ is ▁ " << getLevel ( root , x ) << endl ; else cout << x << " is ▁ not ▁ present ▁ in ▁ tree " << endl ; } getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; node * left ; node * right ; } ; node * getnode ( int data ) { node * newnode = new node ( ) ; newnode -> data = data ; newnode -> left = NULL ; newnode -> right = NULL ; } int getlevel ( node * root , int data ) { queue < node * > q ; int level = 1 ; q . push ( root ) ; q . push ( NULL ) ; while ( ! q . empty ( ) ) { node * temp = q . front ( ) ; q . pop ( ) ; if ( temp == NULL ) { if ( q . front ( ) != NULL ) { q . push ( NULL ) ; } level += 1 ; } else { if ( temp -> data == data ) { return level ; } if ( temp -> left ) { q . push ( temp -> left ) ; } if ( temp -> right ) { q . push ( temp -> right ) ; } } } return 0 ; } int main ( ) { node * root = getnode ( 20 ) ; root -> left = getnode ( 10 ) ; root -> right = getnode ( 30 ) ; root -> left -> left = getnode ( 5 ) ; root -> left -> right = getnode ( 15 ) ; root -> left -> right -> left = getnode ( 12 ) ; root -> right -> left = getnode ( 25 ) ; root -> right -> right = getnode ( 40 ) ; int level = getlevel ( root , 30 ) ; ( level != 0 ) ? ( cout << " level ▁ of ▁ node ▁ 30 ▁ is ▁ " << level << endl ) : ( cout << " node ▁ 30 ▁ not ▁ found " << endl ) ; level = getlevel ( root , 12 ) ; ( level != 0 ) ? ( cout << " level ▁ of ▁ node ▁ 12 ▁ is ▁ " << level << endl ) : ( cout << " node ▁ 12 ▁ not ▁ found " << endl ) ; level = getlevel ( root , 25 ) ; ( level != 0 ) ? ( cout << " level ▁ of ▁ node ▁ 25 ▁ is ▁ " << level << endl ) : ( cout << " node ▁ 25 ▁ not ▁ found " << endl ) ; level = getlevel ( root , 27 ) ; ( level != 0 ) ? ( cout << " level ▁ of ▁ node ▁ 27 ▁ is ▁ " << level << endl ) : ( cout << " node ▁ 27 ▁ not ▁ found " << endl ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( int key ) { struct Node * n = ( struct Node * ) malloc ( sizeof ( struct Node * ) ) ; if ( n != NULL ) { n -> key = key ; n -> left = NULL ; n -> right = NULL ; return n ; } else { cout << " Memory ▁ allocation ▁ failed ! " << endl ; exit ( 1 ) ; } } int findMirrorRec ( int target , struct Node * left , struct Node * right ) { if ( left == NULL right == NULL ) return 0 ; if ( left -> key == target ) return right -> key ; if ( right -> key == target ) return left -> key ; int mirror_val = findMirrorRec ( target , left -> left , right -> right ) ; if ( mirror_val ) return mirror_val ; findMirrorRec ( target , left -> right , right -> left ) ; } int findMirror ( struct Node * root , int target ) { if ( root == NULL ) return 0 ; if ( root -> key == target ) return target ; return findMirrorRec ( target , root -> left , root -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> left -> right = newNode ( 7 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> left -> left = newNode ( 8 ) ; root -> right -> left -> right = newNode ( 9 ) ; int target = root -> left -> left -> key ; int mirror = findMirror ( root , target ) ; if ( mirror ) cout << " Mirror ▁ of ▁ Node ▁ " << target << " ▁ is ▁ Node ▁ " << mirror << endl ; else cout << " Mirror ▁ of ▁ Node ▁ " << target << " ▁ is ▁ NULL ! ▁ " << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int largestSubtreeUtil ( Node * root , string & str , int & maxSize , Node * & maxNode ) { if ( root == NULL ) return 0 ; string left = " " , right = " " ; int ls = largestSubtreeUtil ( root -> left , left , maxSize , maxNode ) ; int rs = largestSubtreeUtil ( root -> right , right , maxSize , maxNode ) ; int size = ls + rs + 1 ; if ( left . compare ( right ) == 0 ) { if ( size > maxSize ) { maxSize = size ; maxNode = root ; } } str . append ( " ▁ " ) . append ( left ) . append ( " ▁ " ) ; str . append ( " ▁ " ) . append ( to_string ( root -> data ) ) . append ( " ▁ " ) ; str . append ( " ▁ " ) . append ( right ) . append ( " ▁ " ) ; return size ; } int largestSubtree ( Node * node , Node * & maxNode ) { int maxSize = 0 ; string str = " " ; largestSubtreeUtil ( node , str , maxSize , maxNode ) ; return maxSize ; } int main ( ) { Node * root = newNode ( 50 ) ; root -> left = newNode ( 10 ) ; root -> right = newNode ( 60 ) ; root -> left -> left = newNode ( 5 ) ; root -> left -> right = newNode ( 20 ) ; root -> right -> left = newNode ( 70 ) ; root -> right -> left -> left = newNode ( 65 ) ; root -> right -> left -> right = newNode ( 80 ) ; root -> right -> right = newNode ( 70 ) ; root -> right -> right -> left = newNode ( 65 ) ; root -> right -> right -> right = newNode ( 80 ) ; Node * maxNode = NULL ; int maxSize = largestSubtree ( root , maxNode ) ; cout << " Largest ▁ Subtree ▁ is ▁ rooted ▁ at ▁ node ▁ " << maxNode -> data << " and its size is " << maxSize ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return ( temp ) ; } bool countSingleRec ( Node * root , int & count ) { if ( root == NULL ) return true ; bool left = countSingleRec ( root -> left , count ) ; bool right = countSingleRec ( root -> right , count ) ; if ( left == false right == false ) return false ; if ( root -> left && root -> data != root -> left -> data ) return false ; if ( root -> right && root -> data != root -> right -> data ) return false ; count ++ ; return true ; } int countSingle ( Node * root ) { int count = 0 ; countSingleRec ( root , count ) ; return count ; } int main ( ) { Node * root = newNode ( 5 ) ; root -> left = newNode ( 4 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> right = newNode ( 5 ) ; cout << " Count ▁ of ▁ Single ▁ Valued ▁ Subtrees ▁ is ▁ " << countSingle ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } void findLeafDown ( Node * root , int lev , int * minDist ) { if ( root == NULL ) return ; if ( root -> left == NULL && root -> right == NULL ) { if ( lev < ( * minDist ) ) * minDist = lev ; return ; } findLeafDown ( root -> left , lev + 1 , minDist ) ; findLeafDown ( root -> right , lev + 1 , minDist ) ; } int findThroughParent ( Node * root , Node * x , int * minDist ) { if ( root == NULL ) return -1 ; if ( root == x ) return 0 ; int l = findThroughParent ( root -> left , x , minDist ) ; if ( l != -1 ) { findLeafDown ( root -> right , l + 2 , minDist ) ; return l + 1 ; } int r = findThroughParent ( root -> right , x , minDist ) ; if ( r != -1 ) { findLeafDown ( root -> left , r + 2 , minDist ) ; return r + 1 ; } return -1 ; } int minimumDistance ( Node * root , Node * x ) { int minDist = INT_MAX ; findLeafDown ( x , 0 , & minDist ) ; findThroughParent ( root , x , & minDist ) ; return minDist ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 13 ) ; root -> right -> left = newNode ( 14 ) ; root -> right -> right = newNode ( 15 ) ; root -> right -> left -> left = newNode ( 21 ) ; root -> right -> left -> right = newNode ( 22 ) ; root -> right -> right -> left = newNode ( 23 ) ; root -> right -> right -> right = newNode ( 24 ) ; root -> right -> left -> left -> left = newNode ( 1 ) ; root -> right -> left -> left -> right = newNode ( 2 ) ; root -> right -> left -> right -> left = newNode ( 3 ) ; root -> right -> left -> right -> right = newNode ( 4 ) ; root -> right -> right -> left -> left = newNode ( 5 ) ; root -> right -> right -> left -> right = newNode ( 6 ) ; root -> right -> right -> right -> left = newNode ( 7 ) ; root -> right -> right -> right -> right = newNode ( 8 ) ; Node * x = root -> right ; cout << " The ▁ closest ▁ leaf ▁ to ▁ the ▁ node ▁ with ▁ value ▁ " << x -> key << " ▁ is ▁ at ▁ a ▁ distance ▁ of ▁ " << minimumDistance ( root , x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { char key ; struct Node * left , * right ; } ; Node * newNode ( char k ) { Node * node = new Node ; node -> key = k ; node -> right = node -> left = NULL ; return node ; } int getMin ( int x , int y ) { return ( x < y ) ? x : y ; } int closestDown ( struct Node * root ) { if ( root == NULL ) return INT_MAX ; if ( root -> left == NULL && root -> right == NULL ) return 0 ; return 1 + getMin ( closestDown ( root -> left ) , closestDown ( root -> right ) ) ; } int findClosestUtil ( struct Node * root , char k , struct Node * ancestors [ ] , int index ) { if ( root == NULL ) return INT_MAX ; if ( root -> key == k ) { int res = closestDown ( root ) ; for ( int i = index - 1 ; i >= 0 ; i -- ) res = getMin ( res , index - i + closestDown ( ancestors [ i ] ) ) ; return res ; } ancestors [ index ] = root ; return getMin ( findClosestUtil ( root -> left , k , ancestors , index + 1 ) , findClosestUtil ( root -> right , k , ancestors , index + 1 ) ) ; } int findClosest ( struct Node * root , char k ) { struct Node * ancestors [ 100 ] ; return findClosestUtil ( root , k , ancestors , 0 ) ; } int main ( ) { struct Node * root = newNode ( ' A ' ) ; root -> left = newNode ( ' B ' ) ; root -> right = newNode ( ' C ' ) ; root -> right -> left = newNode ( ' E ' ) ; root -> right -> right = newNode ( ' F ' ) ; root -> right -> left -> left = newNode ( ' G ' ) ; root -> right -> left -> left -> left = newNode ( ' I ' ) ; root -> right -> left -> left -> right = newNode ( ' J ' ) ; root -> right -> right -> right = newNode ( ' H ' ) ; root -> right -> right -> right -> left = newNode ( ' K ' ) ; char k = ' H ' ; cout << " Distance ▁ of ▁ the ▁ closest ▁ key ▁ from ▁ " << k << " ▁ is ▁ " << findClosest ( root , k ) << endl ; k = ' C ' ; cout << " Distance ▁ of ▁ the ▁ closest ▁ key ▁ from ▁ " << k << " ▁ is ▁ " << findClosest ( root , k ) << endl ; k = ' E ' ; cout << " Distance ▁ of ▁ the ▁ closest ▁ key ▁ from ▁ " << k << " ▁ is ▁ " << findClosest ( root , k ) << endl ; k = ' B ' ; cout << " Distance ▁ of ▁ the ▁ closest ▁ key ▁ from ▁ " << k << " ▁ is ▁ " << findClosest ( root , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; node ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; bool iterativeSearch ( node * root , int x ) { if ( root == NULL ) return false ; queue < node * > q ; q . push ( root ) ; while ( q . empty ( ) == false ) { node * node = q . front ( ) ; if ( node -> data == x ) return true ; q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; } return false ; } int main ( ) { node * NewRoot = NULL ; node * root = new node ( 2 ) ; root -> left = new node ( 7 ) ; root -> right = new node ( 5 ) ; root -> left -> right = new node ( 6 ) ; root -> left -> right -> left = new node ( 1 ) ; root -> left -> right -> right = new node ( 11 ) ; root -> right -> right = new node ( 9 ) ; root -> right -> right -> left = new node ( 4 ) ; iterativeSearch ( root , 6 ) ? cout << " Found STRNEWLINE " : cout << " Not ▁ Found STRNEWLINE " ; iterativeSearch ( root , 12 ) ? cout << " Found STRNEWLINE " : cout << " Not ▁ Found STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; node * next ; } ; void populateNext ( node * root ) { node * next = NULL ; populateNextRecur ( root , & next ) ; } void populateNextRecur ( node * p , node * * next_ref ) { if ( p ) { populateNextRecur ( p -> right , next_ref ) ; p -> next = * next_ref ; * next_ref = p ; populateNextRecur ( p -> left , next_ref ) ; } }
#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; struct node * newNode ( int data ) { struct node * node = new struct node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } bool iterativeSearch ( node * root , int x ) { if ( root == NULL ) return false ; stack < node * > nodeStack ; nodeStack . push ( root ) ; while ( nodeStack . empty ( ) == false ) { struct node * node = nodeStack . top ( ) ; if ( node -> data == x ) return true ; nodeStack . pop ( ) ; if ( node -> right ) nodeStack . push ( node -> right ) ; if ( node -> left ) nodeStack . push ( node -> left ) ; } return false ; } int main ( void ) { struct node * NewRoot = NULL ; struct node * root = newNode ( 2 ) ; root -> left = newNode ( 7 ) ; root -> right = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 1 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> right = newNode ( 9 ) ; root -> right -> right -> left = newNode ( 4 ) ; iterativeSearch ( root , 6 ) ? cout << " Found STRNEWLINE " : cout << " Not ▁ Found STRNEWLINE " ; iterativeSearch ( root , 12 ) ? cout << " Found STRNEWLINE " : cout << " Not ▁ Found STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void Swap ( Node * * a , Node * * b ) { Node * temp = * a ; * a = * b ; * b = temp ; } void swapEveryKLevelUtil ( Node * root , int level , int k ) { if ( root == NULL || ( root -> left == NULL && root -> right == NULL ) ) return ; if ( ( level + 1 ) % k == 0 ) Swap ( & root -> left , & root -> right ) ; swapEveryKLevelUtil ( root -> left , level + 1 , k ) ; swapEveryKLevelUtil ( root -> right , level + 1 , k ) ; } void swapEveryKLevel ( Node * root , int k ) { swapEveryKLevelUtil ( root , 1 , k ) ; } void inorder ( Node * root ) { if ( root == NULL ) return ; inorder ( root -> left ) ; cout << root -> data << " ▁ " ; inorder ( root -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> left = newNode ( 7 ) ; int k = 2 ; cout << " Before ▁ swap ▁ node ▁ : " << endl ; inorder ( root ) ; swapEveryKLevel ( root , k ) ; cout << " After swap Node : " << endl ; inorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newnode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void pathCountUtil ( Node * node , unordered_map < int , int > & m , int path_len ) { if ( node == NULL ) return ; if ( node -> left == NULL && node -> right == NULL ) { m [ path_len ] ++ ; return ; } pathCountUtil ( node -> left , m , path_len + 1 ) ; pathCountUtil ( node -> right , m , path_len + 1 ) ; } void pathCounts ( Node * root ) { unordered_map < int , int > m ; pathCountUtil ( root , m , 1 ) ; for ( auto itr = m . begin ( ) ; itr != m . end ( ) ; itr ++ ) cout << itr -> second << " ▁ paths ▁ have ▁ length ▁ " << itr -> first << endl ; } int main ( ) { struct Node * root = newnode ( 8 ) ; root -> left = newnode ( 5 ) ; root -> right = newnode ( 4 ) ; root -> left -> left = newnode ( 9 ) ; root -> left -> right = newnode ( 7 ) ; root -> right -> right = newnode ( 11 ) ; root -> right -> right -> left = newnode ( 3 ) ; pathCounts ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { Node * left , * right ; int val ; } ; Node * newNode ( int val ) { Node * temp = new Node ( ) ; temp -> val = val ; temp -> left = temp -> right = NULL ; return temp ; } int maxPathLenUtil ( Node * root , int prev_val , int prev_len ) { if ( ! root ) return prev_len ; int cur_val = root -> val ; if ( cur_val == prev_val + 1 ) { return max ( maxPathLenUtil ( root -> left , cur_val , prev_len + 1 ) , maxPathLenUtil ( root -> right , cur_val , prev_len + 1 ) ) ; } int newPathLen = max ( maxPathLenUtil ( root -> left , cur_val , 1 ) , maxPathLenUtil ( root -> right , cur_val , 1 ) ) ; return max ( prev_len , newPathLen ) ; } int maxConsecutivePathLength ( Node * root ) { if ( root == NULL ) return 0 ; return maxPathLenUtil ( root , root -> val - 1 , 0 ) ; } int main ( ) { Node * root = newNode ( 10 ) ; root -> left = newNode ( 11 ) ; root -> right = newNode ( 9 ) ; root -> left -> left = newNode ( 13 ) ; root -> left -> right = newNode ( 12 ) ; root -> right -> left = newNode ( 13 ) ; root -> right -> right = newNode ( 8 ) ; cout << " Maximum ▁ Consecutive ▁ Increasing ▁ Path ▁ Length ▁ is ▁ " << maxConsecutivePathLength ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int val ; struct Node * left , * right ; } ; int length ( Node * node , int * ans ) { if ( ! node ) return 0 ; int left = length ( node -> left , ans ) ; int right = length ( node -> right , ans ) ; int Leftmax = 0 , Rightmax = 0 ; if ( node -> left && node -> left -> val == node -> val ) Leftmax += left + 1 ; if ( node -> right && node -> right -> val == node -> val ) Rightmax += right + 1 ; * ans = max ( * ans , Leftmax + Rightmax ) ; return max ( Leftmax , Rightmax ) ; } int longestSameValuePath ( Node * root ) { int ans = 0 ; length ( root , & ans ) ; return ans ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> val = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = NULL ; root = newNode ( 4 ) ; root -> left = newNode ( 4 ) ; root -> right = newNode ( 4 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 9 ) ; root -> right -> right = newNode ( 5 ) ; cout << longestSameValuePath ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } Node * removeShortPathNodesUtil ( Node * root , int level , int k ) { if ( root == NULL ) return NULL ; root -> left = removeShortPathNodesUtil ( root -> left , level + 1 , k ) ; root -> right = removeShortPathNodesUtil ( root -> right , level + 1 , k ) ; if ( root -> left == NULL && root -> right == NULL && level < k ) { delete root ; return NULL ; } return root ; } Node * removeShortPathNodes ( Node * root , int k ) { int pathLen = 0 ; return removeShortPathNodesUtil ( root , 1 , k ) ; } void printInorder ( Node * root ) { if ( root ) { printInorder ( root -> left ) ; cout << root -> data << " ▁ " ; printInorder ( root -> right ) ; } } int main ( ) { int k = 4 ; Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> left -> left -> left = newNode ( 7 ) ; root -> right -> right = newNode ( 6 ) ; root -> right -> right -> left = newNode ( 8 ) ; cout << " Inorder ▁ Traversal ▁ of ▁ Original ▁ tree " << endl ; printInorder ( root ) ; cout << endl ; cout << " Inorder ▁ Traversal ▁ of ▁ Modified ▁ tree " << endl ; Node * res = removeShortPathNodes ( root , k ) ; printInorder ( res ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void longestConsecutiveUtil ( Node * root , int curLength , int expected , int & res ) { if ( root == NULL ) return ; if ( root -> data == expected ) curLength ++ ; else curLength = 1 ; res = max ( res , curLength ) ; longestConsecutiveUtil ( root -> left , curLength , root -> data + 1 , res ) ; longestConsecutiveUtil ( root -> right , curLength , root -> data + 1 , res ) ; } int longestConsecutive ( Node * root ) { if ( root == NULL ) return 0 ; int res = 0 ; longestConsecutiveUtil ( root , 0 , root -> data , res ) ; return res ; } int main ( ) { Node * root = newNode ( 6 ) ; root -> right = newNode ( 9 ) ; root -> right -> left = newNode ( 7 ) ; root -> right -> right = newNode ( 10 ) ; root -> right -> right -> right = newNode ( 11 ) ; printf ( " % d STRNEWLINE " , longestConsecutive ( root ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int key ) { struct Node * node = new Node ( ) ; node -> left = NULL ; node -> right = NULL ; node -> key = key ; return node ; } void findMaxBendsUtil ( struct Node * node , char dir , int bends , int * maxBends , int soFar , int * len ) { if ( node == NULL ) return ; if ( node -> left == NULL && node -> right == NULL ) { if ( bends > * maxBends ) { * maxBends = bends ; * len = soFar ; } } else { if ( dir == ' l ' ) { findMaxBendsUtil ( node -> left , dir , bends , maxBends , soFar + 1 , len ) ; findMaxBendsUtil ( node -> right , ' r ' , bends + 1 , maxBends , soFar + 1 , len ) ; } else { findMaxBendsUtil ( node -> right , dir , bends , maxBends , soFar + 1 , len ) ; findMaxBendsUtil ( node -> left , ' l ' , bends + 1 , maxBends , soFar + 1 , len ) ; } } } int findMaxBends ( struct Node * node ) { if ( node == NULL ) return 0 ; int len = 0 , bends = 0 , maxBends = -1 ; if ( node -> left ) findMaxBendsUtil ( node -> left , ' l ' , bends , & maxBends , 1 , & len ) ; if ( node -> right ) findMaxBendsUtil ( node -> right , ' r ' , bends , & maxBends , 1 , & len ) ; len ++ ; return len ; } int main ( ) { struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 2 ) ; root -> right -> left -> right = newNode ( 1 ) ; root -> right -> left -> right -> left = newNode ( 9 ) ; cout << findMaxBends ( root ) - 1 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int key ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } struct Node * findLCA ( struct Node * root , int n1 , int n2 ) { if ( root == NULL ) return NULL ; if ( root -> key == n1 root -> key == n2 ) return root ; Node * left_lca = findLCA ( root -> left , n1 , n2 ) ; Node * right_lca = findLCA ( root -> right , n1 , n2 ) ; if ( left_lca && right_lca ) return root ; return ( left_lca != NULL ) ? left_lca : right_lca ; } bool CountTurn ( Node * root , int key , bool turn , int * count ) { if ( root == NULL ) return false ; if ( root -> key == key ) return true ; if ( turn == true ) { if ( CountTurn ( root -> left , key , turn , count ) ) return true ; if ( CountTurn ( root -> right , key , ! turn , count ) ) { * count += 1 ; return true ; } } else { if ( CountTurn ( root -> right , key , turn , count ) ) return true ; if ( CountTurn ( root -> left , key , ! turn , count ) ) { * count += 1 ; return true ; } } return false ; } int NumberOFTurn ( struct Node * root , int first , int second ) { struct Node * LCA = findLCA ( root , first , second ) ; if ( LCA == NULL ) return -1 ; int Count = 0 ; if ( LCA -> key != first && LCA -> key != second ) { if ( CountTurn ( LCA -> right , second , false , & Count ) || CountTurn ( LCA -> left , second , true , & Count ) ) ; if ( CountTurn ( LCA -> left , first , true , & Count ) || CountTurn ( LCA -> right , first , false , & Count ) ) ; return Count + 1 ; } if ( LCA -> key == first ) { CountTurn ( LCA -> right , second , false , & Count ) ; CountTurn ( LCA -> left , second , true , & Count ) ; return Count ; } else { CountTurn ( LCA -> right , first , false , & Count ) ; CountTurn ( LCA -> left , first , true , & Count ) ; return Count ; } } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> right -> left -> left = newNode ( 9 ) ; root -> right -> left -> right = newNode ( 10 ) ; int turn = 0 ; if ( ( turn = NumberOFTurn ( root , 5 , 10 ) ) ) cout << turn << endl ; else cout << " Not ▁ Possible " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right , * abtr ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = node -> abtr = NULL ; return node ; } void preorderTraversal ( Node * root , vector < Node * > * even_ptrs , vector < Node * > * odd_ptrs ) { if ( ! root ) return ; if ( root -> data % 2 == 0 ) ( * even_ptrs ) . push_back ( root ) ; else ( * odd_ptrs ) . push_back ( root ) ; preorderTraversal ( root -> left , even_ptrs , odd_ptrs ) ; preorderTraversal ( root -> right , even_ptrs , odd_ptrs ) ; } void createLoops ( Node * root ) { vector < Node * > even_ptrs , odd_ptrs ; preorderTraversal ( root , & even_ptrs , & odd_ptrs ) ; int i ; for ( i = 1 ; i < even_ptrs . size ( ) ; i ++ ) even_ptrs [ i - 1 ] -> abtr = even_ptrs [ i ] ; even_ptrs [ i - 1 ] -> abtr = even_ptrs [ 0 ] ; for ( i = 1 ; i < odd_ptrs . size ( ) ; i ++ ) odd_ptrs [ i - 1 ] -> abtr = odd_ptrs [ i ] ; odd_ptrs [ i - 1 ] -> abtr = odd_ptrs [ 0 ] ; } void traverseLoop ( Node * start ) { Node * curr = start ; do { cout << curr -> data << " ▁ " ; curr = curr -> abtr ; } while ( curr != start ) ; } int main ( ) { struct Node * root = NULL ; root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; createLoops ( root ) ; cout << " Odd ▁ nodes : ▁ " ; traverseLoop ( root -> right ) ; cout << endl << " Even ▁ nodes : ▁ " ; traverseLoop ( root -> left ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int x ) { Node * temp = new Node ; temp -> data = x ; temp -> left = temp -> right = NULL ; return temp ; } bool isLeaf ( Node * t ) { return ( ( t -> left == NULL ) && ( t -> right == NULL ) ) ; } void findFirstUnmatch ( Node * root1 , Node * root2 ) { if ( root1 == NULL root2 == NULL ) return ; stack < Node * > s1 , s2 ; s1 . push ( root1 ) ; s2 . push ( root2 ) ; while ( ! s1 . empty ( ) || ! s2 . empty ( ) ) { if ( s1 . empty ( ) || s2 . empty ( ) ) return ; Node * temp1 = s1 . top ( ) ; s1 . pop ( ) ; while ( temp1 && ! isLeaf ( temp1 ) ) { s1 . push ( temp1 -> right ) ; s1 . push ( temp1 -> left ) ; temp1 = s1 . top ( ) ; s1 . pop ( ) ; } Node * temp2 = s2 . top ( ) ; s2 . pop ( ) ; while ( temp2 && ! isLeaf ( temp2 ) ) { s2 . push ( temp2 -> right ) ; s2 . push ( temp2 -> left ) ; temp2 = s2 . top ( ) ; s2 . pop ( ) ; } if ( temp1 != NULL && temp2 != NULL ) { if ( temp1 -> data != temp2 -> data ) { cout << " First ▁ non ▁ matching ▁ leaves ▁ : ▁ " << temp1 -> data << " ▁ " << temp2 -> data << endl ; return ; } } } } int main ( ) { struct Node * root1 = newNode ( 5 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 7 ) ; root1 -> left -> left = newNode ( 10 ) ; root1 -> left -> right = newNode ( 11 ) ; struct Node * root2 = newNode ( 6 ) ; root2 -> left = newNode ( 10 ) ; root2 -> right = newNode ( 15 ) ; findFirstUnmatch ( root1 , root2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; int maxOfLeftElement ( Node * root ) { int res = INT_MIN ; if ( root == NULL ) return res ; if ( root -> left != NULL ) res = root -> left -> data ; return max ( { maxOfLeftElement ( root -> left ) , res , maxOfLeftElement ( root -> right ) } ) ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 7 ) ; root -> left = newNode ( 6 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 2 ) ; root -> right -> right = newNode ( 1 ) ; cout << maxOfLeftElement ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define InF  99999 NEW_LINE struct number { int no ; int level ; public : number ( ) { } number ( int n , int l ) : no ( n ) , level ( l ) { } } ; void findnthnumber ( int n ) { queue < number > q ; struct number r ( 0 , 1 ) ; q . push ( r ) ; while ( ! q . empty ( ) ) { struct number temp = q . front ( ) ; q . pop ( ) ; if ( temp . no >= InF temp . no <= - InF ) break ; if ( temp . no == n ) { cout << " Found ▁ number ▁ n ▁ at ▁ level ▁ " << temp . level - 1 ; break ; } q . push ( number ( temp . no + temp . level , temp . level + 1 ) ) ; q . push ( number ( temp . no - temp . level , temp . level + 1 ) ) ; } } int main ( ) { findnthnumber ( 13 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > find ( int n ) { vector < int > ans ; int sum = 0 ; int i ; int sign = ( n >= 0 ? 1 : -1 ) ; n = abs ( n ) ; for ( i = 1 ; sum < n ; i ++ ) { ans . push_back ( sign * i ) ; sum += i ; } if ( sum > sign * n ) { if ( i % 2 ) { sum -= n ; if ( sum % 2 ) { ans . push_back ( sign * i ) ; sum += i ++ ; } ans [ ( sum / 2 ) - 1 ] *= -1 ; } else { sum -= n ; if ( sum % 2 ) { sum -- ; ans . push_back ( sign * i ) ; ans . push_back ( sign * -1 * ( i + 1 ) ) ; } ans [ ( sum / 2 ) - 1 ] *= -1 ; } } return ans ; } int main ( ) { int n = 20 ; if ( n == 0 ) cout << " Minimum ▁ number ▁ of ▁ Steps : ▁ 0 STRNEWLINE Step ▁ sequence : STRNEWLINE 0" ; else { vector < int > a = find ( n ) ; cout << " Minimum ▁ number ▁ of ▁ Steps : ▁ " << a . size ( ) << " Step sequence : " for ( int i : a ) cout << i << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int key ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } void createFactorTree ( struct Node * * node_ref , int v ) { ( * node_ref ) = newNode ( v ) ; for ( int i = 2 ; i < v / 2 ; i ++ ) { if ( v % i != 0 ) continue ; createFactorTree ( & ( ( * node_ref ) -> left ) , i ) ; createFactorTree ( & ( ( * node_ref ) -> right ) , v / i ) ; return ; } } void printLevelOrder ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; while ( q . empty ( ) == false ) { Node * node = q . front ( ) ; cout << node -> key << " ▁ " ; q . pop ( ) ; if ( node -> left != NULL ) q . push ( node -> left ) ; if ( node -> right != NULL ) q . push ( node -> right ) ; } } int main ( ) { int val = 48 ; struct Node * root = NULL ; createFactorTree ( & root , val ) ; cout << " Level ▁ order ▁ traversal ▁ of ▁ " " constructed ▁ factor ▁ tree " ; printLevelOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numoffbt ( int arr [ ] , int n ) { int maxvalue = INT_MIN , minvalue = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { maxvalue = max ( maxvalue , arr [ i ] ) ; minvalue = min ( minvalue , arr [ i ] ) ; } int mark [ maxvalue + 2 ] ; int value [ maxvalue + 2 ] ; memset ( mark , 0 , sizeof ( mark ) ) ; memset ( value , 0 , sizeof ( value ) ) ; for ( int i = 0 ; i < n ; i ++ ) { mark [ arr [ i ] ] = 1 ; value [ arr [ i ] ] = 1 ; } int ans = 0 ; for ( int i = minvalue ; i <= maxvalue ; i ++ ) { if ( mark [ i ] ) { for ( int j = i + i ; j <= maxvalue && j / i <= i ; j += i ) { if ( ! mark [ j ] ) continue ; value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; if ( i != j / i ) value [ j ] = value [ j ] + ( value [ i ] * value [ j / i ] ) ; } } ans += value [ i ] ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << numoffbt ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int countRec ( struct Node * root , int * pcount ) { if ( root == NULL ) return 0 ; int c = countRec ( root -> left , pcount ) ; c += countRec ( root -> right , pcount ) ; if ( root -> data % 2 == 0 ) c += 1 ; if ( c % 2 != 0 ) ( * pcount ) ++ ; return c ; } int countSubtrees ( Node * root ) { int count = 0 ; int * pcount = & count ; countRec ( root , pcount ) ; return count ; } int main ( ) { struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 1 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 10 ) ; root -> right -> left = newNode ( 8 ) ; root -> right -> right = newNode ( 5 ) ; root -> left -> right -> left = newNode ( 6 ) ; printf ( " Count ▁ = ▁ % d " , countSubtrees ( root ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * temp = new Node ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } Node * leftMostNode ( Node * node ) { while ( node != NULL && node -> left != NULL ) node = node -> left ; return node ; } Node * rightMostNode ( Node * node ) { while ( node != NULL && node -> right != NULL ) node = node -> right ; return node ; } Node * findInorderRecursive ( Node * root , Node * x ) { if ( ! root ) return NULL ; if ( root == x || ( temp = findInorderRecursive ( root -> left , x ) ) || ( temp = findInorderRecursive ( root -> right , x ) ) ) { if ( temp ) { if ( root -> left == temp ) { cout << " Inorder ▁ Successor ▁ of ▁ " << x -> data ; cout << " ▁ is ▁ " << root -> data << " STRNEWLINE " ; return NULL ; } } return root ; } return NULL ; } void inorderSuccesor ( Node * root , Node * x ) { if ( x -> right != NULL ) { Node * inorderSucc = leftMostNode ( x -> right ) ; cout << " Inorder ▁ Successor ▁ of ▁ " << x -> data << " ▁ is ▁ " ; cout << inorderSucc -> data << " STRNEWLINE " ; } if ( x -> right == NULL ) { int f = 0 ; Node * rightMost = rightMostNode ( root ) ; if ( rightMost == x ) cout << " No ▁ inorder ▁ successor ! ▁ Right ▁ most ▁ node . STRNEWLINE " ; else findInorderRecursive ( root , x ) ; } } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; inorderSuccesor ( root , root -> right ) ; inorderSuccesor ( root , root -> left -> left ) ; inorderSuccesor ( root , root -> right -> right ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; Node ( int val ) { data = val ; left = NULL ; right = NULL ; } } ; int main ( ) { struct Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> left -> left = new Node ( 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; } int findDistance ( Node * root , int x ) { if ( root == NULL ) return -1 ; int dist = -1 ; if ( ( root -> data == x ) || ( dist = findDistance ( root -> left , x ) ) >= 0 || ( dist = findDistance ( root -> right , x ) ) >= 0 ) return dist + 1 ; return dist ; } int main ( ) { Node * root = newNode ( 5 ) ; root -> left = newNode ( 10 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 20 ) ; root -> left -> right = newNode ( 25 ) ; root -> left -> right -> right = newNode ( 45 ) ; root -> right -> left = newNode ( 30 ) ; root -> right -> right = newNode ( 35 ) ; cout << findDistance ( root , 45 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int data ; Node * left , * right , * parent ; } ; Node * newNode ( int item , Node * parent ) { Node * temp = new Node ; temp -> data = item ; temp -> left = temp -> right = NULL ; temp -> parent = parent ; return temp ; } Node * findRightSibling ( Node * node , int level ) { if ( node == NULL node -> parent == NULL ) return NULL ; while ( node -> parent -> right == node || ( node -> parent -> right == NULL && node -> parent -> left == node ) ) { if ( node -> parent == NULL node -> parent -> parent == NULL ) return NULL ; node = node -> parent ; level -- ; } node = node -> parent -> right ; if ( node == NULL ) return NULL ; while ( level < 0 ) { if ( node -> left != NULL ) node = node -> left ; else if ( node -> right != NULL ) node = node -> right ; else break ; level ++ ; } if ( level == 0 ) return node ; return findRightSibling ( node , level ) ; } int main ( ) { Node * root = newNode ( 1 , NULL ) ; root -> left = newNode ( 2 , root ) ; root -> right = newNode ( 3 , root ) ; root -> left -> left = newNode ( 4 , root -> left ) ; root -> left -> right = newNode ( 6 , root -> left ) ; root -> left -> left -> left = newNode ( 7 , root -> left -> left ) ; root -> left -> left -> left -> left = newNode ( 10 , root -> left -> left -> left ) ; root -> left -> right -> right = newNode ( 9 , root -> left -> right ) ; root -> right -> right = newNode ( 5 , root -> right ) ; root -> right -> right -> right = newNode ( 8 , root -> right -> right ) ; root -> right -> right -> right -> right = newNode ( 12 , root -> right -> right -> right ) ; Node * res = findRightSibling ( root -> left -> left -> left -> left , 0 ) ; if ( res == NULL ) printf ( " No ▁ right ▁ sibling " ) ; else printf ( " % d " , res -> data ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int key ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } Node * nextRightNode ( Node * root , int k , int level , int & value_level ) { if ( root == NULL ) return NULL ; if ( root -> key == k ) { value_level = level ; return NULL ; } else if ( value_level ) { if ( level == value_level ) return root ; } Node * leftNode = nextRightNode ( root -> left , k , level + 1 , value_level ) ; if ( leftNode ) return leftNode ; return nextRightNode ( root -> right , k , level + 1 , value_level ) ; } Node * nextRightNodeUtil ( Node * root , int k ) { int value_level = 0 ; return nextRightNode ( root , k , 1 , value_level ) ; } void test ( Node * root , int k ) { Node * nr = nextRightNodeUtil ( root , k ) ; if ( nr != NULL ) cout << " Next ▁ Right ▁ of ▁ " << k << " ▁ is ▁ " << nr -> key << endl ; else cout << " No ▁ next ▁ right ▁ node ▁ found ▁ for ▁ " << k << endl ; } int main ( ) { Node * root = newNode ( 10 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 6 ) ; root -> right -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( 4 ) ; test ( root , 10 ) ; test ( root , 2 ) ; test ( root , 6 ) ; test ( root , 5 ) ; test ( root , 8 ) ; test ( root , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void threelargest ( Node * root , int & first , int & second , int & third ) { if ( root == NULL ) return ; if ( root -> data > first ) { third = second ; second = first ; first = root -> data ; } else if ( root -> data > second && root -> data != first ) { third = second ; second = root -> data ; } else if ( root -> data > third && root -> data != first && root -> data != second ) third = root -> data ; threelargest ( root -> left , first , second , third ) ; threelargest ( root -> right , first , second , third ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 5 ) ; int first = 0 , second = 0 , third = 0 ; threelargest ( root , first , second , third ) ; cout << " three ▁ largest ▁ elements ▁ are ▁ " << first << " ▁ " << second << " ▁ " << third ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; class Node { public : int data ; Node * left , * right ; Node ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; int findMax ( Node * root ) { if ( root == NULL ) return INT_MIN ; int res = root -> data ; int lres = findMax ( root -> left ) ; int rres = findMax ( root -> right ) ; if ( lres > res ) res = lres ; if ( rres > res ) res = rres ; return res ; } int main ( ) { Node * NewRoot = NULL ; Node * root = new Node ( 2 ) ; root -> left = new Node ( 7 ) ; root -> right = new Node ( 5 ) ; root -> left -> right = new Node ( 6 ) ; root -> left -> right -> left = new Node ( 1 ) ; root -> left -> right -> right = new Node ( 11 ) ; root -> right -> right = new Node ( 9 ) ; root -> right -> right -> left = new Node ( 4 ) ; cout << " Maximum ▁ element ▁ is ▁ " << findMax ( root ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * left , * right ; } ; Node * extractLeafList ( Node * root , Node * * head_ref ) { if ( root == NULL ) return NULL ; if ( root -> left == NULL && root -> right == NULL ) { root -> right = * head_ref ; if ( * head_ref != NULL ) ( * head_ref ) -> left = root ; * head_ref = root ; return NULL ; } root -> right = extractLeafList ( root -> right , head_ref ) ; root -> left = extractLeafList ( root -> left , head_ref ) ; return root ; } Node * newNode ( int data ) { Node * node = new Node ( ) ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } void print ( Node * root ) { if ( root != NULL ) { print ( root -> left ) ; cout << root -> data << " ▁ " ; print ( root -> right ) ; } } void printList ( Node * head ) { while ( head ) { cout << head -> data << " ▁ " ; head = head -> right ; } } int main ( ) { Node * head = NULL ; Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; root -> left -> left -> left = newNode ( 7 ) ; root -> left -> left -> right = newNode ( 8 ) ; root -> right -> right -> left = newNode ( 9 ) ; root -> right -> right -> right = newNode ( 10 ) ; cout << " Inorder ▁ Trvaersal ▁ of ▁ given ▁ Tree ▁ is : STRNEWLINE " ; print ( root ) ; root = extractLeafList ( root , & head ) ; cout << " Extracted Double Linked list is : " ; printList ( head ) ; cout << " Inorder traversal of modified tree is : " print ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left ; Node * right ; } ; Node * newNode ( int val ) { Node * temp = new Node ; temp -> data = val ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } void inorderSuccessor ( Node * root , Node * target_node , Node * & next ) { if ( ! root ) return ; inorderSuccessor ( root -> right , target_node , next ) ; if ( root -> data == target_node -> data ) { if ( next == NULL ) cout << " inorder ▁ successor ▁ of ▁ " << root -> data << " ▁ is : ▁ null STRNEWLINE " ; else cout << " inorder ▁ successor ▁ of ▁ " << root -> data << " ▁ is : ▁ " << next -> data << " STRNEWLINE " ; } next = root ; inorderSuccessor ( root -> left , target_node , next ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; Node * next = NULL ; inorderSuccessor ( root , root -> right , next ) ; next = NULL ; inorderSuccessor ( root , root -> left -> left , next ) ; next = NULL ; inorderSuccessor ( root , root -> right -> right , next ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void addEdge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void printGraph ( vector < int > adj [ ] , int V ) { for ( int v = 0 ; v < V ; ++ v ) { cout << " Adjacency list of vertex " << v < < " head " for ( auto x : adj [ v ] ) cout << " - > ▁ " << x ; printf ( " STRNEWLINE " ) ; } } int main ( ) { int V = 5 ; vector < int > adj [ V ] ; addEdge ( adj , 0 , 1 ) ; addEdge ( adj , 0 , 4 ) ; addEdge ( adj , 1 , 2 ) ; addEdge ( adj , 1 , 3 ) ; addEdge ( adj , 1 , 4 ) ; addEdge ( adj , 2 , 3 ) ; addEdge ( adj , 3 , 4 ) ; printGraph ( adj , V ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Graph { int V ; set < int , greater < int > > * adjList ; } ; Graph * createGraph ( int V ) { Graph * graph = new Graph ; graph -> V = V ; graph -> adjList = new set < int , greater < int > > [ V ] ; return graph ; } void addEdge ( Graph * graph , int src , int dest ) { graph -> adjList [ src ] . insert ( dest ) ; graph -> adjList [ dest ] . insert ( src ) ; } void printGraph ( Graph * graph ) { for ( int i = 0 ; i < graph -> V ; ++ i ) { set < int , greater < int > > lst = graph -> adjList [ i ] ; cout << endl << " Adjacency ▁ list ▁ of ▁ vertex ▁ " << i << endl ; for ( auto itr = lst . begin ( ) ; itr != lst . end ( ) ; ++ itr ) cout << * itr << " ▁ " ; cout << endl ; } } void searchEdge ( Graph * graph , int src , int dest ) { auto itr = graph -> adjList [ src ] . find ( dest ) ; if ( itr == graph -> adjList [ src ] . end ( ) ) cout << endl << " Edge ▁ from ▁ " << src << " ▁ to ▁ " << dest << " ▁ not ▁ found . " << endl ; else cout << endl << " Edge ▁ from ▁ " << src << " ▁ to ▁ " << dest << " ▁ found . " << endl ; } int main ( ) { int V = 5 ; struct Graph * graph = createGraph ( V ) ; addEdge ( graph , 0 , 1 ) ; addEdge ( graph , 0 , 4 ) ; addEdge ( graph , 1 , 2 ) ; addEdge ( graph , 1 , 3 ) ; addEdge ( graph , 1 , 4 ) ; addEdge ( graph , 2 , 3 ) ; addEdge ( graph , 3 , 4 ) ; printGraph ( graph ) ; searchEdge ( graph , 2 , 1 ) ; searchEdge ( graph , 0 , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Graph { int V ; list < int > * adj ; public : Graph :: Graph ( int V ) { this -> V = V ; adj = new list < int > [ V ] ; } void addEdge ( int u , int v ) ; bool DFSUtil ( int , vector < bool > & , vector < int > & , int k ) ; void printKCores ( int k ) ; } ; void Graph :: addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void Graph :: DFSUtil ( int v , vector < bool > & visited , vector < int > & vDegree , int k ) { visited [ v ] = true ; list < int > :: iterator i ; for ( i = adj [ v ] . begin ( ) ; i != adj [ v ] . end ( ) ; ++ i ) { if ( vDegree [ v ] < k ) vDegree [ * i ] -- ; if ( ! visited [ * i ] ) { DFSUtil ( * i , visited , vDegree , k ) } } return ( vDegree [ v ] < k ) ; } void Graph :: printKCores ( int k ) { vector < bool > visited ( V , false ) ; vector < bool > processed ( V , false ) ; int mindeg = INT_MAX ; int startvertex ; vector < int > vDegree ( V ) ; for ( int i = 0 ; i < V ; i ++ ) { vDegree [ i ] = adj [ i ] . size ( ) ; if ( vDegree [ i ] < mindeg ) { mindeg = vDegree [ i ] ; startvertex = i ; } } DFSUtil ( startvertex , visited , vDegree , k ) ; for ( int i = 0 ; i < V ; i ++ ) if ( visited [ i ] == false ) DFSUtil ( i , visited , vDegree , k ) ; cout << " K - Cores ▁ : ▁ STRNEWLINE " ; for ( int v = 0 ; v < V ; v ++ ) { if ( vDegree [ v ] >= k ) { cout << " STRNEWLINE [ " << v << " ] " ; list < int > :: iterator itr ; for ( itr = adj [ v ] . begin ( ) ; itr != adj [ v ] . end ( ) ; ++ itr ) if ( vDegree [ * itr ] >= k ) cout << " ▁ - > ▁ " << * itr ; } } } int main ( ) { int k = 3 ; Graph g1 ( 9 ) ; g1 . addEdge ( 0 , 1 ) ; g1 . addEdge ( 0 , 2 ) ; g1 . addEdge ( 1 , 2 ) ; g1 . addEdge ( 1 , 5 ) ; g1 . addEdge ( 2 , 3 ) ; g1 . addEdge ( 2 , 4 ) ; g1 . addEdge ( 2 , 5 ) ; g1 . addEdge ( 2 , 6 ) ; g1 . addEdge ( 3 , 4 ) ; g1 . addEdge ( 3 , 6 ) ; g1 . addEdge ( 3 , 7 ) ; g1 . addEdge ( 4 , 6 ) ; g1 . addEdge ( 4 , 7 ) ; g1 . addEdge ( 5 , 6 ) ; g1 . addEdge ( 5 , 8 ) ; g1 . addEdge ( 6 , 7 ) ; g1 . addEdge ( 6 , 8 ) ; g1 . printKCores ( k ) ; cout << endl << endl ; Graph g2 ( 13 ) ; g2 . addEdge ( 0 , 1 ) ; g2 . addEdge ( 0 , 2 ) ; g2 . addEdge ( 0 , 3 ) ; g2 . addEdge ( 1 , 4 ) ; g2 . addEdge ( 1 , 5 ) ; g2 . addEdge ( 1 , 6 ) ; g2 . addEdge ( 2 , 7 ) ; g2 . addEdge ( 2 , 8 ) ; g2 . addEdge ( 2 , 9 ) ; g2 . addEdge ( 3 , 10 ) ; g2 . addEdge ( 3 , 11 ) ; g2 . addEdge ( 3 , 12 ) ; g2 . printKCores ( k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLevels ( vector < int > graph [ ] , int V , int x ) { int level [ V ] ; bool marked [ V ] ; queue < int > que ; que . push ( x ) ; level [ x ] = 0 ; marked [ x ] = true ; while ( ! que . empty ( ) ) { x = que . front ( ) ; que . pop ( ) ; for ( int i = 0 ; i < graph [ x ] . size ( ) ; i ++ ) { int b = graph [ x ] [ i ] ; if ( ! marked [ b ] ) { que . push ( b ) ; level [ b ] = level [ x ] + 1 ; marked [ b ] = true ; } } } cout << " Nodes " << " TABSYMBOL " << " Level " << endl ; for ( int i = 0 ; i < V ; i ++ ) cout << " ▁ " << i << " ▁ - - > ▁ " << level [ i ] << endl ; } int main ( ) { int V = 8 ; vector < int > graph [ V ] ; graph [ 0 ] . push_back ( 1 ) ; graph [ 0 ] . push_back ( 2 ) ; graph [ 1 ] . push_back ( 3 ) ; graph [ 1 ] . push_back ( 4 ) ; graph [ 1 ] . push_back ( 5 ) ; graph [ 2 ] . push_back ( 5 ) ; graph [ 2 ] . push_back ( 6 ) ; graph [ 6 ] . push_back ( 7 ) ; printLevels ( graph , V , 0 ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void dfs ( int parent , int ans [ ] , vector < int > connectchars [ ] ) { ans [ parent ] = 1 ; for ( int i = 0 ; i < connectchars [ parent ] . size ( ) ; i ++ ) { if ( ! ans [ connectchars [ parent ] [ i ] ] ) dfs ( connectchars [ parent ] [ i ] , ans , connectchars ) ; } } void printBinaryPalindrome ( int n , int k ) { int arr [ n ] , ans [ n ] = { 0 } ; vector < int > connectchars [ k ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = i % k ; for ( int i = 0 ; i < n / 2 ; i ++ ) { connectchars [ arr [ i ] ] . push_back ( arr [ n - i - 1 ] ) ; connectchars [ arr [ n - i - 1 ] ] . push_back ( arr [ i ] ) ; } dfs ( 0 , ans , connectchars ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ arr [ i ] ] ; } int main ( ) { int n = 10 , k = 4 ; printBinaryPalindrome ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; struct Node * createNode ( int item ) { Node * temp = new Node ; temp -> data = item ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } void NthPostordernode ( struct Node * root , int N ) { static int flag = 0 ; if ( root == NULL ) return ; if ( flag <= N ) { NthPostordernode ( root -> left , N ) ; NthPostordernode ( root -> right , N ) ; flag ++ ; if ( flag == N ) cout << root -> data ; } } int main ( ) { struct Node * root = createNode ( 25 ) ; root -> left = createNode ( 20 ) ; root -> right = createNode ( 30 ) ; root -> left -> left = createNode ( 18 ) ; root -> left -> right = createNode ( 22 ) ; root -> right -> left = createNode ( 24 ) ; root -> right -> right = createNode ( 32 ) ; int N = 6 ; NthPostordernode ( root , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( vector < int > list [ ] , int node , int arrival ) { cout << node << ' ' ; for ( int i = 0 ; i < list [ node ] . size ( ) ; i ++ ) { if ( list [ node ] [ i ] != arrival ) dfs ( list , list [ node ] [ i ] , node ) ; } } int main ( ) { int nodes = 5 ; vector < int > list [ 10000 ] ; list [ 1 ] . push_back ( 2 ) ; list [ 2 ] . push_back ( 1 ) ; list [ 1 ] . push_back ( 3 ) ; list [ 3 ] . push_back ( 1 ) ; list [ 2 ] . push_back ( 4 ) ; list [ 4 ] . push_back ( 2 ) ; list [ 3 ] . push_back ( 5 ) ; list [ 5 ] . push_back ( 3 ) ; dfs ( list , 1 , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long count_color [ 2 ] ; void dfs ( vector < int > adj [ ] , int node , int parent , int color ) { count_color [ color ] ++ ; for ( int i = 0 ; i < adj [ node ] . size ( ) ; i ++ ) { if ( adj [ node ] [ i ] != parent ) dfs ( adj , adj [ node ] [ i ] , node , ! color ) ; } } int findMaxEdges ( vector < int > adj [ ] , int n ) { dfs ( adj , 1 , 0 , 0 ) ; return count_color [ 0 ] * count_color [ 1 ] - ( n - 1 ) ; } int main ( ) { int n = 5 ; vector < int > adj [ n + 1 ] ; adj [ 1 ] . push_back ( 2 ) ; adj [ 1 ] . push_back ( 3 ) ; adj [ 2 ] . push_back ( 4 ) ; adj [ 3 ] . push_back ( 5 ) ; cout << findMaxEdges ( adj , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printpath ( vector < int > & path ) { int size = path . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) cout << path [ i ] << " ▁ " ; cout << endl ; } int isNotVisited ( int x , vector < int > & path ) { int size = path . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) if ( path [ i ] == x ) return 0 ; return 1 ; } void findpaths ( vector < vector < int > > & g , int src , int dst , int v ) { queue < vector < int > > q ; vector < int > path ; path . push_back ( src ) ; q . push ( path ) ; while ( ! q . empty ( ) ) { path = q . front ( ) ; q . pop ( ) ; int last = path [ path . size ( ) - 1 ] ; if ( last == dst ) printpath ( path ) ; for ( int i = 0 ; i < g [ last ] . size ( ) ; i ++ ) { if ( isNotVisited ( g [ last ] [ i ] , path ) ) { vector < int > newpath ( path ) ; newpath . push_back ( g [ last ] [ i ] ) ; q . push ( newpath ) ; } } } } int main ( ) { vector < vector < int > > g ; int v = 4 ; g . resize ( 4 ) ; g [ 0 ] . push_back ( 3 ) ; g [ 0 ] . push_back ( 1 ) ; g [ 0 ] . push_back ( 2 ) ; g [ 1 ] . push_back ( 3 ) ; g [ 2 ] . push_back ( 0 ) ; g [ 2 ] . push_back ( 1 ) ; int src = 2 , dst = 3 ; cout << " path ▁ from ▁ src ▁ " << src << " ▁ to ▁ dst ▁ " << dst << " ▁ are ▁ STRNEWLINE " ; findpaths ( g , src , dst , v ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minEdgeBFS ( vector < int > edges [ ] , int u , int v , int n ) { vector < bool > visited ( n , 0 ) ; vector < int > distance ( n , 0 ) ; queue < int > Q ; distance [ u ] = 0 ; Q . push ( u ) ; visited [ u ] = true ; while ( ! Q . empty ( ) ) { int x = Q . front ( ) ; Q . pop ( ) ; for ( int i = 0 ; i < edges [ x ] . size ( ) ; i ++ ) { if ( visited [ edges [ x ] [ i ] ] ) continue ; distance [ edges [ x ] [ i ] ] = distance [ x ] + 1 ; Q . push ( edges [ x ] [ i ] ) ; visited [ edges [ x ] [ i ] ] = 1 ; } } return distance [ v ] ; } void addEdge ( vector < int > edges [ ] , int u , int v ) { edges [ u ] . push_back ( v ) ; edges [ v ] . push_back ( u ) ; } int main ( ) { int n = 9 ; vector < int > edges [ 9 ] ; addEdge ( edges , 0 , 1 ) ; addEdge ( edges , 0 , 7 ) ; addEdge ( edges , 1 , 7 ) ; addEdge ( edges , 1 , 2 ) ; addEdge ( edges , 2 , 3 ) ; addEdge ( edges , 2 , 5 ) ; addEdge ( edges , 2 , 8 ) ; addEdge ( edges , 3 , 4 ) ; addEdge ( edges , 3 , 5 ) ; addEdge ( edges , 4 , 5 ) ; addEdge ( edges , 5 , 6 ) ; addEdge ( edges , 6 , 7 ) ; addEdge ( edges , 7 , 8 ) ; int u = 0 ; int v = 5 ; cout << minEdgeBFS ( edges , u , v , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dfs ( vector < pair < int , int > > g [ ] , pair < int , int > disRev [ ] , bool visit [ ] , int u ) { visit [ u ] = true ; int totalRev = 0 ; for ( int i = 0 ; i < g [ u ] . size ( ) ; i ++ ) { int v = g [ u ] [ i ] . first ; if ( ! visit [ v ] ) { disRev [ v ] . first = disRev [ u ] . first + 1 ; disRev [ v ] . second = disRev [ u ] . second ; if ( g [ u ] [ i ] . second ) { disRev [ v ] . second = disRev [ u ] . second + 1 ; totalRev ++ ; } totalRev += dfs ( g , disRev , visit , v ) ; } } return totalRev ; } void printMinEdgeReverseForRootNode ( int edges [ ] [ 2 ] , int e ) { int V = e + 1 ; vector < pair < int , int > > g [ V ] ; pair < int , int > disRev [ V ] ; bool visit [ V ] ; int u , v ; for ( int i = 0 ; i < e ; i ++ ) { u = edges [ i ] [ 0 ] ; v = edges [ i ] [ 1 ] ; g [ u ] . push_back ( make_pair ( v , 0 ) ) ; g [ v ] . push_back ( make_pair ( u , 1 ) ) ; } for ( int i = 0 ; i < V ; i ++ ) { visit [ i ] = false ; disRev [ i ] . first = disRev [ i ] . second = 0 ; } int root = 0 ; int totalRev = dfs ( g , disRev , visit , root ) ; int res = INT_MAX ; for ( int i = 0 ; i < V ; i ++ ) { int edgesToRev = ( totalRev - disRev [ i ] . second ) + ( disRev [ i ] . first - disRev [ i ] . second ) ; if ( edgesToRev < res ) { res = edgesToRev ; root = i ; } } cout << root << " ▁ " << res << endl ; } int main ( ) { int edges [ ] [ 2 ] = { { 0 , 1 } , { 2 , 1 } , { 3 , 2 } , { 3 , 4 } , { 5 , 4 } , { 5 , 6 } , { 7 , 6 } } ; int e = sizeof ( edges ) / sizeof ( edges [ 0 ] ) ; printMinEdgeReverseForRootNode ( edges , e ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool dfs ( int residue , int curStep , int wt [ ] , int arr [ ] , int N , int steps ) { if ( curStep > steps ) return true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > residue && arr [ i ] != wt [ curStep - 1 ] ) { wt [ curStep ] = arr [ i ] ; if ( dfs ( arr [ i ] - residue , curStep + 1 , wt , arr , N , steps ) ) return true ; } } return false ; } void printWeightsOnScale ( int arr [ ] , int N , int steps ) { int wt [ steps ] ; if ( dfs ( 0 , 0 , wt , arr , N , steps ) ) { for ( int i = 0 ; i < steps ; i ++ ) cout << wt [ i ] << " ▁ " ; cout << endl ; } else cout << " Not ▁ possible STRNEWLINE " ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int steps = 10 ; printWeightsOnScale ( arr , N , steps ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( vector < int > graph [ ] , bool visited [ ] , int x , int * k ) { for ( int i = 0 ; i < graph [ x ] . size ( ) ; i ++ ) { if ( ! visited [ graph [ x ] [ i ] ] ) { ( * k ) ++ ; visited [ graph [ x ] [ i ] ] = true ; dfs ( graph , visited , graph [ x ] [ i ] , k ) ; } } } int countNonAccessible ( vector < int > graph [ ] , int N ) { bool visited [ N * N + N ] ; memset ( visited , false , sizeof ( visited ) ) ; int ans = 0 ; for ( int i = 1 ; i <= N * N ; i ++ ) { if ( ! visited [ i ] ) { visited [ i ] = true ; int k = 1 ; dfs ( graph , visited , i , & k ) ; ans += k * ( N * N - k ) ; } } return ans ; } void insertpath ( vector < int > graph [ ] , int N , int x1 , int y1 , int x2 , int y2 ) { int a = ( x1 - 1 ) * N + y1 ; int b = ( x2 - 1 ) * N + y2 ; graph [ a ] . push_back ( b ) ; graph [ b ] . push_back ( a ) ; } int main ( ) { int N = 2 ; vector < int > graph [ N * N + 1 ] ; insertpath ( graph , N , 1 , 1 , 1 , 2 ) ; insertpath ( graph , N , 1 , 2 , 2 , 2 ) ; cout << countNonAccessible ( graph , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dfs ( vector < int > g [ ] , int & curMax , int u , int v ) { int max1 = 0 , max2 = 0 , total = 0 ; for ( int i = 0 ; i < g [ u ] . size ( ) ; i ++ ) { if ( g [ u ] [ i ] == v ) continue ; total = max ( total , dfs ( g , curMax , g [ u ] [ i ] , u ) ) ; if ( curMax > max1 ) { max2 = max1 ; max1 = curMax ; } else max2 = max ( max2 , curMax ) ; } total = max ( total , max1 + max2 ) ; curMax = max1 + 1 ; return total ; } int maxProductOfTwoPaths ( vector < int > g [ ] , int N ) { int res = INT_MIN ; int path1 , path2 ; for ( int i = 1 ; i < N + 2 ; i ++ ) { for ( int j = 0 ; j < g [ i ] . size ( ) ; j ++ ) { int curMax = 0 ; path1 = dfs ( g , curMax , g [ i ] [ j ] , i ) ; curMax = 0 ; path2 = dfs ( g , curMax , i , g [ i ] [ j ] ) ; res = max ( res , path1 * path2 ) ; } } return res ; } void addEdge ( vector < int > g [ ] , int u , int v ) { g [ u ] . push_back ( v ) ; g [ v ] . push_back ( u ) ; } int main ( ) { int edges [ ] [ 2 ] = { { 1 , 8 } , { 2 , 6 } , { 3 , 1 } , { 5 , 3 } , { 7 , 8 } , { 8 , 4 } , { 8 , 6 } } ; int N = sizeof ( edges ) / sizeof ( edges [ 0 ] ) ; vector < int > g [ N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) addEdge ( g , edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ) ; cout << maxProductOfTwoPaths ( g , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( int u , int parent , int totalSum , vector < int > edge [ ] , int subtree [ ] , int & res ) { int sum = subtree [ u ] ; for ( int i = 0 ; i < edge [ u ] . size ( ) ; i ++ ) { int v = edge [ u ] [ i ] ; if ( v != parent ) { dfs ( v , u , totalSum , edge , subtree , res ) ; sum += subtree [ v ] ; } } subtree [ u ] = sum ; if ( u != 0 && abs ( totalSum - 2 * sum ) < res ) res = abs ( totalSum - 2 * sum ) ; } int getMinSubtreeSumDifference ( int vertex [ ] , int edges [ ] [ 2 ] , int N ) { int totalSum = 0 ; int subtree [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { subtree [ i ] = vertex [ i ] ; totalSum += vertex [ i ] ; } vector < int > edge [ N ] ; for ( int i = 0 ; i < N - 1 ; i ++ ) { edge [ edges [ i ] [ 0 ] ] . push_back ( edges [ i ] [ 1 ] ) ; edge [ edges [ i ] [ 1 ] ] . push_back ( edges [ i ] [ 0 ] ) ; } int res = INT_MAX ; dfs ( 0 , -1 , totalSum , edge , subtree , res ) ; return res ; } int main ( ) { int vertex [ ] = { 4 , 2 , 1 , 6 , 3 , 5 , 2 } ; int edges [ ] [ 2 ] = { { 0 , 1 } , { 0 , 2 } , { 0 , 3 } , { 2 , 4 } , { 2 , 5 } , { 3 , 6 } } ; int N = sizeof ( vertex ) / sizeof ( vertex [ 0 ] ) ; cout << getMinSubtreeSumDifference ( vertex , edges , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isStepNum ( int n ) { int prevDigit = -1 ; while ( n ) { int curDigit = n % 10 ; if ( prevDigit == -1 ) prevDigit = curDigit ; else { if ( abs ( prevDigit - curDigit ) != 1 ) return false ; } prevDigit = curDigit ; n /= 10 ; } return true ; } void displaySteppingNumbers ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) if ( isStepNum ( i ) ) cout << i << " ▁ " ; } int main ( ) { int n = 0 , m = 21 ; displaySteppingNumbers ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( int n , int m , int stepNum ) { if ( stepNum <= m && stepNum >= n ) cout << stepNum << " ▁ " ; if ( stepNum == 0 stepNum > m ) return ; int lastDigit = stepNum % 10 ; int stepNumA = stepNum * 10 + ( lastDigit - 1 ) ; int stepNumB = stepNum * 10 + ( lastDigit + 1 ) ; if ( lastDigit == 0 ) dfs ( n , m , stepNumB ) ; else if ( lastDigit == 9 ) dfs ( n , m , stepNumA ) ; else { dfs ( n , m , stepNumA ) ; dfs ( n , m , stepNumB ) ; } } void displaySteppingNumbers ( int n , int m ) { for ( int i = 0 ; i <= 9 ; i ++ ) dfs ( n , m , i ) ; } int main ( ) { int n = 0 , m = 21 ; displaySteppingNumbers ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ROW  4 NEW_LINE #define COL  5 NEW_LINE int isSafe ( int M [ ] [ COL ] , int row , int col , bool visited [ ] [ COL ] ) { return ( row >= 0 ) && ( row < ROW ) && ( col >= 0 ) && ( col < COL ) && ( M [ row ] [ col ] && ! visited [ row ] [ col ] ) ; } void DFS ( int M [ ] [ COL ] , int row , int col , bool visited [ ] [ COL ] , int & count ) { static int rowNbr [ ] = { -1 , -1 , -1 , 0 , 0 , 1 , 1 , 1 } ; static int colNbr [ ] = { -1 , 0 , 1 , -1 , 1 , -1 , 0 , 1 } ; visited [ row ] [ col ] = true ; for ( int k = 0 ; k < 8 ; ++ k ) { if ( isSafe ( M , row + rowNbr [ k ] , col + colNbr [ k ] , visited ) ) { count ++ ; DFS ( M , row + rowNbr [ k ] , col + colNbr [ k ] , visited , count ) ; } } } int largestRegion ( int M [ ] [ COL ] ) { bool visited [ ROW ] [ COL ] ; memset ( visited , 0 , sizeof ( visited ) ) ; int result = INT_MIN ; for ( int i = 0 ; i < ROW ; ++ i ) { for ( int j = 0 ; j < COL ; ++ j ) { if ( M [ i ] [ j ] && ! visited [ i ] [ j ] ) { int count = 1 ; DFS ( M , i , j , visited , count ) ; result = max ( result , count ) ; } } } return result ; } int main ( ) { int M [ ] [ COL ] = { { 0 , 0 , 1 , 1 , 0 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 } } ; cout << largestRegion ( M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int V = 5 ; void DFS ( bool graph [ ] [ V ] , bool marked [ ] , int n , int vert , int start , int & count ) { marked [ vert ] = true ; if ( n == 0 ) { marked [ vert ] = false ; if ( graph [ vert ] [ start ] ) { count ++ ; return ; } else return ; } for ( int i = 0 ; i < V ; i ++ ) if ( ! marked [ i ] && graph [ vert ] [ i ] ) DFS ( graph , marked , n - 1 , i , start , count ) ; marked [ vert ] = false ; } int countCycles ( bool graph [ ] [ V ] , int n ) { bool marked [ V ] ; memset ( marked , 0 , sizeof ( marked ) ) ; int count = 0 ; for ( int i = 0 ; i < V - ( n - 1 ) ; i ++ ) { DFS ( graph , marked , n - 1 , i , i , count ) ; marked [ i ] = true ; } return count / 2 ; } int main ( ) { bool graph [ ] [ V ] = { { 0 , 1 , 0 , 1 , 0 } , { 1 , 0 , 1 , 0 , 1 } , { 0 , 1 , 0 , 1 , 0 } , { 1 , 0 , 1 , 0 , 1 } , { 0 , 1 , 0 , 1 , 0 } } ; int n = 4 ; cout << " Total ▁ cycles ▁ of ▁ length ▁ " << n << " ▁ are ▁ " << countCycles ( graph , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define V  4 NEW_LINE void printSolution ( int dist [ ] [ V ] ) ; #define INF  99999 NEW_LINE bool negCyclefloydWarshall ( int graph [ ] [ V ] ) { int dist [ V ] [ V ] , i , j , k ; for ( i = 0 ; i < V ; i ++ ) for ( j = 0 ; j < V ; j ++ ) dist [ i ] [ j ] = graph [ i ] [ j ] ; for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } for ( int i = 0 ; i < V ; i ++ ) if ( dist [ i ] [ i ] < 0 ) return true ; return false ; } int main ( ) { int graph [ V ] [ V ] = { { 0 , 1 , INF , INF } , { INF , 0 , -1 , INF } , { INF , INF , 0 , -1 } , { -1 , INF , INF , 0 } } ; if ( negCyclefloydWarshall ( graph ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool twoColorUtil ( vector < int > G [ ] , int src , int N , int colorArr [ ] ) { colorArr [ src ] = 1 ; queue < int > q ; q . push ( src ) ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; for ( int v = 0 ; v < G [ u ] . size ( ) ; ++ v ) { if ( colorArr [ G [ u ] [ v ] ] == -1 ) { colorArr [ G [ u ] [ v ] ] = 1 - colorArr [ u ] ; q . push ( G [ u ] [ v ] ) ; } else if ( colorArr [ G [ u ] [ v ] ] == colorArr [ u ] ) return false ; } } return true ; } bool twoColor ( vector < int > G [ ] , int N ) { int colorArr [ N ] ; for ( int i = 1 ; i <= N ; ++ i ) colorArr [ i ] = -1 ; for ( int i = 1 ; i <= N ; i ++ ) if ( colorArr [ i ] == -1 ) if ( twoColorUtil ( G , i , N , colorArr ) == false ) return false ; return true ; } bool isOddSum ( int info [ ] [ 3 ] , int n , int m ) { vector < int > G [ 2 * n ] ; int pseudo = n + 1 ; int pseudo_count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( info [ i ] [ 2 ] % 2 == 1 ) { int u = info [ i ] [ 0 ] ; int v = info [ i ] [ 1 ] ; G [ u ] . push_back ( v ) ; G [ v ] . push_back ( u ) ; } else { int u = info [ i ] [ 0 ] ; int v = info [ i ] [ 1 ] ; G [ u ] . push_back ( pseudo ) ; G [ pseudo ] . push_back ( u ) ; G [ v ] . push_back ( pseudo ) ; G [ pseudo ] . push_back ( v ) ; pseudo_count ++ ; pseudo ++ ; } } return twoColor ( G , n + pseudo_count ) ; } int main ( ) { int n = 4 , m = 3 ; int info [ 4 ] [ 3 ] = { { 1 , 2 , 12 } , { 2 , 3 , 1 } , { 4 , 3 , 1 } , { 4 , 1 , 20 } } ; if ( isOddSum ( info , n , m ) == true ) cout << " No STRNEWLINE " ; else cout << " Yes STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCycleRec ( int v , vector < int > adj [ ] , vector < bool > & visited , vector < bool > & recur ) { visited [ v ] = true ; recur [ v ] = true ; for ( int i = 0 ; i < adj [ v ] . size ( ) ; i ++ ) { if ( visited [ adj [ v ] [ i ] ] == false ) { if ( isCycleRec ( adj [ v ] [ i ] , adj , visited , recur ) ) return true ; } else if ( visited [ adj [ v ] [ i ] ] == true && recur [ adj [ v ] [ i ] ] == true ) return true ; } recur [ v ] = false ; return false ; } bool isCycle ( int arr [ ] , int n ) { vector < int > adj [ n ] ; for ( int i = 0 ; i < n ; i ++ ) if ( i != ( i + arr [ i ] + n ) % n ) adj [ i ] . push_back ( ( i + arr [ i ] + n ) % n ) ; vector < bool > visited ( n , false ) ; vector < bool > recur ( n , false ) ; for ( int i = 0 ; i < n ; i ++ ) if ( visited [ i ] == false ) if ( isCycleRec ( i , adj , visited , recur ) ) return true ; return true ; } int main ( void ) { int arr [ ] = { 2 , -1 , 1 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isCycle ( arr , n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
int find ( int parent [ ] , int i ) { if ( parent [ i ] == -1 ) return i ; return find ( parent , parent [ i ] ) ; } void Union ( int parent [ ] , int x , int y ) { int xset = find ( parent , x ) ; int yset = find ( parent , y ) ; parent [ xset ] = yset ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_VERTEX = 101 ; int Arr [ MAX_VERTEX ] ; int size [ MAX_VERTEX ] ; void initialize ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) { Arr [ i ] = i ; size [ i ] = 1 ; } } int find ( int i ) { while ( Arr [ i ] != i ) { Arr [ i ] = Arr [ Arr [ i ] ] ; i = Arr [ i ] ; } return i ; } void _union ( int xr , int yr ) { if ( size [ xr ] < size [ yr ] ) { Arr [ xr ] = Arr [ yr ] ; size [ yr ] += size [ xr ] ; } else { Arr [ yr ] = Arr [ xr ] ; size [ xr ] += size [ yr ] ; } } int isCycle ( vector < int > adj [ ] , int V ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < adj [ i ] . size ( ) ; j ++ ) { int x = find ( i ) ; int y = find ( adj [ i ] [ j ] ) ; if ( x == y ) return 1 ; _union ( x , y ) ; } } return 0 ; } int main ( ) { int V = 3 ; initialize ( V ) ; vector < int > adj [ V ] ; adj [ 0 ] . push_back ( 1 ) ; adj [ 0 ] . push_back ( 2 ) ; adj [ 1 ] . push_back ( 2 ) ; if ( isCycle ( adj , V ) ) cout << " Gxrph ▁ contains ▁ Cycle . STRNEWLINE " ; else cout << " Gxrph ▁ does ▁ not ▁ contain ▁ Cycle . STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mp  make_pair NEW_LINE #define pb  push_back NEW_LINE #define mod  1000000007 NEW_LINE int solve ( int A [ ] , int n ) { int i , cnt = 0 , j ; int parent [ n + 1 ] ; int vis [ n + 1 ] ; memset ( parent , -1 , sizeof ( parent ) ) ; memset ( vis , 0 , sizeof ( vis ) ) ; for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == -1 ) { while ( parent [ j ] == -1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( ! vis [ j ] ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; } int main ( ) { int A [ ] = { 0 , 0 , 0 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << solve ( A , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <queue> NEW_LINE #include <stack> NEW_LINE using namespace std ; struct Node { struct Node * left ; int data ; struct Node * right ; } ; void modifiedLevelOrder ( struct Node * node ) { if ( node == NULL ) return ; if ( node -> left == NULL && node -> right == NULL ) { cout << node -> data ; return ; } queue < Node * > myQueue ; stack < Node * > myStack ; struct Node * temp = NULL ; int sz ; int ct = 0 ; bool rightToLeft = false ; myQueue . push ( node ) ; while ( ! myQueue . empty ( ) ) { ct ++ ; sz = myQueue . size ( ) ; for ( int i = 0 ; i < sz ; i ++ ) { temp = myQueue . front ( ) ; myQueue . pop ( ) ; if ( rightToLeft == false ) cout << temp -> data << " ▁ " ; else myStack . push ( temp ) ; if ( temp -> left ) myQueue . push ( temp -> left ) ; if ( temp -> right ) myQueue . push ( temp -> right ) ; } if ( rightToLeft == true ) { while ( ! myStack . empty ( ) ) { temp = myStack . top ( ) ; myStack . pop ( ) ; cout << temp -> data << " ▁ " ; } } if ( ct == 2 ) { rightToLeft = ! rightToLeft ; ct = 0 ; } cout << " STRNEWLINE " ; } } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 3 ) ; root -> left -> right -> right = newNode ( 1 ) ; root -> right -> left -> left = newNode ( 4 ) ; root -> right -> left -> right = newNode ( 2 ) ; root -> right -> right -> left = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 2 ) ; root -> left -> right -> left -> left = newNode ( 16 ) ; root -> left -> right -> left -> right = newNode ( 17 ) ; root -> right -> left -> right -> left = newNode ( 18 ) ; root -> right -> right -> left -> right = newNode ( 19 ) ; modifiedLevelOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minnode ( int n , int keyval [ ] , bool mstset [ ] ) { int mini = numeric_limits < int > :: max ( ) ; int mini_index ; for ( int i = 0 ; i < n ; i ++ ) { if ( mstset [ i ] == false && keyval [ i ] < mini ) { mini = keyval [ i ] , mini_index = i ; } } return mini_index ; } void findcost ( int n , vector < vector < int > > city ) { int parent [ n ] ; int keyval [ n ] ; bool mstset [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { keyval [ i ] = numeric_limits < int > :: max ( ) ; mstset [ i ] = false ; } parent [ 0 ] = -1 ; keyval [ 0 ] = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int u = minnode ( n , keyval , mstset ) ; mstset [ u ] = true ; for ( int v = 0 ; v < n ; v ++ ) { if ( city [ u ] [ v ] && mstset [ v ] == false && city [ u ] [ v ] < keyval [ v ] ) { keyval [ v ] = city [ u ] [ v ] ; parent [ v ] = u ; } } } int cost = 0 ; for ( int i = 1 ; i < n ; i ++ ) cost += city [ parent [ i ] ] [ i ] ; cout << cost << endl ; } int main ( ) { int n1 = 5 ; vector < vector < int > > city1 = { { 0 , 1 , 2 , 3 , 4 } , { 1 , 0 , 5 , 0 , 7 } , { 2 , 5 , 0 , 6 , 0 } , { 3 , 0 , 6 , 0 , 0 } , { 4 , 7 , 0 , 0 , 0 } } ; findcost ( n1 , city1 ) ; int n2 = 6 ; vector < vector < int > > city2 = { { 0 , 1 , 1 , 100 , 0 , 0 } , { 1 , 0 , 1 , 0 , 0 , 0 } , { 1 , 1 , 0 , 0 , 0 , 0 } , { 100 , 0 , 0 , 0 , 2 , 2 } , { 0 , 0 , 0 , 2 , 0 , 2 } , { 0 , 0 , 0 , 2 , 2 , 0 } } ; findcost ( n2 , city2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define V  5 NEW_LINE int minKey ( int key [ ] , bool mstSet [ ] ) { int min = INT_MAX , min_index ; for ( int v = 0 ; v < V ; v ++ ) if ( mstSet [ v ] == false && key [ v ] < min ) min = key [ v ] , min_index = v ; return min_index ; } int printMST ( int parent [ ] , int n , int graph [ V ] [ V ] ) { printf ( " Edge ▁ Weight STRNEWLINE " ) ; int minProduct = 1 ; for ( int i = 1 ; i < V ; i ++ ) { printf ( " % d ▁ - ▁ % d ▁ % d ▁ STRNEWLINE " , parent [ i ] , i , graph [ i ] [ parent [ i ] ] ) ; minProduct *= graph [ i ] [ parent [ i ] ] ; } printf ( " Minimum ▁ Obtainable ▁ product ▁ is ▁ % d STRNEWLINE " , minProduct ) ; } void primMST ( int inputGraph [ V ] [ V ] , double logGraph [ V ] [ V ] ) { int parent [ V ] ; int key [ V ] ; bool mstSet [ V ] ; for ( int i = 0 ; i < V ; i ++ ) key [ i ] = INT_MAX , mstSet [ i ] = false ; key [ 0 ] = 0 ; parent [ 0 ] = -1 ; for ( int count = 0 ; count < V - 1 ; count ++ ) { int u = minKey ( key , mstSet ) ; mstSet [ u ] = true ; for ( int v = 0 ; v < V ; v ++ ) if ( logGraph [ u ] [ v ] > 0 && mstSet [ v ] == false && logGraph [ u ] [ v ] < key [ v ] ) parent [ v ] = u , key [ v ] = logGraph [ u ] [ v ] ; } printMST ( parent , V , inputGraph ) ; } void minimumProductMST ( int graph [ V ] [ V ] ) { double logGraph [ V ] [ V ] ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( graph [ i ] [ j ] > 0 ) logGraph [ i ] [ j ] = log ( graph [ i ] [ j ] ) ; else logGraph [ i ] [ j ] = 0 ; } } primMST ( graph , logGraph ) ; } int main ( ) { int graph [ V ] [ V ] = { { 0 , 2 , 0 , 6 , 0 } , { 2 , 0 , 3 , 8 , 5 } , { 0 , 3 , 0 , 0 , 7 } , { 6 , 8 , 0 , 0 , 9 } , { 0 , 5 , 7 , 9 , 0 } , } ; minimumProductMST ( graph ) ; return 0 ; }
#include <iostream> NEW_LINE #include <stack> NEW_LINE #include <queue> NEW_LINE using namespace std ; #define LEFT  0 NEW_LINE #define RIGHT  1 NEW_LINE #define ChangeDirection ( Dir )  ((Dir) = 1 - (Dir)) NEW_LINE struct node { int data ; struct node * left , * right ; } ; node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void modifiedLevelOrder ( struct node * root ) { if ( ! root ) return ; int dir = LEFT ; struct node * temp ; queue < struct node * > Q ; stack < struct node * > S ; S . push ( root ) ; while ( ! Q . empty ( ) || ! S . empty ( ) ) { while ( ! S . empty ( ) ) { temp = S . top ( ) ; S . pop ( ) ; cout << temp -> data << " ▁ " ; if ( dir == LEFT ) { if ( temp -> left ) Q . push ( temp -> left ) ; if ( temp -> right ) Q . push ( temp -> right ) ; } else { if ( temp -> right ) Q . push ( temp -> right ) ; if ( temp -> left ) Q . push ( temp -> left ) ; } } cout << endl ; while ( ! Q . empty ( ) ) { temp = Q . front ( ) ; Q . pop ( ) ; cout << temp -> data << " ▁ " ; if ( dir == LEFT ) { if ( temp -> left ) S . push ( temp -> left ) ; if ( temp -> right ) S . push ( temp -> right ) ; } else { if ( temp -> right ) S . push ( temp -> right ) ; if ( temp -> left ) S . push ( temp -> left ) ; } } cout << endl ; ChangeDirection ( dir ) ; } } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 3 ) ; root -> left -> right -> right = newNode ( 1 ) ; root -> right -> left -> left = newNode ( 4 ) ; root -> right -> left -> right = newNode ( 2 ) ; root -> right -> right -> left = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 2 ) ; root -> left -> right -> left -> left = newNode ( 16 ) ; root -> left -> right -> left -> right = newNode ( 17 ) ; root -> right -> left -> right -> left = newNode ( 18 ) ; root -> right -> right -> left -> right = newNode ( 19 ) ; modifiedLevelOrder ( root ) ; return 0 ; }
#include <iostream> NEW_LINE #include <queue> NEW_LINE using namespace std ; struct Node { int data ; Node * left ; Node * right ; } ; Node * CreateNode ( int data ) { Node * newNode = new Node ( ) ; if ( ! newNode ) { cout << " Memory ▁ error STRNEWLINE " ; return NULL ; } newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return newNode ; } void inorder ( Node * temp ) { if ( temp == NULL ) return ; inorder ( temp -> left ) ; cout << temp -> data << ' ▁ ' ; inorder ( temp -> right ) ; } Node * InsertNode ( Node * root , int data ) { if ( root == NULL ) { root = CreateNode ( data ) ; return root ; } queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp -> left != NULL ) q . push ( temp -> left ) ; else { temp -> left = CreateNode ( data ) ; return root ; } if ( temp -> right != NULL ) q . push ( temp -> right ) ; else { temp -> right = CreateNode ( data ) ; return root ; } } } int main ( ) { Node * root = CreateNode ( 10 ) ; root -> left = CreateNode ( 11 ) ; root -> left -> left = CreateNode ( 7 ) ; root -> right = CreateNode ( 9 ) ; root -> right -> left = CreateNode ( 15 ) ; root -> right -> right = CreateNode ( 8 ) ; cout << " Inorder ▁ traversal ▁ before ▁ insertion : ▁ " ; inorder ( root ) ; cout << endl ; int key = 12 ; root = InsertNode ( root , key ) ; cout << " Inorder ▁ traversal ▁ after ▁ insertion : ▁ " ; inorder ( root ) ; cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void TOWUtil ( int * arr , int n , bool * curr_elements , int no_of_selected_elements , bool * soln , int * min_diff , int sum , int curr_sum , int curr_position ) { if ( curr_position == n ) return ; if ( ( n / 2 - no_of_selected_elements ) > ( n - curr_position ) ) return ; TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , min_diff , sum , curr_sum , curr_position + 1 ) ; no_of_selected_elements ++ ; curr_sum = curr_sum + arr [ curr_position ] ; curr_elements [ curr_position ] = true ; if ( no_of_selected_elements == n / 2 ) { if ( abs ( sum / 2 - curr_sum ) < * min_diff ) { * min_diff = abs ( sum / 2 - curr_sum ) ; for ( int i = 0 ; i < n ; i ++ ) soln [ i ] = curr_elements [ i ] ; } } else { TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , min_diff , sum , curr_sum , curr_position + 1 ) ; } curr_elements [ curr_position ] = false ; } void tugOfWar ( int * arr , int n ) { bool * curr_elements = new bool [ n ] ; bool * soln = new bool [ n ] ; int min_diff = INT_MAX ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; curr_elements [ i ] = soln [ i ] = false ; } TOWUtil ( arr , n , curr_elements , 0 , soln , & min_diff , sum , 0 , 0 ) ; cout << " The ▁ first ▁ subset ▁ is : ▁ " ; for ( int i = 0 ; i < n ; i ++ ) { if ( soln [ i ] == true ) cout << arr [ i ] << " ▁ " ; } cout << " The second subset is : " for ( int i = 0 ; i < n ; i ++ ) { if ( soln [ i ] == false ) cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 23 , 45 , -34 , 12 , 0 , 98 , -99 , 4 , 189 , -1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; tugOfWar ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  8 NEW_LINE int solveKTUtil ( int x , int y , int movei , int sol [ N ] [ N ] , int xMove [ ] , int yMove [ ] ) ; int isSafe ( int x , int y , int sol [ N ] [ N ] ) { return ( x >= 0 && x < N && y >= 0 && y < N && sol [ x ] [ y ] == -1 ) ; } void printSolution ( int sol [ N ] [ N ] ) { for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < N ; y ++ ) cout << " ▁ " << setw ( 2 ) << sol [ x ] [ y ] << " ▁ " ; cout << endl ; } } int solveKT ( ) { int sol [ N ] [ N ] ; for ( int x = 0 ; x < N ; x ++ ) for ( int y = 0 ; y < N ; y ++ ) sol [ x ] [ y ] = -1 ; int xMove [ 8 ] = { 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 } ; int yMove [ 8 ] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 } ; sol [ 0 ] [ 0 ] = 0 ; if ( solveKTUtil ( 0 , 0 , 1 , sol , xMove , yMove ) == 0 ) { cout << " Solution ▁ does ▁ not ▁ exist " ; return 0 ; } else printSolution ( sol ) ; return 1 ; } int solveKTUtil ( int x , int y , int movei , int sol [ N ] [ N ] , int xMove [ N ] , int yMove [ N ] ) { int k , next_x , next_y ; if ( movei == N * N ) return 1 ; for ( k = 0 ; k < 8 ; k ++ ) { next_x = x + xMove [ k ] ; next_y = y + yMove [ k ] ; if ( isSafe ( next_x , next_y , sol ) ) { sol [ next_x ] [ next_y ] = movei ; if ( solveKTUtil ( next_x , next_y , movei + 1 , sol , xMove , yMove ) == 1 ) return 1 ; else sol [ next_x ] [ next_y ] = -1 ; } } return 0 ; } int main ( ) { solveKT ( ) ; return 0 ; }
#include <stdio.h> NEW_LINE #define N  4 NEW_LINE bool solveMazeUtil ( int maze [ N ] [ N ] , int x , int y , int sol [ N ] [ N ] ) ; void printSolution ( int sol [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( " ▁ % d ▁ " , sol [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } } bool isSafe ( int maze [ N ] [ N ] , int x , int y ) { if ( x >= 0 && x < N && y >= 0 && y < N && maze [ x ] [ y ] == 1 ) return true ; return false ; } bool solveMaze ( int maze [ N ] [ N ] ) { int sol [ N ] [ N ] = { { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; if ( solveMazeUtil ( maze , 0 , 0 , sol ) == false ) { printf ( " Solution ▁ doesn ' t ▁ exist " ) ; return false ; } printSolution ( sol ) ; return true ; } bool solveMazeUtil ( int maze [ N ] [ N ] , int x , int y , int sol [ N ] [ N ] ) { if ( x == N - 1 && y == N - 1 && maze [ x ] [ y ] == 1 ) { sol [ x ] [ y ] = 1 ; return true ; } if ( isSafe ( maze , x , y ) == true ) { if ( sol [ x ] [ y ] == 1 ) return false ; sol [ x ] [ y ] = 1 ; if ( solveMazeUtil ( maze , x + 1 , y , sol ) == true ) return true ; if ( solveMazeUtil ( maze , x , y + 1 , sol ) == true ) return true ; if ( solveMazeUtil ( maze , x - 1 , y , sol ) == true ) return true ; if ( solveMazeUtil ( maze , x , y - 1 , sol ) == true ) return true ; sol [ x ] [ y ] = 0 ; return false ; } return false ; } int main ( ) { int maze [ N ] [ N ] = { { 1 , 0 , 0 , 0 } , { 1 , 1 , 0 , 1 } , { 0 , 1 , 0 , 0 } , { 1 , 1 , 1 , 1 } } ; solveMaze ( maze ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define V  4 NEW_LINE void printSolution ( int color [ ] ) ; void printSolution ( int color [ ] ) { cout << " Solution ▁ Exists : " " ▁ Following ▁ are ▁ the ▁ assigned ▁ colors ▁ STRNEWLINE " ; for ( int i = 0 ; i < V ; i ++ ) cout << " ▁ " << color [ i ] ; cout << " STRNEWLINE " ; } bool isSafe ( bool graph [ V ] [ V ] , int color [ ] ) { for ( int i = 0 ; i < V ; i ++ ) for ( int j = i + 1 ; j < V ; j ++ ) if ( graph [ i ] [ j ] && color [ j ] == color [ i ] ) return false ; return true ; } bool graphColoring ( bool graph [ V ] [ V ] , int m , int i , int color [ V ] ) { if ( i == V ) { if ( isSafe ( graph , color ) ) { printSolution ( color ) ; return true ; } return false ; } for ( int j = 1 ; j <= m ; j ++ ) { color [ i ] = j ; if ( graphColoring ( graph , m , i + 1 , color ) ) return true ; color [ i ] = 0 ; } return false ; } int main ( ) { bool graph [ V ] [ V ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } , } ; int m = 3 ; int color [ V ] ; for ( int i = 0 ; i < V ; i ++ ) color [ i ] = 0 ; if ( ! graphColoring ( graph , m , 0 , color ) ) cout << " Solution ▁ does ▁ not ▁ exist " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; class node { public : int color = 1 ; set < int > edges ; } ; int canPaint ( vector < node > & nodes , int n , int m ) { vector < int > visited ( n + 1 , 0 ) ; int maxColors = 1 ; for ( int sv = 1 ; sv <= n ; sv ++ ) { if ( visited [ sv ] ) continue ; visited [ sv ] = 1 ; queue < int > q ; q . push ( sv ) ; while ( ! q . empty ( ) ) { int top = q . front ( ) ; q . pop ( ) ; for ( auto it = nodes [ top ] . edges . begin ( ) ; it != nodes [ top ] . edges . end ( ) ; it ++ ) { if ( nodes [ top ] . color == nodes [ * it ] . color ) nodes [ * it ] . color += 1 ; maxColors = max ( maxColors , max ( nodes [ top ] . color , nodes [ * it ] . color ) ) ; if ( maxColors > m ) return 0 ; if ( ! visited [ * it ] ) { visited [ * it ] = 1 ; q . push ( * it ) ; } } } } return 1 ; } int main ( ) { int n = 4 ; bool graph [ n ] [ n ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } } ; int m = 3 ; vector < node > nodes ( n + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( graph [ i ] [ j ] ) { nodes [ i ] . edges . insert ( i ) ; nodes [ j ] . edges . insert ( j ) ; } } } cout << canPaint ( nodes , n , m ) ; cout << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define V  4 NEW_LINE #define INF  INT_MAX NEW_LINE int shortestPath ( int graph [ ] [ V ] , int u , int v , int k ) { if ( k == 0 && u == v ) return 0 ; if ( k == 1 && graph [ u ] [ v ] != INF ) return graph [ u ] [ v ] ; if ( k <= 0 ) return INF ; int res = INF ; for ( int i = 0 ; i < V ; i ++ ) { if ( graph [ u ] [ i ] != INF && u != i && v != i ) { int rec_res = shortestPath ( graph , i , v , k - 1 ) ; if ( rec_res != INF ) res = min ( res , graph [ u ] [ i ] + rec_res ) ; } } return res ; } int main ( ) { int graph [ V ] [ V ] = { { 0 , 10 , 3 , 2 } , { INF , 0 , INF , 7 } , { INF , INF , 0 , 6 } , { INF , INF , INF , 0 } } ; int u = 0 , v = 3 , k = 2 ; cout << " Weight ▁ of ▁ the ▁ shortest ▁ path ▁ is ▁ " << shortestPath ( graph , u , v , k ) ; return 0 ; }
#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; #define V  4 NEW_LINE #define INF  INT_MAX NEW_LINE int shortestPath ( int graph [ ] [ V ] , int u , int v , int k ) { int sp [ V ] [ V ] [ k + 1 ] ; for ( int e = 0 ; e <= k ; e ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { sp [ i ] [ j ] [ e ] = INF ; if ( e == 0 && i == j ) sp [ i ] [ j ] [ e ] = 0 ; if ( e == 1 && graph [ i ] [ j ] != INF ) sp [ i ] [ j ] [ e ] = graph [ i ] [ j ] ; if ( e > 1 ) { for ( int a = 0 ; a < V ; a ++ ) { if ( graph [ i ] [ a ] != INF && i != a && j != a && sp [ a ] [ j ] [ e - 1 ] != INF ) sp [ i ] [ j ] [ e ] = min ( sp [ i ] [ j ] [ e ] , graph [ i ] [ a ] + sp [ a ] [ j ] [ e - 1 ] ) ; } } } } } return sp [ u ] [ v ] [ k ] ; } int main ( ) { int graph [ V ] [ V ] = { { 0 , 10 , 3 , 2 } , { INF , 0 , INF , 7 } , { INF , INF , 0 , 6 } , { INF , INF , INF , 0 } } ; int u = 0 , v = 3 , k = 2 ; cout << shortestPath ( graph , u , v , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  8 NEW_LINE #define INF  INT_MAX NEW_LINE int shortestDist ( int graph [ N ] [ N ] ) { int dist [ N ] ; dist [ N - 1 ] = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { dist [ i ] = INF ; for ( int j = i ; j < N ; j ++ ) { if ( graph [ i ] [ j ] == INF ) continue ; dist [ i ] = min ( dist [ i ] , graph [ i ] [ j ] + dist [ j ] ) ; } } return dist [ 0 ] ; } int main ( ) { int graph [ N ] [ N ] = { { INF , 1 , 2 , 5 , INF , INF , INF , INF } , { INF , INF , INF , INF , 4 , 11 , INF , INF } , { INF , INF , INF , INF , 9 , 5 , 16 , INF } , { INF , INF , INF , INF , INF , INF , 2 , INF } , { INF , INF , INF , INF , INF , INF , INF , 18 } , { INF , INF , INF , INF , INF , INF , INF , 13 } , { INF , INF , INF , INF , INF , INF , INF , 2 } , { INF , INF , INF , INF , INF , INF , INF , INF } } ; cout << shortestDist ( graph ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; void printGivenLevel ( node * root , int level ) ; int height ( node * node ) ; node * newNode ( int data ) ; void reverseLevelOrder ( node * root ) { int h = height ( root ) ; int i ; for ( i = h ; i >= 1 ; i -- ) printGivenLevel ( root , i ) ; } void printGivenLevel ( node * root , int level ) { if ( root == NULL ) return ; if ( level == 1 ) cout << root -> data << " ▁ " ; else if ( level > 1 ) { printGivenLevel ( root -> left , level - 1 ) ; printGivenLevel ( root -> right , level - 1 ) ; } } int height ( node * node ) { if ( node == NULL ) return 0 ; else { int lheight = height ( node -> left ) ; int rheight = height ( node -> right ) ; if ( lheight > rheight ) return ( lheight + 1 ) ; else return ( rheight + 1 ) ; } } node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << " Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is ▁ STRNEWLINE " ; reverseLevelOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int V = 4 ; struct edge { int from , weight ; } ; vector < edge > edges [ V ] ; void addedge ( int u , int v , int w ) { edges [ v ] . push_back ( { u , w } ) ; } void shortestpath ( int dp [ ] [ V ] ) { for ( int i = 0 ; i <= V ; i ++ ) for ( int j = 0 ; j < V ; j ++ ) dp [ i ] [ j ] = -1 ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { for ( int k = 0 ; k < edges [ j ] . size ( ) ; k ++ ) { if ( dp [ i - 1 ] [ edges [ j ] [ k ] . from ] != -1 ) { int curr_wt = dp [ i - 1 ] [ edges [ j ] [ k ] . from ] + edges [ j ] [ k ] . weight ; if ( dp [ i ] [ j ] == -1 ) dp [ i ] [ j ] = curr_wt ; else dp [ i ] [ j ] = min ( dp [ i ] [ j ] , curr_wt ) ; } } } } } double minAvgWeight ( ) { int dp [ V + 1 ] [ V ] ; shortestpath ( dp ) ; double avg [ V ] ; for ( int i = 0 ; i < V ; i ++ ) avg [ i ] = -1 ; for ( int i = 0 ; i < V ; i ++ ) { if ( dp [ V ] [ i ] != -1 ) { for ( int j = 0 ; j < V ; j ++ ) if ( dp [ j ] [ i ] != -1 ) avg [ i ] = max ( avg [ i ] , ( ( double ) dp [ V ] [ i ] - dp [ j ] [ i ] ) / ( V - j ) ) ; } } double result = avg [ 0 ] ; for ( int i = 0 ; i < V ; i ++ ) if ( avg [ i ] != -1 && avg [ i ] < result ) result = avg [ i ] ; return result ; } int main ( ) { addedge ( 0 , 1 , 1 ) ; addedge ( 0 , 2 , 10 ) ; addedge ( 1 , 2 , 3 ) ; addedge ( 2 , 3 , 2 ) ; addedge ( 3 , 1 , 0 ) ; addedge ( 3 , 0 , 8 ) ; cout << minAvgWeight ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; void reverseLevelOrder ( node * root ) { stack < node * > S ; queue < node * > Q ; Q . push ( root ) ; while ( Q . empty ( ) == false ) { root = Q . front ( ) ; Q . pop ( ) ; S . push ( root ) ; if ( root -> right ) Q . push ( root -> right ) ; if ( root -> left ) Q . push ( root -> left ) ; } while ( S . empty ( ) == false ) { root = S . top ( ) ; cout << root -> data << " ▁ " ; S . pop ( ) ; } } node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return ( temp ) ; } int main ( ) { struct node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; cout << " Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is ▁ STRNEWLINE " ; reverseLevelOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class DisjointUnionSets { vector < int > rank , parent ; int n ; public : DisjointUnionSets ( int n ) { rank . resize ( n ) ; parent . resize ( n ) ; this -> n = n ; makeSet ( ) ; } void makeSet ( ) { for ( int i = 0 ; i < n ; i ++ ) parent [ i ] = i ; } int find ( int x ) { if ( parent [ x ] != x ) { return find ( parent [ x ] ) ; } return x ; } void Union ( int x , int y ) { int xRoot = find ( x ) ; int yRoot = find ( y ) ; if ( xRoot == yRoot ) return ; if ( rank [ xRoot ] < rank [ yRoot ] ) parent [ xRoot ] = yRoot ; else if ( rank [ yRoot ] < rank [ xRoot ] ) parent [ yRoot ] = xRoot ; else { parent [ yRoot ] = xRoot ; rank [ xRoot ] = rank [ xRoot ] + 1 ; } } } ; int countIslands ( vector < vector < int > > a ) { int n = a . size ( ) ; int m = a [ 0 ] . size ( ) ; DisjointUnionSets * dus = new DisjointUnionSets ( n * m ) ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < m ; k ++ ) { if ( a [ j ] [ k ] == 0 ) continue ; if ( j + 1 < n && a [ j + 1 ] [ k ] == 1 ) dus -> Union ( j * ( m ) + k , ( j + 1 ) * ( m ) + k ) ; if ( j - 1 >= 0 && a [ j - 1 ] [ k ] == 1 ) dus -> Union ( j * ( m ) + k , ( j - 1 ) * ( m ) + k ) ; if ( k + 1 < m && a [ j ] [ k + 1 ] == 1 ) dus -> Union ( j * ( m ) + k , ( j ) * ( m ) + k + 1 ) ; if ( k - 1 >= 0 && a [ j ] [ k - 1 ] == 1 ) dus -> Union ( j * ( m ) + k , ( j ) * ( m ) + k - 1 ) ; if ( j + 1 < n && k + 1 < m && a [ j + 1 ] [ k + 1 ] == 1 ) dus -> Union ( j * ( m ) + k , ( j + 1 ) * ( m ) + k + 1 ) ; if ( j + 1 < n && k - 1 >= 0 && a [ j + 1 ] [ k - 1 ] == 1 ) dus -> Union ( j * m + k , ( j + 1 ) * ( m ) + k - 1 ) ; if ( j - 1 >= 0 && k + 1 < m && a [ j - 1 ] [ k + 1 ] == 1 ) dus -> Union ( j * m + k , ( j - 1 ) * m + k + 1 ) ; if ( j - 1 >= 0 && k - 1 >= 0 && a [ j - 1 ] [ k - 1 ] == 1 ) dus -> Union ( j * m + k , ( j - 1 ) * m + k - 1 ) ; } } int * c = new int [ n * m ] ; int numberOfIslands = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < m ; k ++ ) { if ( a [ j ] [ k ] == 1 ) { int x = dus -> find ( j * m + k ) ; if ( c [ x ] == 0 ) { numberOfIslands ++ ; c [ x ] ++ ; } else c [ x ] ++ ; } } } return numberOfIslands ; } int main ( void ) { vector < vector < int > > a = { { 1 , 1 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 0 , 1 , 1 } , { 0 , 0 , 0 , 0 , 0 } , { 1 , 0 , 1 , 0 , 1 } } ; cout << " Number ▁ of ▁ Islands ▁ is : ▁ " << countIslands ( a ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * reverseTreePathUtil ( Node * root , int data , map < int , int > & temp , int level , int & nextpos ) { if ( root == NULL ) return NULL ; if ( data == root -> data ) { temp [ level ] = root -> data ; root -> data = temp [ nextpos ] ; nextpos ++ ; return root ; } temp [ level ] = root -> data ; Node * left , * right ; left = reverseTreePathUtil ( root -> left , data , temp , level + 1 , nextpos ) ; if ( left == NULL ) right = reverseTreePathUtil ( root -> right , data , temp , level + 1 , nextpos ) ; if ( left right ) { root -> data = temp [ nextpos ] ; nextpos ++ ; return ( left ? left : right ) ; } return NULL ; } void reverseTreePath ( Node * root , int data ) { map < int , int > temp ; int nextpos = 0 ; reverseTreePathUtil ( root , data , temp , 0 , nextpos ) ; } void inorder ( Node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << root -> data << " ▁ " ; inorder ( root -> right ) ; } } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 7 ) ; root -> left = newNode ( 6 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 2 ) ; root -> right -> right = newNode ( 1 ) ; int data = 4 ; reverseTreePath ( root , data ) ; inorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findpath ( int graph [ ] [ 5 ] , int n ) { vector < int > numofadj ; for ( int i = 0 ; i < n ; i ++ ) numofadj . push_back ( accumulate ( graph [ i ] , graph [ i ] + 5 , 0 ) ) ; int startpoint = 0 , numofodd = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( numofadj [ i ] % 2 == 1 ) { numofodd ++ ; startpoint = i ; } } if ( numofodd > 2 ) { cout << " No ▁ Solution " << endl ; return ; } stack < int > stack ; vector < int > path ; int cur = startpoint ; while ( ! stack . empty ( ) or accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) != 0 ) { if ( accumulate ( graph [ cur ] , graph [ cur ] + 5 , 0 ) == 0 ) { path . push_back ( cur ) ; cur = stack . top ( ) ; stack . pop ( ) ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( graph [ cur ] [ i ] == 1 ) { stack . push ( cur ) ; graph [ cur ] [ i ] = 0 ; graph [ i ] [ cur ] = 0 ; cur = i ; break ; } } } } for ( auto ele : path ) cout << ele << " ▁ - > ▁ " ; cout << cur << endl ; } int main ( ) { int graph1 [ ] [ 5 ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 1 , 0 } , { 0 , 1 , 1 , 0 , 0 } , { 1 , 0 , 0 , 0 , 0 } } ; int n = sizeof ( graph1 ) / sizeof ( graph1 [ 0 ] ) ; findpath ( graph1 , n ) ; int graph2 [ ] [ 5 ] = { { 0 , 1 , 0 , 1 , 1 } , { 1 , 0 , 1 , 0 , 1 } , { 0 , 1 , 0 , 1 , 1 } , { 1 , 1 , 1 , 0 , 0 } , { 1 , 0 , 1 , 0 , 0 } } ; n = sizeof ( graph1 ) / sizeof ( graph1 [ 0 ] ) ; findpath ( graph2 , n ) ; int graph3 [ ] [ 5 ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 } , { 0 , 1 , 0 , 1 , 0 } , { 0 , 1 , 1 , 0 , 1 } , { 1 , 1 , 0 , 1 , 0 } } ; n = sizeof ( graph1 ) / sizeof ( graph1 [ 0 ] ) ; findpath ( graph3 , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define nl  " NEW_LINE " class Node { public : int data ; Node * left ; Node * right ; Node ( int value ) { data = value ; } } ; void inorder ( Node * temp ) { if ( temp == NULL ) return ; inorder ( temp -> left ) ; cout << temp -> data << " ▁ " ; inorder ( temp -> right ) ; } void reverseTreePathUtil ( Node * root , vector < Node * > path , int pathLen , int key ) { if ( root == NULL ) return ; path [ pathLen ] = root ; pathLen ++ ; if ( root -> data == key ) { int i = 0 , j = pathLen - 1 ; while ( i < j ) { int temp = path [ i ] -> data ; path [ i ] -> data = path [ j ] -> data ; path [ j ] -> data = temp ; i ++ ; j -- ; } } if ( ! root -> left and ! root -> right ) return ; reverseTreePathUtil ( root -> left , path , pathLen , key ) ; reverseTreePathUtil ( root -> right , path , pathLen , key ) ; } void reverseTreePath ( Node * root , int key ) { if ( root == NULL ) return ; vector < Node * > path ( 50 , NULL ) ; reverseTreePathUtil ( root , path , 0 , key ) ; } int main ( ) { Node * root = new Node ( 7 ) ; root -> left = new Node ( 6 ) ; root -> right = new Node ( 5 ) ; root -> left -> left = new Node ( 4 ) ; root -> left -> right = new Node ( 3 ) ; root -> right -> left = new Node ( 2 ) ; root -> right -> right = new Node ( 1 ) ; int key = 4 ; reverseTreePath ( root , key ) ; inorder ( root ) ; return 0 ; }
#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; #define INF  INT_MAX NEW_LINE #define N  4 NEW_LINE int minCost ( int cost [ ] [ N ] ) { int dist [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dist [ i ] = INF ; dist [ 0 ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( dist [ j ] > dist [ i ] + cost [ i ] [ j ] ) dist [ j ] = dist [ i ] + cost [ i ] [ j ] ; return dist [ N - 1 ] ; } int main ( ) { int cost [ N ] [ N ] = { { 0 , 15 , 80 , 90 } , { INF , 0 , 40 , 50 } , { INF , INF , 0 , 70 } , { INF , INF , INF , 0 } } ; cout << " The ▁ Minimum ▁ cost ▁ to ▁ reach ▁ station ▁ " << N << " ▁ is ▁ " << minCost ( cost ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numOfways ( int n , int k ) { int p = 1 ; if ( k % 2 ) p = -1 ; return ( pow ( n - 1 , k ) + p * ( n - 1 ) ) / n ; } int main ( ) { int n = 4 , k = 2 ; cout << numOfways ( n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int root ( int arr [ ] , int i ) { while ( arr [ i ] != i ) { arr [ i ] = arr [ arr [ i ] ] ; i = arr [ i ] ; } return i ; } void weighted_union ( int arr [ ] , int rank [ ] , int a , int b ) { int root_a = root ( arr , a ) ; int root_b = root ( arr , b ) ; if ( rank [ root_a ] < rank [ root_b ] ) { arr [ root_a ] = arr [ root_b ] ; rank [ root_b ] += rank [ root_a ] ; } else { arr [ root_b ] = arr [ root_a ] ; rank [ root_a ] += rank [ root_b ] ; } } bool areSame ( int arr [ ] , int a , int b ) { return ( root ( arr , a ) == root ( arr , b ) ) ; } void query ( int type , int x , int y , int arr [ ] , int rank [ ] ) { if ( type == 1 ) { if ( areSame ( arr , x , y ) == true ) cout << " Yes " << endl ; else cout << " No " << endl ; } else if ( type == 2 ) { if ( areSame ( arr , x , y ) == false ) weighted_union ( arr , rank , x , y ) ; } } int main ( ) { int n = 7 ; int arr [ n ] , rank [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = i ; rank [ i ] = 1 ; } int q = 11 ; query ( 1 , 0 , 1 , arr , rank ) ; query ( 2 , 0 , 1 , arr , rank ) ; query ( 2 , 1 , 2 , arr , rank ) ; query ( 1 , 0 , 2 , arr , rank ) ; query ( 2 , 0 , 2 , arr , rank ) ; query ( 2 , 2 , 3 , arr , rank ) ; query ( 2 , 3 , 4 , arr , rank ) ; query ( 1 , 0 , 5 , arr , rank ) ; query ( 2 , 4 , 5 , arr , rank ) ; query ( 2 , 5 , 6 , arr , rank ) ; query ( 1 , 2 , 6 , arr , rank ) ; return 0 ; }
#include <iostream> NEW_LINE #include <queue> NEW_LINE using namespace std ; struct Node { int data ; Node * left ; Node * right ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> right = node -> left = NULL ; return node ; } void printSpecificLevelOrder ( Node * root ) { if ( root == NULL ) return ; cout << root -> data ; if ( root -> left != NULL ) cout << " ▁ " << root -> left -> data << " ▁ " << root -> right -> data ; if ( root -> left -> left == NULL ) return ; queue < Node * > q ; q . push ( root -> left ) ; q . push ( root -> right ) ; Node * first = NULL , * second = NULL ; while ( ! q . empty ( ) ) { first = q . front ( ) ; q . pop ( ) ; second = q . front ( ) ; q . pop ( ) ; cout << " ▁ " << first -> left -> data << " ▁ " << second -> right -> data ; cout << " ▁ " << first -> right -> data << " ▁ " << second -> left -> data ; if ( first -> left -> left != NULL ) { q . push ( first -> left ) ; q . push ( second -> right ) ; q . push ( first -> right ) ; q . push ( second -> left ) ; } } } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; root -> right -> left -> left = newNode ( 12 ) ; root -> right -> left -> right = newNode ( 13 ) ; root -> right -> right -> left = newNode ( 14 ) ; root -> right -> right -> right = newNode ( 15 ) ; root -> left -> left -> left -> left = newNode ( 16 ) ; root -> left -> left -> left -> right = newNode ( 17 ) ; root -> left -> left -> right -> left = newNode ( 18 ) ; root -> left -> left -> right -> right = newNode ( 19 ) ; root -> left -> right -> left -> left = newNode ( 20 ) ; root -> left -> right -> left -> right = newNode ( 21 ) ; root -> left -> right -> right -> left = newNode ( 22 ) ; root -> left -> right -> right -> right = newNode ( 23 ) ; root -> right -> left -> left -> left = newNode ( 24 ) ; root -> right -> left -> left -> right = newNode ( 25 ) ; root -> right -> left -> right -> left = newNode ( 26 ) ; root -> right -> left -> right -> right = newNode ( 27 ) ; root -> right -> right -> left -> left = newNode ( 28 ) ; root -> right -> right -> left -> right = newNode ( 29 ) ; root -> right -> right -> right -> left = newNode ( 30 ) ; root -> right -> right -> right -> right = newNode ( 31 ) ; cout << " Specific ▁ Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ tree ▁ is ▁ STRNEWLINE " ; printSpecificLevelOrder ( root ) ; return 0 ; }
#include <iostream> NEW_LINE #include <limits.h> NEW_LINE #include <queue> NEW_LINE #include <string.h> NEW_LINE using namespace std ; #define V  6 NEW_LINE bool bfs ( int rGraph [ V ] [ V ] , int s , int t , int parent [ ] ) { bool visited [ V ] ; memset ( visited , 0 , sizeof ( visited ) ) ; queue < int > q ; q . push ( s ) ; visited [ s ] = true ; parent [ s ] = -1 ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; for ( int v = 0 ; v < V ; v ++ ) { if ( visited [ v ] == false && rGraph [ u ] [ v ] > 0 ) { if ( v == t ) { parent [ v ] = u ; return true ; } q . push ( v ) ; parent [ v ] = u ; visited [ v ] = true ; } } } return false ; } int fordFulkerson ( int graph [ V ] [ V ] , int s , int t ) { int u , v ; int rGraph [ V ] [ V ] ; for ( u = 0 ; u < V ; u ++ ) for ( v = 0 ; v < V ; v ++ ) rGraph [ u ] [ v ] = graph [ u ] [ v ] ; int parent [ V ] ; int max_flow = 0 ; while ( bfs ( rGraph , s , t , parent ) ) { int path_flow = INT_MAX ; for ( v = t ; v != s ; v = parent [ v ] ) { u = parent [ v ] ; path_flow = min ( path_flow , rGraph [ u ] [ v ] ) ; } for ( v = t ; v != s ; v = parent [ v ] ) { u = parent [ v ] ; rGraph [ u ] [ v ] -= path_flow ; rGraph [ v ] [ u ] += path_flow ; } max_flow += path_flow ; } return max_flow ; } int main ( ) { int graph [ V ] [ V ] = { { 0 , 16 , 13 , 0 , 0 , 0 } , { 0 , 0 , 10 , 12 , 0 , 0 } , { 0 , 4 , 0 , 0 , 14 , 0 } , { 0 , 0 , 9 , 0 , 0 , 20 } , { 0 , 0 , 0 , 7 , 0 , 4 } , { 0 , 0 , 0 , 0 , 0 , 0 } } ; cout << " The ▁ maximum ▁ possible ▁ flow ▁ is ▁ " << fordFulkerson ( graph , 0 , 5 ) ; return 0 ; }
#include <iostream> NEW_LINE #include <limits.h> NEW_LINE #include <string.h> NEW_LINE #include <queue> NEW_LINE using namespace std ; #define V  8 NEW_LINE bool bfs ( int rGraph [ V ] [ V ] , int s , int t , int parent [ ] ) { bool visited [ V ] ; memset ( visited , 0 , sizeof ( visited ) ) ; queue < int > q ; q . push ( s ) ; visited [ s ] = true ; parent [ s ] = -1 ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; for ( int v = 0 ; v < V ; v ++ ) { if ( visited [ v ] == false && rGraph [ u ] [ v ] > 0 ) { q . push ( v ) ; parent [ v ] = u ; visited [ v ] = true ; } } } return ( visited [ t ] == true ) ; } int findDisjointPaths ( int graph [ V ] [ V ] , int s , int t ) { int u , v ; int rGraph [ V ] [ V ] ; for ( u = 0 ; u < V ; u ++ ) for ( v = 0 ; v < V ; v ++ ) rGraph [ u ] [ v ] = graph [ u ] [ v ] ; int parent [ V ] ; int max_flow = 0 ; while ( bfs ( rGraph , s , t , parent ) ) { int path_flow = INT_MAX ; for ( v = t ; v != s ; v = parent [ v ] ) { u = parent [ v ] ; path_flow = min ( path_flow , rGraph [ u ] [ v ] ) ; } for ( v = t ; v != s ; v = parent [ v ] ) { u = parent [ v ] ; rGraph [ u ] [ v ] -= path_flow ; rGraph [ v ] [ u ] += path_flow ; } max_flow += path_flow ; } return max_flow ; } int main ( ) { int graph [ V ] [ V ] = { { 0 , 1 , 1 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 } , { 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } } ; int s = 0 ; int t = 7 ; cout << " There ▁ can ▁ be ▁ maximum ▁ " << findDisjointPaths ( graph , s , t ) << " ▁ edge - disjoint ▁ paths ▁ from ▁ " << s << " ▁ to ▁ " << t ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> right = node -> left = NULL ; return node ; } void printSpecificLevelOrderUtil ( Node * root , stack < Node * > & s ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root -> left ) ; q . push ( root -> right ) ; Node * first = NULL , * second = NULL ; while ( ! q . empty ( ) ) { first = q . front ( ) ; q . pop ( ) ; second = q . front ( ) ; q . pop ( ) ; s . push ( second -> left ) ; s . push ( first -> right ) ; s . push ( second -> right ) ; s . push ( first -> left ) ; if ( first -> left -> left != NULL ) { q . push ( first -> right ) ; q . push ( second -> left ) ; q . push ( first -> left ) ; q . push ( second -> right ) ; } } } void printSpecificLevelOrder ( Node * root ) { stack < Node * > s ; s . push ( root ) ; if ( root -> left != NULL ) { s . push ( root -> right ) ; s . push ( root -> left ) ; } if ( root -> left -> left != NULL ) printSpecificLevelOrderUtil ( root , s ) ; while ( ! s . empty ( ) ) { cout << s . top ( ) -> data << " ▁ " ; s . pop ( ) ; } } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; cout << " Specific ▁ Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ " " tree ▁ is ▁ STRNEWLINE " ; printSpecificLevelOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxindex ( int * dist , int n ) { int mi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dist [ i ] > dist [ mi ] ) mi = i ; } return mi ; } void selectKcities ( int n , int weights [ 4 ] [ 4 ] , int k ) { int * dist = new int [ n ] ; vector < int > centers ; for ( int i = 0 ; i < n ; i ++ ) { dist [ i ] = INT_MAX ; } int max = 0 ; for ( int i = 0 ; i < k ; i ++ ) { centers . push_back ( max ) ; for ( int j = 0 ; j < n ; j ++ ) { dist [ j ] = min ( dist [ j ] , weights [ max ] [ j ] ) ; } max = maxindex ( dist , n ) ; } cout << endl << dist [ max ] << endl ; for ( int i = 0 ; i < centers . size ( ) ; i ++ ) { cout << centers [ i ] << " ▁ " ; } cout << endl ; } int main ( ) { int n = 4 ; int weights [ 4 ] [ 4 ] = { { 0 , 4 , 8 , 5 } , { 4 , 0 , 10 , 7 } , { 8 , 10 , 0 , 9 } , { 5 , 7 , 9 , 0 } } ; int k = 2 ; selectKcities ( n , weights , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * left ; Node * right ; Node ( int value ) { data = value ; left = NULL ; right = NULL ; } } ; void specific_level_order_traversal ( Node * root ) { queue < Node * > q ; stack < vector < int > > s ; q . push ( root ) ; int sz ; while ( ! q . empty ( ) ) { vector < int > v ; sz = q . size ( ) ; for ( int i = 0 ; i < sz ; ++ i ) { Node * temp = q . front ( ) ; q . pop ( ) ; v . push_back ( temp -> data ) ; if ( temp -> left != NULL ) q . push ( temp -> left ) ; if ( temp -> right != NULL ) q . push ( temp -> right ) ; } s . push ( v ) ; } while ( ! s . empty ( ) ) { vector < int > v = s . top ( ) ; s . pop ( ) ; for ( int i = 0 , j = v . size ( ) - 1 ; i < j ; ++ i ) { cout << v [ i ] << " ▁ " << v [ j ] << " ▁ " ; j -- ; } } cout << root -> data ; } int main ( ) { Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; cout << " Specific ▁ Level ▁ Order ▁ traversal ▁ of ▁ binary ▁ " " tree ▁ is ▁ STRNEWLINE " ; specific_level_order_traversal ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define V  4 NEW_LINE void multiply ( int A [ ] [ V ] , int B [ ] [ V ] , int C [ ] [ V ] ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { C [ i ] [ j ] = 0 ; for ( int k = 0 ; k < V ; k ++ ) C [ i ] [ j ] += A [ i ] [ k ] * B [ k ] [ j ] ; } } } int getTrace ( int graph [ ] [ V ] ) { int trace = 0 ; for ( int i = 0 ; i < V ; i ++ ) trace += graph [ i ] [ i ] ; return trace ; } int triangleInGraph ( int graph [ ] [ V ] ) { int aux2 [ V ] [ V ] ; int aux3 [ V ] [ V ] ; for ( int i = 0 ; i < V ; ++ i ) for ( int j = 0 ; j < V ; ++ j ) aux2 [ i ] [ j ] = aux3 [ i ] [ j ] = 0 ; multiply ( graph , graph , aux2 ) ; multiply ( graph , aux2 , aux3 ) ; int trace = getTrace ( aux3 ) ; return trace / 6 ; } int main ( ) { int graph [ V ] [ V ] = { { 0 , 1 , 1 , 0 } , { 1 , 0 , 1 , 1 } , { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } } ; printf ( " Total ▁ number ▁ of ▁ Triangle ▁ in ▁ Graph ▁ : ▁ % d STRNEWLINE " , triangleInGraph ( graph ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isBipartite ( int V , vector < int > adj [ ] ) { vector < int > col ( V , -1 ) ; queue < pair < int , int > > q ; for ( int i = 0 ; i < V ; i ++ ) { if ( col [ i ] == -1 ) { q . push ( { i , 0 } ) ; col [ i ] = 0 ; while ( ! q . empty ( ) ) { pair < int , int > p = q . front ( ) ; q . pop ( ) ; int v = p . first ; int c = p . second ; for ( int j : adj [ v ] ) { if ( col [ j ] == c ) return 0 ; if ( col [ j ] == -1 ) { col [ j ] = ( c ) ? 0 : 1 ; q . push ( { j , col [ j ] } ) ; } } } } } return 1 ; } int main ( ) { int V , E ; V = 4 , E = 8 ; vector < int > adj [ V ] ; adj [ 0 ] = { 1 , 3 } ; adj [ 1 ] = { 0 , 2 } ; adj [ 2 ] = { 1 , 3 } ; adj [ 3 ] = { 0 , 2 } ; bool ans = isBipartite ( V , adj ) ; if ( ans ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define V  4 NEW_LINE bool colorGraph ( int G [ ] [ V ] , int color [ ] , int pos , int c ) { if ( color [ pos ] != -1 && color [ pos ] != c ) return false ; color [ pos ] = c ; bool ans = true ; for ( int i = 0 ; i < V ; i ++ ) { if ( G [ pos ] [ i ] ) { if ( color [ i ] == -1 ) ans &= colorGraph ( G , color , i , 1 - c ) ; if ( color [ i ] != -1 && color [ i ] != 1 - c ) return false ; } if ( ! ans ) return false ; } return true ; } bool isBipartite ( int G [ ] [ V ] ) { int color [ V ] ; for ( int i = 0 ; i < V ; i ++ ) color [ i ] = -1 ; int pos = 0 ; return colorGraph ( G , color , pos , 1 ) ; } int main ( ) { int G [ ] [ V ] = { { 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } , { 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } } ; isBipartite ( G ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; #define M  3 NEW_LINE #define N  3 NEW_LINE string dictionary [ ] = { " GEEKS " , " FOR " , " QUIZ " , " GO " } ; int n = sizeof ( dictionary ) / sizeof ( dictionary [ 0 ] ) ; bool isWord ( string & str ) { for ( int i = 0 ; i < n ; i ++ ) if ( str . compare ( dictionary [ i ] ) == 0 ) return true ; return false ; } void findWordsUtil ( char boggle [ M ] [ N ] , bool visited [ M ] [ N ] , int i , int j , string & str ) { visited [ i ] [ j ] = true ; str = str + boggle [ i ] [ j ] ; if ( isWord ( str ) ) cout << str << endl ; for ( int row = i - 1 ; row <= i + 1 && row < M ; row ++ ) for ( int col = j - 1 ; col <= j + 1 && col < N ; col ++ ) if ( row >= 0 && col >= 0 && ! visited [ row ] [ col ] ) findWordsUtil ( boggle , visited , row , col , str ) ; str . erase ( str . length ( ) - 1 ) ; visited [ i ] [ j ] = false ; } void findWords ( char boggle [ M ] [ N ] ) { bool visited [ M ] [ N ] = { { false } } ; string str = " " ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) findWordsUtil ( boggle , visited , i , j , str ) ; } int main ( ) { char boggle [ M ] [ N ] = { { ' G ' , ' I ' , ' Z ' } , { ' U ' , ' E ' , ' K ' } , { ' Q ' , ' S ' , ' E ' } } ; cout << " Following ▁ words ▁ of ▁ dictionary ▁ are ▁ present STRNEWLINE " ; findWords ( boggle ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; struct Node { char data ; struct Node * left , * right ; } ; struct Node * newNode ( char item ) { struct Node * temp = new Node ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; } void storeAlternate ( Node * root , char arr [ ] , int * index , int l ) { if ( root == NULL ) return ; storeAlternate ( root -> left , arr , index , l + 1 ) ; if ( l % 2 != 0 ) { arr [ * index ] = root -> data ; ( * index ) ++ ; } storeAlternate ( root -> right , arr , index , l + 1 ) ; } void modifyTree ( Node * root , char arr [ ] , int * index , int l ) { if ( root == NULL ) return ; modifyTree ( root -> left , arr , index , l + 1 ) ; if ( l % 2 != 0 ) { root -> data = arr [ * index ] ; ( * index ) ++ ; } modifyTree ( root -> right , arr , index , l + 1 ) ; } void reverse ( char arr [ ] , int n ) { int l = 0 , r = n - 1 ; while ( l < r ) { int temp = arr [ l ] ; arr [ l ] = arr [ r ] ; arr [ r ] = temp ; l ++ ; r -- ; } } void reverseAlternate ( struct Node * root ) { char * arr = new char [ MAX ] ; int index = 0 ; storeAlternate ( root , arr , & index , 0 ) ; reverse ( arr , index ) ; index = 0 ; modifyTree ( root , arr , & index , 0 ) ; } void printInorder ( struct Node * root ) { if ( root == NULL ) return ; printInorder ( root -> left ) ; cout << root -> data << " ▁ " ; printInorder ( root -> right ) ; } int main ( ) { struct Node * root = newNode ( ' a ' ) ; root -> left = newNode ( ' b ' ) ; root -> right = newNode ( ' c ' ) ; root -> left -> left = newNode ( ' d ' ) ; root -> left -> right = newNode ( ' e ' ) ; root -> right -> left = newNode ( ' f ' ) ; root -> right -> right = newNode ( ' g ' ) ; root -> left -> left -> left = newNode ( ' h ' ) ; root -> left -> left -> right = newNode ( ' i ' ) ; root -> left -> right -> left = newNode ( ' j ' ) ; root -> left -> right -> right = newNode ( ' k ' ) ; root -> right -> left -> left = newNode ( ' l ' ) ; root -> right -> left -> right = newNode ( ' m ' ) ; root -> right -> right -> left = newNode ( ' n ' ) ; root -> right -> right -> right = newNode ( ' o ' ) ; cout << " Inorder ▁ Traversal ▁ of ▁ given ▁ tree STRNEWLINE " ; printInorder ( root ) ; reverseAlternate ( root ) ; cout << " Inorder Traversal of modified tree " ; printInorder ( root ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; } int main ( ) { int n = 4 ; cout << power ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } int findVertices ( int n ) { return fib ( n + 2 ) ; } int main ( ) { int n = 3 ; cout << findVertices ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMat ( int degseq [ ] , int n ) { int mat [ n ] [ n ] ; memset ( mat , 0 , sizeof ( mat ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( degseq [ i ] > 0 && degseq [ j ] > 0 ) { degseq [ i ] -- ; degseq [ j ] -- ; mat [ i ] [ j ] = 1 ; mat [ j ] [ i ] = 1 ; } } } cout << " STRNEWLINE " << setw ( 3 ) << " TABSYMBOL " ; for ( int i = 0 ; i < n ; i ++ ) cout << setw ( 3 ) << " ( " << i << " ) " ; cout << " STRNEWLINE STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) { cout << setw ( 4 ) << " ( " << i << " ) " ; for ( int j = 0 ; j < n ; j ++ ) cout << setw ( 5 ) << mat [ i ] [ j ] ; cout << " STRNEWLINE " ; } } int main ( ) { int degseq [ ] = { 2 , 2 , 1 , 1 , 1 } ; int n = sizeof ( degseq ) / sizeof ( degseq [ 0 ] ) ; printMat ( degseq , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100000 ; vector < int > adj [ MAX ] ; vector < int > adjInv [ MAX ] ; bool visited [ MAX ] ; bool visitedInv [ MAX ] ; stack < int > s ; int scc [ MAX ] ; int counter = 1 ; void addEdges ( int a , int b ) { adj [ a ] . push_back ( b ) ; } void addEdgesInverse ( int a , int b ) { adjInv [ b ] . push_back ( a ) ; } void dfsFirst ( int u ) { if ( visited [ u ] ) return ; visited [ u ] = 1 ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) dfsFirst ( adj [ u ] [ i ] ) ; s . push ( u ) ; } void dfsSecond ( int u ) { if ( visitedInv [ u ] ) return ; visitedInv [ u ] = 1 ; for ( int i = 0 ; i < adjInv [ u ] . size ( ) ; i ++ ) dfsSecond ( adjInv [ u ] [ i ] ) ; scc [ u ] = counter ; } void is2Satisfiable ( int n , int m , int a [ ] , int b [ ] ) { for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] > 0 && b [ i ] > 0 ) { addEdges ( a [ i ] + n , b [ i ] ) ; addEdgesInverse ( a [ i ] + n , b [ i ] ) ; addEdges ( b [ i ] + n , a [ i ] ) ; addEdgesInverse ( b [ i ] + n , a [ i ] ) ; } else if ( a [ i ] > 0 && b [ i ] < 0 ) { addEdges ( a [ i ] + n , n - b [ i ] ) ; addEdgesInverse ( a [ i ] + n , n - b [ i ] ) ; addEdges ( - b [ i ] , a [ i ] ) ; addEdgesInverse ( - b [ i ] , a [ i ] ) ; } else if ( a [ i ] < 0 && b [ i ] > 0 ) { addEdges ( - a [ i ] , b [ i ] ) ; addEdgesInverse ( - a [ i ] , b [ i ] ) ; addEdges ( b [ i ] + n , n - a [ i ] ) ; addEdgesInverse ( b [ i ] + n , n - a [ i ] ) ; } else { addEdges ( - a [ i ] , n - b [ i ] ) ; addEdgesInverse ( - a [ i ] , n - b [ i ] ) ; addEdges ( - b [ i ] , n - a [ i ] ) ; addEdgesInverse ( - b [ i ] , n - a [ i ] ) ; } } for ( int i = 1 ; i <= 2 * n ; i ++ ) if ( ! visited [ i ] ) dfsFirst ( i ) ; while ( ! s . empty ( ) ) { int n = s . top ( ) ; s . pop ( ) ; if ( ! visitedInv [ n ] ) { dfsSecond ( n ) ; counter ++ ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( scc [ i ] == scc [ i + n ] ) { cout << " The ▁ given ▁ expression ▁ " " is ▁ unsatisfiable . " << endl ; return ; } } cout << " The ▁ given ▁ expression ▁ is ▁ satisfiable . " << endl ; return ; } int main ( ) { int n = 5 , m = 7 ; int a [ ] = { 1 , -2 , -1 , 3 , -3 , -4 , -3 } ; int b [ ] = { 2 , 3 , -2 , 4 , 5 , -5 , 4 } ; is2Satisfiable ( n , m , a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { char key ; Node * left , * right ; } ; void preorder ( struct Node * root1 , struct Node * root2 , int lvl ) { if ( root1 == NULL root2 == NULL ) return ; if ( lvl % 2 == 0 ) swap ( root1 -> key , root2 -> key ) ; preorder ( root1 -> left , root2 -> right , lvl + 1 ) ; preorder ( root1 -> right , root2 -> left , lvl + 1 ) ; } void reverseAlternate ( struct Node * root ) { preorder ( root -> left , root -> right , 0 ) ; } void printInorder ( struct Node * root ) { if ( root == NULL ) return ; printInorder ( root -> left ) ; cout << root -> key << " ▁ " ; printInorder ( root -> right ) ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> left = temp -> right = NULL ; temp -> key = key ; return temp ; } int main ( ) { struct Node * root = newNode ( ' a ' ) ; root -> left = newNode ( ' b ' ) ; root -> right = newNode ( ' c ' ) ; root -> left -> left = newNode ( ' d ' ) ; root -> left -> right = newNode ( ' e ' ) ; root -> right -> left = newNode ( ' f ' ) ; root -> right -> right = newNode ( ' g ' ) ; root -> left -> left -> left = newNode ( ' h ' ) ; root -> left -> left -> right = newNode ( ' i ' ) ; root -> left -> right -> left = newNode ( ' j ' ) ; root -> left -> right -> right = newNode ( ' k ' ) ; root -> right -> left -> left = newNode ( ' l ' ) ; root -> right -> left -> right = newNode ( ' m ' ) ; root -> right -> right -> left = newNode ( ' n ' ) ; root -> right -> right -> right = newNode ( ' o ' ) ; cout << " Inorder ▁ Traversal ▁ of ▁ given ▁ tree STRNEWLINE " ; printInorder ( root ) ; reverseAlternate ( root ) ; cout << " Inorder Traversal of modified tree " ; printInorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( int key ) { struct Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } ; void inorder ( struct Node * temp ) { if ( ! temp ) return ; inorder ( temp -> left ) ; cout << temp -> key << " ▁ " ; inorder ( temp -> right ) ; } void deletDeepest ( struct Node * root , struct Node * d_node ) { queue < struct Node * > q ; q . push ( root ) ; struct Node * temp ; while ( ! q . empty ( ) ) { temp = q . front ( ) ; q . pop ( ) ; if ( temp == d_node ) { temp = NULL ; delete ( d_node ) ; return ; } if ( temp -> right ) { if ( temp -> right == d_node ) { temp -> right = NULL ; delete ( d_node ) ; return ; } else q . push ( temp -> right ) ; } if ( temp -> left ) { if ( temp -> left == d_node ) { temp -> left = NULL ; delete ( d_node ) ; return ; } else q . push ( temp -> left ) ; } } } Node * deletion ( struct Node * root , int key ) { if ( root == NULL ) return NULL ; if ( root -> left == NULL && root -> right == NULL ) { if ( root -> key == key ) return NULL ; else return root ; } queue < struct Node * > q ; q . push ( root ) ; struct Node * temp ; struct Node * key_node = NULL ; while ( ! q . empty ( ) ) { temp = q . front ( ) ; q . pop ( ) ; if ( temp -> key == key ) key_node = temp ; if ( temp -> left ) q . push ( temp -> left ) ; if ( temp -> right ) q . push ( temp -> right ) ; } if ( key_node != NULL ) { int x = temp -> key ; deletDeepest ( root , temp ) ; key_node -> key = x ; } return root ; } int main ( ) { struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 11 ) ; root -> left -> left = newNode ( 7 ) ; root -> left -> right = newNode ( 12 ) ; root -> right = newNode ( 9 ) ; root -> right -> left = newNode ( 15 ) ; root -> right -> right = newNode ( 8 ) ; cout << " Inorder ▁ traversal ▁ before ▁ deletion ▁ : ▁ " ; inorder ( root ) ; int key = 11 ; root = deletion ( root , key ) ; cout << endl ; cout << " Inorder ▁ traversal ▁ after ▁ deletion ▁ : ▁ " ; inorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSink ( int n , int m , int edgeFrom [ ] , int edgeTo [ ] ) { int mark [ n ] ; memset ( mark , 0 , sizeof mark ) ; for ( int i = 0 ; i < m ; i ++ ) mark [ edgeFrom [ i ] ] = 1 ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( ! mark [ i ] ) count ++ ; return count ; } int main ( ) { int n = 4 , m = 2 ; int edgeFrom [ ] = { 2 , 4 } ; int edgeTo [ ] = { 3 , 3 } ; cout << countSink ( n , m , edgeFrom , edgeTo ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 6 ; int subsetGraph ( int C [ ] [ N ] ) { set < int > vertices ; for ( int i = 0 ; i < N ; ++ i ) vertices . insert ( i ) ; while ( ! vertices . empty ( ) ) { if ( vertices . size ( ) == 1 ) return 1 ; bool someone_removed = false ; for ( int x : vertices ) { set < int > values ; for ( int y : vertices ) if ( y != x ) values . insert ( C [ x ] [ y ] ) ; if ( values . size ( ) == 1 ) { vertices . erase ( x ) ; someone_removed = true ; break ; } } if ( ! someone_removed ) break ; } return ( vertices . size ( ) ) ; } int main ( ) { int C [ ] [ N ] = { { 0 , 9 , 2 , 4 , 7 , 8 } , { 9 , 0 , 9 , 9 , 7 , 9 } , { 2 , 9 , 0 , 3 , 7 , 6 } , { 4 , 9 , 3 , 0 , 7 , 1 } , { 7 , 7 , 7 , 7 , 0 , 7 } , { 8 , 9 , 6 , 1 , 7 , 0 } } ; cout << subsetGraph ( C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Graph { int V ; list < int > * adj ; public : Graph ( int V ) { this -> V = V ; adj = new list < int > [ V ] ; } void addEdge ( int u , int v ) ; int countEdges ( ) ; } ; void Graph :: addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } int Graph :: countEdges ( ) { int sum = 0 ; for ( int i = 0 ; i < V ; i ++ ) sum += adj [ i ] . size ( ) ; return sum / 2 ; } int main ( ) { int V = 9 ; Graph g ( V ) ; g . addEdge ( 0 , 1 ) ; g . addEdge ( 0 , 7 ) ; g . addEdge ( 1 , 2 ) ; g . addEdge ( 1 , 7 ) ; g . addEdge ( 2 , 3 ) ; g . addEdge ( 2 , 8 ) ; g . addEdge ( 2 , 5 ) ; g . addEdge ( 3 , 4 ) ; g . addEdge ( 3 , 5 ) ; g . addEdge ( 4 , 5 ) ; g . addEdge ( 5 , 6 ) ; g . addEdge ( 6 , 7 ) ; g . addEdge ( 6 , 8 ) ; g . addEdge ( 7 , 8 ) ; cout << g . countEdges ( ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int V = 5 ; bool isBipartiteUtil ( int G [ ] [ V ] , int src , int colorArr [ ] ) { colorArr [ src ] = 1 ; queue < int > q ; q . push ( src ) ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; for ( int v = 0 ; v < V ; ++ v ) { if ( G [ u ] [ v ] && colorArr [ v ] == -1 ) { colorArr [ v ] = 1 - colorArr [ u ] ; q . push ( v ) ; } else if ( G [ u ] [ v ] && colorArr [ v ] == colorArr [ u ] ) return false ; } } return true ; } bool isBipartite ( int G [ ] [ V ] ) { int colorArr [ V ] ; for ( int i = 0 ; i < V ; ++ i ) colorArr [ i ] = -1 ; for ( int i = 0 ; i < V ; i ++ ) if ( colorArr [ i ] == -1 ) if ( isBipartiteUtil ( G , i , colorArr ) == false ) return false ; return true ; } bool canBeDividedinTwoCliques ( int G [ ] [ V ] ) { int GC [ V ] [ V ] ; for ( int i = 0 ; i < V ; i ++ ) for ( int j = 0 ; j < V ; j ++ ) GC [ i ] [ j ] = ( i != j ) ? ! G [ i ] [ j ] : 0 ; return isBipartite ( GC ) ; } int main ( ) { int G [ ] [ V ] = { { 0 , 1 , 1 , 1 , 0 } , { 1 , 0 , 1 , 0 , 0 } , { 1 , 1 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 0 , 0 , 0 , 1 , 0 } } ; canBeDividedinTwoCliques ( G ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int degree [ ] , int n ) { int deg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) deg_sum += degree [ i ] ; return ( 2 * ( n - 1 ) == deg_sum ) ; } int main ( ) { int n = 5 ; int degree [ ] = { 2 , 3 , 1 , 1 , 1 } ; if ( check ( degree , n ) ) cout << " Tree " ; else cout << " Graph " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define maxn  25 NEW_LINE using namespace std ; bool gr [ maxn ] [ maxn ] ; bool isCover ( int V , int k , int E ) { int set = ( 1 << k ) - 1 ; int limit = ( 1 << V ) ; bool vis [ maxn ] [ maxn ] ; while ( set < limit ) { memset ( vis , 0 , sizeof vis ) ; int cnt = 0 ; for ( int j = 1 , v = 1 ; j < limit ; j = j << 1 , v ++ ) { if ( set & j ) { for ( int k = 1 ; k <= V ; k ++ ) { if ( gr [ v ] [ k ] && ! vis [ v ] [ k ] ) { vis [ v ] [ k ] = 1 ; vis [ k ] [ v ] = 1 ; cnt ++ ; } } } } if ( cnt == E ) return true ; int c = set & - set ; int r = set + c ; set = ( ( ( r ^ set ) >> 2 ) / c ) | r ; } return false ; } int findMinCover ( int n , int m ) { int left = 1 , right = n ; while ( right > left ) { int mid = ( left + right ) >> 1 ; if ( isCover ( n , mid , m ) == false ) left = mid + 1 ; else right = mid ; } return left ; } void insertEdge ( int u , int v ) { gr [ u ] [ v ] = 1 ; gr [ v ] [ u ] = 1 ; } int main ( ) { int V = 6 , E = 6 ; insertEdge ( 1 , 2 ) ; insertEdge ( 2 , 3 ) ; insertEdge ( 1 , 3 ) ; insertEdge ( 1 , 4 ) ; insertEdge ( 1 , 5 ) ; insertEdge ( 1 , 6 ) ; cout << " Minimum ▁ size ▁ of ▁ a ▁ vertex ▁ cover ▁ = ▁ " << findMinCover ( V , E ) << endl ; memset ( gr , 0 , sizeof gr ) ; V = 6 , E = 7 ; insertEdge ( 1 , 2 ) ; insertEdge ( 1 , 3 ) ; insertEdge ( 2 , 3 ) ; insertEdge ( 2 , 4 ) ; insertEdge ( 3 , 5 ) ; insertEdge ( 4 , 5 ) ; insertEdge ( 4 , 6 ) ; cout << " Minimum ▁ size ▁ of ▁ a ▁ vertex ▁ cover ▁ = ▁ " << findMinCover ( V , E ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left , * right ; } ; node * newNode ( int data ) { node * temp = new node ( ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void morrisTraversalPreorder ( node * root ) { while ( root ) { if ( root -> left == NULL ) { cout << root -> data << " ▁ " ; root = root -> right ; } else { node * current = root -> left ; while ( current -> right && current -> right != root ) current = current -> right ; if ( current -> right == root ) { current -> right = NULL ; root = root -> right ; } else { cout << root -> data << " ▁ " ; current -> right = root ; root = root -> left ; } } } } void preorder ( node * root ) { if ( root ) { cout << root -> data << " ▁ " ; preorder ( root -> left ) ; preorder ( root -> right ) ; } } int main ( ) { node * root = NULL ; root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 8 ) ; root -> left -> left -> right = newNode ( 9 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 11 ) ; morrisTraversalPreorder ( root ) ; cout << endl ; preorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void addEdge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; } int findSum ( vector < int > adj [ ] , int V ) { int sum = 0 ; for ( int u = 0 ; u < V ; u ++ ) sum += adj [ u ] . size ( ) ; return sum ; } int main ( ) { int V = 4 ; vector < int > adj [ V ] ; addEdge ( adj , 0 , 2 ) ; addEdge ( adj , 0 , 3 ) ; addEdge ( adj , 1 , 3 ) ; addEdge ( adj , 2 , 3 ) ; cout << " Sum ▁ of ▁ dependencies ▁ is ▁ " << findSum ( adj , V ) ; return 0 ; }
void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; }
void insertAfter ( Node * prev_node , int new_data ) { if ( prev_node == NULL ) { cout << " the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL " ; return ; } Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = prev_node -> next ; prev_node -> next = new_node ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * node = new struct node ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void iterativePreorder ( node * root ) { if ( root == NULL ) return ; stack < node * > nodeStack ; nodeStack . push ( root ) ; while ( nodeStack . empty ( ) == false ) { struct node * node = nodeStack . top ( ) ; printf ( " % d ▁ " , node -> data ) ; nodeStack . pop ( ) ; if ( node -> right ) nodeStack . push ( node -> right ) ; if ( node -> left ) nodeStack . push ( node -> left ) ; } } int main ( ) { struct node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 2 ) ; iterativePreorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; Node ( int data ) { this -> data = data ; this -> left = this -> right = NULL ; } } ; void preorderIterative ( Node * root ) { if ( root == NULL ) return ; stack < Node * > st ; Node * curr = root ; while ( ! st . empty ( ) curr != NULL ) { while ( curr != NULL ) { cout << curr -> data << " ▁ " ; if ( curr -> right ) st . push ( curr -> right ) ; curr = curr -> left ; } if ( st . empty ( ) == false ) { curr = st . top ( ) ; st . pop ( ) ; } } } int main ( ) { Node * root = new Node ( 10 ) ; root -> left = new Node ( 20 ) ; root -> right = new Node ( 30 ) ; root -> left -> left = new Node ( 40 ) ; root -> left -> left -> left = new Node ( 70 ) ; root -> left -> right = new Node ( 50 ) ; root -> right -> left = new Node ( 60 ) ; root -> left -> left -> right = new Node ( 80 ) ; preorderIterative ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; int frequency = 0 ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int count ( struct Node * head , int key ) { if ( head == NULL ) return frequency ; if ( head -> data == key ) frequency ++ ; return count ( head -> next , key ) ; } int main ( ) { struct Node * head = NULL ; push ( & head , 1 ) ; push ( & head , 3 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; cout << " count ▁ of ▁ 1 ▁ is ▁ " << count ( head , 1 ) ; return 0 ; }
int count ( struct Node * head , int key ) { if ( head == NULL ) return 0 ; if ( head -> data == key ) return 1 + count ( head -> next , key ) ; return count ( head -> next , key ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; int flag ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> flag = 0 ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } bool detectLoop ( struct Node * h ) { while ( h != NULL ) { if ( h -> flag == 1 ) return true ; h -> flag = 1 ; h = h -> next ; } return false ; } int main ( ) { struct Node * head = NULL ; push ( & head , 20 ) ; push ( & head , 4 ) ; push ( & head , 15 ) ; push ( & head , 10 ) ; head -> next -> next -> next -> next = head ; if ( detectLoop ( head ) ) cout << " Loop ▁ found " ; else cout << " No ▁ Loop " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int detectLoop ( Node * list ) { Node * slow_p = list , * fast_p = list ; while ( slow_p && fast_p && fast_p -> next ) { slow_p = slow_p -> next ; fast_p = fast_p -> next -> next ; if ( slow_p == fast_p ) { return 1 ; } } return 0 ; } int main ( ) { Node * head = NULL ; push ( & head , 20 ) ; push ( & head , 4 ) ; push ( & head , 15 ) ; push ( & head , 10 ) ; head -> next -> next -> next -> next = head ; if ( detectLoop ( head ) ) cout << " Loop ▁ found " ; else cout << " No ▁ Loop " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * next ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> next = NULL ; return temp ; } void printList ( Node * head ) { while ( head != NULL ) { cout << head -> key << " ▁ " ; head = head -> next ; } cout << endl ; } bool detectLoop ( Node * head ) { Node * temp = new Node ; while ( head != NULL ) { if ( head -> next == NULL ) { return false ; } if ( head -> next == temp ) { return true ; } Node * nex = head -> next ; head -> next = temp ; head = nex ; } return false ; } int main ( ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; head -> next -> next -> next -> next -> next = head -> next -> next ; bool found = detectLoop ( head ) ; if ( found ) cout << " Loop ▁ Found " ; else cout << " No ▁ Loop " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * next ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> next = NULL ; return temp ; } void printList ( Node * head ) { while ( head != NULL ) { cout << head -> key << " ▁ " ; head = head -> next ; } cout << endl ; } int distance ( Node * first , Node * last ) { int counter = 0 ; Node * curr ; curr = first ; while ( curr != last ) { counter += 1 ; curr = curr -> next ; } return counter + 1 ; } bool detectLoop ( Node * head ) { Node * temp = new Node ; Node * first , * last ; first = head ; last = head ; int current_length = 0 ; int prev_length = -1 ; while ( current_length > prev_length && last != NULL ) { prev_length = current_length ; current_length = distance ( first , last ) ; last = last -> next ; } if ( last == NULL ) { return false ; } else { return true ; } } int main ( ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; head -> next -> next -> next -> next -> next = head -> next -> next ; bool found = detectLoop ( head ) ; if ( found ) cout << " Loop ▁ Found " ; else cout << " No ▁ Loop ▁ Found " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; Node ( ) { data = 0 ; next = NULL ; } } ; void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } } void removeDuplicates ( Node * head ) { unordered_map < int , bool > track ; Node * temp = head ; while ( temp ) { if ( track . find ( temp -> data ) == track . end ( ) ) { cout << temp -> data << " ▁ " ; } track [ temp -> data ] = true ; temp = temp -> next ; } } int main ( ) { Node * head = NULL ; push ( & head , 20 ) ; push ( & head , 13 ) ; push ( & head , 13 ) ; push ( & head , 11 ) ; push ( & head , 11 ) ; push ( & head , 11 ) ; cout << " Linked ▁ list ▁ before ▁ duplicate ▁ removal ▁ " ; printList ( head ) ; cout << " Linked list after duplicate removal " ; removeDuplicates ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; void swapNodes ( Node * * head_ref , int x , int y ) { if ( x == y ) return ; Node * prevX = NULL , * currX = * head_ref ; while ( currX && currX -> data != x ) { prevX = currX ; currX = currX -> next ; } Node * prevY = NULL , * currY = * head_ref ; while ( currY && currY -> data != y ) { prevY = currY ; currY = currY -> next ; } if ( currX == NULL currY == NULL ) return ; if ( prevX != NULL ) prevX -> next = currY ; else * head_ref = currY ; if ( prevY != NULL ) prevY -> next = currX ; else * head_ref = currX ; Node * temp = currY -> next ; currY -> next = currX -> next ; currX -> next = temp ; } void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } } int main ( ) { Node * start = NULL ; push ( & start , 7 ) ; push ( & start , 6 ) ; push ( & start , 5 ) ; push ( & start , 4 ) ; push ( & start , 3 ) ; push ( & start , 2 ) ; push ( & start , 1 ) ; cout << " Linked ▁ list ▁ before ▁ calling ▁ swapNodes ( ) ▁ " ; printList ( start ) ; swapNodes ( & start , 4 , 3 ) ; cout << " Linked list after calling swapNodes ( ) " ; printList ( start ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; void postorder ( struct Node * head ) { struct Node * temp = head ; unordered_set < Node * > visited ; while ( temp && visited . find ( temp ) == visited . end ( ) ) { if ( temp -> left && visited . find ( temp -> left ) == visited . end ( ) ) temp = temp -> left ; else if ( temp -> right && visited . find ( temp -> right ) == visited . end ( ) ) temp = temp -> right ; else { printf ( " % d ▁ " , temp -> data ) ; visited . insert ( temp ) ; temp = head ; } } } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } int main ( ) { struct Node * root = newNode ( 8 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 10 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 4 ) ; root -> left -> right -> right = newNode ( 7 ) ; root -> right -> right = newNode ( 14 ) ; root -> right -> right -> left = newNode ( 13 ) ; postorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; bool visited ; } ; void postorder ( struct Node * head ) { struct Node * temp = head ; while ( temp && temp -> visited == false ) { if ( temp -> left && temp -> left -> visited == false ) temp = temp -> left ; else if ( temp -> right && temp -> right -> visited == false ) temp = temp -> right ; else { printf ( " % d ▁ " , temp -> data ) ; temp -> visited = true ; temp = head ; } } } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; node -> visited = false ; return ( node ) ; } int main ( ) { struct Node * root = newNode ( 8 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 10 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 6 ) ; root -> left -> right -> left = newNode ( 4 ) ; root -> left -> right -> right = newNode ( 7 ) ; root -> right -> right = newNode ( 14 ) ; root -> right -> right -> left = newNode ( 13 ) ; postorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isCircular ( struct Node * head ) { if ( head == NULL ) return true ; struct Node * node = head -> next ; while ( node != NULL && node != head ) node = node -> next ; return ( node == head ) ; } Node * newNode ( int data ) { struct Node * temp = new Node ; temp -> data = data ; temp -> next = NULL ; return temp ; } int main ( ) { struct Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; isCircular ( head ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; head -> next -> next -> next -> next = head ; isCircular ( head ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
struct Node * addToEmpty ( struct Node * last , int data ) { if ( last != NULL ) return last ; struct Node * temp = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; temp -> data = data ; last = temp ; temp -> next = last ; return last ; }
struct Node * addBegin ( struct Node * last , int data ) { if ( last == NULL ) return addToEmpty ( last , data ) ; struct Node * temp = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; temp -> data = data ; temp -> next = last -> next ; last -> next = temp ; return last ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; void diagonalPrintUtil ( Node * root , int d , map < int , vector < int > > & diagonalPrint ) { if ( ! root ) return ; diagonalPrint [ d ] . push_back ( root -> data ) ; diagonalPrintUtil ( root -> left , d + 1 , diagonalPrint ) ; diagonalPrintUtil ( root -> right , d , diagonalPrint ) ; } void diagonalPrint ( Node * root ) { map < int , vector < int > > diagonalPrint ; diagonalPrintUtil ( root , 0 , diagonalPrint ) ; cout << " Diagonal ▁ Traversal ▁ of ▁ binary ▁ tree ▁ : ▁ STRNEWLINE " ; for ( auto it : diagonalPrint ) { vector < int > v = it . second ; for ( auto it : v ) cout << it << " ▁ " ; cout << endl ; } } Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int main ( ) { Node * root = newNode ( 8 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 10 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> right = newNode ( 14 ) ; root -> right -> right -> left = newNode ( 13 ) ; root -> left -> right -> left = newNode ( 4 ) ; root -> left -> right -> right = newNode ( 7 ) ; diagonalPrint ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char tree [ 10 ] ; int root ( char key ) { if ( tree [ 0 ] != ' \0' ) cout << " Tree ▁ already ▁ had ▁ root " ; else tree [ 0 ] = key ; return 0 ; } int set_left ( char key , int parent ) { if ( tree [ parent ] == ' \0' ) cout << " Can ' set child at " << ( parent * 2 ) + 1 << " ▁ , ▁ no ▁ parent ▁ found " ; else tree [ ( parent * 2 ) + 1 ] = key ; return 0 ; } int set_right ( char key , int parent ) { if ( tree [ parent ] == ' \0' ) cout << " Can ' set child at " << ( parent * 2 ) + 2 << " ▁ , ▁ no ▁ parent ▁ found " ; else tree [ ( parent * 2 ) + 2 ] = key ; return 0 ; } int print_tree ( ) { cout << " STRNEWLINE " ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( tree [ i ] != ' \0' ) cout << tree [ i ] ; else cout << " - " ; } return 0 ; } int main ( ) { root ( ' A ' ) ; set_right ( ' C ' , 0 ) ; set_left ( ' D ' , 1 ) ; set_right ( ' E ' , 1 ) ; set_right ( ' F ' , 2 ) ; print_tree ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next , * prev ; } ; void pairSum ( struct Node * head , int x ) { struct Node * first = head ; struct Node * second = head ; while ( second -> next != NULL ) second = second -> next ; bool found = false ; while ( first != second && second -> next != first ) { if ( ( first -> data + second -> data ) == x ) { found = true ; cout << " ( " << first -> data << " , ▁ " << second -> data << " ) " << endl ; first = first -> next ; second = second -> prev ; } else { if ( ( first -> data + second -> data ) < x ) first = first -> next ; else second = second -> prev ; } } if ( found == false ) cout << " No ▁ pair ▁ found " ; } void insert ( struct Node * * head , int data ) { struct Node * temp = new Node ; temp -> data = data ; temp -> next = temp -> prev = NULL ; if ( ! ( * head ) ) ( * head ) = temp ; else { temp -> next = * head ; ( * head ) -> prev = temp ; ( * head ) = temp ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 9 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 5 ) ; insert ( & head , 4 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; int x = 7 ; pairSum ( head , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = ( Node * ) malloc ( sizeof ( Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void diagonalPrint ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; q . push ( NULL ) ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( temp == NULL ) { if ( q . empty ( ) ) return ; cout << endl ; q . push ( NULL ) ; } else { while ( temp ) { cout << temp -> data << " ▁ " ; if ( temp -> left ) q . push ( temp -> left ) ; temp = temp -> right ; } } } } int main ( ) { Node * root = newNode ( 8 ) ; root -> left = newNode ( 3 ) ; root -> right = newNode ( 10 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> right = newNode ( 14 ) ; root -> right -> right -> left = newNode ( 13 ) ; root -> left -> right -> left = newNode ( 4 ) ; root -> left -> right -> right = newNode ( 7 ) ; diagonalPrint ( root ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * prev ; } ; void deleteNode ( struct Node * * head_ref , struct Node * del ) { if ( * head_ref == NULL del == NULL ) return ; if ( * head_ref == del ) * head_ref = del -> next ; if ( del -> next != NULL ) del -> next -> prev = del -> prev ; if ( del -> prev != NULL ) del -> prev -> next = del -> next ; free ( del ) ; } void removeDuplicates ( struct Node * * head_ref ) { if ( ( * head_ref ) == NULL || ( * head_ref ) -> next == NULL ) return ; struct Node * ptr1 , * ptr2 ; for ( ptr1 = * head_ref ; ptr1 != NULL ; ptr1 = ptr1 -> next ) { ptr2 = ptr1 -> next ; while ( ptr2 != NULL ) { if ( ptr1 -> data == ptr2 -> data ) { struct Node * next = ptr2 -> next ; deleteNode ( head_ref , ptr2 ) ; ptr2 = next ; } else ptr2 = ptr2 -> next ; } } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> prev = NULL ; new_node -> next = ( * head_ref ) ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; } void printList ( struct Node * head ) { if ( head == NULL ) cout << " Doubly ▁ Linked ▁ list ▁ empty " ; while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 12 ) ; push ( & head , 10 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 4 ) ; push ( & head , 6 ) ; push ( & head , 4 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; cout << " Original ▁ Doubly ▁ linked ▁ list : n " ; printList ( head ) ; removeDuplicates ( & head ) ; cout << " Doubly linked list after " STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL " removing duplicates : n " ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * prev ; } ; void deleteNode ( struct Node * * head_ref , struct Node * del ) { if ( * head_ref == NULL del == NULL ) return ; if ( * head_ref == del ) * head_ref = del -> next ; if ( del -> next != NULL ) del -> next -> prev = del -> prev ; if ( del -> prev != NULL ) del -> prev -> next = del -> next ; free ( del ) ; } void removeDuplicates ( struct Node * * head_ref ) { if ( ( * head_ref ) == NULL ) return ; unordered_set < int > us ; struct Node * current = * head_ref , * next ; while ( current != NULL ) { if ( us . find ( current -> data ) != us . end ( ) ) { next = current -> next ; deleteNode ( head_ref , current ) ; current = next ; } else { us . insert ( current -> data ) ; current = current -> next ; } } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> prev = NULL ; new_node -> next = ( * head_ref ) ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; } void printList ( struct Node * head ) { if ( head == NULL ) cout << " Doubly ▁ Linked ▁ list ▁ empty " ; while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 12 ) ; push ( & head , 10 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 4 ) ; push ( & head , 6 ) ; push ( & head , 4 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; cout << " Original ▁ Doubly ▁ linked ▁ list : n " ; printList ( head ) ; removeDuplicates ( & head ) ; cout << " Doubly linked list after " STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL " removing duplicates : n " ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * prev ; } ; void reverse ( struct Node * * head_ref ) { struct Node * temp = NULL ; struct Node * current = * head_ref ; while ( current != NULL ) { temp = current -> prev ; current -> prev = current -> next ; current -> next = temp ; current = current -> prev ; } if ( temp != NULL ) * head_ref = temp -> prev ; } struct Node * merge ( struct Node * first , struct Node * second ) { if ( ! first ) return second ; if ( ! second ) return first ; if ( first -> data < second -> data ) { first -> next = merge ( first -> next , second ) ; first -> next -> prev = first ; first -> prev = NULL ; return first ; } else { second -> next = merge ( first , second -> next ) ; second -> next -> prev = second ; second -> prev = NULL ; return second ; } } struct Node * sort ( struct Node * head ) { if ( head == NULL head -> next == NULL ) return head ; struct Node * current = head -> next ; while ( current != NULL ) { if ( current -> data < current -> prev -> data ) break ; current = current -> next ; } if ( current == NULL ) return head ; current -> prev -> next = NULL ; current -> prev = NULL ; reverse ( & current ) ; return merge ( head , current ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> prev = NULL ; new_node -> next = ( * head_ref ) ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; } void printList ( struct Node * head ) { if ( head == NULL ) cout << " Doubly ▁ Linked ▁ list ▁ empty " ; while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 1 ) ; push ( & head , 4 ) ; push ( & head , 6 ) ; push ( & head , 10 ) ; push ( & head , 12 ) ; push ( & head , 7 ) ; push ( & head , 5 ) ; push ( & head , 2 ) ; cout << " Original ▁ Doubly ▁ linked ▁ list : n " ; printList ( head ) ; head = sort ( head ) ; cout << " Doubly linked list after sorting : n " ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : Node * prev ; int info ; Node * next ; } ; void nodeInsetail ( Node * * head , Node * * tail , int key ) { Node * p = new Node ( ) ; p -> info = key ; p -> next = NULL ; if ( ( * head ) == NULL ) { ( * head ) = p ; ( * tail ) = p ; ( * head ) -> prev = NULL ; return ; } if ( ( p -> info ) < ( ( * head ) -> info ) ) { p -> prev = NULL ; ( * head ) -> prev = p ; p -> next = ( * head ) ; ( * head ) = p ; return ; } if ( ( p -> info ) > ( ( * tail ) -> info ) ) { p -> prev = ( * tail ) ; ( * tail ) -> next = p ; ( * tail ) = p ; return ; } Node * temp = ( * head ) -> next ; while ( ( temp -> info ) < ( p -> info ) ) temp = temp -> next ; ( temp -> prev ) -> next = p ; p -> prev = temp -> prev ; temp -> prev = p ; p -> next = temp ; } void printList ( Node * temp ) { while ( temp != NULL ) { cout << temp -> info << " ▁ " ; temp = temp -> next ; } } int main ( ) { Node * left = NULL , * right = NULL ; nodeInsetail ( & left , & right , 30 ) ; nodeInsetail ( & left , & right , 50 ) ; nodeInsetail ( & left , & right , 90 ) ; nodeInsetail ( & left , & right , 10 ) ; nodeInsetail ( & left , & right , 40 ) ; nodeInsetail ( & left , & right , 110 ) ; nodeInsetail ( & left , & right , 60 ) ; nodeInsetail ( & left , & right , 95 ) ; nodeInsetail ( & left , & right , 23 ) ; cout << " Doubly ▁ linked ▁ list ▁ on ▁ printing " " ▁ from ▁ left ▁ to ▁ right STRNEWLINE " ; printList ( left ) ; return 0 ; }
void insertEnd ( struct Node * * start , int value ) { if ( * start == NULL ) { struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = new_node -> prev = new_node ; * start = new_node ; return ; } Node * last = ( * start ) -> prev ; struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = * start ; ( * start ) -> prev = new_node ; new_node -> prev = last ; last -> next = new_node ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * prev ; } ; void insertEnd ( struct Node * * start , int value ) { if ( * start == NULL ) { struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = new_node -> prev = new_node ; * start = new_node ; return ; } Node * last = ( * start ) -> prev ; struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = * start ; ( * start ) -> prev = new_node ; new_node -> prev = last ; last -> next = new_node ; } void insertBegin ( struct Node * * start , int value ) { struct Node * last = ( * start ) -> prev ; struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = * start ; new_node -> prev = last ; last -> next = ( * start ) -> prev = new_node ; * start = new_node ; } void insertAfter ( struct Node * * start , int value1 , int value2 ) { struct Node * new_node = new Node ; new_node -> data = value1 ; struct Node * temp = * start ; while ( temp -> data != value2 ) temp = temp -> next ; struct Node * next = temp -> next ; temp -> next = new_node ; new_node -> prev = temp ; new_node -> next = next ; next -> prev = new_node ; } void display ( struct Node * start ) { struct Node * temp = start ; printf ( " Traversal in forward direction " while ( temp -> next != start ) { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } printf ( " % d ▁ " , temp -> data ) ; printf ( " Traversal in reverse direction " Node * last = start -> prev ; temp = last ; while ( temp -> prev != last ) { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> prev ; } printf ( " % d ▁ " , temp -> data ) ; } int main ( ) { struct Node * start = NULL ; insertEnd ( & start , 5 ) ; insertBegin ( & start , 4 ) ; insertEnd ( & start , 7 ) ; insertEnd ( & start , 8 ) ; insertAfter ( & start , 6 , 5 ) ; printf ( " Created ▁ circular ▁ doubly ▁ linked ▁ list ▁ is : ▁ " ) ; display ( start ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct node { int data ; struct node * left , * right ; } ; void printLeaves ( struct node * root ) { if ( root == NULL ) return ; printLeaves ( root -> left ) ; if ( ! ( root -> left ) && ! ( root -> right ) ) printf ( " % d ▁ " , root -> data ) ; printLeaves ( root -> right ) ; } void printBoundaryLeft ( struct node * root ) { if ( root == NULL ) return ; if ( root -> left ) { printf ( " % d ▁ " , root -> data ) ; printBoundaryLeft ( root -> left ) ; } else if ( root -> right ) { printf ( " % d ▁ " , root -> data ) ; printBoundaryLeft ( root -> right ) ; } } void printBoundaryRight ( struct node * root ) { if ( root == NULL ) return ; if ( root -> right ) { printBoundaryRight ( root -> right ) ; printf ( " % d ▁ " , root -> data ) ; } else if ( root -> left ) { printBoundaryRight ( root -> left ) ; printf ( " % d ▁ " , root -> data ) ; } } void printBoundary ( struct node * root ) { if ( root == NULL ) return ; printf ( " % d ▁ " , root -> data ) ; printBoundaryLeft ( root -> left ) ; printLeaves ( root -> left ) ; printLeaves ( root -> right ) ; printBoundaryRight ( root -> right ) ; } struct node * newNode ( int data ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { struct node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; printBoundary ( root ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; void printReverse ( struct Node * * head_ref , int n ) { int j = 0 ; struct Node * current = * head_ref ; while ( current != NULL ) { for ( int i = 0 ; i < 2 * ( n - j ) ; i ++ ) printf ( " ▁ " ) ; printf ( " % d \r " , current -> data ) ; current = current -> next ; j ++ ; } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int printList ( struct Node * head ) { int i = 0 ; struct Node * temp = head ; while ( temp != NULL ) { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; i ++ ; } return i ; } int main ( ) { struct Node * head = NULL ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 3 ) ; push ( & head , 4 ) ; push ( & head , 5 ) ; push ( & head , 6 ) ; printf ( " Given ▁ linked ▁ list : STRNEWLINE " ) ; int n = printList ( head ) ; printf ( " Reversed Linked list : " printReverse ( & head , n ) ; printf ( " STRNEWLINE " ) ; return 0 ; }
struct Node { int data ; struct Node * next ; } ;
void fun1 ( struct Node * head ) { if ( head == NULL ) return ; fun1 ( head -> next ) ; cout << head -> data << " ▁ " ; }
void fun2 ( struct Node * head ) { if ( head == NULL ) return ; cout << head -> data << " ▁ " ; if ( head -> next != NULL ) fun2 ( head -> next -> next ) ; cout << head -> data << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; void fun1 ( Node * head ) { if ( head == NULL ) return ; fun1 ( head -> next ) ; cout << head -> data << " ▁ " ; } void fun2 ( Node * start ) { if ( start == NULL ) return ; cout << start -> data << " ▁ " ; if ( start -> next != NULL ) fun2 ( start -> next -> next ) ; cout << start -> data << " ▁ " ; } void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { Node * head = NULL ; push ( & head , 5 ) ; push ( & head , 4 ) ; push ( & head , 3 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; cout << " Output ▁ of ▁ fun1 ( ) ▁ for ▁ list ▁ 1 - > 2 - > 3 - > 4 - > 5 ▁ STRNEWLINE " ; fun1 ( head ) ; cout << " Output of fun2 ( ) for list 1 -> 2 -> 3 -> 4 -> 5 " ; fun2 ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return node ; } int heighAndSize ( Node * node , int & size ) { if ( node == NULL ) return 0 ; int l = heighAndSize ( node -> left , size ) ; int r = heighAndSize ( node -> right , size ) ; size ++ ; return ( l > r ) ? l + 1 : r + 1 ; } float density ( Node * root ) { if ( root == NULL ) return 0 ; int size = 0 ; int _height = heighAndSize ( root , size ) ; return ( float ) size / _height ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; printf ( " Density ▁ of ▁ given ▁ binary ▁ tree ▁ is ▁ % f " , density ( root ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; int printsqrtn ( Node * head ) { Node * sqrtn = NULL ; int i = 1 , j = 1 ; while ( head != NULL ) { if ( i == j * j ) { if ( sqrtn == NULL ) sqrtn = head ; else sqrtn = sqrtn -> next ; j ++ ; } i ++ ; head = head -> next ; } return sqrtn -> data ; } void print ( Node * head ) { while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } cout << endl ; } void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { Node * head = NULL ; push ( & head , 40 ) ; push ( & head , 30 ) ; push ( & head , 20 ) ; push ( & head , 10 ) ; cout << " Given ▁ linked ▁ list ▁ is : " ; print ( head ) ; cout << " sqrt ( n ) th ▁ node ▁ is ▁ " << printsqrtn ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int data ; Node * next ; } ; Node * newNode ( int data ) { Node * new_node = new Node ; new_node -> data = data ; new_node -> next = NULL ; return new_node ; } Node * fractionalNodes ( Node * head , int k ) { if ( k <= 0 head == NULL ) return NULL ; Node * fractionalNode = NULL ; int i = 0 ; for ( Node * temp = head ; temp != NULL ; temp = temp -> next ) { if ( i % k == 0 ) { if ( fractionalNode == NULL ) fractionalNode = head ; else fractionalNode = fractionalNode -> next ; } i ++ ; } return fractionalNode ; } void printList ( Node * node ) { while ( node != NULL ) { printf ( " % d ▁ " , node -> data ) ; node = node -> next ; } printf ( " STRNEWLINE " ) ; } int main ( void ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; int k = 2 ; printf ( " List ▁ is ▁ " ) ; printList ( head ) ; Node * answer = fractionalNodes ( head , k ) ; printf ( " Fractional node is " printf ( " % d STRNEWLINE " , answer -> data ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int data ; Node * next ; } ; Node * newNode ( int data ) { Node * new_node = new Node ; new_node -> data = data ; new_node -> next = NULL ; return new_node ; } Node * modularNode ( Node * head , int k ) { if ( k <= 0 head == NULL ) return NULL ; int i = 1 ; Node * modularNode = NULL ; for ( Node * temp = head ; temp != NULL ; temp = temp -> next ) { if ( i % k == 0 ) modularNode = temp ; i ++ ; } return modularNode ; } int main ( void ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; int k = 2 ; Node * answer = modularNode ( head , k ) ; printf ( " Modular node is " if ( answer != NULL ) printf ( " % d STRNEWLINE " , answer -> data ) ; else printf ( " null STRNEWLINE " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printList ( struct Node * ) ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = * head_ref ; * head_ref = new_node ; } void frontAndBackSplit ( struct Node * head , struct Node * * front_ref , struct Node * * back_ref ) { Node * slow , * fast ; slow = head ; fast = head -> next ; while ( fast != NULL ) { fast = fast -> next ; if ( fast != NULL ) { slow = slow -> next ; fast = fast -> next ; } } * front_ref = head ; * back_ref = slow -> next ; slow -> next = NULL ; } void reverseList ( struct Node * * head_ref ) { struct Node * current , * prev , * next ; current = * head_ref ; prev = NULL ; while ( current != NULL ) { next = current -> next ; current -> next = prev ; prev = current ; current = next ; } * head_ref = prev ; } void modifyTheContentsOf1stHalf ( struct Node * front , struct Node * back ) { while ( back != NULL ) { front -> data = front -> data - back -> data ; front = front -> next ; back = back -> next ; } } struct Node * concatFrontAndBackList ( struct Node * front , struct Node * back ) { struct Node * head = front ; while ( front -> next != NULL ) front = front -> next ; front -> next = back ; return head ; } struct Node * modifyTheList ( struct Node * head ) { if ( ! head head -> next == NULL ) return head ; struct Node * front , * back ; frontAndBackSplit ( head , & front , & back ) ; reverseList ( & back ) ; modifyTheContentsOf1stHalf ( front , back ) ; reverseList ( & back ) ; head = concatFrontAndBackList ( front , back ) ; return head ; } void printList ( struct Node * head ) { if ( ! head ) return ; while ( head -> next != NULL ) { cout << head -> data << " ▁ - > ▁ " ; head = head -> next ; } cout << head -> data << endl ; } int main ( ) { struct Node * head = NULL ; push ( & head , 10 ) ; push ( & head , 7 ) ; push ( & head , 12 ) ; push ( & head , 8 ) ; push ( & head , 9 ) ; push ( & head , 2 ) ; head = modifyTheList ( head ) ; cout << " Modified ▁ List : " << endl ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printList ( struct Node * ) ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = * head_ref ; * head_ref = new_node ; } void printList ( struct Node * head ) { if ( ! head ) return ; while ( head -> next != NULL ) { cout << head -> data << " ▁ - > ▁ " ; head = head -> next ; } cout << head -> data << endl ; } Node * find_mid ( Node * head ) { Node * temp = head , * slow = head , * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; return slow ; } void modifyTheList ( struct Node * head , struct Node * slow ) { stack < int > s ; Node * temp = head ; while ( slow ) { s . push ( slow -> data ) ; slow = slow -> next ; } while ( ! s . empty ( ) ) { temp -> data = temp -> data - s . top ( ) ; temp = temp -> next ; s . pop ( ) ; } } int main ( ) { struct Node * head = NULL , * mid ; push ( & head , 10 ) ; push ( & head , 7 ) ; push ( & head , 12 ) ; push ( & head , 8 ) ; push ( & head , 9 ) ; push ( & head , 2 ) ; mid = find_mid ( head ) ; modifyTheList ( head , mid ) ; cout << " Modified ▁ List : " << endl ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDepthRec ( char tree [ ] , int n , int & index ) { if ( index >= n tree [ index ] == ' l ' ) return 0 ; index ++ ; int left = findDepthRec ( tree , n , index ) ; index ++ ; int right = findDepthRec ( tree , n , index ) ; return max ( left , right ) + 1 ; } int findDepth ( char tree [ ] , int n ) { int index = 0 ; findDepthRec ( tree , n , index ) ; } int main ( ) { char tree [ ] = " nlnnlll " ; int n = strlen ( tree ) ; cout << findDepth ( tree , n ) << endl ; return 0 ; }
struct node * search ( struct node * root , int key ) { if ( root == NULL root -> key == key ) return root ; if ( root -> key < key ) return search ( root -> right , key ) ; return search ( root -> left , key ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new struct Node ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } struct Node * modifytree ( struct Node * root ) { struct Node * right = root -> right ; struct Node * rightMost = root ; if ( root -> left ) { rightMost = modifytree ( root -> left ) ; root -> right = root -> left ; root -> left = NULL ; } if ( ! right ) return rightMost ; rightMost -> right = right ; rightMost = modifytree ( right ) ; return rightMost ; } void printpre ( struct Node * root ) { while ( root != NULL ) { cout << root -> data << " ▁ " ; root = root -> right ; } } int main ( ) { struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; modifytree ( root ) ; printpre ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return newNode ; } Node * LevelOrder ( Node * root , int data ) { if ( root == NULL ) { root = getNode ( data ) ; return root ; } if ( data <= root -> data ) root -> left = LevelOrder ( root -> left , data ) ; else root -> right = LevelOrder ( root -> right , data ) ; return root ; } Node * constructBst ( int arr [ ] , int n ) { if ( n == 0 ) return NULL ; Node * root = NULL ; for ( int i = 0 ; i < n ; i ++ ) root = LevelOrder ( root , arr [ i ] ) ; return root ; } void inorderTraversal ( Node * root ) { if ( ! root ) return ; inorderTraversal ( root -> left ) ; cout << root -> data << " ▁ " ; inorderTraversal ( root -> right ) ; } int main ( ) { int arr [ ] = { 7 , 4 , 12 , 3 , 6 , 8 , 1 , 5 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Node * root = constructBst ( arr , n ) ; cout << " Inorder ▁ Traversal : ▁ " ; inorderTraversal ( root ) ; return 0 ; }
#include <iostream> NEW_LINE #include <stack> NEW_LINE #include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new struct Node ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } void modifytree ( struct Node * root ) { if ( root == NULL ) return ; stack < Node * > nodeStack ; nodeStack . push ( root ) ; struct Node * pre = NULL ; while ( nodeStack . empty ( ) == false ) { struct Node * node = nodeStack . top ( ) ; nodeStack . pop ( ) ; if ( node -> right ) nodeStack . push ( node -> right ) ; if ( node -> left ) nodeStack . push ( node -> left ) ; if ( pre != NULL ) { pre -> right = node ; } pre = node ; } } void printpre ( struct Node * root ) { while ( root != NULL ) { cout << root -> data << " ▁ " ; root = root -> right ; } } int main ( ) { struct Node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 2 ) ; root -> left -> left = newNode ( 3 ) ; root -> left -> right = newNode ( 5 ) ; modifytree ( root ) ; printpre ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * right , * left ; } ; Node * newNode ( int num ) { Node * temp = new Node ; temp -> key = num ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } Node * createNLevelTree ( int arr [ ] , int n ) { Node * root = newNode ( arr [ 0 ] ) ; Node * temp = root ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp -> key > arr [ i ] ) { temp -> left = newNode ( arr [ i ] ) ; temp = temp -> left ; } else { temp -> right = newNode ( arr [ i ] ) ; temp = temp -> right ; } } return root ; } bool isBST ( Node * root , int min , int max ) { if ( root == NULL ) return true ; if ( root -> key < min root -> key > max ) return false ; return ( isBST ( root -> left , min , ( root -> key ) - 1 ) && isBST ( root -> right , ( root -> key ) + 1 , max ) ) ; } bool canRepresentNLevelBST ( int arr [ ] , int n ) { Node * root = createNLevelTree ( arr , n ) ; return isBST ( root , INT_MIN , INT_MAX ) ; } int main ( ) { int arr [ ] = { 512 , 330 , 78 , 11 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( canRepresentNLevelBST ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int arr [ ] = { 5123 , 3300 , 783 , 1111 , 890 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = INT_MAX ; int min = INT_MIN ; bool flag = true ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > min && arr [ i ] < max ) { min = arr [ i - 1 ] ; } else if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] > min && arr [ i ] < max ) { max = arr [ i - 1 ] ; } else { flag = false ; break ; } } if ( flag ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; void storeBSTNodes ( Node * root , vector < Node * > & nodes ) { if ( root == NULL ) return ; storeBSTNodes ( root -> left , nodes ) ; nodes . push_back ( root ) ; storeBSTNodes ( root -> right , nodes ) ; } Node * buildTreeUtil ( vector < Node * > & nodes , int start , int end ) { if ( start > end ) return NULL ; int mid = ( start + end ) / 2 ; Node * root = nodes [ mid ] ; root -> left = buildTreeUtil ( nodes , start , mid - 1 ) ; root -> right = buildTreeUtil ( nodes , mid + 1 , end ) ; return root ; } Node * buildTree ( Node * root ) { vector < Node * > nodes ; storeBSTNodes ( root , nodes ) ; int n = nodes . size ( ) ; return buildTreeUtil ( nodes , 0 , n - 1 ) ; } Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void preOrder ( Node * node ) { if ( node == NULL ) return ; printf ( " % d ▁ " , node -> data ) ; preOrder ( node -> left ) ; preOrder ( node -> right ) ; } int main ( ) { Node * root = newNode ( 10 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 6 ) ; root -> left -> left -> left -> left = newNode ( 5 ) ; root = buildTree ( root ) ; printf ( " Preorder ▁ traversal ▁ of ▁ balanced ▁ " " BST ▁ is ▁ : ▁ STRNEWLINE " ) ; preOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return ( node ) ; } struct node * insert ( struct node * node , int data ) { if ( node == NULL ) return ( newNode ( data ) ) ; else { if ( data <= node -> data ) node -> left = insert ( node -> left , data ) ; else node -> right = insert ( node -> right , data ) ; return node ; } } int minValue ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) { current = current -> left ; } return ( current -> data ) ; } int main ( ) { struct node * root = NULL ; root = insert ( root , 4 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 6 ) ; insert ( root , 5 ) ; cout << " Minimum value in BST is " getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct NodeDetails { int data ; int min , max ; } ; bool levelOrderIsOfBST ( int arr [ ] , int n ) { if ( n == 0 ) return true ; queue < NodeDetails > q ; int i = 0 ; NodeDetails newNode ; newNode . data = arr [ i ++ ] ; newNode . min = INT_MIN ; newNode . max = INT_MAX ; q . push ( newNode ) ; while ( i != n && ! q . empty ( ) ) { NodeDetails temp = q . front ( ) ; q . pop ( ) ; if ( i < n && ( arr [ i ] < temp . data && arr [ i ] > temp . min ) ) { newNode . data = arr [ i ++ ] ; newNode . min = temp . min ; newNode . max = temp . data ; q . push ( newNode ) ; } if ( i < n && ( arr [ i ] > temp . data && arr [ i ] < temp . max ) ) { newNode . data = arr [ i ++ ] ; newNode . min = temp . data ; newNode . max = temp . max ; q . push ( newNode ) ; } } if ( i == n ) return true ; return false ; } int main ( ) { int arr [ ] = { 7 , 4 , 12 , 3 , 6 , 8 , 1 , 5 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( levelOrderIsOfBST ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : char data ; node * left ; node * right ; } ; int search ( char arr [ ] , int strt , int end , char value ) ; node * newNode ( char data ) ; node * buildTree ( char in [ ] , char pre [ ] , int inStrt , int inEnd ) { static int preIndex = 0 ; if ( inStrt > inEnd ) return NULL ; node * tNode = newNode ( pre [ preIndex ++ ] ) ; if ( inStrt == inEnd ) return tNode ; int inIndex = search ( in , inStrt , inEnd , tNode -> data ) ; tNode -> left = buildTree ( in , pre , inStrt , inIndex - 1 ) ; tNode -> right = buildTree ( in , pre , inIndex + 1 , inEnd ) ; return tNode ; } int search ( char arr [ ] , int strt , int end , char value ) { int i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) return i ; } } node * newNode ( char data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } void printInorder ( node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; cout << node -> data << " ▁ " ; printInorder ( node -> right ) ; } int main ( ) { char in [ ] = { ' D ' , ' B ' , ' E ' , ' A ' , ' F ' , ' C ' } ; char pre [ ] = { ' A ' , ' B ' , ' D ' , ' E ' , ' C ' , ' F ' } ; int len = sizeof ( in ) / sizeof ( in [ 0 ] ) ; node * root = buildTree ( in , pre , 0 , len - 1 ) ; cout << " Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree ▁ is ▁ STRNEWLINE " ; printInorder ( root ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left , * right ; } ; struct node * lca ( struct node * root , int n1 , int n2 ) { while ( root != NULL ) { if ( root -> data > n1 && root -> data > n2 ) root = root -> left ; else if ( root -> data < n1 && root -> data < n2 ) root = root -> right ; else break ; } return root ; } node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = Node -> right = NULL ; return ( Node ) ; } int main ( ) { node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 22 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; int n1 = 10 , n2 = 14 ; node * t = lca ( root , n1 , n2 ) ; cout << " LCA ▁ of ▁ " << n1 << " ▁ and ▁ " << n2 << " ▁ is ▁ " << t -> data << endl ; n1 = 14 , n2 = 8 ; t = lca ( root , n1 , n2 ) ; cout << " LCA ▁ of ▁ " << n1 << " ▁ and ▁ " << n2 << " ▁ is ▁ " << t -> data << endl ; n1 = 10 , n2 = 22 ; t = lca ( root , n1 , n2 ) ; cout << " LCA ▁ of ▁ " << n1 << " ▁ and ▁ " << n2 << " ▁ is ▁ " << t -> data << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; bool isBST ( Node * root , Node * l = NULL , Node * r = NULL ) { if ( root == NULL ) return true ; if ( l != NULL and root -> data <= l -> data ) return false ; if ( r != NULL and root -> data >= r -> data ) return false ; return isBST ( root -> left , l , root ) and isBST ( root -> right , root , r ) ; } struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } int main ( ) { struct Node * root = newNode ( 3 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 4 ) ; if ( isBST ( root , NULL , NULL ) ) cout << " Is ▁ BST " ; else cout << " Not ▁ a ▁ BST " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; int lCount ; Node ( int x ) { data = x ; left = right = NULL ; lCount = 0 ; } } ; Node * insert ( Node * root , int x ) { if ( root == NULL ) return new Node ( x ) ; if ( x < root -> data ) { root -> left = insert ( root -> left , x ) ; root -> lCount ++ ; } else if ( x > root -> data ) root -> right = insert ( root -> right , x ) ; return root ; } Node * kthSmallest ( Node * root , int k ) { if ( root == NULL ) return NULL ; int count = root -> lCount + 1 ; if ( count == k ) return root ; if ( count > k ) return kthSmallest ( root -> left , k ) ; return kthSmallest ( root -> right , k - count ) ; } int main ( ) { Node * root = NULL ; int keys [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; for ( int x : keys ) root = insert ( root , x ) ; int k = 4 ; Node * res = kthSmallest ( root , k ) ; if ( res == NULL ) cout << " There ▁ are ▁ less ▁ than ▁ k ▁ nodes ▁ in ▁ the ▁ BST " ; else cout << " K - th ▁ Smallest ▁ Element ▁ is ▁ " << res -> data ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { char data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( char data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } struct Node * buildTree ( char in [ ] , char pre [ ] , int inStrt , int inEnd , unordered_map < char , int > & mp ) { static int preIndex = 0 ; if ( inStrt > inEnd ) return NULL ; char curr = pre [ preIndex ++ ] ; struct Node * tNode = newNode ( curr ) ; if ( inStrt == inEnd ) return tNode ; int inIndex = mp [ curr ] ; tNode -> left = buildTree ( in , pre , inStrt , inIndex - 1 , mp ) ; tNode -> right = buildTree ( in , pre , inIndex + 1 , inEnd , mp ) ; return tNode ; } struct Node * buldTreeWrap ( char in [ ] , char pre [ ] , int len ) { unordered_map < char , int > mp ; for ( int i = 0 ; i < len ; i ++ ) mp [ in [ i ] ] = i ; return buildTree ( in , pre , 0 , len - 1 , mp ) ; } void printInorder ( struct Node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( " % c ▁ " , node -> data ) ; printInorder ( node -> right ) ; } int main ( ) { char in [ ] = { ' D ' , ' B ' , ' E ' , ' A ' , ' F ' , ' C ' } ; char pre [ ] = { ' A ' , ' B ' , ' D ' , ' E ' , ' C ' , ' F ' } ; int len = sizeof ( in ) / sizeof ( in [ 0 ] ) ; struct Node * root = buldTreeWrap ( in , pre , len ) ; printf ( " Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree ▁ is ▁ STRNEWLINE " ) ; printInorder ( root ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; int KSmallestUsingMorris ( Node * root , int k ) { int count = 0 ; int ksmall = INT_MIN ; Node * curr = root ; while ( curr != NULL ) { if ( curr -> left == NULL ) { count ++ ; if ( count == k ) ksmall = curr -> key ; curr = curr -> right ; } else { Node * pre = curr -> left ; while ( pre -> right != NULL && pre -> right != curr ) pre = pre -> right ; if ( pre -> right == NULL ) { pre -> right = curr ; curr = curr -> left ; } else { pre -> right = NULL ; count ++ ; if ( count == k ) ksmall = curr -> key ; curr = curr -> right ; } } } return ksmall ; } Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } int main ( ) { Node * root = NULL ; root = insert ( root , 50 ) ; insert ( root , 30 ) ; insert ( root , 20 ) ; insert ( root , 40 ) ; insert ( root , 70 ) ; insert ( root , 60 ) ; insert ( root , 80 ) ; for ( int k = 1 ; k <= 7 ; k ++ ) cout << KSmallestUsingMorris ( root , k ) << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int num ) { struct Node * temp = new Node ; temp -> data = num ; temp -> left = temp -> right = NULL ; return temp ; } struct Node * insert ( struct Node * root , int key ) { if ( root == NULL ) return newNode ( key ) ; if ( root -> data > key ) root -> left = insert ( root -> left , key ) ; else root -> right = insert ( root -> right , key ) ; return root ; } void seqExistUtil ( struct Node * ptr , int seq [ ] , int & index ) { if ( ptr == NULL ) return ; seqExistUtil ( ptr -> left , seq , index ) ; if ( ptr -> data == seq [ index ] ) index ++ ; seqExistUtil ( ptr -> right , seq , index ) ; } bool seqExist ( struct Node * root , int seq [ ] , int n ) { int index = 0 ; seqExistUtil ( root , seq , index ) ; return ( index == n ) ; } int main ( ) { struct Node * root = NULL ; root = insert ( root , 8 ) ; root = insert ( root , 10 ) ; root = insert ( root , 3 ) ; root = insert ( root , 6 ) ; root = insert ( root , 1 ) ; root = insert ( root , 4 ) ; root = insert ( root , 7 ) ; root = insert ( root , 14 ) ; root = insert ( root , 13 ) ; int seq [ ] = { 4 , 6 , 8 , 14 } ; int n = sizeof ( seq ) / sizeof ( seq [ 0 ] ) ; seqExist ( root , seq , n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isInorder ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } int main ( ) { int arr [ ] = { 19 , 23 , 25 , 30 , 45 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isInorder ( arr , n ) ) cout << " Yesn " ; else cout << " Non " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; Node * newNode ( int val ) { Node * temp = new Node ; temp -> data = val ; temp -> left = temp -> right = NULL ; return temp ; } void insertToHash ( Node * root , unordered_set < int > & s ) { if ( ! root ) return ; insertToHash ( root -> left , s ) ; s . insert ( root -> data ) ; insertToHash ( root -> right , s ) ; } bool checkBSTs ( Node * root1 , Node * root2 ) { if ( ! root1 && ! root2 ) return true ; if ( ( root1 && ! root2 ) || ( ! root1 && root2 ) ) return false ; unordered_set < int > s1 , s2 ; insertToHash ( root1 , s1 ) ; insertToHash ( root2 , s2 ) ; return ( s1 == s2 ) ; } int main ( ) { Node * root1 = newNode ( 15 ) ; root1 -> left = newNode ( 10 ) ; root1 -> right = newNode ( 20 ) ; root1 -> left -> left = newNode ( 5 ) ; root1 -> left -> right = newNode ( 12 ) ; root1 -> right -> right = newNode ( 25 ) ; Node * root2 = newNode ( 15 ) ; root2 -> left = newNode ( 12 ) ; root2 -> right = newNode ( 20 ) ; root2 -> left -> left = newNode ( 5 ) ; root2 -> left -> left -> right = newNode ( 10 ) ; root2 -> right -> right = newNode ( 25 ) ; if ( checkBSTs ( root1 , root2 ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; Node * newNode ( int val ) { Node * temp = new Node ; temp -> data = val ; temp -> left = temp -> right = NULL ; return temp ; } void storeInorder ( Node * root , vector < int > & v ) { if ( ! root ) return ; storeInorder ( root -> left , v ) ; v . push_back ( root -> data ) ; storeInorder ( root -> right , v ) ; } bool checkBSTs ( Node * root1 , Node * root2 ) { if ( ! root1 && ! root2 ) return true ; if ( ( root1 && ! root2 ) || ( ! root1 && root2 ) ) return false ; vector < int > v1 , v2 ; storeInorder ( root1 , v1 ) ; storeInorder ( root2 , v2 ) ; return ( v1 == v2 ) ; } int main ( ) { Node * root1 = newNode ( 15 ) ; root1 -> left = newNode ( 10 ) ; root1 -> right = newNode ( 20 ) ; root1 -> left -> left = newNode ( 5 ) ; root1 -> left -> right = newNode ( 12 ) ; root1 -> right -> right = newNode ( 25 ) ; Node * root2 = newNode ( 15 ) ; root2 -> left = newNode ( 12 ) ; root2 -> right = newNode ( 20 ) ; root2 -> left -> left = newNode ( 5 ) ; root2 -> left -> left -> right = newNode ( 10 ) ; root2 -> right -> right = newNode ( 25 ) ; if ( checkBSTs ( root1 , root2 ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } int findMaxforN ( Node * root , int N ) { if ( root == NULL ) return -1 ; if ( root -> key == N ) return N ; else if ( root -> key < N ) { int k = findMaxforN ( root -> right , N ) ; if ( k == -1 ) return root -> key ; else return k ; } else if ( root -> key > N ) return findMaxforN ( root -> left , N ) ; } int main ( ) { int N = 4 ; Node * root = insert ( root , 25 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; printf ( " % d " , findMaxforN ( root , N ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; void RangeTraversal ( node * root , int n1 , int n2 ) { if ( ! root ) return ; node * curr = root ; while ( curr ) { if ( curr -> left == NULL ) { if ( curr -> data <= n2 && curr -> data >= n1 ) { cout << curr -> data << " ▁ " ; } curr = curr -> right ; } else { node * pre = curr -> left ; while ( pre -> right != NULL && pre -> right != curr ) pre = pre -> right ; if ( pre -> right == NULL ) { pre -> right = curr ; curr = curr -> left ; } else { pre -> right = NULL ; if ( curr -> data <= n2 && curr -> data >= n1 ) { cout << curr -> data << " ▁ " ; } curr = curr -> right ; } } } } node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> right = temp -> left = NULL ; return temp ; } int main ( ) { node * root = newNode ( 4 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 10 ) ; RangeTraversal ( root , 4 , 12 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } struct Node * insert ( struct Node * root , int data ) { if ( root == NULL ) return newNode ( data ) ; if ( data < root -> data ) root -> left = insert ( root -> left , data ) ; else if ( data > root -> data ) root -> right = insert ( root -> right , data ) ; return root ; } void inorder ( struct Node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << root -> data << " ▁ " ; inorder ( root -> right ) ; } } struct Node * leafDelete ( struct Node * root ) { if ( root == NULL ) return NULL ; if ( root -> left == NULL && root -> right == NULL ) { free ( root ) ; return NULL ; } root -> left = leafDelete ( root -> left ) ; root -> right = leafDelete ( root -> right ) ; return root ; } int main ( ) { struct Node * root = NULL ; root = insert ( root , 20 ) ; insert ( root , 10 ) ; insert ( root , 5 ) ; insert ( root , 15 ) ; insert ( root , 30 ) ; insert ( root , 25 ) ; insert ( root , 35 ) ; cout << " Inorder ▁ before ▁ Deleting ▁ the ▁ leaf ▁ Node . " << endl ; inorder ( root ) ; cout << endl ; leafDelete ( root ) ; cout << " INorder ▁ after ▁ Deleting ▁ the ▁ leaf ▁ Node . " << endl ; inorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; struct Node * createNode ( int data ) { Node * new_Node = new Node ; new_Node -> left = NULL ; new_Node -> right = NULL ; new_Node -> data = data ; return new_Node ; } struct Node * insert ( Node * root , int key ) { if ( root == NULL ) return createNode ( key ) ; if ( root -> data > key ) root -> left = insert ( root -> left , key ) ; else if ( root -> data < key ) root -> right = insert ( root -> right , key ) ; return root ; } int ksmallestElementSumRec ( Node * root , int k , int & count ) { if ( root == NULL ) return 0 ; if ( count > k ) return 0 ; int res = ksmallestElementSumRec ( root -> left , k , count ) ; if ( count >= k ) return res ; res += root -> data ; count ++ ; if ( count >= k ) return res ; return res + ksmallestElementSumRec ( root -> right , k , count ) ; } int ksmallestElementSum ( struct Node * root , int k ) { int count = 0 ; ksmallestElementSumRec ( root , k , count ) ; } int main ( ) { Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; root = insert ( root , 22 ) ; int k = 3 ; cout << ksmallestElementSum ( root , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; int lCount ; int Sum ; Node * left ; Node * right ; } ; struct Node * createNode ( int data ) { Node * new_Node = new Node ; new_Node -> left = NULL ; new_Node -> right = NULL ; new_Node -> data = data ; new_Node -> lCount = 0 ; new_Node -> Sum = 0 ; return new_Node ; } struct Node * insert ( Node * root , int key ) { if ( root == NULL ) return createNode ( key ) ; if ( root -> data > key ) { root -> lCount ++ ; root -> Sum += key ; root -> left = insert ( root -> left , key ) ; } else if ( root -> data < key ) root -> right = insert ( root -> right , key ) ; return root ; } void ksmallestElementSumRec ( Node * root , int k , int & temp_sum ) { if ( root == NULL ) return ; if ( ( root -> lCount + 1 ) == k ) { temp_sum += root -> data + root -> Sum ; return ; } else if ( k > root -> lCount ) { temp_sum += root -> data + root -> Sum ; k = k - ( root -> lCount + 1 ) ; ksmallestElementSumRec ( root -> right , k , temp_sum ) ; } else ksmallestElementSumRec ( root -> left , k , temp_sum ) ; } int ksmallestElementSum ( struct Node * root , int k ) { int sum = 0 ; ksmallestElementSumRec ( root , k , sum ) ; return sum ; } int main ( ) { Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 4 ) ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 14 ) ; root = insert ( root , 22 ) ; int k = 3 ; cout << ksmallestElementSum ( root , k ) << endl ; return 0 ; }
struct Node { int key ; struct Node * left , * right ; } ;
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; void findPreSuc ( Node * root , Node * & pre , Node * & suc , int key ) { if ( root == NULL ) return ; while ( root != NULL ) { if ( root -> key == key ) { if ( root -> right ) { suc = root -> right ; while ( suc -> left ) suc = suc -> left ; } if ( root -> left ) { pre = root -> left ; while ( pre -> right ) pre = pre -> right ; } return ; } else if ( root -> key < key ) { pre = root ; root = root -> right ; } else { suc = root ; root = root -> left ; } } } Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ; return node ; } int main ( ) { int key = 65 ; Node * root = NULL ; root = insert ( root , 50 ) ; insert ( root , 30 ) ; insert ( root , 20 ) ; insert ( root , 40 ) ; insert ( root , 70 ) ; insert ( root , 60 ) ; insert ( root , 80 ) ; Node * pre = NULL , * suc = NULL ; findPreSuc ( root , pre , suc , key ) ; if ( pre != NULL ) cout << " Predecessor ▁ is ▁ " << pre -> key << endl ; else cout << " - 1" ; if ( suc != NULL ) cout << " Successor ▁ is ▁ " << suc -> key ; else cout << " - 1" ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int key ; node * left ; node * right ; } ; void convertBSTtoDLL ( node * root , node * * head , node * * tail ) { if ( root == NULL ) return ; if ( root -> left ) convertBSTtoDLL ( root -> left , head , tail ) ; root -> left = * tail ; if ( * tail ) ( * tail ) -> right = root ; else * head = root ; * tail = root ; if ( root -> right ) convertBSTtoDLL ( root -> right , head , tail ) ; } bool isPresentInDLL ( node * head , node * tail , int sum ) { while ( head != tail ) { int curr = head -> key + tail -> key ; if ( curr == sum ) return true ; else if ( curr > sum ) tail = tail -> left ; else head = head -> right ; } return false ; } bool isTripletPresent ( node * root ) { if ( root == NULL ) return false ; node * head = NULL ; node * tail = NULL ; convertBSTtoDLL ( root , & head , & tail ) ; while ( ( head -> right != tail ) && ( head -> key < 0 ) ) { if ( isPresentInDLL ( head -> right , tail , -1 * head -> key ) ) return true ; else head = head -> right ; } return false ; } node * newNode ( int num ) { node * temp = new node ( ) ; temp -> key = num ; temp -> left = temp -> right = NULL ; return temp ; } node * insert ( node * root , int key ) { if ( root == NULL ) return newNode ( key ) ; if ( root -> key > key ) root -> left = insert ( root -> left , key ) ; else root -> right = insert ( root -> right , key ) ; return root ; } int main ( ) { node * root = NULL ; root = insert ( root , 6 ) ; root = insert ( root , -13 ) ; root = insert ( root , 14 ) ; root = insert ( root , -8 ) ; root = insert ( root , 15 ) ; root = insert ( root , 13 ) ; root = insert ( root , 7 ) ; if ( isTripletPresent ( root ) ) cout << " Present " ; else cout << " Not ▁ Present " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  100 NEW_LINE class node { public : int val ; node * left , * right ; } ; class Stack { public : int size ; int top ; node * * array ; } ; Stack * createStack ( int size ) { Stack * stack = new Stack ( ) ; stack -> size = size ; stack -> top = -1 ; stack -> array = new node * [ ( stack -> size * sizeof ( node * ) ) ] ; return stack ; } int isFull ( Stack * stack ) { return stack -> top - 1 == stack -> size ; } int isEmpty ( Stack * stack ) { return stack -> top == -1 ; } void push ( Stack * stack , node * node ) { if ( isFull ( stack ) ) return ; stack -> array [ ++ stack -> top ] = node ; } node * pop ( Stack * stack ) { if ( isEmpty ( stack ) ) return NULL ; return stack -> array [ stack -> top -- ] ; } bool isPairPresent ( node * root , int target ) { Stack * s1 = createStack ( MAX_SIZE ) ; Stack * s2 = createStack ( MAX_SIZE ) ; bool done1 = false , done2 = false ; int val1 = 0 , val2 = 0 ; node * curr1 = root , * curr2 = root ; while ( 1 ) { while ( done1 == false ) { if ( curr1 != NULL ) { push ( s1 , curr1 ) ; curr1 = curr1 -> left ; } else { if ( isEmpty ( s1 ) ) done1 = 1 ; else { curr1 = pop ( s1 ) ; val1 = curr1 -> val ; curr1 = curr1 -> right ; done1 = 1 ; } } } while ( done2 == false ) { if ( curr2 != NULL ) { push ( s2 , curr2 ) ; curr2 = curr2 -> right ; } else { if ( isEmpty ( s2 ) ) done2 = 1 ; else { curr2 = pop ( s2 ) ; val2 = curr2 -> val ; curr2 = curr2 -> left ; done2 = 1 ; } } } if ( ( val1 != val2 ) && ( val1 + val2 ) == target ) { cout << " Pair ▁ Found : ▁ " << val1 << " + ▁ " << val2 << " ▁ = ▁ " << target << endl ; return true ; } else if ( ( val1 + val2 ) < target ) done1 = false ; else if ( ( val1 + val2 ) > target ) done2 = false ; if ( val1 >= val2 ) return false ; } } node * NewNode ( int val ) { node * tmp = new node ( ) ; tmp -> val = val ; tmp -> right = tmp -> left = NULL ; return tmp ; } int main ( ) { node * root = NewNode ( 15 ) ; root -> left = NewNode ( 10 ) ; root -> right = NewNode ( 20 ) ; root -> left -> left = NewNode ( 8 ) ; root -> left -> right = NewNode ( 12 ) ; root -> right -> left = NewNode ( 16 ) ; root -> right -> right = NewNode ( 25 ) ; int target = 33 ; if ( isPairPresent ( root , target ) == false ) cout << " No such values are found " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * NewNode ( int data ) { Node * temp = ( Node * ) malloc ( sizeof ( Node ) ) ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } Node * insert ( Node * root , int key ) { if ( root == NULL ) return NewNode ( key ) ; if ( key < root -> data ) root -> left = insert ( root -> left , key ) ; else root -> right = insert ( root -> right , key ) ; return root ; } bool findpairUtil ( Node * root , int sum , unordered_set < int > & set ) { if ( root == NULL ) return false ; if ( findpairUtil ( root -> left , sum , set ) ) return true ; if ( set . find ( sum - root -> data ) != set . end ( ) ) { cout << " Pair ▁ is ▁ found ▁ ( " << sum - root -> data << " , ▁ " << root -> data << " ) " << endl ; return true ; } else set . insert ( root -> data ) ; return findpairUtil ( root -> right , sum , set ) ; } void findPair ( Node * root , int sum ) { unordered_set < int > set ; if ( ! findpairUtil ( root , sum , set ) ) cout << " Pairs ▁ do ▁ not ▁ exit " << endl ; } int main ( ) { Node * root = NULL ; root = insert ( root , 15 ) ; root = insert ( root , 10 ) ; root = insert ( root , 20 ) ; root = insert ( root , 8 ) ; root = insert ( root , 12 ) ; root = insert ( root , 16 ) ; root = insert ( root , 25 ) ; root = insert ( root , 10 ) ; int sum = 33 ; findPair ( root , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int num ) { struct Node * temp = new Node ; temp -> data = num ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * root , int key ) { if ( root == NULL ) return newNode ( key ) ; if ( root -> data > key ) root -> left = insert ( root -> left , key ) ; else root -> right = insert ( root -> right , key ) ; return root ; } void storeInorder ( Node * ptr , vector < int > & vect ) { if ( ptr == NULL ) return ; storeInorder ( ptr -> left , vect ) ; vect . push_back ( ptr -> data ) ; storeInorder ( ptr -> right , vect ) ; } void pairSumUtil ( vector < int > & vect1 , vector < int > & vect2 , int sum ) { int left = 0 ; int right = vect2 . size ( ) - 1 ; while ( left < vect1 . size ( ) && right >= 0 ) { if ( vect1 [ left ] + vect2 [ right ] == sum ) { cout << " ( " << vect1 [ left ] << " , ▁ " << vect2 [ right ] << " ) , ▁ " ; left ++ ; right -- ; } else if ( vect1 [ left ] + vect2 [ right ] < sum ) left ++ ; else right -- ; } } void pairSum ( Node * root1 , Node * root2 , int sum ) { vector < int > vect1 , vect2 ; storeInorder ( root1 , vect1 ) ; storeInorder ( root2 , vect2 ) ; pairSumUtil ( vect1 , vect2 , sum ) ; } int main ( ) { struct Node * root1 = NULL ; root1 = insert ( root1 , 8 ) ; root1 = insert ( root1 , 10 ) ; root1 = insert ( root1 , 3 ) ; root1 = insert ( root1 , 6 ) ; root1 = insert ( root1 , 1 ) ; root1 = insert ( root1 , 5 ) ; root1 = insert ( root1 , 7 ) ; root1 = insert ( root1 , 14 ) ; root1 = insert ( root1 , 13 ) ; struct Node * root2 = NULL ; root2 = insert ( root2 , 5 ) ; root2 = insert ( root2 , 18 ) ; root2 = insert ( root2 , 2 ) ; root2 = insert ( root2 , 1 ) ; root2 = insert ( root2 , 3 ) ; root2 = insert ( root2 , 4 ) ; int sum = 10 ; pairSum ( root1 , root2 , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; struct Node * newnode ( int key ) { struct Node * node = new ( struct Node ) ; node -> key = key ; node -> left = node -> right = NULL ; return ( node ) ; } void maxDiffUtil ( struct Node * ptr , int k , int & min_diff , int & min_diff_key ) { if ( ptr == NULL ) return ; if ( ptr -> key == k ) { min_diff_key = k ; return ; } if ( min_diff > abs ( ptr -> key - k ) ) { min_diff = abs ( ptr -> key - k ) ; min_diff_key = ptr -> key ; } if ( k < ptr -> key ) maxDiffUtil ( ptr -> left , k , min_diff , min_diff_key ) ; else maxDiffUtil ( ptr -> right , k , min_diff , min_diff_key ) ; } int maxDiff ( Node * root , int k ) { int min_diff = INT_MAX , min_diff_key = -1 ; maxDiffUtil ( root , k , min_diff , min_diff_key ) ; return min_diff_key ; } int main ( ) { struct Node * root = newnode ( 9 ) ; root -> left = newnode ( 4 ) ; root -> right = newnode ( 17 ) ; root -> left -> left = newnode ( 3 ) ; root -> left -> right = newnode ( 6 ) ; root -> left -> right -> left = newnode ( 5 ) ; root -> left -> right -> right = newnode ( 7 ) ; root -> right -> right = newnode ( 22 ) ; root -> right -> right -> left = newnode ( 20 ) ; int k = 18 ; cout << maxDiff ( root , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = ( Node * ) malloc ( sizeof ( Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } Node * insertLevelOrder ( int arr [ ] , Node * root , int i , int n ) { if ( i < n ) { Node * temp = newNode ( arr [ i ] ) ; root = temp ; root -> left = insertLevelOrder ( arr , root -> left , 2 * i + 1 , n ) ; root -> right = insertLevelOrder ( arr , root -> right , 2 * i + 2 , n ) ; } return root ; } void inOrder ( Node * root ) { if ( root != NULL ) { inOrder ( root -> left ) ; cout << root -> data << " ▁ " ; inOrder ( root -> right ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 6 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Node * root = insertLevelOrder ( arr , root , 0 , n ) ; inOrder ( root ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int info ; bool lthread ; bool rthread ; } ; struct Node * insert ( struct Node * root , int ikey ) { Node * ptr = root ; Node * par = NULL ; while ( ptr != NULL ) { if ( ikey == ( ptr -> info ) ) { printf ( " Duplicate ▁ Key ▁ ! STRNEWLINE " ) ; return root ; } par = ptr ; if ( ikey < ptr -> info ) { if ( ptr -> lthread == false ) ptr = ptr -> left ; else break ; } else { if ( ptr -> rthread == false ) ptr = ptr -> right ; else break ; } } Node * tmp = new Node ; tmp -> info = ikey ; tmp -> lthread = true ; tmp -> rthread = true ; if ( par == NULL ) { root = tmp ; tmp -> left = NULL ; tmp -> right = NULL ; } else if ( ikey < ( par -> info ) ) { tmp -> left = par -> left ; tmp -> right = par ; par -> lthread = false ; par -> left = tmp ; } else { tmp -> left = par ; tmp -> right = par -> right ; par -> rthread = false ; par -> right = tmp ; } return root ; } struct Node * inorderSuccessor ( struct Node * ptr ) { if ( ptr -> rthread == true ) return ptr -> right ; ptr = ptr -> right ; while ( ptr -> lthread == false ) ptr = ptr -> left ; return ptr ; } void inorder ( struct Node * root ) { if ( root == NULL ) printf ( " Tree ▁ is ▁ empty " ) ; struct Node * ptr = root ; while ( ptr -> lthread == false ) ptr = ptr -> left ; while ( ptr != NULL ) { printf ( " % d ▁ " , ptr -> info ) ; ptr = inorderSuccessor ( ptr ) ; } } int main ( ) { struct Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; inorder ( root ) ; return 0 ; }
struct Node { struct Node * left , * right ; int info ; bool lthread ; bool rthread ; } ;
struct Node * caseA ( struct Node * root , struct Node * par , struct Node * ptr ) { if ( par == NULL ) root = NULL ; else if ( ptr == par -> left ) { par -> lthread = true ; par -> left = ptr -> left ; } else { par -> rthread = true ; par -> right = ptr -> right ; } free ( ptr ) ; return root ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; node * newNode ( int data ) { node * temp = new node ( ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } node * constructTreeUtil ( int pre [ ] , int post [ ] , int * preIndex , int l , int h , int size ) { if ( * preIndex >= size l > h ) return NULL ; node * root = newNode ( pre [ * preIndex ] ) ; ++ * preIndex ; if ( l == h ) return root ; int i ; for ( i = l ; i <= h ; ++ i ) if ( pre [ * preIndex ] == post [ i ] ) break ; if ( i <= h ) { root -> left = constructTreeUtil ( pre , post , preIndex , l , i , size ) ; root -> right = constructTreeUtil ( pre , post , preIndex , i + 1 , h , size ) ; } return root ; } node * constructTree ( int pre [ ] , int post [ ] , int size ) { int preIndex = 0 ; return constructTreeUtil ( pre , post , & preIndex , 0 , size - 1 , size ) ; } void printInorder ( node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; cout << node -> data << " ▁ " ; printInorder ( node -> right ) ; } int main ( ) { int pre [ ] = { 1 , 2 , 4 , 8 , 9 , 5 , 3 , 6 , 7 } ; int post [ ] = { 8 , 9 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int size = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; node * root = constructTree ( pre , post , size ) ; cout << " Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree : ▁ STRNEWLINE " ; printInorder ( root ) ; return 0 ; }
struct Node * caseB ( struct Node * root , struct Node * par , struct Node * ptr ) { struct Node * child ; if ( ptr -> lthread == false ) child = ptr -> left ; else child = ptr -> right ; if ( par == NULL ) root = child ; else if ( ptr == par -> left ) par -> left = child ; else par -> right = child ; Node * s = inSucc ( ptr ) ; Node * p = inPred ( ptr ) ; if ( ptr -> lthread == false ) p -> right = s ; else { if ( ptr -> rthread == false ) s -> left = p ; } free ( ptr ) ; return root ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int info ; bool lthread ; bool rthread ; } ; struct Node * insert ( struct Node * root , int ikey ) { Node * ptr = root ; Node * par = NULL ; while ( ptr != NULL ) { if ( ikey == ( ptr -> info ) ) { printf ( " Duplicate ▁ Key ▁ ! STRNEWLINE " ) ; return root ; } par = ptr ; if ( ikey < ptr -> info ) { if ( ptr -> lthread == false ) ptr = ptr -> left ; else break ; } else { if ( ptr -> rthread == false ) ptr = ptr -> right ; else break ; } } Node * tmp = new Node ; tmp -> info = ikey ; tmp -> lthread = true ; tmp -> rthread = true ; if ( par == NULL ) { root = tmp ; tmp -> left = NULL ; tmp -> right = NULL ; } else if ( ikey < ( par -> info ) ) { tmp -> left = par -> left ; tmp -> right = par ; par -> lthread = false ; par -> left = tmp ; } else { tmp -> left = par ; tmp -> right = par -> right ; par -> rthread = false ; par -> right = tmp ; } return root ; } struct Node * inSucc ( struct Node * ptr ) { if ( ptr -> rthread == true ) return ptr -> right ; ptr = ptr -> right ; while ( ptr -> lthread == false ) ptr = ptr -> left ; return ptr ; } struct Node * inorderSuccessor ( struct Node * ptr ) { if ( ptr -> rthread == true ) return ptr -> right ; ptr = ptr -> right ; while ( ptr -> lthread == false ) ptr = ptr -> left ; return ptr ; } void inorder ( struct Node * root ) { if ( root == NULL ) printf ( " Tree ▁ is ▁ empty " ) ; struct Node * ptr = root ; while ( ptr -> lthread == false ) ptr = ptr -> left ; while ( ptr != NULL ) { printf ( " % d ▁ " , ptr -> info ) ; ptr = inorderSuccessor ( ptr ) ; } } struct Node * inPred ( struct Node * ptr ) { if ( ptr -> lthread == true ) return ptr -> left ; ptr = ptr -> left ; while ( ptr -> rthread == false ) ptr = ptr -> right ; return ptr ; } struct Node * caseA ( struct Node * root , struct Node * par , struct Node * ptr ) { if ( par == NULL ) root = NULL ; else if ( ptr == par -> left ) { par -> lthread = true ; par -> left = ptr -> left ; } else { par -> rthread = true ; par -> right = ptr -> right ; } free ( ptr ) ; return root ; } struct Node * caseB ( struct Node * root , struct Node * par , struct Node * ptr ) { struct Node * child ; if ( ptr -> lthread == false ) child = ptr -> left ; else child = ptr -> right ; if ( par == NULL ) root = child ; else if ( ptr == par -> left ) par -> left = child ; else par -> right = child ; Node * s = inSucc ( ptr ) ; Node * p = inPred ( ptr ) ; if ( ptr -> lthread == false ) p -> right = s ; else { if ( ptr -> rthread == false ) s -> left = p ; } free ( ptr ) ; return root ; } struct Node * caseC ( struct Node * root , struct Node * par , struct Node * ptr ) { struct Node * parsucc = ptr ; struct Node * succ = ptr -> right ; while ( succ -> lthread == false ) { parsucc = succ ; succ = succ -> left ; } ptr -> info = succ -> info ; if ( succ -> lthread == true && succ -> rthread == true ) root = caseA ( root , parsucc , succ ) ; else root = caseB ( root , parsucc , succ ) ; return root ; } struct Node * delThreadedBST ( struct Node * root , int dkey ) { struct Node * par = NULL , * ptr = root ; int found = 0 ; while ( ptr != NULL ) { if ( dkey == ptr -> info ) { found = 1 ; break ; } par = ptr ; if ( dkey < ptr -> info ) { if ( ptr -> lthread == false ) ptr = ptr -> left ; else break ; } else { if ( ptr -> rthread == false ) ptr = ptr -> right ; else break ; } } if ( found == 0 ) printf ( " dkey ▁ not ▁ present ▁ in ▁ tree STRNEWLINE " ) ; else if ( ptr -> lthread == false && ptr -> rthread == false ) root = caseC ( root , par , ptr ) ; else if ( ptr -> lthread == false ) root = caseB ( root , par , ptr ) ; else if ( ptr -> rthread == false ) root = caseB ( root , par , ptr ) ; else root = caseA ( root , par , ptr ) ; return root ; } int main ( ) { struct Node * root = NULL ; root = insert ( root , 20 ) ; root = insert ( root , 10 ) ; root = insert ( root , 30 ) ; root = insert ( root , 5 ) ; root = insert ( root , 16 ) ; root = insert ( root , 14 ) ; root = insert ( root , 17 ) ; root = insert ( root , 13 ) ; root = delThreadedBST ( root , 20 ) ; inorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; bool isThreaded ; } ; Node * createThreaded ( Node * root ) { if ( root == NULL ) return NULL ; if ( root -> left == NULL && root -> right == NULL ) return root ; if ( root -> left != NULL ) { Node * l = createThreaded ( root -> left ) ; l -> right = root ; l -> isThreaded = true ; } if ( root -> right == NULL ) return root ; return createThreaded ( root -> right ) ; } Node * leftMost ( Node * root ) { while ( root != NULL && root -> left != NULL ) root = root -> left ; return root ; } void inOrder ( Node * root ) { if ( root == NULL ) return ; Node * cur = leftMost ( root ) ; while ( cur != NULL ) { cout << cur -> key << " ▁ " ; if ( cur -> isThreaded ) cur = cur -> right ; else cur = leftMost ( cur -> right ) ; } } Node * newNode ( int key ) { Node * temp = new Node ; temp -> left = temp -> right = NULL ; temp -> key = key ; return temp ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; createThreaded ( root ) ; cout << " Inorder ▁ traversal ▁ of ▁ created ▁ " " threaded ▁ tree ▁ is STRNEWLINE " ; inOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { Node * left , * right , * parent ; int key ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> parent = temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) { node -> left = insert ( node -> left , key ) ; node -> left -> parent = node ; } else if ( key > node -> key ) { node -> right = insert ( node -> right , key ) ; node -> right -> parent = node ; } return node ; } void inorder ( Node * root ) { bool leftdone = false ; while ( root ) { if ( ! leftdone ) { while ( root -> left ) root = root -> left ; } printf ( " % d ▁ " , root -> key ) ; leftdone = true ; if ( root -> right ) { leftdone = false ; root = root -> right ; } else if ( root -> parent ) { while ( root -> parent && root == root -> parent -> right ) root = root -> parent ; if ( ! root -> parent ) break ; root = root -> parent ; } else break ; } } int main ( void ) { Node * root = NULL ; root = insert ( root , 24 ) ; root = insert ( root , 27 ) ; root = insert ( root , 29 ) ; root = insert ( root , 34 ) ; root = insert ( root , 14 ) ; root = insert ( root , 4 ) ; root = insert ( root , 10 ) ; root = insert ( root , 22 ) ; root = insert ( root , 13 ) ; root = insert ( root , 3 ) ; root = insert ( root , 2 ) ; root = insert ( root , 6 ) ; printf ( " Inorder ▁ traversal ▁ is ▁ STRNEWLINE " ) ; inorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int key ; node * left ; node * right ; } ; node * newNode ( int key ) { node * Node = new node ( ) ; Node -> key = key ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int Ceil ( node * root , int input ) { if ( root == NULL ) return -1 ; if ( root -> key == input ) return root -> key ; if ( root -> key < input ) return Ceil ( root -> right , input ) ; int ceil = Ceil ( root -> left , input ) ; return ( ceil >= input ) ? ceil : root -> key ; } int main ( ) { node * root = newNode ( 8 ) ; root -> left = newNode ( 4 ) ; root -> right = newNode ( 12 ) ; root -> left -> left = newNode ( 2 ) ; root -> left -> right = newNode ( 6 ) ; root -> right -> left = newNode ( 10 ) ; root -> right -> right = newNode ( 14 ) ; for ( int i = 0 ; i < 16 ; i ++ ) cout << i << " ▁ " << Ceil ( root , i ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void printInorder ( Node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( " % d ▁ " , node -> data ) ; printInorder ( node -> right ) ; } Node * constructBinaryTreeUtil ( int pre [ ] , int preM [ ] , int & preIndex , int l , int h , int size ) { if ( preIndex >= size l > h ) return NULL ; Node * root = newNode ( pre [ preIndex ] ) ; ++ ( preIndex ) ; if ( l == h ) return root ; int i ; for ( i = l ; i <= h ; ++ i ) if ( pre [ preIndex ] == preM [ i ] ) break ; if ( i <= h ) { root -> left = constructBinaryTreeUtil ( pre , preM , preIndex , i , h , size ) ; root -> right = constructBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) ; } return root ; } void constructBinaryTree ( Node * root , int pre [ ] , int preMirror [ ] , int size ) { int preIndex = 0 ; int preMIndex = 0 ; root = constructBinaryTreeUtil ( pre , preMirror , preIndex , 0 , size - 1 , size ) ; printInorder ( root ) ; } int main ( ) { int preOrder [ ] = { 1 , 2 , 4 , 5 , 3 , 6 , 7 } ; int preOrderMirror [ ] = { 1 , 3 , 7 , 6 , 2 , 5 , 4 } ; int size = sizeof ( preOrder ) / sizeof ( preOrder [ 0 ] ) ; Node * root = new Node ; constructBinaryTree ( root , preOrder , preOrderMirror , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; Node ( int value ) { data = value ; left = right = NULL ; } } ; void floorCeilBSTHelper ( Node * root , int key , int & floor , int & ceil ) { while ( root ) { if ( root -> data == key ) { ceil = root -> data ; floor = root -> data ; return ; } if ( key > root -> data ) { floor = root -> data ; root = root -> right ; } else { ceil = root -> data ; root = root -> left ; } } return ; } void floorCeilBST ( Node * root , int key ) { int floor = -1 , ceil = -1 ; floorCeilBSTHelper ( root , key , floor , ceil ) ; cout << key << ' ▁ ' << floor << ' ▁ ' << ceil << ' ' ; } int main ( ) { Node * root = new Node ( 8 ) ; root -> left = new Node ( 4 ) ; root -> right = new Node ( 12 ) ; root -> left -> left = new Node ( 2 ) ; root -> left -> right = new Node ( 6 ) ; root -> right -> left = new Node ( 10 ) ; root -> right -> right = new Node ( 14 ) ; for ( int i = 0 ; i < 16 ; i ++ ) floorCeilBST ( root , i ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int key ; int count ; struct node * left , * right ; } ; struct node * newNode ( int item ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> key = item ; temp -> left = temp -> right = NULL ; temp -> count = 1 ; return temp ; } void inorder ( struct node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << root -> key << " ( " << root -> count << " ) ▁ " ; inorder ( root -> right ) ; } } struct node * insert ( struct node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key == node -> key ) { ( node -> count ) ++ ; return node ; } if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ; return node ; } struct node * minValueNode ( struct node * node ) { struct node * current = node ; while ( current -> left != NULL ) current = current -> left ; return current ; } struct node * deleteNode ( struct node * root , int key ) { if ( root == NULL ) return root ; if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ; else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ; else { if ( root -> count > 1 ) { ( root -> count ) -- ; return root ; } if ( root -> left == NULL ) { struct node * temp = root -> right ; free ( root ) ; return temp ; } else if ( root -> right == NULL ) { struct node * temp = root -> left ; free ( root ) ; return temp ; } struct node * temp = minValueNode ( root -> right ) ; root -> key = temp -> key ; root -> right = deleteNode ( root -> right , temp -> key ) ; } return root ; } int main ( ) { struct node * root = NULL ; root = insert ( root , 12 ) ; root = insert ( root , 10 ) ; root = insert ( root , 20 ) ; root = insert ( root , 9 ) ; root = insert ( root , 11 ) ; root = insert ( root , 10 ) ; root = insert ( root , 12 ) ; root = insert ( root , 12 ) ; cout << " Inorder ▁ traversal ▁ of ▁ the ▁ given ▁ tree ▁ " << endl ; inorder ( root ) ; cout << " Delete 20 " root = deleteNode ( root , 20 ) ; cout << " Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE " ; inorder ( root ) ; cout << " Delete 12 " root = deleteNode ( root , 12 ) ; cout << " Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE " ; inorder ( root ) ; cout << " Delete 9 " root = deleteNode ( root , 9 ) ; cout << " Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ STRNEWLINE " ; inorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int key ; node * left , * right ; } ; node * newNode ( int item ) { node * temp = new node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } void inorder ( node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << root -> key << " ▁ " ; inorder ( root -> right ) ; } } node * insert ( node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else node -> right = insert ( node -> right , key ) ; return node ; } node * minValueNode ( node * Node ) { node * current = Node ; while ( current -> left != NULL ) current = current -> left ; return current ; } node * deleteNode ( node * root , int key ) { if ( root == NULL ) return root ; if ( key < root -> key ) root -> left = deleteNode ( root -> left , key ) ; else if ( key > root -> key ) root -> right = deleteNode ( root -> right , key ) ; else { if ( root -> left == NULL ) { node * temp = root -> right ; free ( root ) ; return temp ; } else if ( root -> right == NULL ) { node * temp = root -> left ; free ( root ) ; return temp ; } node * temp = minValueNode ( root -> right ) ; root -> key = temp -> key ; root -> right = deleteNode ( root -> right , temp -> key ) ; } return root ; } node * changeKey ( node * root , int oldVal , int newVal ) { root = deleteNode ( root , oldVal ) ; root = insert ( root , newVal ) ; return root ; } int main ( ) { node * root = NULL ; root = insert ( root , 50 ) ; root = insert ( root , 30 ) ; root = insert ( root , 20 ) ; root = insert ( root , 40 ) ; root = insert ( root , 70 ) ; root = insert ( root , 60 ) ; root = insert ( root , 80 ) ; cout << " Inorder ▁ traversal ▁ of ▁ the ▁ given ▁ tree ▁ STRNEWLINE " ; inorder ( root ) ; root = changeKey ( root , 40 , 10 ) ; cout << " Inorder traversal of the modified tree " ; inorder ( root ) ; return 0 ; }
#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int ele ) { Node * temp = new Node ; temp -> key = ele ; temp -> left = temp -> right = NULL ; return temp ; } void printCommon ( Node * root1 , Node * root2 ) { stack < Node * > stack1 , s1 , s2 ; while ( 1 ) { if ( root1 ) { s1 . push ( root1 ) ; root1 = root1 -> left ; } else if ( root2 ) { s2 . push ( root2 ) ; root2 = root2 -> left ; } else if ( ! s1 . empty ( ) && ! s2 . empty ( ) ) { root1 = s1 . top ( ) ; root2 = s2 . top ( ) ; if ( root1 -> key == root2 -> key ) { cout << root1 -> key << " ▁ " ; s1 . pop ( ) ; s2 . pop ( ) ; root1 = root1 -> right ; root2 = root2 -> right ; } else if ( root1 -> key < root2 -> key ) { s1 . pop ( ) ; root1 = root1 -> right ; root2 = NULL ; } else if ( root1 -> key > root2 -> key ) { s2 . pop ( ) ; root2 = root2 -> right ; root1 = NULL ; } } else break ; } } void inorder ( struct Node * root ) { if ( root ) { inorder ( root -> left ) ; cout << root -> key << " ▁ " ; inorder ( root -> right ) ; } } struct Node * insert ( struct Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } int main ( ) { Node * root1 = NULL ; root1 = insert ( root1 , 5 ) ; root1 = insert ( root1 , 1 ) ; root1 = insert ( root1 , 10 ) ; root1 = insert ( root1 , 0 ) ; root1 = insert ( root1 , 4 ) ; root1 = insert ( root1 , 7 ) ; root1 = insert ( root1 , 9 ) ; Node * root2 = NULL ; root2 = insert ( root2 , 10 ) ; root2 = insert ( root2 , 7 ) ; root2 = insert ( root2 , 20 ) ; root2 = insert ( root2 , 4 ) ; root2 = insert ( root2 , 9 ) ; cout << " Tree ▁ 1 ▁ : ▁ " ; inorder ( root1 ) ; cout << endl ; cout << " Tree ▁ 2 ▁ : ▁ " ; inorder ( root2 ) ; cout << " Common Nodes : " printCommon ( root1 , root2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int inorder [ ] , int l , int r , int d ) { int mid = ( l + r ) >> 1 ; if ( inorder [ mid ] == d ) return mid ; else if ( inorder [ mid ] > d ) return binarySearch ( inorder , l , mid - 1 , d ) ; else return binarySearch ( inorder , mid + 1 , r , d ) ; } int ind = 0 ; void leafNodesRec ( int preorder [ ] , int inorder [ ] , int l , int r , int * ind , int n ) { if ( l == r ) { printf ( " % d ▁ " , inorder [ l ] ) ; * ind = * ind + 1 ; return ; } if ( l < 0 l > r r >= n ) return ; int loc = binarySearch ( inorder , l , r , preorder [ * ind ] ) ; * ind = * ind + 1 ; leafNodesRec ( preorder , inorder , l , loc - 1 , ind , n ) ; leafNodesRec ( preorder , inorder , loc + 1 , r , ind , n ) ; } void leafNodes ( int preorder [ ] , int n ) { int inorder [ n ] ; for ( int i = 0 ; i < n ; i ++ ) inorder [ i ] = preorder [ i ] ; sort ( inorder , inorder + n ) ; leafNodesRec ( preorder , inorder , 0 , n - 1 , & ind , n ) ; } int main ( ) { int preorder [ ] = { 890 , 325 , 290 , 530 , 965 } ; int n = sizeof ( preorder ) / sizeof ( preorder [ 0 ] ) ; leafNodes ( preorder , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void leafNode ( int preorder [ ] , int n ) { stack < int > s ; for ( int i = 0 , j = 1 ; j < n ; i ++ , j ++ ) { bool found = false ; if ( preorder [ i ] > preorder [ j ] ) s . push ( preorder [ i ] ) ; else { while ( ! s . empty ( ) ) { if ( preorder [ j ] > s . top ( ) ) { s . pop ( ) ; found = true ; } else break ; } } if ( found ) cout << preorder [ i ] << " ▁ " ; } cout << preorder [ n - 1 ] ; } int main ( ) { int preorder [ ] = { 890 , 325 , 290 , 530 , 965 } ; int n = sizeof ( preorder ) / sizeof ( preorder [ 0 ] ) ; leafNode ( preorder , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int key ; struct Node * left , * right , * parent ; } ; struct Node * newNode ( int item ) { struct Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; temp -> parent = NULL ; return temp ; } void inorder ( struct Node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; printf ( " Node ▁ : ▁ % d , ▁ " , root -> key ) ; if ( root -> parent == NULL ) printf ( " Parent ▁ : ▁ NULL ▁ STRNEWLINE " ) ; else printf ( " Parent ▁ : ▁ % d ▁ STRNEWLINE " , root -> parent -> key ) ; inorder ( root -> right ) ; } } struct Node * insert ( struct Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) { Node * lchild = insert ( node -> left , key ) ; node -> left = lchild ; lchild -> parent = node ; } else if ( key > node -> key ) { Node * rchild = insert ( node -> right , key ) ; node -> right = rchild ; rchild -> parent = node ; } return node ; } int main ( ) { struct Node * root = NULL ; root = insert ( root , 50 ) ; insert ( root , 30 ) ; insert ( root , 20 ) ; insert ( root , 40 ) ; insert ( root , 70 ) ; insert ( root , 60 ) ; insert ( root , 80 ) ; inorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newNode ( int data ) { struct node * temp = new struct node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } struct node * constructTreeUtil ( int pre [ ] , char preLN [ ] , int * index_ptr , int n ) { int index = * index_ptr ; if ( index == n ) return NULL ; struct node * temp = newNode ( pre [ index ] ) ; ( * index_ptr ) ++ ; if ( preLN [ index ] == ' N ' ) { temp -> left = constructTreeUtil ( pre , preLN , index_ptr , n ) ; temp -> right = constructTreeUtil ( pre , preLN , index_ptr , n ) ; } return temp ; } struct node * constructTree ( int pre [ ] , char preLN [ ] , int n ) { int index = 0 ; return constructTreeUtil ( pre , preLN , & index , n ) ; } void printInorder ( struct node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; printf ( " % d ▁ " , node -> data ) ; printInorder ( node -> right ) ; } int main ( ) { struct node * root = NULL ; int pre [ ] = { 10 , 30 , 20 , 5 , 15 } ; char preLN [ ] = { ' N ' , ' N ' , ' L ' , ' L ' , ' L ' } ; int n = sizeof ( pre ) / sizeof ( pre [ 0 ] ) ; root = constructTree ( pre , preLN , n ) ; printf ( " Following ▁ is ▁ Inorder ▁ Traversal ▁ of ▁ the ▁ Constructed ▁ Binary ▁ Tree : ▁ STRNEWLINE " ) ; printInorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void pairs ( int arr [ ] , int n , int k ) { int smallest = INT_MAX ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } cout << " Minimal ▁ Value ▁ = ▁ " << smallest << " STRNEWLINE " ; cout << " Total ▁ Pairs ▁ = ▁ " << count << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 3 , 5 , 7 , 5 , 1 , 9 , 9 } ; int k = 12 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pairs ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; int leftSize ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; temp -> leftSize = 0 ; return temp ; } Node * insert ( Node * & root , int data ) { if ( ! root ) return newNode ( data ) ; if ( data <= root -> data ) { root -> left = insert ( root -> left , data ) ; root -> leftSize ++ ; } else root -> right = insert ( root -> right , data ) ; return root ; } int getRank ( Node * root , int x ) { if ( root -> data == x ) return root -> leftSize ; if ( x < root -> data ) { if ( ! root -> left ) return -1 ; else return getRank ( root -> left , x ) ; } else { if ( ! root -> right ) return -1 ; else { int rightSize = getRank ( root -> right , x ) ; if ( rightSize == -1 ) return -1 ; return root -> leftSize + 1 + rightSize ; } } } int main ( ) { int arr [ ] = { 5 , 1 , 4 , 4 , 5 , 9 , 7 , 13 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 4 ; Node * root = NULL ; for ( int i = 0 ; i < n ; i ++ ) root = insert ( root , arr [ i ] ) ; cout << " Rank ▁ of ▁ " << x << " ▁ in ▁ stream ▁ is : ▁ " << getRank ( root , x ) << endl ; x = 13 ; cout << " Rank ▁ of ▁ " << x << " ▁ in ▁ stream ▁ is : ▁ " << getRank ( root , x ) << endl ; x = 8 ; cout << " Rank ▁ of ▁ " << x << " ▁ in ▁ stream ▁ is : ▁ " << getRank ( root , x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int a [ ] = { 5 , 1 , 14 , 4 , 15 , 9 , 7 , 20 , 11 } ; int key = 20 ; int arraySize = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int count = 0 ; for ( int i = 0 ; i < arraySize ; i ++ ) { if ( a [ i ] <= key ) { count += 1 ; } } cout << " Rank ▁ of ▁ " << key << " ▁ in ▁ stream ▁ is : ▁ " << count - 1 << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; int max ( int inorder [ ] , int strt , int end ) ; node * newNode ( int data ) ; node * buildTree ( int inorder [ ] , int start , int end ) { if ( start > end ) return NULL ; int i = max ( inorder , start , end ) ; node * root = newNode ( inorder [ i ] ) ; if ( start == end ) return root ; root -> left = buildTree ( inorder , start , i - 1 ) ; root -> right = buildTree ( inorder , i + 1 , end ) ; return root ; } int max ( int arr [ ] , int strt , int end ) { int i , max = arr [ strt ] , maxind = strt ; for ( i = strt + 1 ; i <= end ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; maxind = i ; } } return maxind ; } node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return Node ; } void printInorder ( node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; cout << node -> data << " ▁ " ; printInorder ( node -> right ) ; } int main ( ) { int inorder [ ] = { 5 , 10 , 40 , 30 , 28 } ; int len = sizeof ( inorder ) / sizeof ( inorder [ 0 ] ) ; node * root = buildTree ( inorder , 0 , len - 1 ) ; cout << " Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree ▁ is ▁ STRNEWLINE " ; printInorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } bool treeContinuous ( struct Node * ptr ) { if ( ptr == NULL ) return true ; if ( ptr -> left == NULL && ptr -> right == NULL ) return true ; if ( ptr -> left == NULL ) return ( abs ( ptr -> data - ptr -> right -> data ) == 1 ) && treeContinuous ( ptr -> right ) ; if ( ptr -> right == NULL ) return ( abs ( ptr -> data - ptr -> left -> data ) == 1 ) && treeContinuous ( ptr -> left ) ; return abs ( ptr -> data - ptr -> left -> data ) == 1 && abs ( ptr -> data - ptr -> right -> data ) == 1 && treeContinuous ( ptr -> left ) && treeContinuous ( ptr -> right ) ; } int main ( ) { struct Node * root = newNode ( 3 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 4 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> right = newNode ( 5 ) ; treeContinuous ( root ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  10 NEW_LINE void sortByRow ( int mat [ ] [ MAX_SIZE ] , int n , bool ascending ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ascending ) sort ( mat [ i ] , mat [ i ] + n ) ; else sort ( mat [ i ] , mat [ i ] + n , greater < int > ( ) ) ; } } void transpose ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) swap ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; } void sortMatRowAndColWise ( int mat [ ] [ MAX_SIZE ] , int n ) { sortByRow ( mat , n , true ) ; transpose ( mat , n ) ; sortByRow ( mat , n , false ) ; transpose ( mat , n ) ; } void printMat ( int mat [ ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int n = 3 ; int mat [ n ] [ MAX_SIZE ] = { { 3 , 2 , 1 } , { 9 , 8 , 7 } , { 6 , 5 , 4 } } ; cout << " Original ▁ Matrix : STRNEWLINE " ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; cout << " Matrix After Sorting : " ; printMat ( mat , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; void middlesum ( int mat [ ] [ MAX ] , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; cout << " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " << row_sum << endl ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; cout << " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " << col_sum ; } int main ( ) { int mat [ ] [ MAX ] = { { 2 , 5 , 7 } , { 3 , 7 , 2 } , { 5 , 6 , 9 } } ; middlesum ( mat , 3 ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <time.h> NEW_LINE #define MAX  10000 NEW_LINE int arr [ MAX ] [ MAX ] = { 0 } ; void rowMajor ( ) { int i , j ; for ( i = 0 ; i < MAX ; i ++ ) { for ( j = 0 ; j < MAX ; j ++ ) { arr [ i ] [ j ] ++ ; } } } void colMajor ( ) { int i , j ; for ( i = 0 ; i < MAX ; i ++ ) { for ( j = 0 ; j < MAX ; j ++ ) { arr [ j ] [ i ] ++ ; } } } int main ( ) { int i , j ; clock_t t = clock ( ) ; rowMajor ( ) ; t = clock ( ) - t ; printf ( " Row ▁ major ▁ access ▁ time ▁ : % f ▁ s STRNEWLINE " , t / ( float ) CLOCKS_PER_SEC ) ; t = clock ( ) ; colMajor ( ) ; t = clock ( ) - t ; printf ( " Column ▁ major ▁ access ▁ time ▁ : % f ▁ s STRNEWLINE " , t / ( float ) CLOCKS_PER_SEC ) ; return 0 ; }
#include <iostream> NEW_LINE #define M  3 NEW_LINE #define N  3 NEW_LINE using namespace std ; void rotateMatrix ( int matrix [ ] [ M ] , int k ) { int temp [ M ] ; k = k % M ; for ( int i = 0 ; i < N ; i ++ ) { for ( int t = 0 ; t < M - k ; t ++ ) temp [ t ] = matrix [ i ] [ t ] ; for ( int j = M - k ; j < M ; j ++ ) matrix [ i ] [ j - M + k ] = matrix [ i ] [ j ] ; for ( int j = k ; j < M ; j ++ ) matrix [ i ] [ j ] = temp [ j - k ] ; } } void displayMatrix ( int matrix [ ] [ M ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) cout << matrix [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int matrix [ N ] [ M ] = { { 12 , 23 , 34 } , { 45 , 56 , 67 } , { 78 , 89 , 91 } } ; int k = 2 ; rotateMatrix ( matrix , k ) ; displayMatrix ( matrix ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ; void multiply ( int mat [ ] [ N ] , int res [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { res [ i ] [ j ] = 0 ; for ( int k = 0 ; k < N ; k ++ ) res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] ; } } } bool InvolutoryMatrix ( int mat [ N ] [ N ] ) { int res [ N ] [ N ] ; multiply ( mat , res ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j && res [ i ] [ j ] != 1 ) return false ; if ( i != j && res [ i ] [ j ] != 0 ) return false ; } } return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 0 , 0 } , { 0 , -1 , 0 } , { 0 , 0 , -1 } } ; if ( InvolutoryMatrix ( mat ) ) cout << " Involutory ▁ Matrix " ; else cout << " Not ▁ Involutory ▁ Matrix " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } void createNode ( int parent [ ] , int i , Node * created [ ] , Node * * root ) { if ( created [ i ] != NULL ) return ; created [ i ] = newNode ( i ) ; if ( parent [ i ] == -1 ) { * root = created [ i ] ; return ; } if ( created [ parent [ i ] ] == NULL ) createNode ( parent , parent [ i ] , created , root ) ; Node * p = created [ parent [ i ] ] ; if ( p -> left == NULL ) p -> left = created [ i ] ; else p -> right = created [ i ] ; } Node * createTree ( int parent [ ] , int n ) { Node * created [ n ] ; for ( int i = 0 ; i < n ; i ++ ) created [ i ] = NULL ; Node * root = NULL ; for ( int i = 0 ; i < n ; i ++ ) createNode ( parent , i , created , & root ) ; return root ; } inline void newLine ( ) { cout << " STRNEWLINE " ; } void inorder ( Node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << root -> key << " ▁ " ; inorder ( root -> right ) ; } } int main ( ) { int parent [ ] = { -1 , 0 , 0 , 1 , 1 , 3 , 5 } ; int n = sizeof parent / sizeof parent [ 0 ] ; Node * root = createTree ( parent , n ) ; cout << " Inorder ▁ Traversal ▁ of ▁ constructed ▁ tree STRNEWLINE " ; inorder ( root ) ; newLine ( ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortRowWise ( int m [ ] [ 4 ] , int r , int c ) { for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int k = 0 ; k < c - j - 1 ; k ++ ) { if ( m [ i ] [ k ] > m [ i ] [ k + 1 ] ) { swap ( m [ i ] [ k ] , m [ i ] [ k + 1 ] ) ; } } } } for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) cout << m [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int m [ ] [ 4 ] = { { 9 , 8 , 7 , 1 } , { 7 , 3 , 0 , 2 } , { 9 , 5 , 3 , 2 } , { 6 , 3 , 1 , 2 } } ; int r = sizeof ( m [ 0 ] ) / sizeof ( m [ 0 ] [ 0 ] ) ; int c = sizeof ( m ) / sizeof ( m [ 0 ] ) ; sortRowWise ( m , r , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  4 NEW_LINE #define N  4 NEW_LINE int sortRowWise ( int m [ M ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) sort ( m [ i ] , m [ i ] + N ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << ( m [ i ] [ j ] ) << " ▁ " ; cout << endl ; } } int main ( ) { int m [ M ] [ N ] = { { 9 , 8 , 7 , 1 } , { 7 , 3 , 0 , 2 } , { 9 , 5 , 3 , 2 } , { 6 , 3 , 1 , 2 } } ; sortRowWise ( m ) ; }
#include <iostream> NEW_LINE using namespace std ; #define n  3 NEW_LINE bool checkMarkov ( double m [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; } int main ( ) { double m [ 3 ] [ 3 ] = { { 0 , 0 , 1 } , { 0.5 , 0 , 0.5 } , { 1 , 0 , 0 } } ; if ( checkMarkov ( m ) ) cout << " ▁ yes ▁ " ; else cout << " ▁ no ▁ " ; }
#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; bool isDiagonalMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 4 , 0 , 0 , 0 } , { 0 , 7 , 0 , 0 } , { 0 , 0 , 5 , 0 } , { 0 , 0 , 0 , 1 } } ; if ( isDiagonalMatrix ( mat ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; bool isScalarMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 2 , 0 , 0 , 0 } , { 0 , 2 , 0 , 0 } , { 0 , 0 , 2 , 0 } , { 0 , 0 , 0 , 2 } } ; if ( isScalarMatrix ( mat ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  10 NEW_LINE void sortByRow ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( mat [ i ] , mat [ i ] + n ) ; } void transpose ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) swap ( mat [ i ] [ j ] , mat [ j ] [ i ] ) ; } void sortMatRowAndColWise ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { sortByRow ( mat , n ) ; transpose ( mat , n ) ; sortByRow ( mat , n ) ; transpose ( mat , n ) ; } void printMat ( int mat [ MAX_SIZE ] [ MAX_SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int mat [ MAX_SIZE ] [ MAX_SIZE ] = { { 4 , 1 , 3 } , { 9 , 6 , 8 } , { 5 , 2 , 7 } } ; int n = 3 ; cout << " Original ▁ Matrix : STRNEWLINE " ; printMat ( mat , n ) ; sortMatRowAndColWise ( mat , n ) ; cout << " Matrix After Sorting : " ; printMat ( mat , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void doublyEven ( int n ) { int arr [ n ] [ n ] , i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * i ) + j + 1 ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n / 4 ; i ++ ) for ( j = 3 * ( n / 4 ) ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 0 ; j < n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 3 * n / 4 ; i < n ; i ++ ) for ( j = 3 * n / 4 ; j < n ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = n / 4 ; i < 3 * n / 4 ; i ++ ) for ( j = n / 4 ; j < 3 * n / 4 ; j ++ ) arr [ i ] [ j ] = ( n * n + 1 ) - arr [ i ] [ j ] ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) cout << arr [ i ] [ j ] << " ▁ " ; cout << " STRNEWLINE " ; } } int main ( ) { int n = 8 ; doublyEven ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ; bool isMagicSquare ( int mat [ ] [ N ] ) { int sum = 0 , sum2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum = sum + mat [ i ] [ i ] ; for ( int i = 0 ; i < N ; i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ; if ( sum != sum2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) rowSum += mat [ i ] [ j ] ; if ( rowSum != sum ) return false ; } for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) colSum += mat [ j ] [ i ] ; if ( sum != colSum ) return false ; } return true ; } int main ( ) { int mat [ ] [ N ] = { { 2 , 7 , 6 } , { 9 , 5 , 1 } , { 4 , 3 , 8 } } ; if ( isMagicSquare ( mat ) ) cout << " Magic ▁ Square " ; else cout << " Not ▁ a ▁ magic ▁ Square " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  10 NEW_LINE int subCount ( int arr [ ] , int n , int k ) { int mod [ k ] ; memset ( mod , 0 , sizeof ( mod ) ) ; int cumSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumSum += arr [ i ] ; mod [ ( ( cumSum % k ) + k ) % k ] ++ ; } int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( mod [ i ] > 1 ) result += ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ; result += mod [ 0 ] ; return result ; } int countSubmatrix ( int mat [ SIZE ] [ SIZE ] , int n , int k ) { int tot_count = 0 ; int left , right , i ; int temp [ n ] ; for ( left = 0 ; left < n ; left ++ ) { memset ( temp , 0 , sizeof ( temp ) ) ; for ( right = left ; right < n ; right ++ ) { for ( i = 0 ; i < n ; ++ i ) temp [ i ] += mat [ i ] [ right ] ; tot_count += subCount ( temp , n , k ) ; } } return tot_count ; } int main ( ) { int mat [ ] [ SIZE ] = { { 5 , -1 , 6 } , { -2 , 3 , 8 } , { 7 , 4 , -9 } } ; int n = 3 , k = 4 ; cout << " Count ▁ = ▁ " << countSubmatrix ( mat , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ZigZag ( int rows , int columns , int numbers [ ] ) { int k = 0 ; int arr [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns and numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } else { for ( int j = columns - 1 ; j >= 0 and numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) cout << arr [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int rows = 4 ; int columns = 5 ; int Numbers [ ] = { 3 , 4 , 2 , 2 , 3 , 1 , 5 } ; ZigZag ( rows , columns , Numbers ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberofPosition ( int n , int k , int x , int y , int obstPosx [ ] , int obstPosy [ ] ) { int d11 , d12 , d21 , d22 , r1 , r2 , c1 , c2 ; d11 = min ( x - 1 , y - 1 ) ; d12 = min ( n - x , n - y ) ; d21 = min ( n - x , y - 1 ) ; d22 = min ( x - 1 , n - y ) ; r1 = y - 1 ; r2 = n - y ; c1 = x - 1 ; c2 = n - x ; for ( int i = 0 ; i < k ; i ++ ) { if ( x > obstPosx [ i ] && y > obstPosy [ i ] && x - obstPosx [ i ] == y - obstPosy [ i ] ) d11 = min ( d11 , x - obstPosx [ i ] - 1 ) ; if ( obstPosx [ i ] > x && obstPosy [ i ] > y && obstPosx [ i ] - x == obstPosy [ i ] - y ) d12 = min ( d12 , obstPosx [ i ] - x - 1 ) ; if ( obstPosx [ i ] > x && y > obstPosy [ i ] && obstPosx [ i ] - x == y - obstPosy [ i ] ) d21 = min ( d21 , obstPosx [ i ] - x - 1 ) ; if ( x > obstPosx [ i ] && obstPosy [ i ] > y && x - obstPosx [ i ] == obstPosy [ i ] - y ) d22 = min ( d22 , x - obstPosx [ i ] - 1 ) ; if ( x == obstPosx [ i ] && obstPosy [ i ] < y ) r1 = min ( r1 , y - obstPosy [ i ] - 1 ) ; if ( x == obstPosx [ i ] && obstPosy [ i ] > y ) r2 = min ( r2 , obstPosy [ i ] - y - 1 ) ; if ( y == obstPosy [ i ] && obstPosx [ i ] < x ) c1 = min ( c1 , x - obstPosx [ i ] - 1 ) ; if ( y == obstPosy [ i ] && obstPosx [ i ] > x ) c2 = min ( c2 , obstPosx [ i ] - x - 1 ) ; } return d11 + d12 + d21 + d22 + r1 + r2 + c1 + c2 ; } int main ( void ) { int n = 8 ; int k = 1 ; int Qposx = 4 ; int Qposy = 4 ; int obstPosx [ ] = { 3 } ; int obstPosy [ ] = { 5 } ; cout << numberofPosition ( n , k , Qposx , Qposy , obstPosx , obstPosy ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 5 ; int FindMaxProduct ( int arr [ ] [ n ] , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ; if ( max < result ) max = result ; } } } return max ; } int main ( ) { int arr [ ] [ 5 ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 1 } , { 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 1 , 0 } , { 9 , 6 , 4 , 2 , 3 } } ; cout << FindMaxProduct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPro ( int a [ 6 ] [ 5 ] , int n , int m , int k ) { int maxi ( 1 ) , mp ( 1 ) ; for ( int i = 0 ; i < n ; ++ i ) { int wp ( 1 ) ; for ( int l = 0 ; l < k ; ++ l ) { wp *= a [ i ] [ l ] ; } mp = wp ; for ( int j = k ; j < m ; ++ j ) { wp = wp * a [ i ] [ j ] / a [ i ] [ j - k ] ; maxi = max ( maxi , max ( mp , wp ) ) ; } } return maxi ; } int main ( ) { int n = 6 , m = 5 , k = 4 ; int a [ 6 ] [ 5 ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 1 } , { 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 1 , 0 } , { 9 , 6 , 4 , 2 , 3 } , { 1 , 1 , 2 , 1 , 1 } } ; cout << maxPro ( a , n , m , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) ; Node * buildUtil ( int in [ ] , int post [ ] , int inStrt , int inEnd , int * pIndex , unordered_map < int , int > & mp ) { if ( inStrt > inEnd ) return NULL ; int curr = post [ * pIndex ] ; Node * node = newNode ( curr ) ; ( * pIndex ) -- ; if ( inStrt == inEnd ) return node ; int iIndex = mp [ curr ] ; node -> right = buildUtil ( in , post , iIndex + 1 , inEnd , pIndex , mp ) ; node -> left = buildUtil ( in , post , inStrt , iIndex - 1 , pIndex , mp ) ; return node ; } struct Node * buildTree ( int in [ ] , int post [ ] , int len ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < len ; i ++ ) mp [ in [ i ] ] = i ; int index = len - 1 ; return buildUtil ( in , post , 0 , len - 1 , & index , mp ) ; } Node * newNode ( int data ) { Node * node = ( Node * ) malloc ( sizeof ( Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void preOrder ( Node * node ) { if ( node == NULL ) return ; printf ( " % d ▁ " , node -> data ) ; preOrder ( node -> left ) ; preOrder ( node -> right ) ; } int main ( ) { int in [ ] = { 4 , 8 , 2 , 5 , 1 , 6 , 3 , 7 } ; int post [ ] = { 8 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int n = sizeof ( in ) / sizeof ( in [ 0 ] ) ; Node * root = buildTree ( in , post , n ) ; cout << " Preorder ▁ of ▁ the ▁ constructed ▁ tree ▁ : ▁ STRNEWLINE " ; preOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ; int minimumflip ( int mat [ ] [ N ] , int n ) { int transpose [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; } int main ( ) { int n = 3 ; int mat [ N ] [ N ] = { { 0 , 0 , 1 } , { 1 , 1 , 1 } , { 1 , 0 , 0 } } ; cout << minimumflip ( mat , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ; int minimumflip ( int mat [ ] [ N ] , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; } int main ( ) { int n = 3 ; int mat [ N ] [ N ] = { { 0 , 0 , 1 } , { 1 , 1 , 1 } , { 1 , 0 , 0 } } ; cout << minimumflip ( mat , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; bool isLowerTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 0 , 0 , 0 } , { 1 , 4 , 0 , 0 } , { 4 , 6 , 2 , 0 } , { 0 , 4 , 7 , 6 } } ; if ( isLowerTriangularMatrix ( mat ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; bool isUpperTriangularMatrix ( int mat [ N ] [ N ] ) { for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != 0 ) return false ; return true ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 3 , 5 , 3 } , { 0 , 4 , 6 , 2 } , { 0 , 0 , 2 , 5 } , { 0 , 0 , 0 , 6 } } ; if ( isUpperTriangularMatrix ( mat ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE void freq ( int ar [ ] [ MAX ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } printf ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = ▁ % d ▁ STRNEWLINE " , odd ) ; printf ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ % d ▁ STRNEWLINE " , even ) ; } int main ( ) { int m = 3 , n = 3 ; int array [ ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; freq ( array , m , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; bool HalfDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; } int main ( ) { int a [ ] [ MAX ] = { { 2 , 9 , 1 , 4 , -2 } , { 6 , 7 , 2 , 11 , 4 } , { 4 , 2 , 9 , 2 , 4 } , { 1 , 9 , 2 , 4 , 4 } , { 0 , 2 , 4 , 2 , 5 } } ; cout << ( HalfDiagonalSums ( a , 5 ) ? " Yes " : " No " ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; bool isIdentity ( int mat [ ] [ MAX ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; } int main ( ) { int N = 4 ; int mat [ ] [ MAX ] = { { 1 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 1 } } ; if ( isIdentity ( mat , N ) ) cout << " Yes ▁ " ; else cout << " No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  100000007 NEW_LINE long long modPower ( long long a , long long t ) { long long now = a , ret = 1 ; while ( t ) { if ( t & 1 ) ret = now * ( ret % mod ) ; now = now * ( now % mod ) ; t >>= 1 ; } return ret ; } long countWays ( int n , int m , int k ) { if ( k == -1 && ( n + m ) % 2 == 1 ) return 0 ; if ( n == 1 m == 1 ) return 1 ; return ( modPower ( modPower ( ( long long ) 2 , n - 1 ) , m - 1 ) % mod ) ; } int main ( ) { int n = 2 , m = 7 , k = 1 ; cout << countWays ( n , m , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; Node ( int x ) { data = x ; left = right = NULL ; } } ; Node * buildTree ( int in [ ] , int post [ ] , int n ) { stack < Node * > st ; set < Node * > s ; int postIndex = n - 1 ; Node * root = NULL ; for ( int p = n - 1 , i = n - 1 ; p >= 0 ; ) { Node * node = NULL ; do { node = new Node ( post [ p ] ) ; if ( root == NULL ) { root = node ; } if ( st . size ( ) > 0 ) { if ( s . find ( st . top ( ) ) != s . end ( ) ) { s . erase ( st . top ( ) ) ; st . top ( ) -> left = node ; st . pop ( ) ; } else { st . top ( ) -> right = node ; } } st . push ( node ) ; } while ( post [ p -- ] != in [ i ] && p >= 0 ) ; node = NULL ; while ( st . size ( ) > 0 && i >= 0 && st . top ( ) -> data == in [ i ] ) { node = st . top ( ) ; st . pop ( ) ; i -- ; } if ( node != NULL ) { s . insert ( node ) ; st . push ( node ) ; } } return root ; } void preOrder ( Node * node ) { if ( node == NULL ) return ; printf ( " % d ▁ " , node -> data ) ; preOrder ( node -> left ) ; preOrder ( node -> right ) ; } int main ( ) { int in [ ] = { 4 , 8 , 2 , 5 , 1 , 6 , 3 , 7 } ; int post [ ] = { 8 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int n = sizeof ( in ) / sizeof ( in [ 0 ] ) ; Node * root = buildTree ( in , post , n ) ; cout << " Preorder ▁ of ▁ the ▁ constructed STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL tree ▁ : ▁ STRNEWLINE " ; preOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void imageSwap ( int mat [ ] [ MAX ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j <= i ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] + mat [ j ] [ i ] - ( mat [ j ] [ i ] = mat [ i ] [ j ] ) ; } void printMatrix ( int mat [ ] [ MAX ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int n = 4 ; imageSwap ( mat , n ) ; printMatrix ( mat , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int m = 3 ; const int n = 2 ; long long countSets ( int a [ n ] [ m ] ) { long long res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < m ; j ++ ) a [ i ] [ j ] ? u ++ : v ++ ; res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { int u = 0 , v = 0 ; for ( int j = 0 ; j < n ; j ++ ) a [ j ] [ i ] ? u ++ : v ++ ; res += pow ( 2 , u ) - 1 + pow ( 2 , v ) - 1 ; } return res - ( n * m ) ; } int main ( ) { int a [ ] [ 3 ] = { ( 1 , 0 , 1 ) , ( 0 , 1 , 0 ) } ; cout << countSets ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( mat [ i ] [ j ] == x ) { cout << " Element ▁ found ▁ at ▁ ( " << i << " , ▁ " << j << " ) STRNEWLINE " ; return 1 ; } } cout << " n ▁ Element ▁ not ▁ found " ; return 0 ; } int main ( ) { int mat [ 4 ] [ 4 ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; search ( mat , 4 , 29 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  5 NEW_LINE #define C  4 NEW_LINE using namespace std ; void diagonalOrder ( int arr [ ] [ C ] , int n , int m ) { vector < vector < int > > ans ( n + m - 1 ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { ans [ i + j ] . push_back ( arr [ j ] [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { for ( int j = 0 ; j < ans [ i ] . size ( ) ; j ++ ) cout << ans [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int n = 5 , m = 4 ; int arr [ ] [ C ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } , { 17 , 18 , 19 , 20 } , } ; diagonalOrder ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  100 NEW_LINE int calculateEnergy ( int mat [ SIZE ] [ SIZE ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i ] [ j ] / n ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += abs ( i_des - i ) + abs ( j_des - j ) ; } } return tot_energy ; } int main ( ) { int mat [ SIZE ] [ SIZE ] = { { 4 , 7 , 0 , 3 } , { 8 , 5 , 6 , 1 } , { 9 , 11 , 10 , 2 } , { 15 , 13 , 14 , 12 } } ; int n = 4 ; cout << " Total ▁ energy ▁ required ▁ = ▁ " << calculateEnergy ( mat , n ) << " ▁ units " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; bool isUnique ( int mat [ ] [ MAX ] , int i , int j , int n , int m ) { int sumrow = 0 ; for ( int k = 0 ; k < m ; k ++ ) { sumrow += mat [ i ] [ k ] ; if ( sumrow > 1 ) return false ; } int sumcol = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sumcol += mat [ k ] [ j ] ; if ( sumcol > 1 ) return false ; } return true ; } int countUnique ( int mat [ ] [ MAX ] , int n , int m ) { int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] && isUnique ( mat , i , j , n , m ) ) uniquecount ++ ; return uniquecount ; } int main ( ) { int mat [ ] [ MAX ] = { { 0 , 1 , 0 , 0 } , { 0 , 0 , 1 , 0 } , { 1 , 0 , 0 , 1 } } ; cout << countUnique ( mat , 3 , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int countUnique ( int mat [ ] [ MAX ] , int n , int m ) { int rowsum [ n ] , colsum [ m ] ; memset ( colsum , 0 , sizeof ( colsum ) ) ; memset ( rowsum , 0 , sizeof ( rowsum ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] ) { rowsum [ i ] ++ ; colsum [ j ] ++ ; } int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] && rowsum [ i ] == 1 && colsum [ j ] == 1 ) uniquecount ++ ; return uniquecount ; } int main ( ) { int mat [ ] [ MAX ] = { { 0 , 1 , 0 , 0 } , { 0 , 0 , 1 , 0 } , { 1 , 0 , 0 , 1 } } ; cout << countUnique ( mat , 3 , 4 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; bool isSparse ( int array [ ] [ MAX ] , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ; return ( counter > ( ( m * n ) / 2 ) ) ; } int main ( ) { int array [ ] [ MAX ] = { { 1 , 0 , 3 } , { 0 , 0 , 4 } , { 6 , 0 , 0 } } ; int m = 3 , n = 3 ; if ( isSparse ( array , m , n ) ) cout << " Yes " ; else cout << " No " ; }
#include <iostream> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int countCommon ( int mat [ ] [ MAX ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; cout << countCommon ( mat , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * child ; } ; Node * newNode ( int data ) { Node * newNode = new Node ; newNode -> next = newNode -> child = NULL ; newNode -> data = data ; return newNode ; } Node * addSibling ( Node * n , int data ) { if ( n == NULL ) return NULL ; while ( n -> next ) n = n -> next ; return ( n -> next = newNode ( data ) ) ; } Node * addChild ( Node * n , int data ) { if ( n == NULL ) return NULL ; if ( n -> child ) return addSibling ( n -> child , data ) ; else return ( n -> child = newNode ( data ) ) ; } void traverseTree ( Node * root ) { if ( root == NULL ) return ; while ( root ) { cout << " ▁ " << root -> data ; if ( root -> child ) traverseTree ( root -> child ) ; root = root -> next ; } } int main ( ) { Node * root = newNode ( 10 ) ; Node * n1 = addChild ( root , 2 ) ; Node * n2 = addChild ( root , 3 ) ; Node * n3 = addChild ( root , 4 ) ; Node * n4 = addChild ( n3 , 6 ) ; Node * n5 = addChild ( root , 5 ) ; Node * n6 = addChild ( n5 , 7 ) ; Node * n7 = addChild ( n5 , 8 ) ; Node * n8 = addChild ( n5 , 9 ) ; traverseTree ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ; void findMax ( int arr [ ] [ N ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } cout << " Row ▁ number ▁ = ▁ " << row + 1 ; cout << " , ▁ MaxCount ▁ = ▁ " << N - 1 - j ; } int main ( ) { int arr [ N ] [ N ] = { 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 } ; findMax ( arr ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; void transpose ( int mat [ ] [ MAX ] , int tr [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) tr [ i ] [ j ] = mat [ j ] [ i ] ; } bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { int tr [ N ] [ MAX ] ; transpose ( mat , tr , N ) ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != tr [ i ] [ j ] ) return false ; return true ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; bool isSymmetric ( int mat [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) return false ; return true ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 3 , 5 } , { 3 , 2 , 4 } , { 5 , 4 , 1 } } ; if ( isSymmetric ( mat , 3 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isAllCellTraversed ( vector < vector < pair < int , int > > > grid , int n , int m ) { bool visited [ n ] [ m ] ; int total = n * m ; int startx = grid [ 0 ] [ 0 ] . first ; int starty = grid [ 0 ] [ 0 ] . second ; for ( int i = 0 ; i < total - 2 ; i ++ ) { if ( grid [ startx ] [ starty ] . first == -1 and grid [ startx ] [ starty ] . second == -1 ) return false ; if ( visited [ startx ] [ starty ] == true ) return false ; visited [ startx ] [ starty ] = true ; int x = grid [ startx ] [ starty ] . first ; int y = grid [ startx ] [ starty ] . second ; startx = x ; starty = y ; } if ( grid [ startx ] [ starty ] . first == -1 and grid [ startx ] [ starty ] . second == -1 ) return true ; return false ; } int main ( ) { vector < vector < pair < int , int > > > cell ( 3 , vector < pair < int , int > > ( 2 ) ) ; cell [ 0 ] [ 0 ] = { 0 , 1 } ; cell [ 0 ] [ 1 ] = { 2 , 0 } ; cell [ 1 ] [ 0 ] = { -1 , -1 } ; cell [ 1 ] [ 1 ] = { 1 , 0 } ; cell [ 2 ] [ 0 ] = { 2 , 1 } ; cell [ 2 ] [ 1 ] = { 1 , 1 } ; if ( ! isAllCellTraversed ( cell , 3 , 2 ) ) cout << " true " ; else cout << " false " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE bool isPalin ( string str ) { int len = str . length ( ) / 2 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != str [ str . length ( ) - i - 1 ] ) return false ; } return true ; } void palindromicPath ( string str , char a [ ] [ N ] , int i , int j , int m , int n ) { if ( j < m - 1 i < n - 1 ) { if ( i < n - 1 ) palindromicPath ( str + a [ i ] [ j ] , a , i + 1 , j , m , n ) ; if ( j < m - 1 ) palindromicPath ( str + a [ i ] [ j ] , a , i , j + 1 , m , n ) ; } else { str = str + a [ n - 1 ] [ m - 1 ] ; if ( isPalin ( str ) ) cout << ( str ) << endl ; } } int main ( ) { char arr [ ] [ N ] = { { ' a ' , ' a ' , ' a ' , ' b ' } , { ' b ' , ' a ' , ' a ' , ' a ' } , { ' a ' , ' b ' , ' b ' , ' a ' } } ; string str = " " ; palindromicPath ( str , arr , 0 , 0 , 4 , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define n  4 NEW_LINE #define m  4 NEW_LINE using namespace std ; int findPossibleMoves ( int mat [ n ] [ m ] , int p , int q ) { int X [ 8 ] = { 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 } ; int Y [ 8 ] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 } ; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; } int main ( ) { int mat [ n ] [ m ] = { { 1 , 0 , 1 , 0 } , { 0 , 1 , 1 , 1 } , { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 1 } } ; int p = 2 , q = 2 ; cout << findPossibleMoves ( mat , p , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void printDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } cout << " Principal ▁ Diagonal : " << principal << endl ; cout << " Secondary ▁ Diagonal : " << secondary << endl ; } int main ( ) { int a [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printDiagonalSums ( a , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void printDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } cout << " Principal ▁ Diagonal : " << principal << endl ; cout << " Secondary ▁ Diagonal : " << secondary << endl ; } int main ( ) { int a [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printDiagonalSums ( a , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * child ; } ; Node * newNode ( int data ) { Node * newNode = new Node ; newNode -> next = newNode -> child = NULL ; newNode -> data = data ; return newNode ; } Node * addSibling ( Node * n , int data ) { if ( n == NULL ) return NULL ; while ( n -> next ) n = n -> next ; return ( n -> next = newNode ( data ) ) ; } Node * addChild ( Node * n , int data ) { if ( n == NULL ) return NULL ; if ( n -> child ) return addSibling ( n -> child , data ) ; else return ( n -> child = newNode ( data ) ) ; } void traverseTree ( Node * root ) { if ( root == NULL ) return ; cout << root -> data << " ▁ " ; if ( root -> child == NULL ) return ; queue < Node * > q ; Node * curr = root -> child ; q . push ( curr ) ; while ( ! q . empty ( ) ) { curr = q . front ( ) ; q . pop ( ) ; while ( curr != NULL ) { cout << curr -> data << " ▁ " ; if ( curr -> child != NULL ) { q . push ( curr -> child ) ; } curr = curr -> next ; } } } int main ( ) { Node * root = newNode ( 10 ) ; Node * n1 = addChild ( root , 2 ) ; Node * n2 = addChild ( root , 3 ) ; Node * n3 = addChild ( root , 4 ) ; Node * n4 = addChild ( n3 , 6 ) ; Node * n5 = addChild ( root , 5 ) ; Node * n6 = addChild ( n5 , 7 ) ; Node * n7 = addChild ( n5 , 8 ) ; Node * n8 = addChild ( n5 , 9 ) ; traverseTree ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void printBoundary ( int a [ ] [ MAX ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 j == 0 i == n - 1 j == n - 1 ) cout << a [ i ] [ j ] << " ▁ " ; else cout << " ▁ " << " ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int a [ 4 ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printBoundary ( a , 4 , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int getBoundarySum ( int a [ ] [ MAX ] , int m , int n ) { long long int sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; } int main ( ) { int a [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; long long int sum = getBoundarySum ( a , 4 , 4 ) ; cout << " Sum ▁ of ▁ boundary ▁ elements ▁ is ▁ " << sum ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; void printSpiral ( int mat [ ] [ MAX ] , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) cout << mat [ low_row ] [ i ] << " ▁ " ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) cout << mat [ i ] [ high_column ] << " ▁ " ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) cout << mat [ high_row ] [ i ] << " ▁ " ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) cout << mat [ i ] [ low_column ] << " ▁ " ; low_column -= 1 ; } cout << endl ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int r = 3 , c = 3 ; printSpiral ( mat , r , c ) ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return abs ( d1 - d2 ) ; } int main ( ) { int n = 3 ; int arr [ ] [ MAX ] = { { 11 , 2 , 4 } , { 4 , 5 , 6 } , { 10 , 8 , -12 } } ; cout << difference ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int difference ( int arr [ ] [ MAX ] , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return abs ( d1 - d2 ) ; } int main ( ) { int n = 3 ; int arr [ ] [ MAX ] = { { 11 , 2 , 4 } , { 4 , 5 , 6 } , { 10 , 8 , -12 } } ; cout << difference ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void spiralFill ( int m , int n , int a [ ] [ MAX ] ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) a [ k ] [ i ] = val ++ ; k ++ ; for ( int i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = val ++ ; n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = val ++ ; m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = val ++ ; l ++ ; } } } int main ( ) { int m = 4 , n = 4 ; int a [ MAX ] [ MAX ] ; spiralFill ( m , n , a ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << a [ i ] [ j ] << " ▁ " ; cout << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTreeEdges ( int prufer [ ] , int m ) { int vertices = m + 2 ; int vertex_set [ vertices ] ; for ( int i = 0 ; i < vertices ; i ++ ) vertex_set [ i ] = 0 ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) vertex_set [ prufer [ i ] - 1 ] += 1 ; cout << " The edge set E ( G ) is : " int j = 0 ; for ( int i = 0 ; i < vertices - 2 ; i ++ ) { for ( j = 0 ; j < vertices ; j ++ ) { if ( vertex_set [ j ] == 0 ) { vertex_set [ j ] = -1 ; cout << " ( " << ( j + 1 ) << " , ▁ " << prufer [ i ] << " ) ▁ " ; vertex_set [ prufer [ i ] - 1 ] -- ; break ; } } } j = 0 ; for ( int i = 0 ; i < vertices ; i ++ ) { if ( vertex_set [ i ] == 0 && j == 0 ) { cout << " ( " << ( i + 1 ) << " , ▁ " ; j ++ ; } else if ( vertex_set [ i ] == 0 && j == 1 ) cout << ( i + 1 ) << " ) STRNEWLINE " ; } } int main ( ) { int prufer [ ] = { 4 , 1 , 3 , 4 } ; int n = sizeof ( prufer ) / sizeof ( prufer [ 0 ] ) ; printTreeEdges ( prufer , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE void maxMin ( int arr [ ] [ MAX ] , int n ) { int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } cout << " Maximum ▁ = ▁ " << max << " , ▁ Minimum ▁ = ▁ " << min ; } int main ( ) { int arr [ MAX ] [ MAX ] = { 5 , 9 , 11 , 25 , 0 , 14 , 21 , 6 , 4 } ; maxMin ( arr , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  4 NEW_LINE #define C  5 NEW_LINE void antiSpiralTraversal ( int m , int n , int a [ R ] [ C ] ) { int i , k = 0 , l = 0 ; stack < int > stk ; while ( k <= m && l <= n ) { for ( i = l ; i <= n ; ++ i ) stk . push ( a [ k ] [ i ] ) ; k ++ ; for ( i = k ; i <= m ; ++ i ) stk . push ( a [ i ] [ n ] ) ; n -- ; if ( k <= m ) { for ( i = n ; i >= l ; -- i ) stk . push ( a [ m ] [ i ] ) ; m -- ; } if ( l <= n ) { for ( i = m ; i >= k ; -- i ) stk . push ( a [ i ] [ l ] ) ; l ++ ; } } while ( ! stk . empty ( ) ) { cout << stk . top ( ) << " ▁ " ; stk . pop ( ) ; } } int main ( ) { int mat [ R ] [ C ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 10 } , { 11 , 12 , 13 , 14 , 15 } , { 16 , 17 , 18 , 19 , 20 } } ; antiSpiralTraversal ( R - 1 , C - 1 , mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int findNormal ( int mat [ ] [ MAX ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] * mat [ i ] [ j ] ; return sqrt ( sum ) ; } int findTrace ( int mat [ ] [ MAX ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += mat [ i ] [ i ] ; return sum ; } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; cout << " Trace ▁ of ▁ Matrix ▁ = ▁ " << findTrace ( mat , 5 ) << endl ; cout << " Normal ▁ of ▁ Matrix ▁ = ▁ " << findNormal ( mat , 5 ) << endl ; return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE #define ROW  3 NEW_LINE #define COL  3 NEW_LINE void transpose ( int transpose_matrix [ ROW ] [ COL ] , int matrix [ ROW ] [ COL ] ) { for ( int i = 0 ; i < ROW ; i ++ ) for ( int j = 0 ; j < COL ; j ++ ) transpose_matrix [ j ] [ i ] = matrix [ i ] [ j ] ; } bool check ( int transpose_matrix [ ROW ] [ COL ] , int matrix [ ROW ] [ COL ] ) { for ( int i = 0 ; i < ROW ; i ++ ) for ( int j = 0 ; j < COL ; j ++ ) if ( matrix [ i ] [ j ] != - transpose_matrix [ i ] [ j ] ) return false ; return true ; } void printMatrix ( int matrix [ ROW ] [ COL ] ) { for ( int i = 0 ; i < ROW ; i ++ ) { for ( int j = 0 ; j < COL ; j ++ ) printf ( " % d ▁ " , matrix [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } } int main ( ) { int matrix [ ROW ] [ COL ] = { { 0 , 5 , -4 } , { -5 , 0 , 1 } , { 4 , -1 , 0 } , } ; int transpose_matrix [ ROW ] [ COL ] ; transpose ( transpose_matrix , matrix ) ; printf ( " Transpose ▁ matrix : ▁ STRNEWLINE " ) ; printMatrix ( transpose_matrix ) ; if ( check ( transpose_matrix , matrix ) ) printf ( " Skew ▁ Symmetric ▁ Matrix " ) ; else printf ( " Not ▁ Skew ▁ Symmetric ▁ Matrix " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; } int main ( ) { int N = 2 ; cout << findSum ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ; int countOps ( int A [ ] [ MAX ] , int B [ ] [ MAX ] , int m , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j < m ; j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return -1 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += abs ( A [ i ] [ 0 ] ) ; for ( int j = 0 ; j < m ; j ++ ) result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; return ( result ) ; } int main ( ) { int A [ MAX ] [ MAX ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int B [ MAX ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; cout << countOps ( A , B , 3 , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; vector < Node * > child ; } ; Node * newNode ( int value ) { Node * nNode = new Node ; nNode -> key = value ; return nNode ; } Node * BuildKaryTree ( int A [ ] , int n , int k , int h , int & ind ) { if ( n <= 0 ) return NULL ; Node * nNode = newNode ( A [ ind ] ) ; if ( nNode == NULL ) { cout << " Memory ▁ error " << endl ; return NULL ; } for ( int i = 0 ; i < k ; i ++ ) { if ( ind < n - 1 && h > 1 ) { ind ++ ; nNode -> child . push_back ( BuildKaryTree ( A , n , k , h - 1 , ind ) ) ; } else { nNode -> child . push_back ( NULL ) ; } } return nNode ; } Node * BuildKaryTree ( int * A , int n , int k , int ind ) { int height = ( int ) ceil ( log ( ( double ) n * ( k - 1 ) + 1 ) / log ( ( double ) k ) ) ; return BuildKaryTree ( A , n , k , height , ind ) ; } void postord ( Node * root , int k ) { if ( root == NULL ) return ; for ( int i = 0 ; i < k ; i ++ ) postord ( root -> child [ i ] , k ) ; cout << root -> key << " ▁ " ; } int main ( ) { int ind = 0 ; int k = 3 , n = 10 ; int preorder [ ] = { 1 , 2 , 5 , 6 , 7 , 3 , 8 , 9 , 10 , 4 } ; Node * root = BuildKaryTree ( preorder , n , k , ind ) ; cout << " Postorder ▁ traversal ▁ of ▁ constructed " " ▁ full ▁ k - ary ▁ tree ▁ is : ▁ " ; postord ( root , k ) ; cout << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printCoils ( int n ) { int m = 8 * n * n ; int coil1 [ m ] ; coil1 [ 0 ] = 8 * n * n + 2 * n ; int curr = coil1 [ 0 ] ; int nflg = 1 , step = 2 ; int index = 1 ; while ( index < m ) { for ( int i = 0 ; i < step ; i ++ ) { curr = coil1 [ index ++ ] = ( curr - 4 * n * nflg ) ; if ( index >= m ) break ; } if ( index >= m ) break ; for ( int i = 0 ; i < step ; i ++ ) { curr = coil1 [ index ++ ] = curr + nflg ; if ( index >= m ) break ; } nflg = nflg * ( -1 ) ; step += 2 ; } int coil2 [ m ] ; for ( int i = 0 ; i < 8 * n * n ; i ++ ) coil2 [ i ] = 16 * n * n + 1 - coil1 [ i ] ; cout << " Coil ▁ 1 ▁ : ▁ " ; for ( int i = 0 ; i < 8 * n * n ; i ++ ) cout << coil1 [ i ] << " ▁ " ; cout << " Coil 2 : " for ( int i = 0 ; i < 8 * n * n ; i ++ ) cout << coil2 [ i ] << " ▁ " ; } int main ( ) { int n = 1 ; printCoils ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int n ) { int arr [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; } int main ( ) { int n = 3 ; cout << findSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; } int main ( ) { int n = 3 ; cout << findSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; } int main ( ) { int n = 3 ; cout << findSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  1000 NEW_LINE using namespace std ; void checkHV ( int arr [ ] [ MAX ] , int N , int M ) { bool horizontal = true , vertical = true ; for ( int i = 0 , k = N - 1 ; i < N / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { horizontal = false ; break ; } } } for ( int i = 0 , k = M - 1 ; i < M / 2 ; i ++ , k -- ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] != arr [ k ] [ j ] ) { vertical = false ; break ; } } } if ( ! horizontal && ! vertical ) cout << " NO STRNEWLINE " ; else if ( horizontal && ! vertical ) cout << " HORIZONTAL STRNEWLINE " ; else if ( vertical && ! horizontal ) cout << " VERTICAL STRNEWLINE " ; else cout << " BOTH STRNEWLINE " ; } int main ( ) { int mat [ MAX ] [ MAX ] = { { 1 , 0 , 1 } , { 0 , 0 , 0 } , { 1 , 0 , 1 } } ; checkHV ( mat , 3 , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDet ( int n ) { return ( 2 * n * n * n ) ; } void resMatrix ( int n ) { for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( i == 0 && j == 2 ) cout << "0 ▁ " ; else if ( i == 1 && j == 0 ) cout << "0 ▁ " ; else if ( i == 2 && j == 1 ) cout << "0 ▁ " ; else cout << n << " ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 15 ; cout << " Maximum ▁ Determinant ▁ = ▁ " << maxDet ( n ) ; cout << " Resultant Matrix : " resMatrix ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  5 NEW_LINE int numofneighbour ( int mat [ ] [ C ] , int i , int j ) { int count = 0 ; if ( i > 0 && mat [ i - 1 ] [ j ] ) count ++ ; if ( j > 0 && mat [ i ] [ j - 1 ] ) count ++ ; if ( i < R - 1 && mat [ i + 1 ] [ j ] ) count ++ ; if ( j < C - 1 && mat [ i ] [ j + 1 ] ) count ++ ; return count ; } int findperimeter ( int mat [ R ] [ C ] ) { int perimeter = 0 ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) if ( mat [ i ] [ j ] ) perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; return perimeter ; } int main ( ) { int mat [ R ] [ C ] = { 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , } ; cout << findperimeter ( mat ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = ( Node * ) malloc ( sizeof ( Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void preOrder ( Node * node ) { if ( node == NULL ) return ; printf ( " % d ▁ " , node -> data ) ; preOrder ( node -> left ) ; preOrder ( node -> right ) ; } int findIndex ( string str , int si , int ei ) { if ( si > ei ) return -1 ; stack < char > s ; for ( int i = si ; i <= ei ; i ++ ) { if ( str [ i ] == ' ( ' ) s . push ( str [ i ] ) ; else if ( str [ i ] == ' ) ' ) { if ( s . top ( ) == ' ( ' ) { s . pop ( ) ; if ( s . empty ( ) ) return i ; } } } return -1 ; } Node * treeFromString ( string str , int si , int ei ) { if ( si > ei ) return NULL ; Node * root = newNode ( str [ si ] - '0' ) ; int index = -1 ; if ( si + 1 <= ei && str [ si + 1 ] == ' ( ' ) index = findIndex ( str , si + 1 , ei ) ; if ( index != -1 ) { root -> left = treeFromString ( str , si + 2 , index - 1 ) ; root -> right = treeFromString ( str , index + 2 , ei - 1 ) ; } return root ; } int main ( ) { string str = "4(2(3 ) ( 1 ) ) (6(5 ) ) " ; Node * root = treeFromString ( str , 0 , str . length ( ) - 1 ) ; preOrder ( root ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int val ; node * left ; node * right ; node ( ) : val ( 0 ) , left ( nullptr ) , right ( nullptr ) { } node ( int x ) : val ( x ) , left ( nullptr ) , right ( nullptr ) { } node ( int x , node * left , node * right ) : val ( x ) , left ( left ) , right ( right ) { } } ; bool continuous ( struct node * root ) { if ( root == NULL ) return false ; int flag = 1 ; queue < struct node * > Q ; Q . push ( root ) ; node * temp ; while ( ! Q . empty ( ) ) { temp = Q . front ( ) ; Q . pop ( ) ; if ( temp -> left ) { if ( abs ( temp -> left -> val - temp -> val ) == 1 ) Q . push ( temp -> left ) ; else { flag = 0 ; break ; } } if ( temp -> right ) { if ( abs ( temp -> right -> val - temp -> val ) == 1 ) Q . push ( temp -> right ) ; else { flag = 0 ; break ; } } } if ( flag ) return true ; else return false ; } int main ( ) { struct node * root = new node ( 3 ) ; root -> left = new node ( 2 ) ; root -> right = new node ( 4 ) ; root -> left -> left = new node ( 1 ) ; root -> left -> right = new node ( 3 ) ; root -> right -> right = new node ( 5 ) ; if ( continuous ( root ) ) cout << " True STRNEWLINE " ; else cout << " False STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int mat [ ] [ 4 ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int n = 4 , mode = 0 , it = 0 , lower = 0 ; for ( int t = 0 ; t < ( 2 * n - 1 ) ; t ++ ) { int t1 = t ; if ( t1 >= n ) { mode ++ ; t1 = n - 1 ; it -- ; lower ++ ; } else { lower = 0 ; it ++ ; } for ( int i = t1 ; i >= lower ; i -- ) { if ( ( t1 + mode ) % 2 == 0 ) { cout << ( mat [ i ] [ t1 + lower - i ] ) << endl ; } else { cout << ( mat [ t1 + lower - i ] [ i ] ) << endl ; } } } return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int maxRowDiff ( int mat [ ] [ MAX ] , int m , int n ) { int rowSum [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; } int main ( ) { int m = 5 , n = 4 ; int mat [ ] [ MAX ] = { { -1 , 2 , 3 , 4 } , { 5 , 3 , -2 , 1 } , { 6 , 7 , 2 , -3 } , { 2 , 9 , 1 , 4 } , { 2 , 1 , -2 , 0 } } ; cout << maxRowDiff ( mat , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void preprocessMatrix ( int rows [ ] , int cols [ ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) rows [ i ] = i ; for ( int i = 0 ; i < n ; i ++ ) cols [ i ] = i ; } void queryMatrix ( int rows [ ] , int cols [ ] , int m , int n , char ch , int x , int y ) { int tmp ; switch ( ch ) { case ' R ' : swap ( rows [ x - 1 ] , rows [ y - 1 ] ) ; break ; case ' C ' : swap ( cols [ x - 1 ] , cols [ y - 1 ] ) ; break ; case ' P ' : printf ( " value ▁ at ▁ ( % d , ▁ % d ) ▁ = ▁ % d STRNEWLINE " , x , y , rows [ x - 1 ] * n + cols [ y - 1 ] + 1 ) ; break ; } return ; } int main ( ) { int m = 1234 , n = 5678 ; int rows [ m ] , cols [ n ] ; preprocessMatrix ( rows , cols , m , n ) ; queryMatrix ( rows , cols , m , n , ' R ' , 1 , 2 ) ; queryMatrix ( rows , cols , m , n , ' P ' , 1 , 1 ) ; queryMatrix ( rows , cols , m , n , ' P ' , 2 , 1 ) ; queryMatrix ( rows , cols , m , n , ' C ' , 1 , 2 ) ; queryMatrix ( rows , cols , m , n , ' P ' , 1 , 1 ) ; queryMatrix ( rows , cols , m , n , ' P ' , 2 , 1 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 1000 ; int maxXOR ( int mat [ ] [ MAX ] , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < max ( r_xor , c_xor ) ) max_xor = max ( r_xor , c_xor ) ; } return max_xor ; } int main ( ) { int N = 3 ; int mat [ ] [ MAX ] = { { 1 , 5 , 4 } , { 3 , 7 , 2 } , { 5 , 9 , 10 } } ; cout << " maximum ▁ XOR ▁ value ▁ : ▁ " << maxXOR ( mat , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumMirrorInMatrix ( string mat [ ] , int N ) { int horizontal [ N ] , vertical [ N ] ; memset ( horizontal , -1 , sizeof ( horizontal ) ) ; memset ( vertical , -1 , sizeof ( vertical ) ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == ' B ' ) continue ; horizontal [ i ] = j ; break ; } } for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == ' B ' ) continue ; vertical [ j ] = i ; break ; } } int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i > vertical [ j ] && j > horizontal [ i ] ) { res ++ ; } } } return res ; } int main ( ) { int N = 5 ; string mat [ N ] = { " BBOBB " , " BBBBO " , " BBBBB " , " BOOBO " , " BBBOB " } ; cout << maximumMirrorInMatrix ( mat , N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; typedef long long int ll ; void direction ( ll R , ll C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { cout << " Left " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { cout << " Up " << endl ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { cout << " Right " << endl ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { cout << " Left " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { cout << " Right " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { cout << " Down " << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { cout << " Left " << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { cout << " Up " << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { cout << " Down " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { cout << " Right " << endl ; return ; } } int main ( ) { ll R = 3 , C = 1 ; direction ( R , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int findK ( int A [ MAX ] [ MAX ] , int n , int m , int k ) { if ( n < 1 m < 1 ) return -1 ; if ( k <= m ) return A [ 0 ] [ k - 1 ] ; if ( k <= ( m + n - 1 ) ) return A [ ( k - m ) ] [ m - 1 ] ; if ( k <= ( m + n - 1 + m - 1 ) ) return A [ n - 1 ] [ m - 1 - ( k - ( m + n - 1 ) ) ] ; if ( k <= ( m + n - 1 + m - 1 + n - 2 ) ) return A [ n - 1 - ( k - ( m + n - 1 + m - 1 ) ) ] [ 0 ] ; return findK ( ( int ( * ) [ MAX ] ) ( & ( A [ 1 ] [ 1 ] ) ) , n - 2 , m - 2 , k - ( 2 * n + 2 * m - 4 ) ) ; } int main ( ) { int a [ MAX ] [ MAX ] = { { 1 , 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 , 17 , 18 } } ; int k = 17 ; cout << findK ( a , 3 , 6 , k ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define N  5 NEW_LINE #define M  4 NEW_LINE bool checkDiagonal ( int mat [ N ] [ M ] , int i , int j ) { int res = mat [ i ] [ j ] ; while ( ++ i < N && ++ j < M ) { if ( mat [ i ] [ j ] != res ) return false ; } return true ; } bool isToepliz ( int mat [ N ] [ M ] ) { for ( int i = 0 ; i < M ; i ++ ) { if ( ! checkDiagonal ( mat , 0 , i ) ) return false ; } for ( int i = 1 ; i < N ; i ++ ) { if ( ! checkDiagonal ( mat , i , 0 ) ) return false ; } return true ; } int main ( ) { int mat [ N ] [ M ] = { { 6 , 7 , 8 , 9 } , { 4 , 6 , 7 , 8 } , { 1 , 4 , 6 , 7 } , { 0 , 1 , 4 , 6 } , { 2 , 0 , 1 , 4 } } ; if ( isToepliz ( mat ) ) cout << " Matrix ▁ is ▁ a ▁ Toepliz ▁ " ; else cout << " Matrix ▁ is ▁ not ▁ a ▁ Toepliz ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isToeplitz ( vector < vector < int > > matrix ) { int row = matrix . size ( ) ; int col = matrix [ 0 ] . size ( ) ; map < int , int > Map ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) { int key = i - j ; if ( Map [ key ] ) { if ( Map [ key ] != matrix [ i ] [ j ] ) return false ; } else { Map [ i - j ] = matrix [ i ] [ j ] ; } } } return true ; } int main ( ) { vector < vector < int > > matrix = { { 12 , 23 , -32 } , { -20 , 12 , 23 } , { 56 , -20 , 12 } , { 38 , 56 , -20 } } ; string result = ( isToeplitz ( matrix ) ) ? " Yes " : " No " ; cout << result ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define N  5 NEW_LINE int countZeroes ( int mat [ N ] [ N ] ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; } int main ( ) { int mat [ N ] [ N ] = { { 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 1 , 1 } , { 0 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } } ; cout << countZeroes ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int i = 0 ; int j = m - 1 ; while ( j >= 0 && i < n ) { if ( M [ i ] [ j ] < 0 ) { count += j + 1 ; i += 1 ; } else j -= 1 ; } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << countNegative ( M , 3 , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLastNegativeIndex ( int array [ ] , int start , int end , int n ) { if ( start == end ) { return start ; } int mid = start + ( end - start ) / 2 ; if ( array [ mid ] < 0 ) { if ( mid + 1 < n && array [ mid + 1 ] >= 0 ) { return mid ; } return getLastNegativeIndex ( array , mid + 1 , end , n ) ; } else { return getLastNegativeIndex ( array , start , mid - 1 , n ) ; } } int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; int nextEnd = m - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( M [ i ] [ 0 ] >= 0 ) { break ; } nextEnd = getLastNegativeIndex ( M [ i ] , 0 , nextEnd , 4 ) ; count += nextEnd + 1 ; } return count ; } int main ( ) { int M [ ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; int r = 3 ; int c = 4 ; cout << ( countNegative ( M , r , c ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findLeft ( string str ) { int n = str . length ( ) ; while ( n -- ) { if ( str [ n ] == ' d ' ) { str [ n ] = ' c ' ; break ; } if ( str [ n ] == ' b ' ) { str [ n ] = ' a ' ; break ; } if ( str [ n ] == ' a ' ) str [ n ] = ' b ' ; else if ( str [ n ] == ' c ' ) str [ n ] = ' d ' ; } return str ; } int main ( ) { string str = " aacbddc " ; cout << " Left ▁ of ▁ " << str << " ▁ is ▁ " << findLeft ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) printf ( " % d TABSYMBOL ▁ " , ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) ) ; else printf ( " % d TABSYMBOL ▁ " , ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) ; } printf ( " STRNEWLINE " ) ; } } int main ( ) { int n = 5 ; printSpiral ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ROW  9 NEW_LINE #define COL  10 NEW_LINE struct Point { int x ; int y ; } ; struct queueNode { Point pt ; int dist ; } ; bool isValid ( int row , int col ) { return ( row >= 0 ) && ( row < ROW ) && ( col >= 0 ) && ( col < COL ) ; } int rowNum [ ] = { -1 , 0 , 0 , 1 } ; int colNum [ ] = { 0 , -1 , 1 , 0 } ; int BFS ( int mat [ ] [ COL ] , Point src , Point dest ) { if ( ! mat [ src . x ] [ src . y ] ! mat [ dest . x ] [ dest . y ] ) return -1 ; bool visited [ ROW ] [ COL ] ; memset ( visited , false , sizeof visited ) ; visited [ src . x ] [ src . y ] = true ; queue < queueNode > q ; queueNode s = { src , 0 } ; q . push ( s ) ; while ( ! q . empty ( ) ) { queueNode curr = q . front ( ) ; Point pt = curr . pt ; if ( pt . x == dest . x && pt . y == dest . y ) return curr . dist ; q . pop ( ) ; for ( int i = 0 ; i < 4 ; i ++ ) { int row = pt . x + rowNum [ i ] ; int col = pt . y + colNum [ i ] ; if ( isValid ( row , col ) && mat [ row ] [ col ] && ! visited [ row ] [ col ] ) { visited [ row ] [ col ] = true ; queueNode Adjcell = { { row , col } , curr . dist + 1 } ; q . push ( Adjcell ) ; } } } return -1 ; } int main ( ) { int mat [ ROW ] [ COL ] = { { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 1 } , { 1 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 0 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 } } ; Point source = { 0 , 0 } ; Point dest = { 3 , 4 } ; int dist = BFS ( mat , source , dest ) ; if ( dist != -1 ) cout << " Shortest ▁ Path ▁ is ▁ " << dist ; else cout << " Shortest ▁ Path ▁ doesn ' t ▁ exist " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; for ( int a = 0 ; a < N - 1 ; a ++ ) for ( int b = 0 ; b < N - 1 ; b ++ ) for ( int d = a + 1 ; d < N ; d ++ ) for ( int e = b + 1 ; e < N ; e ++ ) if ( maxValue < ( mat [ d ] [ e ] - mat [ a ] [ b ] ) ) maxValue = mat [ d ] [ e ] - mat [ a ] [ b ] ; return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -4 , -20 } , { -8 , -3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -4 , -1 , 1 , 7 , -6 } , { 0 , -4 , 10 , -5 , 1 } } ; cout << " Maximum ▁ Value ▁ is ▁ " << findMaxValue ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; node * bintree2listUtil ( node * root ) { if ( root == NULL ) return root ; if ( root -> left != NULL ) { node * left = bintree2listUtil ( root -> left ) ; for ( ; left -> right != NULL ; left = left -> right ) ; left -> right = root ; root -> left = left ; } if ( root -> right != NULL ) { node * right = bintree2listUtil ( root -> right ) ; for ( ; right -> left != NULL ; right = right -> left ) ; right -> left = root ; root -> right = right ; } return root ; } node * bintree2list ( node * root ) { if ( root == NULL ) return root ; root = bintree2listUtil ( root ) ; while ( root -> left != NULL ) root = root -> left ; return ( root ) ; } node * newNode ( int data ) { node * new_node = new node ( ) ; new_node -> data = data ; new_node -> left = new_node -> right = NULL ; return ( new_node ) ; } void printList ( node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> right ; } } int main ( ) { node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ; node * head = bintree2list ( root ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  4 NEW_LINE void modifyMatrix ( bool mat [ R ] [ C ] ) { bool row [ R ] ; bool col [ C ] ; int i , j ; for ( i = 0 ; i < R ; i ++ ) { row [ i ] = 0 ; } for ( i = 0 ; i < C ; i ++ ) { col [ i ] = 0 ; } for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { row [ i ] = 1 ; col [ j ] = 1 ; } } } for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( row [ i ] == 1 col [ j ] == 1 ) { mat [ i ] [ j ] = 1 ; } } } } void printMatrix ( bool mat [ R ] [ C ] ) { int i , j ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { cout << mat [ i ] [ j ] ; } cout << endl ; } } int main ( ) { bool mat [ R ] [ C ] = { { 1 , 0 , 0 , 1 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } } ; cout << " Input ▁ Matrix ▁ STRNEWLINE " ; printMatrix ( mat ) ; modifyMatrix ( mat ) ; printf ( " Matrix ▁ after ▁ modification ▁ STRNEWLINE " ) ; printMatrix ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  4 NEW_LINE void modifyMatrix ( int mat [ R ] [ C ] ) { bool row_flag = false ; bool col_flag = false ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( i == 0 && mat [ i ] [ j ] == 1 ) row_flag = true ; if ( j == 0 && mat [ i ] [ j ] == 1 ) col_flag = true ; if ( mat [ i ] [ j ] == 1 ) { mat [ 0 ] [ j ] = 1 ; mat [ i ] [ 0 ] = 1 ; } } } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( mat [ 0 ] [ j ] == 1 mat [ i ] [ 0 ] == 1 ) { mat [ i ] [ j ] = 1 ; } } } if ( row_flag == true ) { for ( int i = 0 ; i < C ; i ++ ) { mat [ 0 ] [ i ] = 1 ; } } if ( col_flag == true ) { for ( int i = 0 ; i < R ; i ++ ) { mat [ i ] [ 0 ] = 1 ; } } } void printMatrix ( int mat [ R ] [ C ] ) { for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { cout << mat [ i ] [ j ] ; } cout << " STRNEWLINE " ; } } int main ( ) { int mat [ R ] [ C ] = { { 1 , 0 , 0 , 1 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } } ; cout << " Input ▁ Matrix ▁ : STRNEWLINE " ; printMatrix ( mat ) ; modifyMatrix ( mat ) ; cout << " Matrix ▁ After ▁ Modification ▁ : STRNEWLINE " ; printMatrix ( mat ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define n  5 NEW_LINE int find ( bool arr [ n ] [ n ] ) { int i = 0 , j = n - 1 ; int res = -1 ; while ( i < n && j >= 0 ) { if ( arr [ i ] [ j ] == 0 ) { while ( j >= 0 && ( arr [ i ] [ j ] == 0 i == j ) ) j -- ; if ( j == -1 ) { res = i ; break ; } else i ++ ; } else { while ( i < n && ( arr [ i ] [ j ] == 1 i == j ) ) i ++ ; if ( i == n ) { res = j ; break ; } else j -- ; } } if ( res == -1 ) return res ; for ( int i = 0 ; i < n ; i ++ ) if ( res != i && arr [ i ] [ res ] != 1 ) return -1 ; for ( int j = 0 ; j < n ; j ++ ) if ( res != j && arr [ res ] [ j ] != 0 ) return -1 ; return res ; } int main ( ) { bool mat [ n ] [ n ] = { { 0 , 0 , 1 , 1 , 0 } , { 0 , 0 , 0 , 1 , 0 } , { 1 , 1 , 1 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 } , { 1 , 1 , 1 , 1 , 1 } } ; cout << find ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int arr [ ] [ 5 ] , int row , int col ) { unordered_set < string > uset ; for ( int i = 0 ; i < row ; i ++ ) { string s = " " ; for ( int j = 0 ; j < col ; j ++ ) s += to_string ( arr [ i ] [ j ] ) ; if ( uset . count ( s ) == 0 ) { uset . insert ( s ) ; cout << s << endl ; } } } int main ( ) { int arr [ ] [ 5 ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 1 , 1 , 1 , 0 , 0 } } ; printArray ( arr , 4 , 5 ) ; }
#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  5 NEW_LINE using namespace std ; int maxArea ( bool mat [ R ] [ C ] ) { int hist [ R + 1 ] [ C + 1 ] ; for ( int i = 0 ; i < C ; i ++ ) { hist [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < R ; j ++ ) hist [ j ] [ i ] = ( mat [ j ] [ i ] == 0 ) ? 0 : hist [ j - 1 ] [ i ] + 1 ; } for ( int i = 0 ; i < R ; i ++ ) { int count [ R + 1 ] = { 0 } ; for ( int j = 0 ; j < C ; j ++ ) count [ hist [ i ] [ j ] ] ++ ; int col_no = 0 ; for ( int j = R ; j >= 0 ; j -- ) { if ( count [ j ] > 0 ) { for ( int k = 0 ; k < count [ j ] ; k ++ ) { hist [ i ] [ col_no ] = j ; col_no ++ ; } } } } int curr_area , max_area = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { curr_area = ( j + 1 ) * hist [ i ] [ j ] ; if ( curr_area > max_area ) max_area = curr_area ; } } return max_area ; } int main ( ) { bool mat [ R ] [ C ] = { { 0 , 1 , 0 , 1 , 0 } , { 0 , 1 , 0 , 1 , 1 } , { 1 , 1 , 0 , 1 , 0 } } ; cout << " Area ▁ of ▁ the ▁ largest ▁ rectangle ▁ is ▁ " << maxArea ( mat ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define M  4 NEW_LINE #define N  5 NEW_LINE int preProcess ( int mat [ M ] [ N ] , int aux [ M ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; } int sumQuery ( int aux [ M ] [ N ] , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; } int main ( ) { int mat [ M ] [ N ] = { { 1 , 2 , 3 , 4 , 6 } , { 5 , 3 , 8 , 1 , 2 } , { 4 , 6 , 7 , 5 , 5 } , { 2 , 4 , 8 , 9 , 4 } } ; int aux [ M ] [ N ] ; preProcess ( mat , aux ) ; int tli = 2 , tlj = 2 , rbi = 3 , rbj = 4 ; cout << " Query1 : " tli = 0 , tlj = 0 , rbi = 1 , rbj = 1 ; cout << " Query2 : " tli = 1 , tlj = 2 , rbi = 3 , rbj = 3 ; cout << " Query3 : " return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  3 NEW_LINE void swap ( int mat [ R ] [ C ] , int row1 , int row2 , int col ) { for ( int i = 0 ; i < col ; i ++ ) { int temp = mat [ row1 ] [ i ] ; mat [ row1 ] [ i ] = mat [ row2 ] [ i ] ; mat [ row2 ] [ i ] = temp ; } } void display ( int mat [ R ] [ C ] , int row , int col ) ; int rankOfMatrix ( int mat [ R ] [ C ] ) { int rank = C ; for ( int row = 0 ; row < rank ; row ++ ) { if ( mat [ row ] [ row ] ) { for ( int col = 0 ; col < R ; col ++ ) { if ( col != row ) { double mult = ( double ) mat [ col ] [ row ] / mat [ row ] [ row ] ; for ( int i = 0 ; i < rank ; i ++ ) mat [ col ] [ i ] -= mult * mat [ row ] [ i ] ; } } } else { bool reduce = true ; for ( int i = row + 1 ; i < R ; i ++ ) { if ( mat [ i ] [ row ] ) { swap ( mat , row , i , rank ) ; reduce = false ; break ; } } if ( reduce ) { rank -- ; for ( int i = 0 ; i < R ; i ++ ) mat [ i ] [ row ] = mat [ i ] [ rank ] ; } row -- ; } } return rank ; } void display ( int mat [ R ] [ C ] , int row , int col ) { for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) printf ( " ▁ % d " , mat [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } } int main ( ) { int mat [ ] [ 3 ] = { { 10 , 20 , 10 } , { -20 , -30 , 10 } , { 30 , 50 , 0 } } ; printf ( " Rank ▁ of ▁ the ▁ matrix ▁ is ▁ : ▁ % d " , rankOfMatrix ( mat ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  4 NEW_LINE #define C  4 NEW_LINE int maxHist ( int row [ ] ) { stack < int > result ; int top_val ; int max_area = 0 ; int area = 0 ; int i = 0 ; while ( i < C ) { if ( result . empty ( ) || row [ result . top ( ) ] <= row [ i ] ) result . push ( i ++ ) ; else { top_val = row [ result . top ( ) ] ; result . pop ( ) ; area = top_val * i ; if ( ! result . empty ( ) ) area = top_val * ( i - result . top ( ) - 1 ) ; max_area = max ( area , max_area ) ; } } while ( ! result . empty ( ) ) { top_val = row [ result . top ( ) ] ; result . pop ( ) ; area = top_val * i ; if ( ! result . empty ( ) ) area = top_val * ( i - result . top ( ) - 1 ) ; max_area = max ( area , max_area ) ; } return max_area ; } int maxRectangle ( int A [ ] [ C ] ) { int result = maxHist ( A [ 0 ] ) ; for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) if ( A [ i ] [ j ] ) A [ i ] [ j ] += A [ i - 1 ] [ j ] ; result = max ( result , maxHist ( A [ i ] ) ) ; } return result ; } int main ( ) { int A [ ] [ C ] = { { 0 , 1 , 1 , 0 } , { 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 } , { 1 , 1 , 0 , 0 } , } ; cout << " Area ▁ of ▁ maximum ▁ rectangle ▁ is ▁ " << maxRectangle ( A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; struct Cell { int r ; int c ; } ; void printSums ( int mat [ ] [ C ] , struct Cell arr [ ] , int n ) { int sum = 0 ; int row [ R ] = { } ; int col [ C ] = { } ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { sum += mat [ i ] [ j ] ; col [ j ] += mat [ i ] [ j ] ; row [ i ] += mat [ i ] [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { int ro = arr [ i ] . r , co = arr [ i ] . c ; cout << sum - row [ ro ] - col [ co ] + mat [ ro ] [ co ] << endl ; } } int main ( ) { int mat [ ] [ C ] = { { 1 , 1 , 2 } , { 3 , 4 , 6 } , { 5 , 3 , 2 } } ; struct Cell arr [ ] = { { 0 , 0 } , { 1 , 1 } , { 0 , 1 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printSums ( mat , arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define M  6 NEW_LINE #define N  3 NEW_LINE int countIslands ( int mat [ ] [ N ] ) { int count = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == ' X ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' O ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; } int main ( ) { int mat [ M ] [ N ] = { { ' O ' , ' O ' , ' O ' } , { ' X ' , ' X ' , ' O ' } , { ' X ' , ' X ' , ' O ' } , { ' O ' , ' O ' , ' X ' } , { ' O ' , ' O ' , ' X ' } , { ' X ' , ' X ' , ' O ' } } ; cout << " Number ▁ of ▁ rectangular ▁ islands ▁ is ▁ " << countIslands ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  4 NEW_LINE #define N  5 NEW_LINE int findCommon ( int mat [ M ] [ N ] ) { int column [ M ] ; int min_row ; int i ; for ( i = 0 ; i < M ; i ++ ) column [ i ] = N - 1 ; min_row = 0 ; while ( column [ min_row ] >= 0 ) { for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] < mat [ min_row ] [ column [ min_row ] ] ) min_row = i ; } int eq_count = 0 ; for ( i = 0 ; i < M ; i ++ ) { if ( mat [ i ] [ column [ i ] ] > mat [ min_row ] [ column [ min_row ] ] ) { if ( column [ i ] == 0 ) return -1 ; column [ i ] -= 1 ; } else eq_count ++ ; } if ( eq_count == M ) return mat [ min_row ] [ column [ min_row ] ] ; } return -1 ; } int main ( ) { int mat [ M ] [ N ] = { { 1 , 2 , 3 , 4 , 5 } , { 2 , 4 , 5 , 8 , 10 } , { 3 , 5 , 7 , 9 , 11 } , { 1 , 3 , 5 , 7 , 9 } , } ; int result = findCommon ( mat ) ; if ( result == -1 ) cout << " No ▁ common ▁ element " ; else cout << " Common ▁ element ▁ is ▁ " << result ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  4 NEW_LINE #define N  5 NEW_LINE int findCommon ( int mat [ M ] [ N ] ) { unordered_map < int , int > cnt ; int i , j ; for ( i = 0 ; i < M ; i ++ ) { cnt [ mat [ i ] [ 0 ] ] ++ ; for ( j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ j - 1 ] ) cnt [ mat [ i ] [ j ] ] ++ ; } } for ( auto ele : cnt ) { if ( ele . second == M ) return ele . first ; } return -1 ; } int main ( ) { int mat [ M ] [ N ] = { { 1 , 2 , 3 , 4 , 5 } , { 2 , 4 , 5 , 8 , 10 } , { 3 , 5 , 7 , 9 , 11 } , { 1 , 3 , 5 , 7 , 9 } , } ; int result = findCommon ( mat ) ; if ( result == -1 ) cout << " No ▁ common ▁ element " ; else cout << " Common ▁ element ▁ is ▁ " << result ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define M  6 NEW_LINE #define N  6 NEW_LINE void floodFillUtil ( char mat [ ] [ N ] , int x , int y , char prevV , char newV ) { if ( x < 0 x > = M y < 0 y > = N ) return ; if ( mat [ x ] [ y ] != prevV ) return ; mat [ x ] [ y ] = newV ; floodFillUtil ( mat , x + 1 , y , prevV , newV ) ; floodFillUtil ( mat , x - 1 , y , prevV , newV ) ; floodFillUtil ( mat , x , y + 1 , prevV , newV ) ; floodFillUtil ( mat , x , y - 1 , prevV , newV ) ; } int replaceSurrounded ( char mat [ ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == ' O ' ) mat [ i ] [ j ] = ' - ' ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ 0 ] == ' - ' ) floodFillUtil ( mat , i , 0 , ' - ' , ' O ' ) ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ N - 1 ] == ' - ' ) floodFillUtil ( mat , i , N - 1 , ' - ' , ' O ' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ 0 ] [ i ] == ' - ' ) floodFillUtil ( mat , 0 , i , ' - ' , ' O ' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ M - 1 ] [ i ] == ' - ' ) floodFillUtil ( mat , M - 1 , i , ' - ' , ' O ' ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == ' - ' ) mat [ i ] [ j ] = ' X ' ; } int main ( ) { char mat [ ] [ N ] = { { ' X ' , ' O ' , ' X ' , ' O ' , ' X ' , ' X ' } , { ' X ' , ' O ' , ' X ' , ' X ' , ' O ' , ' X ' } , { ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' X ' } , { ' O ' , ' X ' , ' X ' , ' X ' , ' X ' , ' X ' } , { ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' O ' } , { ' O ' , ' O ' , ' X ' , ' O ' , ' O ' , ' O ' } , } ; replaceSurrounded ( mat ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << mat [ i ] [ j ] << " ▁ " ; cout << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left , * right ; } ; node * newNode ( int data ) { node * Node = new node ( ) ; Node -> data = data ; Node -> left = Node -> right = NULL ; return ( Node ) ; } void inorder ( node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << " TABSYMBOL " << root -> data ; inorder ( root -> right ) ; } } void fixPrevPtr ( node * root ) { static node * pre = NULL ; if ( root != NULL ) { fixPrevPtr ( root -> left ) ; root -> left = pre ; pre = root ; fixPrevPtr ( root -> right ) ; } } node * fixNextPtr ( node * root ) { node * prev = NULL ; while ( root && root -> right != NULL ) root = root -> right ; while ( root && root -> left != NULL ) { prev = root ; root = root -> left ; root -> right = prev ; } return ( root ) ; } node * BTToDLL ( node * root ) { fixPrevPtr ( root ) ; return fixNextPtr ( root ) ; } void printList ( node * root ) { while ( root != NULL ) { cout << " TABSYMBOL " << root -> data ; root = root -> right ; } } int main ( void ) { node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ; cout << " Inorder Tree Traversal " ; inorder ( root ) ; node * head = BTToDLL ( root ) ; cout << " DLL Traversal " printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  6 NEW_LINE int maximumSubSquare ( int arr [ ] [ N ] ) { pair < int , int > dp [ 51 ] [ 51 ] ; int maxside [ 51 ] [ 51 ] ; memset ( maxside , 0 , sizeof ( maxside ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < N ; i ++ ) { x = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ j ] == ' X ' ) x += 1 ; else x = 0 ; dp [ i ] [ j ] . first = x ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] [ i ] == ' X ' ) y += 1 ; else y = 0 ; dp [ j ] [ i ] . second = y ; } } int maxval = 0 , val = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { val = min ( dp [ i ] [ j ] . first , dp [ i ] [ j ] . second ) ; if ( dp [ i ] [ j - val + 1 ] . second >= val && dp [ i - val + 1 ] [ j ] . first >= val ) maxside [ i ] [ j ] = val ; else maxside [ i ] [ j ] = 0 ; maxval = max ( maxval , maxside [ i ] [ j ] ) ; } } return maxval ; } int main ( ) { int mat [ ] [ N ] = { { ' X ' , ' O ' , ' X ' , ' X ' , ' X ' , ' X ' } , { ' X ' , ' O ' , ' X ' , ' X ' , ' O ' , ' X ' } , { ' X ' , ' X ' , ' X ' , ' O ' , ' O ' , ' X ' } , { ' O ' , ' X ' , ' X ' , ' X ' , ' X ' , ' X ' } , { ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' O ' } , { ' O ' , ' O ' , ' X ' , ' O ' , ' O ' , ' O ' } , } ; cout << maximumSubSquare ( mat ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define M  8 NEW_LINE #define N  8 NEW_LINE void floodFillUtil ( int screen [ ] [ N ] , int x , int y , int prevC , int newC ) { if ( x < 0 x > = M y < 0 y > = N ) return ; if ( screen [ x ] [ y ] != prevC ) return ; if ( screen [ x ] [ y ] == newC ) return ; screen [ x ] [ y ] = newC ; floodFillUtil ( screen , x + 1 , y , prevC , newC ) ; floodFillUtil ( screen , x - 1 , y , prevC , newC ) ; floodFillUtil ( screen , x , y + 1 , prevC , newC ) ; floodFillUtil ( screen , x , y - 1 , prevC , newC ) ; } void floodFill ( int screen [ ] [ N ] , int x , int y , int newC ) { int prevC = screen [ x ] [ y ] ; floodFillUtil ( screen , x , y , prevC , newC ) ; } int main ( ) { int screen [ M ] [ N ] = { { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 } , { 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 } , { 1 , 2 , 2 , 2 , 2 , 0 , 1 , 0 } , { 1 , 1 , 1 , 2 , 2 , 0 , 1 , 0 } , { 1 , 1 , 1 , 2 , 2 , 2 , 2 , 0 } , { 1 , 1 , 1 , 1 , 1 , 2 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 2 , 2 , 1 } , } ; int x = 4 , y = 4 , newC = 3 ; floodFill ( screen , x , y , newC ) ; cout << " Updated ▁ screen ▁ after ▁ call ▁ to ▁ floodFill : ▁ STRNEWLINE " ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << screen [ i ] [ j ] << " ▁ " ; cout << endl ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int validCoord ( int x , int y , int n , int m ) { if ( x < 0 y < 0 ) { return 0 ; } if ( x >= n y >= m ) { return 0 ; } return 1 ; } void bfs ( int n , int m , int data [ ] [ 8 ] , int x , int y , int color ) { int vis [ 101 ] [ 101 ] ; memset ( vis , 0 , sizeof ( vis ) ) ; queue < pair < int , int > > obj ; obj . push ( { x , y } ) ; vis [ x ] [ y ] = 1 ; while ( obj . empty ( ) != 1 ) { pair < int , int > coord = obj . front ( ) ; int x = coord . first ; int y = coord . second ; int preColor = data [ x ] [ y ] ; data [ x ] [ y ] = color ; obj . pop ( ) ; if ( validCoord ( x + 1 , y , n , m ) && vis [ x + 1 ] [ y ] == 0 && data [ x + 1 ] [ y ] == preColor ) { obj . push ( { x + 1 , y } ) ; vis [ x + 1 ] [ y ] = 1 ; } if ( validCoord ( x - 1 , y , n , m ) && vis [ x - 1 ] [ y ] == 0 && data [ x - 1 ] [ y ] == preColor ) { obj . push ( { x - 1 , y } ) ; vis [ x - 1 ] [ y ] = 1 ; } if ( validCoord ( x , y + 1 , n , m ) && vis [ x ] [ y + 1 ] == 0 && data [ x ] [ y + 1 ] == preColor ) { obj . push ( { x , y + 1 } ) ; vis [ x ] [ y + 1 ] = 1 ; } if ( validCoord ( x , y - 1 , n , m ) && vis [ x ] [ y - 1 ] == 0 && data [ x ] [ y - 1 ] == preColor ) { obj . push ( { x , y - 1 } ) ; vis [ x ] [ y - 1 ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { cout << data [ i ] [ j ] << " ▁ " ; } cout << endl ; } cout << endl ; } int main ( ) { int n , m , x , y , color ; n = 8 ; m = 8 ; int data [ 8 ] [ 8 ] = { { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 } , { 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 } , { 1 , 2 , 2 , 2 , 2 , 0 , 1 , 0 } , { 1 , 1 , 1 , 2 , 2 , 0 , 1 , 0 } , { 1 , 1 , 1 , 2 , 2 , 2 , 2 , 0 } , { 1 , 1 , 1 , 1 , 1 , 2 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 2 , 2 , 1 } , } ; x = 4 , y = 4 , color = 3 ; bfs ( n , m , data , x , y , color ) ; return 0 ; }
#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; #define INF  INT_MAX NEW_LINE #define N  4 NEW_LINE void youngify ( int mat [ ] [ N ] , int i , int j ) { int downVal = ( i + 1 < N ) ? mat [ i + 1 ] [ j ] : INF ; int rightVal = ( j + 1 < N ) ? mat [ i ] [ j + 1 ] : INF ; if ( downVal == INF && rightVal == INF ) return ; if ( downVal < rightVal ) { mat [ i ] [ j ] = downVal ; mat [ i + 1 ] [ j ] = INF ; youngify ( mat , i + 1 , j ) ; } else { mat [ i ] [ j ] = rightVal ; mat [ i ] [ j + 1 ] = INF ; youngify ( mat , i , j + 1 ) ; } } int extractMin ( int mat [ ] [ N ] ) { int ret = mat [ 0 ] [ 0 ] ; mat [ 0 ] [ 0 ] = INF ; youngify ( mat , 0 , 0 ) ; return ret ; } void printSorted ( int mat [ ] [ N ] ) { cout << " Elements ▁ of ▁ matrix ▁ in ▁ sorted ▁ order ▁ n " ; for ( int i = 0 ; i < N * N ; i ++ ) cout << extractMin ( mat ) << " ▁ " ; } int main ( ) { int mat [ N ] [ N ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , } ; printSorted ( mat ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define n  5 NEW_LINE void printSumSimple ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { for ( int j = 0 ; j < n - k + 1 ; j ++ ) { int sum = 0 ; for ( int p = i ; p < k + i ; p ++ ) for ( int q = j ; q < k + j ; q ++ ) sum += mat [ p ] [ q ] ; cout << sum << " ▁ " ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumSimple ( mat , k ) ; return 0 ; }
#include <stdio.h> NEW_LINE #define M  3 NEW_LINE #define N  4 NEW_LINE void transpose ( int A [ ] [ N ] , int B [ ] [ M ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = A [ j ] [ i ] ; } int main ( ) { int A [ M ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } } ; int B [ N ] [ M ] , i , j ; transpose ( A , B ) ; printf ( " Result ▁ matrix ▁ is ▁ STRNEWLINE " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) printf ( " % d ▁ " , B [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void transpose ( int A [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) swap ( A [ i ] [ j ] , A [ j ] [ i ] ) ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; transpose ( A ) ; printf ( " Modified ▁ matrix ▁ is ▁ STRNEWLINE " ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( " % d ▁ " , A [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct node { int data ; node * left ; node * right ; } ; void BinaryTree2DoubleLinkedList ( node * root , node * * head ) { if ( root == NULL ) return ; static node * prev = NULL ; BinaryTree2DoubleLinkedList ( root -> left , head ) ; if ( prev == NULL ) * head = root ; else { root -> left = prev ; prev -> right = root ; } prev = root ; BinaryTree2DoubleLinkedList ( root -> right , head ) ; } node * newNode ( int data ) { node * new_node = new node ; new_node -> data = data ; new_node -> left = new_node -> right = NULL ; return ( new_node ) ; } void printList ( node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> right ; } } int main ( ) { node * root = newNode ( 10 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 15 ) ; root -> left -> left = newNode ( 25 ) ; root -> left -> right = newNode ( 30 ) ; root -> right -> left = newNode ( 36 ) ; node * head = NULL ; BinaryTree2DoubleLinkedList ( root , & head ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  5 NEW_LINE #define C  4 NEW_LINE bool isValid ( int x , int y1 , int y2 ) { return ( x >= 0 && x < R && y1 >= 0 && y1 < C && y2 >= 0 && y2 < C ) ; } int getMaxUtil ( int arr [ R ] [ C ] , int mem [ R ] [ C ] [ C ] , int x , int y1 , int y2 ) { if ( ! isValid ( x , y1 , y2 ) ) return INT_MIN ; if ( x == R - 1 && y1 == 0 && y2 == C - 1 ) return ( y1 == y2 ) ? arr [ x ] [ y1 ] : arr [ x ] [ y1 ] + arr [ x ] [ y2 ] ; if ( x == R - 1 ) return INT_MIN ; if ( mem [ x ] [ y1 ] [ y2 ] != -1 ) return mem [ x ] [ y1 ] [ y2 ] ; int ans = INT_MIN ; int temp = ( y1 == y2 ) ? arr [ x ] [ y1 ] : arr [ x ] [ y1 ] + arr [ x ] [ y2 ] ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 - 1 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 + 1 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 , y2 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 - 1 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 - 1 , y2 + 1 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 - 1 ) ) ; ans = max ( ans , temp + getMaxUtil ( arr , mem , x + 1 , y1 + 1 , y2 + 1 ) ) ; return ( mem [ x ] [ y1 ] [ y2 ] = ans ) ; } int geMaxCollection ( int arr [ R ] [ C ] ) { int mem [ R ] [ C ] [ C ] ; memset ( mem , -1 , sizeof ( mem ) ) ; return getMaxUtil ( arr , mem , 0 , 0 , C - 1 ) ; } int main ( ) { int arr [ R ] [ C ] = { { 3 , 6 , 8 , 2 } , { 5 , 2 , 4 , 3 } , { 1 , 1 , 20 , 10 } , { 1 , 1 , 20 , 10 } , { 1 , 1 , 20 , 10 } , } ; cout << " Maximum ▁ collection ▁ is ▁ " << geMaxCollection ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; int pathCountRec ( int mat [ ] [ C ] , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; return pathCountRec ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountRec ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; } int pathCount ( int mat [ ] [ C ] , int k ) { return pathCountRec ( mat , R - 1 , C - 1 , k ) ; } int main ( ) { int k = 12 ; int mat [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; cout << pathCount ( mat , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; int minInitialPoints ( int points [ ] [ C ] ) { int dp [ R ] [ C ] ; int m = R , n = C ; dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ; for ( int i = m - 2 ; i >= 0 ; i -- ) dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) ; for ( int i = m - 2 ; i >= 0 ; i -- ) { for ( int j = n - 2 ; j >= 0 ; j -- ) { int min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ; } } return dp [ 0 ] [ 0 ] ; } int main ( ) { int points [ R ] [ C ] = { { -2 , -3 , 3 } , { -5 , -10 , 1 } , { 10 , 30 , -5 } } ; cout << " Minimum ▁ Initial ▁ Points ▁ Required : ▁ " << minInitialPoints ( points ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; node ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; void increment ( node * node , int diff ) ; void convertTree ( node * node ) { int left_data = 0 , right_data = 0 , diff ; if ( node == NULL || ( node -> left == NULL && node -> right == NULL ) ) return ; else { convertTree ( node -> left ) ; convertTree ( node -> right ) ; if ( node -> left != NULL ) left_data = node -> left -> data ; if ( node -> right != NULL ) right_data = node -> right -> data ; diff = left_data + right_data - node -> data ; if ( diff > 0 ) node -> data = node -> data + diff ; if ( diff < 0 ) increment ( node , - diff ) ; } } void increment ( node * node , int diff ) { if ( node -> left != NULL ) { node -> left -> data = node -> left -> data + diff ; increment ( node -> left , diff ) ; } else if ( node -> right != NULL ) { node -> right -> data = node -> right -> data + diff ; increment ( node -> right , diff ) ; } } void printInorder ( node * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; cout << node -> data << " ▁ " ; printInorder ( node -> right ) ; } int main ( ) { node * root = new node ( 50 ) ; root -> left = new node ( 7 ) ; root -> right = new node ( 2 ) ; root -> left -> left = new node ( 3 ) ; root -> left -> right = new node ( 5 ) ; root -> right -> left = new node ( 1 ) ; root -> right -> right = new node ( 30 ) ; cout << " Inorder traversal before conversion : " printInorder ( root ) ; convertTree ( root ) ; cout << " Inorder traversal after conversion : " printInorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Queue { stack < int > s1 , s2 ; void enQueue ( int x ) { while ( ! s1 . empty ( ) ) { s2 . push ( s1 . top ( ) ) ; s1 . pop ( ) ; } s1 . push ( x ) ; while ( ! s2 . empty ( ) ) { s1 . push ( s2 . top ( ) ) ; s2 . pop ( ) ; } } int deQueue ( ) { if ( s1 . empty ( ) ) { cout << " Q ▁ is ▁ Empty " ; exit ( 0 ) ; } int x = s1 . top ( ) ; s1 . pop ( ) ; return x ; } } ; int main ( ) { Queue q ; q . enQueue ( 1 ) ; q . enQueue ( 2 ) ; q . enQueue ( 3 ) ; cout << q . deQueue ( ) << ' ' ; cout << q . deQueue ( ) << ' ' ; cout << q . deQueue ( ) << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int key ; struct node * left , * right ; } ; void convert ( node * root ) { if ( root == NULL ) return ; convert ( root -> left ) ; convert ( root -> right ) ; if ( root -> left == NULL ) root -> left = root -> right ; else root -> left -> right = root -> right ; root -> right = NULL ; } void downRightTraversal ( node * root ) { if ( root != NULL ) { cout << root -> key << " ▁ " ; downRightTraversal ( root -> right ) ; downRightTraversal ( root -> left ) ; } } node * newNode ( int key ) { node * temp = new node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 5 ) ; root -> right -> left -> left = newNode ( 6 ) ; root -> right -> right -> left = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 8 ) ; convert ( root ) ; cout << " Traversal ▁ of ▁ the ▁ tree ▁ converted ▁ to ▁ down - right ▁ form STRNEWLINE " ; downRightTraversal ( root ) ; return 0 ; }
void SpecialStack :: push ( int x ) { if ( isEmpty ( ) == true ) { Stack :: push ( x ) ; min . push ( x ) ; } else { Stack :: push ( x ) ; int y = min . pop ( ) ; min . push ( y ) ; if ( x <= y ) min . push ( x ) ; } } int SpecialStack :: pop ( ) { int x = Stack :: pop ( ) ; int y = min . pop ( ) ; if ( y != x ) min . push ( y ) ; return x ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; } ; int toSumTree ( node * Node ) { if ( Node == NULL ) return 0 ; int old_val = Node -> data ; Node -> data = toSumTree ( Node -> left ) + toSumTree ( Node -> right ) ; return Node -> data + old_val ; } void printInorder ( node * Node ) { if ( Node == NULL ) return ; printInorder ( Node -> left ) ; cout << " ▁ " << Node -> data ; printInorder ( Node -> right ) ; } node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { node * root = NULL ; int x ; root = newNode ( 10 ) ; root -> left = newNode ( -2 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( -4 ) ; root -> right -> left = newNode ( 7 ) ; root -> right -> right = newNode ( 5 ) ; toSumTree ( root ) ; cout << " Inorder ▁ Traversal ▁ of ▁ the ▁ resultant ▁ tree ▁ is : ▁ STRNEWLINE " ; printInorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPeak ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; if ( arr [ 0 ] >= arr [ 1 ] ) return 0 ; if ( arr [ n - 1 ] >= arr [ n - 2 ] ) return n - 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] >= arr [ i - 1 ] && arr [ i ] >= arr [ i + 1 ] ) return i ; } } int main ( ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ " << findPeak ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { int sum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( sum < arr [ i ] + arr [ j ] + arr [ k ] ) sum = arr [ i ] + arr [ j ] + arr [ k ] ; return sum ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return arr [ n - 1 ] + arr [ n - 2 ] + arr [ n - 3 ] ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxTripletSum ( int arr [ ] , int n ) { int maxA = INT_MIN , maxB = INT_MIN , maxC = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; } return ( maxA + maxB + maxC ) ; } int main ( ) { int arr [ ] = { 1 , 0 , 8 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxTripletSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; sort ( A , A + arr_size ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { printf ( " Triplet ▁ is ▁ % d , ▁ % d , ▁ % d " , A [ i ] , A [ l ] , A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; } int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find3Numbers ( A , arr_size , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool find3Numbers ( int A [ ] , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { unordered_set < int > s ; int curr_sum = sum - A [ i ] ; for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( s . find ( curr_sum - A [ j ] ) != s . end ( ) ) { printf ( " Triplet ▁ is ▁ % d , ▁ % d , ▁ % d " , A [ i ] , A [ j ] , curr_sum - A [ j ] ) ; return true ; } s . insert ( A [ j ] ) ; } } return false ; } int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find3Numbers ( A , arr_size , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  10 NEW_LINE void sortMat ( int mat [ SIZE ] [ SIZE ] , int n ) { int temp [ n * n ] ; int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) temp [ k ++ ] = mat [ i ] [ j ] ; sort ( temp , temp + k ) ; k = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) mat [ i ] [ j ] = temp [ k ++ ] ; } void printMat ( int mat [ SIZE ] [ SIZE ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int mat [ SIZE ] [ SIZE ] = { { 5 , 4 , 7 } , { 1 , 3 , 8 } , { 2 , 9 , 6 } } ; int n = 3 ; cout << " Original ▁ Matrix : STRNEWLINE " ; printMat ( mat , n ) ; sortMat ( mat , n ) ; cout << " Matrix After Sorting : " ; printMat ( mat , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubsequences ( int arr [ ] , int n ) { unsigned int opsize = pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) cout << arr [ j ] << " ▁ " ; } cout << endl ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " All ▁ Non - empty ▁ Subsequences STRNEWLINE " ; printSubsequences ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void productArray ( int arr [ ] , int n ) { if ( n == 1 ) { cout << 0 ; return ; } int i , temp = 1 ; int * prod = new int [ ( sizeof ( int ) * n ) ] ; memset ( prod , 1 , n ) ; for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } temp = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) cout << prod [ i ] << " ▁ " ; return ; } int main ( ) { int arr [ ] = { 10 , 3 , 5 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ product ▁ array ▁ is : ▁ STRNEWLINE " ; productArray ( arr , n ) ; }
#include <iostream> NEW_LINE using namespace std ; long * productExceptSelf ( int a [ ] , int n ) { long prod = 1 ; long flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) flag ++ ; else prod *= a [ i ] ; } long * arr = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag > 1 ) { arr [ i ] = 0 ; } else if ( flag == 0 ) arr [ i ] = ( prod / a [ i ] ) ; else if ( flag == 1 && a [ i ] != 0 ) { arr [ i ] = 0 ; } else arr [ i ] = prod ; } return arr ; } int main ( ) { int n = 5 ; int array [ ] = { 10 , 3 , 5 , 6 , 2 } ; long * ans ; ans = productExceptSelf ( array , n ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int getMin ( int arr [ ] , int n ) ; int getMax ( int arr [ ] , int n ) ; bool areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { int j ; if ( arr [ i ] < 0 ) j = - arr [ i ] - min ; else j = arr [ i ] - min ; if ( arr [ j ] > 0 ) arr [ j ] = - arr [ j ] ; else return false ; } return true ; } return false ; } int getMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] < min ) min = arr [ i ] ; return min ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; } int main ( ) { int arr [ ] = { 1 , 4 , 5 , 3 , 2 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areConsecutive ( arr , n ) == true ) printf ( " ▁ Array ▁ elements ▁ are ▁ consecutive ▁ " ) ; else printf ( " ▁ Array ▁ elements ▁ are ▁ not ▁ consecutive ▁ " ) ; getchar ( ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { cout << arr1 [ i ] << " ▁ " ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) cout << arr1 [ i ] << " ▁ " ; } int main ( ) { int arr1 [ ] = { 3 , 6 , 10 , 12 , 15 } ; int arr2 [ ] = { 1 , 3 , 5 , 10 , 16 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; relativeComplement ( arr1 , arr2 , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOps ( int arr [ ] , int n , int k ) { int max = * max_element ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return -1 ; else res += ( max - arr [ i ] ) / k ; } return res ; } int main ( ) { int arr [ ] = { 21 , 33 , 9 , 45 , 63 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 6 ; cout << minOps ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int A [ ] , int B [ ] , int C [ ] , int i , int j , int k ) { int min_diff , current_diff , max_term ; min_diff = Integer . MAX_VALUE ; while ( i != -1 && j != -1 && k != -1 ) { current_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; } int main ( ) { int D [ ] = { 5 , 8 , 10 , 15 } ; int E [ ] = { 6 , 9 , 15 , 78 , 89 } ; int F [ ] = { 2 , 3 , 6 , 6 , 8 , 8 , 10 } ; int nD = sizeof ( D ) / sizeof ( D [ 0 ] ) ; int nE = sizeof ( E ) / sizeof ( E [ 0 ] ) ; int nF = sizeof ( F ) / sizeof ( F [ 0 ] ) ; cout << solve ( D , E , F , nD - 1 , nE - 1 , nF - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 10 , 30 , 15 } ; int x = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << x << " ▁ is ▁ present ▁ at ▁ index ▁ " << search ( arr , n , x ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void search ( vector < int > arr , int search_Element ) { int left = 0 ; int length = arr . size ( ) ; int position = -1 ; int right = length - 1 ; for ( left = 0 ; left <= right ; ) { if ( arr [ left ] == search_Element ) { position = left ; cout << " Element ▁ found ▁ in ▁ Array ▁ at ▁ " << position + 1 << " ▁ Position ▁ with ▁ " << left + 1 << " ▁ Attempt " ; break ; } if ( arr [ right ] == search_Element ) { position = right ; cout << " Element ▁ found ▁ in ▁ Array ▁ at ▁ " << position + 1 << " ▁ Position ▁ with ▁ " << length - right << " ▁ Attempt " ; break ; } left ++ ; right -- ; } if ( position == -1 ) cout << " Not ▁ found ▁ in ▁ Array ▁ with ▁ " << left << " ▁ Attempt " ; } int main ( ) { vector < int > arr { 1 , 2 , 3 , 4 , 5 } ; int search_element = 5 ; search ( arr , search_element ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? cout << " Element ▁ is ▁ not ▁ present ▁ in ▁ array " : cout << " Element ▁ is ▁ present ▁ at ▁ index ▁ " << result ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int jumpSearch ( int arr [ ] , int x , int n ) { int step = sqrt ( n ) ; int prev = 0 ; while ( arr [ min ( step , n ) - 1 ] < x ) { prev = step ; step += sqrt ( n ) ; if ( prev >= n ) return -1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == min ( step , n ) ) return -1 ; } if ( arr [ prev ] == x ) return prev ; return -1 ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 } ; int x = 55 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int index = jumpSearch ( arr , x , n ) ; cout << " Number " ▁ < < ▁ x ▁ < < ▁ " is at index " return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int interpolationSearch ( int arr [ ] , int lo , int hi , int x ) { int pos ; if ( lo <= hi && x >= arr [ lo ] && x <= arr [ hi ] ) { pos = lo + ( ( ( double ) ( hi - lo ) / ( arr [ hi ] - arr [ lo ] ) ) * ( x - arr [ lo ] ) ) ; if ( arr [ pos ] == x ) return pos ; if ( arr [ pos ] < x ) return interpolationSearch ( arr , pos + 1 , hi , x ) ; if ( arr [ pos ] > x ) return interpolationSearch ( arr , lo , pos - 1 , x ) ; } return -1 ; } int main ( ) { int arr [ ] = { 10 , 12 , 13 , 16 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 33 , 35 , 42 , 47 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 18 ; int index = interpolationSearch ( arr , 0 , n - 1 , x ) ; if ( index != -1 ) cout << " Element ▁ found ▁ at ▁ index ▁ " << index ; else cout << " Element ▁ not ▁ found . " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int , int , int ) ; int exponentialSearch ( int arr [ ] , int n , int x ) { if ( arr [ 0 ] == x ) return 0 ; int i = 1 ; while ( i < n && arr [ i ] <= x ) i = i * 2 ; return binarySearch ( arr , i / 2 , min ( i , n - 1 ) , x ) ; } int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = exponentialSearch ( arr , n , x ) ; ( result == -1 ) ? printf ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) : printf ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " , result ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int * xp , int * yp ) { int temp = * xp ; * xp = * yp ; * yp = temp ; } void selectionSort ( int arr [ ] , int n ) { int i , j , min_idx ; for ( i = 0 ; i < n - 1 ; i ++ ) { min_idx = i ; for ( j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] < arr [ min_idx ] ) min_idx = j ; swap ( & arr [ min_idx ] , & arr [ i ] ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 64 , 25 , 12 , 22 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; selectionSort ( arr , n ) ; cout << " Sorted ▁ array : ▁ STRNEWLINE " ; printArray ( arr , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE void swap ( int * xp , int * yp ) { int temp = * xp ; * xp = * yp ; * yp = temp ; } void bubbleSort ( int arr [ ] , int n ) { int i , j ; bool swapped ; for ( i = 0 ; i < n - 1 ; i ++ ) { swapped = false ; for ( j = 0 ; j < n - i - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( & arr [ j ] , & arr [ j + 1 ] ) ; swapped = true ; } } if ( swapped == false ) break ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; printf ( " n " ) ; } int main ( ) { int arr [ ] = { 64 , 34 , 25 , 12 , 22 , 11 , 90 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; bubbleSort ( arr , n ) ; printf ( " Sorted ▁ array : ▁ STRNEWLINE " ) ; printArray ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void merge ( int arr [ ] , int l , int m , int r ) { int n1 = m - l + 1 ; int n2 = r - m ; int L [ n1 ] , R [ n2 ] ; for ( int i = 0 ; i < n1 ; i ++ ) L [ i ] = arr [ l + i ] ; for ( int j = 0 ; j < n2 ; j ++ ) R [ j ] = arr [ m + 1 + j ] ; int i = 0 ; int j = 0 ; int k = l ; while ( i < n1 && j < n2 ) { if ( L [ i ] <= R [ j ] ) { arr [ k ] = L [ i ] ; i ++ ; } else { arr [ k ] = R [ j ] ; j ++ ; } k ++ ; } while ( i < n1 ) { arr [ k ] = L [ i ] ; i ++ ; k ++ ; } while ( j < n2 ) { arr [ k ] = R [ j ] ; j ++ ; k ++ ; } } void mergeSort ( int arr [ ] , int l , int r ) { if ( l >= r ) { return ; } int m = l + ( r - l ) / 2 ; mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } void printArray ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << A [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Given ▁ array ▁ is ▁ STRNEWLINE " ; printArray ( arr , arr_size ) ; mergeSort ( arr , 0 , arr_size - 1 ) ; cout << " Sorted array is " ; printArray ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int * a , int * b ) { int t = * a ; * a = * b ; * b = t ; } int partition ( int arr [ ] , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j <= high - 1 ; j ++ ) { if ( arr [ j ] < pivot ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ high ] ) ; return ( i + 1 ) ; } void quickSort ( int arr [ ] , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi - 1 ) ; quickSort ( arr , pi + 1 , high ) ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 10 , 7 , 8 , 9 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; quickSort ( arr , 0 , n - 1 ) ; cout << " Sorted ▁ array : ▁ STRNEWLINE " ; printArray ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int getMax ( int arr [ ] , int n ) { int mx = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > mx ) mx = arr [ i ] ; return mx ; } void countSort ( int arr [ ] , int n , int exp ) { int output [ n ] ; int i , count [ 10 ] = { 0 } ; for ( i = 0 ; i < n ; i ++ ) count [ ( arr [ i ] / exp ) % 10 ] ++ ; for ( i = 1 ; i < 10 ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( i = n - 1 ; i >= 0 ; i -- ) { output [ count [ ( arr [ i ] / exp ) % 10 ] - 1 ] = arr [ i ] ; count [ ( arr [ i ] / exp ) % 10 ] -- ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = output [ i ] ; } void radixsort ( int arr [ ] , int n ) { int m = getMax ( arr , n ) ; for ( int exp = 1 ; m / exp > 0 ; exp *= 10 ) countSort ( arr , n , exp ) ; } void print ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 170 , 45 , 75 , 90 , 802 , 24 , 2 , 66 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; radixsort ( arr , n ) ; print ( arr , n ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void bucketSort ( float arr [ ] , int n ) { vector < float > b [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int bi = n * arr [ i ] ; b [ bi ] . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) sort ( b [ i ] . begin ( ) , b [ i ] . end ( ) ) ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < b [ i ] . size ( ) ; j ++ ) arr [ index ++ ] = b [ i ] [ j ] ; } int main ( ) { float arr [ ] = { 0.897 , 0.565 , 0.656 , 0.1234 , 0.665 , 0.3434 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; bucketSort ( arr , n ) ; cout << " Sorted ▁ array ▁ is ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int shellSort ( int arr [ ] , int n ) { for ( int gap = n / 2 ; gap > 0 ; gap /= 2 ) { for ( int i = gap ; i < n ; i += 1 ) { int temp = arr [ i ] ; int j ; for ( j = i ; j >= gap && arr [ j - gap ] > temp ; j -= gap ) arr [ j ] = arr [ j - gap ] ; arr [ j ] = temp ; } } return 0 ; } int main ( ) { int arr [ ] = { 12 , 34 , 54 , 2 , 3 } , i ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Array ▁ before ▁ sorting : ▁ STRNEWLINE " ; printArray ( arr , n ) ; shellSort ( arr , n ) ; cout << " Array after sorting : " ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getNextGap ( int gap ) { gap = ( gap * 10 ) / 13 ; if ( gap < 1 ) return 1 ; return gap ; } void combSort ( int a [ ] , int n ) { int gap = n ; bool swapped = true ; while ( gap != 1 swapped == true ) { gap = getNextGap ( gap ) ; swapped = false ; for ( int i = 0 ; i < n - gap ; i ++ ) { if ( a [ i ] > a [ i + gap ] ) { swap ( a [ i ] , a [ i + gap ] ) ; swapped = true ; } } } } int main ( ) { int a [ ] = { 8 , 4 , 1 , 56 , 3 , -44 , 23 , -6 , 28 , 0 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; combSort ( a , n ) ; printf ( " Sorted ▁ array : ▁ STRNEWLINE " ) ; for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , a [ i ] ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } int partition ( int arr [ ] , int l , int h ) { int x = arr [ h ] ; int i = ( l - 1 ) ; for ( int j = l ; j <= h - 1 ; j ++ ) { if ( arr [ j ] <= x ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ h ] ) ; return ( i + 1 ) ; } void quickSort ( int A [ ] , int l , int h ) { if ( l < h ) { int p = partition ( A , l , h ) ; quickSort ( A , l , p - 1 ) ; quickSort ( A , p + 1 , h ) ; } } int main ( ) { int n = 5 ; int arr [ n ] = { 4 , 2 , 6 , 9 , 2 } ; quickSort ( arr , 0 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int * a , int * b ) { int t = * a ; * a = * b ; * b = t ; } int partition ( int arr [ ] , int l , int h ) { int x = arr [ h ] ; int i = ( l - 1 ) ; for ( int j = l ; j <= h - 1 ; j ++ ) { if ( arr [ j ] <= x ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ h ] ) ; return ( i + 1 ) ; } void quickSortIterative ( int arr [ ] , int l , int h ) { int stack [ h - l + 1 ] ; int top = -1 ; stack [ ++ top ] = l ; stack [ ++ top ] = h ; while ( top >= 0 ) { h = stack [ top -- ] ; l = stack [ top -- ] ; int p = partition ( arr , l , h ) ; if ( p - 1 > l ) { stack [ ++ top ] = l ; stack [ ++ top ] = p - 1 ; } if ( p + 1 < h ) { stack [ ++ top ] = p + 1 ; stack [ ++ top ] = h ; } } } void printArr ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( * arr ) ; quickSortIterative ( arr , 0 , n - 1 ) ; printArr ( arr , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE int findCrossOver ( int arr [ ] , int low , int high , int x ) { if ( arr [ high ] <= x ) return high ; if ( arr [ low ] > x ) return low ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] <= x && arr [ mid + 1 ] > x ) return mid ; if ( arr [ mid ] < x ) return findCrossOver ( arr , mid + 1 , high , x ) ; return findCrossOver ( arr , low , mid - 1 , x ) ; } void printKclosest ( int arr [ ] , int x , int k , int n ) { int l = findCrossOver ( arr , 0 , n - 1 , x ) ; int r = l + 1 ; int count = 0 ; if ( arr [ l ] == x ) l -- ; while ( l >= 0 && r < n && count < k ) { if ( x - arr [ l ] < arr [ r ] - x ) printf ( " % d ▁ " , arr [ l -- ] ) ; else printf ( " % d ▁ " , arr [ r ++ ] ) ; count ++ ; } while ( count < k && l >= 0 ) printf ( " % d ▁ " , arr [ l -- ] ) , count ++ ; while ( count < k && r < n ) printf ( " % d ▁ " , arr [ r ++ ] ) , count ++ ; } int main ( ) { int arr [ ] = { 12 , 16 , 22 , 30 , 35 , 39 , 42 , 45 , 48 , 50 , 53 , 55 , 56 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 35 , k = 4 ; printKclosest ( arr , x , 4 , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSort ( int arr [ ] , int n , int exp ) { int output [ n ] ; int i , count [ n ] ; for ( int i = 0 ; i < n ; i ++ ) count [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) count [ ( arr [ i ] / exp ) % n ] ++ ; for ( i = 1 ; i < n ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( i = n - 1 ; i >= 0 ; i -- ) { output [ count [ ( arr [ i ] / exp ) % n ] - 1 ] = arr [ i ] ; count [ ( arr [ i ] / exp ) % n ] -- ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = output [ i ] ; } void sort ( int arr [ ] , int n ) { countSort ( arr , n , 1 ) ; countSort ( arr , n , n ) ; } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 40 , 12 , 45 , 32 , 33 , 1 , 22 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Given ▁ array ▁ is ▁ n " ; printArr ( arr , n ) ; sort ( arr , n ) ; cout << " nSorted ▁ array ▁ is ▁ n " ; printArr ( arr , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; return binarySearch ( arr , mid + 2 , r , x ) ; } return -1 ; } int main ( void ) { int arr [ ] = { 3 , 2 , 10 , 4 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 4 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) : printf ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " , result ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r ; int l = 0 , r = n - 1 , diff = INT_MAX ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } cout << " ▁ The ▁ closest ▁ pair ▁ is ▁ " << arr [ res_l ] << " ▁ and ▁ " << arr [ res_r ] ; } int main ( ) { int arr [ ] = { 10 , 22 , 28 , 29 , 30 , 40 } , x = 54 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printClosest ( arr , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; } int main ( ) { bool arr [ ] = { 1 , 1 , 1 , 1 , 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is ▁ " << countOnes ( arr , 0 , n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int a [ ] , int n ) { int maxx = -1 , minn = a [ 0 ] , l = 0 , r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxx ) { maxx = a [ i ] ; l = i ; } if ( a [ i ] <= minn ) { minn = a [ i ] ; r = i ; } } if ( r < l ) cout << l + ( n - r - 2 ) ; else cout << l + ( n - r - 1 ) ; } int main ( ) { int a [ ] = { 5 , 6 , 1 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; solve ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SelectActivities ( vector < int > s , vector < int > f ) { vector < pair < int , int > > ans ; priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > p ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { p . push ( make_pair ( f [ i ] , s [ i ] ) ) ; } auto it = p . top ( ) ; int start = it . second ; int end = it . first ; p . pop ( ) ; ans . push_back ( make_pair ( start , end ) ) ; while ( ! p . empty ( ) ) { auto itr = p . top ( ) ; p . pop ( ) ; if ( itr . second >= end ) { start = itr . second ; end = itr . first ; ans . push_back ( make_pair ( start , end ) ) ; } } cout << " Following ▁ Activities ▁ should ▁ be ▁ selected . ▁ " << endl << endl ; for ( auto itr = ans . begin ( ) ; itr != ans . end ( ) ; itr ++ ) { cout << " Activity ▁ started ▁ at : ▁ " << ( * itr ) . first << " ▁ and ▁ ends ▁ at ▁ " << ( * itr ) . second << endl ; } } int main ( ) { vector < int > s = { 1 , 3 , 0 , 5 , 8 , 5 } ; vector < int > f = { 2 , 4 , 6 , 7 , 9 , 9 } ; SelectActivities ( s , f ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int _lis ( int arr [ ] , int n , int * max_ref ) { if ( n == 1 ) return 1 ; int res , max_ending_here = 1 ; for ( int i = 1 ; i < n ; i ++ ) { res = _lis ( arr , i , max_ref ) ; if ( arr [ i - 1 ] < arr [ n - 1 ] && res + 1 > max_ending_here ) max_ending_here = res + 1 ; } if ( * max_ref < max_ending_here ) * max_ref = max_ending_here ; return max_ending_here ; } int lis ( int arr [ ] , int n ) { int max = 1 ; _lis ( arr , n , & max ) ; return max ; } int main ( ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Length ▁ of ▁ lis ▁ is ▁ % d " , lis ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lis ( int arr [ ] , int n ) { int lis [ n ] ; lis [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { lis [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } return * max_element ( lis , lis + n ) ; } int main ( ) { int arr [ ] = { 10 , 22 , 9 , 33 , 21 , 50 , 41 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Length ▁ of ▁ lis ▁ is ▁ % d STRNEWLINE " , lis ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max ( int a , int b ) ; int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } int main ( ) { char X [ ] = " AGGTAB " ; char Y [ ] = " GXTXAYB " ; int m = strlen ( X ) ; int n = strlen ( Y ) ; cout << " Length ▁ of ▁ LCS ▁ is ▁ " << lcs ( X , Y , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max ( int a , int b ) ; int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } int main ( ) { char X [ ] = " AGGTAB " ; char Y [ ] = " GXTXAYB " ; int m = strlen ( X ) ; int n = strlen ( Y ) ; cout << " Length ▁ of ▁ LCS ▁ is ▁ " << lcs ( X , Y , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void EditDistDP ( string str1 , string str2 ) { int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; int DP [ 2 ] [ len1 + 1 ] ; memset ( DP , 0 , sizeof DP ) ; for ( int i = 0 ; i <= len1 ; i ++ ) DP [ 0 ] [ i ] = i ; for ( int i = 1 ; i <= len2 ; i ++ ) { for ( int j = 0 ; j <= len1 ; j ++ ) { if ( j == 0 ) DP [ i % 2 ] [ j ] = i ; else if ( str1 [ j - 1 ] == str2 [ i - 1 ] ) { DP [ i % 2 ] [ j ] = DP [ ( i - 1 ) % 2 ] [ j - 1 ] ; } else { DP [ i % 2 ] [ j ] = 1 + min ( DP [ ( i - 1 ) % 2 ] [ j ] , min ( DP [ i % 2 ] [ j - 1 ] , DP [ ( i - 1 ) % 2 ] [ j - 1 ] ) ) ; } } } cout << DP [ len2 % 2 ] [ len1 ] << endl ; } int main ( ) { string str1 = " food " ; string str2 = " money " ; EditDistDP ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDis ( string s1 , string s2 , int n , int m , vector < vector < int > > & dp ) { if ( n == 0 ) return m ; if ( m == 0 ) return n ; if ( dp [ n ] [ m ] != -1 ) return dp [ n ] [ m ] ; if ( s1 [ n - 1 ] == s2 [ m - 1 ] ) { if ( dp [ n - 1 ] [ m - 1 ] == -1 ) { return dp [ n ] [ m ] = minDis ( s1 , s2 , n - 1 , m - 1 , dp ) ; } else return dp [ n ] [ m ] = dp [ n - 1 ] [ m - 1 ] ; } else { int m1 , m2 , m3 ; if ( dp [ n - 1 ] [ m ] != -1 ) { m1 = dp [ n - 1 ] [ m ] ; } else { m1 = minDis ( s1 , s2 , n - 1 , m , dp ) ; } if ( dp [ n ] [ m - 1 ] != -1 ) { m2 = dp [ n ] [ m - 1 ] ; } else { m2 = minDis ( s1 , s2 , n , m - 1 , dp ) ; } if ( dp [ n - 1 ] [ m - 1 ] != -1 ) { m3 = dp [ n - 1 ] [ m - 1 ] ; } else { m3 = minDis ( s1 , s2 , n - 1 , m - 1 , dp ) ; } return dp [ n ] [ m ] = 1 + min ( m1 , min ( m2 , m3 ) ) ; } } int main ( ) { string str1 = " voldemort " ; string str2 = " dumbledore " ; int n = str1 . length ( ) , m = str2 . length ( ) ; vector < vector < int > > dp ( n + 1 , vector < int > ( m + 1 , -1 ) ) ; cout << minDis ( str1 , str2 , n , m , dp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define endl  " NEW_LINE " using namespace std ; const int row = 3 ; const int col = 3 ; int minCost ( int cost [ row ] [ col ] ) { for ( int i = 1 ; i < row ; i ++ ) { cost [ i ] [ 0 ] += cost [ i - 1 ] [ 0 ] ; } for ( int j = 1 ; j < col ; j ++ ) { cost [ 0 ] [ j ] += cost [ 0 ] [ j - 1 ] ; } for ( int i = 1 ; i < row ; i ++ ) { for ( int j = 1 ; j < col ; j ++ ) { cost [ i ] [ j ] += min ( cost [ i - 1 ] [ j - 1 ] , min ( cost [ i - 1 ] [ j ] , cost [ i ] [ j - 1 ] ) ) ; } } return cost [ row - 1 ] [ col - 1 ] ; } int main ( int argc , char const * argv [ ] ) { int cost [ row ] [ col ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; cout << minCost ( cost ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE int count ( int S [ ] , int m , int n ) { int table [ n + 1 ] ; memset ( table , 0 , sizeof ( table ) ) ; table [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = S [ i ] ; j <= n ; j ++ ) table [ j ] += table [ j - S [ i ] ] ; return table [ n ] ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100 ] [ 100 ] ; int matrixChainMemoised ( int * p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } int MatrixChainOrder ( int * p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; memset ( dp , -1 , sizeof dp ) ; cout << " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " << MatrixChainOrder ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int main ( ) { int n = 5 , k = 2 ; printf ( " Value ▁ of ▁ C ( % d , ▁ % d ) ▁ is ▁ % d ▁ " , n , k , binomialCoeff ( n , k ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } int main ( ) { int n = 5 , r = 2 ; cout << " Value ▁ of ▁ C ( " << n << " , ▁ " << r << " ) ▁ is ▁ " << binomialCoeff ( n , r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max ( int a , int b ) { return ( a > b ) ? a : b ; } int eggDrop ( int n , int k ) { if ( k == 1 k == 0 ) return k ; if ( n == 1 ) return k ; int min = INT_MAX , x , res ; for ( x = 1 ; x <= k ; x ++ ) { res = max ( eggDrop ( n - 1 , x - 1 ) , eggDrop ( n , k - x ) ) ; if ( res < min ) min = res ; } return min + 1 ; } int main ( ) { int n = 2 , k = 10 ; cout << " Minimum ▁ number ▁ of ▁ trials ▁ " " in ▁ worst ▁ case ▁ with ▁ " << n << " ▁ eggs ▁ and ▁ " << k << " ▁ floors ▁ is ▁ " << eggDrop ( n , k ) << endl ; return 0 ; }
#include <limits.h> NEW_LINE #include <stdio.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int eggDrop ( int n , int k ) { int eggFloor [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; } int main ( ) { int n = 2 , k = 36 ; printf ( " Minimum number of trials " STRNEWLINE TABSYMBOL TABSYMBOL " in worst case with % d eggs and " STRNEWLINE TABSYMBOL TABSYMBOL " % d floors is % d " , n , k , eggDrop ( n , k ) ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE int max ( int x , int y ) { return ( x > y ) ? x : y ; } int lps ( char * str ) { int n = strlen ( str ) ; int i , j , cl ; int L [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } int main ( ) { char seq [ ] = " GEEKS ▁ FOR ▁ GEEKS " ; int n = strlen ( seq ) ; printf ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d " , lps ( seq ) ) ; getchar ( ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cutRod ( int price [ ] , int n ) { if ( n <= 0 ) return 0 ; int max_val = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) max_val = max ( max_val , price [ i ] + cutRod ( price , n - i - 1 ) ) ; return max_val ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Maximum ▁ Obtainable ▁ Value ▁ is ▁ % dn " , cutRod ( arr , size ) ) ; getchar ( ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int lbs ( int arr [ ] , int n ) { int i , j ; int * lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int * lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; } int main ( ) { int arr [ ] = { 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Length ▁ of ▁ LBS ▁ is ▁ % d STRNEWLINE " , lbs ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string String , int i , int j ) { while ( i < j ) { if ( String [ i ] != String [ j ] ) return false ; i ++ ; j -- ; } return true ; } int minPalPartion ( string String , int i , int j ) { if ( i >= j || isPalindrome ( String , i , j ) ) return 0 ; int ans = INT_MAX , count ; for ( int k = i ; k < j ; k ++ ) { count = minPalPartion ( String , i , k ) + minPalPartion ( String , k + 1 , j ) + 1 ; ans = min ( ans , count ) ; } return ans ; } int main ( ) { string str = " ababbbabbababa " ; cout << " Min ▁ cuts ▁ needed ▁ for ▁ " << " Palindrome ▁ Partitioning ▁ is ▁ " << minPalPartion ( str , 0 , str . length ( ) - 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCut ( string a ) { int cut [ a . length ( ) ] ; bool palindrome [ a . length ( ) ] [ a . length ( ) ] ; memset ( palindrome , false , sizeof ( palindrome ) ) ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { int minCut = i ; for ( int j = 0 ; j <= i ; j ++ ) { if ( a [ i ] == a [ j ] && ( i - j < 2 palindrome [ j + 1 ] [ i - 1 ] ) ) { palindrome [ j ] [ i ] = true ; minCut = min ( minCut , j == 0 ? 0 : ( cut [ j - 1 ] + 1 ) ) ; } } cut [ i ] = minCut ; } return cut [ a . length ( ) - 1 ] ; } int main ( ) { cout << minCut ( " aab " ) << endl ; cout << minCut ( " aabababaxx " ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; j -- ) { if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << " Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ " " sum " ; else cout << " Can ▁ not ▁ be ▁ divided ▁ into " << " ▁ two ▁ subsets ▁ of ▁ equal ▁ sum " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INF  INT_MAX NEW_LINE int printSolution ( int p [ ] , int n ) ; int printSolution ( int p [ ] , int n ) { int k ; if ( p [ n ] == 1 ) k = 1 ; else k = printSolution ( p , p [ n ] - 1 ) + 1 ; cout << " Line ▁ number ▁ " << k << " : ▁ From ▁ word ▁ no . ▁ " << p [ n ] << " ▁ to ▁ " << n << endl ; return k ; } void solveWordWrap ( int l [ ] , int n , int M ) { int extras [ n + 1 ] [ n + 1 ] ; int lc [ n + 1 ] [ n + 1 ] ; int c [ n + 1 ] ; int p [ n + 1 ] ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { extras [ i ] [ i ] = M - l [ i - 1 ] ; for ( j = i + 1 ; j <= n ; j ++ ) extras [ i ] [ j ] = extras [ i ] [ j - 1 ] - l [ j - 1 ] - 1 ; } for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j ++ ) { if ( extras [ i ] [ j ] < 0 ) lc [ i ] [ j ] = INF ; else if ( j == n && extras [ i ] [ j ] >= 0 ) lc [ i ] [ j ] = 0 ; else lc [ i ] [ j ] = extras [ i ] [ j ] * extras [ i ] [ j ] ; } } c [ 0 ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { c [ j ] = INF ; for ( i = 1 ; i <= j ; i ++ ) { if ( c [ i - 1 ] != INF && lc [ i ] [ j ] != INF && ( c [ i - 1 ] + lc [ i ] [ j ] < c [ j ] ) ) { c [ j ] = c [ i - 1 ] + lc [ i ] [ j ] ; p [ j ] = i ; } } } printSolution ( p , n ) ; } int main ( ) { int l [ ] = { 3 , 2 , 2 , 5 } ; int n = sizeof ( l ) / sizeof ( l [ 0 ] ) ; int M = 6 ; solveWordWrap ( l , n , M ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int maxDivide ( int a , int b ) { while ( a % b == 0 ) a = a / b ; return a ; } int isUgly ( int no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ? 1 : 0 ; } int getNthUglyNo ( int n ) { int i = 1 ; int count = 1 ; while ( n > count ) { i ++ ; if ( isUgly ( i ) ) count ++ ; } return i ; } int main ( ) { unsigned no = getNthUglyNo ( 150 ) ; printf ( "150th ▁ ugly ▁ no . ▁ is ▁ % d ▁ " , no ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubStr ( string str , int low , int high ) { for ( int i = low ; i <= high ; ++ i ) cout << str [ i ] ; } int longestPalSubstr ( string str ) { int n = str . size ( ) ; int maxLength = 1 , start = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = i ; j < str . length ( ) ; j ++ ) { int flag = 1 ; for ( int k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str [ i + k ] != str [ j - k ] ) flag = 0 ; if ( flag && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } cout << " Longest ▁ palindrome ▁ substring ▁ is : ▁ " ; printSubStr ( str , start , start + maxLength - 1 ) ; return maxLength ; } int main ( ) { string str = " forgeeksskeegfor " ; cout << " Length is : " << longestPalSubstr ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubStr ( string str , int low , int high ) { for ( int i = low ; i <= high ; ++ i ) cout << str [ i ] ; } int longestPalSubstr ( string str ) { int n = str . size ( ) ; bool table [ n ] [ n ] ; memset ( table , 0 , sizeof ( table ) ) ; int maxLength = 1 ; for ( int i = 0 ; i < n ; ++ i ) table [ i ] [ i ] = true ; int start = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( str [ i ] == str [ i + 1 ] ) { table [ i ] [ i + 1 ] = true ; start = i ; maxLength = 2 ; } } for ( int k = 3 ; k <= n ; ++ k ) { for ( int i = 0 ; i < n - k + 1 ; ++ i ) { int j = i + k - 1 ; if ( table [ i + 1 ] [ j - 1 ] && str [ i ] == str [ j ] ) { table [ i ] [ j ] = true ; if ( k > maxLength ) { start = i ; maxLength = k ; } } } } cout << " Longest ▁ palindrome ▁ substring ▁ is : ▁ " ; printSubStr ( str , start , start + maxLength - 1 ) ; return maxLength ; } int main ( ) { string str = " forgeeksskeegfor " ; cout << " Length is : " << longestPalSubstr ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; } int optCost ( int freq [ ] , int i , int j ) { if ( j < i ) return 0 ; if ( j == i ) return freq [ i ] ; int fsum = sum ( freq , i , j ) ; int min = INT_MAX ; for ( int r = i ; r <= j ; ++ r ) { int cost = optCost ( freq , i , r - 1 ) + optCost ( freq , r + 1 , j ) ; if ( cost < min ) min = cost ; } return min + fsum ; } int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { return optCost ( freq , 0 , n - 1 ) ; } int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; cout << " Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ " << optimalSearchTree ( keys , freq , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int freq [ ] , int i , int j ) { int s = 0 ; for ( int k = i ; k <= j ; k ++ ) s += freq [ k ] ; return s ; } int optimalSearchTree ( int keys [ ] , int freq [ ] , int n ) { int cost [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) cost [ i ] [ i ] = freq [ i ] ; for ( int L = 2 ; L <= n ; L ++ ) { for ( int i = 0 ; i <= n - L + 1 ; i ++ ) { int j = i + L - 1 ; cost [ i ] [ j ] = INT_MAX ; for ( int r = i ; r <= j ; r ++ ) { int c = ( ( r > i ) ? cost [ i ] [ r - 1 ] : 0 ) + ( ( r < j ) ? cost [ r + 1 ] [ j ] : 0 ) + sum ( freq , i , j ) ; if ( c < cost [ i ] [ j ] ) cost [ i ] [ j ] = c ; } } } return cost [ 0 ] [ n - 1 ] ; } int main ( ) { int keys [ ] = { 10 , 12 , 20 } ; int freq [ ] = { 34 , 8 , 50 } ; int n = sizeof ( keys ) / sizeof ( keys [ 0 ] ) ; cout << " Cost ▁ of ▁ Optimal ▁ BST ▁ is ▁ " << optimalSearchTree ( keys , freq , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max ( int x , int y ) { return ( x > y ) ? x : y ; } class node { public : int data ; node * left , * right ; } ; int LISS ( node * root ) { if ( root == NULL ) return 0 ; int size_excl = LISS ( root -> left ) + LISS ( root -> right ) ; int size_incl = 1 ; if ( root -> left ) size_incl += LISS ( root -> left -> left ) + LISS ( root -> left -> right ) ; if ( root -> right ) size_incl += LISS ( root -> right -> left ) + LISS ( root -> right -> right ) ; return max ( size_incl , size_excl ) ; } node * newNode ( int data ) { node * temp = new node ( ) ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; root -> right = newNode ( 22 ) ; root -> right -> right = newNode ( 25 ) ; cout << " Size ▁ of ▁ the ▁ Largest " << " ▁ Independent ▁ Set ▁ is ▁ " << LISS ( root ) ; return 0 ; }
#include <stdio.h> NEW_LINE bool isSubsetSum ( int set [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 ) return false ; if ( set [ n - 1 ] > sum ) return isSubsetSum ( set , n - 1 , sum ) ; return isSubsetSum ( set , n - 1 , sum ) || isSubsetSum ( set , n - 1 , sum - set [ n - 1 ] ) ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( " Found ▁ a ▁ subset ▁ with ▁ given ▁ sum " ) ; else printf ( " No ▁ subset ▁ with ▁ given ▁ sum " ) ; return 0 ; }
#include <stdio.h> NEW_LINE bool isSubsetSum ( int set [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= sum ; j ++ ) printf ( " % 4d " , subset [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } return subset [ n ] [ sum ] ; } int main ( ) { int set [ ] = { 3 , 34 , 4 , 12 , 5 , 2 } ; int sum = 9 ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; if ( isSubsetSum ( set , n , sum ) == true ) printf ( " Found ▁ a ▁ subset ▁ with ▁ given ▁ sum " ) ; else printf ( " No ▁ subset ▁ with ▁ given ▁ sum " ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int countParenth ( char symb [ ] , char oper [ ] , int n ) { int F [ n ] [ n ] , T [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { F [ i ] [ i ] = ( symb [ i ] == ' F ' ) ? 1 : 0 ; T [ i ] [ i ] = ( symb [ i ] == ' T ' ) ? 1 : 0 ; } for ( int gap = 1 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { T [ i ] [ j ] = F [ i ] [ j ] = 0 ; for ( int g = 0 ; g < gap ; g ++ ) { int k = i + g ; int tik = T [ i ] [ k ] + F [ i ] [ k ] ; int tkj = T [ k + 1 ] [ j ] + F [ k + 1 ] [ j ] ; if ( oper [ k ] == ' & ' ) { T [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] ; F [ i ] [ j ] += ( tik * tkj - T [ i ] [ k ] * T [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ▁ ' ) { F [ i ] [ j ] += F [ i ] [ k ] * F [ k + 1 ] [ j ] ; T [ i ] [ j ] += ( tik * tkj - F [ i ] [ k ] * F [ k + 1 ] [ j ] ) ; } if ( oper [ k ] == ' ^ ' ) { T [ i ] [ j ] += F [ i ] [ k ] * T [ k + 1 ] [ j ] + T [ i ] [ k ] * F [ k + 1 ] [ j ] ; F [ i ] [ j ] += T [ i ] [ k ] * T [ k + 1 ] [ j ] + F [ i ] [ k ] * F [ k + 1 ] [ j ] ; } } } } return T [ 0 ] [ n - 1 ] ; } int main ( ) { char symbols [ ] = " TTFT " ; char operators [ ] = " | & ^ " ; int n = strlen ( symbols ) ; cout << countParenth ( symbols , operators , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( char keypad [ ] [ 3 ] , int n ) { if ( keypad == NULL n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int odd [ 10 ] , even [ 10 ] ; int i = 0 , j = 0 , useOdd = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) odd [ i ] = 1 ; for ( j = 2 ; j <= n ; j ++ ) { useOdd = 1 - useOdd ; if ( useOdd == 1 ) { even [ 0 ] = odd [ 0 ] + odd [ 8 ] ; even [ 1 ] = odd [ 1 ] + odd [ 2 ] + odd [ 4 ] ; even [ 2 ] = odd [ 2 ] + odd [ 1 ] + odd [ 3 ] + odd [ 5 ] ; even [ 3 ] = odd [ 3 ] + odd [ 2 ] + odd [ 6 ] ; even [ 4 ] = odd [ 4 ] + odd [ 1 ] + odd [ 5 ] + odd [ 7 ] ; even [ 5 ] = odd [ 5 ] + odd [ 2 ] + odd [ 4 ] + odd [ 8 ] + odd [ 6 ] ; even [ 6 ] = odd [ 6 ] + odd [ 3 ] + odd [ 5 ] + odd [ 9 ] ; even [ 7 ] = odd [ 7 ] + odd [ 4 ] + odd [ 8 ] ; even [ 8 ] = odd [ 8 ] + odd [ 0 ] + odd [ 5 ] + odd [ 7 ] + odd [ 9 ] ; even [ 9 ] = odd [ 9 ] + odd [ 6 ] + odd [ 8 ] ; } else { odd [ 0 ] = even [ 0 ] + even [ 8 ] ; odd [ 1 ] = even [ 1 ] + even [ 2 ] + even [ 4 ] ; odd [ 2 ] = even [ 2 ] + even [ 1 ] + even [ 3 ] + even [ 5 ] ; odd [ 3 ] = even [ 3 ] + even [ 2 ] + even [ 6 ] ; odd [ 4 ] = even [ 4 ] + even [ 1 ] + even [ 5 ] + even [ 7 ] ; odd [ 5 ] = even [ 5 ] + even [ 2 ] + even [ 4 ] + even [ 8 ] + even [ 6 ] ; odd [ 6 ] = even [ 6 ] + even [ 3 ] + even [ 5 ] + even [ 9 ] ; odd [ 7 ] = even [ 7 ] + even [ 4 ] + even [ 8 ] ; odd [ 8 ] = even [ 8 ] + even [ 0 ] + even [ 5 ] + even [ 7 ] + even [ 9 ] ; odd [ 9 ] = even [ 9 ] + even [ 6 ] + even [ 8 ] ; } } totalCount = 0 ; if ( useOdd == 1 ) { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += even [ i ] ; } else { for ( i = 0 ; i <= 9 ; i ++ ) totalCount += odd [ i ] ; } return totalCount ; } int main ( ) { char keypad [ 4 ] [ 3 ] = { { '1' , '2' , '3' } , { '4' , '5' , '6' } , { '7' , '8' , '9' } , { ' * ' , '0' , ' # ' } } ; cout << " Count ▁ for ▁ numbers ▁ of ▁ length ▁ 1 : ▁ " << getCount ( keypad , 1 ) << endl ; cout << " Count ▁ for ▁ numbers ▁ of ▁ length ▁ 2 : ▁ " << getCount ( keypad , 2 ) << endl ; cout << " Count ▁ for ▁ numbers ▁ of ▁ length ▁ 3 : ▁ " << getCount ( keypad , 3 ) << endl ; cout << " Count ▁ for ▁ numbers ▁ of ▁ length ▁ 4 : ▁ " << getCount ( keypad , 4 ) << endl ; cout << " Count ▁ for ▁ numbers ▁ of ▁ length ▁ 5 : ▁ " << getCount ( keypad , 5 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long int lookup [ 101 ] [ 501 ] ; unsigned long long int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ; if ( lookup [ n ] [ sum ] != -1 ) return lookup [ n ] [ sum ] ; unsigned long long int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return lookup [ n ] [ sum ] = ans ; } unsigned long long int finalCount ( int n , int sum ) { memset ( lookup , -1 , sizeof lookup ) ; unsigned long long int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } int main ( ) { int n = 3 , sum = 5 ; cout << finalCount ( n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countNonDecreasing ( int n ) { long long int dp [ 10 ] [ n + 1 ] ; memset ( dp , 0 , sizeof dp ) ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } long long int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; } int main ( ) { int n = 3 ; cout << countNonDecreasing ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countNonDecreasing ( int n ) { int N = 10 ; long long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; } int main ( ) { int n = 3 ; cout << countNonDecreasing ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int * dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= ceil ( sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; delete [ ] dp ; return res ; } int main ( ) { cout << getMinSquares ( 6 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numSquares ( int n ) { vector < int > visited ( n + 1 , 0 ) ; queue < pair < int , int > > q ; int ans = INT_MAX ; q . push ( { n , 0 } ) ; visited [ n ] = 1 ; while ( ! q . empty ( ) ) { pair < int , int > p ; p = q . front ( ) ; q . pop ( ) ; if ( p . first == 0 ) ans = min ( ans , p . second ) ; for ( int i = 1 ; i * i <= p . first ; i ++ ) { int path = ( p . first - ( i * i ) ) ; if ( path >= 0 && ( ! visited [ path ] path == 0 ) ) { visited [ path ] = 1 ; q . push ( { path , p . second + 1 } ) ; } } } return ans ; } int main ( ) { cout << numSquares ( 12 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCoins ( int coins [ ] , int m , int V ) { if ( V == 0 ) return 0 ; int res = INT_MAX ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != INT_MAX && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; } int main ( ) { int coins [ ] = { 9 , 6 , 5 , 1 } ; int m = sizeof ( coins ) / sizeof ( coins [ 0 ] ) ; int V = 11 ; cout << " Minimum ▁ coins ▁ required ▁ is ▁ " << minCoins ( coins , m , V ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCoins ( int coins [ ] , int m , int V ) { int table [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = INT_MAX ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != INT_MAX && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == INT_MAX ) return -1 ; return table [ V ] ; } int main ( ) { int coins [ ] = { 9 , 6 , 5 , 1 } ; int m = sizeof ( coins ) / sizeof ( coins [ 0 ] ) ; int V = 11 ; cout << " Minimum ▁ coins ▁ required ▁ is ▁ " << minCoins ( coins , m , V ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int superSeq ( char * X , char * Y , int m , int n ) { if ( ! m ) return n ; if ( ! n ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; } int main ( ) { char X [ ] = " AGGTAB " ; char Y [ ] = " GXTXAYB " ; cout << " Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is ▁ " << superSeq ( X , Y , strlen ( X ) , strlen ( Y ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int superSeq ( char * X , char * Y , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( ! i ) dp [ i ] [ j ] = j ; else if ( ! j ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; } int main ( ) { char X [ ] = " AGGTAB " ; char Y [ ] = " GXTXAYB " ; cout << " Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is ▁ " << superSeq ( X , Y , strlen ( X ) , strlen ( Y ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigits ( int ) ; int sumOfDigitsFrom1ToN ( int n ) { int result = 0 ; for ( int x = 1 ; x <= n ; x ++ ) result += sumOfDigits ( x ) ; return result ; } int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; } int main ( ) { int n = 328 ; cout << " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ is ▁ " << sumOfDigitsFrom1ToN ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return n * ( n + 1 ) / 2 ; int d = log10 ( n ) ; int * a = new int [ d + 1 ] ; a [ 0 ] = 0 , a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ceil ( pow ( 10 , i - 1 ) ) ; int p = ceil ( pow ( 10 , d ) ) ; int msd = n / p ; return msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ; } int main ( ) { int n = 328 ; cout << " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ is ▁ " << sumOfDigitsFrom1ToN ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; } int main ( ) { int N = 3 ; cout << " Count ▁ of ▁ ways ▁ for ▁ " << N << " ▁ sections ▁ is ▁ " << countWays ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = 0 ; for ( b = n - 3 ; b >= 1 ; b -- ) { int curr = ( n - b - 1 ) * screen [ b - 1 ] ; if ( curr > screen [ n - 1 ] ) screen [ n - 1 ] = curr ; } } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << " Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ " << N << " ▁ keystrokes ▁ is ▁ " << findoptimal ( N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int screen [ N ] ; int b ; int n ; for ( n = 1 ; n <= 6 ; n ++ ) screen [ n - 1 ] = n ; for ( n = 7 ; n <= N ; n ++ ) { screen [ n - 1 ] = max ( 2 * screen [ n - 4 ] , max ( 3 * screen [ n - 5 ] , 4 * screen [ n - 6 ] ) ) ; } return screen [ N - 1 ] ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) printf ( " Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ % d ▁ keystrokes ▁ is ▁ % d STRNEWLINE " , N , findoptimal ( N ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define NO_OF_CHARS  256  NEW_LINE int getNextState ( string pat , int M , int state , int x ) { if ( state < M && x == pat [ state ] ) return state + 1 ; int ns , i ; for ( ns = state ; ns > 0 ; ns -- ) { if ( pat [ ns - 1 ] == x ) { for ( i = 0 ; i < ns - 1 ; i ++ ) if ( pat [ i ] != pat [ state - ns + 1 + i ] ) break ; if ( i == ns - 1 ) return ns ; } } return 0 ; } void computeTF ( string pat , int M , int TF [ ] [ NO_OF_CHARS ] ) { int state , x ; for ( state = 0 ; state <= M ; ++ state ) for ( x = 0 ; x < NO_OF_CHARS ; ++ x ) TF [ state ] [ x ] = getNextState ( pat , M , state , x ) ; } void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int TF [ M + 1 ] [ NO_OF_CHARS ] ; computeTF ( pat , M , TF ) ; int i , state = 0 ; for ( i = 0 ; i < N ; i ++ ) { state = TF [ state ] [ txt [ i ] ] ; if ( state == M ) cout << " ▁ Pattern ▁ found ▁ at ▁ index ▁ " << i - M + 1 << endl ; } } int main ( ) { string txt = " AABAACAADAABAAABAA " ; string pat = " AABA " ; search ( pat , txt ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; # define NO_OF_CHARS  256 NEW_LINE void badCharHeuristic ( string str , int size , int badchar [ NO_OF_CHARS ] ) { int i ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) badchar [ i ] = -1 ; for ( i = 0 ; i < size ; i ++ ) badchar [ ( int ) str [ i ] ] = i ; } void search ( string txt , string pat ) { int m = pat . size ( ) ; int n = txt . size ( ) ; int badchar [ NO_OF_CHARS ] ; badCharHeuristic ( pat , m , badchar ) ; int s = 0 ; while ( s <= ( n - m ) ) { int j = m - 1 ; while ( j >= 0 && pat [ j ] == txt [ s + j ] ) j -- ; if ( j < 0 ) { cout << " pattern ▁ occurs ▁ at ▁ shift ▁ = ▁ " << s << endl ; s += ( s + m < n ) ? m - badchar [ txt [ s + m ] ] : 1 ; } else s += max ( 1 , j - badchar [ txt [ s + j ] ] ) ; } } int main ( ) { string txt = " ABAAABCD " ; string pat = " ABC " ; search ( txt , pat ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cstring> NEW_LINE #define MAX  256 NEW_LINE using namespace std ; bool compare ( char arr1 [ ] , char arr2 [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } void search ( char * pat , char * txt ) { int M = strlen ( pat ) , N = strlen ( txt ) ; char countP [ MAX ] = { 0 } , countTW [ MAX ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { ( countP [ pat [ i ] ] ) ++ ; ( countTW [ txt [ i ] ] ) ++ ; } for ( int i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) cout << " Found ▁ at ▁ Index ▁ " << ( i - M ) << endl ; ( countTW [ txt [ i ] ] ) ++ ; countTW [ txt [ i - M ] ] -- ; } if ( compare ( countP , countTW ) ) cout << " Found ▁ at ▁ Index ▁ " << ( N - M ) << endl ; } int main ( ) { char txt [ ] = " BACDGABCDA " ; char pat [ ] = " ABCD " ; search ( pat , txt ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE char text [ 100 ] ; int min ( int a , int b ) { int res = a ; if ( b < a ) res = b ; return res ; } void findLongestPalindromicString ( ) { int N = strlen ( text ) ; if ( N == 0 ) return ; N = 2 * N + 1 ; int L [ N ] ; L [ 0 ] = 0 ; L [ 1 ] = 1 ; int C = 1 ; int R = 2 ; int i = 0 ; int iMirror ; int maxLPSLength = 0 ; int maxLPSCenterPosition = 0 ; int start = -1 ; int end = -1 ; int diff = -1 ; for ( i = 2 ; i < N ; i ++ ) { iMirror = 2 * C - i ; L [ i ] = 0 ; diff = R - i ; if ( diff > 0 ) L [ i ] = min ( L [ iMirror ] , diff ) ; while ( ( ( i + L [ i ] ) < N && ( i - L [ i ] ) > 0 ) && ( ( ( i + L [ i ] + 1 ) % 2 == 0 ) || ( text [ ( i + L [ i ] + 1 ) / 2 ] == text [ ( i - L [ i ] - 1 ) / 2 ] ) ) ) { L [ i ] ++ ; } if ( L [ i ] > maxLPSLength ) { maxLPSLength = L [ i ] ; maxLPSCenterPosition = i ; } if ( i + L [ i ] > R ) { C = i ; R = i + L [ i ] ; } } start = ( maxLPSCenterPosition - maxLPSLength ) / 2 ; end = start + maxLPSLength - 1 ; printf ( " LPS ▁ of ▁ string ▁ is ▁ % s ▁ : ▁ " , text ) ; for ( i = start ; i <= end ; i ++ ) printf ( " % c " , text [ i ] ) ; printf ( " STRNEWLINE " ) ; } int main ( int argc , char * argv [ ] ) { strcpy ( text , " babcbabcbaccba " ) ; findLongestPalindromicString ( ) ; strcpy ( text , " abaaba " ) ; findLongestPalindromicString ( ) ; strcpy ( text , " abababa " ) ; findLongestPalindromicString ( ) ; strcpy ( text , " abcbabcbabcba " ) ; findLongestPalindromicString ( ) ; strcpy ( text , " forgeeksskeegfor " ) ; findLongestPalindromicString ( ) ; strcpy ( text , " caba " ) ; findLongestPalindromicString ( ) ; strcpy ( text , " abacdfgdcaba " ) ; findLongestPalindromicString ( ) ; strcpy ( text , " abacdfgdcabba " ) ; findLongestPalindromicString ( ) ; strcpy ( text , " abacdedcaba " ) ; findLongestPalindromicString ( ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void printPatternUtil ( const char str [ ] , char buff [ ] , int i , int j , int n ) { if ( i == n ) { buff [ j ] = ' \0' ; cout << buff << endl ; return ; } buff [ j ] = str [ i ] ; printPatternUtil ( str , buff , i + 1 , j + 1 , n ) ; buff [ j ] = ' ▁ ' ; buff [ j + 1 ] = str [ i ] ; printPatternUtil ( str , buff , i + 1 , j + 2 , n ) ; } void printPattern ( const char * str ) { int n = strlen ( str ) ; char buf [ 2 * n ] ; buf [ 0 ] = str [ 0 ] ; printPatternUtil ( str , buf , 1 , 1 , n ) ; } int main ( ) { const char * str = " ABCD " ; printPattern ( str ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define N  9 NEW_LINE void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << arr [ i ] [ j ] << " ▁ " ; cout << endl ; } } bool isSafe ( int grid [ N ] [ N ] , int row , int col , int num ) { for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ row ] [ x ] == num ) return false ; for ( int x = 0 ; x <= 8 ; x ++ ) if ( grid [ x ] [ col ] == num ) return false ; int startRow = row - row % 3 , startCol = col - col % 3 ; for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) if ( grid [ i + startRow ] [ j + startCol ] == num ) return false ; return true ; } bool solveSuduko ( int grid [ N ] [ N ] , int row , int col ) { if ( row == N - 1 && col == N ) return true ; if ( col == N ) { row ++ ; col = 0 ; } if ( grid [ row ] [ col ] > 0 ) return solveSuduko ( grid , row , col + 1 ) ; for ( int num = 1 ; num <= N ; num ++ ) { if ( isSafe ( grid , row , col , num ) ) { grid [ row ] [ col ] = num ; if ( solveSuduko ( grid , row , col + 1 ) ) return true ; } grid [ row ] [ col ] = 0 ; } return false ; } int main ( ) { int grid [ N ] [ N ] = { { 3 , 0 , 6 , 5 , 0 , 8 , 4 , 0 , 0 } , { 5 , 2 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 8 , 7 , 0 , 0 , 0 , 0 , 3 , 1 } , { 0 , 0 , 3 , 0 , 1 , 0 , 0 , 8 , 0 } , { 9 , 0 , 0 , 8 , 6 , 3 , 0 , 0 , 5 } , { 0 , 5 , 0 , 0 , 9 , 0 , 6 , 0 , 0 } , { 1 , 3 , 0 , 0 , 0 , 0 , 2 , 5 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 4 } , { 0 , 0 , 5 , 2 , 0 , 6 , 3 , 0 , 0 } } ; if ( solveSuduko ( grid , 0 , 0 ) ) print ( grid ) ; else cout << " no ▁ solution ▁ exists ▁ " << endl ; return 0 ; }
int power ( int x , unsigned int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y ) { if ( y == 0 ) return 1 ; if ( x == 0 ) return 0 ; return x * power ( x , y - 1 ) ; } int main ( ) { int x = 2 ; int y = 3 ; cout << ( power ( x , y ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y ) { return ( int ) pow ( x , y ) ; } int main ( ) { int x = 2 ; int y = 3 ; cout << ( power ( x , y ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int median ( int [ ] , int ) ; int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { if ( n <= 0 ) return -1 ; if ( n == 1 ) return ( ar1 [ 0 ] + ar2 [ 0 ] ) / 2 ; if ( n == 2 ) return ( max ( ar1 [ 0 ] , ar2 [ 0 ] ) + min ( ar1 [ 1 ] , ar2 [ 1 ] ) ) / 2 ; int m1 = median ( ar1 , n ) ; int m2 = median ( ar2 , n ) ; if ( m1 == m2 ) return m1 ; if ( m1 < m2 ) { if ( n % 2 == 0 ) return getMedian ( ar1 + n / 2 - 1 , ar2 , n - n / 2 + 1 ) ; return getMedian ( ar1 + n / 2 , ar2 , n - n / 2 ) ; } if ( n % 2 == 0 ) return getMedian ( ar2 + n / 2 - 1 , ar1 , n - n / 2 + 1 ) ; return getMedian ( ar2 + n / 2 , ar1 , n - n / 2 ) ; } int median ( int arr [ ] , int n ) { if ( n % 2 == 0 ) return ( arr [ n / 2 ] + arr [ n / 2 - 1 ] ) / 2 ; else return arr [ n / 2 ] ; } int main ( ) { int ar1 [ ] = { 1 , 2 , 3 , 6 } ; int ar2 [ ] = { 4 , 6 , 8 , 10 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) cout << " Median ▁ is ▁ " << getMedian ( ar1 , ar2 , n1 ) ; else cout << " Doesn ' t ▁ work ▁ for ▁ arrays ▁ " << " of ▁ unequal ▁ size " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int j = 0 ; int i = n - 1 ; while ( ar1 [ i ] > ar2 [ j ] && j < n && i > - 1 ) swap ( ar1 [ i -- ] , ar2 [ j ++ ] ) ; sort ( ar1 , ar1 + n ) ; sort ( ar2 , ar2 + n ) ; return ( ar1 [ n - 1 ] + ar2 [ 0 ] ) / 2 ; } int main ( ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) cout << " Median ▁ is ▁ " << getMedian ( ar1 , ar2 , n1 ) ; else cout << " Doesn ' t ▁ work ▁ for ▁ arrays " << " ▁ of ▁ unequal ▁ size " ; getchar ( ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct Point { int x ; int y ; } ; bool onSegment ( Point p , Point q , Point r ) { if ( q . x <= max ( p . x , r . x ) && q . x >= min ( p . x , r . x ) && q . y <= max ( p . y , r . y ) && q . y >= min ( p . y , r . y ) ) return true ; return false ; } int orientation ( Point p , Point q , Point r ) { int val = ( q . y - p . y ) * ( r . x - q . x ) - ( q . x - p . x ) * ( r . y - q . y ) ; if ( val == 0 ) return 0 ; return ( val > 0 ) ? 1 : 2 ; } bool doIntersect ( Point p1 , Point q1 , Point p2 , Point q2 ) { int o1 = orientation ( p1 , q1 , p2 ) ; int o2 = orientation ( p1 , q1 , q2 ) ; int o3 = orientation ( p2 , q2 , p1 ) ; int o4 = orientation ( p2 , q2 , q1 ) ; if ( o1 != o2 && o3 != o4 ) return true ; if ( o1 == 0 && onSegment ( p1 , p2 , q1 ) ) return true ; if ( o2 == 0 && onSegment ( p1 , q2 , q1 ) ) return true ; if ( o3 == 0 && onSegment ( p2 , p1 , q2 ) ) return true ; if ( o4 == 0 && onSegment ( p2 , q1 , q2 ) ) return true ; return false ; } int main ( ) { struct Point p1 = { 1 , 1 } , q1 = { 10 , 1 } ; struct Point p2 = { 1 , 2 } , q2 = { 10 , 2 } ; doIntersect ( p1 , q1 , p2 , q2 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; p1 = { 10 , 0 } , q1 = { 0 , 10 } ; p2 = { 0 , 0 } , q2 = { 10 , 10 } ; doIntersect ( p1 , q1 , p2 , q2 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; p1 = { -5 , -5 } , q1 = { 0 , 0 } ; p2 = { 1 , 1 } , q2 = { 10 , 10 } ; doIntersect ( p1 , q1 , p2 , q2 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#include <stdio.h> NEW_LINE float getAvg ( float prev_avg , int x , int n ) { return ( prev_avg * n + x ) / ( n + 1 ) ; } void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( avg , arr [ i ] , i ) ; printf ( " Average ▁ of ▁ % d ▁ numbers ▁ is ▁ % f ▁ STRNEWLINE " , i + 1 , avg ) ; } return ; } int main ( ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; streamAvg ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) cout << p << " ▁ " ; } int main ( ) { int n = 30 ; cout << " Following ▁ are ▁ the ▁ prime ▁ numbers ▁ smaller ▁ " << " ▁ than ▁ or ▁ equal ▁ to ▁ " << n << endl ; SieveOfEratosthenes ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumNumberDistinctPrimeRange ( int m , int n ) { long long factorCount [ n + 1 ] ; bool prime [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = factorCount [ i ] ; num = i ; } } return num ; } int main ( ) { int m = 4 , n = 6 ; cout << maximumNumberDistinctPrimeRange ( m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_CHAR  256 NEW_LINE int count [ MAX_CHAR ] = { 0 } ; int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } void populateAndIncreaseCount ( int * count , char * str ) { int i ; for ( i = 0 ; str [ i ] ; ++ i ) ++ count [ str [ i ] ] ; for ( i = 1 ; i < MAX_CHAR ; ++ i ) count [ i ] += count [ i - 1 ] ; } void updatecount ( int * count , char ch ) { int i ; for ( i = ch ; i < MAX_CHAR ; ++ i ) -- count [ i ] ; } int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 , i ; populateAndIncreaseCount ( count , str ) ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; rank += count [ str [ i ] - 1 ] * mul ; updatecount ( count , str [ i ] ) ; } return rank ; } int main ( ) { char str [ ] = " string " ; cout << findRank ( str ) ; return 0 ; }
#include <stdio.h> NEW_LINE int binomialCoeff ( int n , int k ) ; int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } void printPascal ( int n ) { for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) printf ( " % d ▁ " , binomialCoeff ( line , i ) ) ; printf ( " STRNEWLINE " ) ; } } int main ( ) { int n = 7 ; printPascal ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ; } class Vessel { int capacity , current ; public : Vessel ( int capacity ) { this -> capacity = capacity ; current = 0 ; } void makeOneLitre ( Vessel & V2 ) ; int transfer ( int amount ) ; } ; void Vessel :: makeOneLitre ( Vessel & V2 ) { if ( gcd ( capacity , V2 . capacity ) != 1 ) return ; while ( current != 1 ) { if ( current == 0 ) current = capacity ; cout << " Vessel ▁ 1 : ▁ " << current << " ▁ Vessel ▁ 2 : ▁ " << V2 . current << endl ; current = current - V2 . transfer ( current ) ; } cout << " Vessel ▁ 1 : ▁ " << current << " ▁ Vessel ▁ 2 : ▁ " << V2 . current << endl ; } int Vessel :: transfer ( int amount ) { if ( current + amount < capacity ) { current += amount ; return amount ; } int transferred = capacity - current ; current = 0 ; return transferred ; } int main ( ) { int a = 3 , b = 7 ; Vessel V1 ( a ) , V2 ( b ) ; V1 . makeOneLitre ( V2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCeil ( int arr [ ] , int r , int l , int h ) { int mid ; while ( l < h ) { mid = l + ( ( h - l ) >> 1 ) ; ( r > arr [ mid ] ) ? ( l = mid + 1 ) : ( h = mid ) ; } return ( arr [ l ] >= r ) ? l : -1 ; } int myRand ( int arr [ ] , int freq [ ] , int n ) { int prefix [ n ] , i ; prefix [ 0 ] = freq [ 0 ] ; for ( i = 1 ; i < n ; ++ i ) prefix [ i ] = prefix [ i - 1 ] + freq [ i ] ; int r = ( rand ( ) % prefix [ n - 1 ] ) + 1 ; int indexc = findCeil ( prefix , r , 0 , n - 1 ) ; return arr [ indexc ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int freq [ ] = { 10 , 5 , 20 , 100 } ; int i , n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; srand ( time ( NULL ) ) ; for ( i = 0 ; i < 5 ; i ++ ) cout << myRand ( arr , freq , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; } bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; } int main ( ) { for ( int i = 1 ; i <= 10 ; i ++ ) isFibonacci ( i ) ? cout << i << " ▁ is ▁ a ▁ Fibonacci ▁ Number ▁ STRNEWLINE " : cout << i << " ▁ is ▁ a ▁ not ▁ Fibonacci ▁ Number ▁ STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; } int main ( ) { int n = 100 ; cout << " Count ▁ of ▁ trailing ▁ 0s ▁ in ▁ " << 100 << " ! ▁ is ▁ " << findTrailingZeros ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; unsigned long int catalan ( unsigned int n ) { if ( n <= 1 ) return 1 ; unsigned long int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ; return res ; } int main ( ) { for ( int i = 0 ; i < 10 ; i ++ ) cout << catalan ( i ) << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; unsigned long int catalanDP ( unsigned int n ) { unsigned long int catalan [ n + 1 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; } int main ( ) { for ( int i = 0 ; i < 10 ; i ++ ) cout << catalanDP ( i ) << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } int main ( ) { for ( int i = 0 ; i < 10 ; i ++ ) cout << catalan ( i ) << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <boost/multiprecision/cpp_int.hpp> NEW_LINE using boost :: multiprecision :: cpp_int ; using namespace std ; void catalan ( int n ) { cpp_int cat_ = 1 ; cout << cat_ << " ▁ " ; for ( cpp_int i = 1 ; i < n ; i ++ ) { cat_ *= ( 4 * i - 2 ) ; cat_ /= ( i + 1 ) ; cout << cat_ << " ▁ " ; } } int main ( ) { int n = 5 ; catalan ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  50 NEW_LINE using namespace std ; void printString ( int n ) { char str [ MAX ] ; int i = 0 ; while ( n > 0 ) { int rem = n % 26 ; if ( rem == 0 ) { str [ i ++ ] = ' Z ' ; n = ( n / 26 ) - 1 ; } else { str [ i ++ ] = ( rem - 1 ) + ' A ' ; n = n / 26 ; } } str [ i ] = ' \0' ; reverse ( str , str + strlen ( str ) ) ; cout << str << endl ; return ; } int main ( ) { printString ( 26 ) ; printString ( 51 ) ; printString ( 52 ) ; printString ( 80 ) ; printString ( 676 ) ; printString ( 702 ) ; printString ( 705 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printString ( int n ) { int arr [ 10000 ] ; int i = 0 ; while ( n ) { arr [ i ] = n % 26 ; n = n / 26 ; i ++ ; } for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( arr [ j ] <= 0 ) { arr [ j ] += 26 ; arr [ j + 1 ] = arr [ j + 1 ] - 1 ; } } for ( int j = i ; j >= 0 ; j -- ) { if ( arr [ j ] > 0 ) cout << char ( ' A ' + arr [ j ] - 1 ) ; } cout << endl ; } int main ( ) { printString ( 26 ) ; printString ( 51 ) ; printString ( 52 ) ; printString ( 80 ) ; printString ( 676 ) ; printString ( 702 ) ; printString ( 705 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int getInvCount ( int arr [ ] ) { int inv_count = 0 ; for ( int i = 0 ; i < 9 - 1 ; i ++ ) for ( int j = i + 1 ; j < 9 ; j ++ ) if ( arr [ j ] && arr [ i ] && arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; } bool isSolvable ( int puzzle [ 3 ] [ 3 ] ) { int invCount = getInvCount ( ( int * ) puzzle ) ; return ( invCount % 2 == 0 ) ; } int main ( int argv , char * * args ) { int puzzle [ 3 ] [ 3 ] = { { 1 , 8 , 2 } , { 0 , 4 , 3 } , { 7 , 6 , 5 } } ; isSolvable ( puzzle ) ? cout << " Solvable " : cout << " Not ▁ Solvable " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; } int main ( ) { cout << " Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " << countSolutions ( 6 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; } int main ( ) { cout << " Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " << countSolutions ( 6 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define EPSILON  0.001 NEW_LINE using namespace std ; double func ( double x ) { return x * x * x - x * x + 2 ; } double derivFunc ( double x ) { return 3 * x * x - 2 * x ; } void newtonRaphson ( double x ) { double h = func ( x ) / derivFunc ( x ) ; while ( abs ( h ) >= EPSILON ) { h = func ( x ) / derivFunc ( x ) ; x = x - h ; } cout << " The ▁ value ▁ of ▁ the ▁ root ▁ is ▁ : ▁ " << x ; } int main ( ) { double x0 = -20 ; newtonRaphson ( x0 ) ; return 0 ; }
#include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; } int main ( ) { int x = 100 , y = -100 ; if ( oppositeSigns ( x , y ) == true ) printf ( " Signs ▁ are ▁ opposite " ) ; else printf ( " Signs ▁ are ▁ not ▁ opposite " ) ; return 0 ; }
#include <stdio.h> NEW_LINE unsigned int countSetBitsUtil ( unsigned int x ) ; unsigned int countSetBits ( unsigned int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; } unsigned int countSetBitsUtil ( unsigned int x ) { if ( x <= 0 ) return 0 ; return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ; } int main ( ) { int n = 4 ; printf ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ % d " , countSetBits ( n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int getLeftmostBit ( int n ) { int m = 0 ; while ( n > 1 ) { n = n >> 1 ; m ++ ; } return m ; } unsigned int getNextLeftmostBit ( int n , int m ) { unsigned int temp = 1 << m ; while ( n < temp ) { temp = temp >> 1 ; m -- ; } return m ; } unsigned int _countSetBits ( unsigned int n , int m ) ; unsigned int countSetBits ( unsigned int n ) { int m = getLeftmostBit ( n ) ; return _countSetBits ( n , m ) ; } unsigned int _countSetBits ( unsigned int n , int m ) { if ( n == 0 ) return 0 ; m = getNextLeftmostBit ( n , m ) ; if ( n == ( ( unsigned int ) 1 << ( m + 1 ) ) - 1 ) return ( unsigned int ) ( m + 1 ) * ( 1 << m ) ; n = n - ( 1 << m ) ; return ( n + 1 ) + countSetBits ( n ) + m * ( 1 << ( m - 1 ) ) ; } int main ( ) { int n = 17 ; cout << " Total ▁ set ▁ bit ▁ count ▁ is ▁ " << countSetBits ( n ) ; return 0 ; }
int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
#include <iostream> NEW_LINE using namespace std ; int swapBits ( unsigned int num , unsigned int p1 , unsigned int p2 , unsigned int n ) { int shift1 , shift2 , value1 , value2 ; while ( n -- ) { shift1 = 1 << p1 ; shift2 = 1 << p2 ; value1 = ( ( num & shift1 ) ) ; value2 = ( ( num & shift2 ) ) ; if ( ( ! value1 && value2 ) || ( ! value2 && value1 ) ) { if ( value1 ) { num = num & ( ~ shift1 ) ; num = num | shift2 ; } else { num = num & ( ~ shift2 ) ; num = num | shift1 ; } } p1 ++ ; p2 ++ ; } return num ; } int main ( ) { int res = swapBits ( 28 , 0 , 3 , 2 ) ; cout << " Result ▁ = ▁ " << res ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define CHAR_BIT  8 NEW_LINE int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHAR_BIT - 1 ) ) ) ; } int smallest ( int x , int y , int z ) { return min ( x , min ( y , z ) ) ; } int main ( ) { int x = 12 , y = 15 , z = 5 ; cout << " Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ " << smallest ( x , y , z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallest ( int x , int y , int z ) { if ( ! ( y / x ) ) return ( ! ( y / z ) ) ? y : z ; return ( ! ( x / z ) ) ? x : z ; } int main ( ) { int x = 78 , y = 88 , z = 68 ; cout << " Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ " << smallest ( x , y , z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void changeToZero ( int a [ 2 ] ) { a [ a [ 1 ] ] = a [ ! a [ 1 ] ] ; } int main ( ) { int a [ ] = { 1 , 0 } ; changeToZero ( a ) ; cout << " arr [ 0 ] ▁ = ▁ " << a [ 0 ] << endl ; cout << " ▁ arr [ 1 ] ▁ = ▁ " << a [ 1 ] ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; typedef unsigned int uint_t ; uint_t snoob ( uint_t x ) { uint_t rightOne ; uint_t nextHigherOneBit ; uint_t rightOnesPattern ; uint_t next = 0 ; if ( x ) { rightOne = x & - ( signed ) x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; } int main ( ) { int x = 156 ; cout << " Next ▁ higher ▁ number ▁ with ▁ same ▁ number ▁ of ▁ set ▁ bits ▁ is ▁ " << snoob ( x ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; } int main ( ) { int x = 4 ; printf ( " % d " , multiplyWith3Point5 ( x ) ) ; getchar ( ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int multiplyWith3Point5 ( int x ) { int r = 0 ; int x1Shift = x << 1 ; int x2Shifts = x << 2 ; r = ( x ^ x1Shift ) ^ x2Shifts ; int c = ( x & x1Shift ) | ( x & x2Shifts ) | ( x1Shift & x2Shifts ) ; while ( c > 0 ) { c <<= 1 ; int t = r ; r ^= c ; c &= t ; } r = r >> 1 ; return r ; } int main ( ) { cout << ( multiplyWith3Point5 ( 5 ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfFour ( unsigned int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) && ! ( n & 0xAAAAAAAA ) ; } int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) cout << test_no << " ▁ is ▁ a ▁ power ▁ of ▁ 4" ; else cout << test_no << " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4" ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float logn ( int n , int r ) { return log ( n ) / log ( r ) ; } bool isPowerOfFour ( int n ) { if ( n == 0 ) return false ; return floor ( logn ( n , 4 ) ) == ceil ( logn ( n , 4 ) ) ; } int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) cout << test_no << " ▁ is ▁ a ▁ power ▁ of ▁ 4" ; else cout << test_no << " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4" ; return 0 ; }
#include <stdio.h> NEW_LINE unsigned int getModulo ( unsigned int n , unsigned int d ) { return ( n & ( d - 1 ) ) ; } int main ( ) { unsigned int n = 6 ; unsigned int d = 4 ; printf ( " % u ▁ moduo ▁ % u ▁ is ▁ % u " , n , d , getModulo ( n , d ) ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define CHARBIT  8 NEW_LINE int min ( int x , int y ) { return y + ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHARBIT - 1 ) ) ) ; } int max ( int x , int y ) { return x - ( ( x - y ) & ( ( x - y ) >> ( sizeof ( int ) * CHARBIT - 1 ) ) ) ; } int main ( ) { int x = 15 ; int y = 6 ; cout << " Minimum ▁ of ▁ " << x << " ▁ and ▁ " << y << " ▁ is ▁ " ; cout << min ( x , y ) ; cout << " Maximum of " < < x < < " and " < < y < < " is " cout << max ( x , y ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getOddOccurrence ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return -1 ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getOddOccurrence ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; } int main ( ) { int n = 9 ; cout << countSetBits ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int main ( ) { cout << __builtin_popcount ( 4 ) << endl ; cout << __builtin_popcount ( 15 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSetBits ( int N ) { int count = 0 ; for ( int i = 0 ; i < sizeof ( int ) * 8 ; i ++ ) { if ( N & ( 1 << i ) ) count ++ ; } return count ; } int main ( ) { int N = 15 ; cout << countSetBits ( N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; } int FlippedCount ( int a , int b ) { return countSetBits ( a ^ b ) ; } int main ( ) { int a = 10 ; int b = 20 ; cout << FlippedCount ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool powerOf2 ( int n ) { if ( n == 1 ) return true ; else if ( n % 2 != 0 n == 0 ) return false ; return powerOf2 ( n / 2 ) ; } int main ( ) { int n = 64 ; int m = 12 ; if ( powerOf2 ( n ) == 1 ) cout << " True " << endl ; else cout << " False " << endl ; if ( powerOf2 ( m ) == 1 ) cout << " True " << endl ; else cout << " False " << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ! ( n & m ) ) { m = m << 1 ; position ++ ; } return position ; } int main ( ) { int n = 16 ; cout << PositionRightmostSetbit ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define INT_SIZE  32 NEW_LINE int Right_most_setbit ( int num ) { if ( num == 0 ) { return 0 ; } else { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ! ( num & ( 1 << i ) ) ) pos ++ ; else break ; } return pos ; } } int main ( ) { int num = 0 ; int pos = Right_most_setbit ( num ) ; cout << pos << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void bin ( long n ) { long i ; cout << "0" ; for ( i = 1 << 30 ; i > 0 ; i = i / 2 ) { if ( ( n & i ) != 0 ) { cout << "1" ; } else { cout << "0" ; } } } int main ( void ) { bin ( 7 ) ; cout << endl ; bin ( 4 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void bin ( unsigned n ) { if ( n > 1 ) bin ( n >> 1 ) ; printf ( " % d " , n & 1 ) ; } int main ( void ) { bin ( 131 ) ; printf ( " STRNEWLINE " ) ; bin ( 3 ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define N  8 NEW_LINE void printSolution ( int board [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( " % 2d ▁ " , board [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } } bool isSafe ( int row , int col , int slashCode [ N ] [ N ] , int backslashCode [ N ] [ N ] , bool rowLookup [ ] , bool slashCodeLookup [ ] , bool backslashCodeLookup [ ] ) { if ( slashCodeLookup [ slashCode [ row ] [ col ] ] backslashCodeLookup [ backslashCode [ row ] [ col ] ] rowLookup [ row ] ) return false ; return true ; } bool solveNQueensUtil ( int board [ N ] [ N ] , int col , int slashCode [ N ] [ N ] , int backslashCode [ N ] [ N ] , bool rowLookup [ N ] , bool slashCodeLookup [ ] , bool backslashCodeLookup [ ] ) { if ( col >= N ) return true ; for ( int i = 0 ; i < N ; i ++ ) { if ( isSafe ( i , col , slashCode , backslashCode , rowLookup , slashCodeLookup , backslashCodeLookup ) ) { board [ i ] [ col ] = 1 ; rowLookup [ i ] = true ; slashCodeLookup [ slashCode [ i ] [ col ] ] = true ; backslashCodeLookup [ backslashCode [ i ] [ col ] ] = true ; if ( solveNQueensUtil ( board , col + 1 , slashCode , backslashCode , rowLookup , slashCodeLookup , backslashCodeLookup ) ) return true ; board [ i ] [ col ] = 0 ; rowLookup [ i ] = false ; slashCodeLookup [ slashCode [ i ] [ col ] ] = false ; backslashCodeLookup [ backslashCode [ i ] [ col ] ] = false ; } } return false ; } bool solveNQueens ( ) { int board [ N ] [ N ] ; memset ( board , 0 , sizeof board ) ; int slashCode [ N ] [ N ] ; int backslashCode [ N ] [ N ] ; bool rowLookup [ N ] = { false } ; bool slashCodeLookup [ 2 * N - 1 ] = { false } ; bool backslashCodeLookup [ 2 * N - 1 ] = { false } ; for ( int r = 0 ; r < N ; r ++ ) for ( int c = 0 ; c < N ; c ++ ) { slashCode [ r ] = r + c , backslashCode [ r ] = r - c + 7 ; } if ( solveNQueensUtil ( board , 0 , slashCode , backslashCode , rowLookup , slashCodeLookup , backslashCodeLookup ) == false ) { printf ( " Solution ▁ does ▁ not ▁ exist " ) ; return false ; } printSolution ( board ) ; return true ; } int main ( ) { solveNQueens ( ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #include <stdbool.h> NEW_LINE bool checkSentence ( char str [ ] ) { int len = strlen ( str ) ; if ( str [ 0 ] < ' A ' str [ 0 ] > ' Z ' ) return false ; if ( str [ len - 1 ] != ' . ' ) return false ; int prev_state = 0 , curr_state = 0 ; int index = 1 ; while ( str [ index ] ) { if ( str [ index ] >= ' A ' && str [ index ] <= ' Z ' ) curr_state = 0 ; else if ( str [ index ] == ' ▁ ' ) curr_state = 1 ; else if ( str [ index ] >= ' a ' && str [ index ] <= ' z ' ) curr_state = 2 ; else if ( str [ index ] == ' . ' ) curr_state = 3 ; if ( prev_state == curr_state && curr_state != 2 ) return false ; if ( prev_state == 2 && curr_state == 0 ) return false ; if ( curr_state == 3 && prev_state != 1 ) return ( str [ index + 1 ] == ' \0' ) ; index ++ ; prev_state = curr_state ; } return false ; } int main ( ) { char * str [ ] = { " I ▁ love ▁ cinema . " , " The ▁ vertex ▁ is ▁ S . " , " I ▁ am ▁ single . " , " My ▁ name ▁ is ▁ KG . " , " I ▁ lovE ▁ cinema . " , " GeeksQuiz . ▁ is ▁ a ▁ quiz ▁ site . " , " I ▁ love ▁ Geeksquiz ▁ and ▁ Geeksforgeeks . " , " ▁ You ▁ are ▁ my ▁ friend . " , " I ▁ love ▁ cinema " } ; int str_size = sizeof ( str ) / sizeof ( str [ 0 ] ) ; int i = 0 ; for ( i = 0 ; i < str_size ; i ++ ) checkSentence ( str [ i ] ) ? printf ( " \" % s \" ▁ is ▁ correct ▁ STRNEWLINE " , str [ i ] ) : printf ( " \" % s \" ▁ is ▁ incorrect ▁ STRNEWLINE " , str [ i ] ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int maxOnesIndex ( bool arr [ ] , int n ) { int max_count = 0 ; int max_index ; int prev_zero = -1 ; int prev_prev_zero = -1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; } int main ( ) { bool arr [ ] = { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ " << maxOnesIndex ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int min ( int x , int y ) { return ( x < y ) ? x : y ; } int max ( int x , int y ) { return ( x > y ) ? x : y ; } int findLength ( int arr [ ] , int n ) { int max_len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int mn = arr [ i ] , mx = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { mn = min ( mn , arr [ j ] ) ; mx = max ( mx , arr [ j ] ) ; if ( ( mx - mn ) == j - i ) max_len = max ( max_len , mx - mn + 1 ) ; } } return max_len ; } int main ( ) { int arr [ ] = { 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is ▁ " << findLength ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int k ) { for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } void printSeqUtil ( int n , int k , int & len , int arr [ ] ) { if ( len == k ) { printArr ( arr , k ) ; return ; } int i = ( len == 0 ) ? 1 : arr [ len - 1 ] + 1 ; len ++ ; while ( i <= n ) { arr [ len - 1 ] = i ; printSeqUtil ( n , k , len , arr ) ; i ++ ; } len -- ; } void printSeq ( int n , int k ) { int arr [ k ] ; int len = 0 ; printSeqUtil ( n , k , len , arr ) ; } int main ( ) { int k = 3 , n = 7 ; printSeq ( n , k ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; bool isSubSequence ( char str1 [ ] , char str2 [ ] , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; } int main ( ) { char str1 [ ] = " gksrek " ; char str2 [ ] = " geeksforgeeks " ; int m = strlen ( str1 ) ; int n = strlen ( str2 ) ; isSubSequence ( str1 , str2 , m , n ) ? cout << " Yes ▁ " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count ++ ; } for ( int i = 0 ; i < count ; i ++ ) arr [ i ] = 0 ; for ( int i = count ; i < n ; i ++ ) arr [ i ] = 1 ; } void print ( int arr [ ] , int n ) { cout << " Array ▁ after ▁ segregation ▁ is ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , n ) ; print ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int size ) { int type0 = 0 ; int type1 = size - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else type0 ++ ; } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; cout << " Array ▁ after ▁ segregation ▁ is ▁ " ; for ( i = 0 ; i < arr_size ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find3Numbers ( vector < int > & nums ) { if ( nums . size ( ) < 3 ) { cout << " No ▁ such ▁ triplet ▁ found " ; return ; } int seq = 1 ; int min_num = nums [ 0 ] ; int max_seq = INT_MIN ; int store_min = min_num ; for ( int i = 1 ; i < nums . size ( ) ; i ++ ) { if ( nums [ i ] == min_num ) continue ; else if ( nums [ i ] < min_num ) { min_num = nums [ i ] ; continue ; } else if ( nums [ i ] < max_seq ) { max_seq = nums [ i ] ; store_min = min_num ; } else if ( nums [ i ] > max_seq ) { seq ++ ; if ( seq == 3 ) { cout << " Triplet : ▁ " << store_min << " , ▁ " << max_seq << " , ▁ " << nums [ i ] << endl ; return ; } max_seq = nums [ i ] ; } } cout << " No ▁ such ▁ triplet ▁ found " ; } int main ( ) { vector < int > nums { 1 , 2 , -1 , 7 , 5 } ; find3Numbers ( nums ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubarrayProduct ( int arr [ ] , int n ) { int result = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int mul = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { result = max ( result , mul ) ; mul *= arr [ j ] ; } result = max ( result , mul ) ; } return result ; } int main ( ) { int arr [ ] = { 1 , -2 , -3 , 0 , 7 , -8 , -2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ Sub ▁ array ▁ product ▁ is ▁ " << maxSubarrayProduct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GetCeilIndex ( int arr [ ] , vector < int > & T , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; } int LongestIncreasingSubsequence ( int arr [ ] , int n ) { vector < int > tailIndices ( n , 0 ) ; vector < int > prevIndices ( n , -1 ) ; int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) { tailIndices [ 0 ] = i ; } else if ( arr [ i ] > arr [ tailIndices [ len - 1 ] ] ) { prevIndices [ i ] = tailIndices [ len - 1 ] ; tailIndices [ len ++ ] = i ; } else { int pos = GetCeilIndex ( arr , tailIndices , -1 , len - 1 , arr [ i ] ) ; prevIndices [ i ] = tailIndices [ pos - 1 ] ; tailIndices [ pos ] = i ; } } cout << " LIS ▁ of ▁ given ▁ input " << endl ; for ( int i = tailIndices [ len - 1 ] ; i >= 0 ; i = prevIndices [ i ] ) cout << arr [ i ] << " ▁ " ; cout << endl ; return len ; } int main ( ) { int arr [ ] = { 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " LIS ▁ size ▁ % d STRNEWLINE " , LongestIncreasingSubsequence ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { sum -= ( 2 * arr [ i ] ) ; sum += ( 2 * arr [ n - i - 1 ] ) ; } return sum ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void threeWayPartition ( int arr [ ] , int n , int lowVal , int highVal ) { int start = 0 , end = n - 1 ; for ( int i = 0 ; i <= end ; ) { if ( arr [ i ] < lowVal ) swap ( arr [ i ++ ] , arr [ start ++ ] ) ; else if ( arr [ i ] > highVal ) swap ( arr [ i ] , arr [ end -- ] ) ; else i ++ ; } } int main ( ) { int arr [ ] = { 1 , 14 , 5 , 20 , 4 , 2 , 54 , 20 , 87 , 98 , 3 , 1 , 32 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; threeWayPartition ( arr , n , 10 , 20 ) ; cout << " Modified ▁ array ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) ; void generateUtil ( int A [ ] , int B [ ] , int C [ ] , int i , int j , int m , int n , int len , bool flag ) { if ( flag ) { if ( len ) printArr ( C , len + 1 ) ; for ( int k = i ; k < m ; k ++ ) { if ( ! len ) { C [ len ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len , ! flag ) ; } else { if ( A [ k ] > C [ len ] ) { C [ len + 1 ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , ! flag ) ; } } } } else { for ( int l = j ; l < n ; l ++ ) { if ( B [ l ] > C [ len ] ) { C [ len + 1 ] = B [ l ] ; generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , ! flag ) ; } } } } void generate ( int A [ ] , int B [ ] , int m , int n ) { int C [ m + n ] ; generateUtil ( A , B , C , 0 , 0 , m , n , 0 , true ) ; } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int A [ ] = { 10 , 15 , 25 } ; int B [ ] = { 5 , 20 , 30 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int m = sizeof ( B ) / sizeof ( B [ 0 ] ) ; generate ( A , B , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void updateindex ( int index [ ] , int a , int ai , int b , int bi ) { index [ a ] = ai ; index [ b ] = bi ; } int minSwapsUtil ( int arr [ ] , int pairs [ ] , int index [ ] , int i , int n ) { if ( i > n ) return 0 ; if ( pairs [ arr [ i ] ] == arr [ i + 1 ] ) return minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; int one = arr [ i + 1 ] ; int indextwo = i + 1 ; int indexone = index [ pairs [ arr [ i ] ] ] ; int two = arr [ index [ pairs [ arr [ i ] ] ] ] ; swap ( arr [ i + 1 ] , arr [ indexone ] ) ; updateindex ( index , one , indexone , two , indextwo ) ; int a = minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; swap ( arr [ i + 1 ] , arr [ indexone ] ) ; updateindex ( index , one , indextwo , two , indexone ) ; one = arr [ i ] , indexone = index [ pairs [ arr [ i + 1 ] ] ] ; two = arr [ index [ pairs [ arr [ i + 1 ] ] ] ] , indextwo = i ; swap ( arr [ i ] , arr [ indexone ] ) ; updateindex ( index , one , indexone , two , indextwo ) ; int b = minSwapsUtil ( arr , pairs , index , i + 2 , n ) ; swap ( arr [ i ] , arr [ indexone ] ) ; updateindex ( index , one , indextwo , two , indexone ) ; return 1 + min ( a , b ) ; } int minSwaps ( int n , int pairs [ ] , int arr [ ] ) { int index [ 2 * n + 1 ] ; for ( int i = 1 ; i <= 2 * n ; i ++ ) index [ arr [ i ] ] = i ; return minSwapsUtil ( arr , pairs , index , 1 , 2 * n ) ; } int main ( ) { int arr [ ] = { 0 , 3 , 5 , 6 , 4 , 1 , 2 } ; int pairs [ ] = { 0 , 3 , 6 , 1 , 5 , 4 , 2 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = m / 2 ; cout << " Min ▁ swaps ▁ required ▁ is ▁ " << minSwaps ( n , pairs , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void replace_elements ( int arr [ ] , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 6 , 4 , 3 , 4 , 3 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; replace_elements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrangeString ( string str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { cout << "0" ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { cout << "1" ; count_1 -- ; } } } } int main ( ) { string str = "01101101101101101000000" ; int x = 1 ; int y = 2 ; arrangeString ( str , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void distinctAdjacentElement ( int a [ ] , int n ) { map < int , int > m ; for ( int i = 0 ; i < n ; ++ i ) m [ a [ i ] ] ++ ; int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( mx < m [ a [ i ] ] ) mx = m [ a [ i ] ] ; if ( mx > ( n + 1 ) / 2 ) cout << " NO " << endl ; else cout << " YES " << endl ; } int main ( ) { int a [ ] = { 7 , 7 , 7 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; distinctAdjacentElement ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void rearrange ( int arr [ ] , int n ) { if ( arr == NULL n % 2 == 1 ) return ; int currIdx = ( n - 1 ) / 2 ; while ( currIdx > 0 ) { int count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 2 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << " ▁ " << arr [ i ] ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; } int main ( ) { int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ difference ▁ is ▁ " << maxDiff ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDiff ( int arr [ ] , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; } int main ( ) { int arr [ ] = { 80 , 2 , 6 , 3 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ difference ▁ is ▁ " << maxDiff ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxIndexDiff ( vector < int > & arr , int n ) { unordered_map < int , vector < int > > hashmap ; for ( int i = 0 ; i < n ; i ++ ) { hashmap [ arr [ i ] ] . push_back ( i ) ; } sort ( arr . begin ( ) , arr . end ( ) ) ; int maxDiff = INT_MIN ; int temp = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( temp > hashmap [ arr [ i ] ] [ 0 ] ) { temp = hashmap [ arr [ i ] ] [ 0 ] ; } maxDiff = max ( maxDiff , hashmap [ arr [ i ] ] [ hashmap [ arr [ i ] ] . size ( ) - 1 ] - temp ) ; } return maxDiff ; } int main ( ) { int n = 9 ; vector < int > arr { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int ans = maxIndexDiff ( arr , n ) ; cout << " The ▁ maxIndexDiff ▁ is ▁ : ▁ " << ans << endl ; return 1 ; }
#include <iostream> NEW_LINE using namespace std ; void constructLowerArray ( int arr [ ] , int * countSmaller , int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ i ] ) countSmaller [ i ] ++ ; } } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 12 , 10 , 5 , 4 , 2 , 20 , 6 , 1 , 0 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * low = ( int * ) malloc ( sizeof ( int ) * n ) ; constructLowerArray ( arr , low , n ) ; printArray ( low , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int * a , int * b ) { int temp ; temp = * a ; * a = * b ; * b = temp ; } int segregate ( int arr [ ] , int size ) { int j = 0 , i ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] <= 0 ) { swap ( & arr [ i ] , & arr [ j ] ) ; j ++ ; } } return j ; } int findMissingPositive ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { if ( abs ( arr [ i ] ) - 1 < size && arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; } for ( i = 0 ; i < size ; i ++ ) if ( arr [ i ] > 0 ) return i + 1 ; return size + 1 ; } int findMissing ( int arr [ ] , int size ) { int shift = segregate ( arr , size ) ; return findMissingPositive ( arr + shift , size - shift ) ; } int main ( ) { int arr [ ] = { 0 , 10 , 2 , -10 , -20 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int missing = findMissing ( arr , arr_size ) ; cout << " The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ " << missing ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstMissingPositive ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] >= 1 && arr [ i ] <= n && arr [ i ] != arr [ arr [ i ] - 1 ] ) { swap ( arr [ i ] , arr [ arr [ i ] - 1 ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } } return n + 1 ; } int main ( ) { int arr [ ] = { 2 , 3 , -7 , 6 , 8 , 1 , -10 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int ans = firstMissingPositive ( arr , n ) ; cout << ans ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int maxRepeating ( int * arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % k ] += k ; int max = arr [ 0 ] , result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; result = i ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 5 , 3 , 4 , 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 8 ; cout << " The ▁ maximum ▁ repeating ▁ number ▁ is ▁ " << maxRepeating ( arr , n , k ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int max ( int x , int y ) { return ( x > y ) ? x : y ; } int maxPathSum ( int ar1 [ ] , int ar2 [ ] , int m , int n ) { int i = 0 , j = 0 ; int result = 0 , sum1 = 0 , sum2 = 0 ; while ( i < m && j < n ) { if ( ar1 [ i ] < ar2 [ j ] ) sum1 += ar1 [ i ++ ] ; else if ( ar1 [ i ] > ar2 [ j ] ) sum2 += ar2 [ j ++ ] ; else { result += max ( sum1 , sum2 ) + ar1 [ i ] ; sum1 = 0 ; sum2 = 0 ; i ++ ; j ++ ; } } while ( i < m ) sum1 += ar1 [ i ++ ] ; while ( j < n ) sum2 += ar2 [ j ++ ] ; result += max ( sum1 , sum2 ) ; return result ; } int main ( ) { int ar1 [ ] = { 2 , 3 , 7 , 10 , 12 , 15 , 30 , 34 } ; int ar2 [ ] = { 1 , 5 , 7 , 8 , 10 , 15 , 16 , 19 } ; int m = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; cout << " Maximum ▁ sum ▁ path ▁ is ▁ " << maxPathSum ( ar1 , ar2 , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallestGreater ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int diff = INT_MAX , closest = -1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } ( closest == -1 ) ? cout << " _ ▁ " : cout << arr [ closest ] << " ▁ " ; } } int main ( ) { int ar [ ] = { 6 , 3 , 9 , 8 , 10 , 2 , 1 , 15 , 7 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; smallestGreater ( ar , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallestGreater ( int arr [ ] , int n ) { set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { auto it = s . find ( arr [ i ] ) ; it ++ ; if ( it != s . end ( ) ) cout << * it << " ▁ " ; else cout << " _ ▁ " ; } } int main ( ) { int ar [ ] = { 6 , 3 , 9 , 8 , 10 , 2 , 1 , 15 , 7 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; smallestGreater ( ar , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #define d  256 NEW_LINE #define q  103 NEW_LINE void checkPalindromes ( char str [ ] ) { int N = strlen ( str ) ; printf ( " % c ▁ Yes STRNEWLINE " , str [ 0 ] ) ; if ( N == 1 ) return ; int firstr = str [ 0 ] % q ; int second = str [ 1 ] % q ; int h = 1 , i , j ; for ( i = 1 ; i < N ; i ++ ) { if ( firstr == second ) { for ( j = 0 ; j < i / 2 ; j ++ ) { if ( str [ j ] != str [ i - j ] ) break ; } ( j == i / 2 ) ? printf ( " % c ▁ Yes STRNEWLINE " , str [ i ] ) : printf ( " % c ▁ No STRNEWLINE " , str [ i ] ) ; } else printf ( " % c ▁ No STRNEWLINE " , str [ i ] ) ; if ( i != N - 1 ) { if ( i % 2 == 0 ) { h = ( h * d ) % q ; firstr = ( firstr + h * str [ i / 2 ] ) % q ; second = ( second * d + str [ i + 1 ] ) % q ; } else { second = ( d * ( second + q - str [ ( i + 1 ) / 2 ] * h ) % q + str [ i + 1 ] ) % q ; } } } } int main ( ) { char * txt = " aabaacaabaa " ; checkPalindromes ( txt ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findZeroes ( int arr [ ] , int n , int m ) { int wL = 0 , wR = 0 ; int bestL = 0 , bestWindow = 0 ; int zeroCount = 0 ; while ( wR < n ) { if ( zeroCount <= m ) { if ( arr [ wR ] == 0 ) zeroCount ++ ; wR ++ ; } if ( zeroCount > m ) { if ( arr [ wL ] == 0 ) zeroCount -- ; wL ++ ; } if ( ( wR - wL > bestWindow ) && ( zeroCount <= m ) ) { bestWindow = wR - wL ; bestL = wL ; } } for ( int i = 0 ; i < bestWindow ; i ++ ) { if ( arr [ bestL + i ] == 0 ) cout << bestL + i << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 } ; int m = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Indexes ▁ of ▁ zeroes ▁ to ▁ be ▁ flipped ▁ are ▁ " ; findZeroes ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is ▁ " << countIncreasing ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is ▁ " << countIncreasing ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int arraySum ( int arr [ ] , int n ) { long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; } long long int maxDiff ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; long long int arraysum = arraySum ( arr , n ) ; long long int diff1 = abs ( arraysum - 2 * arraySum ( arr , k ) ) ; reverse ( arr , arr + n ) ; long long int diff2 = abs ( arraysum - 2 * arraySum ( arr , k ) ) ; return ( max ( diff1 , diff2 ) ) ; } int main ( ) { int arr [ ] = { 1 , 7 , 4 , 8 , -1 , 5 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << " Maximum ▁ Difference ▁ = ▁ " << maxDiff ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minNumber ( int a [ ] , int n , int x ) { sort ( a , a + n ) ; int k ; for ( k = 0 ; a [ ( n - 1 ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; sort ( a , a + n ) ; } return k ; } int main ( ) { int x = 10 ; int a [ 6 ] = { 10 , 20 , 30 } ; int n = 3 ; cout << minNumber ( a , n , x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; } int main ( ) { int x = 10 ; int a [ ] = { 10 , 20 , 30 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minNumber ( a , n , x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int preprocess ( int arr [ ] , int N , int left [ ] , int right [ ] ) { left [ 0 ] = 0 ; int lastIncr = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) lastIncr = i ; left [ i ] = lastIncr ; } right [ N - 1 ] = N - 1 ; int firstDecr = N - 1 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) firstDecr = i ; right [ i ] = firstDecr ; } } bool isSubarrayMountainForm ( int arr [ ] , int left [ ] , int right [ ] , int L , int R ) { return ( right [ L ] >= left [ R ] ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 2 , 4 , 4 , 6 , 3 , 2 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int left [ N ] , right [ N ] ; preprocess ( arr , N , left , right ) ; int L = 0 ; int R = 2 ; if ( isSubarrayMountainForm ( arr , left , right , L , R ) ) cout << " Subarray ▁ is ▁ in ▁ mountain ▁ form STRNEWLINE " ; else cout << " Subarray ▁ is ▁ not ▁ in ▁ mountain ▁ form STRNEWLINE " ; L = 1 ; R = 3 ; if ( isSubarrayMountainForm ( arr , left , right , L , R ) ) cout << " Subarray ▁ is ▁ in ▁ mountain ▁ form STRNEWLINE " ; else cout << " Subarray ▁ is ▁ not ▁ in ▁ mountain ▁ form STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void preCompute ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = arr [ i ] + pre [ i - 1 ] ; } int rangeSum ( int i , int j , int pre [ ] ) { if ( i == 0 ) return pre [ j ] ; return pre [ j ] - pre [ i - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int pre [ n ] ; preCompute ( arr , n , pre ) ; cout << rangeSum ( 1 , 3 , pre ) << endl ; cout << rangeSum ( 2 , 4 , pre ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE void sieveOfEratosthenes ( bool isPrime [ ] ) { isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } } int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } int queryPrimesUtil ( int * st , int ss , int se , int qs , int qe , int index ) { if ( qs <= ss && qe >= se ) return st [ index ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return queryPrimesUtil ( st , ss , mid , qs , qe , 2 * index + 1 ) + queryPrimesUtil ( st , mid + 1 , se , qs , qe , 2 * index + 2 ) ; } void updateValueUtil ( int * st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } } void updateValue ( int arr [ ] , int * st , int n , int i , int new_val , bool isPrime [ ] ) { if ( i < 0 i > n - 1 ) { printf ( " Invalid ▁ Input " ) ; return ; } int diff , oldValue ; oldValue = arr [ i ] ; arr [ i ] = new_val ; if ( isPrime [ oldValue ] && isPrime [ new_val ] ) return ; if ( ( ! isPrime [ oldValue ] ) && ( ! isPrime [ new_val ] ) ) return ; if ( isPrime [ oldValue ] && ! isPrime [ new_val ] ) { diff = -1 ; } if ( ! isPrime [ oldValue ] && isPrime [ new_val ] ) { diff = 1 ; } updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } void queryPrimes ( int * st , int n , int qs , int qe ) { int primesInRange = queryPrimesUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; cout << " Number ▁ of ▁ Primes ▁ in ▁ subarray ▁ from ▁ " << qs << " ▁ to ▁ " << qe << " ▁ = ▁ " << primesInRange << " STRNEWLINE " ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si , bool isPrime [ ] ) { if ( ss == se ) { if ( isPrime [ arr [ ss ] ] ) st [ si ] = 1 ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , isPrime ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , isPrime ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n , bool isPrime [ ] ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 , isPrime ) ; return st ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; bool isPrime [ MAX + 1 ] ; memset ( isPrime , true , sizeof isPrime ) ; sieveOfEratosthenes ( isPrime ) ; int * st = constructST ( arr , n , isPrime ) ; int start = 0 ; int end = 4 ; queryPrimes ( st , n , start , end ) ; int i = 3 ; int x = 6 ; updateValue ( arr , st , n , i , x , isPrime ) ; start = 0 ; end = 4 ; queryPrimes ( st , n , start , end ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkEVENodd ( int arr [ ] , int n , int l , int r ) { if ( arr [ r ] == 1 ) cout << " odd " << endl ; else cout << " even " << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkEVENodd ( arr , n , 1 , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > twos ( 1000 , 0 ) ; vector < int > fives ( 1000 , 0 ) ; int sum = 0 ; int returnTwos ( int val ) { int count = 0 ; while ( val % 2 == 0 && val != 0 ) { val = val / 2 ; count ++ ; } return count ; } int returnFives ( int val ) { int count = 0 ; while ( val % 5 == 0 && val != 0 ) { val = val / 5 ; count ++ ; } return count ; } void solve_queries ( int arr [ ] , int n ) { int type , ql , qr , x , y ; cin >> type ; if ( type == 1 ) { cin >> ql >> qr >> x ; int temp = returnTwos ( x ) ; int temp1 = returnFives ( x ) ; for ( int i = ql - 1 ; i < qr ; i ++ ) { arr [ i ] = arr [ i ] * x ; twos [ i ] += temp ; fives [ i ] += temp1 ; } } if ( type == 2 ) { cin >> ql >> qr >> y ; int temp = returnTwos ( y ) ; int temp1 = returnFives ( y ) ; for ( int i = ql - 1 ; i < qr ; i ++ ) { arr [ i ] = ( i - ql + 2 ) * y ; twos [ i ] = returnTwos ( i - ql + 2 ) + temp ; fives [ i ] = returnFives ( i - ql + 2 ) + temp1 ; } } if ( type == 3 ) { cin >> ql >> qr ; int sumtwos = 0 ; int sumfives = 0 ; for ( int i = ql - 1 ; i < qr ; i ++ ) { sumtwos += twos [ i ] ; sumfives += fives [ i ] ; } sum += min ( sumtwos , sumfives ) ; } } int main ( ) { int n , m ; cin >> n >> m ; int arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cin >> arr [ i ] ; twos [ i ] = returnTwos ( arr [ i ] ) ; fives [ i ] = returnFives ( arr [ i ] ) ; } while ( m -- ) { solve_queries ( arr , n ) ; } cout << sum << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMean ( int arr [ ] , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = floor ( sum / count ) ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; cout << findMean ( arr , 0 , 2 ) << endl ; cout << findMean ( arr , 1 , 3 ) << endl ; cout << findMean ( arr , 0 , 4 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  1000005 NEW_LINE using namespace std ; int prefixSum [ MAX ] ; void calculatePrefixSum ( int arr [ ] , int n ) { prefixSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; } int findMean ( int l , int r ) { if ( l == 0 ) return floor ( prefixSum [ r ] / ( r + 1 ) ) ; return floor ( ( prefixSum [ r ] - prefixSum [ l - 1 ] ) / ( r - l + 1 ) ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; calculatePrefixSum ( arr , n ) ; cout << findMean ( 0 , 2 ) << endl ; cout << findMean ( 1 , 3 ) << endl ; cout << findMean ( 0 , 4 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void updateQuery ( int arr [ ] , int n , int q , int l , int r , int k ) { if ( q == 0 ) { arr [ l - 1 ] += k ; arr [ r ] += - k ; } else { arr [ l - 1 ] += - k ; arr [ r ] += k ; } return ; } void generateArray ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; ++ i ) arr [ i ] += arr [ i - 1 ] ; return ; } int main ( ) { int n = 5 ; int arr [ n + 1 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; int q = 0 , l = 1 , r = 3 , k = 2 ; updateQuery ( arr , n , q , l , r , k ) ; q = 1 , l = 3 , r = 5 , k = 3 ; updateQuery ( arr , n , q , l , r , k ) ; q = 0 , l = 2 , r = 5 , k = 1 ; updateQuery ( arr , n , q , l , r , k ) ; generateArray ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateProduct ( int A [ ] , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans = 1 ; for ( int i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int P = 229 ; int L = 2 , R = 5 ; cout << calculateProduct ( A , L , R , P ) << endl ; L = 1 , R = 3 ; cout << calculateProduct ( A , L , R , P ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE int pre_product [ MAX ] ; int inverse_product [ MAX ] ; int modInverse ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m , a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } void calculate_Pre_Product ( int A [ ] , int N , int P ) { pre_product [ 0 ] = A [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pre_product [ i ] = pre_product [ i - 1 ] * A [ i ] ; pre_product [ i ] = pre_product [ i ] % P ; } } void calculate_inverse_product ( int A [ ] , int N , int P ) { inverse_product [ 0 ] = modInverse ( pre_product [ 0 ] , P ) ; for ( int i = 1 ; i < N ; i ++ ) inverse_product [ i ] = modInverse ( pre_product [ i ] , P ) ; } int calculateProduct ( int A [ ] , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans ; if ( L == 0 ) ans = pre_product [ R ] ; else ans = pre_product [ R ] * inverse_product [ L - 1 ] ; return ans ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int P = 113 ; calculate_Pre_Product ( A , N , P ) ; calculate_inverse_product ( A , N , P ) ; int L = 2 , R = 5 ; cout << calculateProduct ( A , L , R , P ) << endl ; L = 1 , R = 3 ; cout << calculateProduct ( A , L , R , P ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; int prefix [ MAX + 1 ] ; void buildPrefix ( ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] ++ ; } } int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; } int main ( ) { buildPrefix ( ) ; int L = 5 , R = 10 ; cout << query ( L , R ) << endl ; L = 1 , R = 10 ; cout << query ( L , R ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void command ( bool arr [ ] , int a , int b ) { arr [ a ] ^= 1 ; arr [ b + 1 ] ^= 1 ; } void process ( bool arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) arr [ k ] ^= arr [ k - 1 ] ; } void result ( bool arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) cout << arr [ k ] << " ▁ " ; } int main ( ) { int n = 5 , m = 3 ; bool arr [ n + 2 ] = { 0 } ; command ( arr , 1 , 5 ) ; command ( arr , 2 , 5 ) ; command ( arr , 3 , 5 ) ; process ( arr , n ) ; result ( arr , n ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; struct Interval { int start ; int end ; } ; bool compareInterval ( Interval i1 , Interval i2 ) { return ( i1 . start < i2 . start ) ? true : false ; } bool isIntersect ( Interval arr [ ] , int n ) { sort ( arr , arr + n , compareInterval ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] . end > arr [ i ] . start ) return true ; return false ; } int main ( ) { Interval arr1 [ ] = { { 1 , 3 } , { 7 , 9 } , { 4 , 6 } , { 10 , 13 } } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; isIntersect ( arr1 , n1 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; Interval arr2 [ ] = { { 6 , 8 } , { 1 , 3 } , { 2 , 4 } , { 4 , 7 } } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; isIntersect ( arr2 , n2 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; struct Interval { int start ; int end ; } ; bool isIntersect ( Interval arr [ ] , int n ) { int max_ele = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_ele < arr [ i ] . end ) max_ele = arr [ i ] . end ; } int aux [ max_ele + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] . start ; int y = arr [ i ] . end ; aux [ x ] ++ , aux [ y + 1 ] -- ; } for ( int i = 1 ; i <= max_ele ; i ++ ) { aux [ i ] += aux [ i - 1 ] ; if ( aux [ i ] > 1 ) return true ; } return false ; } int main ( ) { Interval arr1 [ ] = { { 1 , 3 } , { 7 , 9 } , { 4 , 6 } , { 10 , 13 } } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; isIntersect ( arr1 , n1 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; Interval arr2 [ ] = { { 6 , 8 } , { 1 , 3 } , { 2 , 4 } , { 4 , 7 } } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; isIntersect ( arr2 , n2 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct query { int start , end ; } ; void incrementByD ( int arr [ ] , struct query q_arr [ ] , int n , int m , int d ) { int sum [ n ] ; memset ( sum , 0 , sizeof ( sum ) ) ; for ( int i = 0 ; i < m ; i ++ ) { sum [ q_arr [ i ] . start ] += d ; if ( ( q_arr [ i ] . end + 1 ) < n ) sum [ q_arr [ i ] . end + 1 ] -= d ; } arr [ 0 ] += sum [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum [ i ] += sum [ i - 1 ] ; arr [ i ] += sum [ i ] ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 3 , 5 , 4 , 8 , 6 , 1 } ; struct query q_arr [ ] = { { 0 , 3 } , { 4 , 5 } , { 1 , 4 } , { 0 , 1 } , { 2 , 5 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = sizeof ( q_arr ) / sizeof ( q_arr [ 0 ] ) ; int d = 2 ; cout << " Original ▁ Array : STRNEWLINE " ; printArray ( arr , n ) ; incrementByD ( arr , q_arr , n , m , d ) ; cout << " Modified Array : " printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void prefixXOR ( int arr [ ] , int preXOR [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( arr [ i ] % 2 != 1 ) arr [ i ] /= 2 ; preXOR [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) preXOR [ i ] = preXOR [ i - 1 ] ^ preXOR [ i ] ; } int query ( int preXOR [ ] , int l , int r ) { if ( l == 0 ) return preXOR [ r ] ; else return preXOR [ r ] ^ preXOR [ l - 1 ] ; } int main ( ) { int arr [ ] = { 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int preXOR [ n ] ; prefixXOR ( arr , preXOR , n ) ; cout << query ( preXOR , 0 , 2 ) << endl ; cout << query ( preXOR , 1 , 2 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000001 ; struct Query { int l , r , idx ; } ; bool cmp ( Query x , Query y ) { return x . r < y . r ; } void update ( int idx , int val , int bit [ ] , int n ) { for ( ; idx <= n ; idx += idx & - idx ) bit [ idx ] += val ; } int query ( int idx , int bit [ ] , int n ) { int sum = 0 ; for ( ; idx > 0 ; idx -= idx & - idx ) sum += bit [ idx ] ; return sum ; } void answeringQueries ( int arr [ ] , int n , Query queries [ ] , int q ) { int bit [ n + 1 ] ; memset ( bit , 0 , sizeof ( bit ) ) ; int last_visit [ MAX ] ; memset ( last_visit , -1 , sizeof ( last_visit ) ) ; int ans [ q ] ; int query_counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last_visit [ arr [ i ] ] != -1 ) update ( last_visit [ arr [ i ] ] + 1 , -1 , bit , n ) ; last_visit [ arr [ i ] ] = i ; update ( i + 1 , 1 , bit , n ) ; while ( query_counter < q && queries [ query_counter ] . r == i ) { ans [ queries [ query_counter ] . idx ] = query ( queries [ query_counter ] . r + 1 , bit , n ) - query ( queries [ query_counter ] . l , bit , n ) ; query_counter ++ ; } } for ( int i = 0 ; i < q ; i ++ ) cout << ans [ i ] << endl ; } int main ( ) { int a [ ] = { 1 , 1 , 2 , 1 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Query queries [ 3 ] ; queries [ 0 ] . l = 0 ; queries [ 0 ] . r = 4 ; queries [ 0 ] . idx = 0 ; queries [ 1 ] . l = 1 ; queries [ 1 ] . r = 3 ; queries [ 1 ] . idx = 1 ; queries [ 2 ] . l = 2 ; queries [ 2 ] . r = 4 ; queries [ 2 ] . idx = 2 ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; sort ( queries , queries + q , cmp ) ; answeringQueries ( a , n , queries , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100000 ; int tree [ MAX ] = { 0 } ; bool lazy [ MAX ] = { false } ; void toggle ( int node , int st , int en , int us , int ue ) { if ( lazy [ node ] ) { lazy [ node ] = false ; tree [ node ] = en - st + 1 - tree [ node ] ; if ( st < en ) { lazy [ node << 1 ] = ! lazy [ node << 1 ] ; lazy [ 1 + ( node << 1 ) ] = ! lazy [ 1 + ( node << 1 ) ] ; } } if ( st > en us > en ue < st ) return ; if ( us <= st && en <= ue ) { tree [ node ] = en - st + 1 - tree [ node ] ; if ( st < en ) { lazy [ node << 1 ] = ! lazy [ node << 1 ] ; lazy [ 1 + ( node << 1 ) ] = ! lazy [ 1 + ( node << 1 ) ] ; } return ; } int mid = ( st + en ) / 2 ; toggle ( ( node << 1 ) , st , mid , us , ue ) ; toggle ( ( node << 1 ) + 1 , mid + 1 , en , us , ue ) ; if ( st < en ) tree [ node ] = tree [ node << 1 ] + tree [ ( node << 1 ) + 1 ] ; } int countQuery ( int node , int st , int en , int qs , int qe ) { if ( st > en qs > en qe < st ) return 0 ; if ( lazy [ node ] ) { lazy [ node ] = false ; tree [ node ] = en - st + 1 - tree [ node ] ; if ( st < en ) { lazy [ node << 1 ] = ! lazy [ node << 1 ] ; lazy [ ( node << 1 ) + 1 ] = ! lazy [ ( node << 1 ) + 1 ] ; } } if ( qs <= st && en <= qe ) return tree [ node ] ; int mid = ( st + en ) / 2 ; return countQuery ( ( node << 1 ) , st , mid , qs , qe ) + countQuery ( ( node << 1 ) + 1 , mid + 1 , en , qs , qe ) ; } int main ( ) { int n = 5 ; toggle ( 1 , 0 , n - 1 , 1 , 2 ) ; toggle ( 1 , 0 , n - 1 , 2 , 4 ) ; cout << countQuery ( 1 , 0 , n - 1 , 2 , 3 ) << endl ; toggle ( 1 , 0 , n - 1 , 2 , 4 ) ; cout << countQuery ( 1 , 0 , n - 1 , 1 , 4 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n , int x , int k ) { sort ( a , a + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int d = ( a [ i ] - 1 ) / x ; int it1 = lower_bound ( a , a + n , max ( ( d + k ) * x , a [ i ] ) ) - a ; int it2 = lower_bound ( a , a + n , max ( ( d + k + 1 ) * x , a [ i ] ) ) - a ; ans += it2 - it1 ; } return ans ; } int main ( ) { int a [ ] = { 1 , 3 , 5 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int x = 2 , k = 1 ; cout << countPairs ( a , n , x , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDe ( int arr [ ] , int n ) { vector < int > v ( arr , arr + n ) ; sort ( arr , arr + n ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; reverse ( arr , arr + n ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( min ( count1 , count2 ) ) ; } int main ( ) { int arr [ ] = { 5 , 9 , 21 , 17 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ Dearrangement ▁ = ▁ " << countDe ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxOfSegmentMins ( int a [ ] , int n , int k ) { if ( k == 1 ) return * min_element ( a , a + n ) ; if ( k == 2 ) return max ( a [ 0 ] , a [ n - 1 ] ) ; return * max_element ( a , a + n ) ; } int main ( ) { int a [ ] = { -10 , -9 , -8 , 2 , 7 , -6 , -5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 2 ; cout << maxOfSegmentMins ( a , n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printMinimumProduct ( int arr [ ] , int n ) { int first_min = min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; } int main ( ) { int a [ ] = { 11 , 8 , 5 , 7 , 5 , 100 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << printMinimumProduct ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long noOfTriples ( long long arr [ ] , int n ) { sort ( arr , arr + n ) ; long long count = 0 ; for ( long long i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; } int main ( ) { long long arr [ ] = { 1 , 3 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << noOfTriples ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkReverse ( int arr [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; sort ( temp , temp + n ) ; int front ; for ( front = 0 ; front < n ; front ++ ) if ( temp [ front ] != arr [ front ] ) break ; int back ; for ( back = n - 1 ; back >= 0 ; back -- ) if ( temp [ back ] != arr [ back ] ) break ; if ( front >= back ) return true ; do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) return false ; } while ( front != back ) ; return true ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkReverse ( arr , n ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) return true ; int i ; for ( i = 1 ; i < n && arr [ i - 1 ] < arr [ i ] ; i ++ ) ; if ( i == n ) return true ; int j = i ; while ( j < n && arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ; j ++ ; } if ( j == n ) return true ; int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) return false ; while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) return false ; k ++ ; } return true ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 10 , 9 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkReverse ( arr , n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOperation ( int a [ ] , int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { result = result + abs ( a [ i ] - b [ i ] ) ; } return result ; } int main ( ) { int a [ ] = { 3 , 1 , 1 } ; int b [ ] = { 1 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinOperation ( a , b , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortExceptUandL ( int a [ ] , int l , int u , int n ) { int b [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; sort ( b , b + n - ( u - l + 1 ) ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; } int main ( ) { int a [ ] = { 5 , 4 , 3 , 12 , 14 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int l = 2 , u = 4 ; sortExceptUandL ( a , l , u , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sortExceptK ( int arr [ ] , int k , int n ) { swap ( arr [ k ] , arr [ n - 1 ] ) ; sort ( arr , arr + n - 1 ) ; int last = arr [ n - 1 ] ; for ( int i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; } int main ( ) { int a [ ] = { 10 , 4 , 11 , 7 , 6 , 20 } ; int k = 2 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; sortExceptK ( a , k , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void printList ( struct Node * ) ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = * head_ref ; * head_ref = new_node ; } void printList ( struct Node * head ) { while ( head != NULL ) { cout << head -> data << " ▁ - > ▁ " ; head = head -> next ; } } void sortlist ( int arr [ ] , int N , struct Node * head ) { unordered_map < int , int > hash ; struct Node * temp = head ; while ( temp ) { hash [ temp -> data ] ++ ; temp = temp -> next ; } temp = head ; for ( int i = 0 ; i < N ; i ++ ) { int frequency = hash [ arr [ i ] ] ; while ( frequency -- ) { temp -> data = arr [ i ] ; temp = temp -> next ; } } } int main ( ) { struct Node * head = NULL ; int arr [ ] = { 5 , 1 , 3 , 2 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; push ( & head , 3 ) ; push ( & head , 2 ) ; push ( & head , 5 ) ; push ( & head , 8 ) ; push ( & head , 5 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; sortlist ( arr , N , head ) ; cout << " Sorted ▁ List : " << endl ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRepeating ( int arr [ ] , int size ) { set < int > s ( arr , arr + size ) ; for ( auto x : s ) cout << x << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 0 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxPartitions ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void cuttringRopes ( int Ropes [ ] , int n ) { sort ( Ropes , Ropes + n ) ; int singleOperation = 0 ; int cuttingLenght = Ropes [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( Ropes [ i ] - cuttingLenght > 0 ) { cout << ( n - i ) << " ▁ " ; cuttingLenght = Ropes [ i ] ; singleOperation ++ ; } } if ( singleOperation == 0 ) cout << "0 ▁ " ; } int main ( ) { int Ropes [ ] = { 5 , 1 , 1 , 2 , 3 , 5 } ; int n = sizeof ( Ropes ) / sizeof ( Ropes [ 0 ] ) ; cuttringRopes ( Ropes , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rankify ( int * A , int n ) { float R [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int r = 1 , s = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i && A [ j ] < A [ i ] ) r += 1 ; if ( j != i && A [ j ] == A [ i ] ) s += 1 ; } R [ i ] = r + ( float ) ( s - 1 ) / ( float ) 2 ; } for ( int i = 0 ; i < n ; i ++ ) cout << R [ i ] << ' ▁ ' ; } int main ( ) { int A [ ] = { 1 , 2 , 5 , 2 , 1 , 25 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) cout << A [ i ] << ' ▁ ' ; cout << ' ' ; rankify ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << min_noOf_operation ( arr , N , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; } int main ( ) { int arr [ ] = { 3 , 5 , 6 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; } int main ( ) { int a [ ] = { 1 , 10 , 4 , 2 } ; int k = 3 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; } int main ( ) { int a [ ] = { 1 , 10 , 4 , 2 } ; int k = 3 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll findMaxPairs ( ll a [ ] , ll b [ ] , ll n , ll k ) { sort ( a , a + n ) ; sort ( b , b + n ) ; bool flag [ n ] ; memset ( flag , false , sizeof ( flag ) ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - b [ j ] ) <= k && flag [ j ] == false ) { result ++ ; flag [ j ] = true ; break ; } } } return result ; } int main ( ) { ll a [ ] = { 10 , 15 , 20 } , b [ ] = { 17 , 12 , 24 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; cout << findMaxPairs ( a , b , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll findMaxPairs ( ll a [ ] , ll b [ ] , ll n , ll k ) { sort ( a , a + n ) ; sort ( b , b + n ) ; int result = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { if ( abs ( a [ i ] - b [ j ] ) <= k ) { result ++ ; i ++ ; j ++ ; } else if ( a [ i ] > b [ j ] ) j ++ ; else i ++ ; } return result ; } int main ( ) { ll a [ ] = { 10 , 15 , 20 } ; ll b [ ] = { 17 , 12 , 24 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; cout << findMaxPairs ( a , b , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfMinAbsDifferences ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int sum = 0 ; sum += abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; } int main ( ) { int arr [ ] = { 5 , 10 , 1 , 4 , 8 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ = ▁ " << sumOfMinAbsDifferences ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) { sort ( A , A + m ) ; sort ( B , B + n ) ; int a = 0 , b = 0 ; int result = INT_MAX ; while ( a < m && b < n ) { if ( abs ( A [ a ] - B [ b ] ) < result ) result = abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; } int main ( ) { int A [ ] = { 1 , 2 , 11 , 5 } ; int B [ ] = { 4 , 12 , 19 , 23 , 127 , 235 } ; int m = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int n = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << findSmallestDifference ( A , B , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( arraySortedOrNot ( arr , n ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLarger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 3 , 6 , 1 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findLarger ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int singleNumber ( int nums [ ] , int n ) { map < int , int > m ; long sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( m [ nums [ i ] ] == 0 ) { sum1 += nums [ i ] ; m [ nums [ i ] ] ++ ; } sum2 += nums [ i ] ; } return 2 * ( sum1 ) - sum2 ; } int main ( ) { int a [ ] = { 2 , 3 , 5 , 4 , 5 , 3 , 4 } ; int n = 7 ; cout << singleNumber ( a , n ) << " STRNEWLINE " ; int b [ ] = { 15 , 18 , 16 , 18 , 16 , 15 , 89 } ; cout << singleNumber ( b , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int arr [ ] , int n , int sum ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) ans ++ ; } } return ans ; } int main ( ) { int arr [ ] = { 5 , 1 , 3 , 4 , 7 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int sum = 12 ; cout << countTriplets ( arr , n , sum ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int a [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( a [ i ] ) ; int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int xr = a [ i ] ^ a [ j ] ; if ( s . find ( xr ) != s . end ( ) && xr != a [ i ] && xr != a [ j ] ) count ++ ; } } return count / 3 ; } int main ( ) { int a [ ] = { 1 , 3 , 5 , 10 , 14 , 15 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countTriplets ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 2 ; cout << countOccurrences ( arr , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return -1 ; int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } int countOccurrences ( int arr [ ] , int n , int x ) { int ind = binarySearch ( arr , 0 , n - 1 , x ) ; if ( ind == -1 ) return 0 ; int count = 1 ; int left = ind - 1 ; while ( left >= 0 && arr [ left ] == x ) count ++ , left -- ; int right = ind + 1 ; while ( right < n && arr [ right ] == x ) count ++ , right ++ ; return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 2 ; cout << countOccurrences ( arr , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printClosest ( int arr [ ] , int n , int x ) { int res_l , res_r ; int l = 0 , r = n - 1 , diff = INT_MAX ; while ( r > l ) { if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } cout << " ▁ The ▁ closest ▁ pair ▁ is ▁ " << arr [ res_l ] << " ▁ and ▁ " << arr [ res_r ] ; } int main ( ) { int arr [ ] = { 10 , 22 , 28 , 29 , 30 , 40 } , x = 54 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printClosest ( arr , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; } int main ( ) { bool arr [ ] = { 1 , 1 , 1 , 1 , 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is ▁ " << countOnes ( arr , 0 , n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOnes ( bool arr [ ] , int n ) { int ans ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] < 1 ) high = mid - 1 ; else if ( arr [ mid ] > 1 ) low = mid + 1 ; else { if ( mid == n - 1 arr [ mid + 1 ] != 1 ) return mid + 1 ; else low = mid + 1 ; } } } int main ( ) { bool arr [ ] = { 1 , 1 , 1 , 1 , 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is ▁ " << countOnes ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMissingUtil ( int arr1 [ ] , int arr2 [ ] , int N ) { if ( N == 1 ) return arr1 [ 0 ] ; if ( arr1 [ 0 ] != arr2 [ 0 ] ) return arr1 [ 0 ] ; int lo = 0 , hi = N - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( arr1 [ mid ] == arr2 [ mid ] ) lo = mid ; else hi = mid ; if ( lo == hi - 1 ) break ; } return arr1 [ hi ] ; } void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( N == M - 1 ) cout << " Missing ▁ Element ▁ is ▁ " << findMissingUtil ( arr1 , arr2 , M ) << endl ; else if ( M == N - 1 ) cout << " Missing ▁ Element ▁ is ▁ " << findMissingUtil ( arr2 , arr1 , N ) << endl ; else cout << " Invalid ▁ Input " ; } int main ( ) { int arr1 [ ] = { 1 , 4 , 5 , 7 , 9 } ; int arr2 [ ] = { 4 , 5 , 7 , 9 } ; int M = sizeof ( arr1 ) / sizeof ( int ) ; int N = sizeof ( arr2 ) / sizeof ( int ) ; findMissing ( arr1 , arr2 , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { cout << " Invalid ▁ Input " ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; cout << " Missing ▁ element ▁ is ▁ " << res ; } int main ( ) { int arr1 [ ] = { 4 , 1 , 5 , 9 , 7 } ; int arr2 [ ] = { 7 , 5 , 9 , 4 } ; int M = sizeof ( arr1 ) / sizeof ( int ) ; int N = sizeof ( arr2 ) / sizeof ( int ) ; findMissing ( arr1 , arr2 , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getTwoElements ( int arr [ ] , int n , int * x , int * y ) { int xor1 ; int set_bit_no ; int i ; * x = 0 ; * y = 0 ; xor1 = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) xor1 = xor1 ^ arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor1 = xor1 ^ i ; set_bit_no = xor1 & ~ ( xor1 - 1 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit_no ) * x = * x ^ arr [ i ] ; else * y = * y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) * x = * x ^ i ; else * y = * y ^ i ; } } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 , 6 , 2 } ; int * x = ( int * ) malloc ( sizeof ( int ) ) ; int * y = ( int * ) malloc ( sizeof ( int ) ) ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getTwoElements ( arr , n , x , y ) ; cout << " ▁ The ▁ missing ▁ element ▁ is ▁ " << * x << " ▁ and ▁ the ▁ repeating " << " ▁ number ▁ is ▁ " << * y ; getchar ( ) ; }
#include <iostream> NEW_LINE #include <unordered_map> NEW_LINE using namespace std ; int main ( ) { int arr [ ] = { 4 , 3 , 6 , 2 , 1 , 1 } ; int n = 6 ; unordered_map < int , bool > numberMap ; for ( int i : arr ) { if ( numberMap . find ( i ) == numberMap . end ( ) ) { numberMap [ i ] = true ; } else { cout << " Repeating ▁ = ▁ " << i ; } } cout << endl ; for ( int i = 1 ; i <= n ; i ++ ) { if ( numberMap . find ( i ) == numberMap . end ( ) ) { cout << " Missing ▁ = ▁ " << i ; } } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findFourElements ( int arr [ ] , int n , int X ) { unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) mp [ arr [ i ] + arr [ j ] ] = { i , j } ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( mp . find ( X - sum ) != mp . end ( ) ) { pair < int , int > p = mp [ X - sum ] ; if ( p . first != i && p . first != j && p . second != i && p . second != j ) { cout << arr [ i ] << " , ▁ " << arr [ j ] << " , ▁ " << arr [ p . first ] << " , ▁ " << arr [ p . second ] ; return ; } } } } } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 91 ; findFourElements ( arr , n , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int arr [ ] , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + abs ( arr [ i ] - x ) ; } cout << " number ▁ is ▁ not ▁ present ! " ; return -1 ; } int main ( ) { int arr [ ] = { 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; cout << " Element ▁ " << x << " ▁ is ▁ present ▁ at ▁ index ▁ " << search ( arr , n , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; printf ( " The ▁ third ▁ Largest ▁ element ▁ is ▁ % d STRNEWLINE " , third ) ; } int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; thirdLargest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void thirdLargest ( int arr [ ] , int arr_size ) { if ( arr_size < 3 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] , second = INT_MIN , third = INT_MIN ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) third = arr [ i ] ; } printf ( " The ▁ third ▁ Largest ▁ element ▁ is ▁ % d STRNEWLINE " , third ) ; } int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; thirdLargest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPair ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; sum = sum / 2 ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . find ( val ) != s . end ( ) ) { printf ( " Pair ▁ elements ▁ are ▁ % d ▁ and ▁ % d STRNEWLINE " , arr [ i ] , val ) ; return true ; } s . insert ( arr [ i ] ) ; } return false ; } int main ( ) { int arr [ ] = { 2 , 11 , 5 , 1 , 4 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkPair ( arr , n ) == false ) printf ( " No ▁ pair ▁ found " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string search ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return " Found " ; int backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( int i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " Found " ; return " Not ▁ Found " ; } } } int main ( ) { int arr [ ] = { 4 , 6 , 1 , 5 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 1 ; cout << search ( arr , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < int , int > sequence ( const vector < int > & a ) { if ( a . size ( ) == 0 ) return { 0 , 0 } ; int s = 0 ; int e = a . size ( ) - 1 ; while ( s < e ) { int m = ( s + e ) / 2 ; if ( a [ m ] >= m + a [ 0 ] ) s = m + 1 ; else e = m ; } return { a [ s ] , a . size ( ) - ( a [ a . size ( ) - 1 ] - a [ 0 ] ) } ; } int main ( ) { pair < int , int > p = sequence ( { 1 , 2 , 3 , 4 , 4 , 4 , 5 , 6 } ) ; cout << " Repeated ▁ element ▁ is ▁ " << p . first << " , ▁ it ▁ appears ▁ " << p . second << " ▁ times " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ; int res = abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; cout << " Min ▁ Difference ▁ = ▁ " << res ; } int main ( ) { int a [ ] = { 10 , 12 , 13 , 15 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; minAdjDifference ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100000 NEW_LINE using namespace std ; int Print3Smallest ( int array [ ] , int n ) { int firstmin = MAX , secmin = MAX , thirdmin = MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] < firstmin ) { thirdmin = secmin ; secmin = firstmin ; firstmin = array [ i ] ; } else if ( array [ i ] < secmin ) { thirdmin = secmin ; secmin = array [ i ] ; } else if ( array [ i ] < thirdmin ) thirdmin = array [ i ] ; } cout << " First ▁ min ▁ = ▁ " << firstmin << " STRNEWLINE " ; cout << " Second ▁ min ▁ = ▁ " << secmin << " STRNEWLINE " ; cout << " Third ▁ min ▁ = ▁ " << thirdmin << " STRNEWLINE " ; } int main ( ) { int array [ ] = { 4 , 9 , 1 , 32 , 12 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; Print3Smallest ( array , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMin ( int arr [ ] , int n ) { return ( n == 1 ) ? arr [ 0 ] : min ( arr [ 0 ] , getMin ( arr + 1 , n - 1 ) ) ; } int getMax ( int arr [ ] , int n ) { return ( n == 1 ) ? arr [ 0 ] : max ( arr [ 0 ] , getMax ( arr + 1 , n - 1 ) ) ; } int main ( ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ element ▁ of ▁ array : ▁ " << getMin ( arr , n ) << " STRNEWLINE " ; cout << " Maximum ▁ element ▁ of ▁ array : ▁ " << getMax ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMin ( int arr [ ] , int n ) { return * min_element ( arr , arr + n ) ; } int getMax ( int arr [ ] , int n ) { return * max_element ( arr , arr + n ) ; } int main ( ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ element ▁ of ▁ array : ▁ " << getMin ( arr , n ) << " STRNEWLINE " ; cout << " Maximum ▁ element ▁ of ▁ array : ▁ " << getMax ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void closestResult ( int a [ ] , int b [ ] , int n ) { vector < int > vect ( a , a + n ) ; sort ( vect . begin ( ) , vect . end ( ) ) ; vector < int > :: iterator up ; vector < int > c ; for ( int i = 0 ; i < n ; i ++ ) { up = upper_bound ( vect . begin ( ) , vect . end ( ) , b [ i ] ) ; if ( up == vect . end ( ) ) c . push_back ( -1 ) ; else c . push_back ( * up ) ; } cout << " Result ▁ = ▁ " ; for ( auto it = c . begin ( ) ; it != c . end ( ) ; it ++ ) cout << * it << " ▁ " ; } int main ( ) { int a [ ] = { 2 , 5 , 6 , 1 , 8 , 9 } ; int b [ ] = { 2 , 1 , 0 , 5 , 4 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; closestResult ( a , b , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCounts ( int * arr , int n ) { int hash [ n ] = { 0 } ; int i = 0 ; while ( i < n ) { hash [ arr [ i ] - 1 ] ++ ; i ++ ; } printf ( " Below are counts of all elements " for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ - > ▁ % d STRNEWLINE " , i + 1 , hash [ i ] ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 2 , 5 } ; findCounts ( arr , sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; int arr1 [ ] = { 1 } ; findCounts ( arr1 , sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ) ; int arr3 [ ] = { 4 , 4 , 4 , 4 } ; findCounts ( arr3 , sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ) ; int arr2 [ ] = { 1 , 3 , 5 , 7 , 9 , 1 , 3 , 5 , 7 , 9 , 1 } ; findCounts ( arr2 , sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ) ; int arr4 [ ] = { 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 } ; findCounts ( arr4 , sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ) ; int arr5 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 } ; findCounts ( arr5 , sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ) ; int arr6 [ ] = { 11 , 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 } ; findCounts ( arr6 , sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCounts ( int * arr , int n ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] <= 0 ) { i ++ ; continue ; } int elementIndex = arr [ i ] - 1 ; if ( arr [ elementIndex ] > 0 ) { arr [ i ] = arr [ elementIndex ] ; arr [ elementIndex ] = -1 ; } else { arr [ elementIndex ] -- ; arr [ i ] = 0 ; i ++ ; } } printf ( " Below are counts of all elements " for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ - > ▁ % d STRNEWLINE " , i + 1 , abs ( arr [ i ] ) ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 2 , 5 } ; findCounts ( arr , sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; int arr1 [ ] = { 1 } ; findCounts ( arr1 , sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ) ; int arr3 [ ] = { 4 , 4 , 4 , 4 } ; findCounts ( arr3 , sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ) ; int arr2 [ ] = { 1 , 3 , 5 , 7 , 9 , 1 , 3 , 5 , 7 , 9 , 1 } ; findCounts ( arr2 , sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ) ; int arr4 [ ] = { 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 , 3 } ; findCounts ( arr4 , sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ) ; int arr5 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 } ; findCounts ( arr5 , sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ) ; int arr6 [ ] = { 11 , 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 } ; findCounts ( arr6 , sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printfrequency ( int arr [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) arr [ j ] = arr [ j ] - 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % n ] = arr [ arr [ i ] % n ] + n ; for ( int i = 0 ; i < n ; i ++ ) cout << i + 1 << " ▁ - > ▁ " << arr [ i ] / n << endl ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printfrequency ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int deleteElement ( int arr [ ] , int n , int x ) { if ( arr [ n - 1 ] == x ) return ( n - 1 ) ; int prev = arr [ n - 1 ] , i ; for ( i = n - 2 ; i >= 0 && arr [ i ] != x ; i -- ) { int curr = arr [ i ] ; arr [ i ] = prev ; prev = curr ; } if ( i < 0 ) return 0 ; arr [ i ] = prev ; return ( n - 1 ) ; } int main ( ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 6 ; n = deleteElement ( arr , n , x ) ; cout << " Modified ▁ array ▁ is ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; } int main ( ) { int arr [ ] = { 8 , 4 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Inversion ▁ Count ▁ : ▁ " << getInvCount ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxWater ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int left = arr [ i ] ; for ( int j = 0 ; j < i ; j ++ ) left = max ( left , arr [ j ] ) ; int right = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) right = max ( right , arr [ j ] ) ; res = res + ( min ( left , right ) - arr [ i ] ) ; } return res ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxWater ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWater ( int arr [ ] , int n ) { int left [ n ] ; int right [ n ] ; int water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) left [ i ] = max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) right [ i ] = max ( right [ i + 1 ] , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) water += min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ water ▁ that ▁ can ▁ be ▁ accumulated ▁ is ▁ " << findWater ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findWater ( int arr [ ] , int n ) { int result = 0 ; int left_max = 0 , right_max = 0 ; int lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ water ▁ that ▁ can ▁ be ▁ accumulated ▁ is ▁ " << findWater ( arr , n ) ; }
#include <iostream> NEW_LINE using namespace std ; int maxWater ( int arr [ ] , int n ) { int size = n - 1 ; int prev = arr [ 0 ] ; int prev_index = 0 ; int water = 0 ; int temp = 0 ; for ( int i = 1 ; i <= size ; i ++ ) { if ( arr [ i ] >= prev ) { prev = arr [ i ] ; prev_index = i ; temp = 0 ; } else { water += prev - arr [ i ] ; temp += prev - arr [ i ] ; } } if ( prev_index < size ) { water -= temp ; prev = arr [ size ] ; for ( int i = size ; i >= prev_index ; i -- ) { if ( arr [ i ] >= prev ) { prev = arr [ i ] ; } else { water += prev - arr [ i ] ; } } } return water ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxWater ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxWater ( int height [ ] , int n ) { stack < int > st ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ( ! st . empty ( ) ) && ( height [ st . top ( ) ] < height [ i ] ) ) { int pop_height = height [ st . top ( ) ] ; st . pop ( ) ; if ( st . empty ( ) ) break ; int distance = i - st . top ( ) - 1 ; int min_height = min ( height [ st . top ( ) ] , height [ i ] ) - pop_height ; ans += distance * min_height ; } st . push ( i ) ; } return ans ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxWater ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int maxWater ( int arr [ ] , int n ) { int left = 0 ; int right = n - 1 ; int l_max = 0 ; int r_max = 0 ; int result = 0 ; while ( left <= right ) { if ( r_max <= l_max ) { result += max ( 0 , r_max - arr [ right ] ) ; r_max = max ( r_max , arr [ right ] ) ; right -= 1 ; } else { result += max ( 0 , l_max - arr [ left ] ) ; l_max = max ( l_max , arr [ left ] ) ; left += 1 ; } } return result ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxWater ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingK ( int a [ ] , int k , int n ) { int difference = 0 , ans = 0 , count = k ; bool flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { difference = 0 ; if ( ( a [ i ] + 1 ) != a [ i + 1 ] ) { difference += ( a [ i + 1 ] - a [ i ] ) - 1 ; if ( difference >= count ) { ans = a [ i ] + count ; flag = 1 ; break ; } else count -= difference ; } } if ( flag ) return ans ; else return -1 ; } int main ( ) { int a [ ] = { 1 , 5 , 11 , 19 } ; int k = 11 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int missing = missingK ( a , k , n ) ; cout << missing << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; int missingK ( vector < int > & arr , int k ) { int n = arr . size ( ) ; int l = 0 , u = n - 1 , mid ; while ( l <= u ) { mid = ( l + u ) / 2 ; int numbers_less_than_mid = arr [ mid ] - ( mid + 1 ) ; if ( numbers_less_than_mid == k ) { if ( mid > 0 && ( arr [ mid - 1 ] - ( mid ) ) == k ) { u = mid - 1 ; continue ; } return arr [ mid ] - 1 ; } if ( numbers_less_than_mid < k ) { l = mid + 1 ; } else if ( k < numbers_less_than_mid ) { u = mid - 1 ; } } if ( u < 0 ) return k ; int less = arr [ u ] - ( u + 1 ) ; k -= less ; return arr [ u ] + k ; } int main ( ) { vector < int > arr = { 2 , 3 , 4 , 7 , 11 } ; int k = 5 ; cout << " Missing ▁ kth ▁ number ▁ = ▁ " << missingK ( arr , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using std :: cout ; int maximum ( int a , int b ) ; int findMedianSortedArrays ( int * a , int n , int * b , int m ) { int min_index = 0 , max_index = n , i , j ; while ( min_index <= max_index ) { i = ( min_index + max_index ) / 2 ; j = ( ( n + m + 1 ) / 2 ) - i ; if ( i < n && j > 0 && b [ j - 1 ] > a [ i ] ) min_index = i + 1 ; else if ( i > 0 && j < m && b [ j ] < a [ i - 1 ] ) max_index = i - 1 ; else { if ( i == 0 ) return b [ j - 1 ] ; if ( j == 0 ) return a [ i - 1 ] ; else return maximum ( a [ i - 1 ] , b [ j - 1 ] ) ; } } cout << " ERROR ! ! ! ▁ " << " returning STRNEWLINE " ; return 0 ; } int maximum ( int a , int b ) { return a > b ? a : b ; } int main ( ) { int a [ ] = { 900 } ; int b [ ] = { 10 , 13 , 14 } ; int n = sizeof ( a ) / sizeof ( int ) ; int m = sizeof ( b ) / sizeof ( int ) ; if ( n < m ) cout << " The ▁ median ▁ is : ▁ " << findMedianSortedArrays ( a , n , b , m ) ; else cout << " The ▁ median ▁ is : ▁ " << findMedianSortedArrays ( b , m , a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUncommon ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) { cout << arr1 [ i ] << " ▁ " ; i ++ ; k ++ ; } else if ( arr2 [ j ] < arr1 [ i ] ) { cout << arr2 [ j ] << " ▁ " ; k ++ ; j ++ ; } else { i ++ ; j ++ ; } } while ( i < n1 ) { cout << arr1 [ i ] << " ▁ " ; i ++ ; k ++ ; } while ( j < n2 ) { cout << arr2 [ j ] << " ▁ " ; j ++ ; k ++ ; } } int main ( ) { int arr1 [ ] = { 10 , 20 , 30 } ; int arr2 [ ] = { 20 , 25 , 30 , 40 , 50 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printUncommon ( arr1 , arr2 , n1 , n2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int leastFrequent ( int arr [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int min_count = n + 1 , res = -1 ; for ( auto i : hash ) { if ( min_count >= i . second ) { res = i . first ; min_count = i . second ; } } return res ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << leastFrequent ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define M  4 NEW_LINE using namespace std ; int maximumSum ( int a [ ] [ M ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sort ( a [ i ] , a [ i ] + M ) ; int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; int i , j ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } } if ( j == -1 ) return 0 ; } return sum ; } int main ( ) { int arr [ ] [ M ] = { { 1 , 7 , 3 , 4 } , { 4 , 2 , 5 , 1 } , { 9 , 5 , 1 , 8 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define M  4 NEW_LINE using namespace std ; int maximumSum ( int a [ ] [ M ] , int n ) { int prev = * max_element ( & a [ n - 1 ] [ 0 ] , & a [ n - 1 ] [ M - 1 ] + 1 ) ; int sum = prev ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int max_smaller = INT_MIN ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev && a [ i ] [ j ] > max_smaller ) max_smaller = a [ i ] [ j ] ; } if ( max_smaller == INT_MIN ) return 0 ; prev = max_smaller ; sum += max_smaller ; } return sum ; } int main ( ) { int arr [ ] [ M ] = { { 1 , 7 , 3 , 4 } , { 4 , 2 , 5 , 1 } , { 9 , 5 , 1 , 8 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int A [ ] , int n , int k ) { int ans = 0 ; sort ( A , A + n ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; } int main ( ) { int A [ ] = { 3 , 8 , 9 , 12 , 18 , 4 , 24 , 2 , 6 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int k = 3 ; cout << countPairs ( A , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findValue ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == k ) k *= 2 ; } return k ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 10 , 8 , 1 } , k = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findValue ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void dupLastIndex ( int arr [ ] , int n ) { if ( arr == NULL n <= 0 ) return ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { printf ( " Last ▁ index : ▁ % d STRNEWLINE Last ▁ " " duplicate ▁ item : ▁ % d STRNEWLINE " , i , arr [ i ] ) ; return ; } } printf ( " no ▁ duplicate ▁ found " ) ; } int main ( ) { int arr [ ] = { 1 , 5 , 5 , 6 , 6 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( int ) ; dupLastIndex ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSmallest ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] ) break ; if ( j == n ) return a [ i ] ; } return -1 ; } int main ( ) { int a [ ] = { 25 , 20 , 5 , 10 , 100 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << findSmallest ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSmallest ( int a [ ] , int n ) { int smallest = * min_element ( a , a + n ) ; for ( int i = 1 ; i < n ; i ++ ) if ( a [ i ] % smallest ) return -1 ; return smallest ; } int main ( ) { int a [ ] = { 25 , 20 , 5 , 10 , 100 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << findSmallest ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMax ( int arr [ ] , int k , int n ) { vector < int > brr ( arr , arr + n ) ; sort ( brr . begin ( ) , brr . end ( ) , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; ++ i ) if ( binary_search ( brr . begin ( ) , brr . begin ( ) + k , arr [ i ] , greater < int > ( ) ) ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 50 , 8 , 45 , 12 , 25 , 40 , 84 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printMax ( arr , k , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findIndex ( int arr [ ] , int len ) { int maxIndex = 0 ; for ( int i = 0 ; i < len ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( int i = 0 ; i < len ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return -1 ; return maxIndex ; } int main ( ) { int arr [ ] = { 3 , 6 , 1 , 0 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( findIndex ( arr , len ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_consecutive_steps ( int arr [ ] , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = max ( maximum , count ) ; count = 0 ; } } return max ( maximum , count ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find_consecutive_steps ( arr , len ) ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll CalculateMax ( ll arr [ ] , int n ) { sort ( arr , arr + n ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return abs ( max_sum - min_sum ) ; } int main ( ) { ll arr [ ] = { 6 , 7 , 1 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CalculateMax ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll calculate ( ll a [ ] , ll n ) { sort ( a , a + n ) ; vector < ll > s ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push_back ( a [ i ] + a [ j ] ) ; ll mini = * min_element ( s . begin ( ) , s . end ( ) ) ; ll maxi = * max_element ( s . begin ( ) , s . end ( ) ) ; return abs ( maxi - mini ) ; } int main ( ) { ll a [ ] = { 2 , 6 , 4 , 3 } ; int n = sizeof ( a ) / ( sizeof ( a [ 0 ] ) ) ; cout << calculate ( a , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMinDiffPairs ( int arr [ ] , int n ) { if ( n <= 1 ) return ; sort ( arr , arr + n ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) cout << " ( " << arr [ i - 1 ] << " , ▁ " << arr [ i ] << " ) , ▁ " ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 , 4 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMinDiffPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateDiff ( int i , int j , int arr [ ] ) { return abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ; } int maxDistance ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( calculateDiff ( i , j , arr ) > result ) result = calculateDiff ( i , j , arr ) ; } } return result ; } int main ( ) { int arr [ ] = { -70 , -64 , -6 , -56 , 64 , 61 , -57 , 16 , 48 , -98 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxDistance ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int extrema ( int a [ ] , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { count += ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) ; count += ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) ; } return count ; } int main ( ) { int a [ ] = { 1 , 0 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << extrema ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int a [ ] , int n ) { int maxSum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) maxSum = max ( maxSum , a [ i ] + a [ j ] ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; } int main ( ) { int array [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << sum ( array , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int a [ ] , int n ) { int maxVal = a [ 0 ] , maxCount = 1 ; int secondMax = INT_MIN , secondMaxCount ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == maxVal ) maxCount ++ ; else if ( a [ i ] > maxVal ) { secondMax = maxVal ; secondMaxCount = maxCount ; maxVal = a [ i ] ; maxCount = 1 ; } else if ( a [ i ] == secondMax ) { secondMax = a [ i ] ; secondMaxCount ++ ; } else if ( a [ i ] > secondMax ) { secondMax = a [ i ] ; secondMaxCount = 1 ; } } if ( maxCount > 1 ) return maxCount * ( maxCount - 1 ) / 2 ; return secondMaxCount ; } int main ( ) { int array [ ] = { 1 , 1 , 1 , 2 , 2 , 2 , 3 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << sum ( array , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSmall ( int arr [ ] , int asize , int n ) { vector < int > copy_arr ( arr , arr + asize ) ; sort ( copy_arr . begin ( ) , copy_arr . begin ( ) + asize ) ; for ( int i = 0 ; i < asize ; ++ i ) if ( binary_search ( copy_arr . begin ( ) , copy_arr . begin ( ) + n , arr [ i ] ) ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int asize = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 5 ; printSmall ( arr , asize , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printKMissing ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; int count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { cout << curr << " ▁ " ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { cout << curr << " ▁ " ; curr ++ ; count ++ ; } } int main ( ) { int arr [ ] = { 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printKMissing ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nobleInteger ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return -1 ; } int main ( ) { int arr [ ] = { 10 , 3 , 20 , 40 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int res = nobleInteger ( arr , size ) ; if ( res != -1 ) cout << " The ▁ noble ▁ integer ▁ is ▁ " << res ; else cout << " No ▁ Noble ▁ Integer ▁ Found " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nobleInteger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return -1 ; } int main ( ) { int arr [ ] = { 10 , 3 , 20 , 40 , 2 } ; int res = nobleInteger ( arr , 5 ) ; if ( res != -1 ) cout << " The ▁ noble ▁ integer ▁ is ▁ " << res ; else cout << " No ▁ Noble ▁ Integer ▁ Found " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int findMinSum ( long long int a [ ] , long long int b [ ] , int n ) { sort ( a , a + n ) ; sort ( b , b + n ) ; long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ; return sum ; } int main ( ) { long long int a [ ] = { 4 , 1 , 8 , 7 } ; long long int b [ ] = { 2 , 3 , 6 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printf ( " % lld STRNEWLINE " , findMinSum ( a , b , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n ) { int mn = INT_MAX ; int mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { mn = min ( mn , a [ i ] ) ; mx = max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; } int main ( ) { int a [ ] = { 3 , 2 , 1 , 1 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findElement ( int a [ ] , int n , int b ) { sort ( a , a + n ) ; int max = a [ n - 1 ] ; while ( b < max ) { if ( binary_search ( a , a + n , b ) ) b *= 2 ; else return b ; } return b ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int b = 1 ; cout << findElement ( a , n , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define Mod  1000000007 NEW_LINE using namespace std ; long long int findSum ( int arr [ ] , int n ) { long long int sum = 0 ; sort ( arr , arr + n ) ; int i = 0 ; while ( i < n && arr [ i ] < 0 ) { if ( i != n - 1 && arr [ i + 1 ] <= 0 ) { sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod ; i += 2 ; } else break ; } int j = n - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { if ( j != 0 && arr [ j - 1 ] > 0 ) { sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod ; j -= 2 ; } else break ; } if ( j > i ) sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod ; else if ( i == j ) sum = ( sum + arr [ i ] ) % Mod ; return sum ; } int main ( ) { int arr [ ] = { -1 , 9 , 4 , 5 , -4 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSum ( arr , n ) ; return 0 ; }
void insertAfter ( Node * prev_node , int new_data ) { if ( prev_node == NULL ) { cout << " the ▁ given ▁ previous ▁ node ▁ cannot ▁ be ▁ NULL " ; return ; } Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = prev_node -> next ; prev_node -> next = new_node ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_key ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> key = new_key ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } bool search ( struct Node * head , int x ) { if ( head == NULL ) return false ; if ( head -> key == x ) return true ; return search ( head -> next , x ) ; } int main ( ) { struct Node * head = NULL ; int x = 21 ; push ( & head , 10 ) ; push ( & head , 30 ) ; push ( & head , 11 ) ; push ( & head , 21 ) ; push ( & head , 14 ) ; search ( head , 21 ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef uintptr_t ut ; struct Node { int data ; struct Node * next ; } ; void reverse ( struct Node * * head_ref ) { struct Node * prev = NULL ; struct Node * current = * head_ref ; while ( current != NULL ) { current = ( struct Node * ) ( ( ut ) prev ^ ( ut ) current ^ ( ut ) ( current -> next ) ^ ( ut ) ( current -> next = prev ) ^ ( ut ) ( prev = current ) ) ; } * head_ref = prev ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * head ) { struct Node * temp = head ; while ( temp != NULL ) { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 20 ) ; push ( & head , 4 ) ; push ( & head , 15 ) ; push ( & head , 85 ) ; printf ( " Given ▁ linked ▁ list STRNEWLINE " ) ; printList ( head ) ; reverse ( & head ) ; printf ( " Reversed Linked list " printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } cout << endl ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } Node * insertBeg ( Node * head , int val ) { Node * temp = newNode ( val ) ; temp -> next = head ; head = temp ; return head ; } void rearrangeOddEven ( Node * head ) { stack < Node * > odd ; stack < Node * > even ; int i = 1 ; while ( head != nullptr ) { if ( head -> data % 2 != 0 && i % 2 == 0 ) { odd . push ( head ) ; } else if ( head -> data % 2 == 0 && i % 2 != 0 ) { even . push ( head ) ; } head = head -> next ; i ++ ; } while ( ! odd . empty ( ) && ! even . empty ( ) ) { swap ( odd . top ( ) -> data , even . top ( ) -> data ) ; odd . pop ( ) ; even . pop ( ) ; } } int main ( ) { Node * head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 1 ) ; cout << " Linked ▁ List : " << endl ; printList ( head ) ; rearrangeOddEven ( head ) ; cout << " Linked ▁ List ▁ after ▁ " << " Rearranging : " << endl ; printList ( head ) ; return 0 ; }
void deleteAlt ( Node * head ) { if ( head == NULL ) return ; Node * node = head -> next ; if ( node == NULL ) return ; head -> next = node -> next ; free ( node ) ; deleteAlt ( head -> next ) ; }
void AlternatingSplit ( Node * source , Node * * aRef , Node * * bRef ) { Node aDummy ; Node * aTail = & aDummy ; Node bDummy ; Node * bTail = & bDummy ; Node * current = source ; aDummy . next = NULL ; bDummy . next = NULL ; while ( current != NULL ) { MoveNode ( & ( aTail -> next ) , t ) ; aTail = aTail -> next ; if ( current != NULL ) { MoveNode ( & ( bTail -> next ) , t ) ; bTail = bTail -> next ; } } * aRef = aDummy . next ; * bRef = bDummy . next ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool areIdentical ( struct Node * a , struct Node * b ) { while ( a != NULL && b != NULL ) { if ( a -> data != b -> data ) return false ; a = a -> next ; b = b -> next ; } return ( a == NULL && b == NULL ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * a = NULL ; struct Node * b = NULL ; push ( & a , 1 ) ; push ( & a , 2 ) ; push ( & a , 3 ) ; push ( & b , 1 ) ; push ( & b , 2 ) ; push ( & b , 3 ) ; if ( areIdentical ( a , b ) ) cout << " Identical " ; else cout << " Not ▁ identical " ; return 0 ; }
bool areIdentical ( Node * a , Node * b ) { if ( a == NULL && b == NULL ) return true ; if ( a != NULL && b != NULL ) return ( a -> data == b -> data ) && areIdentical ( a -> next , b -> next ) ; return false ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; void sortList ( Node * head ) { int count [ 3 ] = { 0 , 0 , 0 } ; Node * ptr = head ; while ( ptr != NULL ) { count [ ptr -> data ] += 1 ; ptr = ptr -> next ; } int i = 0 ; ptr = head ; while ( ptr != NULL ) { if ( count [ i ] == 0 ) ++ i ; else { ptr -> data = i ; -- count [ i ] ; ptr = ptr -> next ; } } } void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } cout << endl ; } int main ( void ) { Node * head = NULL ; push ( & head , 0 ) ; push ( & head , 1 ) ; push ( & head , 0 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; cout << " Linked ▁ List ▁ Before ▁ Sorting STRNEWLINE " ; printList ( head ) ; sortList ( head ) ; cout << " Linked ▁ List ▁ After ▁ Sorting STRNEWLINE " ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * next ; } ; typedef struct node Node ; void rearrange ( Node * head ) { if ( head == NULL ) return ; Node * prev = head , * curr = head -> next ; while ( curr ) { if ( prev -> data > curr -> data ) swap ( prev -> data , curr -> data ) ; if ( curr -> next && curr -> next -> data > curr -> data ) swap ( curr -> next -> data , curr -> data ) ; prev = curr -> next ; if ( ! curr -> next ) break ; curr = curr -> next -> next ; } } void push ( Node * * head , int k ) { Node * tem = ( Node * ) malloc ( sizeof ( Node ) ) ; tem -> data = k ; tem -> next = * head ; * head = tem ; } void display ( Node * head ) { Node * curr = head ; while ( curr != NULL ) { printf ( " % d ▁ " , curr -> data ) ; curr = curr -> next ; } } int main ( ) { Node * head = NULL ; push ( & head , 7 ) ; push ( & head , 3 ) ; push ( & head , 8 ) ; push ( & head , 6 ) ; push ( & head , 9 ) ; rearrange ( head ) ; display ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } Node * rearrangeEvenOdd ( Node * head ) { if ( head == NULL ) return NULL ; Node * odd = head ; Node * even = head -> next ; Node * evenFirst = even ; while ( 1 ) { if ( ! odd || ! even || ! ( even -> next ) ) { odd -> next = evenFirst ; break ; } odd -> next = even -> next ; odd = even -> next ; if ( odd -> next == NULL ) { even -> next = NULL ; odd -> next = evenFirst ; break ; } even -> next = odd -> next ; even = odd -> next ; } return head ; } void printlist ( Node * node ) { while ( node != NULL ) { cout << node -> data << " - > " ; node = node -> next ; } cout << " NULL " << endl ; } int main ( void ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; cout << " Given ▁ Linked ▁ List STRNEWLINE " ; printlist ( head ) ; head = rearrangeEvenOdd ( head ) ; cout << " Modified ▁ Linked ▁ List STRNEWLINE " ; printlist ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int data ; Node * next ; } ; Node * newNode ( int data ) { Node * new_node = new Node ; new_node -> data = data ; new_node -> next = NULL ; return new_node ; } int addWithCarry ( Node * head ) { if ( head == NULL ) return 1 ; int res = head -> data + addWithCarry ( head -> next ) ; head -> data = ( res ) % 10 ; return ( res ) / 10 ; } Node * addOne ( Node * head ) { int carry = addWithCarry ( head ) ; if ( carry ) { Node * newNode = new Node ; newNode -> data = carry ; newNode -> next = head ; return newNode ; } return head ; } void printList ( Node * node ) { while ( node != NULL ) { printf ( " % d " , node -> data ) ; node = node -> next ; } printf ( " STRNEWLINE " ) ; } int main ( void ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 9 ) ; head -> next -> next = newNode ( 9 ) ; head -> next -> next -> next = newNode ( 9 ) ; printf ( " List ▁ is ▁ " ) ; printList ( head ) ; head = addOne ( head ) ; printf ( " Resultant list is " printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next , * arbit ; } ; Node * reverse ( Node * head ) { Node * prev = NULL , * current = head , * next ; while ( current != NULL ) { next = current -> next ; current -> next = prev ; prev = current ; current = next ; } return prev ; } Node * populateArbit ( Node * head ) { head = reverse ( head ) ; Node * max = head ; Node * temp = head -> next ; while ( temp != NULL ) { temp -> arbit = max ; if ( max -> data < temp -> data ) max = temp ; temp = temp -> next ; } return reverse ( head ) ; } void printNextArbitPointers ( Node * node ) { printf ( " Node TABSYMBOL Next ▁ Pointer TABSYMBOL Arbit ▁ Pointer STRNEWLINE " ) ; while ( node != NULL ) { cout << node -> data << " TABSYMBOL TABSYMBOL " ; if ( node -> next ) cout << node -> next -> data << " TABSYMBOL TABSYMBOL " ; else cout << " NULL " << " TABSYMBOL TABSYMBOL " ; if ( node -> arbit ) cout << node -> arbit -> data ; else cout << " NULL " ; cout << endl ; node = node -> next ; } } Node * newNode ( int data ) { Node * new_node = new Node ; new_node -> data = data ; new_node -> next = NULL ; return new_node ; } int main ( ) { Node * head = newNode ( 5 ) ; head -> next = newNode ( 10 ) ; head -> next -> next = newNode ( 2 ) ; head -> next -> next -> next = newNode ( 3 ) ; head = populateArbit ( head ) ; printf ( " Resultant ▁ Linked ▁ List ▁ is : ▁ STRNEWLINE " ) ; printNextArbitPointers ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next , * arbit ; } ; void populateArbit ( Node * head ) { static Node * maxNode ; if ( head == NULL ) return ; if ( head -> next == NULL ) { maxNode = head ; return ; } populateArbit ( head -> next ) ; head -> arbit = maxNode ; if ( head -> data > maxNode -> data ) maxNode = head ; return ; } void printNextArbitPointers ( Node * node ) { printf ( " Node TABSYMBOL Next ▁ Pointer TABSYMBOL Arbit ▁ Pointer STRNEWLINE " ) ; while ( node != NULL ) { cout << node -> data << " TABSYMBOL TABSYMBOL " ; if ( node -> next ) cout << node -> next -> data << " TABSYMBOL TABSYMBOL " ; else cout << " NULL " << " TABSYMBOL TABSYMBOL " ; if ( node -> arbit ) cout << node -> arbit -> data ; else cout << " NULL " ; cout << endl ; node = node -> next ; } } Node * newNode ( int data ) { Node * new_node = new Node ; new_node -> data = data ; new_node -> next = NULL ; return new_node ; } int main ( ) { Node * head = newNode ( 5 ) ; head -> next = newNode ( 10 ) ; head -> next -> next = newNode ( 2 ) ; head -> next -> next -> next = newNode ( 3 ) ; populateArbit ( head ) ; printf ( " Resultant ▁ Linked ▁ List ▁ is : ▁ STRNEWLINE " ) ; printNextArbitPointers ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { string data ; Node * next ; } ; bool isPalindromeUtil ( string str ) { int length = str . length ( ) ; for ( int i = 0 ; i < length / 2 ; i ++ ) if ( str [ i ] != str [ length - i - 1 ] ) return false ; return true ; } bool isPalindrome ( Node * node ) { string str = " " ; while ( node != NULL ) { str . append ( node -> data ) ; node = node -> next ; } return isPalindromeUtil ( str ) ; } void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ - > ▁ " ; node = node -> next ; } printf ( " NULL STRNEWLINE " ) ; } Node * newNode ( const char * str ) { Node * new_node = new Node ; new_node -> data = str ; new_node -> next = NULL ; return new_node ; } int main ( ) { Node * head = newNode ( " a " ) ; head -> next = newNode ( " bc " ) ; head -> next -> next = newNode ( " d " ) ; head -> next -> next -> next = newNode ( " dcb " ) ; head -> next -> next -> next -> next = newNode ( " a " ) ; isPalindrome ( head ) ? printf ( " true STRNEWLINE " ) : printf ( " false STRNEWLINE " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void deleteLast ( struct Node * head , int x ) { struct Node * temp = head , * ptr = NULL ; while ( temp ) { if ( temp -> data == x ) ptr = temp ; temp = temp -> next ; } if ( ptr != NULL && ptr -> next == NULL ) { temp = head ; while ( temp -> next != ptr ) temp = temp -> next ; temp -> next = NULL ; } if ( ptr != NULL && ptr -> next != NULL ) { ptr -> data = ptr -> next -> data ; temp = ptr -> next ; ptr -> next = ptr -> next -> next ; free ( temp ) ; } } struct Node * newNode ( int x ) { Node * node = new Node ; node -> data = x ; node -> next = NULL ; return node ; } void display ( struct Node * head ) { struct Node * temp = head ; if ( head == NULL ) { cout << " NULL STRNEWLINE " ; return ; } while ( temp != NULL ) { cout << " ▁ - - > ▁ " << temp -> data ; temp = temp -> next ; } cout << " NULL STRNEWLINE " ; } int main ( ) { struct Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; head -> next -> next -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next -> next -> next = newNode ( 4 ) ; cout << " Created ▁ Linked ▁ list : ▁ " ; display ( head ) ; deleteLast ( head , 4 ) ; cout << " List ▁ after ▁ deletion ▁ of ▁ 4 : ▁ " ; display ( head ) ; return 0 ; }
Node * flattenList2 ( Node * head ) { Node * headcop = head ; stack < Node * > save ; save . push ( head ) ; Node * prev = NULL ; while ( ! save . empty ( ) ) { Node * temp = save . top ( ) ; save . pop ( ) ; if ( temp -> next ) save . push ( temp -> next ) ; if ( temp -> down ) save . push ( temp -> down ) ; if ( prev != NULL ) prev -> next = temp ; prev = temp ; } return headcop ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> next = NULL ; return temp ; } int getLength ( Node * Node ) { int size = 0 ; while ( Node != NULL ) { Node = Node -> next ; size ++ ; } return size ; } Node * paddZeros ( Node * sNode , int diff ) { if ( sNode == NULL ) return NULL ; Node * zHead = newNode ( 0 ) ; diff -- ; Node * temp = zHead ; while ( diff -- ) { temp -> next = newNode ( 0 ) ; temp = temp -> next ; } temp -> next = sNode ; return zHead ; } Node * subtractLinkedListHelper ( Node * l1 , Node * l2 , bool & borrow ) { if ( l1 == NULL && l2 == NULL && borrow == 0 ) return NULL ; Node * previous = subtractLinkedListHelper ( l1 ? l1 -> next : NULL , l2 ? l2 -> next : NULL , borrow ) ; int d1 = l1 -> data ; int d2 = l2 -> data ; int sub = 0 ; if ( borrow ) { d1 -- ; borrow = false ; } if ( d1 < d2 ) { borrow = true ; d1 = d1 + 10 ; } sub = d1 - d2 ; Node * current = newNode ( sub ) ; current -> next = previous ; return current ; } Node * subtractLinkedList ( Node * l1 , Node * l2 ) { if ( l1 == NULL && l2 == NULL ) return NULL ; int len1 = getLength ( l1 ) ; int len2 = getLength ( l2 ) ; Node * lNode = NULL , * sNode = NULL ; Node * temp1 = l1 ; Node * temp2 = l2 ; if ( len1 != len2 ) { lNode = len1 > len2 ? l1 : l2 ; sNode = len1 > len2 ? l2 : l1 ; sNode = paddZeros ( sNode , abs ( len1 - len2 ) ) ; } else { while ( l1 && l2 ) { if ( l1 -> data != l2 -> data ) { lNode = l1 -> data > l2 -> data ? temp1 : temp2 ; sNode = l1 -> data > l2 -> data ? temp2 : temp1 ; break ; } l1 = l1 -> next ; l2 = l2 -> next ; } } bool borrow = false ; return subtractLinkedListHelper ( lNode , sNode , borrow ) ; } void printList ( struct Node * Node ) { while ( Node != NULL ) { printf ( " % d ▁ " , Node -> data ) ; Node = Node -> next ; } printf ( " STRNEWLINE " ) ; } int main ( ) { Node * head1 = newNode ( 1 ) ; head1 -> next = newNode ( 0 ) ; head1 -> next -> next = newNode ( 0 ) ; Node * head2 = newNode ( 1 ) ; Node * result = subtractLinkedList ( head1 , head2 ) ; printList ( result ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; Node * newNode ( int data ) { struct Node * new_node = new Node ; new_node -> data = data ; new_node -> next = NULL ; return new_node ; } struct Node * partition ( struct Node * head , int x ) { struct Node * smallerHead = NULL , * smallerLast = NULL ; struct Node * greaterLast = NULL , * greaterHead = NULL ; struct Node * equalHead = NULL , * equalLast = NULL ; while ( head != NULL ) { if ( head -> data == x ) { if ( equalHead == NULL ) equalHead = equalLast = head ; else { equalLast -> next = head ; equalLast = equalLast -> next ; } } else if ( head -> data < x ) { if ( smallerHead == NULL ) smallerLast = smallerHead = head ; else { smallerLast -> next = head ; smallerLast = head ; } } else { if ( greaterHead == NULL ) greaterLast = greaterHead = head ; else { greaterLast -> next = head ; greaterLast = head ; } } head = head -> next ; } if ( greaterLast != NULL ) greaterLast -> next = NULL ; if ( smallerHead == NULL ) { if ( equalHead == NULL ) return greaterHead ; equalLast -> next = greaterHead ; return equalHead ; } if ( equalHead == NULL ) { smallerLast -> next = greaterHead ; return smallerHead ; } smallerLast -> next = equalHead ; equalLast -> next = greaterHead ; return smallerHead ; } void printList ( struct Node * head ) { struct Node * temp = head ; while ( temp != NULL ) { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } } int main ( ) { struct Node * head = newNode ( 10 ) ; head -> next = newNode ( 4 ) ; head -> next -> next = newNode ( 5 ) ; head -> next -> next -> next = newNode ( 30 ) ; head -> next -> next -> next -> next = newNode ( 2 ) ; head -> next -> next -> next -> next -> next = newNode ( 50 ) ; int x = 3 ; head = partition ( head , x ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; Node * getLoopstart ( Node * loop_node , Node * head ) { Node * ptr1 = loop_node ; Node * ptr2 = loop_node ; unsigned int k = 1 , i ; while ( ptr1 -> next != ptr2 ) { ptr1 = ptr1 -> next ; k ++ ; } ptr1 = head ; ptr2 = head ; for ( i = 0 ; i < k ; i ++ ) ptr2 = ptr2 -> next ; while ( ptr2 != ptr1 ) { ptr1 = ptr1 -> next ; ptr2 = ptr2 -> next ; } return ptr1 ; } Node * detectAndgetLoopstarting ( Node * head ) { Node * slow_p = head , * fast_p = head , * loop_start ; while ( slow_p && fast_p && fast_p -> next ) { slow_p = slow_p -> next ; fast_p = fast_p -> next -> next ; if ( slow_p == fast_p ) { loop_start = getLoopstart ( slow_p , head ) ; break ; } } return loop_start ; } bool isPalindromeUtil ( Node * head , Node * loop_start ) { Node * ptr = head ; stack < int > s ; int count = 0 ; while ( ptr != loop_start count != 1 ) { s . push ( ptr -> data ) ; if ( ptr == loop_start ) count = 1 ; ptr = ptr -> next ; } ptr = head ; count = 0 ; while ( ptr != loop_start count != 1 ) { if ( ptr -> data == s . top ( ) ) s . pop ( ) ; else return false ; if ( ptr == loop_start ) count = 1 ; ptr = ptr -> next ; } return true ; } bool isPalindrome ( Node * head ) { Node * loop_start = detectAndgetLoopstarting ( head ) ; return isPalindromeUtil ( head , loop_start ) ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } int main ( ) { Node * head = newNode ( 50 ) ; head -> next = newNode ( 20 ) ; head -> next -> next = newNode ( 15 ) ; head -> next -> next -> next = newNode ( 20 ) ; head -> next -> next -> next -> next = newNode ( 50 ) ; head -> next -> next -> next -> next -> next = head -> next -> next ; isPalindrome ( head ) ? cout << " Palindrome " : cout << " Not Palindrome " return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; struct Node * newNode ( int x ) { Node * temp = new Node ; temp -> data = x ; temp -> next = NULL ; } void printList ( Node * head ) { struct Node * temp = head ; while ( temp != NULL ) { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } printf ( " STRNEWLINE " ) ; } void moveToEnd ( Node * head , int key ) { struct Node * pKey = head ; struct Node * pCrawl = head ; while ( pCrawl != NULL ) { if ( pCrawl != pKey && pCrawl -> data != key ) { pKey -> data = pCrawl -> data ; pCrawl -> data = key ; pKey = pKey -> next ; } if ( pKey -> data != key ) pKey = pKey -> next ; pCrawl = pCrawl -> next ; } } int main ( ) { Node * head = newNode ( 10 ) ; head -> next = newNode ( 20 ) ; head -> next -> next = newNode ( 10 ) ; head -> next -> next -> next = newNode ( 30 ) ; head -> next -> next -> next -> next = newNode ( 40 ) ; head -> next -> next -> next -> next -> next = newNode ( 10 ) ; head -> next -> next -> next -> next -> next -> next = newNode ( 60 ) ; printf ( " Before ▁ moveToEnd ( ) , ▁ the ▁ Linked ▁ list ▁ is STRNEWLINE " ) ; printList ( head ) ; int key = 10 ; moveToEnd ( head , key ) ; printf ( " After moveToEnd ( ) , the Linked list is " printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; int LinkedListLength ( Node * head ) { while ( head && head -> next ) { head = head -> next -> next ; } if ( ! head ) return 0 ; return 1 ; } void push ( Node * * head , int info ) { Node * node = new Node ( ) ; node -> data = info ; node -> next = ( * head ) ; ( * head ) = node ; } int main ( void ) { Node * head = NULL ; push ( & head , 4 ) ; push ( & head , 5 ) ; push ( & head , 7 ) ; push ( & head , 2 ) ; push ( & head , 9 ) ; push ( & head , 6 ) ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 0 ) ; push ( & head , 5 ) ; push ( & head , 5 ) ; int check = LinkedListLength ( head ) ; if ( check == 0 ) { cout << " Even STRNEWLINE " ; } else { cout << " Odd STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int sumOfLastN_NodesUtil ( struct Node * head , int n ) { if ( n <= 0 ) return 0 ; int sum = 0 , len = 0 ; struct Node * temp = head ; while ( temp != NULL ) { len ++ ; temp = temp -> next ; } int c = len - n ; temp = head ; while ( temp != NULL && c -- ) temp = temp -> next ; while ( temp != NULL ) { sum += temp -> data ; temp = temp -> next ; } return sum ; } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 6 ) ; push ( & head , 10 ) ; int n = 2 ; cout << " Sum ▁ of ▁ last ▁ " << n << " ▁ nodes ▁ = ▁ " << sumOfLastN_NodesUtil ( head , n ) ; return 0 ; }
Node * SortedMerge ( Node * a , Node * b ) { Node * result = NULL ; Node * * lastPtrRef = & result ; while ( 1 ) { if ( a == NULL ) { * lastPtrRef = b ; break ; } else if ( b == NULL ) { * lastPtrRef = a ; break ; } if ( a -> data <= b -> data ) { MoveNode ( lastPtrRef , & a ) ; } else { MoveNode ( lastPtrRef , & b ) ; } lastPtrRef = & ( ( * lastPtrRef ) -> next ) ; } return ( result ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; void printList ( Node * node ) { while ( node != NULL ) { printf ( " % d ▁ " , node -> data ) ; node = node -> next ; } } Node * mergeKLists ( Node * arr [ ] , int last ) { for ( int i = 1 ; i <= last ; i ++ ) { while ( true ) { Node * head_0 = arr [ 0 ] , * head_i = arr [ i ] ; if ( head_i == NULL ) break ; if ( head_0 -> data >= head_i -> data ) { arr [ i ] = head_i -> next ; head_i -> next = head_0 ; arr [ 0 ] = head_i ; } else while ( head_0 -> next != NULL ) { if ( head_0 -> next -> data >= head_i -> data ) { arr [ i ] = head_i -> next ; head_i -> next = head_0 -> next ; head_0 -> next = head_i ; break ; } head_0 = head_0 -> next ; if ( head_0 -> next == NULL ) { arr [ i ] = head_i -> next ; head_i -> next = NULL ; head_0 -> next = head_i ; head_0 -> next -> next = NULL ; break ; } } } } return arr [ 0 ] ; } Node * newNode ( int data ) { struct Node * temp = new Node ; temp -> data = data ; temp -> next = NULL ; return temp ; } int main ( ) { int k = 3 ; int n = 4 ; Node * arr [ k ] ; arr [ 0 ] = newNode ( 1 ) ; arr [ 0 ] -> next = newNode ( 3 ) ; arr [ 0 ] -> next -> next = newNode ( 5 ) ; arr [ 0 ] -> next -> next -> next = newNode ( 7 ) ; arr [ 1 ] = newNode ( 2 ) ; arr [ 1 ] -> next = newNode ( 4 ) ; arr [ 1 ] -> next -> next = newNode ( 6 ) ; arr [ 1 ] -> next -> next -> next = newNode ( 8 ) ; arr [ 2 ] = newNode ( 0 ) ; arr [ 2 ] -> next = newNode ( 9 ) ; arr [ 2 ] -> next -> next = newNode ( 10 ) ; arr [ 2 ] -> next -> next -> next = newNode ( 11 ) ; Node * head = mergeKLists ( arr , k - 1 ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; Node * newNode ( int key ) { struct Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } void printList ( Node * node ) { while ( node != NULL ) { printf ( " % d ▁ " , node -> data ) ; node = node -> next ; } } Node * merge ( Node * h1 , Node * h2 ) { if ( ! h1 ) return h2 ; if ( ! h2 ) return h1 ; if ( h1 -> data < h2 -> data ) { h1 -> next = merge ( h1 -> next , h2 ) ; return h1 ; } else { h2 -> next = merge ( h1 , h2 -> next ) ; return h2 ; } } int main ( ) { Node * head1 = newNode ( 1 ) ; head1 -> next = newNode ( 3 ) ; head1 -> next -> next = newNode ( 5 ) ; Node * head2 = newNode ( 0 ) ; head2 -> next = newNode ( 2 ) ; head2 -> next -> next = newNode ( 4 ) ; Node * mergedhead = merge ( head1 , head2 ) ; printList ( mergedhead ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; struct Node * newNode ( int key ) { struct Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } void printList ( struct Node * node ) { while ( node != NULL ) { printf ( " % d ▁ " , node -> data ) ; node = node -> next ; } } struct Node * mergeUtil ( struct Node * h1 , struct Node * h2 ) { if ( ! h1 -> next ) { h1 -> next = h2 ; return h1 ; } struct Node * curr1 = h1 , * next1 = h1 -> next ; struct Node * curr2 = h2 , * next2 = h2 -> next ; while ( next1 && curr2 ) { if ( ( curr2 -> data ) >= ( curr1 -> data ) && ( curr2 -> data ) <= ( next1 -> data ) ) { next2 = curr2 -> next ; curr1 -> next = curr2 ; curr2 -> next = next1 ; curr1 = curr2 ; curr2 = next2 ; } else { if ( next1 -> next ) { next1 = next1 -> next ; curr1 = curr1 -> next ; } else { next1 -> next = curr2 ; return h1 ; } } } return h1 ; } struct Node * merge ( struct Node * h1 , struct Node * h2 ) { if ( ! h1 ) return h2 ; if ( ! h2 ) return h1 ; if ( h1 -> data < h2 -> data ) return mergeUtil ( h1 , h2 ) ; else return mergeUtil ( h2 , h1 ) ; } int main ( ) { struct Node * head1 = newNode ( 1 ) ; head1 -> next = newNode ( 3 ) ; head1 -> next -> next = newNode ( 5 ) ; struct Node * head2 = newNode ( 0 ) ; head2 -> next = newNode ( 2 ) ; head2 -> next -> next = newNode ( 4 ) ; struct Node * mergedhead = merge ( head1 , head2 ) ; printList ( mergedhead ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> next = NULL ; return newNode ; } void insertAtMid ( Node * * head_ref , int x ) { if ( * head_ref == NULL ) * head_ref = getNode ( x ) ; else { Node * newNode = getNode ( x ) ; Node * ptr = * head_ref ; int len = 0 ; while ( ptr != NULL ) { len ++ ; ptr = ptr -> next ; } int count = ( ( len % 2 ) == 0 ) ? ( len / 2 ) : ( len + 1 ) / 2 ; ptr = * head_ref ; while ( count -- > 1 ) ptr = ptr -> next ; newNode -> next = ptr -> next ; ptr -> next = newNode ; } } void display ( Node * head ) { while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } } int main ( ) { Node * head = NULL ; head = getNode ( 1 ) ; head -> next = getNode ( 2 ) ; head -> next -> next = getNode ( 4 ) ; head -> next -> next -> next = getNode ( 5 ) ; cout << " Linked ▁ list ▁ before ▁ insertion : ▁ " ; display ( head ) ; int x = 3 ; insertAtMid ( & head , x ) ; cout << " Linked list after insertion : " display ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> next = NULL ; return newNode ; } void insertAtMid ( Node * * head_ref , int x ) { if ( * head_ref == NULL ) * head_ref = getNode ( x ) ; else { Node * newNode = getNode ( x ) ; Node * slow = * head_ref ; Node * fast = ( * head_ref ) -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } newNode -> next = slow -> next ; slow -> next = newNode ; } } void display ( Node * head ) { while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } } int main ( ) { Node * head = NULL ; head = getNode ( 1 ) ; head -> next = getNode ( 2 ) ; head -> next -> next = getNode ( 4 ) ; head -> next -> next -> next = getNode ( 5 ) ; cout << " Linked ▁ list ▁ before ▁ insertion : ▁ " ; display ( head ) ; int x = 3 ; insertAtMid ( & head , x ) ; cout << " Linked list after insertion : " display ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> next = NULL ; return newNode ; } void insertAfterNthNode ( Node * head , int n , int x ) { if ( head == NULL ) return ; Node * newNode = getNode ( x ) ; Node * ptr = head ; int len = 0 , i ; while ( ptr != NULL ) { len ++ ; ptr = ptr -> next ; } ptr = head ; for ( i = 1 ; i <= ( len - n ) ; i ++ ) ptr = ptr -> next ; newNode -> next = ptr -> next ; ptr -> next = newNode ; } void printList ( Node * head ) { while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } } int main ( ) { Node * head = getNode ( 1 ) ; head -> next = getNode ( 3 ) ; head -> next -> next = getNode ( 4 ) ; head -> next -> next -> next = getNode ( 5 ) ; int n = 4 , x = 2 ; cout << " Original ▁ Linked ▁ List : ▁ " ; printList ( head ) ; insertAfterNthNode ( head , n , x ) ; cout << " Linked List After Insertion : " printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; newNode -> next = NULL ; return newNode ; } void insertAfterNthNode ( Node * head , int n , int x ) { if ( head == NULL ) return ; Node * newNode = getNode ( x ) ; Node * slow_ptr = head ; Node * fast_ptr = head ; for ( int i = 1 ; i <= n - 1 ; i ++ ) fast_ptr = fast_ptr -> next ; while ( fast_ptr -> next != NULL ) { slow_ptr = slow_ptr -> next ; fast_ptr = fast_ptr -> next ; } newNode -> next = slow_ptr -> next ; slow_ptr -> next = newNode ; } void printList ( Node * head ) { while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } } int main ( ) { Node * head = getNode ( 1 ) ; head -> next = getNode ( 3 ) ; head -> next -> next = getNode ( 4 ) ; head -> next -> next -> next = getNode ( 5 ) ; int n = 4 , x = 2 ; cout << " Original ▁ Linked ▁ List : ▁ " ; printList ( head ) ; insertAfterNthNode ( head , n , x ) ; cout << " Linked List After Insertion : " printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; void setMiddleHead ( Node * * head ) { if ( * head == NULL ) return ; Node * one_node = ( * head ) ; Node * two_node = ( * head ) ; Node * prev = NULL ; while ( two_node != NULL && two_node -> next != NULL ) { prev = one_node ; two_node = two_node -> next -> next ; one_node = one_node -> next ; } prev -> next = prev -> next -> next ; one_node -> next = ( * head ) ; ( * head ) = one_node ; } void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( Node * ptr ) { while ( ptr != NULL ) { cout << ptr -> data << " ▁ " ; ptr = ptr -> next ; } cout << endl ; } int main ( ) { Node * head = NULL ; int i ; for ( i = 5 ; i > 0 ; i -- ) push ( & head , i ) ; cout << " ▁ list ▁ before : ▁ " ; printList ( head ) ; setMiddleHead ( & head ) ; cout << " ▁ list ▁ After : ▁ " ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * prev , * next ; } ; Node * newNode ( int val ) { Node * temp = new Node ; temp -> data = val ; temp -> prev = temp -> next = nullptr ; return temp ; } void printList ( Node * head ) { while ( head -> next != nullptr ) { cout << head -> data << " ▁ < - - > ▁ " ; head = head -> next ; } cout << head -> data << endl ; } void insert ( Node * * head , int val ) { Node * temp = newNode ( val ) ; temp -> next = * head ; ( * head ) -> prev = temp ; ( * head ) = temp ; } void reverseList ( Node * * head ) { Node * left = * head , * right = * head ; while ( right -> next != nullptr ) right = right -> next ; while ( left != right && left -> prev != right ) { swap ( left -> data , right -> data ) ; left = left -> next ; right = right -> prev ; } } int main ( ) { Node * head = newNode ( 5 ) ; insert ( & head , 4 ) ; insert ( & head , 3 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; printList ( head ) ; cout << " List ▁ After ▁ Reversing " << endl ; reverseList ( & head ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * prev , * next ; } ; struct Node * getNode ( int data ) { struct Node * newNode = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; newNode -> data = data ; newNode -> prev = newNode -> next = NULL ; return newNode ; } void sortedInsert ( struct Node * * head_ref , struct Node * newNode ) { struct Node * current ; if ( * head_ref == NULL ) * head_ref = newNode ; else if ( ( * head_ref ) -> data >= newNode -> data ) { newNode -> next = * head_ref ; newNode -> next -> prev = newNode ; * head_ref = newNode ; } else { current = * head_ref ; while ( current -> next != NULL && current -> next -> data < newNode -> data ) current = current -> next ; newNode -> next = current -> next ; if ( current -> next != NULL ) newNode -> next -> prev = newNode ; current -> next = newNode ; newNode -> prev = current ; } } void insertionSort ( struct Node * * head_ref ) { struct Node * sorted = NULL ; struct Node * current = * head_ref ; while ( current != NULL ) { struct Node * next = current -> next ; current -> prev = current -> next = NULL ; sortedInsert ( & sorted , current ) ; current = next ; } * head_ref = sorted ; } void printList ( struct Node * head ) { while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; new_node -> prev = NULL ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * head = NULL ; push ( & head , 9 ) ; push ( & head , 3 ) ; push ( & head , 5 ) ; push ( & head , 10 ) ; push ( & head , 12 ) ; push ( & head , 8 ) ; cout << " Doubly ▁ Linked ▁ List ▁ Before ▁ Sortingn " ; printList ( head ) ; insertionSort ( & head ) ; cout << " nDoubly ▁ Linked ▁ List ▁ After ▁ Sortingn " ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; void printLevels ( Node * root , int low , int high ) { queue < Node * > Q ; Node * marker = new Node ; int level = 1 ; Q . push ( root ) ; Q . push ( marker ) ; while ( Q . empty ( ) == false ) { Node * n = Q . front ( ) ; Q . pop ( ) ; if ( n == marker ) { cout << endl ; level ++ ; if ( Q . empty ( ) == true level > high ) break ; Q . push ( marker ) ; continue ; } if ( level >= low ) cout << n -> key << " ▁ " ; if ( n -> left != NULL ) Q . push ( n -> left ) ; if ( n -> right != NULL ) Q . push ( n -> right ) ; } } Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } int main ( ) { struct Node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 22 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; cout << " Level ▁ Order ▁ traversal ▁ between ▁ given ▁ two ▁ levels ▁ is " ; printLevels ( root , 2 , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : int data ; node * left ; node * right ; node ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; void printKDistant ( node * root , int k ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { cout << root -> data << " ▁ " ; return ; } printKDistant ( root -> left , k - 1 ) ; printKDistant ( root -> right , k - 1 ) ; } int main ( ) { node * root = new node ( 1 ) ; root -> left = new node ( 2 ) ; root -> right = new node ( 3 ) ; root -> left -> left = new node ( 4 ) ; root -> left -> right = new node ( 5 ) ; root -> right -> left = new node ( 8 ) ; printKDistant ( root , 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) { Node * newnode = new Node ( ) ; newnode -> data = data ; newnode -> left = newnode -> right = NULL ; } bool printKDistant ( Node * root , int klevel ) { queue < Node * > q ; int level = 1 ; bool flag = false ; q . push ( root ) ; q . push ( NULL ) ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; if ( level == klevel && temp != NULL ) { flag = true ; cout << temp -> data << " ▁ " ; } q . pop ( ) ; if ( temp == NULL ) { if ( q . front ( ) ) q . push ( NULL ) ; level += 1 ; if ( level > klevel ) break ; } else { if ( temp -> left ) q . push ( temp -> left ) ; if ( temp -> right ) q . push ( temp -> right ) ; } } cout << endl ; return flag ; } int main ( ) { Node * root = newNode ( 20 ) ; root -> left = newNode ( 10 ) ; root -> right = newNode ( 30 ) ; root -> left -> left = newNode ( 5 ) ; root -> left -> right = newNode ( 15 ) ; root -> left -> right -> left = newNode ( 12 ) ; root -> right -> left = newNode ( 25 ) ; root -> right -> right = newNode ( 40 ) ; cout << " data ▁ at ▁ level ▁ 1 ▁ : ▁ " ; int ret = printKDistant ( root , 1 ) ; if ( ret == false ) cout << " Number ▁ exceeds ▁ total ▁ number ▁ of ▁ levels STRNEWLINE " ; cout << " data ▁ at ▁ level ▁ 2 ▁ : ▁ " ; ret = printKDistant ( root , 2 ) ; if ( ret == false ) cout << " Number ▁ exceeds ▁ total ▁ number ▁ of ▁ levels STRNEWLINE " ; cout << " data ▁ at ▁ level ▁ 3 ▁ : ▁ " ; ret = printKDistant ( root , 3 ) ; if ( ret == false ) cout << " Number ▁ exceeds ▁ total ▁ number ▁ of ▁ levels STRNEWLINE " ; cout << " data ▁ at ▁ level ▁ 6 ▁ : ▁ " ; ret = printKDistant ( root , 6 ) ; if ( ret == false ) cout << " Number ▁ exceeds ▁ total ▁ number ▁ of ▁ levels STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { struct node * left , * right ; int key ; } ; node * newNode ( int key ) { node * temp = new node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } void printSingles ( struct node * root ) { if ( root == NULL ) return ; if ( root -> left != NULL && root -> right != NULL ) { printSingles ( root -> left ) ; printSingles ( root -> right ) ; } else if ( root -> right != NULL ) { cout << root -> right -> key << " ▁ " ; printSingles ( root -> right ) ; } else if ( root -> left != NULL ) { cout << root -> left -> key << " ▁ " ; printSingles ( root -> left ) ; } } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> right = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> left -> left = newNode ( 6 ) ; printSingles ( root ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX_HEIGHT  10000 NEW_LINE struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int key ) { Node * node = new Node ; node -> key = key ; node -> left = node -> right = NULL ; return ( node ) ; } void kDistantFromLeafUtil ( Node * node , int path [ ] , bool visited [ ] , int pathLen , int k ) { if ( node == NULL ) return ; path [ pathLen ] = node -> key ; visited [ pathLen ] = false ; pathLen ++ ; if ( node -> left == NULL && node -> right == NULL && pathLen - k - 1 >= 0 && visited [ pathLen - k - 1 ] == false ) { cout << path [ pathLen - k - 1 ] << " ▁ " ; visited [ pathLen - k - 1 ] = true ; return ; } kDistantFromLeafUtil ( node -> left , path , visited , pathLen , k ) ; kDistantFromLeafUtil ( node -> right , path , visited , pathLen , k ) ; } void printKDistantfromLeaf ( Node * node , int k ) { int path [ MAX_HEIGHT ] ; bool visited [ MAX_HEIGHT ] = { false } ; kDistantFromLeafUtil ( node , path , visited , 0 , k ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; cout << " Nodes ▁ at ▁ distance ▁ 2 ▁ are : ▁ " ; printKDistantfromLeaf ( root , 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> left = temp -> right = NULL ; return temp ; } int printKDistantfromLeaf ( struct Node * node , int k ) { if ( node == NULL ) return -1 ; int lk = printKDistantfromLeaf ( node -> left , k ) ; int rk = printKDistantfromLeaf ( node -> right , k ) ; bool isLeaf = lk == -1 && lk == rk ; if ( lk == 0 || rk == 0 || ( isLeaf && k == 0 ) ) cout << ( " ▁ " ) << ( node -> data ) ; if ( isLeaf && k > 0 ) return k - 1 ; if ( lk > 0 && lk < k ) return lk - 1 ; if ( rk > 0 && rk < k ) return rk - 1 ; return -2 ; } int main ( ) { Node * root = NULL ; root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; cout << ( " ▁ Nodes ▁ at ▁ distance ▁ 2 ▁ are ▁ : " ) << endl ; printKDistantfromLeaf ( root , 2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; struct Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } void printCorner ( Node * root ) { if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { int n = q . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( i == 0 i == n - 1 ) cout << temp -> key << " ▁ " ; if ( temp -> left ) q . push ( temp -> left ) ; if ( temp -> right ) q . push ( temp -> right ) ; } } } int main ( ) { Node * root = newNode ( 15 ) ; root -> left = newNode ( 10 ) ; root -> right = newNode ( 20 ) ; root -> left -> left = newNode ( 8 ) ; root -> left -> right = newNode ( 12 ) ; root -> right -> left = newNode ( 16 ) ; root -> right -> right = newNode ( 25 ) ; printCorner ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define COUNT  10 NEW_LINE class Node { public : int data ; Node * left , * right ; Node ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; void print2DUtil ( Node * root , int space ) { if ( root == NULL ) return ; space += COUNT ; print2DUtil ( root -> right , space ) ; cout << endl ; for ( int i = COUNT ; i < space ; i ++ ) cout << " ▁ " ; cout << root -> data << " STRNEWLINE " ; print2DUtil ( root -> left , space ) ; } void print2D ( Node * root ) { print2DUtil ( root , 0 ) ; } int main ( ) { Node * root = new Node ( 1 ) ; root -> left = new Node ( 2 ) ; root -> right = new Node ( 3 ) ; root -> left -> left = new Node ( 4 ) ; root -> left -> right = new Node ( 5 ) ; root -> right -> left = new Node ( 6 ) ; root -> right -> right = new Node ( 7 ) ; root -> left -> left -> left = new Node ( 8 ) ; root -> left -> left -> right = new Node ( 9 ) ; root -> left -> right -> left = new Node ( 10 ) ; root -> left -> right -> right = new Node ( 11 ) ; root -> right -> left -> left = new Node ( 12 ) ; root -> right -> left -> right = new Node ( 13 ) ; root -> right -> right -> left = new Node ( 14 ) ; root -> right -> right -> right = new Node ( 15 ) ; print2D ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int item ) { struct Node * temp = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; temp -> data = item ; temp -> left = temp -> right = NULL ; return temp ; } void leftViewUtil ( struct Node * root , int level , int * max_level ) { if ( root == NULL ) return ; if ( * max_level < level ) { cout << root -> data << " ▁ " ; * max_level = level ; } leftViewUtil ( root -> left , level + 1 , max_level ) ; leftViewUtil ( root -> right , level + 1 , max_level ) ; } void leftView ( struct Node * root ) { int max_level = 0 ; leftViewUtil ( root , 1 , & max_level ) ; } int main ( ) { Node * root = newNode ( 10 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 7 ) ; root -> left -> right = newNode ( 8 ) ; root -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 12 ) ; root -> right -> right -> left = newNode ( 14 ) ; leftView ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } void printLeftView ( Node * root ) { if ( ! root ) return ; queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { int n = q . size ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { Node * temp = q . front ( ) ; q . pop ( ) ; if ( i == 1 ) cout << temp -> data << " ▁ " ; if ( temp -> left != NULL ) q . push ( temp -> left ) ; if ( temp -> right != NULL ) q . push ( temp -> right ) ; } } } int main ( ) { Node * root = newNode ( 10 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 7 ) ; root -> left -> right = newNode ( 8 ) ; root -> right -> right = newNode ( 15 ) ; root -> right -> left = newNode ( 12 ) ; root -> right -> right -> left = newNode ( 14 ) ; printLeftView ( root ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int rotate ( int arr [ ] , int N , int X ) { long long int nextPower = 1 ; while ( nextPower <= N ) nextPower *= 2 ; if ( X == 1 ) return nextPower - N ; long long int prevPower = nextPower / 2 ; return 2 * ( N - prevPower ) + 1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int X = 1 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << rotate ( arr , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print ( vector < vector < int > > & mat ) { for ( int i = 0 ; i < mat . size ( ) ; i ++ ) { for ( int j = 0 ; j < mat [ 0 ] . size ( ) ; j ++ ) cout << setw ( 3 ) << mat [ i ] [ j ] ; cout << " STRNEWLINE " ; } } void performSwap ( vector < vector < int > > & mat , int i , int j ) { int N = mat . size ( ) ; int ei = N - 1 - i ; int ej = N - 1 - j ; int temp = mat [ i ] [ j ] ; mat [ i ] [ j ] = mat [ ej ] [ i ] ; mat [ ej ] [ i ] = mat [ ei ] [ ej ] ; mat [ ei ] [ ej ] = mat [ j ] [ ei ] ; mat [ j ] [ ei ] = temp ; } void rotate ( vector < vector < int > > & mat , int N , int K ) { K = K % 4 ; while ( K -- ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { for ( int j = i ; j < N - i - 1 ; j ++ ) { if ( i != j && ( i + j ) != N - 1 ) { performSwap ( mat , i , j ) ; } } } } print ( mat ) ; } int main ( ) { int K = 5 ; vector < vector < int > > mat = { { 1 , 2 , 3 , 4 } , { 6 , 7 , 8 , 9 } , { 11 , 12 , 13 , 14 } , { 16 , 17 , 18 , 19 } , } ; int N = mat . size ( ) ; rotate ( mat , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaximumZeros ( string str , int n ) { int c0 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str [ i ] == '0' ) c0 ++ ; } if ( c0 == n ) { cout << n ; return ; } string s = str + str ; int mx = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int cs = 0 ; int ce = 0 ; for ( int j = i ; j < i + n ; ++ j ) { if ( s [ j ] == '0' ) cs ++ ; else break ; } for ( int j = i + n - 1 ; j >= i ; -- j ) { if ( s [ j ] == '0' ) ce ++ ; else break ; } int val = cs + ce ; mx = max ( val , mx ) ; } cout << mx ; } int main ( ) { string s = "1001" ; int n = s . size ( ) ; findMaximumZeros ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaximumZeros ( string str , int n ) { int c0 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str [ i ] == '0' ) c0 ++ ; } if ( c0 == n ) { cout << n ; return ; } int mx = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) cnt ++ ; else { mx = max ( mx , cnt ) ; cnt = 0 ; } } mx = max ( mx , cnt ) ; int start = 0 , end = n - 1 ; cnt = 0 ; while ( str [ start ] != '1' && start < n ) { cnt ++ ; start ++ ; } while ( str [ end ] != '1' && end >= 0 ) { cnt ++ ; end -- ; } mx = max ( mx , cnt ) ; cout << mx ; } int main ( ) { string s = "1001" ; int n = s . size ( ) ; findMaximumZeros ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rotateMatrix ( vector < vector < int > > & mat ) { int i = 0 ; for ( auto & it : mat ) { reverse ( it . begin ( ) , it . end ( ) ) ; reverse ( it . begin ( ) , it . begin ( ) + i ) ; reverse ( it . begin ( ) + i , it . end ( ) ) ; i ++ ; } for ( auto rows : mat ) { for ( auto cols : rows ) { cout << cols << " ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { vector < vector < int > > mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; rotateMatrix ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void stringShift ( string s , vector < vector < int > > & shift ) { int val = 0 ; for ( int i = 0 ; i < shift . size ( ) ; ++ i ) val += shift [ i ] [ 0 ] == 0 ? - shift [ i ] [ 1 ] : shift [ i ] [ 1 ] ; int len = s . length ( ) ; val = val % len ; string result = " " ; if ( val > 0 ) result = s . substr ( len - val , val ) + s . substr ( 0 , len - val ) ; else result = s . substr ( - val , len + val ) + s . substr ( 0 , - val ) ; cout << result ; } int main ( ) { string s = " abc " ; vector < vector < int > > shift = { { 0 , 1 } , { 1 , 2 } } ; stringShift ( s , shift ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rotateArray ( vector < int > & arr , int N ) { vector < int > v = arr ; sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 1 ; i <= N ; ++ i ) { rotate ( arr . begin ( ) , arr . begin ( ) + 1 , arr . end ( ) ) ; if ( arr == v ) { cout << " YES " << endl ; return ; } } cout << " NO " << endl ; } int main ( ) { vector < int > arr = { 3 , 4 , 5 , 1 , 2 } ; int N = arr . size ( ) ; rotateArray ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLargestRotation ( int num ) { int ans = num ; int len = floor ( log10 ( num ) + 1 ) ; int x = pow ( 10 , len - 1 ) ; for ( int i = 1 ; i < len ; i ++ ) { int lastDigit = num % 10 ; num = num / 10 ; num += ( lastDigit * x ) ; if ( num > ans ) { ans = num ; } } cout << ans ; } int main ( ) { int N = 657 ; findLargestRotation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfDigit ( int N ) { int digit = 0 ; while ( N > 0 ) { digit ++ ; N /= 10 ; } return digit ; } void rotateNumberByK ( int N , int K ) { int X = numberOfDigit ( N ) ; K = ( ( K % X ) + X ) % X ; int left_no = N / ( int ) ( pow ( 10 , X - K ) ) ; N = N % ( int ) ( pow ( 10 , X - K ) ) ; int left_digit = numberOfDigit ( left_no ) ; N = ( N * ( int ) ( pow ( 10 , left_digit ) ) ) + left_no ; cout << N ; } int main ( ) { int N = 12345 , K = 7 ; rotateNumberByK ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minMovesToSort ( int arr [ ] , int N ) { int count = 0 ; int index ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { count ++ ; index = i ; } } if ( count == 0 ) { cout << "0" ; } else if ( count == N - 1 ) { cout << N - 1 ; } else if ( count == 1 && arr [ 0 ] <= arr [ N - 1 ] ) { cout << index + 1 ; } else { cout << " - 1" ; } } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minMovesToSort ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void diagonalSumPerfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { cout << ( arr [ ( j + i ) % 7 ] ) << " ▁ " ; } cout << endl ; } } int main ( ) { int N = 7 ; int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = i + 1 ; } diagonalSumPerfectSquare ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxSum ( vector < int > arr , int n , int k ) { int i , max_sum = 0 , sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } max_sum = sum ; while ( i < n ) { sum = sum - arr [ i - k ] + arr [ i ] ; if ( max_sum < sum ) { max_sum = sum ; } i ++ ; } return max_sum ; } int gcd ( int n1 , int n2 ) { if ( n2 == 0 ) { return n1 ; } else { return gcd ( n2 , n1 % n2 ) ; } } vector < int > RotateArr ( vector < int > arr , int n , int d ) { int i = 0 , j = 0 ; d = d % n ; int no_of_sets = gcd ( d , n ) ; for ( i = 0 ; i < no_of_sets ; i ++ ) { int temp = arr [ i ] ; j = i ; while ( true ) { int k = j + d ; if ( k >= n ) k = k - n ; if ( k == i ) break ; arr [ j ] = arr [ k ] ; j = k ; } arr [ j ] = temp ; } return arr ; } void performQuery ( vector < int > & arr , int Q [ ] [ 2 ] , int q ) { int N = ( int ) arr . size ( ) ; for ( int i = 0 ; i < q ; i ++ ) { if ( Q [ i ] [ 0 ] == 1 ) { arr = RotateArr ( arr , N , Q [ i ] [ 1 ] ) ; for ( auto t : arr ) { cout << t << " ▁ " ; } cout << " STRNEWLINE " ; } else { cout << MaxSum ( arr , N , Q [ i ] [ 1 ] ) << " STRNEWLINE " ; } } } int main ( ) { vector < int > arr = { 1 , 2 , 3 , 4 , 5 } ; int q = 5 ; int Q [ ] [ 2 ] = { { 1 , 2 } , { 2 , 3 } , { 1 , 3 } , { 1 , 1 } , { 2 , 4 } } ; performQuery ( arr , Q , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinimumRemoval ( string str ) { int n = str . length ( ) ; int ans = n ; if ( n % 2 == 0 ) { vector < int > freqEven ( 128 ) ; vector < int > freqOdd ( 128 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { freqEven [ str [ i ] ] ++ ; } else { freqOdd [ str [ i ] ] ++ ; } } int evenMax = 0 , oddMax = 0 ; for ( char chr = ' a ' ; chr <= ' z ' ; chr ++ ) { evenMax = max ( evenMax , freqEven [ chr ] ) ; oddMax = max ( oddMax , freqOdd [ chr ] ) ; } ans = ans - evenMax - oddMax ; } else { vector < int > freq ( 128 ) ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] ] ++ ; } int strMax = 0 ; for ( char chr = ' a ' ; chr <= ' z ' ; chr ++ ) { strMax = max ( strMax , freq [ chr ] ) ; } ans = ans - strMax ; } return ans ; } int main ( ) { string str = " geeksgeeks " ; cout << getMinimumRemoval ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findAltSubSeq ( string s ) { int n = s . size ( ) , ans = INT_MIN ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int cur = 0 , f = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( f == 0 and s [ k ] - '0' == i ) { f = 1 ; cur ++ ; } else if ( f == 1 and s [ k ] - '0' == j ) { f = 0 ; cur ++ ; } } if ( i != j and cur % 2 == 1 ) cur -- ; ans = max ( cur , ans ) ; } } return ans ; } int main ( ) { string s = "100210601" ; cout << findAltSubSeq ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void matrix ( int n , int m , vector < vector < int > > li ) { int ctr = 0 ; while ( ctr < 2 * n - 1 ) { for ( int i = 0 ; i < abs ( n - ctr - 1 ) ; i ++ ) { cout << " ▁ " ; } vector < int > lst ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j == ctr ) { lst . push_back ( li [ i ] [ j ] ) ; } } } for ( int i = lst . size ( ) - 1 ; i >= 0 ; i -- ) { cout << lst [ i ] << " ▁ " ; } cout << endl ; ctr += 1 ; } } int main ( ) { int n = 8 ; int m = n ; vector < vector < int > > li { { 4 , 5 , 6 , 9 , 8 , 7 , 1 , 4 } , { 1 , 5 , 9 , 7 , 5 , 3 , 1 , 6 } , { 7 , 5 , 3 , 1 , 5 , 9 , 8 , 0 } , { 6 , 5 , 4 , 7 , 8 , 9 , 3 , 7 } , { 3 , 5 , 6 , 4 , 8 , 9 , 2 , 1 } , { 3 , 1 , 6 , 4 , 7 , 9 , 5 , 0 } , { 8 , 0 , 7 , 2 , 3 , 1 , 0 , 8 } , { 7 , 5 , 3 , 1 , 5 , 9 , 8 , 5 } } ; matrix ( n , m , li ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int key ; struct node * left ; struct node * right ; int height ; int size ; } ; int max ( int a , int b ) ; int height ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> height ; } int size ( struct node * N ) { if ( N == NULL ) return 0 ; return N -> size ; } int max ( int a , int b ) { return ( a > b ) ? a : b ; } struct node * newNode ( int key ) { struct node * node = ( struct node * ) malloc ( sizeof ( struct node ) ) ; node -> key = key ; node -> left = NULL ; node -> right = NULL ; node -> height = 1 ; node -> size = 1 ; return ( node ) ; } struct node * rightRotate ( struct node * y ) { struct node * x = y -> left ; struct node * T2 = x -> right ; x -> right = y ; y -> left = T2 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> size = size ( y -> left ) + size ( y -> right ) + 1 ; x -> size = size ( x -> left ) + size ( x -> right ) + 1 ; return x ; } struct node * leftRotate ( struct node * x ) { struct node * y = x -> right ; struct node * T2 = y -> left ; y -> left = x ; x -> right = T2 ; x -> height = max ( height ( x -> left ) , height ( x -> right ) ) + 1 ; y -> height = max ( height ( y -> left ) , height ( y -> right ) ) + 1 ; x -> size = size ( x -> left ) + size ( x -> right ) + 1 ; y -> size = size ( y -> left ) + size ( y -> right ) + 1 ; return y ; } int getBalance ( struct node * N ) { if ( N == NULL ) return 0 ; return height ( N -> left ) - height ( N -> right ) ; } struct node * insert ( struct node * node , int key , int * count ) { if ( node == NULL ) return ( newNode ( key ) ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key , count ) ; else { node -> right = insert ( node -> right , key , count ) ; * count = * count + size ( node -> left ) + 1 ; } node -> height = max ( height ( node -> left ) , height ( node -> right ) ) + 1 ; node -> size = size ( node -> left ) + size ( node -> right ) + 1 ; int balance = getBalance ( node ) ; if ( balance > 1 && key < node -> left -> key ) return rightRotate ( node ) ; if ( balance < -1 && key > node -> right -> key ) return leftRotate ( node ) ; if ( balance > 1 && key > node -> left -> key ) { node -> left = leftRotate ( node -> left ) ; return rightRotate ( node ) ; } if ( balance < -1 && key < node -> right -> key ) { node -> right = rightRotate ( node -> right ) ; return leftRotate ( node ) ; } return node ; } void constructLowerArray ( int arr [ ] , int countSmaller [ ] , int n ) { int i , j ; struct node * root = NULL ; for ( i = 0 ; i < n ; i ++ ) countSmaller [ i ] = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { root = insert ( root , arr [ i ] , & countSmaller [ i ] ) ; } } int countElements ( int A [ ] , int n , int K ) { int count = 0 ; int * countSmaller = ( int * ) malloc ( sizeof ( int ) * n ) ; constructLowerArray ( A , countSmaller , n ) ; int maxi = INT_MIN ; for ( int i = 0 ; i <= ( n - K - 1 ) ; i ++ ) { if ( A [ i ] > maxi && countSmaller [ i ] >= K ) { count ++ ; maxi = A [ i ] ; } } return count ; } int main ( ) { int A [ ] = { 2 , 5 , 1 , 7 , 3 , 4 , 0 } ; int n = sizeof ( A ) / sizeof ( int ) ; int K = 3 ; cout << countElements ( A , n , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; int index ; if ( K >= M ) index = ( N - K ) + ( M - 1 ) ; else index = ( M - K - 1 ) ; int result = a [ index ] ; return result ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int K = 3 , M = 2 ; cout << getFirstElement ( a , N , K , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getFirstElement ( int a [ ] , int N , int K , int M ) { K %= N ; int index = ( K + M - 1 ) % N ; int result = a [ index ] ; return result ; } int main ( ) { int a [ ] = { 3 , 4 , 5 , 23 } ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int K = 2 , M = 1 ; cout << getFirstElement ( a , N , K , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumMatchingPairs ( int perm1 [ ] , int perm2 [ ] , int n ) { int left [ n ] , right [ n ] ; map < int , int > mp1 , mp2 ; for ( int i = 0 ; i < n ; i ++ ) { mp1 [ perm1 [ i ] ] = i ; } for ( int j = 0 ; j < n ; j ++ ) { mp2 [ perm2 [ j ] ] = j ; } for ( int i = 0 ; i < n ; i ++ ) { int idx2 = mp2 [ perm1 [ i ] ] ; int idx1 = i ; if ( idx1 == idx2 ) { left [ i ] = 0 ; right [ i ] = 0 ; } else if ( idx1 < idx2 ) { left [ i ] = ( n - ( idx2 - idx1 ) ) ; right [ i ] = ( idx2 - idx1 ) ; } else { left [ i ] = ( idx1 - idx2 ) ; right [ i ] = ( n - ( idx1 - idx2 ) ) ; } } map < int , int > freq1 , freq2 ; for ( int i = 0 ; i < n ; i ++ ) { freq1 [ left [ i ] ] ++ ; freq2 [ right [ i ] ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , max ( freq1 [ left [ i ] ] , freq2 [ right [ i ] ] ) ) ; } return ans ; } int main ( ) { int P1 [ ] = { 5 , 4 , 3 , 2 , 1 } ; int P2 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( P1 ) / sizeof ( P1 [ 0 ] ) ; cout << maximumMatchingPairs ( P1 , P2 , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int arr [ 10000 ] ; void reverse ( int arr [ ] , int s , int e ) { while ( s < e ) { int tem = arr [ s ] ; arr [ s ] = arr [ e ] ; arr [ e ] = tem ; s = s + 1 ; e = e - 1 ; } } void fun ( int arr [ ] , int k ) { int n = 4 - 1 ; int v = n - k ; if ( v >= 0 ) { reverse ( arr , 0 , v ) ; reverse ( arr , v + 1 , n ) ; reverse ( arr , 0 , n ) ; } } int main ( ) { arr [ 0 ] = 1 ; arr [ 1 ] = 2 ; arr [ 2 ] = 3 ; arr [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { fun ( arr , i ) ; cout << ( " [ " ) ; for ( int j = 0 ; j < 4 ; j ++ ) { cout << ( arr [ j ] ) << " , ▁ " ; } cout << ( " ] " ) ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRotation ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { return i ; } } return 0 ; } int main ( ) { int arr1 [ ] = { 4 , 5 , 1 , 2 , 3 } ; int n = sizeof ( arr1 ) / sizeof ( int ) ; cout << countRotation ( arr1 , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCircularRotations ( string target , vector < string > & blocked , int N ) { string start = " " ; for ( int i = 0 ; i < N ; i ++ ) { start += '0' ; } unordered_set < string > avoid ; for ( int i = 0 ; i < blocked . size ( ) ; i ++ ) avoid . insert ( blocked [ i ] ) ; if ( avoid . find ( start ) != avoid . end ( ) ) return -1 ; if ( avoid . find ( target ) != avoid . end ( ) ) return -1 ; queue < string > qu ; qu . push ( start ) ; int count = 0 ; while ( ! qu . empty ( ) ) { count ++ ; int size = qu . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { string st = qu . front ( ) ; qu . pop ( ) ; for ( int i = 0 ; i < N ; i ++ ) { char ch = st [ i ] ; st [ i ] ++ ; if ( st [ i ] > '9' ) st [ i ] = '0' ; if ( st == target ) return count ; if ( avoid . find ( st ) == avoid . end ( ) ) qu . push ( st ) ; avoid . insert ( st ) ; st [ i ] = ch - 1 ; if ( st [ i ] < '0' ) st [ i ] = '9' ; if ( st == target ) return count ; if ( avoid . find ( st ) == avoid . end ( ) ) qu . push ( st ) ; avoid . insert ( st ) ; st [ i ] = ch ; } } } return -1 ; } int main ( ) { int N = 4 ; string target = "7531" ; vector < string > blocked = { "1543" , "7434" , "7300" , "7321" , "2427" } ; cout << minCircularRotations ( target , blocked , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rotatedSumQuery ( int arr [ ] , int n , vector < vector < int > > & query , int Q ) { int prefix [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] = arr [ i ] ; prefix [ i + n ] = arr [ i ] ; } for ( int i = 1 ; i < 2 * n ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; int start = 0 ; for ( int q = 0 ; q < Q ; q ++ ) { if ( query [ q ] [ 0 ] == 1 ) { int k = query [ q ] [ 1 ] ; start = ( start + k ) % n ; } else if ( query [ q ] [ 0 ] == 2 ) { int L , R ; L = query [ q ] [ 1 ] ; R = query [ q ] [ 2 ] ; if ( start + L == 0 ) cout << prefix [ start + R ] << endl ; else cout << prefix [ start + R ] - prefix [ start + L - 1 ] << endl ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int Q = 5 ; vector < vector < int > > query = { { 2 , 1 , 3 } , { 1 , 3 } , { 2 , 0 , 3 } , { 1 , 4 } , { 2 , 3 , 5 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rotatedSumQuery ( arr , n , query , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isConversionPossible ( string s1 , string s2 , int x ) { int diff , n ; n = s1 . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) continue ; diff = ( int ( s2 [ i ] - s1 [ i ] ) + 26 ) % 26 ; if ( diff > x ) { cout << " NO " << endl ; return ; } } cout << " YES " << endl ; } int main ( ) { string s1 = " you " ; string s2 = " ara " ; int x = 6 ; isConversionPossible ( s1 , s2 , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void RightRotate ( int a [ ] , int n , int k ) { k = k % n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) { cout << a [ n + i - k ] << " ▁ " ; } else { cout << ( a [ i - k ] ) << " ▁ " ; } } cout << " STRNEWLINE " ; } int main ( ) { int Array [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( Array ) / sizeof ( Array [ 0 ] ) ; int K = 2 ; RightRotate ( Array , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ - > ▁ " ; node = node -> next ; } cout << " NULL " ; } Node * rightRotate ( Node * head , int k ) { if ( ! head ) return head ; Node * tmp = head ; int len = 1 ; while ( tmp -> next != NULL ) { tmp = tmp -> next ; len ++ ; } if ( k > len ) k = k % len ; k = len - k ; if ( k == 0 k == len ) return head ; Node * current = head ; int cnt = 1 ; while ( cnt < k && current != NULL ) { current = current -> next ; cnt ++ ; } if ( current == NULL ) return head ; Node * kthnode = current ; tmp -> next = head ; head = kthnode -> next ; kthnode -> next = NULL ; return head ; } int main ( ) { Node * head = NULL ; push ( & head , 5 ) ; push ( & head , 4 ) ; push ( & head , 3 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; int k = 2 ; Node * updated_head = rightRotate ( head , k ) ; printList ( updated_head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntRotations ( string s , int n ) { string str = s + s ; int pre [ 2 * n ] = { 0 } ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i != 0 ) pre [ i ] += pre [ i - 1 ] ; if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { pre [ i ] ++ ; } } int ans = 0 ; for ( int i = n - 1 ; i < 2 * n - 1 ; i ++ ) { int r = i , l = i - n ; int x1 = pre [ r ] ; if ( l >= 0 ) x1 -= pre [ l ] ; r = i - n / 2 ; int left = pre [ r ] ; if ( l >= 0 ) left -= pre [ l ] ; int right = x1 - left ; if ( left > right ) { ans ++ ; } } return ans ; } int main ( ) { string s = " abecidft " ; int n = s . length ( ) ; cout << cntRotations ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntRotations ( char s [ ] , int n ) { int lh = 0 , rh = 0 , i , ans = 0 ; for ( i = 0 ; i < n / 2 ; ++ i ) if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { lh ++ ; } for ( i = n / 2 ; i < n ; ++ i ) if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { rh ++ ; } if ( lh > rh ) ans ++ ; for ( i = 1 ; i < n ; ++ i ) { if ( s [ i - 1 ] == ' a ' s [ i - 1 ] == ' e ' s [ i - 1 ] == ' i ' s [ i - 1 ] == ' o ' s [ i - 1 ] == ' u ' ) { rh ++ ; lh -- ; } if ( s [ ( i - 1 + n / 2 ) % n ] == ' a ' || s [ ( i - 1 + n / 2 ) % n ] == ' e ' || s [ ( i - 1 + n / 2 ) % n ] == ' i ' || s [ ( i - 1 + n / 2 ) % n ] == ' o ' || s [ ( i - 1 + n / 2 ) % n ] == ' u ' ) { rh -- ; lh ++ ; } if ( lh > rh ) ans ++ ; } return ans ; } int main ( ) { char s [ ] = " abecidft " ; int n = strlen ( s ) ; cout << " ▁ " << cntRotations ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define size  2 NEW_LINE void performQueries ( string str , int n , int queries [ ] [ size ] , int q ) { int ptr = 0 ; for ( int i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 1 ) { ptr = ( ptr + queries [ i ] [ 1 ] ) % n ; } else { int k = queries [ i ] [ 1 ] ; int index = ( ptr + k - 1 ) % n ; cout << str [ index ] << " STRNEWLINE " ; } } } int main ( ) { string str = " abcdefgh " ; int n = str . length ( ) ; int queries [ ] [ size ] = { { 1 , 2 } , { 2 , 2 } , { 1 , 4 } , { 2 , 7 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; performQueries ( str , n , queries , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; cout << " Odd ▁ = ▁ " << odd_count << endl ; cout << " Even ▁ = ▁ " << even_count << endl ; } int main ( ) { int n = 1234 ; countOddRotations ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct ListNode { int data ; struct ListNode * next ; } ; void rotateSubList ( ListNode * A , int m , int n , int k ) { int size = n - m + 1 ; if ( k > size ) { k = k % size ; } if ( k == 0 k == size ) { ListNode * head = A ; while ( head != NULL ) { cout << head -> data ; head = head -> next ; } return ; } ListNode * link = NULL ; if ( m == 1 ) { link = A ; } ListNode * c = A ; int count = 0 ; ListNode * end = NULL ; ListNode * pre = NULL ; while ( c != NULL ) { count ++ ; if ( count == m - 1 ) { pre = c ; link = c -> next ; } if ( count == n - k ) { if ( m == 1 ) { end = c ; A = c -> next ; } else { end = c ; pre -> next = c -> next ; } } if ( count == n ) { ListNode * d = c -> next ; c -> next = link ; end -> next = d ; ListNode * head = A ; while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } return ; } c = c -> next ; } } void push ( struct ListNode * * head , int val ) { struct ListNode * new_node = new ListNode ; new_node -> data = val ; new_node -> next = ( * head ) ; ( * head ) = new_node ; } int main ( ) { struct ListNode * head = NULL ; push ( & head , 70 ) ; push ( & head , 60 ) ; push ( & head , 50 ) ; push ( & head , 40 ) ; push ( & head , 30 ) ; push ( & head , 20 ) ; push ( & head , 10 ) ; ListNode * tmp = head ; cout << " Given ▁ List : ▁ " ; while ( tmp != NULL ) { cout << tmp -> data << " ▁ " ; tmp = tmp -> next ; } cout << endl ; int m = 3 , n = 6 , k = 2 ; cout << " After ▁ rotation ▁ of ▁ sublist : ▁ " ; rotateSubList ( head , m , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool rightRotationDivisor ( int N ) { int lastDigit = N % 10 ; int rightRotation = ( lastDigit * pow ( 10 , int ( log10 ( N ) ) ) ) + floor ( N / 10 ) ; return ( rightRotation % N == 0 ) ; } void generateNumbers ( int m ) { for ( int i = pow ( 10 , ( m - 1 ) ) ; i < pow ( 10 , m ) ; i ++ ) if ( rightRotationDivisor ( i ) ) cout << i << endl ; } int main ( ) { int m = 3 ; generateNumbers ( m ) ; }
#include <climits> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void checkIfSortRotated ( int arr [ ] , int n ) { int minEle = INT_MAX ; int maxEle = INT_MIN ; int minIndex = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } int flag1 = 1 ; for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = 0 ; break ; } } int flag2 = 1 ; for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = 0 ; break ; } } if ( flag1 && flag2 && ( arr [ n - 1 ] < arr [ 0 ] ) ) cout << " YES " ; else cout << " NO " ; } int main ( ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkIfSortRotated ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkRotatedAndSorted ( int arr [ ] , int n ) { int x = 0 , y = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) x ++ ; else y ++ ; } if ( x == 1 y == 1 ) { if ( arr [ n - 1 ] < arr [ 0 ] ) x ++ ; else y ++ ; if ( x == 1 y == 1 ) return true ; } return false ; } int main ( ) { int arr [ ] = { 4 , 5 , 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkRotatedAndSorted ( arr , n ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void rotate ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < i ; ++ j ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ j ] [ i ] ; arr [ j ] [ i ] = temp ; } } for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N / 2 ; ++ j ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ i ] [ N - j - 1 ] ; arr [ i ] [ N - j - 1 ] = temp ; } } } void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) cout << arr [ i ] [ j ] << " ▁ " ; cout << ' ' ; } } int main ( ) { int arr [ N ] [ N ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; rotate ( arr ) ; print ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void rotate ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N - i ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ N - 1 - j ] [ N - 1 - i ] ; arr [ N - 1 - j ] [ N - 1 - i ] = temp ; } } for ( int i = 0 ; i < N / 2 ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int temp = arr [ i ] [ j ] ; arr [ i ] [ j ] = arr [ N - 1 - i ] [ j ] ; arr [ N - 1 - i ] [ j ] = temp ; } } } void print ( int arr [ N ] [ N ] ) { for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) cout << arr [ i ] [ j ] << " ▁ " ; cout << ' ' ; } } int main ( ) { int arr [ N ] [ N ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; rotate ( arr ) ; print ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void occurredOnce ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; if ( arr [ 0 ] != arr [ 1 ] ) cout << arr [ 0 ] << " ▁ " ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) cout << arr [ i ] << " ▁ " ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) cout << arr [ n - 1 ] << " ▁ " ; } int main ( ) { int arr [ ] = { 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; occurredOnce ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void occurredOnce ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; for ( auto it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) if ( it -> second == 1 ) cout << it -> first << " ▁ " ; } int main ( ) { int arr [ ] = { 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; occurredOnce ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void occurredOnce ( int arr [ ] , int n ) { int i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else cout << arr [ i - 1 ] << " ▁ " ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) cout << arr [ n - 1 ] ; } int main ( ) { int arr [ ] = { 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; occurredOnce ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rvereseArray ( int arr [ ] , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; } void splitArr ( int arr [ ] , int k , int n ) { rvereseArray ( arr , 0 , n - 1 ) ; rvereseArray ( arr , 0 , n - k - 1 ) ; rvereseArray ( arr , n - k , n - 1 ) ; } int main ( ) { int arr [ ] = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; splitArr ( arr , k , n ) ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isRotation ( string a , string b ) { int n = a . length ( ) ; int m = b . length ( ) ; if ( n != m ) return false ; int lps [ n ] ; int len = 0 ; int i = 1 ; lps [ 0 ] = 0 ; while ( i < n ) { if ( a [ i ] == b [ len ] ) { lps [ i ] = ++ len ; ++ i ; } else { if ( len == 0 ) { lps [ i ] = 0 ; ++ i ; } else { len = lps [ len - 1 ] ; } } } i = 0 ; for ( int k = lps [ n - 1 ] ; k < m ; ++ k ) { if ( b [ k ] != a [ i ++ ] ) return false ; } return true ; } int main ( ) { string s1 = " ABACD " ; string s2 = " CDABA " ; cout << ( isRotation ( s1 , s2 ) ? "1" : "0" ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRotationsDivBy8 ( string n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n [ 0 ] - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0' ) * 10 + ( n [ i + 2 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; } int main ( ) { string n = "43262488612" ; cout << " Rotations : ▁ " << countRotationsDivBy8 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimunMoves ( string arr [ ] , int n ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int curr_count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { string tmp = arr [ j ] + arr [ j ] ; int index = tmp . find ( arr [ i ] ) ; if ( index == string :: npos ) return -1 ; curr_count += index ; } ans = min ( curr_count , ans ) ; } return ans ; } int main ( ) { string arr [ ] = { " xzzwo " , " zwoxz " , " zzwox " , " xzzwo " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimunMoves ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void restoreSortedArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { reverse ( arr , arr + i + 1 ) ; reverse ( arr + i + 1 , arr + n ) ; reverse ( arr , arr + n ) ; } } } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; int countRotation ( struct Node * head ) { int count = 0 ; int min = head -> data ; while ( head != NULL ) { if ( min > head -> data ) break ; count ++ ; head = head -> next ; } return count ; } void push ( struct Node * * head , int data ) { struct Node * newNode = new Node ; newNode -> data = data ; newNode -> next = ( * head ) ; ( * head ) = newNode ; } void printList ( struct Node * node ) { while ( node != NULL ) { printf ( " % d ▁ " , node -> data ) ; node = node -> next ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 11 ) ; push ( & head , 8 ) ; push ( & head , 5 ) ; push ( & head , 18 ) ; push ( & head , 15 ) ; printList ( head ) ; cout << endl ; cout << " Linked ▁ list ▁ rotated ▁ elements : ▁ " ; cout << countRotation ( head ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; Node * rotateHelper ( Node * blockHead , Node * blockTail , int d , Node * * tail , int k ) { if ( d == 0 ) return blockHead ; if ( d > 0 ) { Node * temp = blockHead ; for ( int i = 1 ; temp -> next -> next && i < k - 1 ; i ++ ) temp = temp -> next ; blockTail -> next = blockHead ; * tail = temp ; return rotateHelper ( blockTail , temp , d - 1 , tail , k ) ; } if ( d < 0 ) { blockTail -> next = blockHead ; * tail = blockHead ; return rotateHelper ( blockHead -> next , blockHead , d + 1 , tail , k ) ; } } Node * rotateByBlocks ( Node * head , int k , int d ) { if ( ! head ! head -> next ) return head ; if ( d == 0 ) return head ; Node * temp = head , * tail = NULL ; int i ; for ( i = 1 ; temp -> next && i < k ; i ++ ) temp = temp -> next ; Node * nextBlock = temp -> next ; if ( i < k ) head = rotateHelper ( head , temp , d % k , & tail , i ) ; else head = rotateHelper ( head , temp , d % k , & tail , k ) ; tail -> next = rotateByBlocks ( nextBlock , k , d % k ) ; return head ; } void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } } int main ( ) { Node * head = NULL ; for ( int i = 9 ; i > 0 ; i -= 1 ) push ( & head , i ) ; cout << " Given ▁ linked ▁ list ▁ STRNEWLINE " ; printList ( head ) ; int k = 3 , d = 2 ; head = rotateByBlocks ( head , k , d ) ; cout << " Rotated by blocks Linked list " ; printList ( head ) ; return ( 0 ) ; }
#include <iostream> NEW_LINE using namespace std ; int findRotations ( string str ) { string tmp = str + str ; int n = str . length ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { string substring = tmp . substr ( i , str . size ( ) ) ; if ( str == substring ) return i ; } return n ; } int main ( ) { string str = " abc " ; cout << findRotations ( str ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isRotation ( unsigned int x , unsigned int y ) { unsigned long long int x64 = x | ( ( unsigned long long int ) x << 32 ) ; while ( x64 >= y ) { if ( unsigned ( x64 ) == y ) return true ; x64 >>= 1 ; } return false ; } int main ( ) { unsigned int x = 122 ; unsigned int y = 2147483678 ; if ( isRotation ( x , y ) ) cout << " yes " << endl ; else cout << " no " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void leftrotate ( string & s , int d ) { reverse ( s . begin ( ) , s . begin ( ) + d ) ; reverse ( s . begin ( ) + d , s . end ( ) ) ; reverse ( s . begin ( ) , s . end ( ) ) ; } void rightrotate ( string & s , int d ) { leftrotate ( s , s . length ( ) - d ) ; } int main ( ) { string str1 = " GeeksforGeeks " ; leftrotate ( str1 , 2 ) ; cout << str1 << endl ; string str2 = " GeeksforGeeks " ; rightrotate ( str2 , 2 ) ; cout << str2 << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRotations ( string n ) { int len = n . length ( ) ; if ( len == 1 ) { int oneDigit = n . at ( 0 ) - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n . at ( i ) - '0' ) * 10 + ( n . at ( i + 1 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n . at ( len - 1 ) - '0' ) * 10 + ( n . at ( 0 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; } int main ( ) { string n = "4834" ; cout << " Rotations : ▁ " << countRotations ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isRotated ( string str1 , string str2 ) { if ( str1 . length ( ) != str2 . length ( ) ) return false ; if ( str1 . length ( ) < 2 ) { return str1 . compare ( str2 ) == 0 ; } string clock_rot = " " ; string anticlock_rot = " " ; int len = str2 . length ( ) ; anticlock_rot = anticlock_rot + str2 . substr ( len - 2 , 2 ) + str2 . substr ( 0 , len - 2 ) ; clock_rot = clock_rot + str2 . substr ( 2 ) + str2 . substr ( 0 , 2 ) ; return ( str1 . compare ( clock_rot ) == 0 || str1 . compare ( anticlock_rot ) == 0 ) ; } int main ( ) { string str1 = " geeks " ; string str2 = " eksge " ; isRotated ( str1 , str2 ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; Node ( int d ) { data = d ; next = NULL ; } } ; void print ( Node * head ) { Node * temp = head ; while ( temp != NULL ) { cout << temp -> data << " ▁ " ; temp = temp -> next ; } } void NextGreaterElement ( Node * head ) { Node * H = head ; Node * res = NULL ; Node * tempList = NULL ; do { Node * curr = head ; int Val = -1 ; do { if ( head -> data < curr -> data ) { Val = curr -> data ; break ; } curr = curr -> next ; } while ( curr != head ) ; if ( res == NULL ) { res = new Node ( Val ) ; tempList = res ; } else { tempList -> next = new Node ( Val ) ; tempList = tempList -> next ; } head = head -> next ; } while ( head != H ) ; print ( res ) ; } int main ( ) { Node * head = new Node ( 1 ) ; head -> next = new Node ( 5 ) ; head -> next -> next = new Node ( 12 ) ; head -> next -> next -> next = new Node ( 10 ) ; head -> next -> next -> next -> next = new Node ( 0 ) ; head -> next -> next -> next -> next -> next = head ; NextGreaterElement ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; void printList ( Node * n ) { while ( n != NULL ) { cout << n -> data << " ▁ " ; n = n -> next ; } } int main ( ) { Node * head = NULL ; Node * second = NULL ; Node * third = NULL ; head = new Node ( ) ; second = new Node ( ) ; third = new Node ( ) ; head -> data = 1 ; head -> next = second ; second -> data = 2 ; second -> next = third ; third -> data = 3 ; third -> next = NULL ; printList ( head ) ; return 0 ; }
struct Node { int data ; struct Node * next ; struct Node * prev ; } ;
class Node { public : int data ; Node * next ; } ;
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int data ) { struct Node * ptr1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * temp = * head_ref ; ptr1 -> data = data ; ptr1 -> next = * head_ref ; if ( * head_ref != NULL ) { while ( temp -> next != * head_ref ) temp = temp -> next ; temp -> next = ptr1 ; } else ptr1 -> next = ptr1 ; * head_ref = ptr1 ; } void deleteNode ( Node * head_ref , Node * del ) { struct Node * temp = head_ref ; if ( head_ref == del ) head_ref = del -> next ; while ( temp -> next != del ) { temp = temp -> next ; } temp -> next = del -> next ; free ( del ) ; return ; } int largestElement ( struct Node * head_ref ) { struct Node * current ; current = head_ref ; int maxEle = INT_MIN ; do { if ( current -> data > maxEle ) { maxEle = current -> data ; } current = current -> next ; } while ( current != head_ref ) ; return maxEle ; } void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } void deleteFibonacciNodes ( Node * head ) { int maxEle = largestElement ( head ) ; set < int > hash ; createHash ( hash , maxEle ) ; struct Node * ptr = head ; struct Node * next ; do { if ( hash . find ( ptr -> data ) != hash . end ( ) ) deleteNode ( head , ptr ) ; next = ptr -> next ; ptr = next ; } while ( ptr != head ) ; } void printList ( struct Node * head ) { struct Node * temp = head ; if ( head != NULL ) { do { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } while ( temp != head ) ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 20 ) ; push ( & head , 13 ) ; push ( & head , 6 ) ; push ( & head , 34 ) ; push ( & head , 11 ) ; push ( & head , 9 ) ; deleteFibonacciNodes ( head ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int data ) { struct Node * ptr1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * temp = * head_ref ; ptr1 -> data = data ; ptr1 -> next = * head_ref ; if ( * head_ref != NULL ) { while ( temp -> next != * head_ref ) temp = temp -> next ; temp -> next = ptr1 ; } else ptr1 -> next = ptr1 ; * head_ref = ptr1 ; } void deleteNode ( Node * head_ref , Node * del ) { struct Node * temp = head_ref ; if ( head_ref == del ) head_ref = del -> next ; while ( temp -> next != del ) { temp = temp -> next ; } temp -> next = del -> next ; free ( del ) ; return ; } void deleteoddNodes ( Node * head ) { struct Node * ptr = head ; struct Node * next ; do { if ( ( ptr -> data % 2 ) == 1 ) deleteNode ( head , ptr ) ; next = ptr -> next ; ptr = next ; } while ( ptr != head ) ; } void printList ( struct Node * head ) { struct Node * temp = head ; if ( head != NULL ) { do { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } while ( temp != head ) ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 2 ) ; push ( & head , 12 ) ; push ( & head , 11 ) ; push ( & head , 57 ) ; push ( & head , 61 ) ; push ( & head , 56 ) ; cout << " List after deletion : " ; deleteoddNodes ( head ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { Node * next ; int data ; } ; Node * create ( ) { Node * new_node = ( Node * ) malloc ( sizeof ( Node ) ) ; new_node -> next = NULL ; return new_node ; } Node * find_head ( Node * random ) { if ( random == NULL ) return NULL ; Node * head , * var = random ; while ( ! ( var -> data > var -> next -> data var -> next == random ) ) { var = var -> next ; } return var -> next ; } Node * sortedInsert ( Node * head_ref , Node * new_node ) { Node * current = head_ref ; if ( current == NULL ) { new_node -> next = new_node ; head_ref = new_node ; } else if ( current -> data >= new_node -> data ) { while ( current -> next != head_ref ) current = current -> next ; current -> next = new_node ; new_node -> next = head_ref ; head_ref = new_node ; } else { while ( current -> next != head_ref && current -> next -> data < new_node -> data ) { current = current -> next ; } new_node -> next = current -> next ; current -> next = new_node ; } return head_ref ; } void printList ( Node * start ) { Node * temp ; if ( start != NULL ) { temp = start ; do { cout << temp -> data << " ▁ " ; temp = temp -> next ; } while ( temp != start ) ; } } int main ( ) { int arr [ ] = { 12 , 56 , 2 , 11 , 1 , 90 } ; int list_size , i ; Node * start = NULL ; Node * temp ; for ( i = 0 ; i < 6 ; i ++ ) { if ( start != NULL ) for ( int j = 0 ; j < ( rand ( ) % 10 ) ; j ++ ) start = start -> next ; temp = create ( ) ; temp -> data = arr [ i ] ; start = sortedInsert ( find_head ( start ) , temp ) ; } printList ( find_head ( start ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class CircularLinkedList { public : struct Node { int data ; Node * next ; } ; Node * last ; Node * addToEmpty ( int data ) { if ( last != NULL ) return last ; Node * temp = new Node ( ) ; temp -> data = data ; last = temp ; last -> next = last ; return last ; } Node * addBegin ( int data ) { if ( last == NULL ) return addToEmpty ( data ) ; Node * temp = new Node ( ) ; temp -> data = data ; temp -> next = last -> next ; last -> next = temp ; return last ; } void traverse ( ) { Node * p ; if ( last == NULL ) { cout << ( " List ▁ is ▁ empty . " ) ; return ; } p = last -> next ; do { cout << p -> data << " ▁ " ; p = p -> next ; } while ( p != last -> next ) ; cout << endl ; } int length ( ) { int x = 0 ; if ( last == NULL ) return x ; Node * itr = last -> next ; while ( itr -> next != last -> next ) { x ++ ; itr = itr -> next ; } return ( x + 1 ) ; } Node * split ( int k ) { Node * pass = new Node ( ) ; if ( last == NULL ) return last ; Node * newLast , * itr = last ; for ( int i = 0 ; i < k ; i ++ ) { itr = itr -> next ; } newLast = itr ; pass -> next = itr -> next ; newLast -> next = last -> next ; last -> next = pass -> next ; return newLast ; } } ; int main ( ) { CircularLinkedList * clist = new CircularLinkedList ( ) ; clist -> last = NULL ; clist -> addToEmpty ( 12 ) ; clist -> addBegin ( 10 ) ; clist -> addBegin ( 8 ) ; clist -> addBegin ( 6 ) ; clist -> addBegin ( 4 ) ; clist -> addBegin ( 2 ) ; cout << ( " Original ▁ list : " ) ; clist -> traverse ( ) ; int k = 4 ; CircularLinkedList * clist2 = new CircularLinkedList ( ) ; clist2 -> last = clist -> split ( k ) ; cout << ( " The ▁ new ▁ lists ▁ are : " ) ; clist2 -> traverse ( ) ; clist -> traverse ( ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; Node ( int x ) { data = x ; left = right = NULL ; } } ; void inorder ( Node * root , vector < int > & v ) { if ( ! root ) return ; inorder ( root -> left , v ) ; v . push_back ( root -> data ) ; inorder ( root -> right , v ) ; } Node * bTreeToCList ( Node * root ) { if ( root == NULL ) return NULL ; vector < int > v ; inorder ( root , v ) ; Node * head_ref = new Node ( v [ 0 ] ) ; Node * curr = head_ref ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { Node * temp = curr ; curr -> right = new Node ( v [ i ] ) ; curr = curr -> right ; curr -> left = temp ; } curr -> right = head_ref ; head_ref -> left = curr ; return head_ref ; } void displayCList ( Node * head ) { cout << " Circular ▁ Doubly ▁ Linked ▁ List ▁ is ▁ : STRNEWLINE " ; Node * itr = head ; do { cout << itr -> data << " ▁ " ; itr = itr -> right ; } while ( head != itr ) ; cout << " STRNEWLINE " ; } int main ( ) { Node * root = new Node ( 10 ) ; root -> left = new Node ( 12 ) ; root -> right = new Node ( 15 ) ; root -> left -> left = new Node ( 25 ) ; root -> left -> right = new Node ( 30 ) ; root -> right -> left = new Node ( 36 ) ; Node * head = bTreeToCList ( root ) ; displayCList ( head ) ; return 0 ; }
void DeleteAllOddNode ( struct Node * * head ) { int len = Length ( * head ) ; int count = 0 ; struct Node * previous = * head , * next = * head ; if ( * head == NULL ) { printf ( " Delete Last List is empty " return ; } if ( len == 1 ) { DeleteFirst ( head ) ; return ; } while ( len > 0 ) { if ( count == 0 ) { DeleteFirst ( head ) ; } if ( count % 2 == 0 && count != 0 ) { deleteNode ( * head , previous ) ; } previous = previous -> next ; next = previous -> next ; len -- ; count ++ ; } return ; }
void DeleteAllEvenNode ( struct Node * * head ) { int len = Length ( * head ) ; int count = 1 ; struct Node * previous = * head , * next = * head ; if ( * head == NULL ) { printf ( " List is empty " return ; } if ( len < 2 ) { return ; } previous = * head ; next = previous -> next ; while ( len > 0 ) { if ( count % 2 == 0 ) { previous -> next = next -> next ; free ( next ) ; previous = next -> next ; next = previous -> next ; } len -- ; count ++ ; } return ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int data ; struct Node * next ; } ; int Length ( struct Node * head ) { struct Node * current = head ; int count = 0 ; if ( head == NULL ) { return 0 ; } else { do { current = current -> next ; count ++ ; } while ( current != head ) ; } return count ; } void Display ( struct Node * head ) { struct Node * current = head ; if ( head == NULL ) { printf ( " Display List is empty " return ; } else { do { printf ( " % d ▁ " , current -> data ) ; current = current -> next ; } while ( current != head ) ; } } void Insert ( struct Node * * head , int data ) { struct Node * current = * head ; struct Node * newNode = new Node ; if ( ! newNode ) { printf ( " Memory Error " return ; } newNode -> data = data ; if ( * head == NULL ) { newNode -> next = newNode ; * head = newNode ; return ; } else { while ( current -> next != * head ) { current = current -> next ; } newNode -> next = * head ; current -> next = newNode ; } } void deleteNode ( struct Node * head_ref , struct Node * del ) { struct Node * temp = head_ref ; if ( head_ref == del ) { head_ref = del -> next ; } while ( temp -> next != del ) { temp = temp -> next ; } temp -> next = del -> next ; free ( del ) ; return ; } void DeleteFirst ( struct Node * * head ) { struct Node * previous = * head , * next = * head ; if ( * head == NULL ) { printf ( " List is empty " return ; } if ( previous -> next == previous ) { * head = NULL ; return ; } while ( previous -> next != * head ) { previous = previous -> next ; next = previous -> next ; } previous -> next = next -> next ; * head = previous -> next ; free ( next ) ; return ; } void DeleteAllOddNode ( struct Node * * head ) { int len = Length ( * head ) ; int count = 0 ; struct Node * previous = * head , * next = * head ; if ( * head == NULL ) { printf ( " Delete Last List is empty " return ; } if ( len == 1 ) { DeleteFirst ( head ) ; return ; } while ( len > 0 ) { if ( count == 0 ) { DeleteFirst ( head ) ; } if ( count % 2 == 0 && count != 0 ) { deleteNode ( * head , previous ) ; } previous = previous -> next ; next = previous -> next ; len -- ; count ++ ; } return ; } void DeleteAllEvenNode ( struct Node * * head ) { int len = Length ( * head ) ; int count = 1 ; struct Node * previous = * head , * next = * head ; if ( * head == NULL ) { printf ( " List is empty " return ; } if ( len < 2 ) { return ; } previous = * head ; next = previous -> next ; while ( len > 0 ) { if ( count % 2 == 0 ) { previous -> next = next -> next ; free ( next ) ; previous = next -> next ; next = previous -> next ; } len -- ; count ++ ; } return ; } int main ( ) { struct Node * head = NULL ; Insert ( & head , 99 ) ; Insert ( & head , 11 ) ; Insert ( & head , 22 ) ; Insert ( & head , 33 ) ; Insert ( & head , 44 ) ; Insert ( & head , 55 ) ; Insert ( & head , 66 ) ; printf ( " Initial ▁ List : ▁ " ) ; Display ( head ) ; printf ( " After deleting Odd position nodes : " DeleteAllOddNode ( & head ) ; Display ( head ) ; printf ( " Initial List : " Display ( head ) ; printf ( " After deleting even position nodes : " DeleteAllEvenNode ( & head ) ; Display ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void Insert ( struct Node * * head , int data ) { struct Node * current = * head ; struct Node * newNode = new Node ; if ( ! newNode ) { printf ( " Memory Error " return ; } newNode -> data = data ; if ( * head == NULL ) { newNode -> next = newNode ; * head = newNode ; return ; } else { while ( current -> next != * head ) { current = current -> next ; } newNode -> next = * head ; current -> next = newNode ; } } void Display ( struct Node * head ) { struct Node * current = head ; if ( head == NULL ) { printf ( " Display List is empty " return ; } else { do { printf ( " % d ▁ " , current -> data ) ; current = current -> next ; } while ( current != head ) ; } } int Length ( struct Node * head ) { struct Node * current = head ; int count = 0 ; if ( head == NULL ) { return 0 ; } else { do { current = current -> next ; count ++ ; } while ( current != head ) ; } return count ; } void DeleteFirst ( struct Node * * head ) { struct Node * previous = * head , * next = * head ; if ( * head == NULL ) { printf ( " List is empty " return ; } if ( previous -> next == previous ) { * head = NULL ; return ; } while ( previous -> next != * head ) { previous = previous -> next ; next = previous -> next ; } previous -> next = next -> next ; * head = previous -> next ; free ( next ) ; return ; } void DeleteLast ( struct Node * * head ) { struct Node * current = * head , * temp = * head , * previous ; if ( * head == NULL ) { printf ( " List is empty " return ; } if ( current -> next == current ) { * head = NULL ; return ; } while ( current -> next != * head ) { previous = current ; current = current -> next ; } previous -> next = current -> next ; * head = previous -> next ; free ( current ) ; return ; } void DeleteAtPosition ( struct Node * * head , int index ) { int len = Length ( * head ) ; int count = 1 ; struct Node * previous = * head , * next = * head ; if ( * head == NULL ) { printf ( " Delete Last List is empty " return ; } if ( index >= len index < 0 ) { printf ( " Index is not Found " return ; } if ( index == 0 ) { DeleteFirst ( head ) ; return ; } while ( len > 0 ) { if ( index == count ) { previous -> next = next -> next ; free ( next ) ; return ; } previous = previous -> next ; next = previous -> next ; len -- ; count ++ ; } return ; } int main ( ) { struct Node * head = NULL ; Insert ( & head , 99 ) ; Insert ( & head , 11 ) ; Insert ( & head , 22 ) ; Insert ( & head , 33 ) ; Insert ( & head , 44 ) ; Insert ( & head , 55 ) ; Insert ( & head , 66 ) ; printf ( " Initial ▁ List : ▁ " ) ; Display ( head ) ; printf ( " After Deleting node at index 4 : " DeleteAtPosition ( & head , 4 ) ; Display ( head ) ; printf ( " Initial List : " Display ( head ) ; printf ( " After Deleting first node : " DeleteFirst ( & head ) ; Display ( head ) ; printf ( " Initial List : " Display ( head ) ; printf ( " After Deleting last node : " DeleteLast ( & head ) ; Display ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void printMinMax ( struct Node * * head ) { if ( * head == NULL ) { return ; } struct Node * current ; current = * head ; int min = INT_MAX , max = INT_MIN ; do { if ( current -> data < min ) { min = current -> data ; } if ( current -> data > max ) { max = current -> data ; } current = current -> next ; } while ( current != head ) ; cout << " Minimum = " ▁ < < ▁ min ▁ < < ▁ " , Maximum = " } void insertNode ( struct Node * * head , int data ) { struct Node * current = * head ; struct Node * newNode = new Node ; if ( ! newNode ) { printf ( " Memory Error " return ; } newNode -> data = data ; if ( * head == NULL ) { newNode -> next = newNode ; * head = newNode ; return ; } else { while ( current -> next != * head ) { current = current -> next ; } newNode -> next = * head ; current -> next = newNode ; } } void displayList ( struct Node * head ) { struct Node * current = head ; if ( head == NULL ) { printf ( " Display List is empty " return ; } else { do { printf ( " % d ▁ " , current -> data ) ; current = current -> next ; } while ( current != head ) ; } } int main ( ) { struct Node * Head = NULL ; insertNode ( & Head , 99 ) ; insertNode ( & Head , 11 ) ; insertNode ( & Head , 22 ) ; insertNode ( & Head , 33 ) ; insertNode ( & Head , 44 ) ; insertNode ( & Head , 55 ) ; insertNode ( & Head , 66 ) ; cout << " Initial ▁ List : ▁ " ; displayList ( Head ) ; printMinMax ( & Head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int data ) { struct Node * ptr1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * temp = * head_ref ; ptr1 -> data = data ; ptr1 -> next = * head_ref ; if ( * head_ref != NULL ) { while ( temp -> next != * head_ref ) temp = temp -> next ; temp -> next = ptr1 ; } else ptr1 -> next = ptr1 ; * head_ref = ptr1 ; } void deleteNode ( Node * head_ref , Node * del ) { struct Node * temp = head_ref ; if ( head_ref == del ) head_ref = del -> next ; while ( temp -> next != del ) { temp = temp -> next ; } temp -> next = del -> next ; free ( del ) ; return ; } void deleteEvenNodes ( Node * head ) { struct Node * ptr = head ; struct Node * next ; do { if ( ptr -> data % 2 == 0 ) deleteNode ( head , ptr ) ; next = ptr -> next ; ptr = next ; } while ( ptr != head ) ; } void printList ( struct Node * head ) { struct Node * temp = head ; if ( head != NULL ) { do { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } while ( temp != head ) ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 61 ) ; push ( & head , 12 ) ; push ( & head , 56 ) ; push ( & head , 2 ) ; push ( & head , 11 ) ; push ( & head , 57 ) ; cout << " List after deletion : " ; deleteEvenNodes ( head ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int data ) { struct Node * ptr1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * temp = * head_ref ; ptr1 -> data = data ; ptr1 -> next = * head_ref ; if ( * head_ref != NULL ) { while ( temp -> next != * head_ref ) temp = temp -> next ; temp -> next = ptr1 ; } else ptr1 -> next = ptr1 ; * head_ref = ptr1 ; } int sumOfList ( struct Node * head ) { struct Node * temp = head ; int sum = 0 ; if ( head != NULL ) { do { temp = temp -> next ; sum += temp -> data ; } while ( temp != head ) ; } return sum ; } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 56 ) ; push ( & head , 2 ) ; push ( & head , 11 ) ; cout << " Sum ▁ of ▁ Circular ▁ linked ▁ list ▁ is ▁ = ▁ " << sumOfList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; Node ( int x ) { data = x ; next = NULL ; } } ; void printList ( Node * head ) { if ( head == NULL ) return ; Node * temp = head ; do { cout << temp -> data << " - > " ; temp = temp -> next ; } while ( temp != head ) ; cout << head -> data << endl ; } void deleteK ( Node * * head_ref , int k ) { Node * head = * head_ref ; if ( head == NULL ) return ; Node * curr = head , * prev ; while ( true ) { if ( curr -> next == head && curr == head ) break ; printList ( head ) ; for ( int i = 0 ; i < k ; i ++ ) { prev = curr ; curr = curr -> next ; } if ( curr == head ) { prev = head ; while ( prev -> next != head ) prev = prev -> next ; head = curr -> next ; prev -> next = head ; * head_ref = head ; free ( curr ) ; } else if ( curr -> next == head ) { prev -> next = head ; free ( curr ) ; } else { prev -> next = curr -> next ; free ( curr ) ; } } } void insertNode ( Node * * head_ref , int x ) { Node * head = * head_ref ; Node * temp = new Node ( x ) ; if ( head == NULL ) { temp -> next = temp ; * head_ref = temp ; } else { Node * temp1 = head ; while ( temp1 -> next != head ) temp1 = temp1 -> next ; temp1 -> next = temp ; temp -> next = head ; } } int main ( ) { struct Node * head = NULL ; insertNode ( & head , 1 ) ; insertNode ( & head , 2 ) ; insertNode ( & head , 3 ) ; insertNode ( & head , 4 ) ; insertNode ( & head , 5 ) ; insertNode ( & head , 6 ) ; insertNode ( & head , 7 ) ; insertNode ( & head , 8 ) ; insertNode ( & head , 9 ) ; int k = 4 ; deleteK ( & head , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * next ; struct node * prev ; } ; struct node * getNode ( ) { return ( ( struct node * ) malloc ( sizeof ( struct node ) ) ) ; } int displayList ( struct node * temp ) { struct node * t = temp ; if ( temp == NULL ) return 0 ; else { cout << " The ▁ list ▁ is : ▁ " ; while ( temp -> next != t ) { cout << temp -> data << " ▁ " ; temp = temp -> next ; } cout << temp -> data << endl ; return 1 ; } } int countList ( struct node * start ) { struct node * temp = start ; int count = 0 ; while ( temp -> next != start ) { temp = temp -> next ; count ++ ; } count ++ ; return count ; } bool insertAtLocation ( struct node * start , int data , int loc ) { struct node * temp , * newNode ; int i , count ; newNode = getNode ( ) ; temp = start ; count = countList ( start ) ; if ( temp == NULL count < loc ) return false ; else { newNode -> data = data ; for ( i = 1 ; i < loc - 1 ; i ++ ) { temp = temp -> next ; } newNode -> next = temp -> next ; ( temp -> next ) -> prev = newNode ; temp -> next = newNode ; newNode -> prev = temp ; return true ; } return false ; } void createList ( int arr [ ] , int n , struct node * * start ) { struct node * newNode , * temp ; int i ; for ( i = 0 ; i < n ; i ++ ) { newNode = getNode ( ) ; newNode -> data = arr [ i ] ; if ( i == 0 ) { * start = newNode ; newNode -> prev = * start ; newNode -> next = * start ; } else { temp = ( * start ) -> prev ; temp -> next = newNode ; newNode -> next = * start ; newNode -> prev = temp ; temp = * start ; temp -> prev = newNode ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; struct node * start = NULL ; createList ( arr , n , & start ) ; displayList ( start ) ; insertAtLocation ( start , 8 , 3 ) ; displayList ( start ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next , * prev ; } ; Node * getNode ( int data ) { Node * newNode = ( Node * ) malloc ( sizeof ( Node ) ) ; newNode -> data = data ; return newNode ; } void insertEnd ( Node * * head , Node * new_node ) { if ( * head == NULL ) { new_node -> next = new_node -> prev = new_node ; * head = new_node ; return ; } Node * last = ( * head ) -> prev ; new_node -> next = * head ; ( * head ) -> prev = new_node ; new_node -> prev = last ; last -> next = new_node ; } Node * reverse ( Node * head ) { if ( ! head ) return NULL ; Node * new_head = NULL ; Node * last = head -> prev ; Node * curr = last , * prev ; while ( curr -> prev != last ) { prev = curr -> prev ; insertEnd ( & new_head , curr ) ; curr = prev ; } insertEnd ( & new_head , curr ) ; return new_head ; } void display ( Node * head ) { if ( ! head ) return ; Node * temp = head ; cout << " Forward ▁ direction : ▁ " ; while ( temp -> next != head ) { cout << temp -> data << " ▁ " ; temp = temp -> next ; } cout << temp -> data ; Node * last = head -> prev ; temp = last ; cout << " Backward direction : " while ( temp -> prev != last ) { cout << temp -> data << " ▁ " ; temp = temp -> prev ; } cout << temp -> data ; } int main ( ) { Node * head = NULL ; insertEnd ( & head , getNode ( 1 ) ) ; insertEnd ( & head , getNode ( 2 ) ) ; insertEnd ( & head , getNode ( 3 ) ) ; insertEnd ( & head , getNode ( 4 ) ) ; insertEnd ( & head , getNode ( 5 ) ) ; cout << " Current ▁ list : STRNEWLINE " ; display ( head ) ; head = reverse ( head ) ; cout << " Reversed list : " display ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * next ; struct node * prev ; } ; struct node * getNode ( ) { return ( ( struct node * ) malloc ( sizeof ( struct node ) ) ) ; } int displayList ( struct node * temp ) { struct node * t = temp ; if ( temp == NULL ) return 0 ; else { cout << " The ▁ list ▁ is : ▁ " ; while ( temp -> next != t ) { cout << temp -> data << " ▁ " ; temp = temp -> next ; } cout << temp -> data ; return 1 ; } } void createList ( int arr [ ] , int n , struct node * * start ) { struct node * newNode , * temp ; int i ; for ( i = 0 ; i < n ; i ++ ) { newNode = getNode ( ) ; newNode -> data = arr [ i ] ; if ( i == 0 ) { * start = newNode ; newNode -> prev = * start ; newNode -> next = * start ; } else { temp = ( * start ) -> prev ; temp -> next = newNode ; newNode -> next = * start ; newNode -> prev = temp ; temp = * start ; temp -> prev = newNode ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; struct node * start = NULL ; createList ( arr , n , & start ) ; displayList ( start ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> next = NULL ; return node ; } int alivesol ( int Num ) { if ( Num == 1 ) return 1 ; Node * last = newNode ( 1 ) ; last -> next = last ; for ( int i = 2 ; i <= Num ; i ++ ) { Node * temp = newNode ( i ) ; temp -> next = last -> next ; last -> next = temp ; last = temp ; } Node * curr = last -> next ; Node * temp ; while ( curr -> next != curr ) { temp = curr ; curr = curr -> next ; temp -> next = curr -> next ; delete curr ; temp = temp -> next ; curr = temp ; } int res = temp -> data ; delete temp ; return res ; } int main ( ) { int N = 100 ; cout << alivesol ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left ; struct Node * right ; int data ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> left = temp -> right = NULL ; return temp ; } int finddepth ( Node * root ) { if ( ! root ) return 0 ; int left = finddepth ( root -> left ) ; int right = finddepth ( root -> right ) ; return 1 + max ( left , right ) ; } Node * dfs ( Node * root , int curr , int depth ) { if ( ! root ) return NULL ; if ( curr == depth ) return root ; Node * left = dfs ( root -> left , curr + 1 , depth ) ; Node * right = dfs ( root -> right , curr + 1 , depth ) ; if ( left != NULL && right != NULL ) return root ; return left ? left : right ; } Node * lcaOfDeepestLeaves ( Node * root ) { if ( ! root ) return NULL ; int depth = finddepth ( root ) - 1 ; return dfs ( root , 0 , depth ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> left = newNode ( 8 ) ; root -> right -> left -> right = newNode ( 9 ) ; cout << lcaOfDeepestLeaves ( root ) -> data ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int filter ( int x , int y , int z ) { if ( x != -1 && y != -1 ) { return z ; } return x == -1 ? y : x ; } int samePathUtil ( int mtrx [ ] [ 7 ] , int vrtx , int v1 , int v2 , int i ) { int ans = -1 ; if ( i == v1 i == v2 ) return i ; for ( int j = 0 ; j < vrtx ; j ++ ) { if ( mtrx [ i ] [ j ] == 1 ) { ans = filter ( ans , samePathUtil ( mtrx , vrtx , v1 , v2 , j ) , i ) ; } } return ans ; } bool isVertexAtSamePath ( int mtrx [ ] [ 7 ] , int vrtx , int v1 , int v2 , int i ) { int lca = samePathUtil ( mtrx , vrtx , v1 - 1 , v2 - 1 , i ) ; if ( lca == v1 - 1 lca == v2 - 1 ) return true ; return false ; } int main ( ) { int vrtx = 7 , edge = 6 ; int mtrx [ 7 ] [ 7 ] = { { 0 , 1 , 1 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 } } ; int v1 = 1 , v2 = 5 ; if ( isVertexAtSamePath ( mtrx , vrtx , v1 , v2 , 0 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE #define log  10  NEW_LINE int level [ MAX ] ; int lca [ MAX ] [ log ] ; int dist [ MAX ] [ log ] ; vector < pair < int , int > > graph [ MAX ] ; void addEdge ( int u , int v , int cost ) { graph [ u ] . push_back ( { v , cost } ) ; graph [ v ] . push_back ( { u , cost } ) ; } void dfs ( int node , int parent , int h , int cost ) { lca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != -1 ) { dist [ node ] [ 0 ] = cost ; } for ( int i = 1 ; i < log ; i ++ ) { if ( lca [ node ] [ i - 1 ] != -1 ) { lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; dist [ node ] [ i ] = dist [ node ] [ i - 1 ] + dist [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; } } for ( auto i : graph [ node ] ) { if ( i . first == parent ) continue ; dfs ( i . first , node , h + 1 , i . second ) ; } } void findDistance ( int u , int v ) { int ans = 0 ; if ( level [ u ] > level [ v ] ) swap ( u , v ) ; for ( int i = log - 1 ; i >= 0 ; i -- ) { if ( lca [ v ] [ i ] != -1 && level [ lca [ v ] [ i ] ] >= level [ u ] ) { ans += dist [ v ] [ i ] ; v = lca [ v ] [ i ] ; } } if ( v == u ) { cout << ans << endl ; } else { for ( int i = log - 1 ; i >= 0 ; i -- ) { if ( lca [ v ] [ i ] != lca [ u ] [ i ] ) { ans += dist [ u ] [ i ] + dist [ v ] [ i ] ; v = lca [ v ] [ i ] ; u = lca [ u ] [ i ] ; } } ans += dist [ u ] [ 0 ] + dist [ v ] [ 0 ] ; cout << ans << endl ; } } int main ( ) { int n = 5 ; addEdge ( 1 , 2 , 2 ) ; addEdge ( 1 , 3 , 3 ) ; addEdge ( 2 , 4 , 5 ) ; addEdge ( 2 , 5 , 7 ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < log ; j ++ ) { lca [ i ] [ j ] = -1 ; dist [ i ] [ j ] = 0 ; } } dfs ( 1 , -1 , 0 , 0 ) ; findDistance ( 1 , 3 ) ; findDistance ( 2 , 3 ) ; findDistance ( 3 , 5 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int T = 1 ; void dfs ( int node , int parent , vector < int > g [ ] , int level [ ] , int t_in [ ] , int t_out [ ] ) { if ( parent == -1 ) { level [ node ] = 1 ; } else { level [ node ] = level [ parent ] + 1 ; } t_in [ node ] = T ; for ( auto i : g [ node ] ) { if ( i != parent ) { T ++ ; dfs ( i , node , g , level , t_in , t_out ) ; } } T ++ ; t_out [ node ] = T ; } int findLCA ( int n , vector < int > g [ ] , vector < int > v ) { int level [ n + 1 ] ; int t_in [ n + 1 ] ; int t_out [ n + 1 ] ; dfs ( 1 , -1 , g , level , t_in , t_out ) ; int mint = INT_MAX , maxt = INT_MIN ; int minv = -1 , maxv = -1 ; for ( auto i = v . begin ( ) ; i != v . end ( ) ; i ++ ) { if ( t_in [ * i ] < mint ) { mint = t_in [ * i ] ; minv = * i ; } if ( t_out [ * i ] > maxt ) { maxt = t_out [ * i ] ; maxv = * i ; } } if ( minv == maxv ) { return minv ; } int lev = min ( level [ minv ] , level [ maxv ] ) ; int node , l = INT_MIN ; for ( int i = 1 ; i <= n ; i ++ ) { if ( level [ i ] > lev ) continue ; if ( t_in [ i ] <= mint && t_out [ i ] >= maxt && level [ i ] > l ) { node = i ; l = level [ i ] ; } } return node ; } int main ( ) { int n = 10 ; vector < int > g [ n + 1 ] ; g [ 1 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 3 ) ; g [ 3 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 4 ) ; g [ 4 ] . push_back ( 1 ) ; g [ 2 ] . push_back ( 5 ) ; g [ 5 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 6 ) ; g [ 6 ] . push_back ( 2 ) ; g [ 3 ] . push_back ( 7 ) ; g [ 7 ] . push_back ( 3 ) ; g [ 4 ] . push_back ( 10 ) ; g [ 10 ] . push_back ( 4 ) ; g [ 8 ] . push_back ( 7 ) ; g [ 7 ] . push_back ( 8 ) ; g [ 9 ] . push_back ( 7 ) ; g [ 7 ] . push_back ( 9 ) ; vector < int > v = { 7 , 3 , 8 } ; cout << findLCA ( n , g , v ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_SIZE = 100005 , MAX_CHAR = 26 ; int nodeCharactersCount [ MAX_SIZE ] [ MAX_CHAR ] ; vector < int > tree [ MAX_SIZE ] ; bool canFormPalindrome ( int * charArray ) { int oddCount = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( charArray [ i ] % 2 == 1 ) oddCount ++ ; } if ( oddCount >= 2 ) return false ; else return true ; } int LCA ( int currentNode , int x , int y ) { if ( currentNode == x ) return x ; if ( currentNode == y ) return y ; int xLca , yLca ; xLca = yLca = -1 ; int gotLca = -1 ; for ( int l = 0 ; l < tree [ currentNode ] . size ( ) ; l ++ ) { int nextNode = tree [ currentNode ] [ l ] ; int out_ = LCA ( nextNode , x , y ) ; if ( out_ == x ) xLca = out_ ; if ( out_ == y ) yLca = out_ ; if ( xLca != -1 and yLca != -1 ) return currentNode ; if ( out_ != -1 ) gotLca = out_ ; } return gotLca ; } void buildTree ( int i ) { for ( int l = 0 ; l < tree [ i ] . size ( ) ; l ++ ) { int nextNode = tree [ i ] [ l ] ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { nodeCharactersCount [ nextNode ] [ j ] += nodeCharactersCount [ i ] [ j ] ; } buildTree ( nextNode ) ; } } bool canFormPalindromicPath ( int x , int y ) { int lcaNode ; if ( x == y ) lcaNode = x ; else lcaNode = LCA ( 1 , x , y ) ; int charactersCountFromXtoY [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { charactersCountFromXtoY [ i ] = nodeCharactersCount [ x ] [ i ] + nodeCharactersCount [ y ] [ i ] - 2 * nodeCharactersCount [ lcaNode ] [ i ] ; } if ( canFormPalindrome ( charactersCountFromXtoY ) ) return true ; return false ; } void updateNodeCharactersCount ( string str , int v ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) nodeCharactersCount [ v ] [ str [ i ] - ' a ' ] ++ ; } void performQueries ( vector < vector < int > > queries , int q ) { int i = 0 ; while ( i < q ) { int x = queries [ i ] [ 0 ] ; int y = queries [ i ] [ 1 ] ; if ( canFormPalindromicPath ( x , y ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; i ++ ; } } int main ( ) { memset ( nodeCharactersCount , 0 , sizeof ( nodeCharactersCount ) ) ; tree [ 1 ] . push_back ( 2 ) ; updateNodeCharactersCount ( " bbc " , 2 ) ; tree [ 1 ] . push_back ( 3 ) ; updateNodeCharactersCount ( " ac " , 3 ) ; buildTree ( 1 ) ; vector < vector < int > > queries { { 1 , 2 } , { 2 , 3 } , { 3 , 1 } , { 3 , 3 } } ; int q = queries . size ( ) ; performQueries ( queries , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * node = new Node ; node -> data = data ; node -> left = NULL ; node -> right = NULL ; return node ; } bool getPath ( Node * root , vector < int > & arr , int x ) { if ( ! root ) return false ; arr . push_back ( root -> data ) ; if ( root -> data == x ) return true ; if ( getPath ( root -> left , arr , x ) || getPath ( root -> right , arr , x ) ) return true ; arr . pop_back ( ) ; return false ; } int sumOddNodes ( Node * root , int n1 , int n2 ) { vector < int > path1 ; vector < int > path2 ; getPath ( root , path1 , n1 ) ; getPath ( root , path2 , n2 ) ; int intersection = -1 ; int i = 0 , j = 0 ; while ( i != path1 . size ( ) || j != path2 . size ( ) ) { if ( i == j && path1 [ i ] == path2 [ j ] ) { i ++ ; j ++ ; } else { intersection = j - 1 ; break ; } } int sum = 0 ; for ( int i = path1 . size ( ) - 1 ; i > intersection ; i -- ) if ( path1 [ i ] % 2 ) sum += path1 [ i ] ; for ( int i = intersection ; i < path2 . size ( ) ; i ++ ) if ( path2 [ i ] % 2 ) sum += path2 [ i ] ; return sum ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; int node1 = 5 ; int node2 = 6 ; cout << sumOddNodes ( root , node1 , node2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100001 NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * temp = new struct Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int level [ MAX ] ; void FindLevels ( struct Node * root ) { if ( ! root ) return ; queue < pair < struct Node * , int > > q ; q . push ( { root , 0 } ) ; pair < struct Node * , int > p ; while ( ! q . empty ( ) ) { p = q . front ( ) ; q . pop ( ) ; level [ p . first -> data ] = p . second ; if ( p . first -> left ) q . push ( { p . first -> left , p . second + 1 } ) ; if ( p . first -> right ) q . push ( { p . first -> right , p . second + 1 } ) ; } } int Euler [ MAX ] ; int idx = 0 ; void eulerTree ( struct Node * root ) { Euler [ ++ idx ] = root -> data ; if ( root -> left ) { eulerTree ( root -> left ) ; Euler [ ++ idx ] = root -> data ; } if ( root -> right ) { eulerTree ( root -> right ) ; Euler [ ++ idx ] = root -> data ; } } int vis [ MAX ] ; int L [ MAX ] ; int H [ MAX ] ; void preprocessEuler ( int size ) { for ( int i = 1 ; i <= size ; i ++ ) { L [ i ] = level [ Euler [ i ] ] ; if ( vis [ Euler [ i ] ] == 0 ) { H [ Euler [ i ] ] = i ; vis [ Euler [ i ] ] = 1 ; } } } pair < int , int > seg [ 4 * MAX ] ; pair < int , int > min ( pair < int , int > a , pair < int , int > b ) { if ( a . first <= b . first ) return a ; else return b ; } pair < int , int > buildSegTree ( int low , int high , int pos ) { if ( low == high ) { seg [ pos ] . first = L [ low ] ; seg [ pos ] . second = low ; return seg [ pos ] ; } int mid = low + ( high - low ) / 2 ; buildSegTree ( low , mid , 2 * pos ) ; buildSegTree ( mid + 1 , high , 2 * pos + 1 ) ; seg [ pos ] = min ( seg [ 2 * pos ] , seg [ 2 * pos + 1 ] ) ; } pair < int , int > LCA ( int qlow , int qhigh , int low , int high , int pos ) { if ( qlow <= low && qhigh >= high ) return seg [ pos ] ; if ( qlow > high qhigh < low ) return { INT_MAX , 0 } ; int mid = low + ( high - low ) / 2 ; return min ( LCA ( qlow , qhigh , low , mid , 2 * pos ) , LCA ( qlow , qhigh , mid + 1 , high , 2 * pos + 1 ) ) ; } int findDistance ( int n1 , int n2 , int size ) { int prevn1 = n1 , prevn2 = n2 ; n1 = H [ n1 ] ; n2 = H [ n2 ] ; if ( n2 < n1 ) swap ( n1 , n2 ) ; int lca = LCA ( n1 , n2 , 1 , size , 1 ) . second ; lca = Euler [ lca ] ; return level [ prevn1 ] + level [ prevn2 ] - 2 * level [ lca ] ; } void preProcessing ( Node * root , int N ) { eulerTree ( root ) ; FindLevels ( root ) ; preprocessEuler ( 2 * N - 1 ) ; buildSegTree ( 1 , 2 * N - 1 , 1 ) ; } int main ( ) { int N = 8 ; Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 7 ) ; root -> right -> left -> right = newNode ( 8 ) ; preProcessing ( root , N ) ; cout << " Dist ( 4 , ▁ 5 ) ▁ = ▁ " << findDistance ( 4 , 5 , 2 * N - 1 ) << " STRNEWLINE " ; cout << " Dist ( 4 , ▁ 6 ) ▁ = ▁ " << findDistance ( 4 , 6 , 2 * N - 1 ) << " STRNEWLINE " ; cout << " Dist ( 3 , ▁ 4 ) ▁ = ▁ " << findDistance ( 3 , 4 , 2 * N - 1 ) << " STRNEWLINE " ; cout << " Dist ( 2 , ▁ 4 ) ▁ = ▁ " << findDistance ( 2 , 4 , 2 * N - 1 ) << " STRNEWLINE " ; cout << " Dist ( 8 , ▁ 5 ) ▁ = ▁ " << findDistance ( 8 , 5 , 2 * N - 1 ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  1001 NEW_LINE int depth [ MAXN ] ; int parent [ MAXN ] ; vector < int > adj [ MAXN ] ; void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void dfs ( int cur , int prev ) { parent [ cur ] = prev ; depth [ cur ] = depth [ prev ] + 1 ; for ( int i = 0 ; i < adj [ cur ] . size ( ) ; i ++ ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; } void preprocess ( ) { depth [ 0 ] = -1 ; dfs ( 1 , 0 ) ; } int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) swap ( u , v ) ; v = parent [ v ] ; return LCANaive ( u , v ) ; } int main ( int argc , char const * argv [ ] ) { addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; preprocess ( ) ; cout << " LCA ( 11,8 ) ▁ : ▁ " << LCANaive ( 11 , 8 ) << endl ; cout << " LCA ( 3,13 ) ▁ : ▁ " << LCANaive ( 3 , 13 ) << endl ; return 0 ; }
#include " iostream " NEW_LINE #include " vector " NEW_LINE #include " math . h " NEW_LINE using namespace std ; #define MAXN  1001 NEW_LINE int block_sz ; int depth [ MAXN ] ; int parent [ MAXN ] ; int jump_parent [ MAXN ] ; vector < int > adj [ MAXN ] ; void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } int LCANaive ( int u , int v ) { if ( u == v ) return u ; if ( depth [ u ] > depth [ v ] ) swap ( u , v ) ; v = parent [ v ] ; return LCANaive ( u , v ) ; } void dfs ( int cur , int prev ) { depth [ cur ] = depth [ prev ] + 1 ; parent [ cur ] = prev ; if ( depth [ cur ] % block_sz == 0 ) jump_parent [ cur ] = parent [ cur ] ; else jump_parent [ cur ] = jump_parent [ prev ] ; for ( int i = 0 ; i < adj [ cur ] . size ( ) ; ++ i ) if ( adj [ cur ] [ i ] != prev ) dfs ( adj [ cur ] [ i ] , cur ) ; } int LCASQRT ( int u , int v ) { while ( jump_parent [ u ] != jump_parent [ v ] ) { if ( depth [ u ] > depth [ v ] ) swap ( u , v ) ; v = jump_parent [ v ] ; } return LCANaive ( u , v ) ; } void preprocess ( int height ) { block_sz = sqrt ( height ) ; depth [ 0 ] = -1 ; dfs ( 1 , 0 ) ; } int main ( int argc , char const * argv [ ] ) { addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 4 , 8 ) ; addEdge ( 4 , 9 ) ; addEdge ( 9 , 10 ) ; addEdge ( 9 , 11 ) ; addEdge ( 7 , 12 ) ; addEdge ( 7 , 13 ) ; int height = 4 ; preprocess ( height ) ; cout << " LCA ( 11,8 ) ▁ : ▁ " << LCASQRT ( 11 , 8 ) << endl ; cout << " LCA ( 3,13 ) ▁ : ▁ " << LCASQRT ( 3 , 13 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  100000 NEW_LINE #define level  18 NEW_LINE vector < int > tree [ MAXN ] ; int depth [ MAXN ] ; int parent [ MAXN ] [ level ] ; void dfs ( int cur , int prev ) { depth [ cur ] = depth [ prev ] + 1 ; parent [ cur ] [ 0 ] = prev ; for ( int i = 0 ; i < tree [ cur ] . size ( ) ; i ++ ) { if ( tree [ cur ] [ i ] != prev ) dfs ( tree [ cur ] [ i ] , cur ) ; } } void precomputeSparseMatrix ( int n ) { for ( int i = 1 ; i < level ; i ++ ) { for ( int node = 1 ; node <= n ; node ++ ) { if ( parent [ node ] [ i - 1 ] != -1 ) parent [ node ] [ i ] = parent [ parent [ node ] [ i - 1 ] ] [ i - 1 ] ; } } } int lca ( int u , int v ) { if ( depth [ v ] < depth [ u ] ) swap ( u , v ) ; int diff = depth [ v ] - depth [ u ] ; for ( int i = 0 ; i < level ; i ++ ) if ( ( diff >> i ) & 1 ) v = parent [ v ] [ i ] ; if ( u == v ) return u ; for ( int i = level - 1 ; i >= 0 ; i -- ) if ( parent [ u ] [ i ] != parent [ v ] [ i ] ) { u = parent [ u ] [ i ] ; v = parent [ v ] [ i ] ; } return parent [ u ] [ 0 ] ; } void addEdge ( int u , int v ) { tree [ u ] . push_back ( v ) ; tree [ v ] . push_back ( u ) ; } int main ( ) { memset ( parent , -1 , sizeof ( parent ) ) ; int n = 8 ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 3 , 8 ) ; depth [ 0 ] = 0 ; dfs ( 1 , 0 ) ; precomputeSparseMatrix ( n ) ; cout << " LCA ( 4 , ▁ 7 ) ▁ = ▁ " << lca ( 4 , 7 ) << endl ; cout << " LCA ( 4 , ▁ 6 ) ▁ = ▁ " << lca ( 4 , 6 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Query { int L , R ; } ; int LCE ( string str , int n , int L , int R ) { int length = 0 ; while ( str [ L + length ] == str [ R + length ] && R + length < n ) length ++ ; return ( length ) ; } void LCEQueries ( string str , int n , Query q [ ] , int m ) { for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] . L ; int R = q [ i ] . R ; printf ( " LCE ▁ ( % d , ▁ % d ) ▁ = ▁ % d STRNEWLINE " , L , R , LCE ( str , n , L , R ) ) ; } return ; } int main ( ) { string str = " abbababba " ; int n = str . length ( ) ; Query q [ ] = { { 1 , 2 } , { 1 , 6 } , { 0 , 5 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; LCEQueries ( str , n , q , m ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE #define V  5	 NEW_LINE #define WHITE  1	 NEW_LINE #define BLACK  2  NEW_LINE struct Node { int data ; Node * left , * right ; } ; struct subset { int parent , rank , ancestor , child , sibling , color ; } ; struct Query { int L , R ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void makeSet ( struct subset subsets [ ] , int i ) { if ( i < 1 i > V ) return ; subsets [ i ] . color = WHITE ; subsets [ i ] . parent = i ; subsets [ i ] . rank = 0 ; return ; } int findSet ( struct subset subsets [ ] , int i ) { if ( subsets [ i ] . parent != i ) subsets [ i ] . parent = findSet ( subsets , subsets [ i ] . parent ) ; return subsets [ i ] . parent ; } void unionSet ( struct subset subsets [ ] , int x , int y ) { int xroot = findSet ( subsets , x ) ; int yroot = findSet ( subsets , y ) ; if ( subsets [ xroot ] . rank < subsets [ yroot ] . rank ) subsets [ xroot ] . parent = yroot ; else if ( subsets [ xroot ] . rank > subsets [ yroot ] . rank ) subsets [ yroot ] . parent = xroot ; else { subsets [ yroot ] . parent = xroot ; ( subsets [ xroot ] . rank ) ++ ; } } void lcaWalk ( int u , struct Query q [ ] , int m , struct subset subsets [ ] ) { makeSet ( subsets , u ) ; subsets [ findSet ( subsets , u ) ] . ancestor = u ; int child = subsets [ u ] . child ; while ( child != 0 ) { lcaWalk ( child , q , m , subsets ) ; unionSet ( subsets , u , child ) ; subsets [ findSet ( subsets , u ) ] . ancestor = u ; child = subsets [ child ] . sibling ; } subsets [ u ] . color = BLACK ; for ( int i = 0 ; i < m ; i ++ ) { if ( q [ i ] . L == u ) { if ( subsets [ q [ i ] . R ] . color == BLACK ) { printf ( " LCA ( % d ▁ % d ) ▁ - > ▁ % d STRNEWLINE " , q [ i ] . L , q [ i ] . R , subsets [ findSet ( subsets , q [ i ] . R ) ] . ancestor ) ; } } else if ( q [ i ] . R == u ) { if ( subsets [ q [ i ] . L ] . color == BLACK ) { printf ( " LCA ( % d ▁ % d ) ▁ - > ▁ % d STRNEWLINE " , q [ i ] . L , q [ i ] . R , subsets [ findSet ( subsets , q [ i ] . L ) ] . ancestor ) ; } } } return ; } void preprocess ( Node * node , struct subset subsets [ ] ) { if ( node == NULL ) return ; preprocess ( node -> left , subsets ) ; if ( node -> left != NULL && node -> right != NULL ) { subsets [ node -> data ] . child = node -> left -> data ; subsets [ node -> left -> data ] . sibling = node -> right -> data ; } else if ( ( node -> left != NULL && node -> right == NULL ) || ( node -> left == NULL && node -> right != NULL ) ) { if ( node -> left != NULL && node -> right == NULL ) subsets [ node -> data ] . child = node -> left -> data ; else subsets [ node -> data ] . child = node -> right -> data ; } preprocess ( node -> right , subsets ) ; } void initialise ( struct subset subsets [ ] ) { memset ( subsets , 0 , ( V + 1 ) * sizeof ( struct subset ) ) ; for ( int i = 1 ; i <= V ; i ++ ) subsets [ i ] . color = WHITE ; return ; } void printLCAs ( Node * root , Query q [ ] , int m ) { struct subset * subsets = new subset [ V + 1 ] ; initialise ( subsets ) ; preprocess ( root , subsets ) ; lcaWalk ( root -> data , q , m , subsets ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; Query q [ ] = { { 5 , 4 } , { 1 , 3 } , { 2 , 3 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; printLCAs ( root , q , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1024 NEW_LINE int tree [ N ] [ N ] ; struct treeNode { int par ; int depth ; int size ; int pos_segbase ; int chain ; } node [ N ] ; struct Edge { int weight ; int deeper_end ; } edge [ N ] ; struct segmentTree { int base_array [ N ] , tree [ 6 * N ] ; } s ; void addEdge ( int e , int u , int v , int w ) { tree [ u - 1 ] [ v - 1 ] = e - 1 ; tree [ v - 1 ] [ u - 1 ] = e - 1 ; edge [ e - 1 ] . weight = w ; } void dfs ( int curr , int prev , int dep , int n ) { node [ curr ] . par = prev ; node [ curr ] . depth = dep ; node [ curr ] . size = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != curr && j != node [ curr ] . par && tree [ curr ] [ j ] != -1 ) { edge [ tree [ curr ] [ j ] ] . deeper_end = j ; dfs ( j , curr , dep + 1 , n ) ; node [ curr ] . size += node [ j ] . size ; } } } void hld ( int curr_node , int id , int * edge_counted , int * curr_chain , int n , int chain_heads [ ] ) { if ( chain_heads [ * curr_chain ] == -1 ) chain_heads [ * curr_chain ] = curr_node ; node [ curr_node ] . chain = * curr_chain ; node [ curr_node ] . pos_segbase = * edge_counted ; s . base_array [ ( * edge_counted ) ++ ] = edge [ id ] . weight ; int spcl_chld = -1 , spcl_edg_id ; for ( int j = 0 ; j < n ; j ++ ) if ( j != curr_node && j != node [ curr_node ] . par && tree [ curr_node ] [ j ] != -1 ) if ( spcl_chld == -1 node [ spcl_chld ] . size < node [ j ] . size ) spcl_chld = j , spcl_edg_id = tree [ curr_node ] [ j ] ; if ( spcl_chld != -1 ) hld ( spcl_chld , spcl_edg_id , edge_counted , curr_chain , n , chain_heads ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != curr_node && j != node [ curr_node ] . par && j != spcl_chld && tree [ curr_node ] [ j ] != -1 ) { ( * curr_chain ) ++ ; hld ( j , tree [ curr_node ] [ j ] , edge_counted , curr_chain , n , chain_heads ) ; } } } int construct_ST ( int ss , int se , int si ) { if ( ss == se - 1 ) { s . tree [ si ] = s . base_array [ ss ] ; return s . base_array [ ss ] ; } int mid = ( ss + se ) / 2 ; s . tree [ si ] = max ( construct_ST ( ss , mid , si * 2 ) , construct_ST ( mid , se , si * 2 + 1 ) ) ; return s . tree [ si ] ; } int update_ST ( int ss , int se , int si , int x , int val ) { if ( ss > x se <= x ) ; else if ( ss == x && ss == se - 1 ) s . tree [ si ] = val ; else { int mid = ( ss + se ) / 2 ; s . tree [ si ] = max ( update_ST ( ss , mid , si * 2 , x , val ) , update_ST ( mid , se , si * 2 + 1 , x , val ) ) ; } return s . tree [ si ] ; } void change ( int e , int val , int n ) { update_ST ( 0 , n , 1 , node [ edge [ e ] . deeper_end ] . pos_segbase , val ) ; } int LCA ( int u , int v , int n ) { int LCA_aux [ n + 5 ] ; if ( node [ u ] . depth < node [ v ] . depth ) swap ( u , v ) ; memset ( LCA_aux , -1 , sizeof ( LCA_aux ) ) ; while ( u != -1 ) { LCA_aux [ u ] = 1 ; u = node [ u ] . par ; } while ( v ) { if ( LCA_aux [ v ] == 1 ) break ; v = node [ v ] . par ; } return v ; } int RMQUtil ( int ss , int se , int qs , int qe , int index ) { if ( qs <= ss && qe >= se - 1 ) return s . tree [ index ] ; if ( se - 1 < qs ss > qe ) return -1 ; int mid = ( ss + se ) / 2 ; return max ( RMQUtil ( ss , mid , qs , qe , 2 * index ) , RMQUtil ( mid , se , qs , qe , 2 * index + 1 ) ) ; } int RMQ ( int qs , int qe , int n ) { if ( qs < 0 qe > n -1 qs > qe ) { printf ( " Invalid ▁ Input " ) ; return - 1 ; } return RMQUtil ( 0 , n , qs , qe , 1 ) ; } int crawl_tree ( int u , int v , int n , int chain_heads [ ] ) { int chain_u , chain_v = node [ v ] . chain , ans = 0 ; while ( true ) { chain_u = node [ u ] . chain ; if ( chain_u == chain_v ) { if ( u == v ) ; else ans = max ( RMQ ( node [ v ] . pos_segbase + 1 , node [ u ] . pos_segbase , n ) , ans ) ; break ; } else { ans = max ( ans , RMQ ( node [ chain_heads [ chain_u ] ] . pos_segbase , node [ u ] . pos_segbase , n ) ) ; u = node [ chain_heads [ chain_u ] ] . par ; } } return ans ; } void maxEdge ( int u , int v , int n , int chain_heads [ ] ) { int lca = LCA ( u , v , n ) ; int ans = max ( crawl_tree ( u , lca , n , chain_heads ) , crawl_tree ( v , lca , n , chain_heads ) ) ; printf ( " % d STRNEWLINE " , ans ) ; } int main ( ) { memset ( tree , -1 , sizeof ( tree ) ) ; int n = 11 ; addEdge ( 1 , 1 , 2 , 13 ) ; addEdge ( 2 , 1 , 3 , 9 ) ; addEdge ( 3 , 1 , 4 , 23 ) ; addEdge ( 4 , 2 , 5 , 4 ) ; addEdge ( 5 , 2 , 6 , 25 ) ; addEdge ( 6 , 3 , 7 , 29 ) ; addEdge ( 7 , 6 , 8 , 5 ) ; addEdge ( 8 , 7 , 9 , 30 ) ; addEdge ( 9 , 8 , 10 , 1 ) ; addEdge ( 10 , 8 , 11 , 6 ) ; int root = 0 , parent_of_root = -1 , depth_of_root = 0 ; dfs ( root , parent_of_root , depth_of_root , n ) ; int chain_heads [ N ] ; memset ( chain_heads , -1 , sizeof ( chain_heads ) ) ; int edge_counted = 0 ; int curr_chain = 0 ; hld ( root , n - 1 , & edge_counted , & curr_chain , n , chain_heads ) ; construct_ST ( 0 , edge_counted , 1 ) ; int u = 11 , v = 9 ; cout << " Max ▁ edge ▁ between ▁ " << u << " ▁ and ▁ " << v << " ▁ is ▁ " ; maxEdge ( u - 1 , v - 1 , n , chain_heads ) ; change ( 8 - 1 , 28 , n ) ; cout << " After ▁ Change : ▁ max ▁ edge ▁ between ▁ " << u << " ▁ and ▁ " << v << " ▁ is ▁ " ; maxEdge ( u - 1 , v - 1 , n , chain_heads ) ; v = 4 ; cout << " Max ▁ edge ▁ between ▁ " << u << " ▁ and ▁ " << v << " ▁ is ▁ " ; maxEdge ( u - 1 , v - 1 , n , chain_heads ) ; change ( 5 - 1 , 22 , n ) ; cout << " After ▁ Change : ▁ max ▁ edge ▁ between ▁ " << u << " ▁ and ▁ " << v << " ▁ is ▁ " ; maxEdge ( u - 1 , v - 1 , n , chain_heads ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPair ( int a [ ] , int n , int z ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( i != j && a [ i ] + a [ j ] == z ) return true ; return false ; } int main ( ) { int a [ ] = { 1 , -2 , 1 , 0 , 5 } ; int z = 0 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( findPair ( a , n , z ) ) cout << " True " ; else cout << " False " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int print ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j ) cout << a [ i ] << " ▁ " << a [ j ] << " STRNEWLINE " ; } } } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; print ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSum ( int arr [ ] , int N ) { int Sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) Sum += ( arr [ i ] - arr [ i - 1 ] ) ; } return Sum ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 } ; int N = ( sizeof ( arr ) / ( sizeof ( arr [ 0 ] ) ) ) ; cout << maximumSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int a = 0 , b = 0 ; int N = 4 , M = 4 ; for ( int i = 0 ; i < N ; i ++ ) { a = a + 10 ; } for ( int i = 0 ; i < M ; i ++ ) { b = b + 40 ; } cout << a << ' ▁ ' << b ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void stoogesort ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; if ( arr [ l ] > arr [ h ] ) swap ( arr [ l ] , arr [ h ] ) ; if ( h - l + 1 > 2 ) { int t = ( h - l + 1 ) / 3 ; stoogesort ( arr , l , h - t ) ; stoogesort ( arr , l + t , h ) ; stoogesort ( arr , l , h - t ) ; } } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; stoogesort ( arr , 0 , N - 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " ▁ " ; } return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int Fibonacci ( int N ) { if ( N < 2 ) return N ; return Fibonacci ( N - 1 ) + Fibonacci ( N - 2 ) ; } int main ( ) { int N = 5 ; cout << Fibonacci ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void findWinner ( int n , int m ) { int X = 0 ; int Y = 0 ; if ( n >= m ) { X = n - 1 ; Y = m ; } else { X = m - 1 ; Y = n ; } if ( X > Y ) cout << " X " ; else if ( Y > X ) cout << " Y " ; else cout << " - 1" ; } int main ( ) { int n = 3 , m = 1 ; findWinner ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkPascaltriangle ( int N ) { double x = ( sqrt ( 8 * N + 1 ) - 1 ) / 2 ; if ( ceil ( x ) - x == 0 ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int N = 10 ; checkPascaltriangle ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( ( j - i ) % 2 == 0 ) sum += arr [ j ] ; else sum -= arr [ j ] ; if ( sum == 0 ) count ++ ; } } cout << " ▁ " << count ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarrays ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCountRooks ( int row [ ] , int col [ ] , int n , int k ) { int res = n - k ; cout << res << " STRNEWLINE " ; int ri = 0 , ci = 0 ; while ( res -- > 0 ) { while ( ri < k && row [ ri ] == 1 ) { ri ++ ; } while ( ci < k && col [ ci ] == 1 ) { ci ++ ; } cout << ( ri + 1 ) << " ▁ " << ( ci + 1 ) << " STRNEWLINE " ; ri ++ ; ci ++ ; } } int main ( ) { int n = 4 ; int k = 2 ; int row [ ] = { 1 , 2 } ; int col [ ] = { 4 , 2 } ; findCountRooks ( row , col , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check_order ( vector < int > arr ) { int cnt = 0 ; for ( int i = 0 ; i < arr . size ( ) - 1 ; i ++ ) { if ( abs ( arr [ i + 1 ] - arr [ i ] ) > 1 ) cnt ++ ; } if ( abs ( arr [ 0 ] - arr [ arr . size ( ) - 1 ] ) > 1 ) cnt ++ ; if ( cnt > 1 ) return false ; return true ; } int main ( ) { vector < int > arr = { 2 , 3 , 4 , 5 , 1 } ; if ( check_order ( arr ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getM ( int n ) { if ( n == 1 ) return -1 ; else return n - 2 ; } int main ( ) { int n = 10 ; int ans = getM ( n ) ; cout << ans ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProfit ( int prices [ ] , int n ) { if ( n <= 1 ) return 0 ; int rest [ n ] = { 0 } ; int hold [ n ] = { 0 } ; int sold [ n ] = { 0 } ; rest [ 0 ] = 0 ; hold [ 0 ] = - prices [ 0 ] ; sold [ 0 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { rest [ i ] = max ( rest [ i - 1 ] , sold [ i - 1 ] ) ; hold [ i ] = max ( hold [ i - 1 ] , rest [ i - 1 ] - prices [ i ] ) ; sold [ i ] = hold [ i - 1 ] + prices [ i ] ; } return max ( rest [ n - 1 ] , sold [ n - 1 ] ) ; } int main ( ) { int price [ ] = { 2 , 4 , 5 , 0 , 2 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; cout << maxProfit ( price , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubarrays ( int arr [ ] , int N , int K ) { return N - K + 1 ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 2 , 17 , 18 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSubarrays ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial [ ] = { 1 , 1 , 2 , 6 , 24 , 120 , 720 , 5040 , 40320 , 362880 } ; bool isStrong ( int N ) { string num = to_string ( N ) ; int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { sum += factorial [ num [ i ] - '0' ] ; } return sum == N ; } void printStrongNumbers ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( isStrong ( i ) ) { cout << i << " ▁ " ; } } } int main ( ) { int N = 1000 ; printStrongNumbers ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int A , int B ) { int countY = 0 , countX = ( B - A ) + 1 , next_val = 9 ; while ( next_val <= B ) { if ( next_val >= A ) { countY += 1 ; } next_val = next_val * 10 + 9 ; } return ( countX * countY ) ; } int main ( ) { int A = 1 ; int B = 16 ; cout << countPairs ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getXOR ( int BITree [ ] , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans ^= BITree [ index ] ; index -= index & ( - index ) ; } return ans ; } void updateBIT ( int BITree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] ^= val ; index += index & ( - index ) ; } } int * constructBITree ( int arr [ ] , int n ) { int * BITree = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BITree [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) updateBIT ( BITree , n , i , arr [ i ] ) ; return BITree ; } int rangeXor ( int BITree [ ] , int l , int r ) { return getXOR ( BITree , r ) ^ getXOR ( BITree , l - 1 ) ; } int main ( ) { int A [ ] = { 2 , 1 , 1 , 3 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; vector < vector < int > > q = { { 1 , 0 , 9 } , { 2 , 3 , 6 } , { 2 , 5 , 5 } , { 2 , 8 , 1 } , { 1 , 0 , 9 } } ; int * BITree = constructBITree ( A , n ) ; for ( int i = 0 ; i < q . size ( ) ; i ++ ) { int id = q [ i ] [ 0 ] ; if ( id == 1 ) { int L = q [ i ] [ 1 ] ; int R = q [ i ] [ 2 ] ; cout << " XOR ▁ of ▁ elements ▁ " << " in ▁ given ▁ range ▁ is ▁ " << rangeXor ( BITree , L , R ) << " STRNEWLINE " ; } else { int idx = q [ i ] [ 1 ] ; int val = q [ i ] [ 2 ] ; A [ idx ] ^= val ; updateBIT ( BITree , n , idx , val ) ; } } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; int prefix [ MAX + 1 ] ; bool isPowerOfTwo ( int x ) { if ( x && ( ! ( x & ( x - 1 ) ) ) ) return true ; return false ; } void computePrefix ( int n , int a [ ] ) { if ( isPowerOfTwo ( a [ 0 ] ) ) prefix [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] ; if ( isPowerOfTwo ( a [ i ] ) ) prefix [ i ] ++ ; } } int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; } int main ( ) { int A [ ] = { 3 , 8 , 5 , 2 , 5 , 10 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int Q = 2 ; computePrefix ( N , A ) ; cout << query ( 0 , 4 ) << " STRNEWLINE " ; cout << query ( 3 , 5 ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int arr [ 1000001 ] ; int dp [ 1000001 ] ; void count ( ) { int maxN = 1000000 , i , j ; for ( i = 0 ; i < maxN ; i ++ ) arr [ i ] = 1 ; arr [ 0 ] = 0 ; arr [ 1 ] = 0 ; for ( i = 2 ; i * i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { for ( j = 2 * i ; j <= maxN ; j += i ) { arr [ j ] = 0 ; } } } int cnt = 0 ; for ( i = 0 ; i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) cnt ++ ; if ( arr [ cnt ] == 1 ) dp [ i ] = 1 ; else dp [ i ] = 0 ; } for ( i = 1 ; i <= maxN ; i ++ ) dp [ i ] += dp [ i - 1 ] ; } int main ( ) { int L = 4 , R = 12 ; count ( ) ; cout << dp [ R ] - dp [ L - 1 ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findUngroupedElement ( string s , int k ) { int n = s . length ( ) ; int b [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) b [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char p = s . at ( i ) ; b [ p - ' a ' ] += 1 ; } int sum = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( b [ i ] > k ) sum += b [ i ] - k ; } cout << sum << endl ; } int main ( ) { string s = " stayinghomesaveslife " ; int k = 1 ; findUngroupedElement ( s , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSolution ( int N ) { if ( N % 4 != 0 ) cout << -1 << " STRNEWLINE " ; else { int temp = 0 , sum_odd = 0 , sum_even = 0 ; int result [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i += 2 ) { temp += 2 ; result [ i + 1 ] = temp ; sum_even += result [ i + 1 ] ; result [ i ] = temp - 1 ; sum_odd += result [ i ] ; } int diff = sum_even - sum_odd ; result [ N - 2 ] += diff ; for ( int i = 0 ; i < N ; i ++ ) cout << result [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } } int main ( ) { int N = 8 ; findSolution ( N ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int main ( ) { int N = 3 ; cout << pow ( 2 , N + 1 ) - 2 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; ll possiblePositions ( ll n ) { ll term1 = pow ( n , 4 ) ; ll term2 = pow ( n , 3 ) ; ll term3 = pow ( n , 2 ) ; ll term4 = n / 3 ; ll ans = ( ceil ) ( term1 ) / 2 - ( ceil ) ( 5 * term2 ) / 3 + ( ceil ) ( 3 * term3 ) / 2 - term4 ; return ans ; } int main ( ) { ll n ; n = 3 ; ll ans = possiblePositions ( n ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mutually_coprime ( int n ) { if ( n <= 3 ) { for ( int j = 1 ; j <= n ; j ++ ) { cout << j << " ▁ " ; } cout << " STRNEWLINE " ; } else { cout << "1 ▁ 2 ▁ 3 STRNEWLINE " ; for ( int j = 4 ; j < n ; j += 2 ) { cout << j << " ▁ " << j + 1 << " STRNEWLINE " ; } if ( n % 2 == 0 ) cout << n << " STRNEWLINE " ; } } int main ( ) { int n = 9 ; mutually_coprime ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSum ( int * arr , int n ) { vector < int > a ; vector < int > b ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { a . push_back ( arr [ i ] ) ; } else if ( arr [ i ] < 0 ) { b . push_back ( arr [ i ] ) ; } } sort ( a . begin ( ) , a . end ( ) ) ; sort ( b . begin ( ) , b . end ( ) ) ; int p = a . size ( ) - 1 ; int q = b . size ( ) - 1 ; int s = 0 ; while ( p >= 0 && q >= 0 ) { if ( a [ p ] + b [ q ] > 0 ) { s = s + a [ p ] + b [ q ] ; } else { break ; } p = p - 1 ; q = q - 1 ; } return s ; } int main ( ) { int arr1 [ ] = { 1 , -2 , 3 , 4 , -5 , 8 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << findMaxSum ( arr1 , n1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } void PrimeDegreeNodes ( int prufer [ ] , int n ) { int nodes = n + 2 ; bool prime [ nodes + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , nodes + 1 ) ; int degree [ n + 2 + 1 ] ; for ( int i = 1 ; i <= nodes ; i ++ ) degree [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) degree [ prufer [ i ] ] ++ ; for ( int i = 1 ; i <= nodes ; i ++ ) { if ( prime [ degree [ i ] ] ) { cout << i << " ▁ " ; } } } int main ( ) { int a [ ] = { 4 , 1 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; PrimeDegreeNodes ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char ShortestPalindrome ( string s ) { int n = s . length ( ) ; char ans = s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = min ( ans , s [ i ] ) ; } return ans ; } int main ( ) { string s = " geeksforgeeks " ; cout << ShortestPalindrome ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubsequence ( int arr [ ] , int n ) { int sign [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) sign [ i ] = 1 ; else sign [ i ] = -1 ; } int k = 0 ; int result [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int cur = arr [ i ] ; int j = i ; while ( j < n && sign [ i ] == sign [ j ] ) { cur = max ( cur , arr [ j ] ) ; ++ j ; } result [ k ++ ] = cur ; i = j - 1 ; } for ( int i = 0 ; i < k ; i ++ ) cout << result [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { -4 , 9 , 4 , 11 , -5 , -17 , 9 , -3 , -5 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubsequence ( arr , n ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE #include <set> NEW_LINE #define ll  long long NEW_LINE using namespace std ; ll int countOfNum ( ll int n , ll int a , ll int b ) { ll int cnt_of_a , cnt_of_b , cnt_of_ab , sum ; cnt_of_a = n / a ; cnt_of_b = n / b ; sum = cnt_of_b + cnt_of_a ; cnt_of_ab = n / ( a * b ) ; sum = sum - cnt_of_ab ; return sum ; } ll int sumOfNum ( ll int n , ll int a , ll int b ) { ll int i ; ll int sum = 0 ; set < ll int > ans ; for ( i = a ; i <= n ; i = i + a ) { ans . insert ( i ) ; } for ( i = b ; i <= n ; i = i + b ) { ans . insert ( i ) ; } for ( auto it = ans . begin ( ) ; it != ans . end ( ) ; it ++ ) { sum = sum + * it ; } return sum ; } int main ( ) { ll int N = 88 ; ll int A = 11 ; ll int B = 8 ; ll int count = countOfNum ( N , A , B ) ; ll int sumofnum = sumOfNum ( N , A , B ) ; cout << sumofnum % count << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string r ) { string p = r ; reverse ( p . begin ( ) , p . end ( ) ) ; return ( r == p ) ; } string PrefixSuffixPalindrome ( string str ) { int n = str . size ( ) , len = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( str [ i ] != str [ n - i - 1 ] ) { len = i ; break ; } } string prefix = " " , suffix = " " ; string midPal = " " ; prefix = str . substr ( 0 , len ) ; suffix = str . substr ( n - len ) ; str = str . substr ( len , n - 2 * len ) ; for ( int i = 1 ; i <= str . size ( ) ; i ++ ) { string y = str . substr ( 0 , i ) ; if ( isPalindrome ( y ) ) { if ( midPal . size ( ) < y . size ( ) ) { midPal = y ; } } } for ( int i = 1 ; i <= str . size ( ) ; i ++ ) { string y = str . substr ( str . size ( ) - i ) ; if ( isPalindrome ( y ) ) { if ( midPal . size ( ) < y . size ( ) ) { midPal = y ; } } } string answer = prefix + midPal + suffix ; return answer ; } int main ( ) { string str = " abcdfdcecba " ; cout << PrefixSuffixPalindrome ( str ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumAdjacentDifference ( vector < int > a , int n , int k ) { int minDiff = INT_MAX ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int cnt = __builtin_popcount ( i ) ; if ( cnt == n - k ) { vector < int > temp ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) temp . push_back ( a [ j ] ) ; } int maxDiff = INT_MIN ; for ( int j = 0 ; j < temp . size ( ) - 1 ; j ++ ) { maxDiff = max ( maxDiff , temp [ j + 1 ] - temp [ j ] ) ; } minDiff = min ( minDiff , maxDiff ) ; } } return minDiff ; } int main ( ) { int n = 5 ; int k = 2 ; vector < int > a = { 3 , 7 , 8 , 10 , 14 } ; cout << minimumAdjacentDifference ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumAdjacentDifference ( vector < int > a , int n , int k ) { int minDiff = INT_MAX ; for ( int i = 0 ; i <= k ; i ++ ) { int maxDiff = INT_MIN ; for ( int j = 0 ; j < n - k - 1 ; j ++ ) { for ( int p = i ; p <= i + j ; p ++ ) { maxDiff = max ( maxDiff , a [ p + 1 ] - a [ p ] ) ; } } minDiff = min ( minDiff , maxDiff ) ; } return minDiff ; } int main ( ) { int n = 5 ; int k = 2 ; vector < int > a = { 3 , 7 , 8 , 10 , 14 } ; cout << minimumAdjacentDifference ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findKMin ( vector < int > arr , int n , int k ) { deque < int > Qi ( k ) ; int i ; for ( i = 0 ; i < k ; ++ i ) { while ( ( ! Qi . empty ( ) ) && arr [ i ] >= arr [ Qi . back ( ) ] ) Qi . push_back ( i ) ; } int minDiff = INT_MAX ; for ( ; i < n ; ++ i ) { minDiff = min ( minDiff , arr [ Qi . front ( ) ] ) ; while ( ( ! Qi . empty ( ) ) && Qi . front ( ) <= i - k ) Qi . pop_front ( ) ; while ( ( ! Qi . empty ( ) ) && arr [ i ] >= arr [ Qi . back ( ) ] ) Qi . pop_back ( ) ; Qi . push_back ( i ) ; } minDiff = min ( minDiff , arr [ Qi . front ( ) ] ) ; return minDiff ; } int minimumAdjacentDifference ( vector < int > a , int n , int k ) { vector < int > diff ( n - 1 ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff [ i ] = a [ i + 1 ] - a [ i ] ; } int answer = findKMin ( diff , n - 1 , n - k - 1 ) ; return answer ; } int main ( ) { int n = 5 ; int k = 2 ; vector < int > a = { 3 , 7 , 8 , 10 , 14 } ; cout << minimumAdjacentDifference ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcdFunc ( int a , int b ) { if ( b == 0 ) return a ; return gcdFunc ( b , a % b ) ; } int findMinimumElements ( int * a , int n ) { int b [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) { b [ i - 1 ] = a [ i ] - a [ i - 1 ] ; } int gcd = b [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { gcd = gcdFunc ( gcd , b [ i ] ) ; } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += ( b [ i ] / gcd ) - 1 ; } return ans ; } int main ( ) { int arr1 [ ] = { 1 , 6 , 8 , 10 , 14 , 16 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << findMinimumElements ( arr1 , n1 ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriplets ( int x ) { vector < int > fact ; unordered_set < int > factors ; for ( int i = 2 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . push_back ( i ) ; if ( x / i != i ) fact . push_back ( x / i ) ; factors . insert ( i ) ; factors . insert ( x / i ) ; } } bool found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact [ i ] ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact [ j ] ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { cout << a << " ▁ " << b << " ▁ " << ( x / ( a * b ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) cout << " - 1" ; } int main ( ) { int x = 105 ; findTriplets ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPair ( int a , int b ) { string s = to_string ( b ) ; int i ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != '9' ) break ; } int result ; if ( i == s . length ( ) ) result = a * s . length ( ) ; else result = a * ( s . length ( ) - 1 ) ; return result ; } int main ( ) { int a = 5 , b = 101 ; cout << countPair ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > makeSeq ( string s , int a [ ] ) { vector < int > seq ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) if ( s [ i ] == ' A ' ) seq . push_back ( a [ i ] ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) if ( s [ i ] == ' B ' ) seq . push_back ( a [ i ] ) ; return seq ; } bool checkSeq ( vector < int > v ) { bool check = true ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) if ( v [ i ] < v [ i - 1 ] ) check = false ; return check ; } string digitPartition ( int X ) { string num = to_string ( X ) ; int l = num . size ( ) ; int a [ l ] ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = ( num [ i ] - '0' ) ; for ( int D = 0 ; D < 10 ; D ++ ) { string res = " " ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] < D ) res += ' A ' ; else if ( a [ i ] > D ) res += ' B ' ; else res += ' C ' ; } bool flag = false ; for ( int i = 0 ; i < l ; i ++ ) { if ( res [ i ] == ' B ' ) flag = true ; if ( res [ i ] == ' C ' ) res [ i ] = flag ? ' A ' : ' B ' ; } vector < int > seq = makeSeq ( res , a ) ; if ( checkSeq ( seq ) ) return res ; } return " - 1" ; } int main ( ) { int X = 777147777 ; cout << digitPartition ( X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float getArea ( int a ) { float area = ( M_PI * a * a ) / 4.0 ; return area ; } int main ( ) { int a = 3 ; cout << getArea ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool flipsPossible ( int a [ ] , int n ) { int count_odd = 0 , count_even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) count_odd ++ ; else count_even ++ ; } if ( count_odd % 2 && count_even % 2 ) return false ; else return true ; } int main ( ) { int a [ ] = { 1 , 0 , 1 , 1 , 0 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( flipsPossible ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PerformQueries ( vector < int > & a , vector < pair < long long , int > > & vec ) { vector < int > ans ; int n = ( int ) a . size ( ) - 1 ; int q = ( int ) vec . size ( ) ; for ( int i = 0 ; i < q ; ++ i ) { long long t = vec [ i ] . first ; int m = vec [ i ] . second ; if ( m > n ) { ans . push_back ( -1 ) ; continue ; } int turn = t / n ; int rem = t % n ; if ( rem == 0 and turn % 2 == 1 ) { ans . push_back ( -1 ) ; continue ; } if ( rem == 0 and turn % 2 == 0 ) { ans . push_back ( a [ m ] ) ; continue ; } if ( turn % 2 == 0 ) { int cursize = n - rem ; if ( cursize < m ) { ans . push_back ( -1 ) ; continue ; } ans . push_back ( a [ m + rem ] ) ; } else { int cursize = rem ; if ( cursize < m ) { ans . push_back ( -1 ) ; continue ; } ans . push_back ( a [ m ] ) ; } } for ( int i : ans ) cout << i << " STRNEWLINE " ; } int main ( ) { vector < int > a = { -1 , 1 , 2 , 3 , 4 , 5 } ; vector < pair < long long , int > > vec = { { 1 , 4 } , { 6 , 1 } , { 3 , 5 } } ; PerformQueries ( a , vec ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumEqualProduct ( int a [ ] , int n ) { int zero = 0 , two = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } if ( a [ i ] == 2 ) { two ++ ; } } int cnt = ( zero * ( zero - 1 ) ) / 2 + ( two * ( two - 1 ) ) / 2 ; return cnt ; } int main ( ) { int a [ ] = { 2 , 2 , 3 , 4 , 2 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << sumEqualProduct ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void initialize ( int mul [ ] , int div [ ] , int size ) { for ( int i = 1 ; i < size ; i ++ ) { mul [ i ] = ( mul [ i ] * mul [ i - 1 ] ) / div [ i ] ; } } void update ( int l , int r , int x , int mul [ ] , int div [ ] ) { mul [ l ] *= x ; div [ r + 1 ] *= x ; } void printArray ( int ar [ ] , int mul [ ] , int div [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { ar [ i ] = ar [ i ] * mul [ i ] ; cout << ar [ i ] << " ▁ " ; } } int main ( ) { int ar [ ] = { 10 , 5 , 20 , 40 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; int mul [ n + 1 ] , div [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { mul [ i ] = div [ i ] = 1 ; } update ( 0 , 1 , 10 , mul , div ) ; update ( 1 , 3 , 20 , mul , div ) ; update ( 2 , 2 , 2 , mul , div ) ; initialize ( mul , div , n + 1 ) ; printArray ( ar , mul , div , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const long MAX = 1000000000 ; void findTriangle ( long S ) { long X1 = 0 , Y1 = 0 ; long X2 = MAX , Y2 = 1 ; long X3 = ( MAX - S % MAX ) % MAX ; long Y3 = ( S + X3 ) / MAX ; cout << " ( " << X1 << " , ▁ " << Y1 << " ) STRNEWLINE " ; cout << " ( " << X2 << " , ▁ " << Y2 << " ) STRNEWLINE " ; cout << " ( " << X3 << " , ▁ " << Y3 << " ) " ; } int main ( ) { long S = 4 ; findTriangle ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define DIGITS  10 NEW_LINE #define MAX  10000 NEW_LINE #define MOD  1000000007 NEW_LINE long dp [ MAX ] [ DIGITS ] , cnt [ MAX ] [ DIGITS ] ; void precompute ( ) { for ( int i = 0 ; i < DIGITS ; i ++ ) dp [ 1 ] [ i ] = i , cnt [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < DIGITS ; j ++ ) { for ( int k = 0 ; k < DIGITS ; k ++ ) { if ( j != k ) { dp [ i ] [ j ] = dp [ i ] [ j ] + ( dp [ i - 1 ] [ k ] + ( cnt [ i - 1 ] [ k ] * j ) % MOD ) % MOD ; dp [ i ] [ j ] %= MOD ; cnt [ i ] [ j ] += cnt [ i - 1 ] [ k ] ; cnt [ i ] [ j ] %= MOD ; } } } } } int main ( ) { long long int x = 6 , y = 4 ; precompute ( ) ; cout << dp [ x ] [ y ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE const ll N = 10000 ; const ll MOD = 1000000007 ; ll F [ N ] ; void precompute ( ) { F [ 1 ] = 2 ; F [ 2 ] = 3 ; F [ 3 ] = 4 ; for ( int i = 4 ; i < N ; i ++ ) F [ i ] = ( F [ i - 1 ] + F [ i - 2 ] ) % MOD ; } int main ( ) { int n = 8 ; precompute ( ) ; cout << F [ n ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } double minimizedSum ( int a [ ] , int n , int K ) { int sum = maxSubArraySum ( a , n ) ; double totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) totalSum += a [ i ] ; if ( sum < 0 ) return totalSum ; totalSum = totalSum - sum + ( double ) sum / ( double ) K ; return totalSum ; } int main ( ) { int a [ ] = { 1 , -2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int K = 2 ; cout << minimizedSum ( a , n , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double get ( double L , double R ) { double x = 1.0 / L ; double y = 1.0 / ( R + 1.0 ) ; return ( x - y ) ; } int main ( ) { int L = 6 , R = 12 ; double ans = get ( L , R ) ; cout << fixed << setprecision ( 2 ) << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int N ) { int digit = N % 10 ; switch ( digit ) { case 0 : if ( N >= 90 ) return 10 ; break ; case 1 : if ( N >= 81 ) return 9 ; break ; case 2 : if ( N >= 72 ) return 8 ; break ; case 3 : if ( N >= 63 ) return 7 ; break ; case 4 : if ( N >= 54 ) return 6 ; break ; case 5 : if ( N >= 45 ) return 5 ; break ; case 6 : if ( N >= 36 ) return 4 ; break ; case 7 : if ( N >= 27 ) return 3 ; break ; case 8 : if ( N >= 18 ) return 2 ; break ; case 9 : if ( N >= 9 ) return 1 ; break ; } return -1 ; } int main ( ) { int N = 27 ; cout << findMin ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100000 ; vector < int > v ; int consecutiveOnes ( int x ) { int p = 0 ; while ( x > 0 ) { if ( x % 2 == 1 and p == 1 ) return true ; p = x % 2 ; x /= 2 ; } return false ; } void preCompute ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) { if ( ! consecutiveOnes ( i ) ) v . push_back ( i ) ; } } int nextValid ( int n ) { int it = upper_bound ( v . begin ( ) , v . end ( ) , n ) - v . begin ( ) ; int val = v [ it ] ; return val ; } void performQueries ( int queries [ ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) cout << nextValid ( queries [ i ] ) << " STRNEWLINE " ; } int main ( ) { int queries [ ] = { 4 , 6 } ; int q = sizeof ( queries ) / sizeof ( int ) ; preCompute ( ) ; performQueries ( queries , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int changeToOnes ( string str ) { int i , l , ctr = 0 ; l = str . length ( ) ; for ( i = l - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '1' ) ctr ++ ; else break ; } return l - ctr ; } string removeZeroesFromFront ( string str ) { string s ; int i = 0 ; while ( i < str . length ( ) && str [ i ] == '0' ) i ++ ; if ( i == str . length ( ) ) s = "0" ; else s = str . substr ( i , str . length ( ) - i ) ; return s ; } int main ( ) { string str = "10010111" ; str = removeZeroesFromFront ( str ) ; cout << changeToOnes ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPartition ( string s ) { int n = s . length ( ) , P = 0 ; string current = " " , previous = " " ; for ( int i = 0 ; i < n ; i ++ ) { current += s [ i ] ; if ( current != previous ) { previous = current ; current . clear ( ) ; P ++ ; } } return P ; } int main ( ) { string s = " geeksforgeeks " ; int ans = maxPartition ( s ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int main ( ) { int N = 4 , i , j , min ; cout << " Value ▁ of ▁ N : ▁ " << N << endl ; for ( i = 1 ; i <= N ; i ++ ) { for ( j = 1 ; j <= N ; j ++ ) { min = i < j ? i : j ; cout << N - min + 1 ; } for ( j = N - 1 ; j >= 1 ; j -- ) { min = i < j ? i : j ; cout << N - min + 1 ; } cout << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMissingPositive ( int arr [ ] , int n ) { int m = 1 ; set < int > x ; for ( int i = 0 ; i < n ; i ++ ) { if ( m < arr [ i ] ) { x . insert ( arr [ i ] ) ; } else if ( m == arr [ i ] ) { m = m + 1 ; while ( x . count ( m ) ) { x . erase ( m ) ; m = m + 1 ; } } } return m ; } int main ( ) { int arr [ ] = { 2 , 3 , -7 , 6 , 8 , 1 , -10 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMissingPositive ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; ++ i ) if ( n % i == 0 ) return false ; return true ; } int Min_Sum ( int n ) { if ( prime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; else { if ( prime ( n - 2 ) ) return 2 ; else return 3 ; } } int main ( ) { int n = 27 ; cout << Min_Sum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinDeletion ( int a [ ] , int n ) { unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ a [ i ] ] ++ ; int ans = 0 ; for ( auto i : map ) { int x = i . first ; int frequency = i . second ; if ( x <= frequency ) { ans += ( frequency - x ) ; } else ans += frequency ; } return ans ; } int main ( ) { int a [ ] = { 2 , 3 , 2 , 3 , 4 , 4 , 4 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinDeletion ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string find_number ( int N , int K ) { string r ; if ( N % 100 == 0 ) { N += 1 ; r = to_string ( N ) ; } else { r = to_string ( N ) ; } for ( int i = 1 ; i <= K ; i ++ ) r += "00" ; return r ; } int main ( ) { int N = 1000 , K = 2 ; string ans = find_number ( N , K ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCountAB ( string s [ ] , int n ) { int A = 0 , B = 0 , BA = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string S = s [ i ] ; int L = S . size ( ) ; for ( int j = 0 ; j < L - 1 ; j ++ ) { if ( S . at ( j ) == ' A ' && S . at ( j + 1 ) == ' B ' ) { ans ++ ; } } if ( S . at ( 0 ) == ' B ' && S . at ( L - 1 ) == ' A ' ) BA ++ ; else if ( S . at ( 0 ) == ' B ' ) B ++ ; else if ( S . at ( L - 1 ) == ' A ' ) A ++ ; } if ( BA == 0 ) ans += min ( B , A ) ; else if ( A + B == 0 ) ans += BA - 1 ; else ans += BA + min ( B , A ) ; return ans ; } int main ( ) { string s [ ] = { " ABCA " , " BOOK " , " BAND " } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; cout << maxCountAB ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOperations ( int n , int x , int * arr ) { int total = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] > x ) { int difference = arr [ i ] - x ; total = total + difference ; arr [ i ] = x ; } } for ( int i = 1 ; i < n ; ++ i ) { int LeftNeigbouringSum = arr [ i ] + arr [ i - 1 ] ; if ( LeftNeigbouringSum > x ) { int current_diff = LeftNeigbouringSum - x ; arr [ i ] = max ( 0 , arr [ i ] - current_diff ) ; total = total + current_diff ; } } return total ; } int main ( ) { int X = 1 ; int arr [ ] = { 1 , 6 , 1 , 2 , 0 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << MinOperations ( N , X , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( string s ) { set < char > st ; st . insert ( ' a ' ) ; st . insert ( ' e ' ) ; st . insert ( ' i ' ) ; st . insert ( ' o ' ) ; st . insert ( ' u ' ) ; int count = 0 ; int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( st . find ( s [ i ] ) == st . end ( ) && st . find ( s [ i + 1 ] ) != st . end ( ) ) count ++ ; } return count ; } int main ( ) { string s = " geeksforgeeks " ; cout << countPairs ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int d1 , int d2 , int d3 ) { int maxx = max ( d1 , max ( d2 , d3 ) ) ; int sum = ( d1 + d2 + d3 ) ; if ( 2 * maxx > sum or sum % 2 == 1 ) { cout << " - 1" ; return ; } int x1 = 0 , y1 = 0 ; int x2 = d1 , y2 = 0 ; int x3 = ( d1 + d2 - d3 ) / 2 ; int y3 = ( d2 + d3 - d1 ) / 2 ; cout << " ( " << x1 << " , ▁ " << y1 << " ) , ▁ ( " << x2 << " , ▁ " << y2 << " ) ▁ and ▁ ( " << x3 << " , ▁ " << y3 << " ) " ; } int main ( ) { int d1 = 3 , d2 = 4 , d3 = 5 ; solve ( d1 , d2 , d3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSize ( vector < int > & v , int n ) { v . push_back ( 0 ) ; v . push_back ( 100001 ) ; n += 2 ; sort ( v . begin ( ) , v . end ( ) ) ; int mx = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int L = v [ i - 1 ] + 1 ; int R = v [ i + 1 ] - 1 ; int cnt = R - L + 1 ; mx = max ( mx , cnt ) ; } return mx ; } int main ( ) { vector < int > v = { 200 , 10 , 5 } ; int n = v . size ( ) ; cout << maxSize ( v , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( int a [ ] , int n ) { int sum = 0 , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return n ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) len = max ( len , max ( n - i - 1 , i ) ) ; } return len ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxLength ( a , n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( long long n ) { long long initial_array [ n - 1 ] [ n - 1 ] , final_array [ n ] [ n ] ; for ( long long i = 0 ; i < n - 1 ; ++ i ) initial_array [ 0 ] [ i ] = i + 1 ; for ( long long i = 1 ; i < n - 1 ; ++ i ) for ( long long j = 0 ; j < n - 1 ; ++ j ) initial_array [ i ] [ j ] = initial_array [ i - 1 ] [ ( j + 1 ) % ( n - 1 ) ] ; for ( long long i = 0 ; i < n - 1 ; ++ i ) for ( long long j = 0 ; j < n - 1 ; ++ j ) final_array [ i ] [ j ] = initial_array [ i ] [ j ] ; for ( long long i = 0 ; i < n ; ++ i ) final_array [ i ] [ n - 1 ] = final_array [ n - 1 ] [ i ] = 0 ; for ( long long i = 0 ; i < n ; ++ i ) { long long t0 = final_array [ i ] [ i ] ; long long t1 = final_array [ i ] [ n - 1 ] ; swap ( final_array [ i ] [ i ] , final_array [ i ] [ n - 1 ] ) ; final_array [ n - 1 ] [ i ] = t0 ; } for ( long long i = 0 ; i < n ; ++ i ) { for ( long long j = 0 ; j < n ; ++ j ) cout << final_array [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { long long n = 5 ; solve ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPerm ( int n , vector < int > & differences ) { vector < int > ans ; ans . clear ( ) ; ans . push_back ( 0 ) ; int x = 0 ; for ( int i = 0 ; i <= n - 2 ; ++ i ) { int diff = differences [ i ] ; x = x + diff ; ans . push_back ( x ) ; } vector < int > anss = ans ; sort ( ans . begin ( ) , ans . end ( ) ) ; int flag = -1 ; for ( int i = 1 ; i <= n - 1 ; ++ i ) { int res = ans [ i ] - ans [ i - 1 ] ; if ( res != 1 ) { flag = 0 ; } } if ( flag == 0 ) { cout << -1 ; return ; } else { unordered_map < int , int > mpp ; mpp . clear ( ) ; int j = 1 ; vector < int > value_at_index ; for ( auto & x : ans ) { mpp [ x ] = j ; ++ j ; } for ( auto & x : anss ) { value_at_index . push_back ( mpp [ x ] ) ; } for ( auto & x : value_at_index ) { cout << x << " ▁ " ; } cout << endl ; } } int main ( ) { vector < int > differences ; differences . push_back ( 2 ) ; differences . push_back ( -3 ) ; differences . push_back ( 2 ) ; int n = differences . size ( ) + 1 ; findPerm ( n , differences ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str , int i , int j ) { while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; } int countPrimePalindrome ( string str , int len ) { bool prime [ len + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= len ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i <= len ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int j = 2 ; j <= len ; j ++ ) { if ( prime [ j ] ) { for ( int i = 0 ; i + j - 1 < len ; i ++ ) { if ( isPalindrome ( str , i , i + j - 1 ) ) count ++ ; } } } return count ; } int main ( ) { string s = " geeksforgeeks " ; int len = s . length ( ) ; cout << countPrimePalindrome ( s , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int N ) { double x = log2 ( N ) ; int ans = ceil ( x ) ; return ans ; } int main ( ) { int N = 10 ; cout << minOperations ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_greatest_divisor ( int l , int r ) { if ( l == r ) return l ; return 1 ; } int main ( ) { int l = 2 , r = 12 ; cout << find_greatest_divisor ( l , r ) ; }
#include <cmath> NEW_LINE #include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void findNumbers ( int arr [ ] , int n ) { int sumN = ( n * ( n + 1 ) ) / 2 ; int sumSqN = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sum = 0 , sumSq = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; sumSq = sumSq + ( pow ( arr [ i ] , 2 ) ) ; } int B = ( ( ( sumSq - sumSqN ) / ( sum - sumN ) ) + sumN - sum ) / 2 ; int A = sum - sumN + B ; cout << " A ▁ = ▁ " ; cout << A << endl ; cout << " B ▁ = ▁ " ; cout << B << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findNumbers ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; } int main ( ) { double p , q ; p = 80 ; q = 40 ; cout << fixed << setprecision ( 15 ) << getProbability ( p , q ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return true ; } return false ; } int main ( ) { int arr [ ] = { 3 , 9 , 12 , 13 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( check ( arr , n ) ) cout << " Odd ▁ Bit - wise ▁ OR " ; else cout << " Even ▁ Bit - wise ▁ OR " ; return 0 ; }
#include <bits / stdc++.h> NEW_LINE using namespace std ; int main ( ) { char str [ ] = "10010111" ; int length = strlen ( str ) ; int i = length - 1 ; while ( str [ i ] == '1' ) { str [ i ] = '0' ; i -- ; } if ( i >= 0 ) str [ i ] = '1' ; printf ( " % ▁ s " , str ) ; }
#include <iostream> NEW_LINE #include <time.h> NEW_LINE using namespace std ; int main ( ) { int n = 800000 ; clock_t t = clock ( ) ; long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i ; t = clock ( ) - t ; cout << " sum ▁ is : ▁ " << sum << endl ; cout << " time ▁ taken ▁ by ▁ normal ▁ loops : " " ( float ) t ▁ / ▁ CLOCKS _ PER _ SEC ▁ < < ▁ " seconds " << endl ; t = clock ( ) ; sum = 0 ; for ( int i = 1 ; i <= n ; i += 8 ) { sum += i sum += ( i + 1 ) ; sum += ( i + 2 ) ; sum += ( i + 3 ) ; sum += ( i + 4 ) ; sum += ( i + 5 ) ; sum += ( i + 6 ) ; sum += ( i + 7 ) ; } t = clock ( ) - t ; cout << " Sum ▁ is : ▁ " << sum << endl ; cout << " Time ▁ taken ▁ by ▁ unrolling : ▁ " " ( float ) t ▁ / ▁ CLOCKS _ PER _ SEC ▁ < < ▁ " seconds " return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int _log ( double x , double base ) { return ( int ) ( log ( x ) / log ( base ) ) ; } double recursiveLogStar ( double n , double b ) { if ( n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) ; else return 0 ; } int main ( ) { int n = 100 , base = 5 ; cout << " Log * ( " << n << " ) ▁ = ▁ " << recursiveLogStar ( n , base ) << " STRNEWLINE " ; return 0 ; }
int iterativeLogStar ( double n , double b ) { int count = 0 ; while ( n >= 1 ) { n = _log ( n , b ) ; count ++ ; } return count ; }
void function ( int n ) { int count = 0 ; for ( int i = n / 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j = 2 * j ) for ( int k = 1 ; k <= n ; k = k * 2 ) count ++ ; }
int sum ( int sum ) { if ( n <= 0 ) return 0 ; return n + sum ( n - 1 ) ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int findMaximum ( int arr [ ] , int size ) { int i = 0 , j = size - 1 , mid ; while ( i <= j ) { mid = i + ( j - i ) / 2 ; if ( arr [ mid ] < 0 ) i = mid + 1 ; else if ( arr [ mid ] > 0 ) j = mid - 1 ; } return max ( i , size - i ) ; } int main ( ) { int arr [ ] = { -9 , -7 , -4 , 1 , 5 , 8 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaximum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double maxKth ( int arr [ ] , int N , int C , int K ) { if ( N + C < K ) { return -1 ; } int iter = 300 ; double l = 0 , r = 1000000000.0 ; while ( iter -- ) { double mid = ( l + r ) * 0.5 ; double a = 0 ; double b = 0 ; for ( int i = 0 ; i < N ; i ++ ) { a += int ( ( double ) arr [ i ] / mid ) ; if ( ( double ) arr [ i ] >= mid ) { b ++ ; } } if ( a >= K && b + C >= K ) { l = mid ; } else { r = mid ; } } return l ; } int main ( ) { int arr [ ] = { 5 , 8 } ; int K = 1 , C = 1 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxKth ( arr , N , C , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossibleToSelect ( int arr [ ] , int N , int dif , int K ) { int count = 1 ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= ( prev + dif ) ) { count ++ ; if ( count == K ) return true ; prev = arr [ i ] ; } } return false ; } int binarySearch ( int arr [ ] , int left , int right , int K , int N ) { int ans = 1 ; while ( left <= right ) { int dif = left + ( right - left ) / 2 ; if ( isPossibleToSelect ( arr , N , dif , K ) ) { ans = max ( ans , dif ) ; left = dif + 1 ; } else right = dif - 1 ; } return ans ; } int main ( ) { int N , K ; N = 7 , K = 4 ; int arr [ ] = { 1 , 4 , 9 , 0 , 2 , 13 , 3 } ; sort ( arr , arr + N ) ; cout << binarySearch ( arr , 0 , arr [ N - 1 ] , K , N ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cal ( vector < int > arr , int mid ) { int chocolate = 0 ; for ( auto i : arr ) { if ( i >= mid ) chocolate += i - mid ; } return chocolate ; } int maximumCut ( vector < int > arr , int K ) { int low = 0 ; int high = * max_element ( arr . begin ( ) , arr . end ( ) ) ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int chocolate = cal ( arr , mid ) ; if ( chocolate == K ) return mid ; else if ( chocolate < K ) high = mid - 1 ; else { low = mid + 1 ; if ( mid > high ) high = mid ; } } return high ; } int main ( ) { int N = 4 ; int K = 7 ; vector < int > arr { 15 , 20 , 8 , 17 } ; cout << ( maximumCut ( arr , K ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( vector < int > & bananas , int mid_val , int H ) { int time = 0 ; for ( int i = 0 ; i < bananas . size ( ) ; i ++ ) { if ( bananas [ i ] % mid_val != 0 ) { time += ( ( bananas [ i ] / mid_val ) + 1 ) ; } else { time += ( bananas [ i ] / mid_val ) ; } } if ( time <= H ) { return true ; } else { return false ; } } int minEatingSpeed ( vector < int > & piles , int H ) { int start = 1 ; int end = * max_element ( piles . begin ( ) , piles . end ( ) ) ; while ( start < end ) { int mid = start + ( end - start ) / 2 ; if ( ( check ( piles , mid , H ) ) == true ) { end = mid ; } else { start = mid + 1 ; } } return end ; } int main ( ) { vector < int > piles = { 30 , 11 , 23 , 4 , 20 } ; int H = 6 ; cout << minEatingSpeed ( piles , H ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long check ( long H [ ] , long A [ ] , long mid , long N , long M , long L ) { long sum = 0 ; for ( long i = 0 ; i < N ; i ++ ) { long speed = mid * A [ i ] + H [ i ] ; if ( speed >= L ) { sum += speed ; } } return sum ; } long buzzTime ( long N , long M , long L , long H [ ] , long A [ ] ) { long low = 0 , high = 1e10 ; long ans = 0 ; while ( high >= low ) { long mid = low + ( high - low ) / 2 ; if ( check ( H , A , mid , N , M , L ) >= M ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; } int main ( ) { long M = 400 , L = 120 ; long H [ ] = { 20 , 50 , 20 } ; long A [ ] = { 20 , 70 , 90 } ; long N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << buzzTime ( N , M , L , H , A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_possible ( vector < int > & teams , int T , int k ) { int sum = 0 ; for ( int i = 0 ; i < teams . size ( ) ; i ++ ) { sum += min ( T , teams [ i ] ) ; } return ( sum >= ( T * k ) ) ; } int countOfTeams ( vector < int > & teams_list , int N , int K ) { int lb = 0 , ub = 1e9 ; while ( lb <= ub ) { int mid = lb + ( ub - lb ) / 2 ; if ( is_possible ( teams_list , mid , K ) ) { if ( ! is_possible ( teams_list , mid + 1 , K ) ) { return mid ; } else { lb = mid + 1 ; } } else { ub = mid - 1 ; } } return 0 ; } int main ( ) { vector < int > arr = { 2 , 3 , 4 } ; int K = 2 ; int N = arr . size ( ) ; cout << countOfTeams ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumOperations ( int arr [ ] , int N ) { int mx = 0 , pos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= mx ) { mx = arr [ i ] ; pos = i ; } } cout << ( mx - 1 ) * N + pos + 1 ; } int main ( ) { int arr [ ] = { 2 , 0 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumOperations ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Rearrange ( int arr [ ] , int K , int N ) { int ans [ N + 1 ] ; int f = -1 ; for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = -1 ; } K = find ( arr , arr + N , K ) - arr ; vector < int > smaller , greater ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ K ] ) smaller . push_back ( arr [ i ] ) ; else if ( arr [ i ] > arr [ K ] ) greater . push_back ( arr [ i ] ) ; } int low = 0 , high = N - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid == K ) { ans [ mid ] = arr [ K ] ; f = 1 ; break ; } else if ( mid < K ) { if ( smaller . size ( ) == 0 ) { break ; } ans [ mid ] = smaller . back ( ) ; smaller . pop_back ( ) ; low = mid + 1 ; } else { if ( greater . size ( ) == 0 ) { break ; } ans [ mid ] = greater . back ( ) ; greater . pop_back ( ) ; high = mid - 1 ; } } if ( f == -1 ) { cout << -1 << endl ; return ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ans [ i ] == -1 ) { if ( smaller . size ( ) ) { ans [ i ] = smaller . back ( ) ; smaller . pop_back ( ) ; } else if ( greater . size ( ) ) { ans [ i ] = greater . back ( ) ; greater . pop_back ( ) ; } } } for ( int i = 0 ; i < N ; i ++ ) cout << ans [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 10 , 7 , 2 , 5 , 3 , 8 } ; int K = 7 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Rearrange ( arr , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestAltitude ( int L , int B ) { if ( L > B ) { swap ( B , L ) ; } int low = 0 , high = L ; int res = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( mid <= ( B / 2 ) ) { res = mid ; low = mid + 1 ; } else high = mid - 1 ; } return res ; } int main ( ) { int L = 3 ; int B = 4 ; cout << largestAltitude ( L , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFreq ( vector < int > & arr , int N ) { int freq = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { freq ++ ; } else { cout << " Frequency ▁ of ▁ " << arr [ i - 1 ] << " ▁ is : ▁ " << freq << endl ; freq = 1 ; } } cout << " Frequency ▁ of ▁ " << arr [ N - 1 ] << " ▁ is : ▁ " << freq << endl ; } int main ( ) { vector < int > arr = { 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 } ; int N = arr . size ( ) ; printFreq ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isMaximumMedian ( vector < vector < int > > & arr , int N , int K , int mid ) { vector < vector < int > > Pre ( N + 5 , vector < int > ( N + 5 , 0 ) ) ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { Pre [ i + 1 ] [ j + 1 ] = Pre [ i + 1 ] [ j ] + Pre [ i ] [ j + 1 ] - Pre [ i ] [ j ] ; if ( arr [ i ] [ j ] <= mid ) Pre [ i + 1 ] [ j + 1 ] ++ ; } } int required = ( K * K + 1 ) / 2 ; bool flag = 0 ; for ( int i = K ; i <= N ; ++ i ) { for ( int j = K ; j <= N ; ++ j ) { int X = Pre [ i ] [ j ] - Pre [ i - K ] [ j ] - Pre [ i ] [ j - K ] + Pre [ i - K ] [ j - K ] ; if ( X < required ) flag = 1 ; } } return flag ; } int maximumMedian ( vector < vector < int > > & arr , int N , int K ) { int low = 0 , high = 1e9 ; while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( isMaximumMedian ( arr , N , K , mid ) ) { low = mid + 1 ; } else { high = mid ; } } return low ; } int main ( ) { vector < vector < int > > arr = { { 1 , 5 , 12 } , { 6 , 7 , 11 } , { 8 , 9 , 10 } } ; int N = arr . size ( ) ; int K = 2 ; cout << maximumMedian ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinDays ( int arr [ ] , int R [ ] , int N , int X , int K ) { int low = 0 , high = X ; int minDays ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int temp = arr [ i ] + R [ i ] * mid ; if ( temp >= K ) { sum += temp ; } } if ( sum >= X ) { minDays = mid ; high = mid - 1 ; } else { low = mid + 1 ; } } cout << minDays ; } int main ( ) { int X = 100 , K = 45 ; int arr [ ] = { 2 , 5 , 2 , 6 } ; int R [ ] = { 10 , 13 , 15 , 12 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMinDays ( arr , R , N , X , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairsCount ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( a [ i ] * a [ j ] ) == abs ( i - j ) ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getPairsCount ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string lexicographicallySmallestString ( string S , int N ) { int LastZe = -1 ; string ans ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '0' ) { LastZe = i ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( i <= LastZe && S [ i ] == '0' ) ans += S [ i ] ; else if ( i > LastZe ) ans += S [ i ] ; } return ans ; } int main ( ) { string S = "11001101" ; int N = S . size ( ) ; cout << lexicographicallySmallestString ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSwaps ( int N , int M , vector < vector < int > > & A , vector < vector < int > > & B ) { int count01 = 0 ; int count10 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( A [ i ] [ j ] != B [ i ] [ j ] ) { if ( A [ i ] [ j ] == 1 ) count10 ++ ; else count01 ++ ; } } } if ( count01 == count10 ) return count01 ; else return -1 ; } int main ( ) { vector < vector < int > > A = { { 1 , 1 , 0 } , { 0 , 0 , 1 } , { 0 , 1 , 0 } } ; vector < vector < int > > B = { { 0 , 0 , 1 } , { 0 , 1 , 0 } , { 1 , 1 , 0 } } ; int N = A . size ( ) ; int M = B [ 0 ] . size ( ) ; cout << minSwaps ( N , M , A , B ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int sum = 0 ; int res = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += i ; if ( sum <= K ) res ++ ; else break ; } return res ; } int main ( ) { int N = 6 , K = 14 ; cout << Count ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeLastOccurrence ( string S , string W , int N , int M ) { if ( M > N ) return S ; for ( int i = N - M ; i >= 0 ; i -- ) { int flag = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( S [ j + i ] != W [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) { for ( int j = i ; j < N - M ; j ++ ) S [ j ] = S [ j + M ] ; S . resize ( N - M ) ; break ; } } return S ; } int main ( ) { string S = " This ▁ is ▁ GeeksForGeeks " ; string W = " Geeks " ; int N = S . length ( ) ; int M = W . length ( ) ; cout << removeLastOccurrence ( S , W , N , M ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumIndices ( int arr [ ] , int N ) { int temp [ N ] = { 0 } ; int maxIndices = ( N - 1 ) / 2 ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < maxIndices ; i ++ ) { temp [ 2 * i + 1 ] = arr [ i ] ; } int j = 0 ; for ( int i = maxIndices ; i < N ; ) { if ( temp [ j ] == 0 ) { temp [ j ] = arr [ i ] ; i ++ ; } j ++ ; } for ( int i = 0 ; i < N ; i ++ ) { cout << temp [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximumIndices ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumK ( vector < int > & arr , int M , int N ) { int good = ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { int K = i ; int candies = N ; int taken = 0 ; while ( candies > 0 ) { taken += min ( K , candies ) ; candies -= min ( K , candies ) ; for ( int j = 0 ; j < M ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } if ( taken >= good ) { cout << i ; return ; } } } int main ( ) { int N = 13 , M = 1 ; vector < int > arr = { 50 } ; minimumK ( arr , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int K , int n , int m , vector < int > arr , int good_share ) { int candies = n , taken = 0 ; while ( candies > 0 ) { taken += min ( K , candies ) ; candies -= min ( K , candies ) ; for ( int j = 0 ; j < m ; j ++ ) { int consume = ( arr [ j ] * candies ) / 100 ; candies -= consume ; } } return ( taken >= good_share ) ; } void minimumK ( vector < int > & arr , int N , int M ) { int good_share = ceil ( ( N * 1.0 ) / ( ( M + 1 ) * 1.0 ) ) ; int lo = 1 , hi = N ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( check ( mid , N , M , arr , good_share ) ) { hi = mid ; } else { lo = mid + 1 ; } } cout << hi ; } int main ( ) { int N = 13 , M = 1 ; vector < int > arr = { 50 } ; minimumK ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ans = 0 ; vector < int > edges [ 100000 ] ; void Add_edge ( int u , int v ) { edges [ u ] . push_back ( v ) ; edges [ v ] . push_back ( u ) ; } void minTimeToColor ( int node , int parent , int arrival_time ) { int current_time = 0 ; for ( auto x : edges [ node ] ) { if ( x != parent ) { ++ current_time ; if ( current_time == arrival_time ) ++ current_time ; ans = max ( ans , current_time ) ; minTimeToColor ( x , node , current_time ) ; } } } int main ( ) { pair < int , int > A [ ] = { { 1 , 2 } , { 2 , 3 } , { 3 , 4 } } ; for ( auto i : A ) { Add_edge ( i . first , i . second ) ; } minTimeToColor ( 1 , -1 , 0 ) ; cout << ans << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestNum ( vector < int > arr ) { int res = 0 ; sort ( arr . begin ( ) , arr . end ( ) ) ; int l = 0 , r = arr . size ( ) - 1 ; while ( l < r ) { int sum = arr [ l ] + arr [ r ] ; if ( sum == 0 ) { res = max ( res , max ( arr [ l ] , arr [ r ] ) ) ; return res ; } else if ( sum < 0 ) { l ++ ; } else { r -- ; } } return res ; } int main ( ) { vector < int > arr = { 3 , 2 , -2 , 5 , -3 } ; cout << ( largestNum ( arr ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLarger ( int arr [ ] , int n ) { int mid = ( n + 1 ) / 2 ; int mx = * max_element ( arr , arr + n ) ; int count [ mx + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] ++ ; } for ( int i = mx ; i >= 0 ; i -- ) { while ( count [ i ] > 0 ) { count [ i ] -- ; mid -- ; cout << i << ' ▁ ' ; if ( mid == 0 ) break ; } if ( mid == 0 ) break ; } } int main ( ) { int arr [ ] = { 10 , 4 , 2 , 8 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findLarger ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double probability ( vector < int > arr1 , vector < int > arr2 ) { int N = arr1 . size ( ) ; int M = arr2 . size ( ) ; double res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int y = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr2 [ j ] > arr1 [ i ] ) y ++ ; } res += y ; } res = ( double ) res / ( double ) ( N * M ) ; return res ; } int main ( ) { vector < int > arr1 = { 5 , 2 , 6 , 1 } ; vector < int > arr2 = { 1 , 6 , 10 , 1 } ; cout << probability ( arr1 , arr2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countGreater ( int * arr , int k ) ; float probability ( int * arr1 , int * arr2 ) { int N = 4 ; int M = 4 ; float res = 0 ; sort ( arr2 , arr2 + M ) ; for ( int i = 0 ; i < N ; i ++ ) { int y = countGreater ( arr2 , arr1 [ i ] ) ; res += y ; } res = res / ( N * M ) ; return res ; } int countGreater ( int * arr , int k ) { int n = 4 ; int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; } int main ( ) { int arr1 [ ] = { 5 , 2 , 6 , 1 } ; int arr2 [ ] = { 1 , 6 , 10 , 1 } ; cout << probability ( arr1 , arr2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( vector < vector < char > > arr , int A , int B ) { int n = arr . size ( ) ; int m = arr [ 0 ] . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == ' * ' ) continue ; if ( j == m - 1 ) ans += A ; else { if ( arr [ i ] [ j + 1 ] == ' . ' ) { ans += min ( 2 * A , B ) ; j ++ ; } else ans += A ; } } } cout << ans ; } int main ( ) { vector < vector < char > > arr = { { ' . ' , ' . ' , ' * ' } , { ' . ' , ' * ' , ' * ' } } ; int A = 2 , B = 10 ; minCost ( arr , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void calcTotalTime ( string path ) { int time = 0 ; int x = 0 , y = 0 ; set < pair < int , int > > s ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { int p = x ; int q = y ; if ( path [ i ] == ' N ' ) y ++ ; else if ( path [ i ] == ' S ' ) y -- ; else if ( path [ i ] == ' E ' ) x ++ ; else if ( path [ i ] == ' W ' ) x -- ; if ( s . find ( { p + x , q + y } ) == s . end ( ) ) { time += 2 ; s . insert ( { p + x , q + y } ) ; } else time += 1 ; } cout << time << endl ; } int main ( ) { string path = " NSE " ; calcTotalTime ( path ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countInversions ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 1 ; i <= n ; i ++ ) { v . push_back ( i ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { auto itr = lower_bound ( v . begin ( ) , v . end ( ) , arr [ i ] ) ; ans += itr - v . begin ( ) ; v . erase ( itr ) ; } cout << ans ; return 0 ; } int main ( ) { int arr [ ] = { 2 , 3 , 1 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countInversions ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarysearch ( int array [ ] , int right , int element ) { int left = 1 ; while ( left <= right ) { int mid = ( left + right / 2 ) ; if ( array [ mid ] == element ) { return mid ; } if ( mid - 1 > 0 && array [ mid ] > element && array [ mid - 1 ] < element ) { return mid ; } else if ( array [ mid ] < element ) { left = mid + 1 ; } else { right = mid - 1 ; } } return 1 ; } void countDistinct ( vector < int > arr , int L , int R ) { int count = 0 ; int pref [ arr . size ( ) + 1 ] ; for ( int i = 1 ; i <= arr . size ( ) ; ++ i ) { count += arr [ i - 1 ] ; pref [ i ] = count ; } int left = binarysearch ( pref , arr . size ( ) + 1 , L ) ; int right = binarysearch ( pref , arr . size ( ) + 1 , R ) ; cout << right - left + 1 ; } int main ( ) { vector < int > arr { 3 , 6 , 7 , 1 , 8 } ; int L = 3 ; int R = 7 ; countDistinct ( arr , L , R ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubstrings ( string & s ) { int n = s . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( s [ j ] == ' a ' ) cnt ++ ; else if ( s [ j ] == ' c ' ) cnt -- ; if ( cnt > 0 ) { ans ++ ; } } } cout << ans ; } int main ( ) { string S = " abccaab " ; countSubstrings ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( int weight [ ] , int n , int D , int mx ) { int st = 1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += weight [ i ] ; if ( sum > mx ) { st ++ ; sum = weight [ i ] ; } if ( st > D ) return false ; } return true ; } void shipWithinDays ( int weight [ ] , int D , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += weight [ i ] ; int s = weight [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = max ( s , weight [ i ] ) ; } int e = sum ; int res = -1 ; while ( s <= e ) { int mid = s + ( e - s ) / 2 ; if ( isValid ( weight , n , D , mid ) ) { res = mid ; e = mid - 1 ; } else s = mid + 1 ; } cout << res ; } int main ( ) { int weight [ ] = { 9 , 8 , 10 } ; int D = 3 ; int N = sizeof ( weight ) / sizeof ( weight [ 0 ] ) ; shipWithinDays ( weight , D , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createGraph ( unordered_map < int , vector < int > > & adj , int paths [ ] [ 2 ] , int A [ ] , int N , int E ) { for ( int i = 0 ; i < E ; i ++ ) { if ( ! A [ paths [ i ] [ 0 ] ] && ! A [ paths [ i ] [ 1 ] ] ) { adj [ paths [ i ] [ 0 ] ] . push_back ( paths [ i ] [ 1 ] ) ; } } } int minPath ( int paths [ ] [ 2 ] , int A [ ] , int N , int E ) { if ( A [ 0 ] == 1 A [ N - 1 ] == 1 ) return -1 ; unordered_map < int , vector < int > > adj ; createGraph ( adj , paths , A , N , E ) ; vector < int > visited ( N , 0 ) ; int dist [ N ] ; dist [ 0 ] = 0 ; queue < int > q ; q . push ( 0 ) ; visited [ 0 ] = 1 ; while ( ! q . empty ( ) ) { int temp = q . front ( ) ; q . pop ( ) ; for ( auto x : adj [ temp ] ) { if ( ! visited [ x ] ) { q . push ( x ) ; visited [ x ] = 1 ; dist [ x ] = dist [ temp ] + 1 ; } } } if ( ! visited [ N - 1 ] ) return -1 ; else return dist [ N - 1 ] ; } int main ( ) { int N = 5 , E = 5 ; int A [ ] = { 0 , 1 , 0 , 0 , 0 } ; int paths [ ] [ 2 ] = { { 0 , 1 } , { 0 , 2 } , { 1 , 4 } , { 2 , 3 } , { 3 , 4 } } ; cout << minPath ( paths , A , N , E ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int * arr , int N , int pt ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += abs ( arr [ i ] - pt ) ; } return sum ; } void findPoint ( int * arr , int N , int K ) { int left ; if ( N % 2 ) { left = arr [ N / 2 ] ; } else { left = arr [ N / 2 - 1 ] + 1 ; } int right = arr [ N - 1 ] ; while ( left <= right ) { int mid = ( left + right ) / 2 ; int temp = findSum ( arr , N , mid ) ; if ( temp == K ) { cout << mid << endl ; return ; } else if ( K < temp ) { right = mid - 1 ; } else { left = mid + 1 ; } } left = arr [ 0 ] ; right = arr [ N / 2 ] - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; int temp = findSum ( arr , N , mid ) ; if ( temp == K ) { cout << mid << endl ; return ; } else if ( K > temp ) { right = mid - 1 ; } else { left = mid + 1 ; } } cout << " - 1" << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 6 , 7 , 11 } ; int K = 18 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPoint ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findArray ( int arr [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { int ans = -1 , old_c = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { int curr_c = count ( & arr [ j ] , & arr [ n ] , arr [ j ] ) ; if ( curr_c == old_c ) { if ( arr [ j ] < ans ) ans = arr [ j ] ; } if ( curr_c > old_c ) { ans = arr [ j ] ; old_c = curr_c ; } } } v . push_back ( ans ) ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 4 , 5 , 2 , 25 , 10 , 5 , 10 , 3 , 10 , 5 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findArray ( arr , size ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void prodEquilibrium ( int arr [ ] , int N ) { int product = 1 ; for ( int i = 0 ; i < N ; i ++ ) { product *= arr [ i ] ; } int left = 1 ; int right = product ; for ( int i = 0 ; i < N ; i ++ ) { left = left * arr [ i ] ; right = right / arr [ i ] ; if ( left == right ) { cout << i + 1 << endl ; return ; } } cout << -1 << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; prodEquilibrium ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void convert ( int arr [ ] , int n ) { int brr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; sort ( brr , brr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int l = 0 , r = n - 1 , mid ; while ( l <= r ) { mid = ( l + r ) / 2 ; if ( brr [ mid ] == arr [ i ] ) { cout << mid << ' ▁ ' ; break ; } else if ( brr [ mid ] < arr [ i ] ) { l = mid + 1 ; } else { r = mid - 1 ; } } } } int main ( ) { int arr [ ] = { 10 , 20 , 15 , 12 , 11 , 50 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; convert ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findIndex ( int arr [ ] , int N ) { int maxValue = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { maxValue = max ( maxValue , arr [ i ] ) ; } map < int , int > St ; for ( int i = 1 ; i <= maxValue ; i ++ ) { St [ i ] ++ ; } if ( St . find ( 1 ) != St . end ( ) ) { St . erase ( 1 ) ; } for ( int i = 2 ; i <= sqrt ( maxValue ) ; i ++ ) { int j = 2 ; while ( ( i * j ) <= maxValue ) { if ( St . find ( i * j ) != St . end ( ) ) { St . erase ( i * j ) ; } j ++ ; } } int LeftCount = 0 ; int Prefix [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { Prefix [ i ] = LeftCount ; if ( St . find ( arr [ i ] ) != St . end ( ) ) { LeftCount ++ ; } } int RightCount = 0 ; int Suffix [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { Suffix [ i ] = RightCount ; if ( St . find ( arr [ i ] ) != St . end ( ) ) { RightCount ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( Prefix [ i ] == Suffix [ i ] ) { return i ; } } return -1 ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 7 , 5 , 10 , 1 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findIndex ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCountPairs ( vector < int > arr , int N , int S ) { int count = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < arr . size ( ) ; j ++ ) { if ( ( arr [ i ] + arr [ j ] ) == S ) count ++ ; } } return count ; } int countPairs ( vector < int > arr , int N ) { int count = 0 ; unordered_set < int > S ; for ( int i = 0 ; i < N ; i ++ ) S . insert ( arr [ i ] ) ; for ( int ele : S ) { int sum = 2 * ele ; count += getCountPairs ( arr , N , sum ) ; } return count ; } int main ( ) { vector < int > arr = { 4 , 2 , 5 , 1 , 3 , 5 } ; int N = arr . size ( ) ; cout << countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE const int MAX = 1e5 ; using namespace std ; ll power ( ll x , unsigned ll y ) { ll res = 1 ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) ; y = y >> 1 ; x = ( x * x ) ; } return res ; } void SieveOfEratosthenes ( vector < pair < ll , ll > > & v ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } int num = 1 ; for ( int i = 1 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) { v . push_back ( { i , num } ) ; num ++ ; } } } int countIntegers ( ll n ) { if ( n < 16 ) { return 0 ; } vector < pair < ll , ll > > v ; SieveOfEratosthenes ( v ) ; int low = 0 ; int high = v . size ( ) - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; ll curr = power ( v [ mid ] . first , 4 ) ; ll prev = power ( v [ mid - 1 ] . first , 4 ) ; if ( curr == n ) { return v [ mid ] . second ; } else if ( curr > n and prev <= n ) { return v [ mid - 1 ] . second ; } else if ( curr > n ) { high = mid - 1 ; } else { low = mid + 1 ; } } return 0 ; } int main ( ) { ll N = 100 ; cout << countIntegers ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } void printArray ( vector < string > res ) { sort ( res . begin ( ) , res . end ( ) ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) { cout << res [ i ] << " ▁ " ; } } void sortedStrings ( string S [ ] , int N ) { unordered_map < char , int > freq ; vector < string > res ; for ( int i = 0 ; i < N ; i ++ ) { string st = " " ; for ( int j = 0 ; j < S [ i ] . size ( ) ; j ++ ) { freq [ S [ i ] [ j ] ] ++ ; } for ( auto i : freq ) { if ( isPowerOfTwo ( i . second ) ) { for ( int j = 0 ; j < i . second ; j ++ ) { st += i . first ; } } } freq . clear ( ) ; if ( st . size ( ) == 0 ) continue ; sort ( st . begin ( ) , st . end ( ) , greater < char > ( ) ) ; res . push_back ( st ) ; } printArray ( res ) ; } int main ( ) { string arr [ ] = { " aaacbb " , " geeks " , " aaa " } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortedStrings ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void replaceCharacters ( string s , vector < vector < char > > p ) { int n = s . size ( ) , k = p . size ( ) ; char arr [ 26 ] ; char brr [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s [ i ] - ' a ' ] = s [ i ] ; brr [ s [ i ] - ' a ' ] = s [ i ] ; } for ( int j = 0 ; j < k ; j ++ ) { char a = p [ j ] [ 0 ] , b = p [ j ] [ 1 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( arr [ i ] == a ) { brr [ i ] = b ; } } } for ( int i = 0 ; i < n ; i ++ ) { cout << brr [ s [ i ] - ' a ' ] ; } } int main ( ) { string S = " aabbgg " ; vector < vector < char > > P { { ' a ' , ' b ' } , { ' b ' , ' g ' } , { ' g ' , ' a ' } } ; replaceCharacters ( S , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100001 NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool prime [ ] ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } } void smallestSemiPrime ( int n ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime ) ; int num1 = n + 1 ; while ( prime [ num1 ] != true ) { num1 ++ ; } int num2 = num1 + n ; while ( prime [ num2 ] != true ) { num2 ++ ; } cout << num1 * 1LL * num2 ; } int main ( ) { int N = 2 ; smallestSemiPrime ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void productOfTwoPerfectCubes ( int N ) { map < int , int > cubes ; for ( int i = 1 ; i * i * i <= N ; i ++ ) cubes [ i * i * i ] = i ; for ( auto itr = cubes . begin ( ) ; itr != cubes . end ( ) ; itr ++ ) { int firstNumber = itr -> first ; if ( N % itr -> first == 0 ) { int secondNumber = N / itr -> first ; if ( cubes . find ( secondNumber ) != cubes . end ( ) ) { cout << " Yes " ; return ; } } } cout << " No " ; } int main ( ) { int N = 216 ; productOfTwoPerfectCubes ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void productOfTwoPerfectCubes ( int N ) { int cube_root ; cube_root = round ( cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { cout << " Yes " ; return ; } else { cout << " No " ; return ; } } int main ( ) { int N = 216 ; productOfTwoPerfectCubes ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNumberOfPairs ( int N ) { unordered_set < int > st ; for ( int i = 2 ; i * i <= N ; i ++ ) { int x = i ; while ( x <= N ) { x *= i ; if ( x <= N ) { st . insert ( x ) ; } } } cout << st . size ( ) ; } int main ( ) { int N = 10000 ; printNumberOfPairs ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } void maximumProduct ( vector < string > words ) { vector < int > bits ( words . size ( ) , 0 ) ; for ( int i = 0 ; i < words . size ( ) ; i ++ ) { for ( int j = 0 ; j < words [ i ] . length ( ) ; j ++ ) { bits [ i ] = bits [ i ] | 1 << ( words [ i ] [ j ] - ' a ' ) ; } } int result = 0 ; for ( int i = 0 ; i < bits . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < bits . size ( ) ; j ++ ) { if ( ( bits [ i ] & bits [ j ] ) == 0 ) { int L = countSetBits ( bits [ i ] ) ; int R = countSetBits ( bits [ j ] ) ; result = max ( L * R , result ) ; } } } cout << result ; } int main ( ) { vector < string > arr = { " abcw " , " baz " , " foo " , " bar " , " xtfn " , " abcdef " } ; maximumProduct ( arr ) ; return 0 ; }
function palindrome ( str ) { var st = 0 ; var ed = str . length - 1 ; while ( st < ed ) { if ( str [ st ] == str [ ed ] ) { st ++ ; ed -- ; } else return false ; } return true ; } function printReverse ( sentence ) { var newlist = [ ] ; var lis = [ ] ; var temp = " " ; for ( var i = 0 ; i < sentence . length ; i ++ ) { if ( sentence [ i ] == ' ▁ ' ) { lis . push ( temp ) ; temp = " " ; } else temp += sentence [ i ] ; } lis . push ( temp ) ; for ( var i = 0 ; i < lis . length ; i ++ ) { if ( palindrome ( lis [ i ] ) ) newlist . push ( lis [ i ] ) ; } newlist . reverse ( ) ; var j = 0 ; for ( var i = 0 ; i < lis . length ; i ++ ) { if ( palindrome ( lis [ i ] ) ) { lis [ i ] = newlist [ j ] ; j = j + 1 ; } } for ( var i = 0 ; i < lis . length ; i ++ ) { document . write ( lis [ i ] + " ▁ " ) ; } } var sentence = " mom ▁ and ▁ dad ▁ went ▁ to ▁ eye ▁ hospital " ; printReverse ( sentence ) ;
#include <iostream> NEW_LINE using namespace std ; int minCount ( int A [ ] , int B [ ] , int N ) { int i = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] == B [ j ] ) { i ++ ; } } return N - i ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 } ; int B [ ] = { 1 , 5 , 2 , 3 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minCount ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int possible ( int A [ ] , int N , int mid , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { count += ( A [ i ] - 1 ) / mid ; } return count <= K ; } int minimumMaximum ( int A [ ] , int N , int K ) { int lo = 1 ; int hi = * max_element ( A , A + N ) ; int mid ; while ( lo < hi ) { mid = ( lo + hi ) / 2 ; if ( possible ( A , N , mid , K ) ) { hi = mid ; } else { lo = mid + 1 ; } } return hi ; } int main ( ) { int arr [ ] = { 2 , 4 , 8 , 2 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumMaximum ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumNumber ( int arr [ ] , int N , int K ) { int minimum = * min_element ( arr , arr + N ) ; int ans = minimum + K ; for ( int i = 0 ; i < N ; i ++ ) { if ( abs ( arr [ i ] - ans ) > K ) { ans = -1 ; break ; } } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximumNumber ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } void sumOfPrimeSquare ( int n ) { int i = 0 ; vector < int > squares ; while ( i * i < n ) { squares . push_back ( i * i ) ; i ++ ; } bool flag = false ; for ( i = 0 ; i < squares . size ( ) ; i ++ ) { int difference = n - squares [ i ] ; if ( isPrime ( difference ) ) { flag = true ; break ; } } if ( flag ) { cout << " Yes " ; } else cout << " No " ; } int main ( ) { int N = 27 ; sumOfPrimeSquare ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; bool checkExists ( int arr [ ] , int N , int M , int K ) { int count = 0 ; for ( int i = 0 ; i < N - M ; i ++ ) { if ( arr [ i ] == arr [ i + M ] ) count ++ ; else count = 0 ; if ( count == M * ( K - 1 ) ) return true ; } return false ; } int main ( ) { int arr [ ] = { 2 , 1 , 2 , 1 , 1 , 1 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = 2 , K = 2 ; if ( checkExists ( arr , N , M , K ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CommonDigits ( int N , int M ) { int count = 0 ; int freq1 [ 10 ] = { 0 } ; int freq2 [ 10 ] = { 0 } ; while ( N > 0 ) { freq1 [ N % 10 ] ++ ; N = N / 10 ; } while ( M > 0 ) { freq2 [ M % 10 ] ++ ; M = M / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( freq1 [ i ] > 0 & freq2 [ i ] > 0 ) { count ++ ; } } return count ; } int main ( ) { int N = 748294 ; int M = 34298156 ; cout << CommonDigits ( N , M ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int CountPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( i * j ) == ( arr [ i ] * arr [ j ] ) ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 0 , 3 , 2 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CountPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxRemainder ( int A [ ] , int N , int K ) { unordered_set < int > even ; set < int > odd ; for ( int i = 0 ; i < N ; i ++ ) { int num = A [ i ] ; if ( num % 2 == 0 ) even . insert ( num % K ) ; else odd . insert ( num % K ) ; } int max_rem = 0 ; for ( int x : even ) { int y = K - 1 - x ; auto it = odd . upper_bound ( y ) ; if ( it != odd . begin ( ) ) { it -- ; max_rem = max ( max_rem , x + * it ) ; } } cout << max_rem ; } int main ( ) { int arr [ ] = { 3 , 2 , 4 , 11 , 6 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 7 ; maxRemainder ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( int src , vector < int > Adj [ ] , vector < bool > & visited , int level , int & distance ) { visited [ src ] = true ; distance = max ( distance , level ) ; for ( auto & child : Adj [ src ] ) { if ( child != src and visited [ child ] == false ) { dfs ( child , Adj , visited , level + 1 , distance ) ; } } visited [ src ] = false ; } int maximumLength ( vector < vector < int > > & mat , int V ) { int distance = 0 ; int N = ( int ) mat . size ( ) ; vector < int > Adj [ N ] ; vector < bool > visited ( N , false ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { Adj [ i ] . push_back ( j ) ; } } } dfs ( V , Adj , visited , 0 , distance ) ; return distance ; } int main ( ) { vector < vector < int > > mat = { { 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 } , { 0 , 1 , 0 , 0 } , { 0 , 1 , 0 , 0 } } ; int V = 2 ; cout << maximumLength ( mat , V ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLength ( string s , char i , char j ) { char required = i ; int length = 0 ; for ( char curr : s ) { if ( curr == required ) { length += 1 ; if ( required == i ) required = j ; else required = i ; } } return length ; } int minimumDeletions ( string S ) { int len = 0 ; int n = S . length ( ) ; for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { for ( char j = i + 1 ; j <= ' z ' ; j ++ ) { int newLen = findLength ( S , i , j ) ; len = max ( len , newLen ) ; } } return n - len ; } int main ( ) { string S = " adebbeeaebd " ; cout << minimumDeletions ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } int findMinX ( int A [ ] , int B [ ] , int N ) { int prod = 1 ; for ( int i = 0 ; i < N ; i ++ ) prod *= A [ i ] ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int pp = prod / A [ i ] ; result += B [ i ] * inv ( pp , A [ i ] ) * pp ; } return result % prod ; } int product ( int a [ ] , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= a [ i ] ; } return ans ; } void findSmallestInteger ( int A [ ] , int B [ ] , int P , int n ) { int Y = findMinX ( A , B , n ) ; int M = product ( A , n ) ; int K = ceil ( ( ( double ) P - ( double ) Y ) / ( double ) M ) ; int X = Y + K * M ; cout << X ; } int main ( ) { int A [ ] = { 3 , 4 , 5 } ; int B [ ] = { 2 , 3 , 1 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int P = 72 ; findSmallestInteger ( A , B , P , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool intersection ( int X1 , int Y1 , double R1 , int X2 , int Y2 , double R2 , int X3 , int Y3 , double R3 ) { double d12 = sqrt ( ( X1 - X2 ) * ( X1 - X2 ) + ( Y1 - Y2 ) * ( Y1 - Y2 ) ) ; double d13 = sqrt ( ( X1 - X3 ) * ( X1 - X3 ) + ( Y1 - Y3 ) * ( Y1 - Y3 ) ) ; double d23 = sqrt ( ( X2 - X3 ) * ( X2 - X3 ) + ( Y2 - Y3 ) * ( Y2 - Y3 ) ) ; if ( ( R1 + R2 < d12 ) || ( R1 + R3 < d13 ) || ( R2 + R3 < d23 ) ) { return false ; } else { if ( abs ( R1 - R2 ) >= d12 ) { if ( R1 < R2 ) { return R1 + R3 >= d13 ; } else { return R2 + R3 >= d23 ; } } else if ( abs ( R1 - R3 ) >= d13 ) { if ( R1 < R3 ) { return R1 + R2 >= d12 ; } else { return R2 + R3 >= d23 ; } } else if ( abs ( R2 - R3 ) >= d23 ) { if ( R2 < R3 ) { return R1 + R2 >= d12 ; } else { return R1 + R3 >= d13 ; } } else { double x121 , y121 , x122 , y122 , x131 , y131 , x132 , y132 , x231 , y231 , x232 , y232 , a , b ; a = ( R1 * R1 - R2 * R2 ) / ( 2 * d12 * d12 ) ; b = sqrt ( 2 * ( R1 * R1 + R2 * R2 ) / ( d12 * d12 ) - ( R1 * R1 - R2 * R2 ) * ( R1 * R1 - R2 * R2 ) / ( pow ( d12 , 4 ) ) - 1 ) / 2 ; x121 = ( X1 + X2 ) / 2.0 + a * ( X2 - X1 ) + b * ( Y2 - Y1 ) ; y121 = ( Y1 + Y2 ) / 2.0 + a * ( Y2 - Y1 ) + b * ( X1 - X2 ) ; if ( R3 >= sqrt ( ( x121 - X3 ) * ( x121 - X3 ) + ( y121 - Y3 ) * ( y121 - Y3 ) ) ) { return true ; } x122 = ( X1 + X2 ) / 2.0 + a * ( X2 - X1 ) - b * ( Y2 - Y1 ) ; y122 = ( Y1 + Y2 ) / 2.0 + a * ( Y2 - Y1 ) - b * ( X1 - X2 ) ; if ( R3 >= sqrt ( ( x122 - X3 ) * ( x122 - X3 ) + ( y122 - Y3 ) * ( y122 - Y3 ) ) ) { return true ; } a = ( R1 * R1 - R3 * R3 ) / ( 2 * d13 * d13 ) ; b = sqrt ( 2 * ( R1 * R1 + R3 * R3 ) / ( d13 * d13 ) - ( R1 * R1 - R3 * R3 ) * ( R1 * R1 - R3 * R3 ) / ( pow ( d13 , 4 ) ) - 1 ) / 2 ; x131 = ( X1 + X3 ) / 2.0 + a * ( X3 - X1 ) + b * ( Y3 - Y1 ) ; y131 = ( Y1 + Y3 ) / 2.0 + a * ( Y3 - Y1 ) + b * ( X1 - X3 ) ; if ( R2 >= sqrt ( ( x131 - X2 ) * ( x131 - X2 ) + ( y131 - Y2 ) * ( y131 - Y2 ) ) ) { return true ; } x132 = ( X1 + X3 ) / 2.0 + a * ( X3 - X1 ) - b * ( Y3 - Y1 ) ; y132 = ( Y1 + Y3 ) / 2.0 + a * ( Y3 - Y1 ) - b * ( X1 - X3 ) ; if ( R2 >= sqrt ( ( x132 - X2 ) * ( x132 - X2 ) + ( y132 - Y2 ) * ( y132 - Y2 ) ) ) { return true ; } a = ( R2 * R2 - R3 * R3 ) / ( 2 * d23 * d23 ) ; b = sqrt ( 2 * ( R2 * R2 + R3 * R3 ) / ( d23 * d23 ) - ( R2 * R2 - R3 * R3 ) * ( R2 * R2 - R3 * R3 ) / ( pow ( d23 , 4 ) ) - 1 ) / 2 ; x231 = ( X2 + X3 ) / 2.0 + a * ( X3 - X2 ) + b * ( Y3 - Y2 ) ; y231 = ( Y2 + Y3 ) / 2.0 + a * ( Y3 - Y2 ) + b * ( X2 - X3 ) ; if ( R1 >= sqrt ( ( x231 - X1 ) * ( x231 - X1 ) + ( y231 - Y1 ) * ( y231 - Y1 ) ) ) { return true ; } x232 = ( X2 + X3 ) / 2.0 + a * ( X3 - X2 ) - b * ( Y3 - Y2 ) ; y232 = ( Y2 + Y3 ) / 2.0 + a * ( Y3 - Y2 ) - b * ( X2 - X3 ) ; return R1 >= sqrt ( ( x232 - X1 ) * ( x232 - X1 ) + ( y232 - Y1 ) * ( y232 - Y1 ) ) ; } } } bool isGood ( double t , int N , int X [ ] , int Y [ ] , int V [ ] ) { if ( N >= 3 ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { if ( intersection ( X [ i ] , Y [ i ] , t * V [ i ] , X [ j ] , Y [ j ] , t * V [ j ] , X [ k ] , Y [ k ] , t * V [ k ] ) == false ) return false ; } } } return true ; } else { return sqrt ( ( X [ 0 ] - X [ 1 ] ) * ( X [ 0 ] - X [ 1 ] ) + ( Y [ 0 ] - Y [ 1 ] ) * ( Y [ 0 ] - Y [ 1 ] ) ) <= t * ( V [ 0 ] + V [ 1 ] ) ; } } void binarySearch ( int N , int X [ ] , int Y [ ] , int V [ ] ) { double tl = 0.0 , tu = 100000.0 , t ; for ( int i = 0 ; i < 1000 ; i ++ ) { t = ( tl + tu ) / 2.0 ; if ( isGood ( t , N , X , Y , V ) ) { tu = t ; } else { tl = t ; } } cout << fixed << setprecision ( 16 ) << tu << endl ; } int main ( ) { int N = 4 ; int X [ ] = { 1 , -3 , -1 , 2 } ; int Y [ ] = { 2 , 4 , -2 , -2 } ; int V [ ] = { 3 , 2 , 4 , 5 } ; binarySearch ( N , X , Y , V ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minJumps ( int arr [ ] , int jump [ ] , int N ) { int jumps = 0 ; int temp [ 1000 ] ; vector < pair < int , int > > vect ; for ( int i = 0 ; i < N ; i ++ ) { vect . push_back ( { arr [ i ] , i + 1 } ) ; } for ( int i = 0 ; i < N ; i ++ ) { temp [ arr [ i ] ] = jump [ i ] ; } sort ( vect . begin ( ) , vect . end ( ) ) ; for ( int i = 1 ; i < N ; i ++ ) { while ( vect [ i ] . second <= vect [ i - 1 ] . second ) { vect [ i ] = make_pair ( vect [ i ] . first , vect [ i ] . second + temp [ vect [ i ] . first ] ) ; jumps ++ ; } } cout << jumps << endl ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int jump [ ] = { 1 , 1 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minJumps ( arr , jump , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberOfGates ( string s ) { int N = s . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == ' . ' s [ i ] == ' + ' s [ i ] == '1' ) { ans ++ ; } } cout << ans ; } int main ( ) { string S = " ( 1 - A ) . B + C " ; numberOfGates ( S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumSwaps ( int arr [ ] , int N ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != i % 2 ) { if ( i % 2 == 0 ) { even ++ ; } else { odd ++ ; } } } if ( even != odd ) { cout << -1 ; } else { cout << even ; } } int main ( ) { int arr [ ] = { 3 , 2 , 7 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumSwaps ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestSubstring ( string a ) { vector < string > a1 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < a . size ( ) ; j ++ ) { if ( i != j ) a1 . push_back ( a . substr ( i , j + 1 ) ) ; } } map < string , int > a2 ; for ( string i : a1 ) a2 [ i ] ++ ; vector < string > freshlist ; for ( auto i : a2 ) { if ( i . second == 1 ) freshlist . push_back ( i . first ) ; } map < string , int > dictionary ; for ( auto i : freshlist ) { dictionary [ i ] = i . size ( ) ; } vector < int > newlist ; for ( auto i : dictionary ) newlist . push_back ( i . second ) ; int ans = INT_MAX ; for ( int i : newlist ) ans = min ( ans , i ) ; return ans ; } int main ( ) { string S = " ababaabba " ; cout << smallestSubstring ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CalculateValues ( int N ) { int A = 0 , B = 0 , C = 0 ; for ( C = 0 ; C < N / 7 ; C ++ ) { for ( B = 0 ; B < N / 5 ; B ++ ) { int A = N - 7 * C - 5 * B ; if ( A >= 0 && A % 3 == 0 ) { cout << " A ▁ = ▁ " << A / 3 << " , ▁ B ▁ = ▁ " << B << " , ▁ C ▁ = ▁ " << C << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int N = 19 ; CalculateValues ( 19 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mininsert ( int arr [ ] , int K , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = min ( arr [ i ] , arr [ i + 1 ] ) ; int b = max ( arr [ i ] , arr [ i + 1 ] ) ; while ( K * a < b ) { a *= K ; ans ++ ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 10 , 25 , 21 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << mininsert ( arr , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_triplet ( int arr [ ] , int n ) { for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { cout << i - 1 << " ▁ " << i << " ▁ " << i + 1 ; return ; } } cout << -1 ; } int main ( ) { int arr [ ] = { 4 , 3 , 5 , 2 , 1 , 6 } ; int N = sizeof ( arr ) / sizeof ( int ) ; print_triplet ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findConcatenatedNumbers ( vector < int > a , vector < int > b ) { bool ans = true ; int n1 = a . size ( ) ; int n2 = b . size ( ) ; unordered_map < int , int > cnt ; for ( int i = 0 ; i < n1 ; i ++ ) { cnt [ a [ i ] ] = 1 ; } for ( int i = 0 ; i < n2 ; i ++ ) { int left = b [ i ] ; int right = 0 ; int mul = 1 ; while ( left > 9 ) { right += ( left % 10 ) * mul ; left /= 10 ; mul *= 10 ; if ( cnt [ left ] == 1 && cnt [ right ] == 1 ) { ans = false ; cout << b [ i ] << " ▁ " ; } } } if ( ans ) cout << " - 1" ; } int main ( ) { vector < int > a = { 2 , 34 , 4 , 5 } ; vector < int > b = { 26 , 24 , 345 , 4 , 22 } ; findConcatenatedNumbers ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long ans = 0 ; vector < int > adj [ int ( 1e5 ) + 1 ] ; void dfsUtil ( int u , int par , int depth ) { for ( auto it : adj [ u ] ) { if ( it != par ) { dfsUtil ( it , u , depth + 1 ) ; } } ans += depth ; } void dfs ( int u , int par , int depth ) { dfsUtil ( u , par , depth ) ; cout << ans << endl ; } void countPairs ( vector < vector < int > > edges ) { for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } dfs ( 1 , 1 , 1 ) ; } int main ( ) { vector < vector < int > > edges = { { 1 , 2 } , { 1 , 3 } , { 2 , 4 } } ; countPairs ( edges ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class TreeNode { public : int val ; TreeNode * left , * right ; TreeNode ( int key ) { val = key ; left = right = NULL ; } } ; int convertBinaryToDecimal ( vector < int > arr ) { int ans = 0 ; for ( int i : arr ) ans = ( ans << 1 ) | i ; return ans ; } void decimalEquilvalentAtEachLevel ( TreeNode * root ) { int ans = 0 ; queue < TreeNode * > que ; que . push ( root ) ; while ( true ) { int length = que . size ( ) ; if ( length == 0 ) break ; vector < int > eachLvl ; while ( length > 0 ) { TreeNode * temp = que . front ( ) ; que . pop ( ) ; eachLvl . push_back ( temp -> val ) ; if ( temp -> left != NULL ) que . push ( temp -> left ) ; if ( temp -> right != NULL ) que . push ( temp -> right ) ; length -= 1 ; } ans += convertBinaryToDecimal ( eachLvl ) ; } cout << ans << endl ; } int main ( ) { TreeNode * root = new TreeNode ( 0 ) ; root -> left = new TreeNode ( 1 ) ; root -> right = new TreeNode ( 0 ) ; root -> left -> left = new TreeNode ( 0 ) ; root -> left -> right = new TreeNode ( 1 ) ; root -> right -> left = new TreeNode ( 1 ) ; root -> right -> right = new TreeNode ( 1 ) ; decimalEquilvalentAtEachLevel ( root ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minIncr ( int * arr , int n ) { int forEven = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) { if ( ( arr [ i ] % 2 ) == 0 ) forEven += 1 ; } else { if ( arr [ i ] % 2 ) forEven += 1 ; } } return min ( forEven , n - forEven ) ; } int main ( ) { int arr [ ] = { 1 , 4 , 6 , 8 , 9 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minIncr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void hasArrayTwoPairs ( int nums [ ] , int n , int target ) { sort ( nums , nums + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = target - nums [ i ] ; int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = low + ( ( high - low ) / 2 ) ; if ( nums [ mid ] > x ) { high = mid - 1 ; } else if ( nums [ mid ] < x ) { low = mid + 1 ; } else { if ( mid == i ) { if ( ( mid - 1 >= 0 ) && nums [ mid - 1 ] == x ) { cout << nums [ i ] << " , ▁ " ; cout << nums [ mid - 1 ] ; return ; } if ( ( mid + 1 < n ) && nums [ mid + 1 ] == x ) { cout << nums [ i ] << " , ▁ " ; cout << nums [ mid + 1 ] ; return ; } break ; } else { cout << nums [ i ] << " , ▁ " ; cout << nums [ mid ] ; return ; } } } } cout << -1 ; } int main ( ) { int A [ ] = { 0 , -1 , 2 , -3 , 1 } ; int X = -2 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; hasArrayTwoPairs ( A , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperations ( int arr [ ] , int N , int Q [ ] , int M ) { map < int , int > m1 , m2 ; int front = 0 , rear = 0 ; for ( int i = 0 ; i < N ; i ++ ) { front += arr [ i ] ; m1 . insert ( { arr [ i ] , front } ) ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { rear += arr [ i ] ; m2 . insert ( { arr [ i ] , rear } ) ; } for ( int i = 0 ; i < M ; i ++ ) { cout << min ( m1 [ Q [ i ] ] , m2 [ Q [ i ] ] ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 2 , 3 , 6 , 7 , 4 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q [ ] = { 7 , 6 } ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; minOperations ( arr , N , Q , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkAnagram ( string s1 , string s2 ) { vector < int > s2hash ( 26 , 0 ) ; vector < int > s1hash ( 26 , 0 ) ; int s1len = s1 . size ( ) ; int s2len = s2 . size ( ) ; if ( s1len > s2len ) return false ; int left = 0 , right = 0 ; while ( right < s1len ) { s1hash [ s1 [ right ] - ' a ' ] += 1 ; s2hash [ s2 [ right ] - ' a ' ] += 1 ; right ++ ; } right -= 1 ; while ( right < s2len ) { if ( s1hash == s2hash ) return true ; right ++ ; if ( right != s2len ) s2hash [ s2 [ right ] - ' a ' ] += 1 ; s2hash [ s2 [ left ] - ' a ' ] -= 1 ; left ++ ; } return false ; } int main ( ) { string s1 = " ab " ; string s2 = " bbpobac " ; if ( checkAnagram ( s1 , s2 ) ) cout << " YES STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canPlace ( string s , int n , int k ) { int cnt = 0 ; int i = 0 ; while ( i < n ) { if ( s [ i ] == '1' ) { i += 2 ; } else { if ( i == 0 ) { if ( s [ i + 1 ] == '0' ) { cnt ++ ; i += 2 ; } else i ++ ; } else if ( i == n - 1 ) { if ( s [ i - 1 ] == '0' ) { cnt ++ ; i += 2 ; } else i ++ ; } else { if ( s [ i + 1 ] == '0' && s [ i - 1 ] == '0' ) { cnt ++ ; i += 2 ; } else i ++ ; } } } if ( cnt >= k ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { string S = "10001" ; int K = 1 ; int N = S . size ( ) ; canPlace ( S , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxIntervals ( vector < pair < int , int > > v , int n ) { int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int c = n ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ i ] . second < v [ j ] . first v [ i ] . first > v [ j ] . second ) { c -- ; } } maxi = max ( c , maxi ) ; } cout << maxi ; } int main ( ) { vector < pair < int , int > > arr = { { 1 , 2 } , { 3 , 4 } , { 2 , 5 } } ; int N = arr . size ( ) ; findMaxIntervals ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void smallestNumber ( int arr [ ] , int len ) { int maxi = 0 ; for ( int i = 0 ; i < len ; i ++ ) { maxi = std :: max ( maxi , arr [ i ] ) ; } int ans = -1 ; for ( int i = 2 ; i < maxi + 2 ; i ++ ) { bool flag = true ; for ( int j = 0 ; j < len ; j ++ ) { if ( arr [ j ] % i == 0 ) { flag = false ; break ; } } if ( flag ) { ans = i ; break ; } } cout << ans ; } int main ( ) { int arr [ ] = { 3 , 2 , 6 , 9 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; smallestNumber ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findDuplicate ( string str , int N ) { int first = 0 ; int second = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( first & ( 1 << ( str [ i ] - ' a ' ) ) ) { second = second | ( 1 << ( str [ i ] - ' a ' ) ) ; } else { first = first | ( 1 << ( str [ i ] - ' a ' ) ) ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( ( first & ( 1 << i ) ) && ( second & ( 1 << i ) ) ) { cout << char ( i + ' a ' ) << " ▁ " ; } } } int main ( ) { string str = " geeksforgeeks " ; int N = str . length ( ) ; findDuplicate ( str , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void calculateQuery ( int arr [ ] , int N , int query [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int X = query [ i ] ; int sum_start = 0 , sum_end = 0 ; for ( int j = 0 ; j < N ; j ++ ) { sum_start += arr [ j ] ; if ( arr [ j ] == X ) break ; } for ( int j = N - 1 ; j >= 0 ; j -- ) { sum_end += arr [ j ] ; if ( arr [ j ] == X ) break ; } cout << min ( sum_end , sum_start ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 2 , 3 , 6 , 7 , 4 , 5 , 30 } ; int queries [ ] = { 6 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; calculateQuery ( arr , N , queries , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void calculateQuery ( int arr [ ] , int N , int query [ ] , int M ) { int prefix = 0 , suffix = 0 ; unordered_map < int , pair < int , int > > mp ; for ( int i = 0 ; i < N ; i ++ ) { prefix += arr [ i ] ; mp [ arr [ i ] ] . first = prefix ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { suffix += arr [ i ] ; mp [ arr [ i ] ] . second = suffix ; } for ( int i = 0 ; i < M ; i ++ ) { int X = query [ i ] ; cout << min ( mp [ X ] . first , mp [ X ] . second ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 2 , 3 , 6 , 7 , 4 , 5 , 30 } ; int queries [ ] = { 6 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; calculateQuery ( arr , N , queries , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int oddOneOut ( int arr [ ] , int N ) { int odd = 0 , even = 0 ; int lastOdd = 0 , lastEven = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { even ++ ; lastEven = i ; } else { odd ++ ; lastOdd = i ; } } if ( odd == 1 ) { cout << lastOdd << endl ; } else { cout << lastEven << endl ; } } int main ( ) { int arr [ ] = { 2 , 4 , 7 , 8 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; oddOneOut ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isGreaterEqual ( int N , int X ) { return ( N * 1LL * ( N + 1 ) / 2 ) >= X ; } int minimumPossible ( int X ) { for ( int i = 1 ; i <= X ; i ++ ) { if ( isGreaterEqual ( i , X ) ) return i ; } } int main ( ) { int X = 14 ; cout << minimumPossible ( X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define Max  1000005 NEW_LINE bool CheckDivByAllDigits ( int number ) { int n = number ; while ( n > 0 ) { if ( n % 10 ) if ( number % ( n % 10 ) ) { return false ; } n /= 10 ; } return true ; } void cntNumInRang ( int arr [ ] [ 2 ] , int N ) { int prefCntDiv [ Max ] = { 0 } ; for ( int i = 1 ; i <= Max ; i ++ ) { prefCntDiv [ i ] = prefCntDiv [ i - 1 ] + ( CheckDivByAllDigits ( i ) ) ; } for ( int i = 0 ; i < N ; i ++ ) cout << ( prefCntDiv [ arr [ i ] [ 1 ] ] - prefCntDiv [ arr [ i ] [ 0 ] - 1 ] ) << " ▁ " ; } int main ( ) { int arr [ ] [ 2 ] = { { 1 , 5 } , { 12 , 14 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cntNumInRang ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int arrayNesting ( vector < int > arr ) { int res = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] == i ) { res = max ( res , 1 ) ; } else { int count = 0 ; int curr_index = i ; while ( arr [ curr_index ] != curr_index ) { int next_index = arr [ curr_index ] ; arr [ curr_index ] = curr_index ; curr_index = next_index ; count ++ ; } res = max ( res , count ) ; } } return res ; } int main ( ) { vector < int > arr = { 5 , 4 , 0 , 3 , 1 , 6 , 2 } ; int res = arrayNesting ( arr ) ; cout << res ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 2e5 ; vector < long long > prime ; void Sieve ( ) { prime . clear ( ) ; vector < bool > p ( N + 1 , true ) ; p [ 0 ] = p [ 1 ] = false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( p [ i ] == true ) { for ( int j = i * i ; j <= N ; j += i ) { p [ j ] = false ; } } } for ( int i = 1 ; i < N ; i ++ ) { if ( p [ i ] ) { prime . push_back ( 1LL * pow ( i , 4 ) ) ; } } } void countNumbers ( long long int L , long long int R ) { int Count = 0 ; for ( int p : prime ) { if ( p >= L && p <= R ) { Count ++ ; } } cout << Count << endl ; } int main ( ) { long long L = 16 , R = 85000 ; Sieve ( ) ; countNumbers ( L , R ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int getCount ( int rows , int columns , int A [ ] [ 2 ] ) { int res = 0 ; for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = i + 1 ; j < rows ; j ++ ) { if ( A [ i ] [ 0 ] * 1LL * A [ j ] [ 1 ] == A [ i ] [ 1 ] * 1LL * A [ j ] [ 0 ] ) { res ++ ; } } } return res ; } int main ( ) { int A [ ] [ 2 ] = { { 4 , 8 } , { 10 , 20 } , { 15 , 30 } , { 3 , 6 } } ; int columns = 2 ; int rows = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << getCount ( rows , columns , A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Min_Score_Index ( int N , vector < int > A ) { vector < int > Score ( N , 0 ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] + i < N ) Score [ i ] = A [ i ] * Score [ A [ i ] + i ] ; else Score [ i ] = A [ i ] ; } int min_value = INT_MAX ; for ( int i : Score ) min_value = min ( i , min_value ) ; int ind = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( Score [ i ] == min_value ) ind = i ; } cout << ( ind ) ; } int main ( ) { int N = 5 ; vector < int > A = { 1 , 2 , 3 , 4 , 5 } ; Min_Score_Index ( N , A ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minLength ( string & S , string & T , int N , int M ) { string temp ; int subtract = 0 ; for ( int i = 0 ; i < N ; ++ i ) { temp . push_back ( S [ i ] ) ; if ( temp . size ( ) >= M ) { if ( temp . substr ( temp . size ( ) - M , M ) == T ) { subtract += M ; int cnt = 0 ; while ( cnt != M ) { temp . pop_back ( ) ; ++ cnt ; } } } } cout << ( N - subtract ) << " STRNEWLINE " ; } int main ( ) { string S = " aabcbcbd " , T = " abc " ; int N = S . size ( ) ; int M = T . size ( ) ; minLength ( S , T , N , M ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumCount ( int arr1 [ ] , int arr2 [ ] , int s1 , int s2 ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < s1 ; i ++ ) { sum1 += arr1 [ i ] ; } for ( int j = 0 ; j < s2 ; j ++ ) { sum2 += arr2 [ j ] ; } int len = 0 ; if ( s1 >= s2 ) { len = s2 ; } else { len = s1 ; } sort ( arr1 , arr1 + s1 ) ; sort ( arr2 , arr2 + s2 ) ; int j = 0 , k = s2 - 1 , count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( sum1 <= sum2 ) { if ( arr2 [ k ] >= arr1 [ i ] ) { int dif1 = arr1 [ j ] , dif2 = arr2 [ k ] ; sum1 -= dif1 ; sum1 += dif2 ; sum2 -= dif2 ; sum2 += dif1 ; j ++ ; k -- ; count ++ ; } else { break ; } } else { break ; } } return count ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 2 , 4 } ; int arr2 [ ] = { 6 , 7 , 8 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << maximumCount ( arr1 , arr2 , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; static bool isValidDigit ( int digit , int K ) { while ( K != 0 ) { if ( K % 10 == digit ) { return true ; } K = K / 10 ; } return false ; } int noOfValidNumbers ( int K , int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int no = arr [ i ] ; bool flag = true ; while ( no != 0 ) { int digit = no % 10 ; if ( ! isValidDigit ( digit , K ) ) { flag = false ; break ; } no = no / 10 ; } if ( flag == true ) { count ++ ; } } return count ; } int main ( ) { int K = 12 ; int arr [ ] = { 1 , 12 , 1222 , 13 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << noOfValidNumbers ( K , arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumIndex ( vector < int > & arr , vector < int > & Q ) { int N = arr . size ( ) ; int M = Q . size ( ) ; vector < pair < int , int > > storeArrIdx ; vector < int > minIdx ( N ) ; for ( int i = 0 ; i < N ; ++ i ) { storeArrIdx . push_back ( { arr [ i ] , i } ) ; } sort ( arr . begin ( ) , arr . end ( ) ) ; sort ( storeArrIdx . begin ( ) , storeArrIdx . end ( ) ) ; minIdx [ N - 1 ] = storeArrIdx [ N - 1 ] . second ; for ( int i = N - 2 ; i >= 0 ; i -- ) { minIdx [ i ] = min ( minIdx [ i + 1 ] , storeArrIdx [ i ] . second ) ; } for ( int i = 0 ; i < M ; i ++ ) { int pos = lower_bound ( arr . begin ( ) , arr . end ( ) , Q [ i ] ) - arr . begin ( ) ; if ( pos == N ) { cout << -1 << " ▁ " ; continue ; } cout << minIdx [ pos ] << " ▁ " ; } } int main ( ) { vector < int > arr = { 1 , 9 } ; vector < int > Q = { 7 , 10 , 0 } ; minimumIndex ( arr , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSubarrayExistUtil ( int arr [ ] , int K , int N ) { int totalXOR = 0 ; int SubarrayXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) totalXOR ^= arr [ i ] ; for ( int i = 0 ; i < K ; i ++ ) SubarrayXOR ^= arr [ i ] ; if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) return true ; for ( int i = K ; i < N ; i ++ ) { SubarrayXOR ^= arr [ i ] ; SubarrayXOR ^= arr [ i - 1 ] ; if ( SubarrayXOR == ( totalXOR ^ SubarrayXOR ) ) return true ; } return false ; } void isSubarrayExist ( int arr [ ] , int K , int N ) { if ( isSubarrayExistUtil ( arr , K , N ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; } int32_t main ( ) { int arr [ ] = { 2 , 3 , 3 , 5 , 7 , 7 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; isSubarrayExist ( arr , K , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int L , int R ) { int count_even ; if ( L % 2 == 0 ) { count_even = ( R / 2 ) - ( L / 2 ) + 1 ; } else { count_even = ( R / 2 ) - ( L / 2 ) ; } int count_odd ; if ( L % 2 == 0 ) { count_odd = ( ( R + 1 ) / 2 ) - ( ( L + 1 ) / 2 ) ; } else { count_odd = ( ( R + 1 ) / 2 ) - ( ( L + 1 ) / 2 ) + 1 ; } count_even *= count_even ; count_odd *= count_odd ; cout << count_even + count_odd ; } int main ( ) { int L = 1 , R = 3 ; countPairs ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getDefiniteFinds ( vector < int > & arr ) { int n = arr . size ( ) ; vector < int > smallestRight ( n + 1 ) ; smallestRight [ n ] = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { smallestRight [ i ] = min ( smallestRight [ i + 1 ] , arr [ i ] ) ; } int mn = INT_MIN ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mn < arr [ i ] and arr [ i ] < smallestRight [ i + 1 ] ) { ans ++ ; } mn = max ( arr [ i ] , mn ) ; } return ans ; } int main ( ) { vector < int > arr = { 5 , 4 , 9 } ; cout << getDefiniteFinds ( arr ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Count_numbers ( int L , int R ) { int count = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) count += 1 ; cout << count << endl ; } int main ( ) { int L = 6 , R = 30 ; Count_numbers ( L , R ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkReverse ( int leftSum , int rightSum ) { int rev = 0 ; int temp = rightSum ; while ( temp != 0 ) { rev = ( rev * 10 ) + ( temp % 10 ) ; temp /= 10 ; } if ( rev == leftSum ) { return true ; } return false ; } int findIndex ( int arr [ ] , int N ) { int rightSum = 0 ; int leftSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { rightSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { rightSum -= arr [ i ] ; if ( checkReverse ( leftSum , rightSum ) ) { return i ; } leftSum += arr [ i ] ; } return -1 ; } int main ( ) { int arr [ ] = { 5 , 7 , 3 , 6 , 4 , 9 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findIndex ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumTime ( int * arr , int n ) { int sum = 0 ; int T = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } cout << max ( 2 * T , sum ) ; } int main ( ) { int arr [ ] = { 2 , 8 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumTime ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findClosest ( int N , int target ) { int closest = -1 ; int diff = INT_MAX ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( N / i == i ) { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } } else { if ( abs ( target - i ) < diff ) { diff = abs ( target - i ) ; closest = i ; } if ( abs ( target - N / i ) < diff ) { diff = abs ( target - N / i ) ; closest = N / i ; } } } } cout << closest ; } int main ( ) { int N = 16 , X = 5 ; findClosest ( N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCS ( vector < int > & firstArr , vector < int > & secondArr ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < firstArr . size ( ) ; i ++ ) { mp [ firstArr [ i ] ] = i + 1 ; } vector < int > tempArr ; for ( int i = 0 ; i < secondArr . size ( ) ; i ++ ) { if ( mp . find ( secondArr [ i ] ) != mp . end ( ) ) { tempArr . push_back ( mp [ secondArr [ i ] ] ) ; } } vector < int > tail ; tail . push_back ( tempArr [ 0 ] ) ; for ( int i = 1 ; i < tempArr . size ( ) ; i ++ ) { if ( tempArr [ i ] > tail . back ( ) ) tail . push_back ( tempArr [ i ] ) ; else if ( tempArr [ i ] < tail [ 0 ] ) tail [ 0 ] = tempArr [ i ] ; else { auto it = lower_bound ( tail . begin ( ) , tail . end ( ) , tempArr [ i ] ) ; * it = tempArr [ i ] ; } } return ( int ) tail . size ( ) ; } int main ( ) { vector < int > firstArr = { 3 , 5 , 1 , 8 } ; vector < int > secondArr = { 3 , 3 , 5 , 3 , 8 } ; cout << LCS ( firstArr , secondArr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int * arr , int N ) { vector < int > zero_i ; vector < int > one_i ; unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero_i . push_back ( i + 1 ) ; else if ( arr [ i ] == 1 ) one_i . push_back ( i + 1 ) ; else mp [ i + 1 ] = 1 ; } int total = zero_i . size ( ) * one_i . size ( ) * mp . size ( ) ; for ( int i = 0 ; i < zero_i . size ( ) ; i ++ ) { for ( int j = 0 ; j < one_i . size ( ) ; j ++ ) { int p = zero_i [ i ] ; int q = one_i [ j ] ; int r = 2 * p - q ; if ( mp [ r ] > 0 ) total -- ; r = 2 * q - p ; if ( mp [ r ] > 0 ) total -- ; r = ( p + q ) / 2 ; if ( mp [ r ] > 0 && abs ( r - p ) == abs ( r - q ) ) total -- ; } } cout << total ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countTriplets ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrimeFactors ( int N ) { stack < int > st ; int i = 2 ; while ( N != 1 ) { if ( N % i == 0 ) { st . push ( i ) ; while ( N % i == 0 ) { N = N / i ; } } i ++ ; } while ( ! st . empty ( ) ) { printf ( " % d ▁ " , st . top ( ) ) ; st . pop ( ) ; } } int main ( ) { int N = 8 ; PrimeFactors ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( long long int A , long long int N ) { int count = 0 ; if ( A == 1 ) return 0 ; while ( N ) { count ++ ; N /= A ; } return count ; } void Pairs ( long long int N , long long int A , long long int B ) { int powerA , powerB ; powerA = power ( A , N ) ; powerB = power ( B , N ) ; long long int intialB = B , intialA = A ; A = 1 ; for ( int i = 0 ; i <= powerA ; i ++ ) { B = 1 ; for ( int j = 0 ; j <= powerB ; j ++ ) { if ( B == N - A ) { cout << i << " ▁ " << j << endl ; return ; } B *= intialB ; } A *= intialA ; } cout << -1 << endl ; return ; } int main ( ) { long long int N = 106 , A = 3 , B = 5 ; Pairs ( N , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void minSum ( int N ) { ll low = 0 , high = 1e9 ; while ( low + 1 < high ) { ll mid = low + ( high - low ) / 2 ; if ( mid * mid >= N ) { high = mid ; } else { low = mid ; } } ll first = high ; low = 0 ; high = 1e9 ; while ( low + 1 < high ) { ll mid = low + ( high - low ) / 2 ; if ( first * mid > N ) { high = mid ; } else { low = mid ; } } ll second = high ; cout << first + second ; } int main ( ) { int N = 10 ; minSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minSum ( int N ) { int ans = ceil ( 2 * sqrt ( N + 1 ) ) ; cout << ans ; } int main ( ) { int N = 10 ; minSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INF  1000000 NEW_LINE int pref [ 500005 ] ; int suf [ 500005 ] ; int MAX [ 500005 ] ; void build ( int a [ ] , int tl , int tr , int v ) { if ( tl == tr ) { MAX [ v ] = a [ tl ] ; pref [ v ] = a [ tl ] ; suf [ v ] = a [ tl ] ; } else { int tm = ( tl + tr ) / 2 ; build ( a , tl , tm , v * 2 ) ; build ( a , tm + 1 , tr , v * 2 + 1 ) ; MAX [ v ] = max ( MAX [ v * 2 ] , max ( MAX [ v * 2 + 1 ] , suf [ v * 2 ] + pref [ v * 2 + 1 ] ) ) ; pref [ v ] = max ( pref [ v * 2 ] , pref [ 2 * v ] + ( pref [ 2 * v ] == tm - tl + 1 ) * pref [ v * 2 + 1 ] ) ; suf [ v ] = max ( suf [ v * 2 + 1 ] , suf [ 2 * v + 1 ] + suf [ v * 2 ] * ( suf [ 2 * v + 1 ] == tr - tm ) ) ; } } void update ( int a [ ] , int pos , int tl , int tr , int v ) { if ( tl > pos tr < pos ) { return ; } if ( tl == tr && tl == pos ) { MAX [ v ] = a [ pos ] ; pref [ v ] = a [ pos ] ; suf [ v ] = a [ pos ] ; } else { int tm = ( tl + tr ) / 2 ; update ( a , pos , tl , tm , v * 2 ) ; update ( a , pos , tm + 1 , tr , v * 2 + 1 ) ; MAX [ v ] = max ( MAX [ v * 2 ] , max ( MAX [ v * 2 + 1 ] , suf [ v * 2 ] + pref [ v * 2 + 1 ] ) ) ; pref [ v ] = max ( pref [ v * 2 ] , pref [ 2 * v ] + ( pref [ 2 * v ] == tm - tl + 1 ) * pref [ v * 2 + 1 ] ) ; suf [ v ] = max ( suf [ v * 2 + 1 ] , suf [ 2 * v + 1 ] + ( suf [ 2 * v + 1 ] == tr - tm ) * suf [ v * 2 ] ) ; } } void solveQueries ( int arr [ ] , int n , vector < vector < int > > Q , int k ) { int cntQuery = Q . size ( ) ; build ( arr , 0 , n - 1 , 1 ) ; for ( int i = 0 ; i < cntQuery ; i ++ ) { if ( Q [ i ] [ 0 ] == 1 ) { cout << MAX [ 1 ] << " ▁ " ; } else { arr [ Q [ i ] [ 1 ] - 1 ] ^= 1 ; update ( arr , Q [ i ] [ 1 ] - 1 , 0 , n - 1 , 1 ) ; } } } int main ( ) { int N = 10 ; int arr [ ] = { 1 , 1 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 1 } ; vector < vector < int > > Q = { { 1 } , { 2 , 3 } , { 1 } } ; int K = 3 ; solveQueries ( arr , N , Q , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countFreq ( int N , int K ) { int count = 0 ; while ( N > 0 ) { if ( N % 10 == K ) { count ++ ; } N = N / 10 ; } return count ; } int findElementUtil ( int arr [ ] , int N , int K ) { int c ; int max ; int ele ; max = 0 ; for ( int i = 0 ; i < N ; i ++ ) { c = countFreq ( arr [ i ] , K ) ; if ( c > max ) { max = c ; ele = arr [ i ] ; } } if ( max == 0 ) return -1 ; else return ele ; } void findElement ( int arr [ ] , int N , int K ) { int ele = findElementUtil ( arr , N , K ) ; if ( ele == -1 ) cout << " - 1" ; else cout << ele ; } int main ( ) { int K = 3 ; int arr [ ] = { 3 , 77 , 343 , 456 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElement ( arr , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDeletions ( vector < pair < int , int > > & v , int n ) { int minDel = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int L = v [ i ] . first ; int R = v [ i ] . second ; int Count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( v [ j ] . first >= L && v [ j ] . second <= R ) { Count += 1 ; } } minDel = min ( minDel , n - Count ) ; } return minDel ; } int main ( ) { vector < pair < int , int > > v ; v . push_back ( { 1 , 3 } ) ; v . push_back ( { 4 , 12 } ) ; v . push_back ( { 5 , 8 } ) ; v . push_back ( { 13 , 20 } ) ; int N = v . size ( ) ; cout << findMinDeletions ( v , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxEvenIntegers ( int arr [ ] , int N , int M ) { int curr = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( arr [ i ] % 2 == 0 ) curr ++ ; } int ans = curr ; for ( int i = M ; i < N ; i ++ ) { if ( arr [ i - M ] % 2 == 0 ) { curr -- ; } if ( arr [ i ] % 2 == 0 ) curr ++ ; ans = max ( ans , curr ) ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 7 , 6 } ; int M = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxEvenIntegers ( arr , N , M ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countNumbers ( int n , int d ) { int total = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int x = i ; while ( x > 0 ) { if ( x % 8 == d ) { total ++ ; break ; } x = x / 8 ; } } cout << total ; } int main ( ) { int n = 20 , d = 7 ; countNumbers ( n , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int build ( int tree [ ] , int * A , int start , int end , int node ) { if ( start == end ) { tree [ node ] = A [ start ] ; return tree [ node ] ; } int mid = ( start + end ) / 2 ; int X = build ( tree , A , start , mid , 2 * node + 1 ) ; int Y = build ( tree , A , mid + 1 , end , 2 * node + 2 ) ; return tree [ node ] = min ( X , Y ) ; } int query ( int tree [ ] , int start , int end , int l , int r , int node ) { if ( start > r end < l ) return INT_MAX ; if ( start >= l && end <= r ) return tree [ node ] ; int mid = ( start + end ) / 2 ; int X = query ( tree , start , mid , l , r , 2 * node + 1 ) ; int Y = query ( tree , mid + 1 , end , l , r , 2 * node + 2 ) ; return min ( X , Y ) ; } int longestSubArray ( int * A , int N , int K ) { int res = 1 ; int preSum [ N + 1 ] ; preSum [ 0 ] = A [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) preSum [ i + 1 ] = preSum [ i ] + A [ i ] ; int tree [ 4 * N + 5 ] ; build ( tree , A , 0 , N - 1 , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { int start = i ; int end = N - 1 ; int mid ; int max_index = i ; while ( start <= end ) { mid = ( start + end ) / 2 ; int min_element = query ( tree , 0 , N - 1 , i , mid , 0 ) ; int expected_sum = ( mid - i + 1 ) * min_element ; int actual_sum = preSum [ mid + 1 ] - preSum [ i ] ; if ( actual_sum - expected_sum <= K ) { start = mid + 1 ; max_index = max ( max_index , mid ) ; } else { end = mid - 1 ; } } res = max ( res , max_index - i + 1 ) ; } return res ; } int main ( ) { int arr [ ] = { 1 , 7 , 3 , 4 , 5 , 6 } ; int k = 6 ; int n = 6 ; cout << longestSubArray ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestIndexArrayElementsFlip ( int arr [ ] , int N ) { int pos = -1 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] *= -1 ; int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { sum += arr [ j ] ; } if ( sum == 0 ) { pos = i ; break ; } else { arr [ i ] *= -1 ; } } return pos ; } int main ( ) { int arr [ ] = { 1 , 3 , -5 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << smallestIndexArrayElementsFlip ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestIndexArrayElementsFlip ( int arr [ ] , int N ) { int pos = -1 ; int ArrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ArrSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( 2 * arr [ i ] == ArrSum ) { pos = i ; break ; } } return pos ; } int main ( ) { int arr [ ] = { 1 , 3 , -5 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << smallestIndexArrayElementsFlip ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string make_string_S_to_T ( string S , string T ) { bool possible = false ; int M = T . length ( ) ; int N = S . length ( ) ; for ( int i = 0 ; i <= M ; i ++ ) { int prefix_length = i ; int suffix_length = M - i ; string prefix = S . substr ( 0 , prefix_length ) ; string suffix = S . substr ( N - suffix_length , suffix_length ) ; if ( prefix + suffix == T ) { possible = true ; break ; } } if ( possible ) return " YES " ; else return " NO " ; } int main ( ) { string S = " ababcdcd " ; string T = " abcd " ; cout << make_string_S_to_T ( S , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSum ( vector < int > a ) { int ans = 0 ; for ( int low = 0 ; low < a . size ( ) ; low ++ ) { for ( int high = low ; high < a . size ( ) ; high ++ ) { int count = 0 ; int maxNumber = 0 ; for ( int i = low ; i <= high ; i ++ ) { if ( a [ i ] == maxNumber ) count ++ ; else if ( a [ i ] > maxNumber ) { maxNumber = a [ i ] ; count = 1 ; } } ans += maxNumber * ( ( count % 2 == 0 ) ? 2 : 1 ) ; } } cout << ( ans ) ; } int main ( ) { vector < int > arr = { 2 , 1 , 4 , 4 , 2 } ; findSum ( arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int * arr , int n ) { unordered_map < int , int > mp1 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; mp1 [ sum ] += 1 ; } sum = 0 ; int ans = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( mp1 . find ( sum ) != mp1 . end ( ) ) { ans += mp1 [ sum ] ; } } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isMagic ( int num ) { return ( num % 9 == 1 ) ; } bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } void find ( int L [ ] , int R [ ] , int q ) { int dp [ 1000005 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 0 ; for ( int i = 1 ; i < 1000005 ; i ++ ) { if ( isComposite ( i ) && isMagic ( i ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = dp [ i - 1 ] ; } for ( int i = 0 ; i < q ; i ++ ) cout << dp [ R [ i ] ] - dp [ L [ i ] - 1 ] << endl ; } int main ( ) { int L [ ] = { 10 , 3 } ; int R [ ] = { 100 , 2279 } ; int Q = 2 ; find ( L , R , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSmallestInteger ( int arr [ ] , int N , int K ) { int left = 1 ; int right = * max_element ( arr , arr + N ) ; while ( left < right ) { int mid = ( left + right ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += ( arr [ i ] + mid - 1 ) / mid ; } if ( sum > K ) { left = mid + 1 ; } else { right = mid ; } } return left ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ; int K = 6 ; cout << findSmallestInteger ( arr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimum_deci_binary_number ( string s ) { int m = INT_MIN ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { int temp = s [ i ] - '0' ; if ( temp > m ) { m = temp ; } } return m ; } int main ( ) { string S = "31" ; cout << minimum_deci_binary_number ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperations ( int arr [ ] , int n ) { int flips = 0 ; for ( int i = 0 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 1 ) { continue ; } while ( i < n && arr [ i ] % 2 == 0 ) { i += 2 ; } flips ++ ; } for ( int i = 1 ; i < n ; i += 2 ) { if ( arr [ i ] % 2 == 1 ) { continue ; } while ( i < n && arr [ i ] % 2 == 0 ) { i += 2 ; } flips ++ ; } cout << flips ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 3 , 5 , 3 , 2 } ; int N = sizeof ( arr ) / sizeof ( int ) ; minOperations ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexicographicallyMax ( string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; int beg = i ; int end = i ; if ( s [ i ] == '1' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] == '1' ) count ++ ; if ( count % 2 == 0 && count != 0 ) { end = j ; break ; } } reverse ( s . begin ( ) + beg , s . begin ( ) + end + 1 ) ; } cout << s << " STRNEWLINE " ; } int main ( ) { string S = "0101" ; lexicographicallyMax ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumReverse ( string s , int n ) { int k = 0 , l = 0 ; int sum1 = 0 , sum0 = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) sum1 ++ ; else sum0 ++ ; if ( s [ i ] == s [ i - 1 ] && s [ i ] == '0' ) k ++ ; else if ( s [ i ] == s [ i - 1 ] && s [ i ] == '1' ) l ++ ; } if ( s [ 0 ] == '1' ) sum1 ++ ; sum0 ++ ; if ( abs ( sum1 - sum0 ) > 1 ) return -1 ; return max ( k , l ) ; } int main ( ) { string S = "10001" ; int N = S . size ( ) ; cout << minimumReverse ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxPairs ( int nums [ ] , int n , int k ) { sort ( nums , nums + n ) ; int result = 0 ; int start = 0 , end = n - 1 ; while ( start < end ) { if ( nums [ start ] + nums [ end ] > k ) end -- ; else if ( nums [ start ] + nums [ end ] < k ) start ++ ; else { start ++ ; end -- ; result ++ ; } } cout << result << endl ; ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; maxPairs ( arr , n , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; void maxPairs ( vector < int > nums , int k ) { map < int , int > m ; int result = 0 ; for ( auto i : nums ) { if ( m . find ( i ) != m . end ( ) && m [ i ] > 0 ) { m [ i ] = m [ i ] - 1 ; result ++ ; } else { m [ k - i ] = m [ k - i ] + 1 ; } } cout << result ; } int main ( ) { vector < int > arr = { 1 , 2 , 3 , 4 } ; int K = 5 ; maxPairs ( arr , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeIndicesToMakeSumEqual ( vector < int > & arr ) { int N = arr . size ( ) ; vector < int > odd ( N , 0 ) ; vector < int > even ( N , 0 ) ; even [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { odd [ i ] = odd [ i - 1 ] ; even [ i ] = even [ i - 1 ] ; if ( i % 2 == 0 ) { even [ i ] += arr [ i ] ; } else { odd [ i ] += arr [ i ] ; } } bool find = 0 ; int p = odd [ N - 1 ] ; int q = even [ N - 1 ] - arr [ 0 ] ; if ( p == q ) { cout << "0 ▁ " ; find = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { p = even [ N - 1 ] - even [ i - 1 ] - arr [ i ] + odd [ i - 1 ] ; q = odd [ N - 1 ] - odd [ i - 1 ] + even [ i - 1 ] ; } else { q = odd [ N - 1 ] - odd [ i - 1 ] - arr [ i ] + even [ i - 1 ] ; p = even [ N - 1 ] - even [ i - 1 ] + odd [ i - 1 ] ; } if ( p == q ) { find = 1 ; cout << i << " ▁ " ; } } if ( ! find ) { cout << -1 ; } } int main ( ) { vector < int > arr = { 4 , 1 , 6 , 2 } ; removeIndicesToMakeSumEqual ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; sort ( arr , arr + N ) ; int i = 0 ; int j = N - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] == K ) { while ( i < j && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } while ( i < j && arr [ j ] == arr [ j - 1 ] ) { j -- ; } cntPairs += 1 ; i ++ ; j -- ; } else if ( arr [ i ] + arr [ j ] < K ) { i ++ ; } else { j -- ; } } return cntPairs ; } int main ( ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 13 ; cout << cntDisPairs ( arr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntDisPairs ( int arr [ ] , int N , int K ) { int cntPairs = 0 ; unordered_map < int , int > cntFre ; for ( int i = 0 ; i < N ; i ++ ) { cntFre [ arr [ i ] ] ++ ; } for ( auto it : cntFre ) { int i = it . first ; if ( 2 * i == K ) { if ( cntFre [ i ] > 1 ) cntPairs += 2 ; } else { if ( cntFre [ K - i ] ) { cntPairs += 1 ; } } } cntPairs = cntPairs / 2 ; return cntPairs ; } int main ( ) { int arr [ ] = { 5 , 6 , 5 , 7 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 13 ; cout << cntDisPairs ( arr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntPairsInTwoArray ( int arr [ ] , int brr [ ] , int N , int M ) { int cntOddArr = 0 ; int cntOddBrr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) { cntOddArr += 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { if ( brr [ i ] & 1 ) { cntOddBrr += 1 ; } } return ( N * M ) - ( cntOddArr * cntOddBrr ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int brr [ ] = { 1 , 2 } ; int M = sizeof ( brr ) / sizeof ( brr [ 0 ] ) ; cout << cntPairsInTwoArray ( arr , brr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void max_freq ( int arr [ ] , int N ) { int Max = * max_element ( arr , arr + N ) ; int Min = * min_element ( arr , arr + N ) ; int freq [ Max - Min + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] - Min ] ++ ; } int maxSum = 0 ; for ( int i = 0 ; i < ( Max - Min - 1 ) ; i ++ ) { int val = freq [ i ] + freq [ i + 1 ] + freq [ i + 2 ] ; maxSum = max ( maxSum , val ) ; } cout << maxSum << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 3 , 1 , 4 , 1 , 5 , 9 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; max_freq ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binary_search ( vector < pair < int , int > > vec , int n , int a ) { int low , high , mid ; low = 0 ; high = n - 1 ; while ( low < high ) { mid = low + ( high - low + 1 ) / 2 ; if ( vec [ mid ] . first > a ) { high = mid - 1 ; } else if ( vec [ mid ] . first <= a ) { low = mid ; } } return low ; } void modify_vec ( vector < pair < int , int > > & v , int n ) { for ( int i = 1 ; i < n ; i ++ ) { v [ i ] . second = min ( v [ i ] . second , v [ i - 1 ] . second ) ; } } int evaluate_query ( vector < pair < int , int > > v , int n , int m1 , int m2 ) { int temp = binary_search ( v , n , m1 ) ; if ( ( v [ temp ] . first <= m1 ) && ( v [ temp ] . second <= m2 ) ) { return 1 ; } return 0 ; } void checkPairs ( vector < pair < int , int > > & v , vector < pair < int , int > > & queries ) { int n = v . size ( ) ; sort ( v . begin ( ) , v . end ( ) ) ; modify_vec ( v , n ) ; int k = queries . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int m1 = queries [ i ] . first ; int m2 = queries [ i ] . second ; int result = evaluate_query ( v , n , m1 , m2 ) ; if ( result > 0 ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; } } int main ( ) { vector < pair < int , int > > arr = { { 3 , 5 } , { 2 , 7 } , { 2 , 3 } , { 4 , 9 } } ; vector < pair < int , int > > queries = { { 3 , 4 } , { 3 , 2 } , { 4 , 1 } , { 3 , 7 } } ; checkPairs ( arr , queries ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void min_element_removal ( int arr [ ] , int N ) { vector < int > left ( N , 1 ) ; vector < int > right ( N , 1 ) ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { left [ i ] = max ( left [ i ] , left [ j ] + 1 ) ; } } } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ i ] > arr [ j ] ) { right [ i ] = max ( right [ i ] , right [ j ] + 1 ) ; } } } int maxLen = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { maxLen = max ( maxLen , left [ i ] + right [ i ] - 1 ) ; } cout << ( N - maxLen ) << " STRNEWLINE " ; } void makeBitonic ( int arr [ ] , int N ) { if ( N == 1 ) { cout << "0" << endl ; return ; } if ( N == 2 ) { if ( arr [ 0 ] != arr [ 1 ] ) cout << "0" << endl ; else cout << "1" << endl ; return ; } min_element_removal ( arr , N ) ; } int main ( ) { int arr [ ] = { 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; makeBitonic ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Sort ( vector < int > & ans , int num ) { int pos = -1 ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { if ( ans [ i ] >= num ) { pos = i ; break ; } } if ( pos == -1 ) ans . push_back ( num ) ; else ans . insert ( ans . begin ( ) + pos , num ) ; } void sortStream ( int arr [ ] , int N ) { vector < int > ans ; for ( int i = 0 ; i < N ; i ++ ) { Sort ( ans , arr [ i ] ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] << " ▁ " ; } cout << endl ; } } int main ( ) { int arr [ ] = { 4 , 1 , 7 , 6 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortStream ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <ext/pb_ds/assoc_container.hpp> NEW_LINE #include <ext/pb_ds/tree_policy.hpp> NEW_LINE using namespace std ; using namespace __gnu_cxx ; using namespace __gnu_pbds ; template < typename T > using ordered_set = tree < T , null_type , less < T > , rb_tree_tag , tree_order_statistics_node_update > ; int countMaxCommonChar ( string & S ) { ordered_set < char > Q ; int res = 0 ; map < char , int > freq ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { freq [ S [ i ] ] ++ ; } for ( int i = 0 ; i < S . length ( ) ; i ++ ) { freq [ S [ i ] ] -- ; if ( ! freq [ S [ i ] ] ) { Q . erase ( S [ i ] ) ; } else { Q . insert ( S [ i ] ) ; } int curr = Q . size ( ) ; res = max ( res , curr ) ; } cout << res << " STRNEWLINE " ; } int main ( ) { string str = " aabbca " ; countMaxCommonChar ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubarray ( string s ) { s += '0' ; int i ; int res = 0 ; int prev_one = 0 ; int curr_one = 0 ; int numberOfZeros = 0 ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { curr_one += 1 ; } else { numberOfZeros += 1 ; prev_one += curr_one ; res = max ( res , prev_one ) ; prev_one = curr_one ; curr_one = 0 ; } } if ( numberOfZeros == 1 ) { res -= 1 ; } return res ; } int main ( ) { string S = "1101" ; cout << longestSubarray ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubarray ( string s ) { int i = 0 , j = 0 , k = 1 ; for ( j = 0 ; j < s . size ( ) ; ++ j ) { if ( s [ j ] == '0' ) k -- ; if ( k < 0 && s [ i ++ ] == '0' ) k ++ ; } return j - i - 1 ; } int main ( ) { string S = "011101101" ; cout << longestSubarray ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void LarUnEl ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int LNRElem = INT_MIN ; int ind = -1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp [ arr [ i ] ] == 1 && arr [ i ] > LNRElem ) { ind = i ; LNRElem = arr [ i ] ; } } if ( ind == -1 ) { cout << ind ; return ; } cout << arr [ ind ] ; } int main ( ) { int arr [ ] = { 3 , 1 , 8 , 8 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; LarUnEl ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countShifts ( string str ) { int firstOne = -1 ; int lastOne = -1 ; int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '1' ) { if ( firstOne == -1 ) firstOne = i ; lastOne = i ; } } if ( ( firstOne == -1 ) || ( firstOne == lastOne ) ) { cout << 0 ; return ; } for ( int i = firstOne ; i <= lastOne ; i ++ ) { if ( str [ i ] == '0' ) { count ++ ; } } cout << count << endl ; } int main ( ) { string str = "00110111011" ; countShifts ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkSubsequenceUtil ( int arr [ ] , int L , int R , int N ) { for ( int i = 0 ; i < L ; i ++ ) if ( arr [ i ] == arr [ L ] ) return true ; for ( int i = R + 1 ; i < N ; i ++ ) if ( arr [ i ] == arr [ R ] ) return true ; return false ; } void checkSubsequence ( int arr [ ] , int L , int R , int N ) { if ( checkSubsequenceUtil ( arr , L , R , N ) ) { cout << " YES STRNEWLINE " ; } else { cout << " NO STRNEWLINE " ; } } int main ( ) { int arr [ ] = { 1 , 7 , 12 , 1 , 7 , 5 , 10 , 11 , 42 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 3 , R = 6 ; checkSubsequence ( arr , L , R , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; Node * prev ; } ; void push ( Node * * head_ref , int new_data ) { Node * new_node = ( Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> prev = NULL ; new_node -> next = ( * head_ref ) ; if ( ( * head_ref ) != NULL ) { ( * head_ref ) -> prev = new_node ; } ( * head_ref ) = new_node ; } int search ( Node * * head_ref , int x ) { Node * temp = * head_ref ; int pos = 0 ; while ( temp -> data != x && temp -> next != NULL ) { pos ++ ; temp = temp -> next ; } if ( temp -> data != x ) return -1 ; return ( pos + 1 ) ; } int main ( ) { Node * head = NULL ; int X = 8 ; push ( & head , 14 ) ; push ( & head , 9 ) ; push ( & head , 8 ) ; push ( & head , 15 ) ; push ( & head , 18 ) ; cout << search ( & head , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestSubarray ( int arr [ ] , int N , int K ) { int count = 0 ; int len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < K ) { count += 1 ; } else { len = max ( len , count ) ; count = 0 ; } } if ( count ) { len = max ( len , count ) ; } cout << len ; } int main ( ) { int arr [ ] = { 1 , 8 , 3 , 5 , 2 , 2 , 1 , 13 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 6 ; largestSubarray ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarrays ( int A [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) { ans ++ ; for ( int j = i - 1 , k = i + 2 ; j >= 0 && k < N && A [ j ] == A [ i ] && A [ k ] == A [ i + 1 ] ; j -- , k ++ ) { ans ++ ; } } } cout << ans << " STRNEWLINE " ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countSubarrays ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; arr [ x - 1 ] = y ; int count = 1 ; for ( int j = 1 ; j < N ; j ++ ) { if ( arr [ j ] != arr [ j - 1 ] ) { count += 1 ; } } cout << count << ' ▁ ' ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; int Queries [ Q ] [ 2 ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubsequence ( int N , int Q , int arr [ ] , int Queries [ ] [ 2 ] ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count += 1 ; } } for ( int i = 0 ; i < Q ; i ++ ) { int x = Queries [ i ] [ 0 ] ; int y = Queries [ i ] [ 1 ] ; if ( x > 1 ) { if ( arr [ x - 1 ] != arr [ x - 2 ] ) { count -= 1 ; } if ( arr [ x - 2 ] != y ) { count += 1 ; } } if ( x < N ) { if ( arr [ x ] != arr [ x - 1 ] ) { count -= 1 ; } if ( y != arr [ x ] ) { count += 1 ; } } cout << count << ' ▁ ' ; arr [ x - 1 ] = y ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; int Queries [ Q ] [ 2 ] = { { 1 , 3 } , { 4 , 2 } } ; longestSubsequence ( N , Q , arr , Queries ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void findPair ( int A [ ] , int N ) { int right_prod [ N ] ; int flag = 0 ; right_prod [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) right_prod [ i ] = right_prod [ i + 1 ] * A [ i ] ; int total_prod = right_prod [ 0 ] ; int product ; for ( int i = 1 ; i < N - 1 ; i ++ ) { product = 1 ; for ( int j = i ; j < N - 1 ; j ++ ) { product *= A [ j ] ; if ( gcd ( product , right_prod [ j + 1 ] ) == 1 || gcd ( product , total_prod / right_prod [ i ] ) == 1 ) { flag = 1 ; cout << " ( " << i - 1 << " , ▁ " << j + 1 << " ) " ; break ; } } if ( flag == 1 ) break ; } if ( flag == 0 ) cout << -1 ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPair ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countString ( string S ) { long long count = 0 ; for ( auto it : S ) { if ( it == '0' and count > 0 ) { count -- ; } else { count ++ ; } } cout << ( ( 1 << count ) - 1 ) << " STRNEWLINE " ; } int main ( ) { string S = "1001" ; countString ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void replaceDuplicates ( vector < string > & names ) { unordered_map < string , int > hash ; for ( int i = 0 ; i < names . size ( ) ; i ++ ) { if ( hash . count ( names [ i ] ) == 0 ) hash [ names [ i ] ] ++ ; else { int count = hash [ names [ i ] ] ++ ; names [ i ] += to_string ( count ) ; } } for ( int i = 0 ; i < names . size ( ) ; i ++ ) { cout << names [ i ] << " ▁ " ; } } int main ( ) { vector < string > str = { " aa " , " bb " , " cc " , " bb " , " aa " , " aa " , " aa " } ; replaceDuplicates ( str ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void convert_to_allzeroes ( string str , int a , int b ) { int len = str . length ( ) ; int left_1 , i = 0 ; while ( i < len && str [ i ] == '0' ) i ++ ; left_1 = i ; int right_1 ; i = len - 1 ; while ( i >= 0 && str [ i ] == '0' ) i -- ; right_1 = i ; if ( left_1 == len && right_1 == -1 ) { cout << 0 ; return ; } int cost = a , zeroes ; for ( i = left_1 ; i <= right_1 ; i ++ ) { zeroes = 0 ; while ( i < len && str [ i ] == '0' ) { zeroes ++ ; i ++ ; } if ( zeroes ) cost += min ( zeroes * b , a ) ; } cout << cost ; } int main ( ) { string str = "01101110" ; int A = 5 , B = 1 ; convert_to_allzeroes ( str , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinDistK ( int arr [ ] , int N , int K ) { int res = INT_MAX ; int dist = 0 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { if ( arr [ i ] >= 0 && arr [ i + K - 1 ] >= 0 ) { dist = max ( arr [ i ] , arr [ i + K - 1 ] ) ; } else { dist = abs ( arr [ i ] ) + abs ( arr [ i + K - 1 ] ) + min ( abs ( arr [ i ] ) , abs ( arr [ i + K - 1 ] ) ) ; } res = min ( res , dist ) ; } return res ; } int main ( ) { int K = 3 ; int arr [ ] = { -30 , -10 , 10 , 20 , 50 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinDistK ( arr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min ( int a [ ] , int n ) { int minIndex = 0 , minValue = a [ 0 ] , i ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] < minValue ) { minValue = a [ i ] ; minIndex = i ; } } return minIndex ; } int maximizeMin ( int A [ ] , int N , int S , int M ) { int minIndex , left , right , i , j ; for ( i = 0 ; i < M ; i ++ ) { minIndex = min ( A , N ) ; A [ minIndex ] ++ ; left = minIndex - 1 ; right = minIndex + 1 ; for ( j = 0 ; j < S - 1 ; j ++ ) { if ( left == -1 ) A [ right ++ ] ++ ; else if ( right == N ) A [ left -- ] ++ ; else { if ( A [ left ] < A [ right ] ) A [ left -- ] ++ ; else A [ right ++ ] ++ ; } } } minIndex = min ( A , N ) ; return A [ minIndex ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int S = 2 , M = 3 ; cout << maximizeMin ( arr , N , S , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sum ( int arr [ ] , int n ) { map < int , vector < int > > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] . push_back ( i ) ; } int ans [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( auto it : mp [ arr [ i ] ] ) { sum += abs ( it - i ) ; } ans [ i ] = sum ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } return ; } int main ( ) { int arr [ ] = { 1 , 3 , 1 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sum ( arr , n ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; const int maxN = 2002 ; int lcount [ maxN ] [ maxN ] ; int rcount [ maxN ] [ maxN ] ; void fill_counts ( int a [ ] , int n ) { int i , j ; int maxA = a [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxA ) { maxA = a [ i ] ; } } memset ( lcount , 0 , sizeof ( lcount ) ) ; memset ( rcount , 0 , sizeof ( rcount ) ) ; for ( i = 0 ; i < n ; i ++ ) { lcount [ a [ i ] ] [ i ] = 1 ; rcount [ a [ i ] ] [ i ] = 1 ; } for ( i = 0 ; i <= maxA ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { lcount [ i ] [ j ] = lcount [ i ] [ j - 1 ] + lcount [ i ] [ j ] ; } for ( j = n - 2 ; j >= 0 ; j -- ) { rcount [ i ] [ j ] = rcount [ i ] [ j + 1 ] + rcount [ i ] [ j ] ; } } } int countSubsequence ( int a [ ] , int n ) { int i , j ; fill_counts ( a , n ) ; int answer = 0 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n - 1 ; j ++ ) { answer += lcount [ a [ j ] ] [ i - 1 ] * rcount [ a [ i ] ] [ j + 1 ] ; } } return answer ; } int main ( ) { int a [ 7 ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; cout << countSubsequence ( a , 7 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPointRange ( int arr [ ] [ 3 ] , int X , int Y , int N ) { for ( int i = 0 ; i < N ; i ++ ) { double dist = sqrt ( ( arr [ i ] [ 0 ] - X ) * ( arr [ i ] [ 0 ] - X ) + ( arr [ i ] [ 1 ] - Y ) * ( arr [ i ] [ 1 ] - Y ) ) ; if ( dist <= arr [ i ] [ 2 ] ) { return true ; } } return false ; } int main ( ) { int arr [ ] [ 3 ] = { { 1 , 1 , 3 } , { 10 , 10 , 3 } , { 15 , 15 , 15 } } ; int X = 5 , Y = 5 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkPointRange ( arr , X , Y , N ) ) { cout << " True " ; } else { cout << " False " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( int arr [ ] , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { odd ++ ; } else { even ++ ; } } if ( even == 0 ) { if ( odd % 2 == 0 ) { cout << " Player ▁ 2" << endl ; } else if ( odd % 2 == 1 ) { cout << " Player ▁ 1" << endl ; } } else if ( even == 1 && odd % 2 == 1 ) { cout << " Player ▁ 1" << endl ; } else { cout << -1 << endl ; } } int main ( ) { int arr [ ] = { 3 , 1 , 9 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findWinner ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeArrMaxcntMinima ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int left = 0 ; int right = N / 2 ; while ( left < N / 2 right < N ) { if ( right < N ) { cout << arr [ right ] << " ▁ " ; right ++ ; } if ( left < N / 2 ) { cout << arr [ left ] << " ▁ " ; left ++ ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrangeArrMaxcntMinima ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int MOD = 1e9 + 7 ; int minJumps ( string seats ) { vector < int > position ; int count = 0 ; int len = seats . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( seats [ i ] == ' x ' ) { position . push_back ( i - count ) ; count ++ ; } } if ( count == len count == 0 ) return 0 ; int med_index = ( count - 1 ) / 2 ; int med_val = position [ med_index ] ; int ans = 0 ; for ( int i = 0 ; i < position . size ( ) ; i ++ ) { ans = ( ans % MOD + abs ( position [ i ] - med_val ) % MOD ) % MOD ; } return ans % MOD ; } int main ( ) { string S = " . . . . x . . xx . . . x . . " ; cout << minJumps ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int singlePrimeFactor ( int N ) { unordered_set < int > disPrimeFact ; for ( int i = 2 ; i * i <= N ; ++ i ) { while ( N % i == 0 ) { disPrimeFact . insert ( i ) ; N /= i ; } } if ( N != 1 ) { disPrimeFact . insert ( N ) ; } if ( disPrimeFact . size ( ) == 1 ) { return * disPrimeFact . begin ( ) ; } return -1 ; } int cntsingleFactorPair ( int arr [ ] , int N ) { int countOf1 = 0 ; unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { countOf1 ++ ; continue ; } int factorValue = singlePrimeFactor ( arr [ i ] ) ; if ( factorValue == -1 ) { continue ; } else { mp [ factorValue ] ++ ; } } int res = 0 ; for ( auto it : mp ) { int X = it . second ; res += countOf1 * X + ( X * ( X - 1 ) ) / 2 ; } return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntsingleFactorPair ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MincntBothPalin ( string str1 , string str2 , int N ) { int i = 0 ; int j = N - 1 ; int cntOp = 0 ; while ( i < j ) { if ( str1 [ i ] == str1 [ j ] && str2 [ i ] != str2 [ j ] ) { cntOp += 1 ; } else if ( str1 [ i ] != str1 [ j ] && str2 [ i ] == str2 [ j ] ) { cntOp += 1 ; } else if ( str1 [ i ] != str1 [ j ] && str2 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == str2 [ j ] && str2 [ i ] == str1 [ j ] ) { cntOp += 1 ; } else { cntOp += 2 ; } } i += 1 ; j -= 1 ; } return cntOp ; } int main ( ) { string str1 = " dbba " ; string str2 = " abcd " ; int N = str1 . length ( ) ; cout << MincntBothPalin ( str1 , str2 , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int v1 [ ] , int v2 [ ] , int n , int m , int k ) { int count = 0 ; if ( n <= m ) { sort ( v1 , v1 + n ) ; for ( int j = 0 ; j < m ; j ++ ) { int index = lower_bound ( v1 , v1 + n , v2 [ j ] - k ) - v1 ; count += index ; } } else { sort ( v2 , v2 + m ) ; for ( int i = 0 ; i < n ; i ++ ) { int index = upper_bound ( v2 , v2 + m , v1 [ i ] + k ) - v2 ; count += m - index ; } } return count ; } int main ( ) { int arr [ ] = { 5 , 9 , 1 , 8 } ; int brr [ ] = { 10 , 12 , 7 , 4 , 2 , 3 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( brr ) / sizeof ( brr [ 0 ] ) ; cout << countPairs ( arr , brr , N , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; vector < Node * > child ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; return temp ; } void Siblings ( Node * root , int value ) { int flag = 0 ; if ( root == NULL ) return ; queue < Node * > q ; q . push ( root ) ; while ( ! q . empty ( ) ) { Node * temp = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < temp -> child . size ( ) ; i ++ ) { if ( temp -> child [ i ] -> key == value ) { flag = 1 ; for ( int j = 0 ; j < temp -> child . size ( ) ; j ++ ) { if ( value != temp -> child [ j ] -> key ) cout << temp -> child [ j ] -> key << " ▁ " ; } break ; } q . push ( temp -> child [ i ] ) ; } } if ( flag == 0 ) cout << " No ▁ siblings ! ! " ; } Node * constructTree ( ) { Node * root = newNode ( 10 ) ; ( root -> child ) . push_back ( newNode ( 20 ) ) ; ( root -> child ) . push_back ( newNode ( 30 ) ) ; ( root -> child ) . push_back ( newNode ( 40 ) ) ; ( root -> child [ 0 ] -> child ) . push_back ( newNode ( 50 ) ) ; ( root -> child [ 0 ] -> child ) . push_back ( newNode ( 60 ) ) ; ( root -> child [ 1 ] -> child ) . push_back ( newNode ( 70 ) ) ; ( root -> child [ 1 ] -> child ) . push_back ( newNode ( 80 ) ) ; ( root -> child [ 2 ] -> child ) . push_back ( newNode ( 90 ) ) ; ( root -> child [ 2 ] -> child ) . push_back ( newNode ( 100 ) ) ; ( root -> child [ 2 ] -> child ) . push_back ( newNode ( 110 ) ) ; return root ; } int main ( ) { Node * root = constructTree ( ) ; int X = 30 ; Siblings ( root , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSumSubarr ( int A [ ] , int N , int K , int X ) { int sum_K = 0 ; for ( int i = 0 ; i < K ; i ++ ) { sum_K += A [ i ] ; } int Max_Sum = 0 ; if ( sum_K < X ) { Max_Sum = sum_K ; } for ( int i = K ; i < N ; i ++ ) { sum_K -= ( A [ i - K ] - A [ i ] ) ; if ( sum_K < X ) { Max_Sum = max ( Max_Sum , sum_K ) ; } } cout << Max_Sum << endl ; } int main ( ) { int arr [ ] = { -5 , 8 , 7 , 2 , 10 , 1 , 20 , -4 , 6 , 9 } ; int K = 5 ; int X = 30 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxSumSubarr ( arr , N , K , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOuterParentheses ( string S ) { string res ; int count = 0 ; for ( char c : S ) { if ( c == ' ( ' && count ++ > 0 ) res += c ; if ( c == ' ) ' && count -- > 1 ) res += c ; } return res ; } int main ( ) { string S = " ( ( ) ( ) ) ( ( ) ) ( ) " ; cout << removeOuterParentheses ( S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeSmallestSubarray ( int arr [ ] , int n , int k ) { int mod_arr [ n ] ; int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mod_arr [ i ] = ( arr [ i ] + k ) % k ; total_sum += arr [ i ] ; } int target_remainder = total_sum % k ; if ( target_remainder == 0 ) { cout << "0" ; return ; } unordered_map < int , int > map1 ; map1 [ 0 ] = -1 ; int curr_remainder = 0 ; int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 [ curr_remainder ] = i ; int mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . find ( mod ) != map1 . end ( ) ) res = min ( res , i - map1 [ mod ] ) ; } if ( res == INT_MAX res == n ) { res = -1 ; } cout << res ; } int main ( ) { int arr [ ] = { 3 , 1 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 6 ; removeSmallestSubarray ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( int wood [ ] , int N , int len , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { count += wood [ i ] / len ; } return count >= K ; } int findMaxLen ( int wood [ ] , int N , int K ) { int left = 1 ; int right = * max_element ( wood , wood + N ) ; while ( left <= right ) { int mid = left + ( right - left ) / 2 ; if ( isValid ( wood , N , mid , K ) ) { left = mid + 1 ; } else { right = mid - 1 ; } } return right ; } int main ( ) { int wood [ ] = { 5 , 9 , 7 } ; int N = sizeof ( wood ) / sizeof ( wood [ 0 ] ) ; int K = 4 ; cout << findMaxLen ( wood , N , K ) ; }
#include <iostream> NEW_LINE using namespace std ; int countSum ( int a [ ] , int n , int sum ) { int i , j , k , l ; int count = 0 ; for ( i = 0 ; i < n - 3 ; i ++ ) { for ( j = i + 1 ; j < n - 2 ; j ++ ) { for ( k = j + 1 ; k < n - 1 ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ i ] + a [ j ] + a [ k ] + a [ l ] == sum ) count ++ ; } } } } return count ; } int main ( ) { int arr [ ] = { 4 , 5 , 3 , 1 , 2 , 4 } ; int S = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSum ( arr , N , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSwaps ( string S , int n ) { int swaps = 0 ; vector < vector < int > > arr ( 26 ) ; for ( int i = 0 ; i < n ; i ++ ) { int pos = S [ i ] - ' a ' ; arr [ pos ] . push_back ( i ) ; } for ( char ch = ' a ' ; ch <= ' z ' ; ++ ch ) { int pos = ch - ' a ' ; for ( int i = 1 ; i < arr [ pos ] . size ( ) ; ++ i ) { swaps += abs ( arr [ pos ] [ i ] - arr [ pos ] [ i - 1 ] - 1 ) ; } } return swaps ; } int main ( ) { string S = " abbccabbcc " ; int N = S . length ( ) ; cout << minSwaps ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printConnections ( vector < pair < int , int > > store , vector < int > ind , int ind1 ) { for ( auto pr : store ) { cout << pr . first << " ▁ " << pr . second << " STRNEWLINE " ; } if ( ind . size ( ) != 0 ) { for ( auto x : ind ) { cout << ind1 << " ▁ " << x + 1 << " STRNEWLINE " ; } } } void constructGraph ( char arr [ ] , int N ) { vector < int > ind ; vector < pair < int , int > > store ; char x = arr [ 0 ] ; int count = 0 , ind1 ; for ( int i = 1 ; i <= N - 1 ; ++ i ) { if ( arr [ i ] != x ) { ind1 = i + 1 ; count ++ ; store . push_back ( { 1 , i + 1 } ) ; } else { ind . push_back ( i ) ; } } if ( count == 0 ) { cout << " Not ▁ Possible " ; } else { cout << " Possible " << " STRNEWLINE " ; printConnections ( store , ind , ind1 ) ; } } int main ( ) { int N = 5 ; char arr [ ] = { ' a ' , ' b ' , ' a ' , ' b ' , ' c ' } ; constructGraph ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( int arr [ ] , int n , int m , int d ) { for ( int i = 0 ; i < m ; i ++ ) { if ( abs ( arr [ n - m + i ] - arr [ i ] ) < d ) { return 0 ; } } return 1 ; } int countPairs ( int arr [ ] , int N , int K ) { int ans = 0 ; int left = 0 , right = N / 2 + 1 ; sort ( arr , arr + N ) ; while ( left < right ) { int mid = ( left + right ) / 2 ; if ( isValid ( arr , N , mid , K ) ) { ans = mid ; left = mid + 1 ; } else right = mid - 1 ; } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 5 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void max_distance ( int a [ ] , int temp [ ] , int n ) { map < int , int > mp ; for ( int i = 1 ; i <= n ; i ++ ) { temp [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( a [ i ] ) == mp . end ( ) ) temp [ a [ i ] ] = i + 1 ; else temp [ a [ i ] ] = max ( temp [ a [ i ] ] , i - mp [ a [ i ] ] ) ; mp [ a [ i ] ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( temp [ i ] != -1 ) temp [ i ] = max ( temp [ i ] , n - mp [ i ] ) ; } } void min_comm_ele ( int a [ ] , int ans [ ] , int temp [ ] , int n ) { max_distance ( a , temp , n ) ; for ( int i = 1 ; i <= n ; i ++ ) { ans [ i ] = -1 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ans [ temp [ i ] ] == -1 ) ans [ temp [ i ] ] = i ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( i > 1 && ans [ i - 1 ] != -1 ) { if ( ans [ i ] == -1 ) ans [ i ] = ans [ i - 1 ] ; else ans [ i ] = min ( ans [ i ] , ans [ i - 1 ] ) ; } cout << ans [ i ] << " ▁ " ; } } int main ( ) { int N = 6 ; int a [ ] = { 1 , 3 , 4 , 5 , 6 , 7 } ; int temp [ 100 ] , ans [ 100 ] ; min_comm_ele ( a , ans , temp , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void FindTrip ( int arr [ ] , int N ) { for ( int i = 1 ; i < N - 1 ; i ++ ) { int p = arr [ i - 1 ] ; int q = arr [ i ] ; int r = arr [ i + 1 ] ; if ( p < q && q > r ) { cout << i - 1 << " ▁ " << i << " ▁ " << i + 1 ; return ; } } cout << -1 ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; FindTrip ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubarrays ( int arr [ ] , int N ) { int cntSub = 0 ; int cntUnique = 0 ; unordered_map < int , int > cntFreq ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j ++ ) { cntFreq [ arr [ j ] ] ++ ; if ( cntFreq [ arr [ j ] ] == 1 ) { cntUnique ++ ; } else if ( cntFreq [ arr [ j ] ] == 2 ) { cntUnique -- ; } if ( cntUnique == 0 ) { cntSub ++ ; } } cntFreq . clear ( ) ; cntUnique = 0 ; } return cntSub ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntSubarrays ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPalinK ( string str , int K ) { int N = str . length ( ) ; int cntFreq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ str [ i ] ] ++ ; } int cntOddFreq = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % 2 == 1 ) { cntOddFreq ++ ; } } if ( cntOddFreq <= ( K + 1 ) ) { return true ; } return false ; } int main ( ) { string str = " geeksforgeeks " ; int K = 2 ; if ( checkPalinK ( str , K ) ) { cout << " Yes " ; } else { cout << " No " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count_Number ( int x ) { int ans = 0 ; if ( x % 99 != 0 ) { ans = -1 ; } else { int diff = x / 99 ; for ( int i = 1 ; i < 10 ; i ++ ) { for ( int j = 1 ; j < 10 ; j ++ ) { if ( ( i - j ) == diff ) { ans += 10 ; } } } } return ans ; } int main ( ) { int x = 792 ; cout << Count_Number ( x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int INF = INT_MAX ; int * findMaxPoint ( int arr [ ] [ 2 ] , int i , int n ) { if ( i == n ) { arr [ 0 ] [ 0 ] = INF ; arr [ 0 ] [ 1 ] = INF ; return arr [ 0 ] ; } bool flag = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( j == i ) continue ; if ( arr [ j ] [ 0 ] >= arr [ i ] [ 0 ] arr [ j ] [ 1 ] >= arr [ i ] [ 1 ] ) { flag = false ; break ; } } if ( flag ) return arr [ i ] ; return findMaxPoint ( arr , i + 1 , n ) ; } void findMaxPoints ( int arr [ ] [ 2 ] , int n ) { int ans [ 2 ] ; memcpy ( ans , findMaxPoint ( arr , 0 , n ) , 2 * sizeof ( int ) ) ; if ( ans [ 0 ] == INF ) { cout << -1 ; } else { cout << " ( " << ans [ 0 ] << " ▁ " << ans [ 1 ] << " ) " ; } } int main ( ) { int arr [ ] [ 2 ] = { { 1 , 2 } , { 2 , 1 } , { 3 , 4 } , { 4 , 3 } , { 5 , 5 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMaxPoints ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE #define P  2 NEW_LINE void findMaxPoint ( int arr [ N ] [ P ] ) { int maxX = INT_MIN ; int maxY = INT_MIN ; int n = N ; for ( int i = 0 ; i < n ; i ++ ) { maxX = max ( maxX , arr [ i ] [ 0 ] ) ; maxY = max ( maxY , arr [ i ] [ 1 ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( maxX == arr [ i ] [ 0 ] && maxY == arr [ i ] [ 1 ] ) { cout << " ( " << maxX << " , ▁ " << maxY << " ) " ; return ; } } cout << ( -1 ) ; } int main ( ) { int arr [ N ] [ P ] = { { 1 , 2 } , { 2 , 1 } , { 3 , 4 } , { 4 , 3 } , { 5 , 5 } } ; findMaxPoint ( arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_index ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == K ) return i ; else if ( arr [ i ] > K ) return i ; return n ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << find_index ( arr , n , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minSubarray ( int * arr , int N ) { unordered_map < int , int > m ; for ( int i = 0 ; i < N ; i ++ ) { int mini = INT_MAX ; for ( int j = i ; j < N ; j ++ ) { mini = min ( mini , arr [ j ] ) ; m [ mini ] ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << m [ arr [ i ] ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 3 , 2 , 1 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; minSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minSubarray ( int * arr , int N ) { int result [ N ] ; stack < pair < int , int > > l , r ; for ( int i = 0 ; i < N ; i ++ ) { int count = 1 ; while ( ! l . empty ( ) && l . top ( ) . first > arr [ i ] ) { count += l . top ( ) . second ; l . pop ( ) ; } l . push ( { arr [ i ] , count } ) ; result [ i ] = count ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { int count = 1 ; while ( ! r . empty ( ) && r . top ( ) . first >= arr [ i ] ) { count += r . top ( ) . second ; r . pop ( ) ; } r . push ( { arr [ i ] , count } ) ; result [ i ] *= count ; } for ( int i = 0 ; i < N ; i ++ ) { cout << result [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 3 , 2 , 1 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; minSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printAlter ( int arr [ ] , int N ) { for ( int currIndex = 0 ; currIndex < N ; currIndex ++ ) { if ( currIndex % 2 == 0 ) { cout << arr [ currIndex ] << " ▁ " ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAlter ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findmin ( string s ) { int n = s . length ( ) ; int i , j , maximum = 0 ; int incr [ n + 1 ] = { 0 } ; for ( i = 0 ; i < n ; i ++ ) { incr [ i + 1 ] = incr [ i ] ; if ( s [ i ] == '0' ) { incr [ i + 1 ] ++ ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { maximum = max ( maximum , incr [ i ] + j - i + 1 - ( incr [ j + 1 ] - incr [ i ] ) + incr [ n ] - incr [ j + 1 ] ) ; } } return n - maximum ; } int main ( ) { string S = "0110100110" ; int minimum = findmin ( S ) ; cout << minimum << ' ' ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } int digitSum ( int number ) { int sum = 0 ; while ( number > 0 ) { sum += ( number % 10 ) ; number /= 10 ; } return sum ; } void longestCompositeDigitSumSubsequence ( int arr [ ] , int n ) { int count = 0 ; bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int res = digitSum ( arr [ i ] ) ; if ( res == 1 ) { continue ; } if ( ! prime [ res ] ) { count ++ ; } } cout << count << endl ; } int main ( ) { int arr [ ] = { 13 , 55 , 7 , 3 , 5 , 1 , 10 , 21 , 233 , 144 , 89 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; longestCompositeDigitSumSubsequence ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPower ( int x ) { return ( x && ( ! ( x & ( x - 1 ) ) ) ) ; } int maximumlength ( int arr [ ] , int N ) { int max_length = 0 ; int max_len_subarray = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( isPower ( arr [ i ] ) == 1 ) { max_length ++ ; max_len_subarray = max ( max_length , max_len_subarray ) ; } else { max_length = 0 ; } } cout << max_len_subarray ; } int main ( ) { int arr [ ] = { 2 , 5 , 4 , 6 , 8 , 8 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximumlength ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLengthOfShortestSubarray ( int arr [ ] , int N ) { int minlength = INT_MAX ; int left = 0 ; int right = N - 1 ; while ( left < right && arr [ left + 1 ] >= arr [ left ] ) { left ++ ; } if ( left == N - 1 ) return 0 ; while ( right > left && arr [ right - 1 ] <= arr [ right ] ) { right -- ; } minlength = min ( N - left - 1 , right ) ; int j = right ; for ( int i = 0 ; i < left + 1 ; i ++ ) { if ( arr [ i ] <= arr [ j ] ) { minlength = min ( minlength , j - i - 1 ) ; } else if ( j < N - 1 ) { j ++ ; } else { break ; } } return minlength ; } int main ( ) { int arr [ ] = { 6 , 3 , 10 , 11 , 15 , 20 , 13 , 3 , 18 , 12 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( findLengthOfShortestSubarray ( arr , N ) ) ; }
#include <iostream> NEW_LINE using namespace std ; void minSub ( int N ) { int count = 0 ; while ( N >= 0 ) { int num = N ; int rev = 0 ; while ( num != 0 ) { int digit = num % 10 ; rev = ( rev * 10 ) + digit ; num = num / 10 ; } if ( N == rev ) { break ; } count ++ ; N -- ; } cout << count ; } int main ( ) { int N = 3456 ; minSub ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfGP ( int L [ ] , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i - 1 ] * L [ i - 1 ] == L [ i ] * L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 , 24 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << numberOfGP ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string conVowUpp ( string & str ) { int N = str . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' str [ i ] == ' e ' str [ i ] == ' i ' str [ i ] == ' o ' str [ i ] == ' u ' ) { str [ i ] = str [ i ] - ' a ' + ' A ' ; } } return str ; } int main ( ) { string str = " eutopia " ; cout << conVowUpp ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubarr ( int arr [ ] , int N ) { int res = 0 ; int prefixXor = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixXor = arr [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { prefixXor ^= arr [ j ] ; if ( prefixXor == 0 && ( j - i + 1 ) % 2 == 0 ) { res ++ ; } } } return res ; } int main ( ) { int arr [ ] = { 2 , 2 , 3 , 3 , 6 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntSubarr ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000 NEW_LINE int cntSubXor ( int arr [ ] , int N ) { int prefixXor = 0 ; int Even [ M ] ; int Odd [ M ] ; int cntSub = 0 ; Odd [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { prefixXor ^= arr [ i ] ; if ( i % 2 == 1 ) { cntSub += Odd [ prefixXor ] ; Odd [ prefixXor ] ++ ; } else { cntSub += Even [ prefixXor ] ; Even [ prefixXor ] ++ ; } } return cntSub ; } int main ( ) { int arr [ ] = { 2 , 2 , 3 , 3 , 6 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntSubXor ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxSum ( vector < int > arr , int n , vector < int > min , int k , int & S ) { vector < pair < int , int > > A ; for ( int i = 0 ; i < n ; i ++ ) { A . push_back ( { arr [ i ] , min [ i ] } ) ; } sort ( A . begin ( ) , A . end ( ) , greater < pair < int , int > > ( ) ) ; int K = 0 ; for ( int i = 0 ; i < n ; i ++ ) { S += max ( A [ i ] . first - K , A [ i ] . second ) ; K += k ; } } int main ( ) { vector < int > arr , min ; arr = { 3 , 5 , 2 , 1 } ; min = { 3 , 2 , 1 , 3 } ; int N = arr . size ( ) ; int K = 3 ; int S = 0 ; findMaxSum ( arr , N , min , K , S ) ; cout << S ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minLength ( string a , string b ) { map < char , int > Char ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) { Char [ b [ i ] ] ++ ; } map < char , vector < int > > CharacterIndex ; for ( int i = 0 ; i < a . length ( ) ; i ++ ) { char x = a [ i ] ; if ( Char . find ( x ) != Char . end ( ) ) { CharacterIndex [ x ] . push_back ( i ) ; } } int len = INT_MAX ; int flag ; while ( true ) { flag = 1 ; int firstVar , lastVar ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) { if ( i == 0 ) { if ( CharacterIndex . find ( b [ i ] ) == CharacterIndex . end ( ) ) { flag = 0 ; break ; } else { int x = * ( CharacterIndex [ b [ i ] ] . begin ( ) ) ; CharacterIndex [ b [ i ] ] . erase ( CharacterIndex [ b [ i ] ] . begin ( ) ) ; firstVar = x ; lastVar = x ; } } else { int elementFound = 0 ; for ( auto e : CharacterIndex [ b [ i ] ] ) { if ( e > lastVar ) { elementFound = 1 ; lastVar = e ; break ; } } if ( elementFound == 0 ) { flag = 0 ; break ; } } } if ( flag == 0 ) { break ; } len = min ( len , abs ( lastVar - firstVar ) + 1 ) ; } return len ; } int main ( ) { string a = " abcdefababaef " ; string b = " abf " ; int len = minLength ( a , b ) ; if ( len != INT_MAX ) { cout << len << endl ; } else { cout << " Impossible " << endl ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinLen ( string str , int K ) { int N = str . length ( ) ; int i = 0 ; while ( i < N - 1 ) { if ( str [ i ] != str [ i + 1 ] ) { break ; } i ++ ; } if ( i == N - 1 ) { return N ; } return max ( 1 , N - K ) ; } int main ( ) { string str = " aabc " ; int K = 1 ; cout << MinLen ( str , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > mp ; int N , P ; bool helper ( int mid ) { int cnt = 0 ; for ( auto i : mp ) { int temp = i . second ; while ( temp >= mid ) { temp -= mid ; cnt ++ ; } } return cnt >= N ; } int findMaximumDays ( int arr [ ] ) { for ( int i = 0 ; i < P ; i ++ ) { mp [ arr [ i ] ] ++ ; } int start = 0 , end = P , ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( mid != 0 and helper ( mid ) ) { ans = mid ; start = mid + 1 ; } else if ( mid == 0 ) { start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; } int main ( ) { N = 3 , P = 10 ; int arr [ ] = { 1 , 2 , 2 , 1 , 1 , 3 , 3 , 3 , 2 , 4 } ; cout << findMaximumDays ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define pb  push_back NEW_LINE double temp ( int n , int x ) { return pow ( x * 1.0 / n , n ) ; } bool check ( int n , int y , int x ) { double v = temp ( n , x ) ; return ( v >= y ) ; } void find ( int x , int y ) { int high = ( int ) floor ( x / exp ( 1.0 ) ) ; int low = 1 ; if ( x == y ) cout << 1 << endl ; else if ( ! check ( high , y , x ) ) cout << -1 << endl ; else { while ( high - low > 1 ) { int mid = ( high + low ) / 2 ; if ( check ( mid , y , x ) ) high = mid ; else low = mid ; } cout << high << endl ; } } int main ( ) { int x = 9 , y = 8 ; find ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newnode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } Node * insert ( string s , int i , int N , Node * root , Node * temp ) { if ( i == N ) return temp ; if ( s [ i ] == ' L ' ) root -> left = insert ( s , i + 1 , N , root -> left , temp ) ; else root -> right = insert ( s , i + 1 , N , root -> right , temp ) ; return root ; } int SBTUtil ( Node * root , int & sum ) { if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return root -> data ; int left = SBTUtil ( root -> left , sum ) ; int right = SBTUtil ( root -> right , sum ) ; if ( root -> left && root -> right ) { if ( ( left % 2 == 0 && right % 2 != 0 ) || ( left % 2 != 0 && right % 2 == 0 ) ) { sum += root -> data ; } } return left + right + root -> data ; } Node * build_tree ( int R , int N , string str [ ] , int values [ ] ) { Node * root = newnode ( R ) ; int i ; for ( i = 0 ; i < N - 1 ; i ++ ) { string s = str [ i ] ; int x = values [ i ] ; Node * temp = newnode ( x ) ; root = insert ( s , 0 , s . size ( ) , root , temp ) ; } return root ; } void speciallyBalancedNodes ( int R , int N , string str [ ] , int values [ ] ) { Node * root = build_tree ( R , N , str , values ) ; int sum = 0 ; SBTUtil ( root , sum ) ; cout << sum << " ▁ " ; } int main ( ) { int N = 7 ; int R = 12 ; string str [ N - 1 ] = { " L " , " R " , " RL " , " RR " , " RLL " , " RLR " } ; int values [ N - 1 ] = { 17 , 16 , 4 , 9 , 2 , 3 } ; speciallyBalancedNodes ( R , N , str , values ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left ; struct node * right ; } ; struct node * newnode ( int d ) { struct node * temp = ( struct node * ) malloc ( sizeof ( struct node ) ) ; temp -> data = d ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } void dfs ( node * root , int l , map < int , vector < int > > & M ) { if ( root == NULL ) return ; M [ l ] . push_back ( root -> data ) ; dfs ( root -> left , l + 1 , M ) ; dfs ( root -> right , l + 1 , M ) ; } void printMidNodes ( node * root ) { map < int , vector < int > > M ; dfs ( root , 0 , M ) ; for ( auto & it : M ) { int size = it . second . size ( ) ; if ( size & 1 ) { cout << it . second [ ( size - 1 ) / 2 ] << endl ; } else { cout << it . second [ ( size - 1 ) / 2 ] << ' ▁ ' << it . second [ ( size - 1 ) / 2 + 1 ] << endl ; } } } int main ( ) { struct node * root = newnode ( 1 ) ; root -> left = newnode ( 2 ) ; root -> right = newnode ( 3 ) ; root -> left -> left = newnode ( 4 ) ; root -> left -> right = newnode ( 5 ) ; root -> left -> right -> left = newnode ( 11 ) ; root -> left -> right -> right = newnode ( 6 ) ; root -> left -> right -> right -> left = newnode ( 7 ) ; root -> left -> right -> right -> right = newnode ( 9 ) ; root -> right -> left = newnode ( 10 ) ; root -> right -> right = newnode ( 8 ) ; printMidNodes ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class node { public : node * left ; node * right ; } ; void insert ( int x , node * head ) { node * curr = head ; for ( int i = 30 ; i >= 0 ; i -- ) { int val = ( x >> i ) & 1 ; if ( val == 0 ) { if ( ! curr -> left ) curr -> left = new node ( ) ; curr = curr -> left ; } else { if ( ! curr -> right ) curr -> right = new node ( ) ; curr = curr -> right ; } } } int findMaximumXOR ( int arr [ ] , int n ) { node * head = new node ( ) ; for ( int i = 0 ; i < n ; i ++ ) { insert ( arr [ i ] , head ) ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; int M = pow ( 2 , 30 ) ; node * curr = head ; for ( int j = 30 ; j >= 0 ; j -- ) { int val = ( arr [ i ] >> j ) & 1 ; if ( val == 0 ) { if ( curr -> right ) { curr_xor += M ; curr = curr -> right ; } else { curr = curr -> left ; } } else { if ( curr -> left ) { curr_xor += M ; curr = curr -> left ; } else { curr = curr -> right ; } } M /= 2 ; } ans = max ( ans , curr_xor ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaximumXOR ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintIndexes ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int currSubSum = 0 ; for ( int j = i ; j < N ; j ++ ) { currSubSum += arr [ j ] ; int sq = sqrt ( currSubSum ) ; if ( sq * sq == currSubSum ) { cout << " ( " << i << " , ▁ " << j << " ) ▁ " ; } } } } int main ( ) { int arr [ ] = { 65 , 79 , 81 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; PrintIndexes ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int right = INT_MIN ; int left = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ 1 ] > right ) { right = arr [ i ] [ 1 ] ; } if ( arr [ i ] [ 0 ] < left ) { left = arr [ i ] [ 0 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] == left && arr [ i ] [ 1 ] == right ) { pos = i + 1 ; } } cout << pos << endl ; } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAtLevel ( int N , int M , vector < int > Value , int Edges [ ] [ 2 ] ) { vector < int > adj [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; adj [ u ] . push_back ( v ) ; } queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int count = q . size ( ) ; int maxVal = 0 ; while ( count -- ) { int temp = q . front ( ) ; q . pop ( ) ; maxVal = max ( maxVal , Value [ temp ] ) ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } cout << maxVal << " ▁ " ; } } int main ( ) { int N = 10 ; int Edges [ ] [ 2 ] = { { 0 , 1 } , { 0 , 2 } , { 0 , 3 } , { 1 , 4 } , { 1 , 5 } , { 3 , 6 } , { 6 , 7 } , { 6 , 8 } , { 6 , 9 } } ; vector < int > Value = { 1 , 2 , -1 , 3 , 4 , 5 , 8 , 6 , 12 , 7 } ; maxAtLevel ( N , N - 1 , Value , Edges ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ctTriplets ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; vector < int > temp ( N ) ; int index = 0 ; for ( int i = 1 ; i < N ; i += 2 ) { temp [ i ] = arr [ index ++ ] ; } for ( int i = 0 ; i < N ; i += 2 ) { temp [ i ] = arr [ index ++ ] ; } int ct = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i > 0 && i + 1 < N ) { if ( temp [ i ] < temp [ i + 1 ] && temp [ i ] < temp [ i - 1 ] ) { ct ++ ; } } } cout << " Count ▁ of ▁ triplets : " << ct << endl ; cout << " Array : " ; for ( int i = 0 ; i < N ; i ++ ) { cout << temp [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ctTriplets ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countSubarrays ( int a [ ] , int n , int k ) { int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { if ( ( pref [ j ] - pref [ i - 1 ] + k ) % k == j - i + 1 ) { ans ++ ; } } } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; countSubarrays ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countSubarrays ( int a [ ] , int n , int k ) { unordered_map < int , int > cnt ; long long int ans = 0 ; vector < int > pref ; pref . push_back ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref . push_back ( ( a [ i ] + pref [ i ] ) % k ) ; cnt [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { int remIdx = i - k ; if ( remIdx >= 0 ) { cnt [ ( pref [ remIdx ] - remIdx % k + k ) % k ] -- ; } ans += cnt [ ( pref [ i ] - i % k + k ) % k ] ; cnt [ ( pref [ i ] - i % k + k ) % k ] ++ ; } cout << ans << ' ▁ ' ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 3 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; countSubarrays ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int a [ ] , int n ) { int b [ n ] ; int minElement = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = a [ i ] ; minElement = min ( minElement , a [ i ] ) ; } sort ( b , b + n ) ; int k = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] && a [ i ] % minElement != 0 ) { k = 0 ; break ; } } return k == 1 ? true : false ; } int main ( ) { int a [ ] = { 4 , 3 , 6 , 6 , 2 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( check ( a , n ) == true ) cout << " Yes ▁ STRNEWLINE " ; else cout << " No ▁ STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ctMinEdits ( string str1 , string str2 ) { int N1 = str1 . length ( ) ; int N2 = str2 . length ( ) ; int freq1 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N1 ; i ++ ) { freq1 [ str1 [ i ] ] ++ ; } int freq2 [ 256 ] = { 0 } ; for ( int i = 0 ; i < N2 ; i ++ ) { freq2 [ str2 [ i ] ] ++ ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freq1 [ i ] > freq2 [ i ] ) { freq1 [ i ] = freq1 [ i ] - freq2 [ i ] ; freq2 [ i ] = 0 ; } else { freq2 [ i ] = freq2 [ i ] - freq1 [ i ] ; freq1 [ i ] = 0 ; } } int sum1 = 0 ; int sum2 = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { sum1 += freq1 [ i ] ; sum2 += freq2 [ i ] ; } return max ( sum1 , sum2 ) ; } int main ( ) { string str1 = " geeksforgeeks " ; string str2 = " geeksforcoder " ; cout << ctMinEdits ( str1 , str2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperation ( string s ) { int n = s . length ( ) ; int temp1 = -1 , temp2 = -1 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr = s [ i ] ; if ( curr == '0' ) { if ( temp1 == -1 && temp2 == -1 ) { temp1 = i ; } else if ( temp1 != -1 && temp2 == -1 && i - temp1 == 1 ) { temp2 = i ; } else if ( temp1 != -1 ) { temp1 = -1 ; ans ++ ; } else if ( temp1 == -1 && temp2 != -1 && i - temp2 != 1 ) { temp2 = -1 ; ans ++ ; } } } if ( temp1 != -1 && temp2 != -1 ) { ans += 2 ; } else if ( temp1 != -1 temp2 != -1 ) { ans += 1 ; } return ans ; } int main ( ) { string s = "110010" ; cout << ( minOperation ( s ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinLength ( vector < int > & arr ) { int index = ( int ) arr . size ( ) - 1 ; while ( index > 0 && arr [ index ] >= arr [ index - 1 ] ) { index -- ; } return index ; } int main ( ) { vector < int > arr = { 7 , 8 , 5 , 0 , -1 , -1 , 0 , 1 , 2 , 3 , 4 } ; cout << findMinLength ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountPairs ( int * a , int * b , int n ) { int C [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { C [ i ] = a [ i ] + b [ i ] ; } map < int , int > freqCount ; for ( int i = 0 ; i < n ; i ++ ) { freqCount [ C [ i ] ] ++ ; } int NoOfPairs = 0 ; for ( auto x : freqCount ) { int y = x . second ; NoOfPairs = NoOfPairs + y * ( y - 1 ) / 2 ; } cout << NoOfPairs ; } int main ( ) { int arr [ ] = { 1 , 4 , 20 , 3 , 10 , 5 } ; int brr [ ] = { 9 , 6 , 1 , 7 , 11 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; CountPairs ( arr , brr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void convertBfromA ( int a , int b ) { int moves = 0 ; int x = abs ( a - b ) ; for ( int i = 10 ; i > 0 ; i -- ) { moves += x / i ; x = x % i ; } cout << moves << " ▁ " ; } int main ( ) { int A = 188 , B = 4 ; convertBfromA ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestNth ( int A , int B , int N ) { int res = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = N ; j > i ; j -- ) { if ( ( B - A ) % ( j - i ) == 0 ) { int D = ( B - A ) / ( j - i ) ; int FirstTerm = A - ( i - 1 ) * D ; int NthTerm = FirstTerm + ( N - 1 ) * D ; if ( FirstTerm > 0 ) res = min ( res , NthTerm ) ; } } } return res ; } int main ( ) { int N = 3 ; int A = 1 ; int B = 6 ; cout << smallestNth ( A , B , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sieve ( bool prime [ ] ) { for ( int i = 0 ; i < 1000000 ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j <= 1000000 ; j += i ) { prime [ j ] = false ; } } } } void subPrimeSum ( int N , int K , int arr [ ] , bool prime [ ] ) { int currSum = 0 ; for ( int i = 0 ; i < K ; i ++ ) { currSum += arr [ i ] ; } if ( prime [ currSum ] ) { for ( int i = 0 ; i < K ; i ++ ) { cout << arr [ i ] << " ▁ " ; } return ; } int st = 1 , en = K ; while ( en < N ) { currSum += arr [ en ] - arr [ st - 1 ] ; if ( prime [ currSum ] ) { for ( int i = st ; i <= en ; i ++ ) { cout << arr [ i ] << " ▁ " ; } return ; } en ++ ; st ++ ; } } int main ( ) { int arr [ ] = { 20 , 7 , 5 , 4 , 3 , 11 , 99 , 87 , 23 , 45 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; bool prime [ 1000000 ] ; sieve ( prime ) ; subPrimeSum ( N , K , arr , prime ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSum ( int a [ ] , int b [ ] , int n , int index , int lastpicked ) { if ( index == n ) return 0 ; int option1 = 0 , option2 = 0 ; if ( lastpicked == -1 a [ lastpicked ] != a [ index ] ) option1 = b [ index ] + maximumSum ( a , b , n , index + 1 , index ) ; option2 = maximumSum ( a , b , n , index + 1 , lastpicked ) ; return max ( option1 , option2 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 1 } ; int brr [ ] = { -1 , 2 , 10 , 20 , -10 , -9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( maximumSum ( arr , brr , N , 0 , -1 ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumOfKElements ( int arr [ ] , int n , int k ) { bool rev = false ; if ( k < 0 ) { rev = true ; k *= -1 ; int l = 0 , r = n - 1 ; while ( l < r ) { int tmp = arr [ l ] ; arr [ l ] = arr [ r ] ; arr [ r ] = tmp ; l ++ ; r -- ; } } int dp [ n ] = { 0 } ; dp [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] += dp [ i - 1 ] + arr [ i ] ; } int ans [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + k < n ) ans [ i ] = dp [ i + k ] - dp [ i ] ; else { int x = k - ( n - 1 - i ) ; int y = x / n ; int rem = x % n ; ans [ i ] = dp [ n - 1 ] - dp [ i ] + y * dp [ n - 1 ] + ( rem - 1 >= 0 ? dp [ rem - 1 ] : 0 ) ; } } if ( rev ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { cout << ans [ i ] << " ▁ " ; } } else { for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } } int main ( ) { int arr [ ] = { 4 , 2 , -5 , 11 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; sumOfKElements ( arr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binaryInsert ( vector < int > & boundary , int i ) { int l = 0 ; int r = boundary . size ( ) - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( boundary [ m ] < i ) l = m + 1 ; else r = m - 1 ; } boundary . insert ( boundary . begin ( ) + l , i ) ; return l ; } vector < int > countingSubarray ( vector < int > arr , int n ) { unordered_map < int , int > index ; for ( int i = 0 ; i < n ; i ++ ) index [ arr [ i ] ] = i ; vector < int > boundary = { -1 , n } ; sort ( arr . begin ( ) , arr . end ( ) ) ; vector < int > ans ( n , 0 ) ; for ( int num : arr ) { int i = binaryInsert ( boundary , index [ num ] ) ; int l = boundary [ i ] - boundary [ i - 1 ] - 1 ; int r = boundary [ i + 1 ] - boundary [ i ] - 1 ; int cnt = l + r + l * r + 1 ; ans [ index [ num ] ] += cnt ; } return ans ; } int main ( ) { int N = 5 ; vector < int > arr = { 3 , 2 , 4 , 1 , 5 } ; auto a = countingSubarray ( arr , N ) ; cout << " [ " ; int n = a . size ( ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " , ▁ " ; cout << a [ n ] << " ] " ; return 0 ; }
#include <algorithm> NEW_LINE #include <bits/stdc++.h> NEW_LINE #define limit  1000000000 NEW_LINE using namespace std ; long long F ( long long N ) { string str = to_string ( N ) ; long long sum = 0 ; for ( long long i = 0 ; i < str . size ( ) ; i ++ ) { long long val = int ( str [ i ] - '0' ) ; sum += val * val * val ; } return sum ; } long long findDestination ( long long N ) { set < long long > s ; long long prev = N , next ; s . insert ( N ) ; while ( N <= limit ) { next = F ( N ) ; auto it = s . find ( next ) ; if ( it != s . end ( ) ) { return next ; } prev = next ; s . insert ( prev ) ; N = next ; } return next ; } void digitCubeLimit ( long long N ) { if ( N < 0 ) cout << " N ▁ cannot ▁ be ▁ negative STRNEWLINE " ; else { long long ans = findDestination ( N ) ; if ( ans > limit ) cout << " Limit ▁ exceeded STRNEWLINE " ; else if ( ans == F ( ans ) ) { cout << N ; cout << " ▁ reaches ▁ to ▁ a " << " ▁ fixed ▁ point : ▁ " ; cout << ans ; } else { cout << N ; cout << " ▁ reaches ▁ to ▁ a " << " ▁ limit ▁ cycle : ▁ " ; cout << ans ; } } } int main ( ) { long long N = 3 ; digitCubeLimit ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTuples ( int arr [ ] , int N ) { int ans = 0 , val = 0 ; unordered_map < int , int > freq ; for ( int j = 0 ; j < N - 2 ; j ++ ) { val = 0 ; for ( int l = j + 1 ; l < N ; l ++ ) { if ( arr [ j ] == arr [ l ] ) { ans += val ; } val += freq [ arr [ l ] ] ; } freq [ arr [ j ] ] ++ ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countTuples ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperation ( int arr [ ] , int N ) { int minOp = INT_MIN ; int minNeg = 0 , maxPos = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { if ( arr [ i ] < minNeg ) minNeg = arr [ i ] ; } else { if ( arr [ i ] > maxPos ) maxPos = arr [ i ] ; } } return abs ( minNeg ) + maxPos ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperation ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) { return a ; } return GCD ( b , a % b ) ; } void GcdPair ( vector < pair < int , int > > arr , int k ) { int lo = 0 , hi = arr . size ( ) - 1 , mid ; pair < int , int > ans ; ans = make_pair ( -1 , 0 ) ; while ( lo <= hi ) { mid = lo + ( hi - lo ) / 2 ; if ( GCD ( arr [ mid ] . first , arr [ mid ] . second ) > k ) { ans = arr [ mid ] ; hi = mid - 1 ; } else lo = mid + 1 ; } if ( ans . first == -1 ) cout << " - 1" ; else cout << " ( ▁ " << ans . first << " , ▁ " << ans . second << " ▁ ) " ; return ; } int main ( ) { vector < pair < int , int > > arr = { { 3 , 6 } , { 15 , 30 } , { 25 , 75 } , { 30 , 120 } } ; int K = 16 ; GcdPair ( arr , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void addEdge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void DFSUtil ( int u , vector < int > adj [ ] , vector < bool > & visited , int & componentMin , int & componentMax ) { visited [ u ] = true ; componentMax = max ( componentMax , u ) ; componentMin = min ( componentMin , u ) ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) if ( visited [ adj [ u ] [ i ] ] == false ) DFSUtil ( adj [ u ] [ i ] , adj , visited , componentMin , componentMax ) ; } bool isValid ( vector < pair < int , int > > & v ) { int MAX = -1 ; bool ans = 0 ; for ( auto i : v ) { if ( i . first <= MAX ) { ans = 1 ; } MAX = max ( MAX , i . second ) ; } return ( ans == 0 ? 1 : 0 ) ; } void DFS ( vector < int > adj [ ] , int V ) { std :: vector < pair < int , int > > v ; vector < bool > visited ( V , false ) ; for ( int u = 1 ; u <= V ; u ++ ) { if ( visited [ u ] == false ) { int componentMax = u ; int componentMin = u ; DFSUtil ( u , adj , visited , componentMin , componentMax ) ; v . push_back ( { componentMin , componentMax } ) ; } } bool check = isValid ( v ) ; if ( check ) cout << " Yes " ; else cout << " No " ; return ; } int main ( ) { int N = 4 , K = 3 ; vector < int > adj [ N + 1 ] ; addEdge ( adj , 1 , 2 ) ; addEdge ( adj , 2 , 3 ) ; addEdge ( adj , 3 , 4 ) ; DFS ( adj , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longDelSub ( string str1 , string str2 ) { int N = str1 . size ( ) ; int M = str2 . size ( ) ; int prev_pos = 0 ; int pos [ M ] ; for ( int i = 0 ; i < M ; i ++ ) { int index = prev_pos ; while ( index < N && str1 [ index ] != str2 [ i ] ) { index ++ ; } pos [ i ] = index ; prev_pos = index + 1 ; } int res = N - prev_pos ; prev_pos = N - 1 ; for ( int i = M - 1 ; i >= 0 ; i -- ) { int index = prev_pos ; while ( index >= 0 && str1 [ index ] != str2 [ i ] ) { index -- ; } if ( i != 0 ) { res = max ( res , index - pos [ i - 1 ] - 1 ) ; } prev_pos = index - 1 ; } res = max ( res , prev_pos + 1 ) ; return res ; } int main ( ) { string str1 = " GeeksforGeeks " ; string str2 = " forks " ; cout << longDelSub ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( string S ) { int count_0 = 0 , count_1 = 0 ; int prev = -1 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S [ i ] == '0' ) count_0 ++ ; else if ( S [ i ] == '1' ) count_1 ++ ; } for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S [ i ] == ' * ' ) continue ; else if ( S [ i ] == '0' && prev == -1 ) { count_0 = count_0 + i ; prev = i ; } else if ( S [ i ] == '1' && prev == -1 ) { prev = i ; } else if ( S [ prev ] == '1' && S [ i ] == '0' ) { count_0 = count_0 + ( i - prev - 1 ) / 2 ; count_1 = count_1 + ( i - prev - 1 ) / 2 ; prev = i ; } else if ( S [ prev ] == '1' && S [ i ] == '1' ) { count_1 = count_1 + ( i - prev - 1 ) ; prev = i ; } else if ( S [ prev ] == '0' && S [ i ] == '1' ) prev = i ; else if ( S [ prev ] == '0' && S [ i ] == '0' ) { count_0 = count_0 + ( i - prev - 1 ) ; prev = i ; } } if ( count_0 > count_1 ) cout << "0" ; else if ( count_1 > count_0 ) cout << "1" ; else { cout << -1 ; } } int main ( ) { string str = " * *0 * * 1 * * *0" ; solve ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minFirstTerm ( int X , int diff , int N ) { int first_term ; int low = 0 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( X - mid * diff > 0 ) { first_term = X - mid * diff ; low = mid + 1 ; } else high = mid - 1 ; } return first_term ; } void printAP ( int N , int X , int Y ) { if ( X > Y ) swap ( X , Y ) ; int maxDiff = Y - X ; int first_term = INT_MAX , diff ; for ( int i = 1 ; i * i <= maxDiff ; i ++ ) { if ( maxDiff % i == 0 ) { int diff1 = i ; int diff2 = maxDiff / diff1 ; int terms1 = diff2 + 1 ; int terms2 = diff1 + 1 ; int first_term1 = minFirstTerm ( X , diff1 , N - terms1 ) ; int first_term2 = minFirstTerm ( X , diff2 , N - terms2 ) ; if ( first_term1 < first_term ) { first_term = first_term1 ; diff = diff1 ; } if ( first_term2 < first_term ) { first_term = first_term2 ; diff = diff2 ; } } } for ( int i = 0 ; i < N ; i ++ ) { cout << first_term << " ▁ " ; first_term += diff ; } } int main ( ) { int N = 5 , X = 10 , Y = 15 ; printAP ( N , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCubeSum ( int n ) { for ( int i = 1 ; i * i * i <= n ; i ++ ) { if ( i * i * i + ( i + 1 ) * ( i + 1 ) * ( i + 1 ) == n ) return true ; } return false ; } int main ( ) { int n = 35 ; if ( isCubeSum ( n ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSumCube ( int N ) { int a = cbrt ( N ) ; int b = a - 1 ; return ( ( a * a * a + b * b * b ) == N ) ; } int main ( ) { int i = 35 ; if ( isSumCube ( i ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxweight ( int s , int e , unordered_map < int , int > & pre ) { if ( s == e ) return 0 ; int ans = 0 ; for ( int i = s ; i < e ; i ++ ) { int left = pre [ i ] - pre [ s - 1 ] ; int right = pre [ e ] - pre [ i ] ; if ( left < right ) ans = max ( ans , left + maxweight ( s , i , pre ) ) ; if ( left == right ) { ans = max ( { ans , left + maxweight ( s , i , pre ) , right + maxweight ( i + 1 , e , pre ) } ) ; } if ( left > right ) ans = max ( ans , right + maxweight ( i + 1 , e , pre ) ) ; } return ans ; } void maxSum ( vector < int > arr ) { unordered_map < int , int > pre ; pre [ -1 ] = 0 ; pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } cout << maxweight ( 0 , arr . size ( ) - 1 , pre ) ; } int main ( ) { vector < int > arr = { 6 , 2 , 3 , 4 , 5 , 5 } ; maxSum ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestTimeFromDigits ( vector < int > & A ) { map < int , int > mp1 , mp2 ; for ( auto x : A ) { mp1 [ x ] ++ ; } mp2 = mp1 ; int hr = 23 , m = 59 , s = 59 ; while ( hr >= 0 ) { int h0 = hr / 10 , h1 = hr % 10 ; int m0 = m / 10 , m1 = m % 10 ; int s0 = s / 10 , s1 = s % 10 ; int p = 0 ; vector < int > arr { h0 , h1 , m0 , m1 , s0 , s1 } ; for ( auto & it : arr ) { if ( mp1 [ it ] > 0 ) { mp1 [ it ] -- ; } else { p = 1 ; } } if ( p == 0 ) { string s = " " ; s = to_string ( h0 ) + to_string ( h1 ) ; s += ' : ' + to_string ( m0 ) + to_string ( m1 ) ; s += ' : ' + to_string ( s0 ) + to_string ( s1 ) ; return s ; } mp1 = mp2 ; if ( s == 0 ) { s = 59 ; m -- ; } else if ( m < 0 ) { m = 59 ; hr -- ; } if ( s > 0 ) { s -- ; } } return " - 1" ; } int main ( ) { vector < int > v = { 0 , 2 , 1 , 9 , 3 , 2 } ; cout << largestTimeFromDigits ( v ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countNumEnds ( int A , int L , int R ) { int temp , count = 0 , digits ; int cycle ; digits = log10 ( A ) + 1 ; temp = pow ( 10 , digits ) ; cycle = temp ; while ( temp <= R ) { if ( temp >= L ) count ++ ; temp += cycle ; } cout << count ; } int main ( ) { int A = 2 , L = 2 , R = 20 ; countNumEnds ( A , L , R ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string s ) { int len = s . length ( ) ; int result = 0 ; for ( int i = 0 ; i < len / 2 ; i ++ ) { int D1 = max ( s [ i ] , s [ len - 1 - i ] ) - min ( s [ i ] , s [ len - 1 - i ] ) ; int D2 = 26 - D1 ; result += min ( D1 , D2 ) ; } return result ; } int main ( ) { string s = " abccdb " ; cout << minOperations ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findFactor ( int value , unordered_set < int > & factors ) { factors . insert ( value ) ; for ( int i = 2 ; i * i <= value ; i ++ ) { if ( value % i == 0 ) { if ( value / i == i ) { if ( factors . find ( i ) != factors . end ( ) ) { return true ; } else { factors . insert ( i ) ; } } else { if ( factors . find ( i ) != factors . end ( ) || factors . find ( value / i ) != factors . end ( ) ) { return true ; } else { factors . insert ( i ) ; factors . insert ( value / i ) ; } } } } return false ; } bool allCoprime ( int A [ ] , int n ) { bool all_coprime = true ; unordered_set < int > factors ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] == 1 ) continue ; if ( findFactor ( A [ i ] , factors ) ) { all_coprime = false ; break ; } } return all_coprime ; } int main ( ) { int A [ ] = { 3 , 5 , 11 , 7 , 19 } ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( allCoprime ( A , arr_size ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int arr [ ] , int n , int value ) ; double countSubSequence ( int arr [ ] , int n ) { int maximum = * max_element ( arr , arr + n ) ; int minimum = * min_element ( arr , arr + n ) ; if ( maximum == minimum ) return pow ( 2 , n ) - 1 ; int i = count ( arr , n , maximum ) ; int j = count ( arr , n , minimum ) ; double res = ( pow ( 2 , i ) - 1 ) * ( pow ( 2 , j ) - 1 ) * pow ( 2 , n - i - j ) ; return res ; } int count ( int arr [ ] , int n , int value ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == value ) sum ++ ; return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubSequence ( arr , n ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int transformSubsequence ( int n , int m , vector < int > A , vector < int > B ) { if ( B . size ( ) == 0 ) return n ; vector < vector < int > > dp ( n + 1 , vector < int > ( m + 1 , 0 ) ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 or j == 0 ) dp [ i ] [ j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return n - dp [ n ] [ m ] ; } int main ( ) { int N = 5 ; int M = 6 ; vector < int > A = { 1 , 2 , 3 , 4 , 5 } ; vector < int > B = { 2 , 5 , 6 , 4 , 9 , 12 } ; cout << transformSubsequence ( N , M , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkForPerfectSquare ( vector < int > arr , int i , int j ) { int mid , sum = 0 ; for ( int m = i ; m <= j ; m ++ ) { sum += arr [ m ] ; } int low = 0 , high = sum / 2 ; while ( low <= high ) { mid = low + ( high - low ) / 2 ; if ( mid * mid == sum ) { return mid ; } else if ( mid * mid > sum ) { high = mid - 1 ; } else { low = mid + 1 ; } } return -1 ; } int main ( ) { vector < int > arr ; arr = { 2 , 19 , 33 , 48 , 90 , 100 } ; int L = 1 , R = 3 ; cout << checkForPerfectSquare ( arr , L , R ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int calcSubarray ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { bool flag = true ; int comm_diff = A [ i + 1 ] - A [ i ] ; for ( int k = i ; k < j ; k ++ ) { if ( A [ k + 1 ] - A [ k ] == comm_diff ) { continue ; } else { flag = false ; break ; } } if ( flag ) { count ++ ; } } } return count ; } int main ( ) { int A [ 5 ] = { 8 , 7 , 4 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( int ) ; cout << calcSubarray ( A , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumSubarray ( int arr [ ] , int n ) { int i = 0 , j = 1 ; set < int > set ; set . insert ( arr [ 0 ] ) ; int sum = arr [ 0 ] ; int maxsum = sum ; while ( i < n - 1 && j < n ) { const bool is_in = set . find ( arr [ j ] ) != set . end ( ) ; if ( ! is_in ) { sum = sum + arr [ j ] ; maxsum = max ( sum , maxsum ) ; set . insert ( arr [ j ++ ] ) ; } else { sum -= arr [ i ] ; set . erase ( arr [ i ++ ] ) ; } } return maxsum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 1 , 5 } ; int ans = maxSumSubarray ( arr , 5 ) ; cout << ( ans ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_numbers ( int L , int R ) { int ans = 0 ; for ( int n = L ; n <= R ; n ++ ) { int no_of_bits = log2 ( n ) + 1 ; int no_of_set_bits = __builtin_popcount ( n ) ; if ( no_of_bits - no_of_set_bits == 1 ) { ans ++ ; } } return ans ; } int main ( ) { int L = 4 , R = 9 ; cout << count_numbers ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_numbers ( int L , int R ) { int ans = 0 ; int LogR = log2 ( R ) + 1 ; for ( int zero_bit = 0 ; zero_bit < LogR ; zero_bit ++ ) { int cur = 0 ; for ( int j = 0 ; j < zero_bit ; j ++ ) { cur |= ( 1LL << j ) ; } for ( int j = zero_bit + 1 ; j < LogR ; j ++ ) { cur |= ( 1LL << j ) ; if ( cur >= L && cur <= R ) { ans ++ ; } } } return ans ; } int main ( ) { long long L = 4 , R = 9 ; cout << count_numbers ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countElements ( int a [ ] , int n ) { int cnt [ n + 1 ] = { 0 } ; memset ( cnt , 0 , sizeof ( cnt ) ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ cnt [ a [ i ] ] ; } for ( int l = 0 ; l < n ; ++ l ) { int sum = 0 ; for ( int r = l ; r < n ; ++ r ) { sum += a [ r ] ; if ( l == r ) continue ; if ( sum <= n ) { ans += cnt [ sum ] ; cnt [ sum ] = 0 ; } } } return ans ; } int main ( ) { int a [ ] = { 1 , 1 , 1 , 1 , 1 } ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countElements ( a , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxGCD ( int n ) { return ( n / 2 ) ; } int main ( ) { int n = 4 ; cout << maxGCD ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOddIndexCharacters ( string s ) { string new_string = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i % 2 == 1 ) { continue ; } new_string += s [ i ] ; } return new_string ; } int main ( ) { string str = " abcdef " ; cout << removeOddIndexCharacters ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestGP ( int A [ ] , int N ) { if ( N < 2 ) return N ; int length = 1 , common_ratio = 1 ; int maxlength = 1 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i + 1 ] % A [ i ] == 0 ) { if ( A [ i + 1 ] / A [ i ] == common_ratio ) { length = length + 1 ; maxlength = max ( maxlength , length ) ; } else { common_ratio = A [ i + 1 ] / A [ i ] ; length = 2 ; } } else { maxlength = max ( maxlength , length ) ; length = 1 ; } } maxlength = max ( maxlength , length ) ; return maxlength ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 7 , 14 , 28 , 56 , 89 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestGP ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int uncrossedLines ( int * a , int * b , int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 0 ; else if ( a [ i - 1 ] == b [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ n ] [ m ] ; } int main ( ) { int A [ ] = { 3 , 9 , 2 } ; int B [ ] = { 3 , 2 , 9 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int M = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << uncrossedLines ( A , B , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minFlips ( vector < vector < int > > & mat , string s ) { int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != s [ i + j ] - '0' ) { count ++ ; } } } return count ; } int main ( ) { vector < vector < int > > mat = { { 1 , 0 , 1 } , { 0 , 1 , 1 } , { 0 , 0 , 0 } } ; string s = "10001" ; cout << minFlips ( mat , s ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void lcmpair ( int l , int r ) { int x , y ; x = l ; y = 2 * l ; if ( y > r ) { cout << " - 1 STRNEWLINE " ; } else { cout << " X ▁ = ▁ " << x << " ▁ Y ▁ = ▁ " << y << " STRNEWLINE " ; } } int main ( ) { int l = 13 , r = 69 ; lcmpair ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int revNum ( int N ) { int x = 0 ; while ( N ) { x = x * 10 + N % 10 ; N = N / 10 ; } return x ; } int ctNonPalin ( int arr [ ] , int N ) { int Res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = revNum ( arr [ i ] ) ; if ( x == arr [ i ] ) { continue ; } else { Res += ( arr [ i ] % 10 == N % 10 ) ; } } return Res ; } int main ( ) { int arr [ ] = { 121 , 134 , 2342 , 4514 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ctNonPalin ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minlt ( vector < int > arr , int target , int n ) { vector < vector < int > > dp ( arr . size ( ) + 1 , vector < int > ( target + 1 , -1 ) ) ; for ( int i = 0 ; i < arr . size ( ) + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int j = 0 ; j < target + 1 ; j ++ ) dp [ 0 ] [ j ] = INT_MAX ; for ( int i = 1 ; i <= arr . size ( ) ; i ++ ) { for ( int j = 1 ; j <= target ; j ++ ) { if ( arr [ i - 1 ] > j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , ( dp [ i ] [ j - arr [ i - 1 ] ] ) != INT_MAX ? ( dp [ i ] [ j - arr [ i - 1 ] ] + 1 ) : INT_MAX ) ; } } } if ( dp [ arr . size ( ) ] [ target ] == INT_MAX ) { return -1 ; } else { return dp [ arr . size ( ) ] [ target ] ; } } int main ( ) { vector < int > arr = { 2 , 3 , 5 , 4 , 1 } ; int target = 11 ; int n = arr . size ( ) ; cout << minlt ( arr , target , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSame ( string str , int n ) { map < int , int > mp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mp [ str [ i ] - ' a ' ] ++ ; } for ( auto it : mp ) { if ( ( it . second ) >= n ) { return true ; } } return false ; } int main ( ) { string str = " ccabcba " ; int n = 4 ; if ( isSame ( str , n ) ) { cout << " Yes " ; } else { cout << " No " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minServerLoads ( int n , vector < int > & servers ) { int totalLoad = 0 ; for ( int i : servers ) totalLoad += i ; int requiredLoad = totalLoad / 2 ; vector < vector < int > > dp ( n + 1 , vector < int > ( requiredLoad + 1 , 0 ) ) ; for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < requiredLoad + 1 ; j ++ ) { if ( servers [ i - 1 ] > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , servers [ i - 1 ] + dp [ i - 1 ] [ j - servers [ i - 1 ] ] ) ; } } return totalLoad - 2 * dp [ n ] [ requiredLoad ] ; } int main ( ) { int N = 5 ; vector < int > servers = { 1 , 2 , 3 , 4 , 5 } ; cout << ( minServerLoads ( N , servers ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLenSub ( int arr [ ] , int N ) { int Pos = 0 ; int Neg = 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { Pos = Neg = 0 ; } else if ( arr [ i ] > 0 ) { Pos += 1 ; if ( Neg != 0 ) { Neg += 1 ; } res = max ( res , Pos ) ; } else { swap ( Pos , Neg ) ; Neg += 1 ; if ( Pos != 0 ) { Pos += 1 ; } res = max ( res , Pos ) ; } } return res ; } int main ( ) { int arr [ ] = { -1 , -2 , -3 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxLenSub ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( vector < string > arr ) { int len = INT_MIN ; int N = arr . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int l = arr [ i ] . size ( ) ; if ( len < l ) { len = l ; } } return len ; } void maxStrings ( vector < string > arr , int len ) { int N = arr . size ( ) ; vector < string > ans ; for ( int i = 0 ; i < N ; i ++ ) { if ( len == arr [ i ] . size ( ) ) { ans . push_back ( arr [ i ] ) ; } } for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } void printStrings ( vector < string > & arr ) { int max = maxLength ( arr ) ; maxStrings ( arr , max ) ; } int main ( ) { vector < string > arr = { " aba " , " aa " , " ad " , " vcd " , " aba " } ; printStrings ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < int > > maxSubArray ( int arr [ ] , int n , int K ) { vector < vector < int > > solution ; int multi = 1 ; int start = 0 ; if ( n <= 1 K < 0 ) { return solution ; } for ( int i = 0 ; i < n ; i ++ ) { multi = multi * arr [ i ] ; while ( multi > K ) { multi = multi / arr [ start ] ; start ++ ; } vector < int > list ; for ( int j = i ; j >= start ; j -- ) { list . insert ( list . begin ( ) , arr [ j ] ) ; solution . push_back ( list ) ; } } return solution ; } int main ( ) { int arr [ ] = { 2 , 7 , 1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 7 ; vector < vector < int > > v = maxSubArray ( arr , n , K ) ; cout << " [ " ; bool first = true ; for ( auto x : v ) { if ( ! first ) { cout << " , ▁ " ; } else { first = false ; } cout << " [ " ; bool ff = true ; for ( int y : x ) { if ( ! ff ) { cout << " , ▁ " ; } else { ff = false ; } cout << y ; } cout << " ] " ; } cout << " ] " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( vector < vector < int > > & D , int N , int X , int Y ) { vector < double > T ; for ( int i = 0 ; i < N ; i ++ ) { int x = D [ i ] [ 0 ] ; int y = D [ i ] [ 1 ] ; double speed = D [ i ] [ 2 ] ; double time = ( ( x * x - X * X ) + ( y * y - Y * Y ) ) / ( speed * speed ) ; T . push_back ( time ) ; } sort ( T . begin ( ) , T . end ( ) ) ; int i = 0 ; int total = 0 ; while ( i < T . size ( ) - 1 ) { int count = 1 ; while ( i < T . size ( ) - 1 and T [ i ] == T [ i + 1 ] ) { count += 1 ; i += 1 ; } total += ( count * ( count - 1 ) ) / 2 ; i += 1 ; } return total ; } int main ( ) { int N = 5 ; vector < vector < int > > D = { { 5 , 12 , 1 } , { 16 , 63 , 5 } , { -10 , 24 , 2 } , { 7 , 24 , 2 } , { -24 , 7 , 2 } } ; int X = 0 , Y = 0 ; cout << ( solve ( D , N , X , Y ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMaxLength ( int arr [ ] , int N ) { int res = 2 ; int dist = 2 ; int curradj = ( arr [ 1 ] - arr [ 0 ] ) ; int prevadj = ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < N ; i ++ ) { curradj = arr [ i ] - arr [ i - 1 ] ; if ( curradj == prevadj ) { dist ++ ; } else { prevadj = curradj ; res = max ( res , dist ) ; dist = 2 ; } } res = max ( res , dist ) ; return res ; } int main ( ) { int arr [ ] = { 10 , 7 , 4 , 6 , 8 , 10 , 11 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMaxLength ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE #include <vector> NEW_LINE using namespace std ; int minSteps ( string str , int N ) { int smaller , cost = 0 ; int f [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int curr_ele = str [ i ] - ' a ' ; smaller = 0 ; for ( int j = 0 ; j <= curr_ele ; j ++ ) { if ( f [ j ] ) smaller += f [ j ] ; } if ( smaller == 0 ) cost += ( i + 1 ) ; else cost += ( i - smaller + 1 ) ; f [ str [ i ] - ' a ' ] ++ ; } return cost ; } int main ( ) { string str = " abcab " ; int N = str . size ( ) ; cout << minSteps ( str , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool possible ( int T , int arr [ ] , int n , int d ) { int partition = 1 ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total = total + arr [ i ] ; if ( total > T ) { partition = partition + 1 ; total = arr [ i ] ; if ( partition > d ) { return false ; } } } return true ; } void calcT ( int n , int d , int arr [ ] ) { int mx = -1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = max ( mx , arr [ i ] ) ; sum = sum + arr [ i ] ; } int lb = mx ; int ub = sum ; while ( lb < ub ) { int T_mid = lb + ( ub - lb ) / 2 ; if ( possible ( T_mid , arr , n , d ) == true ) { ub = T_mid ; } else { lb = T_mid + 1 ; } } cout << lb << endl ; } int main ( ) { int d = 2 ; int arr [ ] = { 1 , 1 , 1 , 1 , 1 } ; int n = sizeof arr / sizeof arr [ 0 ] ; calcT ( n , d , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minReqSubstring ( string s , int n ) { char ongoing = ' N ' ; int count = 0 , l = s . size ( ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( ongoing == ' N ' ) { if ( s [ i ] < s [ i - 1 ] ) { ongoing = ' D ' ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = ' N ' ; } else { ongoing = ' I ' ; } } else if ( ongoing == ' I ' ) { if ( s [ i ] > s [ i - 1 ] ) { ongoing = ' I ' ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = ' I ' ; } else { ongoing = ' N ' ; count += 1 ; } } else { if ( s [ i ] < s [ i - 1 ] ) { ongoing = ' D ' ; } else if ( s [ i ] == s [ i - 1 ] ) { ongoing = ' D ' ; } else { ongoing = ' N ' ; count += 1 ; } } } return count + 1 ; } int main ( ) { string S = " aeccdhba " ; int n = S . size ( ) ; cout << ( minReqSubstring ( S , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimum_required_operations ( int arr [ ] , int n , int k ) { int answer = 0 ; long long mod = 1000000007 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + arr [ i + 1 ] > k ) { if ( arr [ i ] > k ) { answer += ( arr [ i ] - k ) ; arr [ i ] = k ; } answer += ( arr [ i ] + arr [ i + 1 ] ) - k ; arr [ i + 1 ] = ( k - arr [ i ] ) ; answer %= mod ; } } return answer ; } int main ( ) { int a [ ] = { 9 , 50 , 4 , 14 , 42 , 89 } ; int k = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << ( minimum_required_operations ( a , n , k ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findSmallestString ( string str1 , string str2 ) { int freq1 [ 26 ] , freq2 [ 26 ] ; memset ( freq1 , 0 , sizeof freq1 ) ; memset ( freq2 , 0 , sizeof freq2 ) ; int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; for ( int i = 0 ; i < n1 ; ++ i ) { freq1 [ str1 [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < n2 ; ++ i ) { freq2 [ str2 [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; ++ i ) { freq1 [ i ] -= freq2 [ i ] ; } string res = " " ; int minIndex = str2 [ 0 ] - ' a ' ; for ( int i = 0 ; i < 26 ; ++ i ) { for ( int j = 0 ; j < freq1 [ i ] ; ++ j ) { res += ( char ) ( i + ' a ' ) ; } if ( i == minIndex ) { res += str2 ; } } return res ; } int main ( ) { string str1 = " geeksforgeeksfor " ; string str2 = " for " ; cout << findSmallestString ( str1 , str2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void determineWinner ( string str ) { vector < int > A ( 10 ) ; int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { A [ int ( str [ i ] ) - 48 ] ++ ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( i % 2 != 0 ) { sum1 = sum1 + A [ i ] ; } else { sum2 = sum2 + A [ i ] ; } } if ( sum1 == sum2 ) { cout << " - 1" ; } else if ( sum1 > sum2 ) { cout << " Player ▁ 1" ; } else { cout << " Player ▁ 2" ; } } int main ( ) { string str = "78787" ; determineWinner ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void manipulateStrings ( string P , string Q ) { int freq [ 26 ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < P . size ( ) ; i ++ ) { freq [ P [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { freq [ Q [ i ] - ' a ' ] -- ; } string sb = " " ; int pos = Q [ 0 ] - ' a ' ; for ( int i = 0 ; i <= pos ; i ++ ) { while ( freq [ i ] > 0 ) { char c = ( char ) ( ' a ' + i ) ; sb += c ; freq [ i ] -- ; } } sb += Q ; for ( int i = pos + 1 ; i < 26 ; i ++ ) { while ( freq [ i ] > 0 ) { char c = ( char ) ( ' a ' + i ) ; sb += c ; freq [ i ] -- ; } } cout << sb << endl ; } int main ( ) { string P = " geeksforgeeksfor " ; string Q = " for " ; manipulateStrings ( P , Q ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberMoves ( string s ) { int row [ ] = { 2 , 3 , 3 , 2 , 1 , 2 , 2 , 2 , 1 , 2 , 2 , 2 , 3 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 1 , 3 , 1 , 3 } ; int n = s . length ( ) ; int move = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( row [ s [ i ] - ' a ' ] != row [ s [ i - 1 ] - ' a ' ] ) { move ++ ; } } return move ; } int main ( ) { string str = " geeksforgeeks " ; cout << numberMoves ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int L ; int R ; int K ; } ; int kMultipleSum ( int arr [ ] , Node Query [ ] , int N , int Q ) { int prefixSum [ N + 1 ] [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { prefixSum [ i ] [ 0 ] = arr [ 0 ] ; for ( int j = 0 ; j < N ; j ++ ) { if ( j % i == 0 ) { prefixSum [ i ] [ j ] = arr [ j ] + prefixSum [ i ] [ j - 1 ] ; } else { prefixSum [ i ] [ j ] = prefixSum [ i ] [ j - 1 ] ; } } } for ( int i = 0 ; i < Q ; i ++ ) { int last = prefixSum [ Query [ i ] . K ] [ Query [ i ] . R ] ; int first ; if ( Query [ i ] . L == 0 ) { first = prefixSum [ Query [ i ] . K ] [ Query [ i ] . L ] ; } else { first = prefixSum [ Query [ i ] . K ] [ Query [ i ] . L - 1 ] ; } cout << last - first << endl ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 2 ; Node Query [ Q ] ; Query [ 0 ] . L = 2 , Query [ 0 ] . R = 5 , Query [ 0 ] . K = 2 ; Query [ 1 ] . L = 3 , Query [ 1 ] . R = 5 , Query [ 1 ] . K = 5 ; kMultipleSum ( arr , Query , N , Q ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1000000007 ; long countS ( string str [ ] , int n , int m ) { unordered_map < int , unordered_set < char > > counts ; for ( int i = 0 ; i < n ; i ++ ) { string s = str [ i ] ; for ( int j = 0 ; j < m ; j ++ ) { counts [ j ] . insert ( s [ j ] ) ; } } long result = 1 ; for ( auto index : counts ) { result = ( result * counts [ index . first ] . size ( ) ) % mod ; } return result ; } int main ( ) { string str [ ] = { "112" , "211" } ; int N = 2 , M = 3 ; cout << countS ( str , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstrings ( string s , int n ) { int count = 0 , sum = 0 ; unordered_map < int , int > mp ; mp [ 0 ] ++ ; for ( int i = 0 ; i < n ; ++ i ) { sum += ( s [ i ] - '0' ) ; count += mp [ sum - ( i + 1 ) ] ; ++ mp [ sum - ( i + 1 ) ] ; } return count ; } int main ( ) { string str = "112112" ; int n = str . length ( ) ; cout << countSubstrings ( str , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCount ( int arr [ ] , int n ) { int prefix_sum [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int suffix_sum [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int s = 1 , e = 1 ; int curr_subarray_sum = 0 , count = 0 ; while ( s < n - 1 && e < n - 1 ) { while ( e < n - 1 && curr_subarray_sum < prefix_sum [ s - 1 ] ) { curr_subarray_sum += arr [ e ++ ] ; } if ( curr_subarray_sum <= suffix_sum [ e ] ) { count ++ ; } curr_subarray_sum -= arr [ s ++ ] ; } return count ; } int32_t main ( ) { int arr [ ] = { 2 , 3 , 1 , 7 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << ( findCount ( arr , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperation ( string s , int n ) { int cnt1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) cnt1 ++ ; } int cnt0 = 0 ; for ( int i = 0 ; i < cnt1 ; i ++ ) { if ( s [ i ] == '0' ) cnt0 ++ ; } return cnt0 ; } int main ( ) { int n = 8 ; string s = "01001011" ; int ans = minOperation ( s , n ) ; cout << ans << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperation ( string s , int n ) { int ans = 0 ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( s [ i ] == '0' && s [ j ] == '1' ) { ans ++ ; i ++ ; j -- ; continue ; } if ( s [ i ] == '1' ) { i ++ ; } if ( s [ j ] == '0' ) { j -- ; } } return ans ; } int main ( ) { int n = 8 ; string s = "10100101" ; int ans = minOperation ( s , n ) ; cout << ans << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y , int mod ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } void count ( int N ) { if ( N == 1 ) { cout << 10 << endl ; return ; } cout << ( power ( 9 , N , 1000000007 ) ) << endl ; } int main ( ) { int N = 3 ; count ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int * kmp ( string & s ) { int n = s . size ( ) ; int * lps = new int [ n ] ; lps [ 0 ] = 0 ; int i = 1 , len = 0 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } string findString ( string & s , int k ) { int n = s . length ( ) ; int * lps = kmp ( s ) ; string ans = " " ; string suff = s . substr ( 0 , n - lps [ n - 1 ] ) ; for ( int i = 0 ; i < k - 1 ; ++ i ) { ans += suff ; } ans += s ; return ans ; } int main ( ) { int k = 3 ; string s = " geeksforgeeks " ; cout << findString ( s , k ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int arr [ ] , int n ) { int i , g ; g = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 0 && g == 1 ) return false ; if ( arr [ i ] - arr [ i - 1 ] < 0 ) g = 1 ; } return true ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 10 , 4 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; if ( check ( arr , n ) == true ) cout << " Yes " " STRNEWLINE " ; else cout << " No " << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; bool possible ( ll mid , vector < ll > & a ) { ll n = a . size ( ) ; ll total = ( n * ( n - 1 ) ) / 2 ; ll need = ( total + 1 ) / 2 ; ll count = 0 ; ll start = 0 , end = 1 ; while ( end < n ) { if ( a [ end ] - a [ start ] <= mid ) { end ++ ; } else { count += ( end - start - 1 ) ; start ++ ; } } if ( end == n && start < end && a [ end - 1 ] - a [ start ] <= mid ) { ll t = end - start - 1 ; count += ( t * ( t + 1 ) / 2 ) ; } if ( count >= need ) return true ; else return false ; } ll findMedian ( vector < ll > & a ) { ll n = a . size ( ) ; ll low = 0 , high = a [ n - 1 ] - a [ 0 ] ; while ( low <= high ) { ll mid = ( low + high ) / 2 ; if ( possible ( mid , a ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; } int main ( ) { vector < ll > a = { 1 , 7 , 5 , 2 } ; sort ( a . begin ( ) , a . end ( ) ) ; cout << findMedian ( a ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinSum ( int A [ ] , int K , int len ) { int n = len ; int suffix_min [ n ] = { 0 } ; suffix_min [ n - 1 ] = A [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_min [ i ] = min ( suffix_min [ i + 1 ] , A [ i ] ) ; int min_sum = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + K < n ) min_sum = min ( min_sum , A [ i ] + suffix_min [ i + K ] ) ; } cout << min_sum ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int K = 2 ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findMinSum ( A , K , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxEnvelopes ( vector < vector < int > > envelopes ) { int N = envelopes . size ( ) ; if ( N == 0 ) return N ; sort ( envelopes . begin ( ) , envelopes . end ( ) ) ; int dp [ N ] ; int max_envelope = 1 ; dp [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; ++ j ) { if ( envelopes [ i ] [ 0 ] > envelopes [ j ] [ 0 ] && envelopes [ i ] [ 1 ] > envelopes [ j ] [ 1 ] && dp [ i ] < dp [ j ] + 1 ) dp [ i ] = dp [ j ] + 1 ; } max_envelope = max ( max_envelope , dp [ i ] ) ; } return max_envelope ; } int main ( ) { vector < vector < int > > envelopes = { { 4 , 3 } , { 5 , 3 } , { 5 , 6 } , { 1 , 2 } } ; cout << maxEnvelopes ( envelopes ) ; return 0 ; }
#include using namespace std ; string checkPossible ( int A [ ] , int B [ ] , int n ) { unordered_set values ; for ( int i = 0 ; i < n ; i ++ ) { values . insert ( B [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( values . find ( A [ i ] + A [ j ] ) != values . end ( ) ) { values . erase ( A [ i ] + A [ j ] ) ; if ( values . empty ( ) ) break ; } } } if ( values . size ( ) == 0 ) return " Yes " ; else return " No " ; } int main ( ) { int N = 5 ; int A [ ] = { 3 , 5 , 1 , 4 , 2 } ; int B [ ] = { 3 , 4 , 5 , 6 , 7 } ; cout << checkPossible ( A , B , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 2e5 ; const int V = 500 ; void solve ( int n , int d , int input [ ] ) { int a [ N ] ; int cnt [ V + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) a [ i ] = input [ i ] ; int answer = 0 ; for ( int i = 0 ; i < d ; ++ i ) cnt [ a [ i ] ] ++ ; for ( int i = d ; i <= n - 1 ; ++ i ) { int acc = 0 ; int low_median = -1 , high_median = -1 ; for ( int v = 0 ; v <= V ; ++ v ) { acc += cnt [ v ] ; if ( low_median == -1 && acc >= int ( floor ( ( d + 1 ) / 2.0 ) ) ) low_median = v ; if ( high_median == -1 && acc >= int ( ceil ( ( d + 1 ) / 2.0 ) ) ) high_median = v ; } int double_median = low_median + high_median ; if ( a [ i ] >= double_median ) answer ++ ; cnt [ a [ i - d ] ] -- ; cnt [ a [ i ] ] ++ ; } cout << answer << endl ; } int main ( ) { int input [ ] = { 1 , 2 , 2 , 4 , 5 } ; int n = sizeof input / sizeof input [ 0 ] ; int k = 3 ; solve ( n , k , input ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSoln ( int n , int k ) { int minSoln = INT_MAX ; for ( int i = 1 ; i < k ; i ++ ) { if ( n % i == 0 ) minSoln = min ( minSoln , ( n / i ) * k + i ) ; } return minSoln ; } int main ( ) { int n = 4 , k = 6 ; cout << findMinSoln ( n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int BFS ( vector < vector < int > > & mat , int row , int col ) { int area = 0 ; queue < pair < int , int > > Q ; Q . push ( { row , col } ) ; while ( ! Q . empty ( ) ) { auto it = Q . front ( ) ; Q . pop ( ) ; int r = it . first , c = it . second ; if ( r < 0 c < 0 r > 4 c > 4 ) continue ; if ( mat [ r ] == 0 ) continue ; if ( mat [ r ] == 1 ) { mat [ r ] = 0 ; area ++ ; } Q . push ( { r + 1 , c } ) ; Q . push ( { r - 1 , c } ) ; Q . push ( { r , c + 1 } ) ; Q . push ( { r , c - 1 } ) ; } return area ; } void sizeOfConnections ( vector < vector < int > > mat ) { vector < int > result ; for ( int row = 0 ; row < 5 ; ++ row ) { for ( int col = 0 ; col < 5 ; ++ col ) { if ( mat [ row ] [ col ] == 1 ) { int area = BFS ( mat , row , col ) ; result . push_back ( area ) ; } } } for ( int val : result ) cout << val << " ▁ " ; } int main ( ) { vector < vector < int > > mat = { { 1 , 1 , 0 , 0 , 0 } , { 1 , 1 , 0 , 1 , 1 } , { 1 , 0 , 0 , 1 , 1 } , { 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 1 , 1 } } ; sizeOfConnections ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxProduct ( int arr [ ] , int N ) { if ( N < 3 ) { return ; } sort ( arr , arr + N ) ; int smallest1 = arr [ 0 ] ; int smallest3 = arr [ 2 ] ; int largest1 = arr [ N - 1 ] ; int largest3 = arr [ N - 3 ] ; if ( smallest1 * smallest3 >= largest1 * largest3 ) { cout << smallest1 << " ▁ " << smallest3 ; } else { cout << largest1 << " ▁ " << largest3 ; } } int main ( ) { int arr [ ] = { 5 , 2 , 67 , 45 , 160 , 78 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxProduct ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLen ( int A [ ] , int N ) { vector < vector < int > > v ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 1 ) { int s = i , len ; while ( A [ i ] == 1 && i < N ) { i ++ ; } len = i - s ; v . push_back ( { len , s , i - 1 } ) ; } } if ( v . size ( ) == 0 ) { return -1 ; } int ans = 0 ; for ( int i = 0 ; i < v . size ( ) - 1 ; i ++ ) { ans = max ( ans , v [ i ] [ 0 ] ) ; if ( v [ i + 1 ] [ 1 ] - v [ i ] [ 2 ] - 1 == 2 ) { ans = max ( ans , v [ i ] [ 0 ] + v [ i + 1 ] [ 0 ] ) ; } if ( v [ i + 1 ] [ 1 ] - v [ i ] [ 2 ] - 1 == 1 ) { ans = max ( ans , v [ i ] [ 0 ] + v [ i + 1 ] [ 0 ] - 1 ) ; } } ans = max ( v [ v . size ( ) - 1 ] [ 0 ] , ans ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxLen ( arr , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int t , n , m , a ; stack < int > s ; vector < int > tsort ; vector < int > adj [ int ( 1e5 ) + 1 ] ; vector < int > visited ( int ( 1e5 ) + 1 ) ; void dfs ( int u ) { visited [ u ] = 1 ; for ( auto it : adj [ u ] ) { if ( visited [ it ] == 0 ) dfs ( it ) ; } s . push ( u ) ; } bool check_cycle ( ) { unordered_map < int , int > pos ; int ind = 0 ; while ( ! s . empty ( ) ) { pos [ s . top ( ) ] = ind ; tsort . push_back ( s . top ( ) ) ; ind += 1 ; s . pop ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( auto it : adj [ i ] ) { if ( pos [ i ] > pos [ it ] ) { return true ; } } } return false ; } void addEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; } int main ( ) { n = 4 , m = 5 ; addEdge ( 0 , 1 ) ; addEdge ( 0 , 2 ) ; addEdge ( 1 , 2 ) ; addEdge ( 2 , 0 ) ; addEdge ( 2 , 3 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] == 0 ) { dfs ( i ) ; } } if ( check_cycle ( ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNewArray ( vector < int > a , int n ) { vector < pair < int , int > > v ; for ( int i = 0 ; i < n ; i ++ ) { v . push_back ( { a [ i ] , i } ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int ans [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ v [ ( i + 1 ) % n ] . second ] = v [ i ] . first ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } int main ( ) { vector < int > a = { 4 , 1 , 2 , 5 , 3 } ; int n = a . size ( ) ; printNewArray ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_remove ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] - arr [ i ] <= k ) { ans = min ( ans , n - j + i - 1 ) ; } } } return ans ; } int main ( ) { int k = 3 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << min_remove ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int arr [ ] , int n ) { int countzeroes = 0 ; int countones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countzeroes ++ ; else countones ++ ; } if ( abs ( countzeroes - countones ) == 1 ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 0 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; solve ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char bs ( char ar [ ] , int n , int ele ) { int start = 0 ; int end = n - 1 ; char ch = ' @ ' ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( ar [ mid ] == ele ) end = mid - 1 ; else if ( ar [ mid ] < ele ) { ch = ar [ mid ] ; start = mid + 1 ; } else end = mid - 1 ; } return ch ; } int main ( ) { char ar [ ] = { ' e ' , ' g ' , ' t ' , ' y ' } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; char K = ' u ' ; char ch = bs ( ar , n , K ) ; if ( ch == ' @ ' ) cout << " - 1" ; else cout << ch ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; int findMaxLen ( vector < ll > & a , ll k ) { int n = a . size ( ) ; sort ( a . begin ( ) , a . end ( ) ) ; vector < bool > vis ( n , 0 ) ; map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ a [ i ] ] = i ; } int c = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( vis [ i ] == false ) { int check = a [ i ] * k ; if ( mp . find ( check ) != mp . end ( ) ) { c ++ ; vis [ mp [ check ] ] = true ; } } } return n - c ; } int main ( ) { int K = 3 ; vector < ll > arr = { 1 , 4 , 3 , 2 } ; cout << findMaxLen ( arr , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPrefixLength ( string srcStr , string targetStr ) { if ( targetStr . length ( ) == 0 ) return 0 ; transform ( srcStr . begin ( ) , srcStr . end ( ) , srcStr . begin ( ) , :: tolower ) ; transform ( targetStr . begin ( ) , targetStr . end ( ) , targetStr . begin ( ) , :: tolower ) ; map < char , int > dictCount ; int nUnique = 0 ; for ( char ch : targetStr ) { if ( dictCount . find ( ch ) == dictCount . end ( ) ) { nUnique += 1 ; dictCount [ ch ] = 0 ; } dictCount [ ch ] += 1 ; } for ( int i = 0 ; i < srcStr . length ( ) ; i ++ ) { char ch = srcStr [ i ] ; if ( dictCount . find ( ch ) == dictCount . end ( ) ) continue ; dictCount [ ch ] -= 1 ; if ( dictCount [ ch ] == 0 ) nUnique -= 1 ; if ( nUnique == 0 ) return ( i + 1 ) ; } return -1 ; } int main ( ) { string S = " MarvoloGaunt " ; string T = " Tom " ; cout << getPrefixLength ( S , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string & str , int mid , char a ) { int n = str . size ( ) ; int previous = -1 , i ; for ( i = 0 ; i < n ; ++ i ) { if ( str [ i ] == a ) { if ( i - previous > mid ) { return false ; } previous = i ; } } if ( i - previous > mid ) return false ; else return true ; } bool possible ( string & str , int mid ) { for ( int i = 0 ; i < 26 ; ++ i ) { if ( check ( str , mid , i + ' a ' ) ) return true ; } return false ; } int findMinLength ( string & str ) { int low = 1 , high = str . length ( ) ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( possible ( str , mid ) ) high = mid - 1 ; else low = mid + 1 ; } return high + 1 ; } bool ifAllDistinct ( string str ) { set < char > s ; for ( char c : str ) { s . insert ( c ) ; } return s . size ( ) == str . size ( ) ; } int main ( ) { string str = " geeksforgeeks " ; if ( ifAllDistinct ( str ) ) cout << -1 << endl ; else cout << findMinLength ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int A [ ] , int N ) { int i = 0 ; int k = 0 ; for ( int j = 1 ; j < N ; j ++ ) { int tempK = min ( A [ i ] , A [ j ] ) / ( j - i ) ; if ( tempK > k ) { k = tempK ; } if ( A [ j ] >= A [ i ] / ( j - i ) ) i = j ; } return k ; } int main ( ) { int A [ ] = { 10 , 5 , 12 , 15 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << solve ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void split ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] == 1 ) { count = 2 ; break ; } } cout << count << endl ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; split ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str1 , string str2 ) { vector < bool > mark ( 26 , false ) ; int n = str1 . size ( ) , m = str2 . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mark [ str1 [ i ] - ' a ' ] = true ; } for ( int i = 0 ; i < m ; i ++ ) { if ( mark [ str2 [ i ] - ' a ' ] ) return true ; } return false ; } int main ( ) { string str1 = " abca " , str2 = " efad " ; if ( check ( str1 , str2 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void FindPairs ( int n , int k ) { cout << 1 << " ▁ " << n << endl ; k -- ; for ( long long i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { cout << 1 << " ▁ " << i << endl ; k -- ; if ( k == 0 ) break ; if ( i != n / i ) { cout << 1 << " ▁ " << n / i << endl ; k -- ; } if ( k == 0 ) break ; } } } int main ( ) { int N = 100 ; int K = 5 ; FindPairs ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void dfs ( int u , vector < int > adj [ ] , int * vis , int * inDeg , int * outDeg ) { vis [ u ] = 1 ; for ( auto v : adj [ u ] ) { outDeg [ u ] = 1 ; inDeg [ v ] = 1 ; if ( vis [ v ] == 0 ) { dfs ( v , adj , vis , inDeg , outDeg ) ; } } } int findMinimumEdges ( int source [ ] , int N , int M , int dest [ ] ) { vector < int > adj [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { adj [ source [ i ] ] . push_back ( dest [ i ] ) ; } int inDeg [ N + 1 ] = { 0 } ; int outDeg [ N + 1 ] = { 0 } ; int vis [ N + 1 ] = { 0 } ; dfs ( 1 , adj , vis , inDeg , outDeg ) ; int minEdges = 0 ; int totalIndegree = 0 ; int totalOutdegree = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( inDeg [ i ] == 1 ) totalIndegree ++ ; if ( outDeg [ i ] == 1 ) totalOutdegree ++ ; } minEdges = max ( N - totalIndegree , N - totalOutdegree ) ; return minEdges ; } int main ( ) { int N = 5 , M = 5 ; int source [ ] = { 1 , 3 , 1 , 3 , 4 } ; int destination [ ] = { 2 , 2 , 3 , 4 , 5 } ; cout << findMinimumEdges ( source , N , M , destination ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int PermuteTheArray ( int A [ ] , int n ) { int arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ A [ i ] - 1 ] = i ; } int mini = n , maxi = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mini = min ( mini , arr [ i ] ) ; maxi = max ( maxi , arr [ i ] ) ; if ( maxi - mini == i ) count ++ ; } return count ; } int main ( ) { int A [ ] = { 4 , 5 , 1 , 3 , 2 , 6 } ; cout << PermuteTheArray ( A , 6 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSubsetSum ( int arr [ ] , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < arr [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= arr [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; } int findSum ( int * arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int val = sqrt ( sum ) ; for ( int i = val ; i >= 0 ; i -- ) { if ( isSubsetSum ( arr , n , i * i ) ) { return i * i ; } } return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findsubArray ( int arr [ ] , int N , int K ) { int res = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { int curr_prod = 1 ; for ( int j = i ; j < N ; j ++ ) { curr_prod = curr_prod * arr [ j ] ; if ( curr_prod % N == K && res > ( j - i + 1 ) ) { res = min ( res , j - i + 1 ) ; break ; } } } return ( res == N + 1 ) ? 0 : res ; } int main ( ) { int arr [ ] = { 2 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 1 ; int answer = findsubArray ( arr , N , K ) ; if ( answer != 0 ) cout << answer ; else cout << " - 1" ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 3 , M = 3 ; bool checkBitonic ( int arr [ ] , int n ) { int i , j , f = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { f = 1 ; break ; } } if ( i == n ) return true ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < arr [ j - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { if ( f == 1 ) return false ; } } return true ; } void check ( int arr [ N ] [ M ] ) { int f = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! checkBitonic ( arr [ i ] , M ) ) { cout << " NO " << endl ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { int temp [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { temp [ j ] = arr [ j ] [ i ] ; } if ( ! checkBitonic ( temp , N ) ) { cout << " NO " << endl ; return ; } } cout << " YES " ; } int main ( ) { int m [ N ] [ M ] = { { 1 , 2 , 3 } , { 3 , 4 , 5 } , { 2 , 6 , 4 } } ; check ( m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMaxGcd ( int N ) { int maxGcd = INT_MIN , A , B ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { A = i , B = N / i ; maxGcd = max ( maxGcd , __gcd ( A , B ) ) ; } } return maxGcd ; } int main ( ) { int N = 18 ; cout << getMaxGcd ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool can_place ( int A [ ] , int n , int B , int mid ) { int count = 1 ; int last_position = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] - last_position >= mid ) { last_position = A [ i ] ; count ++ ; if ( count == B ) { return true ; } } } return false ; } int find_min_difference ( int A [ ] , int n , int B ) { sort ( A , A + n ) ; int s = 0 ; int e = A [ n - 1 ] - A [ 0 ] ; int ans = 0 ; while ( s <= e ) { long long int mid = ( s + e ) / 2 ; if ( can_place ( A , n , B , mid ) ) { ans = mid ; s = mid + 1 ; } else { e = mid - 1 ; } } return ans ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int B = 3 ; int min_difference = find_min_difference ( A , n , B ) ; cout << min_difference ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void UniversalSubset ( vector < string > A , vector < string > B ) { int n1 = A . size ( ) ; int n2 = B . size ( ) ; vector < string > res ; int A_fre [ n1 ] [ 26 ] ; for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) A_fre [ i ] [ j ] = 0 ; } for ( int i = 0 ; i < n1 ; i ++ ) { for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) { A_fre [ i ] [ A [ i ] [ j ] - ' a ' ] ++ ; } } int B_fre [ 26 ] = { 0 } ; for ( int i = 0 ; i < n2 ; i ++ ) { int arr [ 26 ] = { 0 } ; for ( int j = 0 ; j < B [ i ] . size ( ) ; j ++ ) { arr [ B [ i ] [ j ] - ' a ' ] ++ ; B_fre [ B [ i ] [ j ] - ' a ' ] = max ( B_fre [ B [ i ] [ j ] - ' a ' ] , arr [ B [ i ] [ j ] - ' a ' ] ) ; } } for ( int i = 0 ; i < n1 ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( A_fre [ i ] [ j ] < B_fre [ j ] ) { flag = 1 ; break ; } } if ( flag == 0 ) res . push_back ( A [ i ] ) ; } if ( res . size ( ) ) { for ( int i = 0 ; i < res . size ( ) ; i ++ ) { for ( int j = 0 ; j < res [ i ] . size ( ) ; j ++ ) cout << res [ i ] [ j ] ; } cout << " ▁ " ; } else cout << " - 1" ; } int main ( ) { vector < string > A = { " geeksforgeeks " , " topcoder " , " leetcode " } ; vector < string > B = { " geek " , " ee " } ; UniversalSubset ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int A [ ] , int N ) { int ans = 0 ; map < int , int > map ; for ( int j = N - 2 ; j >= 1 ; j -- ) { map [ A [ j + 1 ] ] ++ ; for ( int i = 0 ; i < j ; i ++ ) { int target = A [ i ] * A [ j ] ; if ( map . find ( target ) != map . end ( ) ) ans += map [ target ] ; } } return ans ; } int main ( ) { int N = 5 ; int A [ ] = { 2 , 3 , 4 , 6 , 12 } ; cout << countTriplets ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MissingPoint ( vector < pair < int , int > > V , int N ) { map < int , int > mp ; for ( int i = 0 ; i < V . size ( ) ; i ++ ) { mp [ V [ i ] . first ] ++ ; } int x , y ; for ( auto it : mp ) { if ( it . second % 2 == 1 ) { x = it . first ; break ; } } mp . clear ( ) ; for ( int i = 0 ; i < V . size ( ) ; i ++ ) { mp [ V [ i ] . second ] ++ ; } for ( auto it : mp ) { if ( it . second % 2 == 1 ) { y = it . first ; break ; } } cout << x << " ▁ " << y ; } int main ( ) { int N = 2 ; vector < pair < int , int > > V ; V . push_back ( { 1 , 1 } ) ; V . push_back ( { 1 , 2 } ) ; V . push_back ( { 4 , 6 } ) ; V . push_back ( { 2 , 1 } ) ; V . push_back ( { 9 , 6 } ) ; V . push_back ( { 9 , 3 } ) ; V . push_back ( { 4 , 3 } ) ; MissingPoint ( V , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sign ( int x ) { if ( x > 0 ) return 1 ; else return -1 ; } int findMaxSum ( int arr [ ] , int size ) { int max_sum = 0 , pres , i , j ; for ( i = 0 ; i < size ; i ++ ) { pres = arr [ i ] ; j = i ; while ( j < size && sign ( arr [ i ] ) == sign ( arr [ j ] ) ) { pres = max ( pres , arr [ j ] ) ; j ++ ; } max_sum = max_sum + pres ; i = j - 1 ; } return max_sum ; } int main ( ) { int arr [ ] = { -2 , 8 , 3 , 8 , -4 , -15 , 5 , -2 , -3 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSum ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool groupInKConsecutive ( vector < int > & arr , int K ) { map < int , int > count ; for ( int h : arr ) { ++ count [ h ] ; } for ( auto c : count ) { int cur = c . first ; int n = c . second ; if ( n > 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( ! count . count ( cur + i ) ) { return false ; } count [ cur + i ] -= n ; if ( count [ cur + i ] < 0 ) return false ; } } } return true ; } int main ( ) { vector < int > arr = { 1 , 2 , 3 , 6 , 2 , 3 , 4 , 7 , 8 } ; int k = 3 ; if ( groupInKConsecutive ( arr , k ) ) { cout << " True " ; } else { cout << " False " ; } }
#include <iostream> NEW_LINE using namespace std ; int countSubAllOnes ( string s ) { int l = 0 , r = 0 , ans = 0 ; while ( l <= r ) { if ( r == s . length ( ) ) { ans += ( ( r - l ) * ( r - l + 1 ) ) / 2 ; break ; } if ( s [ r ] == '1' ) r ++ ; else { ans += ( ( r - l ) * ( r - l + 1 ) ) / 2 ; l = r + 1 ; r ++ ; } } return ans ; } void flip ( string & s ) { for ( int i = 0 ; s [ i ] ; i ++ ) { if ( s [ i ] == '1' ) s [ i ] = '0' ; else s [ i ] = '1' ; } cout << s << endl ; } int countSubAllZerosOnes ( string s ) { int only_1s = countSubAllOnes ( s ) ; flip ( s ) ; cout << s << endl ; int only_0s = countSubAllOnes ( s ) ; return only_0s + only_1s ; } int main ( ) { string s = "011" ; cout << countSubAllZerosOnes ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sumSquare ( int p ) { return ( p - 1 ) % 4 == 0 ; } bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int countOfPrimes ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime ( i ) ) { if ( sumSquare ( i ) ) count ++ ; } } return count ; } int main ( ) { int L = 5 , R = 41 ; cout << countOfPrimes ( L , R ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPair ( int a [ ] , int n ) { int min_dist = INT_MAX ; int index_a = -1 , index_b = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( j - i < min_dist ) { if ( a [ i ] % a [ j ] == 0 a [ j ] % a [ i ] == 0 ) { min_dist = j - i ; index_a = i ; index_b = j ; } } } } if ( index_a == -1 ) { cout << ( " - 1" ) ; } else { cout << " ( " << a [ index_a ] << " , ▁ " << a [ index_b ] << " ) " ; } } int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( int ) ; findPair ( a , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void subString ( char str [ ] , int n ) { int c = 0 ; for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; char temp = str [ i ] , f = 0 ; if ( j == i ) { c ++ ; continue ; } int k = i + 1 ; while ( temp < str [ k ] && k <= j ) { temp = str [ k ] ; k ++ ; f = 2 ; } if ( k > j ) { c ++ ; f = 2 ; } while ( temp > str [ k ] && k <= j && f != 2 ) { k ++ ; f = 0 ; } if ( k > j && f != 2 ) { c ++ ; f = 0 ; } } } cout << c << endl ; } int main ( ) { char str [ ] = " bade " ; subString ( str , strlen ( str ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumberDivByPowerofTwo ( int ar [ ] , int k , int n ) { int found = -1 , m = k ; while ( m > 0 ) { int l = 0 ; int r = n - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] == m ) { found = m ; break ; } else if ( ar [ mid ] > m ) { r = mid - 1 ; } else if ( ar [ mid ] < m ) { l = mid + 1 ; } } if ( found != -1 ) { break ; } m = m / 2 ; } return found ; } int main ( ) { int arr [ ] = { 3 , 5 , 7 , 8 , 10 } ; int k = 4 , n = 5 ; cout << findNumberDivByPowerofTwo ( arr , k , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void setElement ( int * arr , int n , int index , int x ) { arr [ index ] = x ; } int getCount ( int * arr , int n , int l , int r ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l && arr [ i ] <= r ) { count ++ ; } } return count ; } void SolveQuery ( int arr [ ] , int n , vector < pair < int , pair < int , int > > > Q ) { int x ; for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { if ( Q [ i ] . first == 1 ) { x = getCount ( arr , n , Q [ i ] . second . first , Q [ i ] . second . second ) ; cout << x << " ▁ " ; } else { setElement ( arr , n , Q [ i ] . second . first , Q [ i ] . second . second ) ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; vector < pair < int , pair < int , int > > > Q = { { 1 , { 3 , 5 } } , { 1 , { 2 , 4 } } , { 1 , { 1 , 2 } } , { 2 , { 1 , 7 } } , { 1 , { 1 , 2 } } } ; SolveQuery ( arr , n , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getMinimumDistance ( int a [ ] , int n ) { set < int > min_set ; set < int > max_set ; int max = 0 , min = INT_MAX ; map < int , int > frequency ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] += 1 ; } for ( int i = 0 ; i < n ; i ++ ) { int count = frequency [ a [ i ] ] ; if ( count == max ) { max_set . insert ( a [ i ] ) ; } else if ( count > max ) { max_set . clear ( ) ; max = count ; max_set . insert ( a [ i ] ) ; } if ( count == min ) { min_set . insert ( a [ i ] ) ; } else if ( count < min ) { min_set . clear ( ) ; min = count ; min_set . insert ( a [ i ] ) ; } } int min_dist = INT_MAX ; int last_min_found = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_set . find ( a [ i ] ) != min_set . end ( ) ) last_min_found = i ; if ( max_set . find ( a [ i ] ) != max_set . end ( ) && last_min_found != -1 ) { if ( ( i - last_min_found ) < min_dist ) min_dist = i - last_min_found ; } } last_min_found = -1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( min_set . find ( a [ i ] ) != min_set . end ( ) ) last_min_found = i ; if ( max_set . find ( a [ i ] ) != max_set . end ( ) && last_min_found != -1 ) { if ( ( last_min_found - i ) > min_dist ) min_dist = last_min_found - i ; } } cout << ( min_dist ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 , 2 , 3 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getMinimumDistance ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNum ( int L , int R ) { for ( int i = L ; i <= R ; i ++ ) { int temp = i ; int c = 10 ; int flag = 0 ; while ( temp > 0 ) { if ( temp % 10 >= c ) { flag = 1 ; break ; } c = temp % 10 ; temp /= 10 ; } if ( flag == 0 ) cout << i << " ▁ " ; } } int main ( ) { int L = 10 , R = 15 ; printNum ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void printSubsequenceString ( string str , long long k ) { int n = str . size ( ) ; int i ; vector < long long > factors ; for ( long long i = 2 ; i <= sqrt ( k ) ; i ++ ) { while ( k % i == 0 ) { factors . push_back ( i ) ; k /= i ; } } if ( k > 1 ) factors . push_back ( k ) ; vector < long long > count ( n , 1 ) ; int index = 0 ; while ( factors . size ( ) > 0 ) { count [ index ++ ] *= factors . back ( ) ; factors . pop_back ( ) ; if ( index == n ) index = 0 ; } string s ; for ( i = 0 ; i < n ; i ++ ) { while ( count [ i ] -- > 0 ) { s += str [ i ] ; } } cout << s ; } int main ( ) { string str = " code " ; long long k = 20 ; printSubsequenceString ( str , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void changeArr ( int input [ ] , int N ) { int newArray [ N ] ; copy ( input , input + N , newArray ) ; sort ( newArray , newArray + N ) ; int i ; map < int , int > ranks ; int rank = 1 ; for ( int index = 0 ; index < N ; index ++ ) { int element = newArray [ index ] ; if ( ranks [ element ] == 0 ) { ranks [ element ] = rank ; rank ++ ; } } for ( int index = 0 ; index < N ; index ++ ) { int element = input [ index ] ; input [ index ] = ranks [ input [ index ] ] ; } } int main ( ) { int arr [ ] = { 100 , 2 , 70 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; changeArr ( arr , N ) ; cout << " [ " ; for ( int i = 0 ; i < N - 1 ; i ++ ) { cout << arr [ i ] << " , ▁ " ; } cout << arr [ N - 1 ] << " ] " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPair ( int arr [ ] , int n ) { int i , j ; if ( n < 2 ) { cout << " - 1" << endl ; } set < int > hashMap ; for ( int k = 0 ; k < n ; k ++ ) { hashMap . insert ( arr [ k ] ) ; } for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( hashMap . find ( sum ) == hashMap . end ( ) ) { cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << endl ; } } } } int main ( ) { int arr [ ] = { 2 , 4 , 2 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPair ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll findLengthOfMaxSubset ( int arr [ ] , int n , int m ) { set < int > s ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = arr [ i ] ; if ( tmp != m ) { s . insert ( tmp ) ; answer ++ ; } } int min = 1 ; while ( s . count ( min ) ) { min ++ ; } if ( min != m ) { answer = -1 ; } return answer ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = 3 ; cout << findLengthOfMaxSubset ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define m  5 NEW_LINE int countSubsquare ( int arr [ ] [ m ] , int n , int X ) { int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { dp [ i + 1 ] [ j + 1 ] = arr [ i ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int lo = 1 ; int hi = min ( n - i , m - j ) + 1 ; bool found = false ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; int ni = i + mid - 1 ; int nj = j + mid - 1 ; int sum = dp [ ni ] [ nj ] - dp [ ni ] [ j - 1 ] - dp [ i - 1 ] [ nj ] + dp [ i - 1 ] [ j - 1 ] ; if ( sum >= X ) { if ( sum == X ) { found = true ; } hi = mid - 1 ; } else { lo = mid + 1 ; } } if ( found == true ) { cnt ++ ; } } } return cnt ; } int main ( ) { int N = 4 , X = 10 ; int arr [ N ] [ m ] = { { 2 , 4 , 3 , 2 , 10 } , { 3 , 1 , 1 , 1 , 5 } , { 1 , 1 , 2 , 1 , 4 } , { 2 , 1 , 1 , 1 , 3 } } ; cout << countSubsquare ( arr , N , X ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countSub ( string str ) { int n = ( int ) str . size ( ) ; long long int ans = 0 ; int cnt [ 26 ] ; memset ( cnt , 0 , sizeof ( cnt ) ) ; int i = 0 , j = 0 ; while ( i < n ) { if ( j < n && ( cnt [ str [ j ] - ' a ' ] == 0 ) ) { cnt [ str [ j ] - ' a ' ] ++ ; ans += ( j - i + 1 ) ; j ++ ; } else { cnt [ str [ i ] - ' a ' ] -- ; i ++ ; } } return ans ; } int main ( ) { string str = " gffg " ; cout << countSub ( str ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int solve ( int n , int k ) { int ans = 0 ; for ( int j = 1 ; j * j <= n ; j ++ ) { if ( n % j == 0 ) { if ( j <= k ) { ans = max ( ans , j ) ; } if ( n / j <= k ) { ans = max ( ans , n / j ) ; } } } return ans ; } int main ( ) { int N = 8 , K = 7 ; cout << ( N / solve ( N , K ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void max_sum_subarray ( vector < int > arr , int L , int R ) { int n = arr . size ( ) ; int pre [ n ] = { 0 } ; pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } multiset < int > s1 ; s1 . insert ( 0 ) ; int ans = INT_MIN ; ans = max ( ans , pre [ L - 1 ] ) ; int flag = 0 ; for ( int i = L ; i < n ; i ++ ) { if ( i - R >= 0 ) { if ( flag == 0 ) { auto it = s1 . find ( 0 ) ; s1 . erase ( it ) ; flag = 1 ; } } if ( i - L >= 0 ) s1 . insert ( pre [ i - L ] ) ; ans = max ( ans , pre [ i ] - * s1 . begin ( ) ) ; if ( i - R >= 0 ) { auto it = s1 . find ( pre [ i - R ] ) ; s1 . erase ( it ) ; } } cout << ans << endl ; } int main ( ) { int L , R ; L = 1 ; R = 3 ; vector < int > arr = { 1 , 2 , 2 , 1 } ; max_sum_subarray ( arr , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int rowWise ( char * v , int n , int m , int k ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int countcons = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( * ( v + i * m + j ) == '1' ) { countcons = 0 ; } else { countcons ++ ; } if ( countcons >= k ) { ans ++ ; } } } return ans ; } int colWise ( char * v , int n , int m , int k ) { int ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int countcons = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( * ( v + j * n + i ) == '1' ) { countcons = 0 ; } else { countcons ++ ; } if ( countcons >= k ) { ans ++ ; } } } return ans ; } int main ( ) { int n = 3 , m = 3 , k = 1 ; char v [ n ] [ m ] = { '0' , '0' , '0' , '0' , '0' , '0' , '0' , '0' , '0' } ; if ( k == 1 ) { cout << rowWise ( v [ 0 ] , n , m , k ) ; } else { cout << colWise ( v [ 0 ] , n , m , k ) + rowWise ( v [ 0 ] , n , m , k ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool solve ( int a [ ] , int n ) { int mx = INT_MIN ; for ( int j = 1 ; j < n ; j ++ ) { if ( mx > a [ j ] ) return false ; mx = max ( mx , a [ j - 1 ] ) ; } return true ; } int main ( ) { int a [ ] = { 1 , 0 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; bool possible = solve ( a , n ) ; if ( possible ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int spf [ 100009 ] ; void sieve ( ) { memset ( spf , -1 , 100005 ) ; for ( int i = 2 ; i * i <= 100005 ; i ++ ) { for ( int j = i ; j <= 100005 ; j += i ) { if ( spf [ j ] == -1 ) { spf [ j ] = i ; } } } } set < int > findPrimeFactors ( set < int > s , int n ) { while ( n > 1 ) { s . insert ( spf [ n ] ) ; n /= spf [ n ] ; } return s ; } int MinimumSteps ( int n , int m ) { queue < pair < int , int > > q ; set < int > s ; q . push ( { n , 0 } ) ; while ( ! q . empty ( ) ) { int newNum = q . front ( ) . first ; int distance = q . front ( ) . second ; q . pop ( ) ; set < int > k = findPrimeFactors ( s , newNum ) ; for ( auto i : k ) { if ( newNum == m ) { return distance ; } else if ( newNum > m ) { break ; } else { q . push ( { newNum + i , distance + 1 } ) ; } } } return -1 ; } int main ( ) { int N = 7 , M = 16 ; sieve ( ) ; cout << MinimumSteps ( N , M ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > v [ 100000 ] ; void div ( int n ) { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v [ n ] . push_back ( i ) ; } } } int prodof2elements ( int arr [ ] , int n ) { int arr2 [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; } sort ( arr2 , arr2 + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( v [ arr [ i ] ] . size ( ) == 0 ) div ( arr [ i ] ) ; for ( auto j : v [ arr [ i ] ] ) { if ( binary_search ( arr2 , arr2 + n , j ) and binary_search ( arr2 , arr2 + n , arr [ i ] / j ) ) { ans ++ ; break ; } } } return ans ; } int main ( ) { int arr [ ] = { 2 , 1 , 8 , 4 , 32 , 18 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << prodof2elements ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <unordered_map> NEW_LINE using namespace std ; int max_subarray_size ( int N , int arr [ ] ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { unordered_map < int , int > map1 ; unordered_map < int , int > map2 ; for ( int j = i ; j < N ; j ++ ) { int ele_count ; if ( map1 . find ( arr [ j ] ) == map1 . end ( ) ) { ele_count = 0 ; } else { ele_count = map1 [ arr [ j ] ] ; } map1 [ arr [ j ] ] ++ ; if ( map2 . find ( ele_count ) != map2 . end ( ) ) { if ( map2 [ ele_count ] == 1 ) { map2 . erase ( ele_count ) ; } else { map2 [ ele_count ] -- ; } } map2 [ ele_count + 1 ] ++ ; if ( map2 . size ( ) == 1 ) ans = max ( ans , j - i + 1 ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 5 , 6 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << max_subarray_size ( N , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool vowel ( int vo ) { if ( vo == 0 vo == 4 vo == 8 vo == 14 vo == 20 ) return true ; else return false ; } bool check ( string s , int k ) { vector < int > cnt ( 26 , 0 ) ; for ( int i = 0 ; i < k - 1 ; i ++ ) { cnt [ s [ i ] - ' a ' ] ++ ; } for ( int i = k - 1 ; i < s . size ( ) ; i ++ ) { cnt [ s [ i ] - ' a ' ] ++ ; int flag1 = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( vowel ( j ) == false && cnt [ j ] > 0 ) { flag1 = 1 ; break ; } } if ( flag1 == 0 ) return true ; cnt [ s [ i - k + 1 ] - ' a ' ] -- ; } return false ; } int longestSubstring ( string s ) { int l = 1 , r = s . size ( ) ; int maxi = 0 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( check ( s , mid ) ) { l = mid + 1 ; maxi = max ( maxi , mid ) ; } else r = mid - 1 ; } return maxi ; } int main ( ) { string s = " sedrewaefhoiu " ; cout << longestSubstring ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int X [ ] , int Y [ ] , int m , int n ) { vector < int > suffix ( 1005 ) ; long long total_pairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) suffix [ Y [ i ] ] ++ ; for ( int i = 1e3 ; i >= 3 ; i -- ) suffix [ i ] += suffix [ i + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( X [ i ] == 0 ) continue ; else if ( X [ i ] == 1 ) { total_pairs += suffix [ 0 ] ; continue ; } else if ( X [ i ] == 2 ) total_pairs += suffix [ 5 ] ; else if ( X [ i ] == 3 ) total_pairs += suffix [ 2 ] + suffix [ 4 ] ; else total_pairs += suffix [ X [ i ] + 1 ] ; total_pairs += suffix [ 0 ] + suffix [ 1 ] ; } return total_pairs ; } int main ( ) { int X [ ] = { 10 , 19 , 18 } ; int Y [ ] = { 11 , 15 , 9 } ; int m = sizeof ( X ) / sizeof ( X [ 0 ] ) ; int n = sizeof ( Y ) / sizeof ( Y [ 0 ] ) ; cout << countPairs ( X , Y , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int A [ ] [ 10 ] , int N , int M ) { int B [ N ] [ M ] ; int c = 1 ; set < int > s ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) B [ i ] [ j ] = c ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i != 0 ) { if ( A [ i - 1 ] [ j ] == A [ i ] [ j ] ) B [ i - 1 ] [ j ] = B [ i ] [ j ] ; } if ( i != N - 1 ) { if ( A [ i + 1 ] [ j ] == A [ i ] [ j ] ) B [ i + 1 ] [ j ] = B [ i ] [ j ] ; } if ( j != 0 ) { if ( A [ i ] [ j - 1 ] == A [ i ] [ j ] ) B [ i ] [ j - 1 ] = B [ i ] [ j ] ; } if ( j != M - 1 ) { if ( A [ i ] [ j + 1 ] == A [ i ] [ j ] ) B [ i ] [ j + 1 ] = B [ i ] [ j ] ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) s . insert ( B [ i ] [ j ] ) ; } return s . size ( ) ; } int main ( ) { int N = 2 , M = 3 ; int A [ ] [ 10 ] = { { 2 , 1 , 3 } , { 1 , 1 , 2 } } ; cout << solve ( A , N , M ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int splitArray ( int start , int end , int * arr , int * prefix_sum ) { if ( start >= end ) return 0 ; for ( int k = start ; k < end ; ++ k ) { if ( ( prefix_sum [ k ] - prefix_sum [ start - 1 ] ) == ( prefix_sum [ end ] - prefix_sum [ k ] ) ) { return 1 + splitArray ( start , k , arr , prefix_sum ) + splitArray ( k + 1 , end , arr , prefix_sum ) ; } } return 0 ; } void solve ( int arr [ ] , int n ) { int prefix_sum [ n + 1 ] ; prefix_sum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i - 1 ] ; } cout << splitArray ( 1 , n , arr , prefix_sum ) ; } int main ( ) { int arr [ ] = { 12 , 3 , 3 , 0 , 3 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; solve ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDays ( vector < int > & arr , int n , int k ) { int l = arr . size ( ) , left = 1 , right = 1e9 ; if ( n * k > l ) return -1 ; while ( left < right ) { int mid = ( left + right ) / 2 , cnt = 0 , product = 0 ; for ( int j = 0 ; j < l ; ++ j ) { if ( arr [ j ] > mid ) { cnt = 0 ; } else if ( ++ cnt >= k ) { product ++ ; cnt = 0 ; } } if ( product < n ) { left = mid + 1 ; } else { right = mid ; } } return left ; } int main ( ) { vector < int > arr { 1 , 10 , 3 , 10 , 2 } ; int n = 3 , k = 1 ; cout << minDays ( arr , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumSum ( int a [ ] , int b [ ] , int c , int n ) { vector < vector < int > > dp ( n , vector < int > ( 2 , 1e6 ) ) ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = min ( dp [ i ] [ 0 ] , dp [ i - 1 ] [ 0 ] + a [ i ] ) ; dp [ i ] [ 0 ] = min ( dp [ i ] [ 0 ] , dp [ i - 1 ] [ 1 ] + a [ i ] + c ) ; dp [ i ] [ 1 ] = min ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 0 ] + b [ i ] + c ) ; dp [ i ] [ 1 ] = min ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + b [ i ] ) ; } cout << min ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) << " STRNEWLINE " ; } int main ( ) { int arr1 [ ] = { 7 , 6 , 18 , 6 , 16 , 18 , 1 , 17 , 17 } ; int arr2 [ ] = { 6 , 9 , 3 , 10 , 9 , 1 , 10 , 1 , 5 } ; int C = 2 ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; minimumSum ( arr1 , arr2 , C , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumMoves ( string S , int K ) { int N = S . length ( ) ; int ops = 0 ; int last_idx = -1 ; for ( int i = 0 ; i < K ; i ++ ) { if ( S [ i ] == '1' ) last_idx = i ; } if ( last_idx == -1 ) { ++ ops ; S [ K - 1 ] = '1' ; last_idx = K - 1 ; } for ( int i = 1 ; i < N - K + 1 ; i ++ ) { if ( last_idx < i ) last_idx = -1 ; if ( S [ i + K - 1 ] == '1' ) last_idx = i + K - 1 ; if ( last_idx == -1 ) { ++ ops ; S [ i + K - 1 ] = '1' ; last_idx = i + K - 1 ; } } return ops ; } int main ( ) { string S = "001010000" ; int K = 3 ; cout << minimumMoves ( S , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char arr [ ] = { ' a ' , ' b ' , ' c ' } ; void findString ( int n , int k , string s1 , string s2 ) { string s3 = s2 ; int d = 0 ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) d ++ ; } if ( ( d + 1 ) / 2 > k ) { cout << " - 1" << endl ; return ; } else { if ( k <= d ) { int X = d - k ; int T = 2 * k - d ; for ( int i = 0 ; i < s3 . size ( ) ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { if ( T > 0 ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( arr [ j ] != s1 [ i ] && arr [ j ] != s2 [ i ] ) { s3 [ i ] = arr [ j ] ; T -- ; break ; } } } else if ( X > 0 ) { s3 [ i ] = s1 [ i ] ; X -- ; } } } cout << s3 << endl ; } else { for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( s1 [ i ] != s3 [ i ] ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( arr [ j ] != s1 [ i ] && arr [ j ] != s3 [ i ] ) { s3 [ i ] = arr [ j ] ; k -- ; break ; } } } } for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( s1 [ i ] == s3 [ i ] && k ) { for ( int j = 0 ; j < 3 ; j ++ ) { if ( arr [ j ] != s1 [ i ] && arr [ j ] != s3 [ i ] ) { s3 [ i ] = arr [ j ] ; k -- ; break ; } } } } cout << s3 << endl ; } } } int main ( ) { int N = 4 , k = 2 ; string S1 = " zzyy " ; string S2 = " zxxy " ; findString ( N , k , S1 , S2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSolutions ( int N ) { int count = 0 ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { if ( ( i + N / i ) % 2 == 0 ) { count ++ ; } } } cout << 4 * count << endl ; } int main ( ) { int N = 80 ; findSolutions ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int check ( int A , int B , int C , int D , long long int x ) { long long int ans ; ans = ( A * x * x * x + B * x * x + C * x + D ) ; return ans ; } void findSolution ( int A , int B , int C , int D , int E ) { int start = 0 , end = 100000 ; long long int mid , ans ; while ( start <= end ) { mid = start + ( end - start ) / 2 ; ans = check ( A , B , C , D , mid ) ; if ( ans == E ) { cout << mid << endl ; return ; } if ( ans < E ) start = mid + 1 ; else end = mid - 1 ; } cout << " NA " ; } int main ( ) { int A = 1 , B = 0 , C = 0 ; int D = 0 , E = 27 ; findSolution ( A , B , C , D , E ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } int nthRootSearch ( int low , int high , int N , int K ) { if ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( power ( mid , K ) <= N ) && ( power ( mid + 1 , K ) > N ) ) { return mid ; } else if ( power ( mid , K ) < N ) { return nthRootSearch ( mid + 1 , high , N , K ) ; } else { return nthRootSearch ( low , mid - 1 , N , K ) ; } } return low ; } int main ( ) { int N = 16 , K = 4 ; cout << nthRootSearch ( 0 , N , N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( string color ) { int result = 0 , Blue_Count = 0 ; int Red_Count = 0 ; for ( char c : color ) { if ( c == ' B ' ) Blue_Count ++ ; } for ( char c : color ) { if ( c == ' B ' ) Blue_Count -- ; if ( c == ' R ' ) Red_Count ++ ; if ( c == ' G ' ) result += Red_Count * Blue_Count ; } return result ; } int main ( ) { string color = " RRGGBBRGGBB " ; cout << countTriplets ( color ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMaxDiff ( int arr [ ] , int n , int k ) { int max_adj_dif = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) max_adj_dif = max ( max_adj_dif , abs ( arr [ i ] - arr [ i + 1 ] ) ) ; if ( max_adj_dif == 0 ) return 0 ; int best = 1 ; int worst = max_adj_dif ; int mid , required ; while ( best < worst ) { mid = ( best + worst ) / 2 ; required = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { required += ( abs ( arr [ i ] - arr [ i + 1 ] ) - 1 ) / mid ; } if ( required > k ) best = mid + 1 ; else worst = mid ; } return worst ; } int main ( ) { int arr [ ] = { 3 , 12 , 25 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 7 ; cout << minMaxDiff ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minpoint ( int arr [ ] , int n , int k ) { int min_point = 0 ; for ( int i = 1 ; i < k - 1 ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) min_point += 1 ; } int final_point = min_point ; for ( int i = k ; i < n ; i ++ ) { if ( arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) + 1 ] && arr [ i - ( k - 1 ) ] < arr [ i - ( k - 1 ) - 1 ] ) min_point -= 1 ; if ( arr [ i - 1 ] < arr [ i ] && arr [ i - 1 ] < arr [ i - 2 ] ) min_point += 1 ; if ( min_point > final_point ) final_point = min_point ; } cout << ( final_point ) ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 2 , 3 , 4 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; minpoint ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkMin ( int arr [ ] , int len ) { int smallest = INT_MAX , secondSmallest = INT_MAX ; for ( int i = 0 ; i < len ; i ++ ) { if ( arr [ i ] < smallest ) { secondSmallest = smallest ; smallest = arr [ i ] ; } else if ( arr [ i ] < secondSmallest ) { secondSmallest = arr [ i ] ; } } if ( 2 * smallest <= secondSmallest ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkMin ( arr , len ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CountStrings ( vector < string > & str ) { int size = str . size ( ) ; vector < int > count ( 26 , 0 ) ; vector < bool > visited ( 26 , false ) ; for ( int i = 0 ; i < size ; ++ i ) { for ( int j = 0 ; j < str [ i ] . length ( ) ; ++ j ) { if ( visited [ str [ i ] [ j ] ] == false ) count [ str [ i ] [ j ] - ' a ' ] ++ ; visited [ str [ i ] [ j ] ] = true ; } for ( int j = 0 ; j < str [ i ] . length ( ) ; ++ j ) { visited [ str [ i ] [ j ] ] = false ; } } for ( int i = 0 ; i < 26 ; ++ i ) { cout << count [ i ] << " ▁ " ; } } int main ( ) { vector < string > str = { " i " , " will " , " practice " , " everyday " } ; CountStrings ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void distanceSort ( int arr [ ] , int K , int n ) { vector < int > vd [ n ] ; int pos ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == K ) { pos = i ; break ; } } int i = pos - 1 , j = pos + 1 ; vd [ 0 ] . push_back ( arr [ pos ] ) ; while ( i >= 0 ) { vd [ pos - i ] . push_back ( arr [ i ] ) ; -- i ; } while ( j < n ) { vd [ j - pos ] . push_back ( arr [ j ] ) ; ++ j ; } for ( int i = 0 ; i <= max ( pos , n - pos - 1 ) ; ++ i ) { sort ( begin ( vd [ i ] ) , end ( vd [ i ] ) ) ; for ( auto element : vd [ i ] ) cout << element << " ▁ " ; } } int main ( ) { int arr [ ] = { 14 , 1101 , 10 , 35 , 0 } , K = 35 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; distanceSort ( arr , K , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < int , int > find ( int dividend , int divisor , int start , int end ) { if ( start > end ) return { 0 , dividend } ; int mid = start + ( end - start ) / 2 ; int n = dividend - divisor * mid ; if ( n > divisor ) start = mid + 1 ; else if ( n < 0 ) end = mid - 1 ; else { if ( n == divisor ) { ++ mid ; n = 0 ; } return { mid , n } ; } return find ( dividend , divisor , start , end ) ; } pair < int , int > divide ( int dividend , int divisor ) { return find ( dividend , divisor , 1 , dividend ) ; } int main ( int argc , char * argv [ ] ) { int dividend = 10 , divisor = 3 ; pair < int , int > ans ; ans = divide ( dividend , divisor ) ; cout << ans . first << " , ▁ " ; cout << ans . second << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int a [ ] , int n , int x ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { vector < int > temp ; temp . push_back ( a [ i ] ) ; temp . push_back ( a [ j ] ) ; temp . push_back ( a [ k ] ) ; sort ( temp . begin ( ) , temp . end ( ) ) ; if ( temp [ 0 ] < temp [ 1 ] && temp [ 1 ] < temp [ 2 ] && temp [ 0 ] * temp [ 1 ] * temp [ 2 ] <= x ) answer ++ ; } } } return answer ; } int main ( ) { int A [ ] = { 3 , 2 , 5 , 7 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int X = 42 ; cout << countTriplets ( A , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double log ( int a , int b ) { return log10 ( a ) / log10 ( b ) ; } int get ( int a , int b , int n ) { int lo = 0 , hi = 1e6 ; int ans = 0 ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; int dig = ceil ( ( mid * log ( mid , b ) + log ( a , b ) ) ) ; if ( dig > n ) { hi = mid - 1 ; } else { ans = mid ; lo = mid + 1 ; } } return ans ; } int main ( ) { int a = 2 , b = 2 , n = 6 ; cout << get ( a , b , n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxMatrixSize ( vector < vector < int > > arr , int K ) { int i , j ; int n = arr . size ( ) ; int m = arr [ 0 ] . size ( ) ; int sum [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i == 0 j == 0 ) { sum [ i ] [ j ] = 0 ; continue ; } sum [ i ] [ j ] = arr [ i - 1 ] [ j - 1 ] + sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; } } int ans = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= m ; j ++ ) { if ( i + ans - 1 > n j + ans - 1 > m ) break ; int mid , lo = ans ; int hi = min ( n - i + 1 , m - j + 1 ) ; while ( lo < hi ) { mid = ( hi + lo + 1 ) / 2 ; if ( sum [ i + mid - 1 ] [ j + mid - 1 ] + sum [ i - 1 ] [ j - 1 ] - sum [ i + mid - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j + mid - 1 ] <= K ) { lo = mid ; } else { hi = mid - 1 ; } } ans = max ( ans , lo ) ; } } cout << ans << endl ; } int main ( ) { vector < vector < int > > arr ; arr = { { 1 , 1 , 3 , 2 , 4 , 3 , 2 } , { 1 , 1 , 3 , 2 , 4 , 3 , 2 } , { 1 , 1 , 3 , 2 , 4 , 3 , 2 } } ; int K = 4 ; findMaxMatrixSize ( arr , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestPermutation ( int a [ ] , int n ) { map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; } int len = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( freq [ i ] == 0 ) { break ; } len ++ ; } return len ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 , 6 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestPermutation ( arr , n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000005 NEW_LINE set < int > fib ; void fibonacci ( ) { int prev = 0 , curr = 1 , len = 2 ; fib . insert ( prev ) ; fib . insert ( curr ) ; while ( len <= MAX ) { int temp = curr + prev ; fib . insert ( temp ) ; prev = curr ; curr = temp ; len ++ ; } } void findFibonacci ( int N ) { for ( int i = N / 2 ; i > 1 ; i -- ) { if ( fib . find ( i ) != fib . end ( ) && fib . find ( N - i ) != fib . end ( ) ) { cout << i << " ▁ " << ( N - i ) << endl ; return ; } } cout << " - 1" << endl ; } int main ( ) { fibonacci ( ) ; int sum = 199 ; findFibonacci ( sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE #define MAX  100005 NEW_LINE using namespace std ; set < int > fibonacci ; void createHash ( ) { int prev = 0 , curr = 1 ; fibonacci . insert ( prev ) ; fibonacci . insert ( curr ) ; while ( curr <= MAX ) { int temp = curr + prev ; fibonacci . insert ( temp ) ; prev = curr ; curr = temp ; } } bool checkArray ( int arr [ ] , int n ) { ll sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( fibonacci . find ( arr [ i ] ) != fibonacci . end ( ) ) sum += arr [ i ] ; if ( fibonacci . find ( sum ) != fibonacci . end ( ) ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; createHash ( ) ; if ( checkArray ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 100001 ; int f [ 26 ] [ N ] ; void precompute ( string s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { f [ s [ i ] - ' a ' ] [ i ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { f [ i ] [ j ] += f [ i ] [ j - 1 ] ; } } } int palindromicSubsequencesUtil ( int L , int R ) { int c , ok = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = f [ i ] [ R ] ; if ( L > 0 ) cnt -= f [ i ] [ L - 1 ] ; if ( cnt > 1 ) { ok = 1 ; c = i ; break ; } } if ( ok == 0 ) { return -1 ; } return c ; } void palindromicSubsequences ( int Q [ ] [ 2 ] , int l ) { for ( int i = 0 ; i < l ; i ++ ) { int x = palindromicSubsequencesUtil ( Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; if ( x == -1 ) { cout << -1 << " STRNEWLINE " ; } else { char c = ' a ' + x ; cout << c << c << " STRNEWLINE " ; } } } int main ( ) { string str = " dbdeke " ; int Q [ ] [ 2 ] = { { 0 , 5 } , { 1 , 5 } , { 1 , 3 } } ; int n = str . size ( ) ; int l = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; precompute ( str , n ) ; palindromicSubsequences ( Q , l ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100000 NEW_LINE void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } int longestFibSubarray ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; set < int > hash ; createHash ( hash , max_val ) ; int left [ n ] , right [ n ] ; int fibcount = 0 , res = -1 ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = fibcount ; if ( hash . find ( arr [ i ] ) != hash . end ( ) ) { fibcount ++ ; } else fibcount = 0 ; } fibcount = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { right [ i ] = fibcount ; if ( hash . find ( arr [ i ] ) != hash . end ( ) ) { fibcount ++ ; } else fibcount = 0 ; } for ( int i = 0 ; i < n ; i ++ ) res = max ( res , left [ i ] + right [ i ] ) ; return res ; } int main ( ) { int arr [ ] = { 2 , 8 , 5 , 7 , 3 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestFibSubarray ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int N ) { if ( N < 2 ) return false ; if ( N < 4 ) return true ; if ( ( N & 1 ) == 0 ) return false ; if ( N % 3 == 0 ) return false ; int curr = 5 , s = sqrt ( N ) ; while ( curr <= s ) { if ( N % curr == 0 ) return false ; curr += 2 ; if ( N % curr == 0 ) return false ; curr += 4 ; } return true ; } bool check ( int s , int p , int prefix_sum [ ] , int n ) { bool satisfies = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( i + s - 1 >= n ) break ; if ( prefix_sum [ i + s - 1 ] - ( i - 1 >= 0 ? prefix_sum [ i - 1 ] : 0 ) < p ) satisfies = false ; } return satisfies ; } int minimumWindowSize ( int x , int y , int p ) { int prefix_sum [ y - x + 1 ] = { 0 } ; for ( int i = x ; i <= y ; i ++ ) { if ( isPrime ( i ) ) prefix_sum [ i - x ] = 1 ; } for ( int i = 1 ; i < y - x + 1 ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] ; int low = 1 , high = y - x + 1 ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , p , prefix_sum , y - x + 1 ) ) { high = mid ; } else low = mid ; } if ( check ( low , p , prefix_sum , y - x + 1 ) ) return low ; return high ; } int main ( ) { int x = 12 ; int y = 42 ; int p = 3 ; cout << minimumWindowSize ( x , y , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE #define M  5 NEW_LINE void preProcess ( int mat [ N ] [ M ] , int aux [ N ] [ M ] ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; } int sumQuery ( int aux [ N ] [ M ] , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; } int maximumSquareSize ( int mat [ N ] [ M ] , int K ) { int aux [ N ] [ M ] ; preProcess ( mat , aux ) ; for ( int i = min ( N , M ) ; i >= 1 ; i -- ) { bool satisfies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + i - 1 <= N - 1 && y + i - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + i - 1 , y + i - 1 ) > K ) satisfies = false ; } } } if ( satisfies == true ) return ( i ) ; } return 0 ; } int main ( ) { int K = 30 ; int mat [ N ] [ M ] = { { 1 , 2 , 3 , 4 , 6 } , { 5 , 3 , 8 , 1 , 2 } , { 4 , 6 , 7 , 5 , 5 } , { 2 , 4 , 8 , 9 , 4 } } ; cout << maximumSquareSize ( mat , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr < maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } void findFibonacciPair ( int n ) { set < int > hash ; createHash ( hash , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . find ( i ) != hash . end ( ) && hash . find ( n - i ) != hash . end ( ) ) { cout << i << " , ▁ " << ( n - i ) << endl ; return ; } } cout << " - 1 STRNEWLINE " ; } int main ( ) { int N = 90 ; findFibonacciPair ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void add_factors ( int n , unordered_map < int , int > & mp ) { for ( int i = 1 ; i <= int ( sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) mp [ i ] ++ ; else { mp [ i ] ++ ; mp [ n / i ] ++ ; } } } } void count_divisors ( int a [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { cout << mp [ a [ i ] ] << " ▁ " ; add_factors ( a [ i ] , mp ) ; } } int main ( ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; count_divisors ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeDuplicates ( int arr [ ] , int n ) { int st = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 2 && arr [ i ] == arr [ i + 1 ] && arr [ i ] == arr [ i + 2 ] ) continue ; else { arr [ st ] = arr [ i ] ; st ++ ; } } cout << " { " ; for ( int i = 0 ; i < st ; i ++ ) { cout << arr [ i ] ; if ( i != st - 1 ) cout << " , ▁ " ; } cout << " } " ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 2 , 2 , 2 , 3 , 3 , 3 , 3 , 3 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; removeDuplicates ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE int nfa = 1 ; int flag = 0 ; using namespace std ; void state1 ( char c ) { if ( c == ' a ' ) nfa = 2 ; else if ( c == ' b ' c == ' c ' ) nfa = 1 ; else flag = 1 ; } void state2 ( char c ) { if ( c == ' a ' ) nfa = 3 ; else if ( c == ' b ' c == ' c ' ) nfa = 2 ; else flag = 1 ; } void state3 ( char c ) { if ( c == ' a ' ) nfa = 1 ; else if ( c == ' b ' c == ' c ' ) nfa = 3 ; else flag = 1 ; } void state4 ( char c ) { if ( c == ' b ' ) nfa = 5 ; else if ( c == ' a ' c == ' c ' ) nfa = 4 ; else flag = 1 ; } void state5 ( char c ) { if ( c == ' b ' ) nfa = 6 ; else if ( c == ' a ' c == ' c ' ) nfa = 5 ; else flag = 1 ; } void state6 ( char c ) { if ( c == ' b ' ) nfa = 4 ; else if ( c == ' a ' c == ' c ' ) nfa = 6 ; else flag = 1 ; } void state7 ( char c ) { if ( c == ' c ' ) nfa = 8 ; else if ( c == ' b ' c == ' a ' ) nfa = 7 ; else flag = 1 ; } void state8 ( char c ) { if ( c == ' c ' ) nfa = 9 ; else if ( c == ' b ' c == ' a ' ) nfa = 8 ; else flag = 1 ; } void state9 ( char c ) { if ( c == ' c ' ) nfa = 7 ; else if ( c == ' b ' c == ' a ' ) nfa = 9 ; else flag = 1 ; } bool checkA ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 1 ) state1 ( s [ i ] ) ; else if ( nfa == 2 ) state2 ( s [ i ] ) ; else if ( nfa == 3 ) state3 ( s [ i ] ) ; } if ( nfa == 1 ) { return true ; } else { nfa = 4 ; } } bool checkB ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 4 ) state4 ( s [ i ] ) ; else if ( nfa == 5 ) state5 ( s [ i ] ) ; else if ( nfa == 6 ) state6 ( s [ i ] ) ; } if ( nfa == 4 ) { return true ; } else { nfa = 7 ; } } bool checkC ( string s , int x ) { for ( int i = 0 ; i < x ; i ++ ) { if ( nfa == 7 ) state7 ( s [ i ] ) ; else if ( nfa == 8 ) state8 ( s [ i ] ) ; else if ( nfa == 9 ) state9 ( s [ i ] ) ; } if ( nfa == 7 ) { return true ; } } int main ( ) { string s = " bbbca " ; int x = 5 ; if ( checkA ( s , x ) || checkB ( s , x ) || checkC ( s , x ) ) { cout << " ACCEPTED " ; } else { if ( flag == 0 ) { cout << " NOT ▁ ACCEPTED " ; return 0 ; } else { cout << " INPUT ▁ OUT ▁ OF ▁ DICTIONARY . " ; return 0 ; } } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPositionCount ( int a [ ] , int n ) { int count = 1 ; int min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= min ) { min = a [ i ] ; count ++ ; } } return count ; } int main ( ) { int a [ ] = { 5 , 4 , 6 , 1 , 3 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getPositionCount ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountSubSet ( int arr [ ] , int n , int X ) { int N = pow ( 2 , n ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) if ( arr [ j ] == X ) count += 1 ; } } return count ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 7 } ; int X = 5 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CountSubSet ( arr , n , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculatePower ( int b , int e ) { int ans = 1 ; while ( e > 0 ) { if ( e % 2 == 1 ) ans = ans * b ; e = e / 2 ; b = b * b ; } return ans ; } int CountSubSet ( int arr [ ] , int n , int X ) { int count = 0 , checkX = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == X ) { checkX = 1 ; break ; } } if ( checkX == 1 ) count = calculatePower ( 2 , n - 1 ) ; else count = 0 ; return count ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 7 } ; int X = 5 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CountSubSet ( arr , n , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n , int k ) { if ( n < k ) { return -1 ; } int res = 0 ; for ( int i = 0 ; i < k ; i ++ ) res += arr [ i ] ; int curr_sum = res ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; res = max ( res , curr_sum ) ; } return res ; } int solve ( int arr [ ] , int n , int k ) { int max_len = 0 , l = 0 , r = n , m ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( maxSum ( arr , n , m ) > k ) r = m - 1 ; else { l = m + 1 ; max_len = m ; } } return max_len ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 10 ; cout << solve ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidLen ( string s , int len , int k ) { int n = s . size ( ) ; unordered_map < char , int > mp ; int right = 0 ; while ( right < len ) { mp [ s [ right ] ] ++ ; right ++ ; } if ( mp . size ( ) <= k ) return true ; while ( right < n ) { mp [ s [ right ] ] ++ ; mp [ s [ right - len ] ] -- ; if ( mp [ s [ right - len ] ] == 0 ) mp . erase ( s [ right - len ] ) ; if ( mp . size ( ) <= k ) return true ; right ++ ; } return mp . size ( ) <= k ; } int maxLenSubStr ( string s , int k ) { set < char > uni ; for ( auto x : s ) uni . insert ( x ) ; if ( uni . size ( ) < k ) return -1 ; int n = s . size ( ) ; int lo = -1 , hi = n + 1 ; while ( hi - lo > 1 ) { int mid = lo + hi >> 1 ; if ( isValidLen ( s , mid , k ) ) lo = mid ; else hi = mid ; } return lo ; } int main ( ) { string s = " aabacbebebe " ; int k = 3 ; cout << maxLenSubStr ( s , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int woodCollected ( int height [ ] , int n , int m ) { int sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] - m <= 0 ) break ; sum += ( height [ i ] - m ) ; } return sum ; } int collectKWood ( int height [ ] , int n , int k ) { sort ( height , height + n ) ; int low = 0 , high = height [ n - 1 ] ; while ( low <= high ) { int mid = low + ( ( high - low ) / 2 ) ; int collected = woodCollected ( height , n , mid ) ; if ( collected == k ) return mid ; if ( collected > k ) low = mid + 1 ; else high = mid - 1 ; } return -1 ; } int main ( ) { int height [ ] = { 1 , 2 , 1 , 2 } ; int n = sizeof ( height ) / sizeof ( height [ 0 ] ) ; int k = 2 ; cout << collectKWood ( height , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10 ; bool isDigit ( char ch ) { if ( ch >= '0' && ch <= '9' ) return true ; return false ; } bool allDigits ( string str , int len ) { bool present [ MAX ] = { false } ; for ( int i = 0 ; i < len ; i ++ ) { if ( isDigit ( str [ i ] ) ) { int digit = str [ i ] - '0' ; present [ digit ] = true ; } } for ( int i = 0 ; i < MAX ; i ++ ) { if ( ! present [ i ] ) return false ; } return true ; } int main ( ) { string str = " Geeks12345for69708" ; int len = str . length ( ) ; if ( allDigits ( str , len ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPlusPossible ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; bool foundModOne = false ; for ( auto x : mp ) { int element = x . first ; int frequency = x . second ; if ( frequency % 4 == 0 ) continue ; if ( frequency % 4 == 1 ) { if ( foundModOne ) return false ; foundModOne = true ; } else return false ; } } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 1 , 2 , 2 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isPlusPossible ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > merge ( vector < int > & v1 , vector < int > & v2 ) { int i = 0 , j = 0 ; vector < int > v ; while ( i < v1 . size ( ) && j < v2 . size ( ) ) { if ( v1 [ i ] <= v2 [ j ] ) { v . push_back ( v1 [ i ] ) ; i ++ ; } else { v . push_back ( v2 [ j ] ) ; j ++ ; } } for ( int k = i ; k < v1 . size ( ) ; k ++ ) v . push_back ( v1 [ k ] ) ; for ( int k = j ; k < v2 . size ( ) ; k ++ ) v . push_back ( v2 [ k ] ) ; return v ; } void buildTree ( vector < int > * tree , int * arr , int index , int s , int e ) { if ( s == e ) { tree [ index ] . push_back ( arr [ s ] ) ; return ; } int mid = ( s + e ) / 2 ; buildTree ( tree , arr , 2 * index , s , mid ) ; buildTree ( tree , arr , 2 * index + 1 , mid + 1 , e ) ; tree [ index ] = merge ( tree [ 2 * index ] , tree [ 2 * index + 1 ] ) ; } int query ( vector < int > * tree , int index , int s , int e , int l , int r , int k ) { if ( r < s l > e ) return 0 ; if ( s >= l && e <= r ) { return ( tree [ index ] . size ( ) - ( lower_bound ( tree [ index ] . begin ( ) , tree [ index ] . end ( ) , k ) - tree [ index ] . begin ( ) ) ) ; } int mid = ( s + e ) / 2 ; return ( query ( tree , 2 * index , s , mid , l , r , k ) + query ( tree , 2 * index + 1 , mid + 1 , e , l , r , k ) ) ; } void performQueries ( int L [ ] , int R [ ] , int K [ ] , int n , int q , vector < int > tree [ ] ) { for ( int i = 0 ; i < q ; i ++ ) { cout << query ( tree , 1 , 0 , n - 1 , L [ i ] - 1 , R [ i ] - 1 , K [ i ] ) << endl ; } } int main ( ) { int arr [ ] = { 7 , 3 , 9 , 13 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; vector < int > tree [ 4 * n + 1 ] ; buildTree ( tree , arr , 1 , 0 , n - 1 ) ; int L [ ] = { 1 , 2 } ; int R [ ] = { 4 , 6 } ; int K [ ] = { 6 , 8 } ; int q = sizeof ( L ) / sizeof ( L [ 0 ] ) ; performQueries ( L , R , K , n , q , tree ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > arr ( 1000000 ) , tree ( 4 * arr . size ( ) ) ; int combine ( int a , int b ) { if ( a != 0 && b != 0 ) { return a ; } if ( a >= b ) { return a ; } return b ; } void buildTree ( int ind , int low , int high , int x ) { if ( low == high ) { if ( arr [ low ] > x ) { tree [ ind ] = arr [ low ] ; } else { tree [ ind ] = 0 ; } return ; } int mid = ( low + high ) / 2 ; buildTree ( 2 * ind + 1 , low , mid , x ) ; buildTree ( 2 * ind + 2 , mid + 1 , high , x ) ; tree [ ind ] = combine ( tree [ 2 * ind + 1 ] , tree [ 2 * ind + 2 ] ) ; } int query ( int ind , int low , int high , int l , int r ) { int mid = ( low + high ) / 2 ; if ( low > r high < l ) { return 0 ; } if ( l <= low && r >= high ) { return tree [ ind ] ; } return combine ( query ( 2 * ind + 1 , low , mid , l , r ) , query ( 2 * ind + 2 , mid + 1 , high , l , r ) ) ; } int main ( ) { arr = { 7 , 3 , 9 , 13 , 5 , 4 } ; int n = 6 ; int k = 6 ; int l = 1 , r = 4 ; buildTree ( 0 , 0 , n - 1 , k ) ; cout << query ( 0 , 0 , n - 1 , l - 1 , r - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findGCDSum ( int n , int a [ ] ) { int GCDSum = 0 ; int tempGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { tempGCD = 0 ; for ( int k = i ; k <= j ; k ++ ) { tempGCD = __gcd ( tempGCD , a [ k ] ) ; } GCDSum += tempGCD ; } } return GCDSum ; } int main ( ) { int n = 5 ; int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int totalSum = findGCDSum ( n , a ) ; cout << totalSum << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSquarePossible ( int arr [ ] , int n , int l ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; } int maxArea ( int arr [ ] , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxArea ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE #define MAX  100001 NEW_LINE #define ROW  10 NEW_LINE #define COl  3 NEW_LINE vector < int > indices [ MAX ] ; int test [ ROW ] [ COl ] = { { 2 , 3 , 6 } , { 2 , 4 , 4 } , { 2 , 6 , 3 } , { 3 , 2 , 6 } , { 3 , 3 , 3 } , { 3 , 6 , 2 } , { 4 , 2 , 4 } , { 4 , 4 , 2 } , { 6 , 2 , 3 } , { 6 , 3 , 2 } } ; int find_triplet ( int array [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { indices [ array [ i ] ] . push_back ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { int y = array [ i ] ; for ( int j = 0 ; j < ROW ; j ++ ) { int s = test [ j ] [ 1 ] * y ; if ( s % test [ j ] [ 0 ] != 0 ) continue ; if ( s % test [ j ] [ 2 ] != 0 ) continue ; int x = s / test [ j ] [ 0 ] ; ll z = s / test [ j ] [ 2 ] ; if ( x > MAX z > MAX ) continue ; int l = 0 ; int r = indices [ x ] . size ( ) - 1 ; int first = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ x ] [ m ] < i ) { first = m ; l = m + 1 ; } else { r = m - 1 ; } } l = 0 ; r = indices [ z ] . size ( ) - 1 ; int third = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( indices [ z ] [ m ] > i ) { third = m ; r = m - 1 ; } else { l = m + 1 ; } } if ( first != -1 && third != -1 ) { answer += ( first + 1 ) * ( indices [ z ] . size ( ) - third ) ; } } } return answer ; } int main ( ) { int array [ ] = { 2 , 4 , 5 , 6 , 7 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << find_triplet ( array , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void insertNames ( string arr [ ] , int n ) { unordered_set < string > set ; for ( int i = 0 ; i < n ; i ++ ) { if ( set . find ( arr [ i ] ) == set . end ( ) ) { cout << " No STRNEWLINE " ; set . insert ( arr [ i ] ) ; } else { cout << " Yes STRNEWLINE " ; } } } int main ( ) { string arr [ ] = { " geeks " , " for " , " geeks " } ; int n = sizeof ( arr ) / sizeof ( string ) ; insertNames ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool containsElement ( int arr [ ] , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; ++ i ) xorArr ^= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { int x = xorArr ^ arr [ i ] ; if ( arr [ i ] == x ) return true ; } return false ; } int main ( ) { int arr [ ] = { 8 , 2 , 4 , 15 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( containsElement ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double Square ( double n , double i , double j ) { double mid = ( i + j ) / 2 ; double mul = mid * mid ; if ( ( mul == n ) || ( abs ( mul - n ) < 0.00001 ) ) return mid ; else if ( mul < n ) return Square ( n , mid , j ) ; else return Square ( n , i , mid ) ; } void findSqrt ( double n ) { double i = 1 ; bool found = false ; while ( ! found ) { if ( i * i == n ) { cout << fixed << setprecision ( 0 ) << i ; found = true ; } else if ( i * i > n ) { double res = Square ( n , i - 1 , i ) ; cout << fixed << setprecision ( 5 ) << res ; found = true ; } i ++ ; } } int main ( ) { double n = 3 ; findSqrt ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int length_substring ( string S , char K ) { int curr_cnt = 0 , prev_cnt = 0 , max_len ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( S [ i ] == K ) { curr_cnt += 1 ; } else { prev_cnt = max ( prev_cnt , curr_cnt ) ; curr_cnt = 0 ; } } prev_cnt = max ( prev_cnt , curr_cnt ) ; max_len = prev_cnt ; return max_len ; } int main ( ) { string S = " abcd1111aabc " ; char K = '1' ; cout << length_substring ( S , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Xor_Sum ( int arr [ ] , int n ) { int sum = 0 , index , left_xor = 0 , right_xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left_xor = left_xor ^ arr [ i ] ; right_xor = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { right_xor = right_xor ^ arr [ j ] ; } if ( left_xor + right_xor > sum ) { sum = left_xor + right_xor ; index = i ; } } return index + 1 ; } int main ( ) { int arr [ ] = { 1 , 4 , 6 , 3 , 8 , 13 , 34 , 2 , 21 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Xor_Sum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ComputePrefixXor ( int arr [ ] , int PrefixXor [ ] , int n ) { PrefixXor [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) PrefixXor [ i ] = PrefixXor [ i - 1 ] ^ arr [ i ] ; } int Xor_Sum ( int arr [ ] , int n ) { int PrefixXor [ n ] ; ComputePrefixXor ( arr , PrefixXor , n ) ; int sum = 0 , index ; for ( int i = 0 ; i < n ; i ++ ) { if ( PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) > sum ) { sum = PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) ; index = i ; } } return index + 1 ; } int main ( ) { int arr [ ] = { 1 , 4 , 6 , 3 , 8 , 13 , 34 , 2 , 21 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Xor_Sum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int ALPHABET_SIZE = 26 ; struct TrieNode { struct TrieNode * children [ ALPHABET_SIZE ] ; bool isEndOfWord ; } ; struct TrieNode * getNode ( void ) { struct TrieNode * pNode = new TrieNode ; pNode -> isEndOfWord = false ; for ( int i = 0 ; i < ALPHABET_SIZE ; i ++ ) pNode -> children [ i ] = NULL ; return pNode ; } void insert ( struct TrieNode * root , string key ) { struct TrieNode * pCrawl = root ; for ( int i = 0 ; i < key . length ( ) ; i ++ ) { int index = key [ i ] - ' a ' ; if ( ! pCrawl -> children [ index ] ) pCrawl -> children [ index ] = getNode ( ) ; pCrawl -> isEndOfWord = false ; pCrawl = pCrawl -> children [ index ] ; } int i ; for ( i = 0 ; i < 26 ; i ++ ) { if ( pCrawl -> children [ i ] ) { break ; } } if ( i == 26 ) { pCrawl -> isEndOfWord = true ; } } void display ( struct TrieNode * root , char str [ ] , int level ) { if ( root -> isEndOfWord ) { str [ level ] = ' \0' ; cout << str << endl ; } int i ; for ( i = 0 ; i < ALPHABET_SIZE ; i ++ ) { if ( root -> children [ i ] ) { str [ level ] = i + ' a ' ; display ( root -> children [ i ] , str , level + 1 ) ; } } } int main ( ) { string keys [ ] = { " apple " , " app " , " there " , " the " , " like " } ; int n = sizeof ( keys ) / sizeof ( string ) ; struct TrieNode * root = getNode ( ) ; for ( int i = 0 ; i < n ; i ++ ) insert ( root , keys [ i ] ) ; char str [ 100 ] ; display ( root , str , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findColor ( map < int , int > mapWithColor , int query ) { int maximum = 0 ; while ( query >= 1 ) { if ( mapWithColor . find ( query ) != mapWithColor . end ( ) ) { maximum = max ( maximum , mapWithColor [ query ] ) ; } if ( query % 2 == 1 ) query = ( query - 1 ) / 2 ; else query = query / 2 ; } return maximum ; } map < int , int > buildMapWithColor ( int arr [ ] , int n ) { map < int , int > mapWithColor ; for ( int i = 0 ; i < n ; i ++ ) { mapWithColor [ arr [ i ] ] = i + 1 ; } return mapWithColor ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 7 ; map < int , int > mapWithColor = buildMapWithColor ( arr , n ) ; cout << findColor ( mapWithColor , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void LeftRightNode ( int preorder [ ] , int n ) { int min = INT_MAX , max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > preorder [ i ] ) min = preorder [ i ] ; if ( max < preorder [ i ] ) max = preorder [ i ] ; } cout << " Leftmost ▁ node ▁ is ▁ " << min << " STRNEWLINE " ; cout << " Rightmost ▁ node ▁ is ▁ " << max ; } int main ( ) { int preorder [ ] = { 3 , 2 , 1 , 5 , 4 } ; int n = 5 ; LeftRightNode ( preorder , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinct ( int arr [ ] , int n ) { int count = 0 ; if ( n == 1 ) return 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] != arr [ i + 1 ] ) count += 1 ; } else { if ( arr [ i ] != arr [ i + 1 ] arr [ i ] != arr [ i - 1 ] ) count += 1 ; } } if ( arr [ n - 1 ] != arr [ n - 2 ] ) count += 1 ; return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << distinct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int m = 6 , n = 4 ; int compareRow ( int a1 [ ] , int a2 [ ] ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a1 [ i ] < a2 [ i ] ) return 1 ; else if ( a1 [ i ] > a2 [ i ] ) return -1 ; } return 0 ; } int binaryCheck ( int ar [ ] [ n ] , int arr [ ] ) { int l = 0 , r = m - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int temp = compareRow ( ar [ mid ] , arr ) ; if ( temp == 0 ) return mid + 1 ; else if ( temp == 1 ) l = mid + 1 ; else r = mid - 1 ; } return -1 ; } int main ( ) { int mat [ m ] [ n ] = { { 0 , 0 , 1 , 0 } , { 10 , 9 , 22 , 23 } , { 40 , 40 , 40 , 40 } , { 43 , 44 , 55 , 68 } , { 81 , 73 , 100 , 132 } , { 100 , 75 , 125 , 133 } } ; int row [ n ] = { 10 , 9 , 22 , 23 } ; cout << binaryCheck ( mat , row ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define maxLen  30 NEW_LINE using namespace std ; int findCnt ( int arr [ ] , int n , int k ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; if ( arr [ i ] > k or arr [ i ] < -1 * k ) ans ++ ; } if ( arr [ 0 ] > k arr [ 0 ] < -1 * k ) ans ++ ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) ans += n - ( upper_bound ( arr , arr + n , arr [ i ] + k ) - arr ) ; return ans ; } int main ( ) { int arr [ ] = { -1 , 4 , -5 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 0 ; cout << findCnt ( arr , n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindIntersection ( pair < int , int > type1 [ ] , int n , pair < int , int > type2 [ ] , int m ) { int ans = n * m ; vector < int > start , end ; for ( int i = 0 ; i < n ; i ++ ) { start . push_back ( type1 [ i ] . first ) ; end . push_back ( type1 [ i ] . second ) ; } sort ( start . begin ( ) , start . end ( ) ) ; sort ( end . begin ( ) , end . end ( ) ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = type2 [ i ] . first ; int R = type2 [ i ] . second ; ans -= ( start . end ( ) - upper_bound ( start . begin ( ) , start . end ( ) , R ) ) ; ans -= ( upper_bound ( end . begin ( ) , end . end ( ) , L - 1 ) - end . begin ( ) ) ; } return ans ; } int main ( ) { pair < int , int > type1 [ ] = { { 1 , 2 } , { 2 , 3 } , { 4 , 5 } , { 6 , 7 } } ; pair < int , int > type2 [ ] = { { 1 , 5 } , { 2 , 3 } , { 4 , 7 } , { 5 , 7 } } ; int n = sizeof ( type1 ) / ( sizeof ( type1 [ 0 ] ) ) ; int m = sizeof ( type2 ) / sizeof ( type2 [ 0 ] ) ; cout << FindIntersection ( type1 , n , type2 , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } int divTermCount ( int a , int b , int c , int num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / lcm ( a , b ) ) - ( num / lcm ( b , c ) ) - ( num / lcm ( a , c ) ) + ( num / lcm ( a , lcm ( b , c ) ) ) ) ; } int findNthTerm ( int a , int b , int c , int n ) { int low = 1 , high = INT_MAX , mid ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , c , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { int a = 2 , b = 3 , c = 5 , n = 10 ; cout << findNthTerm ( a , b , c , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int mid , int array [ ] , int n , int K ) { int count = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] > mid ) return false ; sum += array [ i ] ; if ( sum > mid ) { count ++ ; sum = array [ i ] ; } } count ++ ; if ( count <= K ) return true ; return false ; } int solve ( int array [ ] , int n , int K ) { int * max = max_element ( array , array + n ) ; int end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { } int answer = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , array , n , K ) ) { answer = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } return answer ; } int main ( ) { int array [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; int K = 3 ; cout << solve ( array , n , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createSorted ( int a [ ] , int n ) { vector < int > b ; for ( int j = 0 ; j < n ; j ++ ) { if ( b . empty ( ) ) b . push_back ( a [ j ] ) ; else { int start = 0 , end = b . size ( ) - 1 ; int pos = 0 ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( b [ mid ] == a [ j ] ) { b . emplace ( b . begin ( ) + max ( 0 , mid + 1 ) , a [ j ] ) ; break ; } else if ( b [ mid ] > a [ j ] ) pos = end = mid - 1 ; else pos = start = mid + 1 ; if ( start > end ) { pos = start ; b . emplace ( b . begin ( ) + max ( 0 , pos ) , a [ j ] ) ; break ; } } } } for ( int i = 0 ; i < n ; i ++ ) cout << b [ i ] << " ▁ " ; } int main ( ) { int a [ ] = { 2 , 5 , 4 , 9 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; createSorted ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE bool atLeastK ( int freq [ ] , int k ) { for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] != 0 && freq [ i ] < k ) return false ; } return true ; } void setZero ( int freq [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) freq [ i ] = 0 ; } int findlength ( string str , int n , int k ) { int maxLen = 0 ; int freq [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { setZero ( freq ) ; for ( int j = i ; j < n ; j ++ ) { freq [ str [ j ] - ' a ' ] ++ ; if ( atLeastK ( freq , k ) ) { maxLen = max ( maxLen , j - i + 1 ) ; } } } return maxLen ; } int main ( ) { string str = " xyxyyz " ; int n = str . length ( ) ; int k = 2 ; cout << findlength ( str , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE #include <unordered_set> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; void insert ( Node * * head , int item ) { Node * temp = new Node ( ) ; temp -> data = item ; temp -> next = * head ; * head = temp ; } int countNode ( Node * head ) { if ( head == NULL ) return 0 ; ; unordered_set < int > s ; s . insert ( head -> data ) ; int count = 0 ; for ( Node * curr = head -> next ; curr != NULL ; curr = curr -> next ) { if ( s . find ( curr -> data ) != s . end ( ) ) count ++ ; s . insert ( curr -> data ) ; } return count ; } int main ( ) { Node * head = NULL ; insert ( & head , 5 ) ; insert ( & head , 7 ) ; insert ( & head , 5 ) ; insert ( & head , 1 ) ; insert ( & head , 7 ) ; cout << countNode ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( int arr [ ] , int n ) { bool v [ n ] = { 0 } ; queue < int > q ; q . push ( 0 ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- ) { int i = q . front ( ) ; q . pop ( ) ; if ( v [ i ] ) continue ; if ( i == n - 1 ) return depth ; v [ i ] = 1 ; if ( i + arr [ i ] < n ) q . push ( i + arr [ i ] ) ; if ( i - arr [ i ] >= 0 ) q . push ( i - arr [ i ] ) ; } depth ++ ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << minSteps ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int box [ ] , int truck [ ] , int n , int m , int min_time ) { int temp = 0 ; int count = 0 ; while ( count < m ) { for ( int j = 0 ; j < min_time && temp < n && truck [ count ] >= box [ temp ] ; j += 2 ) temp ++ ; count ++ ; } if ( temp == n ) return true ; return false ; } int minTime ( int box [ ] , int truck [ ] , int n , int m ) { sort ( box , box + n ) ; sort ( truck , truck + m ) ; int l = 0 ; int h = 2 * n ; int min_time = 0 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( isPossible ( box , truck , n , m , mid ) ) { min_time = mid ; h = mid - 1 ; } else l = mid + 1 ; } return min_time ; } int main ( ) { int box [ ] = { 10 , 2 , 16 , 19 } ; int truck [ ] = { 29 , 25 } ; int n = sizeof ( box ) / sizeof ( int ) ; int m = sizeof ( truck ) / sizeof ( int ) ; printf ( " % d " , minTime ( box , truck , n , m ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; void solve ( int interval [ ] [ 2 ] , int N , int Q ) { int Mark [ Q ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int l = interval [ i ] [ 0 ] - 1 ; int r = interval [ i ] [ 1 ] - 1 ; for ( int j = l ; j <= r ; j ++ ) Mark [ j ] ++ ; } int count = 0 ; for ( int i = 0 ; i < Q ; i ++ ) { if ( Mark [ i ] ) count ++ ; } int count1 [ Q ] = { 0 } ; if ( Mark [ 0 ] == 1 ) count1 [ 0 ] = 1 ; for ( int i = 1 ; i < Q ; i ++ ) { if ( Mark [ i ] == 1 ) count1 [ i ] = count1 [ i - 1 ] + 1 ; else count1 [ i ] = count1 [ i - 1 ] ; } int maxindex ; int maxcoverage = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int l = interval [ i ] [ 0 ] - 1 ; int r = interval [ i ] [ 1 ] - 1 ; int elem1 ; if ( l != 0 ) elem1 = count1 [ r ] - count1 [ l - 1 ] ; else elem1 = count1 [ r ] ; if ( count - elem1 >= maxcoverage ) { maxcoverage = count - elem1 ; maxindex = i ; } } cout << " Maximum ▁ Coverage ▁ is ▁ " << maxcoverage << " ▁ after ▁ removing ▁ interval ▁ at ▁ index ▁ " << maxindex ; } int main ( ) { int interval [ ] [ 2 ] = { { 1 , 4 } , { 4 , 5 } , { 5 , 6 } , { 6 , 7 } , { 3 , 5 } } ; int N = sizeof ( interval ) / sizeof ( interval [ 0 ] ) ; int Q = 7 ; solve ( interval , N , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getKthElement ( int n , int k , int L [ ] , int R [ ] ) { int l = 1 ; int h = n ; int total [ n + 1 ] ; total [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 ; } int index = -1 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( total [ m ] > k ) { index = m ; h = m - 1 ; } else if ( total [ m ] < k ) l = m + 1 ; else { index = m ; break ; } } l = L [ index - 1 ] ; h = R [ index - 1 ] ; int x = k - total [ index - 1 ] ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( m - L [ index - 1 ] ) + 1 == x ) { return m ; } else if ( ( m - L [ index - 1 ] ) + 1 > x ) h = m - 1 ; else l = m + 1 ; } } int main ( ) { int L [ ] = { 1 , 8 , 21 } ; int R [ ] = { 4 , 10 , 23 } ; int n = sizeof ( L ) / sizeof ( int ) ; int k = 6 ; cout << getKthElement ( n , k , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumX ( int a , int b , int c , int k ) { int x = INT_MAX ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; } int main ( ) { int a = 3 , b = 2 , c = 4 , k = 15 ; cout << MinimumX ( a , b , c , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void IfExists ( int arr [ ] , int n ) { int sum [ n ] ; sort ( arr , arr + n ) ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; int max = arr [ n - 1 ] ; bool flag = false ; for ( int i = 1 ; i <= max ; i ++ ) { int findex = 0 ; int lindex = 0 ; int l = 0 ; int r = n - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < i ) { findex = m ; l = m + 1 ; } else r = m - 1 ; } l = 1 ; r = n ; flag = false ; while ( l <= r ) { int m = ( r + l ) / 2 ; if ( arr [ m ] > i ) { lindex = m ; r = m - 1 ; } else l = m + 1 ; } if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) { flag = true ; break ; } } if ( flag ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; IfExists ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMissing ( int arr [ ] , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return -1 ; } int main ( ) { int arr [ ] = { -9 , -8 , -7 , -5 , -4 , -3 , -2 , -1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( findMissing ( arr , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n , int K ) { int maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ; for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = max ( maximum , sumk ) ; } return maximum ; } int main ( ) { int arr [ ] = { 3 , 6 , 4 , 7 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << maxSum ( arr , n , K ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countGreater ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; } int main ( ) { int arr [ ] = { 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 7 ; cout << countGreater ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int operations ( int op [ ] , int n , int k ) { int i , count = 0 ; int nVal = 0 ; int minimum = INT_MAX ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; minimum = min ( minimum , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return -1 ; int times = ( k - abs ( minimum ) ) / abs ( nVal ) ; k = ( k - ( times * abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; } int main ( ) { int op [ ] = { -60 , 65 , -1 , 14 , -25 } ; int n = sizeof ( op ) / sizeof ( op [ 0 ] ) ; int k = 100000 ; cout << operations ( op , n , k ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_SIZE = 1000 ; int lookup_table [ MAX_SIZE ] ; void create_table ( int n ) { int pow = 1 ; int co = 0 ; do { pow <<= 1 ; lookup_table [ co ] = ( n + ( pow >> 1 ) ) / pow ; } while ( lookup_table [ co ++ ] != 0 ) ; } int binary ( int arr [ ] , int v ) { int index = lookup_table [ 0 ] - 1 ; int co = 0 ; while ( lookup_table [ co ] != 0 ) { if ( v == arr [ index ] ) return index ; else if ( v < arr [ index ] ) index -= lookup_table [ ++ co ] ; else index += lookup_table [ ++ co ] ; } } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( int ) ; create_table ( n ) ; cout << " Position ▁ of ▁ 3 ▁ in ▁ array ▁ = ▁ " << binary ( arr , 3 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int squareSum ( int N ) { int sum = ( int ) ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ; return sum ; } int findMaxN ( int X ) { int low = 1 , high = 100000 ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( squareSum ( mid ) <= X ) { N = mid ; low = mid + 1 ; } else high = mid - 1 ; } return N ; } int main ( ) { int X = 25 ; cout << findMaxN ( X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumber ( pair < int , int > a [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( K >= a [ i ] . first && K <= a [ i ] . second ) return i ; } return -1 ; } int main ( ) { pair < int , int > a [ ] = { { 1 , 3 } , { 4 , 7 } , { 8 , 11 } } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 6 ; int index = findNumber ( a , n , k ) ; if ( index != -1 ) cout << index ; else cout << -1 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumber ( pair < int , int > a [ ] , int n , int K ) { int low = 0 , high = n - 1 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( K >= a [ mid ] . first && K <= a [ mid ] . second ) return mid ; else if ( K < a [ mid ] . first ) high = mid - 1 ; else low = mid + 1 ; } return -1 ; } int main ( ) { pair < int , int > a [ ] = { { 1 , 3 } , { 4 , 7 } , { 8 , 11 } } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 6 ; int index = findNumber ( a , n , k ) ; if ( index != -1 ) cout << index ; else cout << -1 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void prefixSum ( int * p_arr , int * arr , int n ) { p_arr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) p_arr [ i ] = arr [ i ] + p_arr [ i - 1 ] ; } void hashPrefixSum ( int * p_arr , int n , unordered_set < int > & q ) { for ( int i = 0 ; i < n ; i ++ ) q . insert ( p_arr [ i ] ) ; } void canDivide ( int * p_arr , int n , unordered_set < int > & q , int l , int r ) { int sum ; if ( l == 0 ) sum = p_arr [ r ] ; else sum = p_arr [ r ] - p_arr [ l - 1 ] ; if ( sum % 2 == 1 ) { cout << " No " << endl ; return ; } int beg = 0 ; if ( l != 0 ) beg = p_arr [ l - 1 ] ; if ( q . find ( beg + sum / 2 ) != q . end ( ) ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int p_arr [ n ] ; prefixSum ( p_arr , arr , n ) ; unordered_set < int > q ; hashPrefixSum ( p_arr , n , q ) ; canDivide ( p_arr , n , q , 0 , 1 ) ; canDivide ( p_arr , n , q , 1 , 3 ) ; canDivide ( p_arr , n , q , 1 , 2 ) ; return 0 ; }
#include <iostream> NEW_LINE #define n  4 NEW_LINE using namespace std ; int findRing ( int arr [ ] [ n ] , int x ) { if ( arr [ 0 ] [ 0 ] > x ) return -1 ; int l = 0 , r = ( n + 1 ) / 2 - 1 ; if ( n % 2 == 1 && arr [ r ] [ r ] < x ) return -1 ; if ( n % 2 == 0 && arr [ r + 1 ] [ r ] < x ) return -1 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] [ mid ] <= x ) if ( mid == ( n + 1 ) / 2 - 1 arr [ mid + 1 ] [ mid + 1 ] > x ) return mid ; else l = mid + 1 ; else r = mid - 1 ; } return r ; } int binarySearchRowInc ( int arr [ ] [ n ] , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return -1 ; } int binarySearchColumnInc ( int arr [ ] [ n ] , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) t = mid + 1 ; else b = mid - 1 ; } return -1 ; } int binarySearchRowDec ( int arr [ ] [ n ] , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) r = mid - 1 ; else l = mid + 1 ; } return -1 ; } int binarySearchColumnDec ( int arr [ ] [ n ] , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) b = mid - 1 ; else t = mid + 1 ; } return -1 ; } void spiralBinary ( int arr [ ] [ n ] , int x ) { int f1 = findRing ( arr , x ) ; int r , c ; if ( f1 == -1 ) { cout << " - 1" ; return ; } if ( n % 2 == 1 && f1 == ( n + 1 ) / 2 - 1 ) { cout << f1 << " ▁ " << f1 << endl ; return ; } if ( x < arr [ f1 ] [ n - f1 - 1 ] ) { c = binarySearchRowInc ( arr , f1 , f1 , n - f1 - 2 , x ) ; r = f1 ; } else if ( x < arr [ n - f1 - 1 ] [ n - f1 - 1 ] ) { c = n - f1 - 1 ; r = binarySearchColumnInc ( arr , n - f1 - 1 , f1 , n - f1 - 2 , x ) ; } else if ( x < arr [ n - f1 - 1 ] [ f1 ] ) { c = binarySearchRowDec ( arr , n - f1 - 1 , f1 + 1 , n - f1 - 1 , x ) ; r = n - f1 - 1 ; } else { r = binarySearchColumnDec ( arr , f1 , f1 + 1 , n - f1 - 1 , x ) ; c = f1 ; } if ( c == -1 r == -1 ) cout << " - 1" ; else cout << r << " ▁ " << c ; return ; } int main ( ) { int arr [ ] [ n ] = { { 1 , 2 , 3 , 4 } , { 12 , 13 , 14 , 5 } , { 11 , 16 , 15 , 6 } , { 10 , 9 , 8 , 7 } } ; spiralBinary ( arr , 7 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubArrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 6 ; cout << countSubArrays ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100002 NEW_LINE int tree [ 4 * N ] ; void build ( int * arr , int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) >> 1 ; build ( arr , 2 * node , start , mid ) ; build ( arr , 2 * node + 1 , mid + 1 , end ) ; tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] ; } int query ( int node , int start , int end , int l , int r ) { if ( start > end start > r end < l ) { return 0 ; } if ( start >= l && end <= r ) { return tree [ node ] ; } int mid = ( start + end ) >> 1 ; int q1 = query ( 2 * node , start , mid , l , r ) ; int q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return q1 | q2 ; } int countSubArrays ( int arr [ ] , int n , int K ) { build ( arr , 1 , 0 , n - 1 ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = query ( 1 , 0 , n - 1 , i , j ) ; if ( bitwise_or >= K ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 6 ; cout << countSubArrays ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  100002 NEW_LINE using namespace std ; int tree [ 4 * N ] ; void build ( int * arr , int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) >> 1 ; build ( arr , 2 * node , start , mid ) ; build ( arr , 2 * node + 1 , mid + 1 , end ) ; tree [ node ] = tree [ 2 * node ] | tree [ 2 * node + 1 ] ; } int query ( int node , int start , int end , int l , int r ) { if ( start > end start > r end < l ) { return 0 ; } if ( start >= l && end <= r ) { return tree [ node ] ; } int mid = ( start + end ) >> 1 ; int q1 = query ( 2 * node , start , mid , l , r ) ; int q2 = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return q1 | q2 ; } int countSubArrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int low = i , high = n - 1 , index = INT_MAX ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( query ( 1 , 0 , n - 1 , i , mid ) >= K ) { index = min ( index , mid ) ; high = mid - 1 ; } else { low = mid + 1 ; } } if ( index != INT_MAX ) { count += n - index ; } } return count ; } int main ( ) { int arr [ ] = { 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; build ( arr , 1 , 0 , n - 1 ) ; int k = 6 ; cout << countSubArrays ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPattern ( int n , string pat ) { int pattern_int = 0 ; int power_two = 1 ; int all_ones = 0 ; for ( int i = pat . length ( ) - 1 ; i >= 0 ; i -- ) { int current_bit = pat [ i ] - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; } int main ( ) { int n = 500 ; string pat = "10" ; cout << countPattern ( n , pat ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_min ( int a [ ] , int n ) { sort ( a , a + n ) ; return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; } int main ( ) { int a [ ] = { 1 , 3 , 3 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << max_min ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000001 ; int primeUpto [ MAX ] ; void SieveOfEratosthenes ( ) { bool isPrime [ MAX ] ; memset ( isPrime , 1 , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] ) primeUpto [ i ] ++ ; } } int countOfNumbers ( int N , int K ) { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans ? N - ans + 1 : 0 ) ; } int main ( ) { int N = 10 , K = 3 ; cout << countOfNumbers ( N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minIndex ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 3 , -5 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minIndex ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPrevGreater ( int arr [ ] , int n ) { if ( n == 1 ) { cout << " - 1" ; return ; } vector < int > v ( arr , arr + n ) ; sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { auto it = upper_bound ( v . begin ( ) , v . end ( ) , arr [ i ] ) ; if ( ( it - 1 ) != v . begin ( ) && * ( it - 2 ) == arr [ i ] ) { cout << arr [ i ] << " ▁ " ; } else if ( it != v . end ( ) ) cout << * it << " ▁ " ; else cout << -1 << " ▁ " ; } } int main ( ) { int arr [ ] = { 10 , 5 , 11 , 10 , 20 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPrevGreater ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 5 ; void diagonalsMinMax ( int mat [ n ] [ n ] ) { if ( n == 0 ) return ; int principalMin = mat [ 0 ] [ 0 ] , principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] , secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ i ] [ i ] < principalMin ) { principalMin = mat [ i ] [ i ] ; } if ( mat [ i ] [ i ] > principalMax ) { principalMax = mat [ i ] [ i ] ; } if ( mat [ n - 1 - i ] [ i ] < secondaryMin ) { secondaryMin = mat [ n - 1 - i ] [ i ] ; } if ( mat [ n - 1 - i ] [ i ] > secondaryMax ) { secondaryMax = mat [ n - 1 - i ] [ i ] ; } } cout << " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " << principalMin << " STRNEWLINE " ; cout << " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " << principalMax << " STRNEWLINE " ; cout << " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " << secondaryMin << " STRNEWLINE " ; cout << " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " << secondaryMax ; } int main ( ) { int matrix [ n ] [ n ] = { { 1 , 2 , 3 , 4 , -10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , -5 } } ; diagonalsMinMax ( matrix ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkSorted ( int n , int arr [ ] ) { int first = 0 , second = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { count ++ ; if ( first == 0 ) first = i ; else second = i ; } } if ( count > 2 ) return false ; if ( count == 0 ) return true ; if ( count == 2 ) swap ( arr [ first - 1 ] , arr [ second ] ) ; else if ( count == 1 ) swap ( arr [ first - 1 ] , arr [ first ] ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] < arr [ i - 1 ] ) return false ; return true ; } int main ( ) { int arr [ ] = { 1 , 4 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkSorted ( n , arr ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE #define M  4 NEW_LINE using namespace std ; void printIntersection ( int A [ ] [ N ] , int B [ ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) cout << A [ i ] [ j ] << " ▁ " ; else cout << " * ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int A [ M ] [ N ] = { { 2 , 4 , 6 , 8 } , { 1 , 3 , 5 , 7 } , { 8 , 6 , 4 , 2 } , { 7 , 5 , 3 , 1 } } ; int B [ M ] [ N ] = { { 2 , 3 , 6 , 8 } , { 1 , 3 , 5 , 2 } , { 8 , 1 , 4 , 2 } , { 3 , 5 , 4 , 1 } } ; printIntersection ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int arr [ ] , int n ) { int max_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) max_val = max ( max_val , arr [ i ] ) ; int freq [ max_val + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ; for ( int i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ; for ( int i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ; for ( int i = 1 ; i <= max_val ; i ++ ) { for ( int j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << ( countWays ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int A1 [ ] , int A2 [ ] , int n1 , int n2 , int K ) { int res = 0 ; unordered_map < int , int > m ; for ( int i = 0 ; i < n1 ; ++ i ) m [ A1 [ i ] ] ++ ; for ( int i = 0 ; i < n2 ; ++ i ) { int temp = K - A2 [ i ] ; if ( m [ temp ] != 0 ) { res ++ ; m [ temp ] -- ; } } return res ; } int main ( ) { int A1 [ ] = { 1 , 1 , 3 , 4 , 5 , 6 , 6 } ; int A2 [ ] = { 1 , 4 , 4 , 5 , 7 } , K = 10 ; int n1 = sizeof ( A1 ) / sizeof ( A1 [ 0 ] ) ; int n2 = sizeof ( A2 ) / sizeof ( A2 [ 0 ] ) ; cout << countPairs ( A1 , A2 , n1 , n2 , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOrderedPairs ( int A [ ] , int n ) { int orderedPairs = 0 ; unordered_map < int , int > m ; for ( int i = 0 ; i < n ; ++ i ) m [ A [ i ] ] ++ ; for ( auto entry : m ) { int X = entry . first ; int Y = entry . second ; for ( int j = 1 ; j <= Y ; j ++ ) { if ( m [ j ] >= X ) orderedPairs ++ ; } } return orderedPairs ; } int main ( ) { int A [ ] = { 1 , 1 , 2 , 2 , 3 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << countOrderedPairs ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return max ( max_length , count ) ; } int main ( ) { int arr [ ] = { 4 , 9 , 7 , 18 , 29 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 11 ; cout << LongestSubarray ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  3 NEW_LINE #define N  4 NEW_LINE bool binarySearch1D ( int arr [ ] , int K ) { int low = 0 ; int high = N - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == K ) return true ; if ( arr [ mid ] < K ) low = mid + 1 ; else high = mid - 1 ; } return false ; } bool searchMatrix ( int matrix [ M ] [ N ] , int K ) { int low = 0 ; int high = M - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( K >= matrix [ mid ] [ 0 ] && K <= matrix [ mid ] [ N - 1 ] ) return binarySearch1D ( matrix [ mid ] , K ) ; if ( K < matrix [ mid ] [ 0 ] ) high = mid - 1 ; else low = mid + 1 ; } return false ; } int main ( ) { int matrix [ M ] [ N ] = { { 1 , 3 , 5 , 7 } , { 10 , 11 , 16 , 20 } , { 23 , 30 , 34 , 50 } } ; int K = 3 ; if ( searchMatrix ( matrix , K ) ) cout << " Found " << endl ; else cout << " Not ▁ found " << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int divTermCount ( int a , int b , int lcm , int num ) { return num / a + num / b - num / lcm ; } int findNthTerm ( int a , int b , int n ) { int low = 1 , high = INT_MAX , mid ; int lcm = ( a * b ) / gcd ( a , b ) ; while ( low < high ) { mid = low + ( high - low ) / 2 ; if ( divTermCount ( a , b , lcm , mid ) < n ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { int a = 2 , b = 5 , n = 10 ; cout << findNthTerm ( a , b , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } bool check_pair_product ( struct Node * head , int prod ) { unordered_set < int > s ; struct Node * p = head ; while ( p != NULL ) { int curr = p -> data ; if ( ( prod % curr == 0 ) && ( s . find ( prod / curr ) != s . end ( ) ) ) { cout << curr << " ▁ " << prod / curr ; return true ; } s . insert ( p -> data ) ; p = p -> next ; } return false ; } int main ( ) { struct Node * head = NULL ; push ( & head , 1 ) ; push ( & head , 2 ) ; push ( & head , 1 ) ; push ( & head , 12 ) ; push ( & head , 1 ) ; push ( & head , 18 ) ; push ( & head , 47 ) ; push ( & head , 16 ) ; push ( & head , 12 ) ; push ( & head , 14 ) ; bool res = check_pair_product ( head , 24 ) ; if ( res == false ) cout << " NO ▁ PAIR ▁ EXIST " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; if ( k == 1 && arr [ n - 2 ] != arr [ n - 1 ] ) { cout << arr [ n - 1 ] << endl ; return ; } int count = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) count ++ ; else count = 1 ; if ( count == k && ( i == 0 || ( arr [ i - 1 ] != arr [ i ] ) ) ) { cout << arr [ i ] << endl ; return ; } } cout << " No ▁ such ▁ element " << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 } ; int k = 2 ; int n = sizeof ( arr ) / sizeof ( int ) ; solve ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int arr [ ] , int n , int k ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } int max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( m [ arr [ i ] ] == k && max == INT_MIN ) { max = arr [ i ] ; } else if ( m [ arr [ i ] ] == k && max < arr [ i ] ) { max = arr [ i ] ; } } if ( max == INT_MIN ) cout << " No ▁ such ▁ element " << endl ; else cout << max << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( int ) ; solve ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEle ( stack < int > & s , int a [ ] , int N ) { unordered_map < int , bool > mp ; for ( int i = 0 ; i < N ; ++ i ) { int num = a [ i ] ; if ( mp . find ( num ) != mp . end ( ) ) cout << "0 ▁ " ; else { int cnt = 0 ; while ( s . top ( ) != num ) { mp [ s . top ( ) ] = true ; s . pop ( ) ; cnt ++ ; } s . pop ( ) ; cnt ++ ; cout << cnt << " ▁ " ; } } } int main ( ) { int N = 5 ; stack < int > s ; s . push ( 1 ) ; s . push ( 2 ) ; s . push ( 3 ) ; s . push ( 4 ) ; s . push ( 6 ) ; int a [ ] = { 6 , 3 , 4 , 1 , 2 } ; countEle ( s , a , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  6 NEW_LINE set < int > Tree [ 6 * N ] ; void buildTree ( int * arr , int idx , int s , int e ) { if ( s == e ) { Tree [ idx ] . insert ( arr [ s ] ) ; return ; } int mid = ( s + e ) >> 1 ; buildTree ( arr , 2 * idx , s , mid ) ; buildTree ( arr , 2 * idx + 1 , mid + 1 , e ) ; for ( auto it : Tree [ 2 * idx ] ) { Tree [ idx ] . insert ( it ) ; } for ( auto it : Tree [ 2 * idx + 1 ] ) { Tree [ idx ] . insert ( it ) ; } } bool query ( int idx , int s , int e , int qs , int qe , int x ) { if ( qs <= s && e <= qe ) { if ( Tree [ idx ] . count ( x ) != 0 ) { return true ; } else return false ; } if ( qe < s e < qs ) { return false ; } int mid = ( s + e ) >> 1 ; bool LeftAns = query ( 2 * idx , s , mid , qs , qe , x ) ; bool RightAns = query ( 2 * idx + 1 , mid + 1 , e , qs , qe , x ) ; return LeftAns or RightAns ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 9 , 8 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; buildTree ( arr , 1 , 0 , n - 1 ) ; int l , r , x ; l = 0 , r = 3 , x = 2 ; if ( query ( 1 , 0 , n - 1 , l , r , x ) ) cout << " YES " << ' ' ; else cout << " NO " << ' ' ; l = 2 , r = 5 , x = 3 ; if ( query ( 1 , 0 , n - 1 , l , r , x ) ) cout << " YES " << ' ' ; else cout << " NO " << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countChar ( string str ) { int n = str . length ( ) ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; } int main ( ) { string str = " egeeksk " ; cout << countChar ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int next ( int arr [ ] , int target , int end ) { if ( end == 0 ) return -1 ; if ( target > arr [ end - 1 ] ) return end - 1 ; int start = 0 ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] >= target ) { end = mid - 1 ; } else { ans = mid ; start = mid + 1 ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( next ( arr , 5 , n ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int next ( int arr [ ] , int target , int end ) { int start = 0 ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) start = mid + 1 ; else { ans = mid ; end = mid - 1 ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << next ( arr , 8 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int find ( long long int n , long long int k ) { long long int sum = 0 , i ; for ( i = 2 ; i <= n ; i ++ ) sum = ( sum + k ) % i ; return sum + 1 ; } int main ( ) { int n = 14 , k = 2 ; cout << find ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool search ( int arr [ ] , int n , int x ) { int res = -1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == -1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; } int main ( ) { int arr [ ] = { 12 , 25 , 36 , 85 , 98 , 75 , 89 , 15 , 63 , 66 , 64 , 74 , 27 , 83 , 97 } ; int q [ ] = { 63 , 63 , 86 , 63 , 78 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; for ( int i = 0 ; i < m ; i ++ ) search ( arr , n , q [ i ] ) ? cout << " Yes ▁ " : cout << " No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float kPresentProbability ( int a [ ] , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; } int main ( ) { int A [ ] = { 4 , 7 , 2 , 0 , 8 , 7 , 5 } ; int K = 3 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << kPresentProbability ( A , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int slopeOfNum ( string num , int n ) { int slope = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ; else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; } return slope ; } int main ( ) { string num = "1213321" ; int n = num . size ( ) ; cout << " Slope ▁ = ▁ " << slopeOfNum ( num , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool pairExists ( int arr1 [ ] , int m , int arr2 [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( s . find ( arr2 [ j ] - arr1 [ i ] ) != s . end ( ) ) return true ; } s . insert ( arr1 [ i ] ) ; } return false ; } int main ( ) { int arr1 [ ] = { 1 , 5 , 10 , 8 } ; int arr2 [ ] = { 2 , 20 , 13 } ; if ( pairExists ( arr1 , 4 , arr2 , 3 ) ) cout << 1 << endl ; else cout << 0 << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void prevGreater ( int arr [ ] , int n ) { cout << " - 1 , ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { cout << arr [ j ] << " , ▁ " ; break ; } } if ( j == -1 ) cout << " - 1 , ▁ " ; } } int main ( ) { int arr [ ] = { 10 , 4 , 2 , 20 , 40 , 12 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; prevGreater ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void prevGreater ( int arr [ ] , int n ) { stack < int > s ; s . push ( arr [ 0 ] ) ; cout << " - 1 , ▁ " ; for ( int i = 1 ; i < n ; i ++ ) { while ( s . empty ( ) == false && s . top ( ) < arr [ i ] ) s . pop ( ) ; s . empty ( ) ? cout << " - 1 , ▁ " : cout << s . top ( ) << " , ▁ " ; s . push ( arr [ i ] ) ; } } int main ( ) { int arr [ ] = { 10 , 4 , 2 , 20 , 40 , 12 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; prevGreater ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printDuplicates ( int arr [ ] , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { cout << arr [ i ] % n << " ▁ " ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) cout << " - 1" ; } int main ( ) { int arr [ ] = { 1 , 6 , 3 , 1 , 3 , 6 , 6 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printDuplicates ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMissingNo ( int arr [ ] , int n ) { int val ; int nextval ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= 0 arr [ i ] > n ) continue ; val = arr [ i ] ; while ( arr [ val - 1 ] != val ) { nextval = arr [ val - 1 ] ; arr [ val - 1 ] = val ; val = nextval ; if ( val <= 0 val > n ) break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } } return n + 1 ; } int main ( ) { int arr [ ] = { 2 , 3 , 7 , 6 , 8 , -1 , -10 , 15 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int missing = findMissingNo ( arr , arr_size ) ; cout << " The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ " << missing ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { cout << arr [ i ] << " ▁ " << arr [ j ] << " ▁ " << arr [ k ] << endl ; } } } } } int main ( ) { int arr [ ] = { 0 , -1 , 2 , -3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTriplets ( arr , n , -2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { unordered_set < int > s ; for ( int j = i + 1 ; j < n ; j ++ ) { int x = sum - ( arr [ i ] + arr [ j ] ) ; if ( s . find ( x ) != s . end ( ) ) printf ( " % d ▁ % d ▁ % d STRNEWLINE " , x , arr [ i ] , arr [ j ] ) ; else s . insert ( arr [ j ] ) ; } } } int main ( ) { int arr [ ] = { 0 , -1 , 2 , -3 , 1 } ; int sum = -2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTriplets ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return -1 ; int max_product = INT_MIN ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; } int main ( ) { int arr [ ] = { 10 , 3 , 5 , 6 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Quadruple ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return -1 ; sort ( arr , arr + n ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return max ( x , max ( y , z ) ) ; } int main ( ) { int arr [ ] = { -10 , -3 , 5 , 6 , -20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Quadruple ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n ) { if ( n < 2 ) return -1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 12 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int costToBalance ( string s ) { if ( s . length ( ) == 0 ) cout << 0 << endl ; int ans = 0 ; int o = 0 , c = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) o ++ ; if ( s [ i ] == ' ) ' ) c ++ ; } if ( o != c ) return -1 ; int a [ s . size ( ) ] ; if ( s [ 0 ] == ' ( ' ) a [ 0 ] = 1 ; else a [ 0 ] = -1 ; if ( a [ 0 ] < 0 ) ans += abs ( a [ 0 ] ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' ( ' ) a [ i ] = a [ i - 1 ] + 1 ; else a [ i ] = a [ i - 1 ] - 1 ; if ( a [ i ] < 0 ) ans += abs ( a [ i ] ) ; } return ans ; } int main ( ) { string s ; s = " ) ) ) ( ( ( " ; cout << costToBalance ( s ) << endl ; s = " ) ) ( ( " ; cout << costToBalance ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int f ( int n ) { return n * ( 2 * n * n - 1 ) ; } bool binarySearch ( int low , int high , int x ) { while ( low <= high ) { long long mid = ( low + high ) / 2 ; if ( f ( mid ) < x ) low = mid + 1 ; else if ( f ( mid ) > x ) high = mid - 1 ; else return true ; } return false ; } bool isStellaOctangula ( int x ) { if ( x == 0 ) return true ; int i = 1 ; while ( f ( i ) < x ) i = i * 2 ; if ( f ( i ) == x ) return true ; return binarySearch ( i / 2 , i , x ) ; } int main ( ) { int n = 51 ; if ( isStellaOctangula ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; string sortString ( string str , int n ) { int i ; char arr [ 26 ] = { 0 } ; string new_str = " " ; for ( i = 0 ; i < n ; i ++ ) ++ arr [ str [ i ] - ' a ' ] ; for ( i = 0 ; i < 26 ; i ++ ) while ( arr [ i ] -- ) new_str += i + ' a ' ; return new_str ; } int main ( ) { string str = " geeksforgeeks " ; int n = str . size ( ) ; cout << sortString ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { char data ; struct Node * next ; } ; char maxChar ( struct Node * head ) { struct Node * p = head ; int hash [ 256 ] = { 0 } ; while ( p != NULL ) { hash [ p -> data ] ++ ; p = p -> next ; } p = head ; int max = -1 ; char res ; while ( p != NULL ) { if ( max < hash [ p -> data ] ) { res = p -> data ; max = hash [ p -> data ] ; } p = p -> next ; } return res ; } void push ( struct Node * * head_ref , char new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * head = NULL ; char str [ ] = " skeegforskeeg " ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) push ( & head , str [ i ] ) ; cout << maxChar ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ; int getGreatestSum ( int a [ ] [ N ] ) { int prev_max = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ; int sum = prev_max ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int curr_max = INT_MIN ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ; if ( curr_max == INT_MIN ) return -1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; } int main ( ) { int a [ 3 ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; cout << getGreatestSum ( a ) << endl ; int b [ 3 ] [ 3 ] = { { 4 , 5 , 6 } , { 4 , 5 , 6 } , { 4 , 5 , 6 } } ; cout << getGreatestSum ( b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElement ( int n , int k ) { int left = 1 ; int right = pow ( 2 , n ) - 1 ; while ( 1 ) { int mid = ( left + right ) / 2 ; if ( k == mid ) { cout << ans << endl ; break ; } ans -- ; if ( k < mid ) right = mid - 1 ; else left = mid + 1 ; } } int main ( ) { int n = 4 , k = 8 ; findElement ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int firstCommon ( struct Node * head1 , struct Node * head2 ) { for ( ; head1 != NULL ; head1 = head1 -> next ) for ( Node * p = head2 ; p != NULL ; p = p -> next ) if ( p -> data == head1 -> data ) return head1 -> data ; return 0 ; } int main ( ) { struct Node * head1 = NULL ; push ( & head1 , 20 ) ; push ( & head1 , 5 ) ; push ( & head1 , 15 ) ; push ( & head1 , 10 ) ; struct Node * head2 = NULL ; push ( & head2 , 10 ) ; push ( & head2 , 2 ) ; push ( & head2 , 15 ) ; push ( & head2 , 8 ) ; cout << firstCommon ( head1 , head2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkBit ( int pattern , int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; } int maxAND ( int arr [ ] , int n ) { int res = 0 , count ; for ( int bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } if ( res == 0 ) cout << " Not ▁ Possible STRNEWLINE " ; else { cout << " Pair ▁ = ▁ " ; count = 0 ; for ( int i = 0 ; i < n && count < 2 ; i ++ ) { if ( ( arr [ i ] & res ) == res ) { count ++ ; cout << arr [ i ] << " ▁ " ; } } } return res ; } int main ( ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum AND Value = " << maxAND ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMaxSumPairs ( int a [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } int cnt1 = 0 , cnt2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == first ) if ( a [ i ] == second ) } if ( cnt1 == 1 ) return cnt2 ; if ( cnt1 > 1 ) return cnt1 * ( cnt1 - 1 ) / 2 ; } float findMaxSumProbability ( int a [ ] , int n ) { int total = n * ( n - 1 ) / 2 ; int max_sum_pairs = countMaxSumPairs ( a , n ) ; return ( float ) max_sum_pairs / ( float ) total ; } int main ( ) { int a [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findMaxSumProbability ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int middleOfThree ( int a , int b , int c ) { int x = a - b ; int y = b - c ; int z = a - c ; if ( x * y > 0 ) return b ; else if ( x * z > 0 ) return c ; else return a ; } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }
int sum [ n + 1 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i - 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ 1 ] [ i ] = sum [ i ] ; and using it to calculate the result as : best = min ( best , max ( dp [ i - 1 ] [ p ] , sum [ j ] - sum [ p ] ) ) ;
for ( int i = k - 1 ; i <= n ; i ++ ) best = min ( best , max ( partition ( arr , i , k - 1 ) , sum ( arr , i , n - 1 ) ) ) ;
#include <iostream> NEW_LINE using namespace std ; int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return -1 ; } int main ( ) { int s = 15 ; int n = findS ( s ) ; n == -1 ? cout << " - 1" : cout << n ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE # define ll  long long NEW_LINE using namespace std ; ll int isvalid ( ll int s ) { float k = ( -1 + sqrt ( 1 + 8 * s ) ) / 2 ; if ( ceil ( k ) == floor ( k ) ) return k ; else return -1 ; } int main ( ) { int s = 15 ; cout << isvalid ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) ; int dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) ; int dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) ; int dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; } int main ( ) { int pos = 34 ; cout << " Safe ▁ Positions ▁ = ▁ " << calcSafe ( pos ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void merge ( int arr [ ] , int l , int m , int r , int * count_crossline ) { int i , j , k ; int n1 = m - l + 1 ; int n2 = r - m ; int L [ n1 ] , R [ n2 ] ; for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = arr [ l + i ] ; for ( j = 0 ; j < n2 ; j ++ ) R [ j ] = arr [ m + 1 + j ] ; while ( i < n1 && j < n2 ) { if ( L [ i ] <= R [ j ] ) { arr [ k ] = L [ i ] ; i ++ ; } else { arr [ k ] = R [ j ] ; * count_crossline += ( n1 - i ) ; j ++ ; } k ++ ; } while ( i < n1 ) { arr [ k ] = L [ i ] ; i ++ ; k ++ ; } while ( j < n2 ) { arr [ k ] = R [ j ] ; j ++ ; k ++ ; } } void mergeSort ( int arr [ ] , int l , int r , int * count_crossline ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; mergeSort ( arr , l , m , count_crossline ) ; mergeSort ( arr , m + 1 , r , count_crossline ) ; merge ( arr , l , m , r , count_crossline ) ; } } int countCrossLine ( int arr [ ] , int n ) { int count_crossline = 0 ; mergeSort ( arr , 0 , n - 1 , & count_crossline ) ; return count_crossline ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countCrossLine ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void missing4 ( int arr [ ] , int n ) { int helper [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { int temp = abs ( arr [ i ] ) ; if ( temp <= n ) arr [ temp - 1 ] *= ( -1 ) ; else if ( temp > n ) { if ( temp % n != 0 ) helper [ temp % n - 1 ] = -1 ; else helper [ ( temp % n ) + n - 1 ] = -1 ; } } for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) cout << ( i + 1 ) << " ▁ " ; for ( int i = 0 ; i < 4 ; i ++ ) if ( helper [ i ] >= 0 ) cout << ( n + i + 1 ) << " ▁ " ; return ; } int main ( ) { int arr [ ] = { 1 , 7 , 3 , 12 , 5 , 10 , 8 , 4 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; missing4 ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int arr [ ] , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; } int main ( ) { int arr [ ] = { 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int num1 = 5 , num2 = 4 ; cout << getCount ( arr , n , num1 , num2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ROW  3 NEW_LINE #define COL  5 NEW_LINE int minTotalDistance ( int grid [ ] [ COL ] ) { if ( ROW == 0 COL == 0 ) return 0 ; vector < int > vertical ; vector < int > horizontal ; for ( int i = 0 ; i < ROW ; i ++ ) { for ( int j = 0 ; j < COL ; j ++ ) { if ( grid [ i ] [ j ] == 1 ) { vertical . push_back ( i ) ; horizontal . push_back ( j ) ; } } } sort ( vertical . begin ( ) , vertical . end ( ) ) ; sort ( horizontal . begin ( ) , horizontal . end ( ) ) ; int size = vertical . size ( ) / 2 ; int x = vertical [ size ] ; int y = horizontal [ size ] ; int distance = 0 ; for ( int i = 0 ; i < ROW ; i ++ ) for ( int j = 0 ; j < COL ; j ++ ) if ( grid [ i ] [ j ] == 1 ) distance += abs ( x - i ) + abs ( y - j ) ; return distance ; } int main ( ) { int grid [ ROW ] [ COL ] = { { 1 , 0 , 1 , 0 , 1 } , { 0 , 1 , 0 , 0 , 0 } , { 0 , 1 , 1 , 0 , 0 } } ; cout << minTotalDistance ( grid ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigit ( int K ) { int sod = 0 ; while ( K ) { sod += K % 10 ; K /= 10 ; } return sod ; } int totalNumbersWithSpecificDifference ( int N , int diff ) { int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ; else high = mid - 1 ; } return ( N - high ) ; } int main ( ) { int N = 13 ; int diff = 2 ; cout << totalNumbersWithSpecificDifference ( N , diff ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countBuildings ( int arr [ ] , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; } int main ( ) { int arr [ ] = { 7 , 4 , 8 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countBuildings ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; } int main ( ) { int arr1 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 13 } ; int arr2 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 } ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << findExtra ( arr1 , arr2 , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; } int main ( ) { int arr1 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 13 } ; int arr2 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 } ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << findExtra ( arr1 , arr2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int computeCost ( int arr [ ] , int N , int X ) { int cost = 0 ; for ( int i = 0 ; i < N ; i ++ ) cost += abs ( arr [ i ] - X ) ; return cost ; } int minCostToMakeElementEqual ( int arr [ ] , int N ) { int low , high ; low = high = arr [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( low > arr [ i ] ) low = arr [ i ] ; if ( high < arr [ i ] ) high = arr [ i ] ; } while ( ( high - low ) > 2 ) { int mid1 = low + ( high - low ) / 3 ; int mid2 = high - ( high - low ) / 3 ; int cost1 = computeCost ( arr , N , mid1 ) ; int cost2 = computeCost ( arr , N , mid2 ) ; if ( cost1 < cost2 ) high = mid2 ; else low = mid1 ; } return computeCost ( arr , N , ( low + high ) / 2 ) ; } int main ( ) { int arr [ ] = { 1 , 100 , 101 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << minCostToMakeElementEqual ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minJumps ( int w [ ] , int l [ ] , int n ) { if ( n == 1 ) { cout << 0 ; return ; } int ans = 0 ; unordered_map < int , int > pos , jump ; unordered_map < int , bool > filled ; int a [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { pos [ w [ i ] ] = i ; filled [ i ] = true ; jump [ w [ i ] ] = l [ i ] ; a [ i ] = w [ i ] ; } sort ( a , a + n ) ; for ( int curr = 1 ; curr < n ; curr ++ ) { int currElementPos = pos [ a [ curr ] ] ; int prevElementPos = pos [ a [ curr - 1 ] ] ; if ( currElementPos > prevElementPos ) continue ; while ( currElementPos <= prevElementPos filled [ currElementPos ] ) { currElementPos += jump [ a [ curr ] ] ; ans ++ ; } pos [ a [ curr ] ] = currElementPos ; filled [ currElementPos ] = true ; } cout << ans ; } int main ( ) { int W [ ] = { 2 , 1 , 4 , 3 } ; int L [ ] = { 4 , 1 , 2 , 4 } ; int N = sizeof ( W ) / sizeof ( W [ 0 ] ) ; minJumps ( W , L , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( int arr [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] >= ( i - 1 ) ) { int p = arr [ i - 1 ] - ( i - 1 ) ; arr [ i ] += p ; arr [ i - 1 ] -= p ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= arr [ i - 1 ] ) { cout << " No " ; return ; } } cout << " Yes " ; } int main ( ) { int arr [ ] = { 1 , 5 , 2 , 7 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; check ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int keyFunc ( int n ) { int rev = 0 ; while ( n > 0 ) { rev = rev << 1 ; if ( n & 1 == 1 ) rev = rev ^ 1 ; n = n >> 1 ; } return rev ; } vector < vector < int > > getNew ( vector < int > arr ) { vector < vector < int > > ans ; for ( int i : arr ) ans . push_back ( { keyFunc ( i ) , i } ) ; return ans ; } vector < int > getArr ( vector < vector < int > > arr ) { vector < int > ans ; for ( auto i : arr ) ans . push_back ( i [ 1 ] ) ; return ans ; } void sortArray ( vector < int > arr ) { vector < vector < int > > newArr = getNew ( arr ) ; sort ( newArr . begin ( ) , newArr . end ( ) ) ; arr = getArr ( newArr ) ; int n = arr . size ( ) ; cout << " [ " ; for ( int i = 0 ; i < n - 1 ; i ++ ) cout << arr [ i ] << " , ▁ " ; cout << arr [ n - 1 ] << " ] " ; } int main ( ) { vector < int > arr = { 43 , 52 , 61 , 41 } ; sortArray ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumSize ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; reverse ( arr , arr + N ) ; if ( count ( arr , arr + N , 0 ) == N ) cout << 0 ; else if ( K >= N ) cout << 1 << endl ; else cout << arr [ K ] << endl ; } int main ( ) { int arr [ ] = { 2 , 4 , 8 , 2 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumSize ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isPossibleToSort ( int arr [ ] , int N ) { int idx = -1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == 1 && arr [ i - 1 ] == 1 ) { idx = i ; break ; } } if ( idx == -1 ) { cout << " YES " ; return ; } for ( int i = idx + 1 ; i < N ; i ++ ) { if ( arr [ i ] == 0 && arr [ i - 1 ] == 0 ) { cout << " NO " ; return ; } } cout << " YES " ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isPossibleToSort ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxConsecutiveRopes ( int ropes [ ] , int N ) { int curSize = 0 ; sort ( ropes , ropes + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ropes [ i ] <= curSize + 1 ) { curSize = curSize + ropes [ i ] ; } else break ; } return curSize ; } int main ( ) { int N = 5 ; int ropes [ ] = { 1 , 2 , 7 , 1 , 1 } ; cout << maxConsecutiveRopes ( ropes , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxRanges ( vector < vector < int > > arr , int N ) { sort ( arr . begin ( ) , arr . end ( ) ) ; int count = 1 ; vector < int > prev = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { vector < int > last = arr [ i - 1 ] ; vector < int > current = arr [ i ] ; if ( last [ 0 ] == current [ 0 ] && last [ 1 ] == current [ 1 ] && current [ 1 ] == current [ 0 ] ) continue ; int start = max ( prev [ 0 ] , current [ 0 ] - 1 ) ; int end = max ( prev [ 1 ] , current [ 1 ] ) ; if ( end - start > 0 ) { prev [ 0 ] = 1 + start ; prev [ 1 ] = end ; count ++ ; } } return count ; } int main ( ) { vector < vector < int > > range = { { 1 , 4 } , { 4 , 4 } , { 2 , 2 } , { 3 , 4 } , { 1 , 1 } } ; int N = range . size ( ) ; cout << maxRanges ( range , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool adjust ( string & S , int & i , int & start , int & end ) { int N = S . length ( ) ; start = i - 1 ; while ( i < N && S [ i ] < S [ i - 1 ] ) { i ++ ; } end = i - 1 ; if ( start <= 0 && i >= N ) return true ; if ( start >= 1 && i <= N ) { return ( S [ end ] >= S [ start - 1 ] && S [ start ] <= S [ i ] ) ; } if ( start >= 1 ) { return S [ end ] >= S [ start - 1 ] ; } if ( i < N ) { return S [ start ] <= S [ i ] ; } return false ; } void isPossible ( string & S , int N ) { int start = -1 , end = -1 ; bool flag = true ; for ( int i = 1 ; i < N ; i ++ ) { if ( S [ i ] < S [ i - 1 ] ) { if ( flag ) { if ( adjust ( S , i , start , end ) == false ) { cout << -1 << endl ; return ; } flag = false ; } else { cout << -1 << endl ; return ; } } } if ( start == -1 ) { start = end = 1 ; } cout << start << " ▁ " << end << " STRNEWLINE " ; } int main ( ) { string S = " abcyxuz " ; int N = S . length ( ) ; isPossible ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximizedCapital ( int K , int W , vector < int > & profits , vector < int > & capital ) { priority_queue < int > pq ; vector < pair < int , int > > v ; for ( int i = 0 ; i < capital . size ( ) ; i ++ ) { v . push_back ( { capital [ i ] , i } ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int j = 0 ; while ( K ) { while ( j < ( int ) capital . size ( ) && v [ j ] . first <= W ) { pq . push ( profits [ v [ j ] . second ] ) ; j ++ ; } if ( ! pq . empty ( ) ) { W = W + pq . top ( ) ; pq . pop ( ) ; } K -- ; } return W ; } int main ( ) { int K = 2 ; int W = 0 ; vector < int > P = { 1 , 2 , 3 } ; vector < int > C = { 0 , 1 , 1 } ; cout << maximizedCapital ( K , W , P , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSum ( int arr [ ] , int S [ ] , int N , int K ) { int ans = 0 ; sort ( arr , arr + N , greater < int > ( ) ) ; for ( int i = 0 ; i < K ; i ++ ) ans += arr [ i ] ; sort ( S , S + K ) ; for ( int i = 0 ; i < K ; i ++ ) { if ( S [ i ] == 1 ) ans += arr [ i ] ; S [ i ] -- ; } int counter = K - 1 ; for ( int i = 0 ; i < K ; i ++ ) { counter = counter + S [ i ] ; if ( S [ i ] != 0 ) ans += arr [ counter ] ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 13 , 7 , 17 } ; int S [ ] = { 1 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = sizeof ( S ) / sizeof ( S [ 0 ] ) ; cout << maximumSum ( arr , S , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binaryToDecimal ( string n ) { string num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; } string decimalToBinary ( int n ) { string binstr = " " ; while ( n > 0 ) { binstr += ( n % 2 + 48 ) ; n = n / 2 ; } return binstr ; } int reversedBinaryDecimal ( int N ) { string decimal_to_binar = decimalToBinary ( N ) ; int binary_to_decimal = binaryToDecimal ( decimal_to_binar ) ; return binary_to_decimal ; } void printSortedArray ( int arr [ ] , int size ) { sort ( arr , arr + size ) ; for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } void modifyArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { arr [ i ] = reversedBinaryDecimal ( arr [ i ] ) ; } printSortedArray ( arr , size ) ; } int main ( ) { int arr [ ] = { 98 , 43 , 66 , 83 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; modifyArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSortedArray ( int arr [ ] , int n ) { int l = 0 , r = ( n - 1 ) ; while ( ( l + 1 ) < r ) { if ( arr [ l ] >= max ( arr [ l + 1 ] , arr [ r - 1 ] ) && arr [ r ] >= max ( arr [ r - 1 ] , arr [ l + 1 ] ) ) { l ++ ; r -- ; } else { return false ; } } return true ; } int main ( ) { int arr [ ] = { 4 , 3 , 1 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSortedArray ( arr , N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int N , int X [ ] , int Y [ ] ) { vector < pair < int , int > > p ; for ( int i = 0 ; i < N ; i ++ ) { p . push_back ( { X [ i ] , Y [ i ] } ) ; } sort ( p . begin ( ) , p . end ( ) ) ; set < int , greater < int > > s ; s . insert ( p [ 0 ] . second ) ; for ( int i = 0 ; i < N ; i ++ ) { auto it = s . lower_bound ( p [ i ] . second ) ; if ( it == s . end ( ) ) { s . insert ( p [ i ] . second ) ; } else { s . erase ( * it ) ; s . insert ( p [ i ] . second ) ; } } return s . size ( ) ; } int main ( ) { int N = 3 ; int X [ ] = { 1 , 2 , 0 } ; int Y [ ] = { 2 , 0 , 1 } ; int maxintersection = solve ( N , X , Y ) ; cout << maxintersection ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canReduceArray ( int arr [ ] , int N , int K ) { sort ( arr , arr + N , greater < int > ( ) ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] - arr [ i + 1 ] > K ) { cout << " No " ; return ; } } cout << " Yes " ; } int main ( ) { int arr [ ] = { 2 , 1 , 1 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 1 ; canReduceArray ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mergeStrings ( string s1 , string s2 ) { int len1 = s1 . size ( ) ; int len2 = s2 . size ( ) ; int pntr1 = 0 ; int pntr2 = 0 ; string ans = " " ; while ( pntr1 < len1 && pntr2 < len2 ) { if ( s1 [ pntr1 ] < s2 [ pntr2 ] ) { ans += s1 [ pntr1 ] ; pntr1 ++ ; } else { ans += s2 [ pntr2 ] ; pntr2 ++ ; } } if ( pntr1 < len1 ) { ans += s1 . substr ( pntr1 , len1 ) ; } if ( pntr2 < len2 ) { ans += s2 . substr ( pntr2 , len2 ) ; } cout << ans ; } int main ( ) { string S1 = " abdcdtx " ; string S2 = " achilp " ; mergeStrings ( S1 , S2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortStr ( string S ) { int N = S . size ( ) ; string temp = " " ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] != ' a ' && S [ i ] != ' e ' && S [ i ] != ' i ' && S [ i ] != ' o ' && S [ i ] != ' u ' ) temp += S [ i ] ; } if ( temp . size ( ) ) sort ( temp . begin ( ) , temp . end ( ) ) ; int ptr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] != ' a ' && S [ i ] != ' e ' && S [ i ] != ' i ' && S [ i ] != ' o ' && S [ i ] != ' u ' ) S [ i ] = temp [ ptr ++ ] ; } cout << S ; } int main ( ) { string S = " geeksforgeeks " ; sortStr ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int high = upper_bound ( arr , arr + n , k * arr [ i ] ) - arr ; ans += high - i - 1 ; } cout << ans ; } int main ( ) { int arr [ ] = { 2 , 3 , 9 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; countPairs ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findXOR ( vector < vector < int > > mat , int K ) { int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; vector < int > digXOR ; for ( int l = 1 ; l <= ( N + M - 1 ) ; l ++ ) { int s_col = max ( 0 , l - N ) ; int count = min ( { l , ( M - s_col ) , N } ) ; int currXOR = 0 ; for ( int j = 0 ; j < count ; j ++ ) { currXOR = ( currXOR ^ mat [ min ( N , l ) - j - 1 ] [ s_col + j ] ) ; } digXOR . push_back ( currXOR ) ; } sort ( digXOR . begin ( ) , digXOR . end ( ) ) ; cout << digXOR [ N + M - 1 - K ] ; } int main ( ) { vector < vector < int > > mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int K = 3 ; findXOR ( mat , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( vector < pair < int , pair < int , int > > > v , int n ) { unordered_map < int , bool > um ; int res = 0 ; int cnt = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( cnt == n ) break ; int x = v [ i ] . second . first ; int y = v [ i ] . second . second ; int xorResult = v [ i ] . first ; if ( um [ x ] == false && um [ y ] == false ) { res += xorResult ; um [ x ] = true ; um [ y ] = true ; cnt += 2 ; } } return res ; } void findMaxMinSum ( int a [ ] , int n ) { vector < pair < int , pair < int , int > > > v ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int xorResult = a [ i ] ^ a [ j ] ; v . push_back ( { xorResult , { a [ i ] , a [ j ] } } ) ; } } sort ( v . begin ( ) , v . end ( ) ) ; int maxi = 0 , mini = 0 ; mini = findSum ( v , n ) ; reverse ( v . begin ( ) , v . end ( ) ) ; maxi = findSum ( v , n ) ; cout << mini << " ▁ " << maxi ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMaxMinSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSumPermutation ( vector < int > & arr ) { int N = arr . size ( ) ; sort ( arr . begin ( ) , arr . end ( ) ) ; swap ( arr [ 0 ] , arr [ N - 1 ] ) ; for ( int i : arr ) { cout << i << " ▁ " ; } } int main ( ) { vector < int > arr = { 1 , 2 , 3 , 4 , 5 } ; maximumSumPermutation ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxNumbers ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int opr = ceil ( log2 ( arr [ i ] ) ) ; k -= opr ; if ( k < 0 ) { break ; } cnt ++ ; } cout << cnt ; } int main ( ) { int arr [ ] = { 5 , 8 , 4 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; findMaxNumbers ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLastElement ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int i = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != 0 && arr [ i ] - arr [ i - 1 ] != 2 ) { cout << " - 1" << endl ; return ; } } cout << arr [ N - 1 ] << endl ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 0 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findLastElement ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxDivisions ( int arr [ ] , int N , int X ) { sort ( arr , arr + N , greater < int > ( ) ) ; int maxSub = 0 ; int size = 0 ; for ( int i = 0 ; i < N ; i ++ ) { size ++ ; if ( arr [ i ] * size >= X ) { maxSub ++ ; size = 0 ; } } cout << maxSub << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 3 ; maxDivisions ( arr , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void meanOfRemainingElements ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int kthPercent = ( N * K ) / 100 ; float sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( i >= kthPercent && i < ( N - kthPercent ) ) sum += arr [ i ] ; float mean = sum / ( N - 2 * kthPercent ) ; cout << fixed << setprecision ( 5 ) << mean << endl ; } int main ( ) { int arr [ ] = { 6 , 2 , 7 , 5 , 1 , 2 , 0 , 3 , 10 , 2 , 5 , 0 , 5 , 5 , 0 , 8 , 7 , 6 , 8 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; meanOfRemainingElements ( arr , arr_size , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxIntersection ( int segments [ ] [ 2 ] , int N ) { vector < int > rvalues ( N ) , lvalues ( N ) ; for ( int i = 0 ; i < N ; ++ i ) { lvalues [ i ] = segments [ i ] [ 0 ] ; rvalues [ i ] = segments [ i ] [ 1 ] ; } sort ( lvalues . begin ( ) , lvalues . end ( ) ) ; sort ( rvalues . begin ( ) , rvalues . end ( ) ) ; pair < int , int > answer = { -1 , -1 } ; int numIntersections = 0 ; for ( int i = 0 ; i < N ; ++ i ) { int lesser = lower_bound ( rvalues . begin ( ) , rvalues . end ( ) , segments [ i ] [ 0 ] ) - rvalues . begin ( ) ; int greater = max ( 0 , N - ( int ) ( upper_bound ( lvalues . begin ( ) , lvalues . end ( ) , segments [ i ] [ 1 ] ) - lvalues . begin ( ) ) ) ; if ( ( N - lesser - greater ) >= numIntersections ) { answer = { segments [ i ] [ 0 ] , segments [ i ] [ 1 ] } ; numIntersections = ( N - lesser - greater ) ; } } cout << answer . first << " ▁ " << answer . second ; } int main ( ) { int segments [ ] [ 2 ] = { { 1 , 4 } , { 2 , 3 } , { 3 , 6 } } ; int N = sizeof ( segments ) / sizeof ( segments [ 0 ] ) ; maxIntersection ( segments , N ) ; }
#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; void maxPossibleSum ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int sum = 0 ; int j = N - 3 ; while ( j >= 0 ) { sum += arr [ j ] ; j -= 3 ; } cout << sum ; } int main ( ) { int arr [ ] = { 7 , 4 , 5 , 2 , 3 , 1 , 5 , 9 } ; int N = 8 ; maxPossibleSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int temp [ 100000 ] ; long int merge ( int A [ ] , int left , int mid , int right ) { long int swaps = 0 ; int i = left , j = mid , k = left ; while ( i < mid && j <= right ) { if ( A [ i ] <= A [ j ] ) { temp [ k ] = A [ i ] ; k ++ , i ++ ; } else { temp [ k ] = A [ j ] ; k ++ , j ++ ; swaps += mid - i ; } } while ( i < mid ) { temp [ k ] = A [ i ] ; k ++ , i ++ ; } while ( j <= right ) { temp [ k ] = A [ j ] ; k ++ , j ++ ; } while ( left <= right ) { A [ left ] = temp [ left ] ; left ++ ; } return swaps ; } long int mergeInsertionSwap ( int A [ ] , int left , int right ) { long int swaps = 0 ; if ( left < right ) { int mid = left + ( right - left ) / 2 ; swaps += mergeInsertionSwap ( A , left , mid ) ; swaps += mergeInsertionSwap ( A , mid + 1 , right ) ; swaps += merge ( A , left , mid + 1 , right ) ; } return swaps ; } int main ( ) { int A [ ] = { 2 , 1 , 3 , 1 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << mergeInsertionSwap ( A , 0 , N - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCntRemovedfromArray ( int arr [ ] , int N , int brr [ ] , int M ) { sort ( arr , arr + N ) ; int i = 0 ; int sumArr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumArr += arr [ i ] ; } int sumBrr = 0 ; for ( int i = 0 ; i < M ; i ++ ) { sumBrr += brr [ i ] ; } int cntRemElem = 0 ; while ( i < N and sumArr > = sumBrr ) { sumArr -= arr [ i ] ; i += 1 ; if ( sumArr >= sumBrr ) { cntRemElem += 1 ; } } return cntRemElem ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 6 } ; int brr [ ] = { 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( brr ) / sizeof ( brr [ 0 ] ) ; cout << maxCntRemovedfromArray ( arr , N , brr , M ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPair ( pair < int , int > * arr , int N ) { sort ( arr , arr + N ) ; for ( int i = 1 ; i < N ; i ++ ) { int b = arr [ i - 1 ] . second ; int d = arr [ i ] . second ; if ( b > d ) { cout << " ( " << arr [ i - 1 ] . first << " ▁ " << b << " ) , ▁ ( " << arr [ i ] . first << " ▁ " << d << " ) " ; return ; } } cout << " NO ▁ SUCH ▁ PAIR ▁ EXIST STRNEWLINE " ; } int main ( ) { pair < int , int > arr [ ] = { { 3 , 7 } , { 21 , 23 } , { 4 , 13 } , { 1 , 2 } , { 7 , -1 } } ; findPair ( arr , 5 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printOrder ( int order [ ] , int N , int X ) { vector < pair < int , int > > vect ; for ( int i = 0 ; i < N ; i ++ ) { if ( order [ i ] % X == 0 ) { vect . push_back ( { order [ i ] / X , i + 1 } ) ; } else { vect . push_back ( { order [ i ] / X + 1 , i + 1 } ) ; } } sort ( vect . begin ( ) , vect . end ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { cout << vect [ i ] . second << " ▁ " ; } cout << endl ; } int main ( ) { int N = 3 , X = 3 ; int order [ ] = { 2 , 7 , 4 } ; printOrder ( order , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrange ( int A [ ] , int B [ ] , int N , int X ) { bool flag = true ; sort ( A , A + N ) ; sort ( B , B + N , greater < int > ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] + B [ i ] > X ) { flag = false ; break ; } } if ( flag ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 1 , 1 , 2 } ; int X = 4 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; rearrange ( A , B , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } cout << endl ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; insertionSort ( arr , N ) ; printArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSmallestNumLeft ( int arr [ ] , int N ) { priority_queue < int > PQ ; for ( int i = 0 ; i < N ; i ++ ) { PQ . push ( arr [ i ] ) ; } while ( PQ . size ( ) > 1 ) { int top1 = PQ . top ( ) ; PQ . pop ( ) ; int top2 = PQ . top ( ) ; PQ . pop ( ) ; PQ . push ( ( top1 + top2 + 1 ) / 2 ) ; } return PQ . top ( ) ; } int main ( ) { int arr [ ] = { 30 , 16 , 40 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSmallestNumLeft ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <vector> NEW_LINE using namespace std ; bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } int digitProduct ( int number ) { int product = 1 ; while ( number > 0 ) { product *= ( number % 10 ) ; number /= 10 ; } return product ; } bool compositedigitProduct ( int num ) { int res = digitProduct ( num ) ; if ( res == 1 ) { return false ; } if ( isComposite ( res ) ) { return true ; } return false ; } int largestCompositeDigitProduct ( int a [ ] , int n , int k ) { vector < pair < int , int > > pq ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i % k ) == 0 ) { continue ; } if ( compositedigitProduct ( a [ i ] ) ) { int b = digitProduct ( a [ i ] ) ; pq . push_back ( make_pair ( b , a [ i ] ) ) ; } } sort ( pq . begin ( ) , pq . end ( ) ) ; return pq . back ( ) . second ; } int main ( ) { int arr [ ] = { 233 , 144 , 89 , 71 , 13 , 21 , 11 , 34 , 55 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; int ans = largestCompositeDigitProduct ( arr , n , k ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimum ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int ans = 0 ; for ( int i = 1 ; i < 2 * ( N / K ) ; i += 2 ) { ans += arr [ i ] ; } cout << ans ; } int main ( ) { int arr [ ] = { 11 , 20 , 5 , 7 , 8 , 14 , 2 , 17 , 16 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; findMinimum ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubarrays ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int i = 0 ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cout << " YES " << endl ; return ; } } cout << " NO " << endl ; } int main ( ) { int arr [ ] = { 4 , 3 , 0 , 1 , 2 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubarrays ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sweetTypeOnGivenDay ( int a [ ] , int b [ ] , int n , int k , vector < pair < int , int > > & q ) { vector < pair < int , pair < int , int > > > v ; for ( int i = 0 ; i < n ; i ++ ) v . push_back ( { b [ i ] , { a [ i ] , i + 1 } } ) ; sort ( v . begin ( ) , v . end ( ) , greater < pair < int , pair < int , int > > > ( ) ) ; map < int , pair < int , int > > mp ; int lowerbound = 0 , upperbound = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int maxi_days = v [ i ] . second . first ; int mini_days = v [ i ] . second . first / k ; if ( v [ i ] . second . first % k != 0 ) mini_days ++ ; upperbound += maxi_days ; mp [ v [ i ] . second . second ] = { lowerbound , upperbound } ; lowerbound += mini_days ; } for ( int i = 0 ; i < q . size ( ) ; i ++ ) { int x = q [ i ] . first , y = q [ i ] . second ; int e = mp [ x ] . first ; int f = mp [ x ] . second ; if ( y >= e && y <= f ) cout << " Yes " << " ▁ " ; else cout << " No " << " ▁ " ; } } int main ( ) { int A [ ] = { 6 , 3 , 7 , 5 , 2 } ; int B [ ] = { 1 , 2 , 3 , 4 , 5 } ; int K = 3 ; vector < pair < int , int > > Queries = { { 4 , 4 } , { 3 , 16 } , { 2 , 7 } } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; sweetTypeOnGivenDay ( A , B , n , K , Queries ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairs ( int arr [ ] , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] > K * arr [ i + 1 ] ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; getPairs ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void NDivKWithFreq ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; ) { int cnt = 1 ; while ( ( i + 1 ) < N && arr [ i ] == arr [ i + 1 ] ) { cnt ++ ; i ++ ; } if ( cnt > ( N / K ) ) { cout << arr [ i ] << " ▁ " ; } i ++ ; } } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 6 , 6 , 6 , 6 , 7 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; NDivKWithFreq ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printCircularArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } void sortCircularArray ( int arr [ ] , int n , int k , int m ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = k ; j < k + m - 1 ; j ++ ) { if ( arr [ j % n ] > arr [ ( j + 1 ) % n ] ) { swap ( arr [ j % n ] , arr [ ( j + 1 ) % n ] ) ; } } } printCircularArray ( arr , n ) ; } int main ( ) { int arr [ ] = { 4 , 1 , 6 , 5 , 3 } ; int K = 2 , M = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortCircularArray ( arr , N , K , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool func ( pair < int , int > i1 , pair < int , int > i2 ) { return ( i1 . first - i1 . second < i2 . first - i2 . second ) ; } int minimumCostReqToCompthePrcess ( vector < pair < int , int > > arr ) { sort ( arr . begin ( ) , arr . end ( ) , func ) ; int n = arr . size ( ) ; int minCost = 0 ; int minCostInit = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] . second > minCostInit ) { minCost += ( arr [ i ] . second - minCostInit ) ; minCostInit = arr [ i ] . second ; } minCostInit -= arr [ i ] . first ; } return minCost ; } int main ( ) { vector < pair < int , int > > arr = { { 1 , 2 } , { 2 , 4 } , { 4 , 8 } } ; cout << ( minimumCostReqToCompthePrcess ( arr ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeArray ( int a [ ] , int n ) { sort ( a , a + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == i + 1 ) { swap ( a [ i ] , a [ i + 1 ] ) ; } } if ( a [ n - 1 ] == n ) { swap ( a [ n - 1 ] , a [ n - 2 ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrangeArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumKthLargestsumPart ( int arr [ ] , int N , int M , int K ) { int maxSum = 0 ; if ( N % M ) return -1 ; int sz = ( N / M ) ; if ( K > sz ) return -1 ; sort ( arr , arr + N , greater < int > ( ) ) ; for ( int i = 1 ; i <= M ; i ++ ) { maxSum += arr [ i * K - 1 ] ; } return maxSum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int M = 2 ; int K = 1 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumKthLargestsumPart ( arr , N , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void minimumRange ( int arr [ ] , int N , int K ) { if ( K >= N ) { cout << 0 ; return ; } sort ( arr , arr + N ) ; int left = 0 , right = N - 1 , i ; for ( i = 0 ; i < K ; i ++ ) { if ( arr [ right - 1 ] - arr [ left ] < arr [ right ] - arr [ left + 1 ] ) right -- ; else left ++ ; } cout << arr [ right ] - arr [ left ] ; } int main ( ) { int arr [ ] = { 5 , 10 , 12 , 14 , 21 , 54 , 61 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; minimumRange ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void splitArray ( int arr [ ] , int n , int K ) { sort ( arr , arr + n ) ; int i = n - 1 ; int result = 0 ; while ( K -- ) { result += arr [ i - 1 ] ; i -= 2 ; } cout << result ; } int main ( ) { int arr [ ] = { 1 , 3 , 1 , 5 , 1 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; splitArray ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void merge ( int * indices , int * a , int l , int mid , int r ) { int temp_ind [ r - l + 1 ] , j = mid + 1 ; int i = 0 , temp_l = l , k ; while ( l <= mid && j <= r ) { if ( a [ indices [ l ] ] < a [ indices [ j ] ] ) temp_ind [ i ++ ] = indices [ l ++ ] ; else temp_ind [ i ++ ] = indices [ j ++ ] ; } while ( l <= mid ) temp_ind [ i ++ ] = indices [ l ++ ] ; while ( j <= r ) temp_ind [ i ++ ] = indices [ j ++ ] ; for ( k = 0 ; k < i ; k ++ ) indices [ temp_l ++ ] = temp_ind [ k ] ; } void divide ( int * indices , int * a , int l , int r ) { if ( l >= r ) return ; int mid = l / 2 + r / 2 ; divide ( indices , a , l , mid ) ; divide ( indices , a , mid + 1 , r ) ; merge ( indices , a , l , mid , r ) ; } void noOfSubsequences ( int arr [ ] , int N ) { int indices [ N ] , i ; for ( i = 0 ; i < N ; i ++ ) indices [ i ] = i ; divide ( indices , arr , 0 , N - 1 ) ; int B [ N ] ; int subseq = 1 ; for ( i = 0 ; i < N ; i ++ ) { B [ indices [ i ] ] = subseq ; subseq *= 2 ; } for ( i = 0 ; i < N ; i ++ ) cout << B [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 2 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; noOfSubsequences ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void merge ( int * order , int * freq , int i , int mid , int j ) { int tempOrder [ j - i + 1 ] ; int temp = mid + 1 , index = -1 ; while ( i <= mid && temp <= j ) { if ( freq [ order [ i ] ] <= freq [ order [ temp ] ] ) { tempOrder [ ++ index ] = order [ i ++ ] ; } else { tempOrder [ ++ index ] = order [ temp ++ ] ; } } while ( i <= mid ) { tempOrder [ ++ index ] = order [ i ++ ] ; } while ( temp <= j ) { tempOrder [ ++ index ] = order [ temp ++ ] ; } for ( index ; index >= 0 ; index -- ) { order [ j -- ] = tempOrder [ index ] ; } } void divide ( int * order , int * freq , int i , int j ) { if ( i >= j ) return ; int mid = i / 2 + j / 2 ; divide ( order , freq , i , mid ) ; divide ( order , freq , mid + 1 , j ) ; merge ( order , freq , i , mid , j ) ; } void orderProcesses ( int A [ ] , int N , int q ) { int i = 0 ; int freq [ N ] ; for ( i = 0 ; i < N ; i ++ ) { freq [ i ] = ( A [ i ] / q ) + ( A [ i ] % q > 0 ) ; } int order [ 4 ] ; for ( i = 0 ; i < N ; i ++ ) { order [ i ] = i ; } divide ( order , freq , 0 , N - 1 ) ; for ( i = 0 ; i < N ; i ++ ) { cout << order [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 3 , 7 , 4 } ; int Q = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; orderProcesses ( arr , N , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string convert_to_words ( int n ) { char num [ 1000 ] ; string str = to_string ( n ) ; strcpy ( num , str . c_str ( ) ) ; char * arr_ptr = & num [ 0 ] ; int len = strlen ( arr_ptr ) ; string ans = " " ; if ( len == 0 ) { ans += " Empty ▁ String " ; return ans ; } string single_digits [ ] = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string two_digits [ ] = { " " , " ten " , " eleven " , " twelve " , " thirteen " , " fourteen " , " fifteen " , " sixteen " , " seventeen " , " eighteen " , " nineteen " } ; string tens_multiple [ ] = { " " , " " , " twenty " , " thirty " , " forty " , " fifty " , " sixty " , " seventy " , " eighty " , " ninety " } ; string tens_power [ ] = { " hundred " , " thousand " } ; if ( len == 1 ) { ans += single_digits [ num [ 0 ] - '0' ] ; return ans ; } int x = 0 ; while ( x < len ) { if ( len >= 3 ) { if ( num [ x ] - '0' != 0 ) { ans += single_digits [ num [ x ] - '0' ] ; ans += " ▁ " ; ans += tens_power [ len - 3 ] ; ans += " ▁ " ; } -- len ; } else { if ( num [ x ] - '0' == 1 ) { int sum = num [ x ] - '0' + num [ x ] - '0' ; ans += two_digits [ sum ] ; return ans ; } else if ( num [ x ] - '0' == 2 && num [ x + 1 ] - '0' == 0 ) { ans += " twenty " ; return ans ; } else { int i = ( num [ x ] - '0' ) ; if ( i > 0 ) { ans += tens_multiple [ i ] ; ans += " ▁ " ; } else ans += " " ; ++ x ; if ( num [ x ] - '0' != 0 ) ans += single_digits [ num [ x ] - '0' ] ; } } ++ x ; } return " " ; } static void lexNumbers ( int n ) { vector < string > s ; for ( int i = 1 ; i <= n ; i ++ ) { s . push_back ( convert_to_words ( i ) ) ; } sort ( s . begin ( ) , s . end ( ) ) ; vector < string > ans ; for ( int i = 0 ; i < n ; i ++ ) ans . push_back ( s [ i ] ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) cout << ans [ i ] << " , ▁ " ; cout << ans [ n - 1 ] ; } int main ( ) { int n = 5 ; lexNumbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumCost ( int * binary , int n , int a , int b ) { vector < int > groupOfZeros ; int len = 0 , i = 0 ; bool increment_need = true ; while ( i < n ) { increment_need = true ; while ( i < n && binary [ i ] == 0 ) { len ++ ; i ++ ; increment_need = false ; } if ( increment_need == true ) { i ++ ; } if ( len != 0 ) { groupOfZeros . push_back ( len ) ; } len = 0 ; } sort ( groupOfZeros . begin ( ) , groupOfZeros . end ( ) ) ; i = 0 ; bool found_ones = false ; int NumOfOnes = 0 ; while ( i < n ) { found_ones = false ; while ( i < n && binary [ i ] == 1 ) { i ++ ; found_ones = true ; } if ( found_ones == false ) i ++ ; else NumOfOnes ++ ; } int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int curr = 0 , totalOnes = NumOfOnes ; if ( i == 0 ) { curr = totalOnes * a ; } else { int mark = i , num_of_changes = 0 ; for ( int x : groupOfZeros ) { if ( mark >= x ) { totalOnes -- ; mark -= x ; num_of_changes += x ; } else { break ; } } curr = ( num_of_changes * b ) + ( totalOnes * a ) ; } ans = min ( ans , curr ) ; } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 0 , 1 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 10 , Y = 4 ; minimumCost ( arr , N , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isSortedparitions ( int arr [ ] , int i , int j ) { for ( int k = i + 1 ; k <= j ; k ++ ) { if ( arr [ k ] < arr [ k - 1 ] ) { return 0 ; } } return 1 ; } int partitionsArr ( int arr [ ] , int i , int j ) { if ( i >= j ) return 1 ; bool flag = isSortedparitions ( arr , i , j ) ; if ( flag ) { return ( j - i + 1 ) ; } int mid = ( i + j ) / 2 ; int X = partitionsArr ( arr , i , mid ) ; int Y = partitionsArr ( arr , mid + 1 , j ) ; return max ( X , Y ) ; } int main ( ) { int arr [ ] = { 11 , 12 , 1 , 2 , 13 , 14 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << partitionsArr ( arr , 0 , N - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimum_possible_sum ( int arr [ ] , int n , int k ) { if ( n == 0 ) { return 0 ; } if ( n == 1 ) { return arr [ 0 ] ; } for ( int i = 0 ; i < k ; i ++ ) { int smallest_element = arr [ 0 ] ; int smallest_pos = 0 ; int largest_element = arr [ 0 ] ; int largest_pos = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] >= largest_element ) { largest_element = arr [ i ] ; largest_pos = i ; } if ( arr [ i ] < smallest_element ) { smallest_element = arr [ i ] ; smallest_pos = i ; } } int a = smallest_element * 2 ; int b = largest_element / 2 ; if ( a + b < smallest_element + largest_element ) { arr [ smallest_pos ] = a ; arr [ largest_pos ] = b ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans += arr [ i ] ; } return ans ; } int main ( ) { int arr [ ] = { 50 , 1 , 100 , 100 , 1 } ; int K = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimum_possible_sum ( arr , n , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int A [ ] , int N ) { int count = 0 ; sort ( A , A + N ) ; int bits [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { continue ; } for ( int j = 0 ; j < 32 ; j ++ ) { if ( ! ( ( 1LL << j ) & A [ i ] ) ) { count += bits [ j ] ; } } ++ bits [ ( int ) ( log2l ( A [ i ] ) ) ] ; } cout << count ; } int main ( ) { int arr [ ] = { 2 , 4 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mostvisitedsector ( int N , vector < int > & A ) { int maxVisited = 0 ; map < int , int > mp ; for ( int i = 0 ; i < A . size ( ) - 1 ; i ++ ) { int start = A [ i ] % N ; int end = A [ i + 1 ] % N ; while ( start != end ) { if ( start == 0 ) { mp [ N ] ++ ; if ( mp [ N ] > maxVisited ) { maxVisited = mp [ N ] ; } } else { mp [ start ] ++ ; if ( mp [ start ] > maxVisited ) { maxVisited = mp [ start ] ; } } start = ( start + 1 ) % N ; } } mp [ A . back ( ) ] ++ ; if ( mp [ A . back ( ) ] > maxVisited ) { maxVisited = mp [ A . back ( ) ] ; } for ( auto x : mp ) { if ( x . second == maxVisited ) { cout << x . first << " ▁ " ; } } } int main ( ) { int N = 4 ; vector < int > arr = { 1 , 2 , 1 , 2 } ; mostvisitedsector ( N , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestArea ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { int end = 0 , start = 0 , i = 0 , j = 0 ; sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + m ) ; while ( i < n and j < m ) { if ( arr1 [ i ] == arr2 [ j ] ) { if ( start == 0 ) start = arr1 [ i ] ; else end = arr1 [ i ] ; i ++ ; j ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) j ++ ; else i ++ ; } if ( end == 0 or start == 0 ) return 0 ; else return ( end - start ) ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 4 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int arr2 [ ] = { 1 , 3 , 4 } ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << largestArea ( arr1 , N , arr2 , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_pairs ( int arr [ ] , int brr [ ] , int N , int M , int K ) { int i = 0 ; int j = 0 ; int cntPairs = 0 ; sort ( arr , arr + N ) ; sort ( brr , brr + M ) ; while ( i < N && j < M ) { if ( brr [ j ] - arr [ i ] > K ) { cntPairs += ( M - j ) ; i ++ ; } else { j ++ ; } } return cntPairs ; } int main ( ) { int arr [ ] = { 5 , 9 , 1 , 8 } ; int brr [ ] = { 10 , 12 , 7 , 4 , 2 , 3 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( brr ) / sizeof ( brr [ 0 ] ) ; cout << count_pairs ( arr , brr , N , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void partition ( int arr [ ] , int N , int brr [ ] , int M , int Pivot ) { int l = N - 1 ; int r = 0 ; while ( l >= 0 && r < M ) { if ( arr [ l ] < Pivot ) l -- ; else if ( brr [ r ] > Pivot ) r ++ ; else { swap ( arr [ l ] , brr [ r ] ) ; l -- ; r ++ ; } } } void Merge ( int arr [ ] , int N , int brr [ ] , int M ) { int l = 0 ; int r = 0 ; int index = -1 ; int Pivot = 0 ; while ( index < N && l < N && r < M ) { if ( arr [ l ] < brr [ r ] ) { Pivot = arr [ l ++ ] ; } else { Pivot = brr [ r ++ ] ; } index ++ ; } while ( index < N && l < N ) { Pivot = arr [ l ++ ] ; index ++ ; } while ( index < N && r < M ) { Pivot = brr [ r ++ ] ; index ++ ; } partition ( arr , N , brr , M , Pivot ) ; sort ( arr , arr + N ) ; sort ( brr , brr + M ) ; for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " ▁ " ; for ( int i = 0 ; i < M ; i ++ ) cout << brr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 5 , 9 } ; int brr [ ] = { 2 , 4 , 7 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( brr ) / sizeof ( brr [ 0 ] ) ; Merge ( arr , N , brr , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int rankLessThanK ( int * arr , int k , int n ) { int rank = 1 ; int position = 1 ; sort ( arr , arr + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i == n - 1 arr [ i ] != arr [ i + 1 ] ) { rank = position ; if ( rank > k ) return position - 1 ; } position ++ ; } return n ; } int main ( ) { int arr [ 5 ] = { 2 , 2 , 3 , 4 , 5 } ; int N = 5 ; int K = 4 ; cout << rankLessThanK ( arr , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void eraseSubdirectory ( vector < string > & dir ) { vector < string > res ; sort ( dir . begin ( ) , dir . end ( ) ) ; res . push_back ( dir [ 0 ] ) ; cout << " { " << dir [ 0 ] << " , ▁ " ; for ( int i = 1 ; i < dir . size ( ) ; i ++ ) { string curr = dir [ i ] ; string prev = res . back ( ) ; int l = prev . length ( ) ; if ( curr . length ( ) > l && curr [ l ] == ' / ' && prev == curr . substr ( 0 , l ) ) continue ; res . push_back ( curr ) ; cout << curr << " , ▁ " ; } cout << " } STRNEWLINE " ; } int main ( ) { vector < string > dir = { " / a " , " / a / j " , " / c / d / e " , " / c / d " , " / b " } ; eraseSubdirectory ( dir ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfPairs ( int arr1 [ ] , int n , int arr2 [ ] , int m ) { priority_queue < int > pq ; int i , j ; sort ( arr1 , arr1 + n ) ; for ( j = 0 ; j < m ; j ++ ) { pq . push ( arr2 [ j ] ) ; } int ans = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( pq . top ( ) >= 2 * arr1 [ i ] ) { ans ++ ; pq . pop ( ) ; } } return ans ; } int main ( ) { int arr1 [ ] = { 3 , 1 , 2 } ; int arr2 [ ] = { 3 , 4 , 2 , 1 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << numberOfPairs ( arr1 , N , arr2 , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( int arr [ ] , int n ) { if ( n == 1 ) { cout << 0 << endl ; return ; } sort ( arr , arr + n ) ; float raised = 1 / float ( n - 1 ) ; float temp = pow ( arr [ n - 1 ] , raised ) ; int r = round ( temp ) + 1 ; int i , j , min_cost = INT_MAX ; int common_ratio = 1 ; for ( j = 1 ; j <= r ; j ++ ) { int curr_cost = 0 , prod = 1 ; for ( i = 0 ; i < n ; i ++ ) { curr_cost += abs ( arr [ i ] - prod ) ; prod *= j ; if ( curr_cost >= min_cost ) break ; } if ( i == n ) { min_cost = min ( min_cost , curr_cost ) ; common_ratio = j ; } } cout << min_cost << ' ▁ ' ; cout << common_ratio << ' ▁ ' ; } int main ( ) { int N = 6 ; int arr [ ] = { 1 , 11 , 4 , 27 , 15 , 33 } ; minCost ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  10 NEW_LINE void calculateFib ( int fib [ ] , int n ) { fib [ 0 ] = fib [ 1 ] = 1 ; for ( int x = 2 ; x < n ; x ++ ) { fib [ x ] = fib [ x - 1 ] + fib [ x - 2 ] ; } } int find_mth_bit ( int n , int m , int fib [ ] ) { if ( n <= 1 ) { return n ; } int len_left = fib [ n - 2 ] ; int len_right = fib [ n - 1 ] ; if ( m <= len_left ) { return find_mth_bit ( n - 2 , len_left + 1 - m , fib ) ; } else { return find_mth_bit ( n - 1 , len_right + 1 - ( m - len_left ) , fib ) ; } } void find_mth_bitUtil ( int n , int m ) { int fib [ maxN ] ; calculateFib ( fib , maxN ) ; int ans = find_mth_bit ( n , m , fib ) ; cout << ans << ' ▁ ' ; } int main ( ) { int n = 5 , m = 3 ; find_mth_bitUtil ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAdjSwaps ( vector < vector < int > > & mat ) { int N = mat . size ( ) ; vector < int > cntZero ( N , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 && mat [ i ] [ j ] == 0 ; j -- ) { cntZero [ i ] ++ ; } } int cntSwaps = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( cntZero [ i ] < ( N - i - 1 ) ) { int First = i ; while ( First < N && cntZero [ First ] < ( N - i - 1 ) ) { First ++ ; } if ( First == N ) { return -1 ; } while ( First > i ) { swap ( cntZero [ First ] , cntZero [ First - 1 ] ) ; First -- ; cntSwaps ++ ; } } } return cntSwaps ; } int main ( ) { vector < vector < int > > mat = { { 0 , 0 , 2 } , { 3 , 1 , 0 } , { 4 , 0 , 0 } } ; cout << minAdjSwaps ( mat ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int arr1 [ ] , int arr2 [ ] , int i , int j , int n ) { int f = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) f = 1 ; break ; } if ( f == 0 ) return 0 ; if ( i >= n j >= n ) return 0 ; if ( arr1 [ i ] < arr2 [ j ] ) return 1 + minOperations ( arr1 , arr2 , i + 1 , j + 1 , n ) ; return max ( minOperations ( arr1 , arr2 , i , j + 1 , n ) , minOperations ( arr1 , arr2 , i + 1 , j , n ) ) ; } void minOperationsUtil ( int arr [ ] , int n ) { int brr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; sort ( brr , brr + n ) ; int f = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != brr [ i ] ) f = 1 ; break ; } if ( f == 1 ) cout << ( minOperations ( arr , brr , 0 , 0 , n ) ) ; else cout << "0" ; } int main ( ) { int arr [ ] = { 4 , 7 , 2 , 3 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minOperationsUtil ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canTransform ( string & s , string & t ) { int n = s . length ( ) ; vector < int > occur [ 26 ] ; for ( int x = 0 ; x < n ; x ++ ) { char ch = s [ x ] - ' a ' ; occur [ ch ] . push_back ( x ) ; } vector < int > idx ( 26 , 0 ) ; bool poss = true ; for ( int x = 0 ; x < n ; x ++ ) { char ch = t [ x ] - ' a ' ; if ( idx [ ch ] >= occur [ ch ] . size ( ) ) { poss = false ; break ; } for ( int small = 0 ; small < ch ; small ++ ) { if ( idx [ small ] < occur [ small ] . size ( ) && occur [ small ] [ idx [ small ] ] < occur [ ch ] [ idx [ ch ] ] ) { poss = false ; break ; } } idx [ ch ] ++ ; } if ( poss ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } } int main ( ) { string s , t ; s = " hdecb " ; t = " cdheb " ; canTransform ( s , t ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int make_cuts ( int arr [ ] , int n , int K ) { int ans = 0 ; vector < int > poss ; int ce = 0 ; int co = 0 ; for ( int x = 0 ; x < n - 1 ; x ++ ) { if ( arr [ x ] % 2 == 0 ) ce ++ ; else co ++ ; if ( ce == co && co > 0 && ce > 0 ) { poss . push_back ( abs ( arr [ x ] - arr [ x + 1 ] ) ) ; } } sort ( poss . begin ( ) , poss . end ( ) ) ; for ( int x : poss ) { if ( K >= x ) { ans ++ ; K -= x ; } else break ; } return ans ; } int main ( ) { int N = 6 ; int K = 4 ; int arr [ ] = { 1 , 2 , 5 , 10 , 15 , 20 } ; cout << make_cuts ( arr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Arrange ( int arr [ ] , int n ) { int cost = 0 ; unordered_map < int , int > index ; for ( int i = 0 ; i < n ; i ++ ) { index [ arr [ i ] ] = i ; } sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( arr [ i ] > arr [ i + 1 ] + arr [ n - 1 ] ) { cout << " - 1" ; return ; } else { cost += abs ( index [ arr [ i ] ] - i ) ; } } else if ( i == n - 1 ) { if ( arr [ i ] > arr [ i - 1 ] + arr [ 0 ] ) { cout << " - 1" ; return ; } else { cost += abs ( index [ arr [ i ] ] - i ) ; } } else { if ( arr [ i ] > arr [ i - 1 ] + arr [ i + 1 ] ) { cout << " - 1" ; return ; } else { cost += abs ( index [ arr [ i ] ] - i ) ; } } } cout << cost ; return ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 1 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Arrange ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int XorSum ( int A [ ] , int B [ ] , int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { ans = ans ^ ( A [ i ] + B [ j ] ) ; } } return ans ; } int main ( ) { int A [ ] = { 4 , 6 , 0 , 0 , 3 , 3 } ; int B [ ] = { 0 , 5 , 6 , 5 , 0 , 3 } ; int N = sizeof A / sizeof A [ 0 ] ; cout << XorSum ( A , B , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDistinctChar ( string s , int n , int k ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ s [ i ] ] ++ ; vector < int > v ; for ( auto it = freq . begin ( ) ; it != freq . end ( ) ; it ++ ) { v . push_back ( it -> second ) ; } sort ( v . begin ( ) , v . end ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int mn = min ( v [ i ] - 1 , k ) ; v [ i ] -= mn ; k -= mn ; } if ( k > 0 ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int mn = min ( v [ i ] , k ) ; v [ i ] -= mn ; k -= mn ; } } int res = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) if ( v [ i ] == 1 ) res ++ ; return res ; } int main ( ) { string S = " geeksforgeeks " ; int N = S . size ( ) ; int K = 1 ; cout << maxDistinctChar ( S , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > primes ; void SieveOfEratosthenes ( ) { bool prime [ 10005 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= 1000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 1000 ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= 1000 ; p ++ ) if ( prime [ p ] ) primes . push_back ( p ) ; } void generate ( int n , int k ) { vector < long long > prod ; SieveOfEratosthenes ( ) ; int l = primes . size ( ) ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i + 1 ; j < l ; j ++ ) { if ( primes [ i ] * primes [ j ] > 0 ) prod . push_back ( primes [ i ] * primes [ j ] ) ; } } sort ( prod . begin ( ) , prod . end ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < k - 1 ; i ++ ) sum += prod [ i ] ; if ( sum > n ) cout << " - 1" ; else { for ( int i = 0 ; i < k - 1 ; i ++ ) { cout << prod [ i ] << " , ▁ " ; } cout << n - sum << " STRNEWLINE " ; } } int main ( ) { int n = 52 , k = 5 ; generate ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int arr [ ] , int n ) { pair < int , int > sorted [ n ] ; int total_cost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sorted [ i ] . first = arr [ i ] ; sorted [ i ] . second = i ; } sort ( sorted , sorted + n ) ; int overall_minimum = sorted [ 0 ] . first ; bool vis [ n ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] && sorted [ i ] . second == i ) continue ; vector < int > v ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; v . push_back ( sorted [ j ] . first ) ; j = sorted [ j ] . second ; } if ( v . size ( ) > 0 ) { int local_minimum = v [ 0 ] , result1 = 0 , result2 = 0 ; for ( int k = 1 ; k < v . size ( ) ; k ++ ) result1 += ( local_minimum * v [ k ] ) ; for ( int k = 0 ; k < v . size ( ) ; k ++ ) result2 += ( overall_minimum * v [ k ] ) ; result2 += ( overall_minimum * local_minimum ) ; total_cost += min ( result1 , result2 ) ; } } return total_cost ; } int main ( ) { int arr [ ] = { 1 , 8 , 9 , 7 , 6 } ; int n = ( sizeof ( arr ) / sizeof ( int ) ) ; cout << minCost ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximizeFinalElement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; if ( arr [ 0 ] != 1 ) arr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] > 1 ) { arr [ i ] = arr [ i - 1 ] + 1 ; } } return arr [ n - 1 ] ; } int main ( ) { int n = 4 ; int arr [ ] = { 3 , 1 , 3 , 4 } ; int max = maximizeFinalElement ( arr , n ) ; cout << max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLeastDist ( int A [ ] , int N ) { sort ( A , A + N ) ; if ( N % 2 == 0 ) { return A [ ( N - 1 ) / 2 ] ; } else { return A [ N / 2 ] ; } } int main ( ) { int A [ ] = { 4 , 1 , 5 , 10 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << " ( " << findLeastDist ( A , N ) << " , ▁ " << 0 << " ) " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubMatSum ( vector < vector < int > > mat ) { int n = mat . size ( ) ; int m = mat [ 0 ] . size ( ) ; int i , j ; int dp [ n ] [ m ] ; dp [ n - 1 ] [ m - 1 ] = mat [ n - 1 ] [ m - 1 ] ; int res = dp [ n - 1 ] [ m - 1 ] ; for ( i = m - 2 ; i >= 0 ; i -- ) { dp [ n - 1 ] [ i ] = mat [ n - 1 ] [ i ] + dp [ n - 1 ] [ i + 1 ] ; res = max ( res , dp [ n - 1 ] [ i ] ) ; } for ( i = n - 2 ; i >= 0 ; i -- ) { dp [ i ] [ m - 1 ] = mat [ i ] [ m - 1 ] + dp [ i + 1 ] [ m - 1 ] ; res = max ( res , dp [ i ] [ m - 1 ] ) ; } for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = m - 2 ; j >= 0 ; j -- ) { dp [ i ] [ j ] = mat [ i ] [ j ] + dp [ i ] [ j + 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j + 1 ] ; res = max ( res , dp [ i ] [ j ] ) ; } } return res ; } int main ( ) { vector < vector < int > > mat ; mat = { { -6 , -4 , -1 } , { -3 , 2 , 4 } , { 2 , 5 , 8 } } ; cout << maxSubMatSum ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; static long sum = 0 , total_sum = 0 ; static long mod = 1000000007 ; struct Node { Node * left , * right ; int data ; Node ( int x ) { data = x ; left = NULL ; right = NULL ; } } ; long getAlphaScore ( Node * node ) { if ( node -> left != NULL ) getAlphaScore ( node -> left ) ; sum = ( sum + node -> data ) % mod ; total_sum = ( total_sum + sum ) % mod ; if ( node -> right != NULL ) getAlphaScore ( node -> right ) ; return total_sum ; } Node * constructBST ( int arr [ ] , int start , int end , Node * root ) { if ( start > end ) return NULL ; int mid = ( start + end ) / 2 ; if ( root == NULL ) root = new Node ( arr [ mid ] ) ; root -> left = constructBST ( arr , start , mid - 1 , root -> left ) ; root -> right = constructBST ( arr , mid + 1 , end , root -> right ) ; return root ; } int main ( ) { int arr [ ] = { 10 , 11 , 12 } ; int length = 3 ; sort ( arr , arr + length ) ; Node * root = NULL ; root = constructBST ( arr , 0 , length - 1 , root ) ; cout << ( getAlphaScore ( root ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canMadeEqual ( int A [ ] , int B [ ] , int n ) { sort ( A , A + n ) ; sort ( B , B + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] != B [ i ] ) return false ; return true ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 1 , 3 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( canMadeEqual ( A , B , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxMinDifference ( int arr [ ] , int n , int k ) { if ( k >= n - 1 ) return 0 ; sort ( arr , arr + n ) ; int ans = arr [ n - 1 ] - arr [ 0 ] ; for ( int i = k , j = n - 1 ; i >= 0 ; -- i , -- j ) { ans = min ( arr [ j ] - arr [ i ] , ans ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 4 , 6 , 11 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << maxMinDifference ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int inversionCount ( string & s ) { int freq [ 26 ] = { 0 } ; int inv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < int ( s [ i ] - ' a ' ) ; j ++ ) temp += freq [ j ] ; inv += ( i - temp ) ; freq [ s [ i ] - ' a ' ] ++ ; } return inv ; } bool haveRepeated ( string & S1 , string & S2 ) { int freq [ 26 ] = { 0 } ; for ( char i : S1 ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) freq [ i ] = 0 ; for ( char i : S2 ) { if ( freq [ i - ' a ' ] > 0 ) return true ; freq [ i - ' a ' ] ++ ; } return false ; } void checkToMakeEqual ( string S1 , string S2 ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) { freq [ S1 [ i ] - ' a ' ] ++ ; } bool flag = 0 ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { if ( freq [ S2 [ i ] - ' a ' ] == 0 ) { flag = true ; break ; } freq [ S2 [ i ] - ' a ' ] -- ; } if ( flag == true ) { cout << " No STRNEWLINE " ; return ; } int invCount1 = inversionCount ( S1 ) ; int invCount2 = inversionCount ( S2 ) ; if ( invCount1 == invCount2 || ( invCount1 & 1 ) == ( invCount2 & 1 ) || haveRepeated ( S1 , S2 ) ) { cout << " Yes STRNEWLINE " ; } else cout << " No STRNEWLINE " ; } int main ( ) { string S1 = " abbca " , S2 = " acabb " ; checkToMakeEqual ( S1 , S2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void max_sum ( int ar [ ] , int n , int q , int x [ ] , int y [ ] ) { int ans = 0 , i ; priority_queue < pair < int , int > > pq ; for ( i = 0 ; i < n ; i ++ ) pq . push ( { ar [ i ] , 1 } ) ; for ( i = 0 ; i < q ; i ++ ) pq . push ( { y [ i ] , x [ i ] } ) ; while ( n > 0 ) { auto pr = pq . top ( ) ; pq . pop ( ) ; ans += pr . first * min ( n , pr . second ) ; n -= pr . second ; } cout << ans << " STRNEWLINE " ; } int main ( ) { int ar [ ] = { 200 , 100 , 200 , 300 } ; int n = ( sizeof ar ) / ( sizeof ar [ 0 ] ) ; int q = 2 ; int x [ ] = { 2 , 3 } ; int y [ ] = { 100 , 90 } ; max_sum ( ar , n , q , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortArr ( int a [ ] , int n ) { int i , k ; k = ( int ) log2 ( n ) ; k = pow ( 2 , k ) ; while ( k > 0 ) { for ( i = 0 ; i + k < n ; i ++ ) if ( a [ i ] > a [ i + k ] ) swap ( a [ i ] , a [ i + k ] ) ; k = k / 2 ; } for ( i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 5 , 20 , 30 , 40 , 36 , 33 , 25 , 15 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSum ( int arr [ ] , int n , int k ) { int elt = n / k ; int sum = 0 ; sort ( arr , arr + n ) ; int count = 0 ; int i = n - 1 ; while ( count < k ) { sum += arr [ i ] ; i -- ; count ++ ; } count = 0 ; i = 0 ; while ( count < k ) { sum += arr [ i ] ; i += elt - 1 ; count ++ ; } cout << sum << " STRNEWLINE " ; } int main ( ) { int Arr [ ] = { 1 , 13 , 7 , 17 , 6 , 5 } ; int K = 2 ; int size = sizeof ( Arr ) / sizeof ( Arr [ 0 ] ) ; maximumSum ( Arr , size , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1e5 + 5 ; void find_missing ( vector < pair < int , int > > interval ) { vector < int > vis ( MAX ) ; for ( int i = 0 ; i < interval . size ( ) ; ++ i ) { int start = interval [ i ] . first ; int end = interval [ i ] . second ; vis [ start ] ++ ; vis [ end + 1 ] -- ; } for ( int i = 1 ; i < MAX ; i ++ ) { vis [ i ] += vis [ i - 1 ] ; if ( ! vis [ i ] ) { cout << i << endl ; return ; } } } int main ( ) { vector < pair < int , int > > interval = { { 0 , 14 } , { 86 , 108 } , { 22 , 30 } , { 5 , 17 } } ; find_missing ( interval ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_missing ( vector < pair < int , int > > interval ) { sort ( interval . begin ( ) , interval . end ( ) ) ; int mx = 0 ; for ( int i = 0 ; i < ( int ) interval . size ( ) ; ++ i ) { if ( interval [ i ] . first > mx ) { cout << mx ; return ; } else mx = max ( mx , interval [ i ] . second + 1 ) ; } cout << mx ; } int main ( ) { vector < pair < int , int > > interval = { { 0 , 14 } , { 86 , 108 } , { 22 , 30 } , { 5 , 17 } } ; find_missing ( interval ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int build_num ( int bit [ ] ) { int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] ) ans += ( 1 << i ) ; return ans ; } int maximumOR ( int arr [ ] , int n , int k ) { int bit [ 32 ] = { 0 } ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( bit [ i ] == 0 && k > 0 ) { int temp = build_num ( bit ) ; int temp1 = temp ; int val = -1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( temp1 < ( temp arr [ j ] ) ) { temp1 = temp | arr [ j ] ; val = arr [ j ] ; } } if ( val != -1 ) { k -- ; for ( int j = 0 ; j < 32 ; j ++ ) { if ( val & ( 1 << j ) ) bit [ j ] ++ ; } } } } return build_num ( bit ) ; } int main ( ) { int arr [ ] = { 5 , 9 , 7 , 19 } ; int k = 3 ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << maximumOR ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallest_string ( string s , int m ) { int n = s . size ( ) ; int a [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int distance = s [ i ] - ' a ' ; if ( distance == 0 ) a [ i ] = 0 ; else a [ i ] = 26 - distance ; } for ( int i = 0 ; i < n ; i ++ ) { if ( m >= a [ i ] ) { s [ i ] = ' a ' ; m = m - a [ i ] ; } } m = m % 26 ; s [ n - 1 ] = s [ n - 1 ] + m ; cout << s ; } int main ( ) { string str = " aazzx " ; int m = 6 ; smallest_string ( str , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_maximum_jobs ( int N , vector < pair < int , int > > ranges ) { priority_queue < int , vector < int > , greater < int > > queue ; sort ( ranges . begin ( ) , ranges . end ( ) ) ; int min_day = ranges [ 0 ] . first ; int max_day = 0 ; for ( int i = 0 ; i < N ; i ++ ) max_day = max ( max_day , ranges [ i ] . second ) ; int index = 0 , count_jobs = 0 ; for ( int i = min_day ; i <= max_day ; i ++ ) { while ( index < ranges . size ( ) && ranges [ index ] . first <= i ) { queue . push ( ranges [ index ] . second ) ; index ++ ; } while ( ! queue . empty ( ) && queue . top ( ) < i ) queue . pop ( ) ; if ( queue . empty ( ) ) continue ; count_jobs ++ ; queue . pop ( ) ; } return count_jobs ; } int main ( ) { int N = 5 ; vector < pair < int , int > > ranges ; ranges . push_back ( { 1 , 5 } ) ; ranges . push_back ( { 1 , 5 } ) ; ranges . push_back ( { 1 , 5 } ) ; ranges . push_back ( { 2 , 3 } ) ; ranges . push_back ( { 2 , 3 } ) ; cout << find_maximum_jobs ( N , ranges ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minBox ( int arr [ ] , int n ) { int box = n ; sort ( arr , arr + n ) ; int curr_box = 0 , next_box = 1 ; while ( curr_box < n && next_box < n ) { if ( arr [ curr_box ] < arr [ next_box ] ) { box -- ; curr_box ++ ; next_box ++ ; } else if ( arr [ curr_box ] == arr [ next_box ] ) next_box ++ ; } cout << box << endl ; } int main ( ) { int size [ ] = { 1 , 2 , 3 } ; int n = sizeof ( size ) / sizeof ( size [ 0 ] ) ; minBox ( size , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countReductions ( vector < pair < int , int > > & v , int K ) { int sum = 0 ; for ( auto i : v ) { sum += i . first ; } if ( sum <= K ) { return 0 ; } sort ( v . begin ( ) , v . end ( ) , [ & ] ( pair < int , int > a , pair < int , int > b ) { return ( a . first - a . second ) > ( b . first - b . second ) ; } ) ; int i = 0 ; while ( sum > K && i < v . size ( ) ) { sum -= ( v [ i ] . first - v [ i ] . second ) ; i ++ ; } if ( sum <= K ) return i ; return -1 ; } int main ( ) { int N = 4 , K = 25 ; vector < pair < int , int > > v ( N ) ; v [ 0 ] = { 10 , 5 } ; v [ 1 ] = { 20 , 9 } ; v [ 2 ] = { 12 , 10 } ; v [ 3 ] = { 4 , 2 } ; cout << countReductions ( v , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; node * next ; } ; void setData ( node * head ) { node * tmp ; tmp = head ; while ( tmp != NULL ) { cout << tmp -> data << " ▁ - > ▁ " ; tmp = tmp -> next ; } } node * getData ( node * head , int num ) { node * temp = new node ; node * tail = head ; temp -> data = num ; temp -> next = NULL ; if ( head == NULL ) { head = temp ; tail = temp ; } else { while ( tail != NULL ) { if ( tail -> next == NULL ) { tail -> next = temp ; tail = tail -> next ; } tail = tail -> next ; } } return head ; } node * mergelists ( node * * head1 , node * * head2 ) { node * tail = * head1 ; while ( tail != NULL ) { if ( tail -> next == NULL && head2 != NULL ) { tail -> next = * head2 ; break ; } tail = tail -> next ; } return * head1 ; } void sortlist ( node * * head1 ) { node * curr = * head1 ; node * temp = * head1 ; while ( curr -> next != NULL ) { temp = curr -> next ; while ( temp != NULL ) { if ( temp -> data < curr -> data ) { int t = temp -> data ; temp -> data = curr -> data ; curr -> data = t ; } temp = temp -> next ; } curr = curr -> next ; } } int main ( ) { node * head1 = new node ; node * head2 = new node ; head1 = NULL ; head2 = NULL ; head1 = getData ( head1 , 4 ) ; head1 = getData ( head1 , 7 ) ; head1 = getData ( head1 , 5 ) ; head2 = getData ( head2 , 2 ) ; head2 = getData ( head2 , 1 ) ; head2 = getData ( head2 , 8 ) ; head2 = getData ( head2 , 1 ) ; head1 = mergelists ( & head1 , & head2 ) ; sortlist ( & head1 ) ; setData ( head1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double findMedian ( int a [ ] , int n ) { if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } void kStrongest ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; double median = findMedian ( arr , n ) ; int diff [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { diff [ i ] = abs ( median - arr [ i ] ) ; } int i = 0 , j = n - 1 ; while ( k > 0 ) { if ( diff [ i ] > diff [ j ] ) { cout << arr [ i ] << " ▁ " ; i ++ ; } else { cout << arr [ j ] << " ▁ " ; j -- ; } k -- ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; kStrongest ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sorting_possible ( int a [ ] , int b [ ] , int n ) { bool sorted = true ; int type1 = 0 , type0 = 0 , i ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { sorted = false ; break ; } } for ( i = 0 ; i < n ; i ++ ) { if ( b [ i ] == 0 ) type0 ++ ; else type1 ++ ; } if ( sorted ) return true ; else if ( type1 == n type0 == n ) return false ; else return true ; } int main ( ) { int a [ ] = { 15 , 1 , 2 , 17 , 6 } ; int b [ ] = { 1 , 1 , 0 , 1 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; bool res = sorting_possible ( a , b , n ) ; if ( res ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE #define infi  1000000000 NEW_LINE using namespace std ; class Node { public : int vertexNumber ; vector < pair < int , int > > children ; Node ( int vertexNumber ) { this -> vertexNumber = vertexNumber ; } void add_child ( int vNumber , int length ) { pair < int , int > p ; p . first = vNumber ; p . second = length ; children . push_back ( p ) ; } } ; vector < int > dijkstraDist ( vector < Node * > g , int s , vector < int > & path ) { vector < int > dist ( g . size ( ) ) ; bool visited [ g . size ( ) ] ; for ( int i = 0 ; i < g . size ( ) ; i ++ ) { visited [ i ] = false ; path [ i ] = -1 ; dist [ i ] = infi ; } dist [ s ] = 0 ; path [ s ] = -1 ; int current = s ; unordered_set < int > sett ; while ( true ) { visited [ current ] = true ; for ( int i = 0 ; i < g [ current ] -> children . size ( ) ; i ++ ) { int v = g [ current ] -> children [ i ] . first ; if ( visited [ v ] ) continue ; sett . insert ( v ) ; int alt = dist [ current ] + g [ current ] -> children [ i ] . second ; if ( alt < dist [ v ] ) { dist [ v ] = alt ; path [ v ] = current ; } } sett . erase ( current ) ; if ( sett . empty ( ) ) break ; int minDist = infi ; int index = 0 ; for ( int a : sett ) { if ( dist [ a ] < minDist ) { minDist = dist [ a ] ; index = a ; } } current = index ; } return dist ; } void printPath ( vector < int > path , int i , int s ) { if ( i != s ) { if ( path [ i ] == -1 ) { cout << " Path ▁ not ▁ found ! ! " ; return ; } printPath ( path , path [ i ] , s ) ; cout << path [ i ] << " ▁ " ; } } int main ( ) { vector < Node * > v ; int n = 4 , s = 0 , e = 5 ; for ( int i = 0 ; i < n ; i ++ ) { Node * a = new Node ( i ) ; v . push_back ( a ) ; } v [ 0 ] -> add_child ( 1 , 1 ) ; v [ 0 ] -> add_child ( 2 , 4 ) ; v [ 1 ] -> add_child ( 2 , 2 ) ; v [ 1 ] -> add_child ( 3 , 6 ) ; v [ 2 ] -> add_child ( 3 , 3 ) ; vector < int > path ( v . size ( ) ) ; vector < int > dist = dijkstraDist ( v , s , path ) ; for ( int i = 0 ; i < dist . size ( ) ; i ++ ) { if ( dist [ i ] == infi ) { cout << i << " ▁ and ▁ " << s << " ▁ are ▁ not ▁ connected " << endl ; continue ; } cout << " Distance ▁ of ▁ " << i << " th ▁ vertex ▁ from ▁ source ▁ vertex ▁ " << s << " ▁ is : ▁ " << dist [ i ] << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximizeval10 ( int a [ ] , int n , int k ) { int increments = 0 ; int ans = 0 ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { ans += ( a [ i ] / 10 ) ; if ( a [ i ] == 1000 ) continue ; else { v . push_back ( 10 - a [ i ] % 10 ) ; increments += ( 100 - ( ( a [ i ] ) / 10 ) - 1 ) ; } } sort ( v . begin ( ) , v . end ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { sum += v [ i ] ; if ( sum <= k ) { ans ++ ; } else break ; } if ( sum < k ) { int remaining = k - sum ; ans += min ( increments , remaining / 10 ) ; } cout << ans ; } int main ( ) { int N = 4 ; int X = 6 ; int A [ N ] = { 4 , 8 , 8 , 8 } ; maximizeval10 ( A , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDif ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; return ( arr [ N - 1 ] - arr [ N - 2 ] ) ; } int main ( ) { int arr [ ] = { 7 , 9 , 5 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinDif ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int partition ( int arr [ ] , int l , int h ) { int pivot = arr [ l ] ; int i = l + 1 ; int j = h ; while ( i <= j ) { while ( i <= h && arr [ i ] < pivot ) { i ++ ; } while ( j > l && arr [ j ] > pivot ) { j -- ; } if ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i ++ ; j -- ; } else i ++ ; } arr [ l ] = arr [ j ] ; arr [ j ] = pivot ; return j ; } void sortArray ( int arr [ ] , int l , int h ) { if ( l >= h ) return ; int pivot = partition ( arr , l , h ) ; sortArray ( arr , l , pivot - 1 ) ; sortArray ( arr , pivot + 1 , h ) ; } int findMaxIntervals ( int start [ ] , int end [ ] , int n , int R ) { int ans = 0 ; int prev = 0 ; int currActive = 0 ; int i = 0 ; int j = 0 ; if ( start [ 0 ] > 0 ) ans ++ ; while ( i < n && j < n ) { if ( start [ i ] < end [ j ] ) { i ++ ; currActive ++ ; } else if ( start [ i ] > end [ j ] ) { j ++ ; currActive -- ; } else { i ++ ; j ++ ; } if ( currActive == 0 ) { ans ++ ; } } if ( end [ n - 1 ] < R ) ans ++ ; return ans ; } int main ( ) { int R , N ; R = 10 ; N = 3 ; int start [ N ] = { 2 , 5 , 8 } ; int end [ N ] = { 3 , 9 , 10 } ; sortArray ( start , 0 , N - 1 ) ; sortArray ( end , 0 , N - 1 ) ; cout << findMaxIntervals ( start , end , N , R ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int number ( int a [ ] , int n , int p , int k ) { sort ( a , a + n ) ; int pre [ n ] = { 0 } , val , i , j , ans = 0 ; pre [ 0 ] = a [ 0 ] ; if ( pre [ 0 ] <= p ) ans = 1 ; for ( i = 1 ; i < k - 1 ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i ] ; if ( pre [ i ] <= p ) ans = i + 1 ; } pre [ k - 1 ] = a [ k - 1 ] ; for ( i = k - 1 ; i < n ; i ++ ) { if ( i >= k ) { pre [ i ] += pre [ i - k ] + a [ i ] ; } if ( pre [ i ] <= p ) ans = i + 1 ; } return ans ; } int main ( ) { int n = 5 ; int arr [ ] = { 2 , 4 , 3 , 5 , 7 } ; int p = 11 ; int k = 2 ; cout << number ( arr , n , p , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sieveOfEratosthenes ( bool prime [ ] , int n ) { prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } void sortSpecialPrimes ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; bool prime [ maxVal + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; sieveOfEratosthenes ( prime , maxVal ) ; vector < int > list ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] && prime [ arr [ i ] - 2 ] ) { list . push_back ( arr [ i ] ) ; arr [ i ] = -1 ; } } sort ( list . begin ( ) , list . end ( ) ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == -1 ) cout << list [ j ++ ] << " ▁ " ; else cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 31 , 5 , 2 , 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( int ) ; sortSpecialPrimes ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProfit ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - ( 1 * i ) ) > 0 ) ans += ( arr [ i ] - ( 1 * i ) ) ; if ( ( arr [ i ] - ( 1 * i ) ) == 0 ) break ; } return ans ; } int main ( ) { int arr [ ] = { 6 , 6 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxProfit ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check_vector ( vector < int > A , int n , vector < int > p ) { vector < int > pos ( A . size ( ) ) ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { pos [ p [ i ] - 1 ] = 1 ; } int flag = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( pos [ i ] == 0 ) continue ; int j = i ; while ( j < n && pos [ j ] ) ++ j ; sort ( A . begin ( ) + i , A . begin ( ) + j + 1 ) ; i = j ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << " Yes " ; else cout << " No " ; } int main ( ) { vector < int > A { 3 , 2 , 1 } ; vector < int > p { 1 , 2 } ; check_vector ( A , A . size ( ) , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumCost ( int arr [ ] , int N , int M ) { sort ( arr , arr + N ) ; int pref [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pref [ i ] = arr [ i ] + pref [ i - 1 ] ; } for ( int i = M ; i < N ; i ++ ) { pref [ i ] += pref [ i - M ] ; } for ( int i = 0 ; i < N ; i ++ ) { cout << pref [ i ] << ' ▁ ' ; } } int main ( ) { int arr [ ] = { 6 , 19 , 3 , 4 , 4 , 2 , 6 , 7 , 8 } ; int M = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumCost ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int uniqueSum ( int A [ ] , int R [ ] [ 2 ] , int N , int M ) { for ( int i = 0 ; i < M ; ++ i ) { int l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; A [ l ] ++ ; if ( r < N ) A [ r ] -- ; } for ( int i = 1 ; i < N ; ++ i ) { A [ i ] += A [ i - 1 ] ; } int ans = 0 ; unordered_set < int > s ; for ( int i = 0 ; i < N ; ++ i ) { if ( s . find ( A [ i ] ) == s . end ( ) ) ans += A [ i ] ; s . insert ( A [ i ] ) ; } return ans ; } int main ( ) { int A [ ] = { 0 , 0 , 0 , 0 , 0 , 0 } ; int R [ ] [ 2 ] = { { 1 , 3 } , { 4 , 6 } , { 3 , 4 } , { 3 , 3 } } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int M = sizeof ( R ) / sizeof ( R [ 0 ] ) ; cout << uniqueSum ( A , R , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void kthpair ( int n , int k , int arr [ ] ) { int i , t ; sort ( arr , arr + n ) ; -- k ; for ( i = 0 ; i < n ; i += t ) { for ( t = 1 ; arr [ i ] == arr [ i + t ] ; ++ t ) ; if ( t * n > k ) break ; k = k - t * n ; } cout << arr [ i ] << ' ▁ ' << arr [ k / t ] ; } int main ( ) { int n = 3 , k = 2 ; int arr [ n ] = { 3 , 1 , 5 } ; kthpair ( n , k , arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string s ) { int freq [ 26 ] = { 0 } ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s [ i ] - ' A ' ] ++ ; } sort ( freq , freq + 26 , greater < int > ( ) ) ; int answer = n ; for ( int i = 1 ; i <= 26 ; i ++ ) { if ( n % i == 0 ) { int x = n / i ; int y = 0 ; for ( int j = 0 ; j < i ; j ++ ) { y += min ( freq [ j ] , x ) ; } answer = min ( answer , n - y ) ; } } return answer ; } int main ( ) { string s = " BBC " ; cout << minOperations ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool fun ( int arr [ ] , int n , int k ) { vector < int > v ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { v . push_back ( arr [ j ] ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int x = 0 ; for ( int j = i ; j < n ; j += k ) { arr [ j ] = v [ x ] ; x ++ ; } v . clear ( ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) return false ; } return true ; } int main ( ) { int arr [ ] = { 4 , 2 , 3 , 7 , 6 } ; int K = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( fun ( arr , n , K ) ) cout << " yes " << endl ; else cout << " no " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int get_permutation ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result += abs ( arr [ i ] - ( i + 1 ) ) ; } return result ; } int main ( ) { int arr [ ] = { 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << get_permutation ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 1000 ] [ 1000 ] ; int minimumIncDec ( int arr [ ] , int N , int maxE , int minE ) { if ( N == 0 ) { return 0 ; } if ( dp [ N ] [ maxE ] ) return dp [ N ] [ maxE ] ; int ans = INT_MAX ; for ( int k = minE ; k <= maxE ; k ++ ) { int x = minimumIncDec ( arr , N - 1 , k , minE ) ; ans = min ( ans , x + abs ( arr [ N - 1 ] - k ) ) ; } dp [ N ] [ maxE ] = ans ; return dp [ N ] [ maxE ] ; } int main ( ) { int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int minE = * min_element ( arr , arr + N ) ; int maxE = * max_element ( arr , arr + N ) ; cout << minimumIncDec ( arr , N , maxE , minE ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortDiagonal ( int a [ 2 ] [ 2 ] , int M , int N ) { for ( int i = 0 ; i < M ; i ++ ) { int sm = a [ i ] [ i ] ; int pos = i ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( sm > a [ j ] [ j ] ) { sm = a [ j ] [ j ] ; pos = j ; } } swap ( a [ i ] [ i ] , a [ pos ] [ pos ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << a [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int a [ 2 ] [ 2 ] = { { 4 , 2 } , { 3 , 1 } } ; sortDiagonal ( a , 2 , 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int make_permutation ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += abs ( i + 1 - arr [ i ] ) ; return ans ; } int main ( ) { int arr [ ] = { 5 , 3 , 8 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << make_permutation ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( vector < vector < int > > & V , int n , int m ) { int ans = 0 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { vector < pair < int , int > > aux ; for ( int j = 0 ; j < m ; ++ j ) { aux . push_back ( { V [ i + 1 ] [ j ] , j } ) ; } sort ( aux . begin ( ) , aux . end ( ) ) ; reverse ( aux . begin ( ) , aux . end ( ) ) ; for ( int j = 0 ; j < m ; ++ j ) { for ( int k = 0 ; k < m ; ++ k ) { if ( aux [ k ] . second - j == 0 || abs ( aux [ k ] . second - j ) > 1 ) { V [ i ] [ j ] += aux [ k ] . first ; break ; } } } } for ( int i = 0 ; i < m ; ++ i ) { ans = max ( ans , V [ 0 ] [ i ] ) ; } return ans ; } int main ( ) { vector < vector < int > > V { { 1 , 2 , 3 , 4 } , { 8 , 7 , 6 , 5 } , { 10 , 11 , 12 , 13 } } ; int n = V . size ( ) ; int m = V [ 0 ] . size ( ) ; cout << maxSum ( V , n , m ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int minimumProduct ( int * arr , int n ) { sort ( arr , arr + n ) ; int product = 1 ; for ( int i = 0 ; i < n ; i += 2 ) { product *= ( arr [ i ] + arr [ i + 1 ] ) ; } return product ; } int main ( ) { int arr [ ] = { 1 , 6 , 3 , 1 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumProduct ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  3 NEW_LINE void sortMat ( int data [ N ] [ M ] , int row , int col ) { int size = row * col ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size - 1 ; j ++ ) { if ( data [ j / col ] [ j % col ] > data [ ( j + 1 ) / col ] [ ( j + 1 ) % col ] ) { int temp = data [ j / col ] [ j % col ] ; data [ j / col ] [ j % col ] = data [ ( j + 1 ) / col ] [ ( j + 1 ) % col ] ; data [ ( j + 1 ) / col ] [ ( j + 1 ) % col ] = temp ; } } } } void printMat ( int mat [ N ] [ M ] , int row , int col ) { for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) { cout << mat [ i ] [ j ] << " ▁ " ; } cout << endl ; } } int main ( ) { int mat [ N ] [ M ] = { { 5 , 4 , 7 } , { 1 , 3 , 8 } , { 2 , 9 , 6 } } ; int row = N ; int col = M ; sortMat ( mat , row , col ) ; printMat ( mat , row , col ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int minimiseMedian ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; return abs ( arr [ n / 2 ] - arr [ ( n / 2 ) - 1 ] ) ; } int main ( ) { int arr [ ] = { 15 , 25 , 35 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimiseMedian ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void overlap ( vector < pair < int , int > > v ) { int ans = 0 ; int count = 0 ; vector < pair < int , char > > data ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { data . push_back ( { v [ i ] . first , ' x ' } ) ; data . push_back ( { v [ i ] . second , ' y ' } ) ; } sort ( data . begin ( ) , data . end ( ) ) ; for ( int i = 0 ; i < data . size ( ) ; i ++ ) { if ( data [ i ] . second == ' x ' ) count ++ ; if ( data [ i ] . second == ' y ' ) count -- ; ans = max ( ans , count ) ; } cout << ans << endl ; } int main ( ) { vector < pair < int , int > > v = { { 1 , 2 } , { 2 , 4 } , { 3 , 6 } } ; overlap ( v ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canBeEqual ( int a , int b , int c , int k ) { int arr [ 3 ] ; arr [ 0 ] = a ; arr [ 1 ] = b ; arr [ 2 ] = c ; sort ( arr , arr + 3 ) ; int diff = 2 * arr [ 2 ] - arr [ 1 ] - arr [ 0 ] ; k = k - diff ; if ( k < 0 k % 3 != 0 ) return false ; return true ; } int main ( ) { int a1 = 6 , b1 = 3 , c1 = 2 , k1 = 7 ; if ( canBeEqual ( a1 , b1 , c1 , k1 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int * arr , int n , int k ) { int ans = arr [ n - k - 1 ] - arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) { ans = min ( arr [ n - 1 - ( k - i ) ] - arr [ i ] , ans ) ; } return ans ; } int32_t main ( ) { int arr [ ] = { 1 , 2 , 100 , 120 , 140 } ; int k = 2 ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findSum ( arr , n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkRectangles ( int * arr , int n ) { bool ans = true ; sort ( arr , arr + 4 * n ) ; int area = arr [ 0 ] * arr [ 4 * n - 1 ] ; for ( int i = 0 ; i < 2 * n ; i = i + 2 ) { if ( arr [ i ] != arr [ i + 1 ] arr [ 4 * n - i - 1 ] != arr [ 4 * n - i - 2 ] arr [ i ] * arr [ 4 * n - i - 1 ] != area ) { ans = false ; break ; } } if ( ans ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 2 , 1 , 2 , 4 , 4 , 8 } ; int n = 2 ; if ( checkRectangles ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int * arr , int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; ans = max ( ans , j - i ) ; i = j - 1 ; } return n - ans ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMin ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubSeq ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; vector < int > arr ; for ( int i = 0 ; i < n ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < n && a [ i ] == x ) { count ++ ; i ++ ; } arr . push_back ( count ) ; } int m = arr . size ( ) ; n = min ( m , k ) ; int count = 1 ; int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = m ; j >= 0 ; j -- ) { if ( j > m - i ) dp [ i ] [ j ] = 0 ; else { dp [ i ] [ j ] = dp [ i ] [ j + 1 ] + arr [ j ] * dp [ i - 1 ] [ j + 1 ] ; } } count = count + dp [ i ] [ 0 ] ; } return count ; } int main ( ) { int a [ ] = { 2 , 2 , 3 , 3 , 5 } ; int n = sizeof ( a ) / sizeof ( int ) ; int k = 3 ; cout << countSubSeq ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countUnvisited ( int n , int m ) { int X = ( m * n ) - m - n ; queue < int > queue ; queue . push ( X ) ; int count = 0 ; while ( queue . size ( ) > 0 ) { int curr = queue . front ( ) ; queue . pop ( ) ; count ++ ; if ( curr - m > 0 ) queue . push ( curr - m ) ; if ( curr - n > 0 ) queue . push ( curr - n ) ; } return count ; } int main ( ) { int n = 2 , m = 5 ; cout << countUnvisited ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string partOdd ( string s ) { string st = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( i % 2 != 0 ) st += s [ i ] ; } return st ; } string partEven ( string str ) { string s = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i % 2 == 0 ) s += str [ i ] ; } return s ; } bool canBeMadeEqual ( string s1 , string s2 ) { string even_s1 = partEven ( s1 ) ; string even_s2 = partEven ( s2 ) ; string odd_s1 = partOdd ( s1 ) ; string odd_s2 = partOdd ( s2 ) ; sort ( even_s1 . begin ( ) , even_s1 . end ( ) ) ; sort ( even_s2 . begin ( ) , even_s2 . end ( ) ) ; sort ( odd_s1 . begin ( ) , odd_s1 . end ( ) ) ; sort ( odd_s2 . begin ( ) , odd_s2 . end ( ) ) ; if ( even_s1 == even_s2 and odd_s1 == odd_s2 ) return true ; return false ; } int main ( ) { string s1 = " cdab " ; string s2 = " abcd " ; if ( canBeMadeEqual ( s1 , s2 ) ) cout << " Yes " << endl ; else cout << " No " << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortStack ( stack < int > & input , int k ) { stack < int > tmpStack ; while ( ! input . empty ( ) ) { int tmp = input . top ( ) ; input . pop ( ) ; while ( ! tmpStack . empty ( ) ) { int tmpStackMod = tmpStack . top ( ) % k ; int tmpMod = tmp % k ; if ( ( tmpStackMod > tmpMod ) || ( tmpStackMod == tmpMod && tmpStack . top ( ) > tmp ) ) { input . push ( tmpStack . top ( ) ) ; tmpStack . pop ( ) ; } else break ; } tmpStack . push ( tmp ) ; } while ( ! tmpStack . empty ( ) ) { input . push ( tmpStack . top ( ) ) ; tmpStack . pop ( ) ; } while ( ! input . empty ( ) ) { cout << input . top ( ) << " ▁ " ; input . pop ( ) ; } } int main ( ) { stack < int > input ; input . push ( 10 ) ; input . push ( 3 ) ; input . push ( 2 ) ; input . push ( 6 ) ; input . push ( 12 ) ; int k = 4 ; sortStack ( input , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLen ( int * arr , int n ) { int c_sum = 0 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { c_sum += arr [ i ] ; if ( c_sum < 0 ) return i ; } return n ; } int main ( ) { int arr [ ] = { 3 , 5 , -6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxLen ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntElements ( int arr [ ] , int n ) { int copy_arr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) copy_arr [ i ] = arr [ i ] ; int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != copy_arr [ i ] ) { count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 6 , 2 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void sortWithRemainder ( int arr [ ] , int n , int k ) { vector < int > v [ k ] ; for ( int i = 0 ; i < n ; i ++ ) { v [ arr [ i ] % k ] . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < k ; i ++ ) sort ( v [ i ] . begin ( ) , v [ i ] . end ( ) ) ; int j = 0 ; for ( int i = 0 ; i < k ; i ++ ) { for ( vector < int > :: iterator it = v [ i ] . begin ( ) ; it != v [ i ] . end ( ) ; it ++ ) { arr [ j ] = * it ; j ++ ; } } printArr ( arr , n ) ; } int main ( ) { int arr [ ] = { 10 , 7 , 2 , 6 , 12 , 3 , 33 , 46 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; sortWithRemainder ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool customSort ( string s1 , string s2 ) { int count_a1 = 0 , count_b1 = 0 ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( s1 [ i ] == ' a ' ) count_a1 ++ ; else count_b1 ++ ; } int count_a2 = 0 , count_b2 = 0 ; for ( int i = 0 ; i < s2 . size ( ) ; i ++ ) { if ( s2 [ i ] == ' a ' ) count_a2 ++ ; else count_b2 ++ ; } if ( count_a1 * count_b2 > count_b1 * count_a2 ) { return 1 ; } else { return 0 ; } } string concatenateStrings ( string S [ ] , int N ) { string str = " " ; for ( int i = 0 ; i < N ; i ++ ) str += S [ i ] ; return str ; } int getMaxScore ( string S [ ] , int N ) { sort ( S , S + N , customSort ) ; string combined_string = concatenateStrings ( S , N ) ; int final_score = 0 , count_a = 0 ; for ( int i = 0 ; i < combined_string . size ( ) ; i ++ ) { if ( combined_string [ i ] == ' a ' ) { count_a ++ ; } else { final_score += count_a ; } } return final_score ; } int main ( ) { string S [ ] = { " bab " , " aa " , " ba " , " b " } ; int N = sizeof ( S ) / sizeof ( string ) ; cout << getMaxScore ( S , N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; int x = -1 ; string heap [ 1000 ] ; void heapForm ( string k ) { x ++ ; heap [ x ] = k ; int child = x ; string tmp ; int index = x / 2 ; while ( index >= 0 ) { if ( heap [ index ] > heap [ child ] ) { tmp = heap [ index ] ; heap [ index ] = heap [ child ] ; heap [ child ] = tmp ; child = index ; index = index / 2 ; } else { break ; } } } void heapSort ( ) { int left1 , right1 ; while ( x >= 0 ) { string k ; k = heap [ 0 ] ; cout << k << " ▁ " ; heap [ 0 ] = heap [ x ] ; x = x - 1 ; string tmp ; int index = 0 ; int length = x ; left1 = 1 ; right1 = left1 + 1 ; while ( left1 <= length ) { if ( heap [ index ] <= heap [ left1 ] && heap [ index ] <= heap [ right1 ] ) { break ; } else { if ( heap [ left1 ] < heap [ right1 ] ) { tmp = heap [ index ] ; heap [ index ] = heap [ left1 ] ; heap [ left1 ] = tmp ; index = left1 ; } else { tmp = heap [ index ] ; heap [ index ] = heap [ right1 ] ; heap [ right1 ] = tmp ; index = right1 ; } } left1 = 2 * left1 ; right1 = left1 + 1 ; } } } void sort ( string k [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { heapForm ( k [ i ] ) ; } heapSort ( ) ; } int main ( ) { string arr [ ] = { " banana " , " orange " , " apple " , " pineapple " , " berries " , " lichi " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void UpdateArr ( int arr [ ] , int n ) { int i = 0 , j = n - 1 ; while ( i < j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; i += 2 ; j -= 2 ; } printArr ( arr , n ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; UpdateArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  20 NEW_LINE int fact [ N ] ; void pre ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; } } int CountPermutation ( int a [ ] , int n ) { int ways = 1 ; sort ( a , a + n ) ; int size = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { size ++ ; } else { ways *= fact [ size ] ; size = 1 ; } } ways *= fact [ size ] ; return ways ; } int main ( ) { int a [ ] = { 1 , 2 , 4 , 4 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; pre ( ) ; cout << CountPermutation ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Next_greater ( int a [ ] , int n , int x ) { sort ( a , a + n ) ; int low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; } int main ( ) { int a [ ] = { 1 , 5 , 10 , 4 , 7 } , x = 4 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Next_greater ( a , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100000 NEW_LINE void xorOnSortedArray ( int arr [ ] , int n , int k , int x ) { int arr1 [ MAX + 1 ] = { 0 } ; int arr2 [ MAX + 1 ] = { 0 } ; int xor_val [ MAX + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) arr1 [ arr [ i ] ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) xor_val [ i ] = i ^ x ; while ( k -- ) { int count = 0 ; for ( int i = 0 ; i <= MAX ; i ++ ) { int store = arr1 [ i ] ; if ( arr1 [ i ] > 0 ) { if ( count % 2 == 0 ) { int div = ceil ( ( float ) arr1 [ i ] / 2 ) ; arr1 [ i ] = arr1 [ i ] - div ; arr2 [ xor_val [ i ] ] += div ; } else if ( count % 2 != 0 ) { int div = arr1 [ i ] / 2 ; arr1 [ i ] = arr1 [ i ] - div ; arr2 [ xor_val [ i ] ] += div ; } } count = count + store ; } for ( int i = 0 ; i <= MAX ; i ++ ) { arr1 [ i ] = arr1 [ i ] + arr2 [ i ] ; arr2 [ i ] = 0 ; } } int min = INT_MAX ; int max = INT_MIN ; for ( int i = 0 ; i <= MAX ; i ++ ) { if ( arr1 [ i ] > 0 ) { if ( min > i ) min = i ; if ( max < i ) max = i ; } } cout << min << " ▁ " << max << endl ; } int main ( ) { int arr [ ] = { 605 , 986 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 548 , x = 569 ; xorOnSortedArray ( arr , n , k , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int arr [ ] , int n , int k , int d ) { if ( n < 2 * k ) { cout << -1 ; return ; } vector < pair < int , int > > pairs ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < k ; i ++ ) { if ( arr [ n - k + i ] - arr [ i ] >= d ) { pair < int , int > p = make_pair ( arr [ i ] , arr [ n - k + i ] ) ; pairs . push_back ( p ) ; } } if ( pairs . size ( ) < k ) { cout << -1 ; return ; } for ( auto v : pairs ) { cout << " ( " << v . first << " , ▁ " << v . second << " ) " << endl ; } } int main ( ) { int arr [ ] = { 4 , 6 , 10 , 23 , 14 , 7 , 2 , 20 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 , d = 3 ; findPairs ( arr , n , k , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pairs_count ( int arr [ ] , int n , int sum ) { int ans = 0 ; sort ( arr , arr + n ) ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( arr [ i ] + arr [ j ] < sum ) i ++ ; else if ( arr [ i ] + arr [ j ] > sum ) j -- ; else { int x = arr [ i ] , xx = i ; while ( i < j and arr [ i ] == x ) i ++ ; int y = arr [ j ] , yy = j ; while ( j >= i and arr [ j ] == y ) j -- ; if ( x == y ) { int temp = i - xx + yy - j - 1 ; ans += ( temp * ( temp + 1 ) ) / 2 ; } else ans += ( i - xx ) * ( yy - j ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 , 5 , -1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; cout << pairs_count ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findSubarray ( int a [ ] , int k , int n ) { vector < vector < int > > vec ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { vector < int > temp ; for ( int j = i ; j < i + k ; j ++ ) { temp . push_back ( a [ j ] ) ; } vec . push_back ( temp ) ; } sort ( vec . begin ( ) , vec . end ( ) ) ; return vec [ vec . size ( ) - 1 ] ; } int main ( ) { int a [ ] = { 1 , 4 , 3 , 2 , 5 } ; int k = 4 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; vector < int > ans = findSubarray ( a , k , n ) ; for ( auto it : ans ) cout << it << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct val { int first ; int second ; } ; bool comparator ( struct val p1 , struct val p2 ) { return ( p1 . second < p2 . second ) ; } int maxChainLen ( struct val p [ ] , int n ) { int l = 1 ; sort ( p , p + n , comparator ) ; int s = p [ 0 ] . second ; for ( int i = 1 ; i < n ; i ++ ) { if ( p [ i ] . first > s ) { l ++ ; s = p [ i ] . second ; } } return l ; } int main ( ) { val p [ ] = { { 5 , 24 } , { 39 , 60 } , { 15 , 28 } , { 27 , 40 } , { 50 , 90 } } ; int n = sizeof ( p ) / sizeof ( p [ 0 ] ) ; cout << maxChainLen ( p , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortArray ( int a [ ] , int n ) { vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) ans . push_back ( a [ i ] ) ; } sort ( ans . begin ( ) , ans . end ( ) ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= 0 ) { a [ i ] = ans [ j ] ; j ++ ; } } for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 2 , -6 , -3 , 8 , 4 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solution ( vector < int > & arr , int x ) { sort ( arr . begin ( ) , arr . end ( ) ) ; int closestSum = 1000000000 ; for ( int i = 0 ; i < arr . size ( ) - 2 ; i ++ ) { int ptr1 = i + 1 , ptr2 = arr . size ( ) - 1 ; while ( ptr1 < ptr2 ) { int sum = arr [ i ] + arr [ ptr1 ] + arr [ ptr2 ] ; if ( abs ( 1LL * x - sum ) < abs ( 1LL * x - closestSum ) ) { closestSum = sum ; } if ( sum > x ) { ptr2 -- ; } else { ptr1 ++ ; } } } return closestSum ; } int main ( ) { vector < int > arr = { -1 , 2 , 1 , -4 } ; int x = 1 ; cout << solution ( arr , x ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool IsSorted ( int A [ ] , int B [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int x , y ; x = max ( A [ i ] , B [ i ] ) ; y = min ( A [ i ] , B [ i ] ) ; A [ i ] = x ; B [ i ] = y ; } for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] <= A [ i - 1 ] B [ i ] <= B [ i - 1 ] ) return false ; } return true ; } int main ( ) { int A [ ] = { 1 , 4 , 3 , 5 , 7 } ; int B [ ] = { 2 , 2 , 5 , 8 , 9 } ; int n = sizeof ( A ) / sizeof ( int ) ; cout << ( IsSorted ( A , B , n ) ? " True " : " False " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void K_multiple ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] % k == 0 && s . find ( a [ i ] / k ) == s . end ( ) ) a [ i ] % k != 0 ) s . insert ( a [ i ] ) ; } for ( auto i = s . begin ( ) ; i != s . end ( ) ; i ++ ) { cout << * i << " ▁ " ; } } int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 6 , 10 } ; int k = 2 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; K_multiple ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxWater ( int height [ ] , int n ) { int maximum = 0 ; int i = 0 , j = n - 1 ; while ( i < j ) { if ( height [ i ] < height [ j ] ) { maximum = max ( maximum , ( j - i - 1 ) * height [ i ] ) ; i ++ ; } else if ( height [ j ] < height [ i ] ) { maximum = max ( maximum , ( j - i - 1 ) * height [ j ] ) ; j -- ; } else { maximum = max ( maximum , ( j - i - 1 ) * height [ i ] ) ; i ++ ; j -- ; } } return maximum ; } int main ( ) { int height [ ] = { 2 , 1 , 3 , 4 , 6 , 5 } ; int n = sizeof ( height ) / sizeof ( height [ 0 ] ) ; cout << ( maxWater ( height , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSelectionCount ( int a [ ] , int n ) { int res = 0 ; sort ( a , a + n ) ; int select = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= select ) { res ++ ; select ++ ; } } return res ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 , 5 , 1 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSelectionCount ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCombinationsUtil ( int arr [ ] , int index , int n , int red_num ) { set < int > s ; int sum = 0 ; if ( red_num < 0 ) { return ; } if ( red_num == 0 ) { for ( int i = 0 ; i < index ; i ++ ) { s . insert ( arr [ i ] ) ; } for ( auto itr = s . begin ( ) ; itr != s . end ( ) ; itr ++ ) { sum = sum + ( * itr ) ; } if ( sum == n ) { for ( auto i = s . begin ( ) ; i != s . end ( ) ; i ++ ) { cout << * i << " ▁ " ; } cout << endl ; return ; } } int prev = ( index == 0 ) ? 1 : arr [ index - 1 ] ; for ( int k = prev ; k <= n ; k ++ ) { arr [ index ] = k ; findCombinationsUtil ( arr , index + 1 , n , red_num - k ) ; } } void findCombinations ( int n ) { int a [ n ] ; findCombinationsUtil ( a , 0 , n , n ) ; } int main ( ) { int n = 7 ; findCombinations ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool check ( int arr [ ] , int n ) { int modify = 0 ; if ( arr [ 0 ] > arr [ 1 ] ) { arr [ 0 ] = arr [ 1 ] / 2 ; modify ++ ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( arr [ i - 1 ] < arr [ i ] && arr [ i + 1 ] < arr [ i ] ) || ( arr [ i - 1 ] > arr [ i ] && arr [ i + 1 ] > arr [ i ] ) ) { arr [ i ] = ( arr [ i - 1 ] + arr [ i + 1 ] ) / 2 ; if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i + 1 ] ) return false ; modify ++ ; } } if ( arr [ n - 1 ] < arr [ n - 2 ] ) modify ++ ; if ( modify > 1 ) return false ; return true ; } int main ( ) { int arr [ ] = { 2 , 4 , 8 , 6 , 9 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( check ( arr , n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; long long mod = 1000000007 ; int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } long long powmod ( long long a , long long n ) { if ( ! n ) return 1 ; long long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 ) return ( pt * a ) % mod ; else return pt ; } long long CountSubset ( int * arr , int n ) { long long ans = powmod ( 2 , n - 1 ) ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && arr [ j ] == arr [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CountSubset ( arr , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX  100000 NEW_LINE int findSumofEle ( int arr1 [ ] , int m , int arr2 [ ] , int n ) { int hash [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr2 [ i ] ] ++ ; for ( int i = 1 ; i < MAX ; i ++ ) hash [ i ] = hash [ i ] + hash [ i - 1 ] ; int maximumFreq = 0 ; for ( int i = 0 ; i < m ; i ++ ) maximumFreq = max ( maximumFreq , hash [ arr1 [ i ] ] ) ; int sumOfElements = 0 ; for ( int i = 0 ; i < m ; i ++ ) sumOfElements += ( maximumFreq == hash [ arr1 [ i ] ] ) ? arr1 [ i ] : 0 ; return sumOfElements ; } int main ( ) { int arr1 [ ] = { 2 , 5 , 6 , 8 } ; int arr2 [ ] = { 4 , 10 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << findSumofEle ( arr1 , m , arr2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintBothArrays ( int a [ ] , int n ) { vector < int > v1 , v2 ; unordered_map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) { mpp [ a [ i ] ] ++ ; if ( mpp [ a [ i ] ] == 1 ) v1 . push_back ( a [ i ] ) ; else if ( mpp [ a [ i ] ] == 2 ) v2 . push_back ( a [ i ] ) ; else { cout << " Not ▁ possible " ; return ; } } sort ( v1 . begin ( ) , v1 . end ( ) ) ; cout << " Strictly ▁ increasing ▁ array ▁ is : STRNEWLINE " ; for ( auto it : v1 ) cout << it << " ▁ " ; sort ( v2 . begin ( ) , v2 . end ( ) , greater < int > ( ) ) ; cout << " Strictly decreasing array is : " for ( auto it : v2 ) cout << it << " ▁ " ; } int main ( ) { int a [ ] = { 7 , 2 , 7 , 3 , 3 , 1 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; PrintBothArrays ( a , n ) ; return 0 ; }
void selectionSort ( node * head ) { node * temp = head ; while ( temp ) { node * min = temp ; node * r = temp -> next ; while ( r ) { if ( min -> data > r -> data ) min = r ; r = r -> next ; } int x = temp -> data ; temp -> data = min -> data ; min -> data = x ; temp = temp -> next ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str ) { int min = INT_MAX ; int max = - INT_MAX ; int sum = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { int ascii = str [ i ] ; if ( ascii < 96 ascii > 122 ) return false ; sum += ascii ; if ( min > ascii ) min = ascii ; if ( max < ascii ) max = ascii ; } min -= 1 ; int eSum = ( ( max * ( max + 1 ) ) / 2 ) - ( ( min * ( min + 1 ) ) / 2 ) ; return sum == eSum ; } int main ( ) { string str = " dcef " ; if ( check ( str ) ) cout << ( " Yes " ) ; else cout << ( " No " ) ; string str1 = " xyza " ; if ( check ( str1 ) ) cout << ( " Yes " else cout << ( " No " }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isUgly ( int n ) { while ( n % 2 == 0 ) n = n / 2 ; while ( n % 3 == 0 ) n = n / 3 ; while ( n % 5 == 0 ) n = n / 5 ; if ( n == 1 ) return true ; return false ; } void sortUglyNumbers ( int arr [ ] , int n ) { vector < int > list ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( isUgly ( arr [ i ] ) ) { list . push_back ( arr [ i ] ) ; arr [ i ] = -1 ; } } sort ( list . begin ( ) , list . end ( ) ) ; int j = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == -1 ) cout << list [ j ++ ] << " ▁ " ; else cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 7 , 12 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortUglyNumbers ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << ( arr [ i ] ) << " ▁ " ; } void sortArr ( int arr [ ] , int n , int k ) { int prev = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { if ( prev != -1 ) sort ( arr + prev + 1 , arr + i ) ; prev = i ; } } printArr ( arr , n ) ; } int main ( ) { int arr [ ] = { 2 , 1 , 13 , 3 , 7 , 8 , 21 , 13 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; sortArr ( arr , n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findKth ( int arr [ ] , int n , int k ) { unordered_set < int > missing ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) missing . insert ( arr [ i ] ) ; int maxm = * max_element ( arr , arr + n ) ; int minm = * min_element ( arr , arr + n ) ; for ( int i = minm + 1 ; i < maxm ; i ++ ) { if ( missing . find ( i ) == missing . end ( ) ) count ++ ; if ( count == k ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { 2 , 10 , 9 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << findKth ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperation ( string S , int N , int K ) { if ( N % K ) { cout << " Not ▁ Possible " << endl ; return ; } int count [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { count [ S [ i ] - 97 ] ++ ; } int E = N / K ; vector < int > greaterE ; vector < int > lessE ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] < E ) lessE . push_back ( E - count [ i ] ) ; else greaterE . push_back ( count [ i ] - E ) ; } sort ( greaterE . begin ( ) , greaterE . end ( ) ) ; sort ( lessE . begin ( ) , lessE . end ( ) ) ; int mi = INT_MAX ; for ( int i = 0 ; i <= K ; i ++ ) { int set1 = i ; int set2 = K - i ; if ( greaterE . size ( ) >= set1 && lessE . size ( ) >= set2 ) { int step1 = 0 ; int step2 = 0 ; for ( int j = 0 ; j < set1 ; j ++ ) step1 += greaterE [ j ] ; for ( int j = 0 ; j < set2 ; j ++ ) step2 += lessE [ j ] ; mi = min ( mi , max ( step1 , step2 ) ) ; } } cout << mi << endl ; } int main ( ) { string S = " accb " ; int N = S . size ( ) ; int K = 2 ; minOperation ( S , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll maxProd ( int arr [ ] , int n , int k ) { ll product = 1 ; unordered_map < int , int > s ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ arr [ i ] ] == 0 ) { product = product * arr [ i ] ; } s [ arr [ i ] ] = s [ arr [ i ] ] + 1 ; } for ( int j = n - 1 ; j >= 0 && k > 0 ; j -- ) { if ( ( k > ( s [ arr [ j ] ] - 1 ) ) && ( ( s [ arr [ j ] ] - 1 ) > 0 ) ) { product *= pow ( arr [ j ] , s [ arr [ j ] ] - 1 ) ; k = k - s [ arr [ j ] ] + 1 ; s [ arr [ j ] ] = 0 ; } if ( k <= ( s [ arr [ j ] ] - 1 ) && ( ( s [ arr [ j ] ] - 1 ) > 0 ) ) { product *= pow ( arr [ j ] , k ) ; break ; } } return product ; } int main ( ) { int arr [ ] = { 5 , 6 , 7 , 8 , 2 , 5 , 6 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << maxProd ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long findAnswer ( int n , vector < int > & arr ) { sort ( arr . begin ( ) , arr . end ( ) ) ; unsigned long long sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; } int main ( ) { std :: vector < int > arr = { 53 , 28 , 143 , 5 } ; int n = arr . size ( ) ; cout << findAnswer ( n , arr ) ; }
#include <iostream> NEW_LINE #define n  4 NEW_LINE using namespace std ; void merge ( int l , int r , int * output ) { int l_in = l * n , r_in = ( ( l + r ) / 2 + 1 ) * n ; int l_c = ( ( l + r ) / 2 - l + 1 ) * n ; int r_c = ( r - ( l + r ) / 2 ) * n ; int l_arr [ l_c ] , r_arr [ r_c ] ; for ( int i = 0 ; i < l_c ; i ++ ) l_arr [ i ] = output [ l_in + i ] ; for ( int i = 0 ; i < r_c ; i ++ ) r_arr [ i ] = output [ r_in + i ] ; int l_curr = 0 , r_curr = 0 ; int in = l_in ; while ( l_curr + r_curr < l_c + r_c ) { if ( r_curr == r_c || ( l_curr != l_c && l_arr [ l_curr ] < r_arr [ r_curr ] ) ) output [ in ] = l_arr [ l_curr ] , l_curr ++ , in ++ ; else output [ in ] = r_arr [ r_curr ] , r_curr ++ , in ++ ; } } void divide ( int l , int r , int * output , int arr [ ] [ n ] ) { if ( l == r ) { for ( int i = 0 ; i < n ; i ++ ) output [ l * n + i ] = arr [ l ] [ i ] ; return ; } divide ( l , ( l + r ) / 2 , output , arr ) ; divide ( ( l + r ) / 2 + 1 , r , output , arr ) ; merge ( l , r , output ) ; } int main ( ) { int arr [ ] [ n ] = { { 5 , 7 , 15 , 18 } , { 1 , 8 , 9 , 17 } , { 1 , 4 , 7 , 7 } } ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * output = new int [ n * k ] ; divide ( 0 , k - 1 , output , arr ) ; for ( int i = 0 ; i < n * k ; i ++ ) cout << output [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNonPalinString ( string s ) { int freq [ 26 ] = { 0 } , flag = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] != s [ 0 ] ) flag = 1 ; freq [ s [ i ] - ' a ' ] ++ ; } if ( ! flag ) cout << " - 1" ; else { for ( int i = 0 ; i < 26 ; i ++ ) for ( int j = 0 ; j < freq [ i ] ; j ++ ) cout << char ( ' a ' + i ) ; } } int main ( ) { string s = " abba " ; findNonPalinString ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int n , int m , int k , vector < vector < int > > & matrix ) { vector < int > arr ( n * m , 0 ) ; int mod = matrix [ 0 ] [ 0 ] % k ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr [ i * m + j ] = matrix [ i ] [ j ] ; if ( matrix [ i ] [ j ] % k != mod ) { return -1 ; } } } sort ( arr . begin ( ) , arr . end ( ) ) ; int median = arr [ ( n * m ) / 2 ] ; int minOperations = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations += abs ( arr [ i ] - median ) / k ; if ( ( n * m ) % 2 == 0 ) { int median2 = arr [ ( ( n * m ) / 2 ) - 1 ] ; int minOperations2 = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations2 += abs ( arr [ i ] - median2 ) / k ; minOperations = min ( minOperations , minOperations2 ) ; } return minOperations ; } int main ( ) { vector < vector < int > > matrix = { { 2 , 4 , 6 } , { 8 , 10 , 12 } , { 14 , 16 , 18 } , { 20 , 22 , 24 } } ; int n = matrix . size ( ) ; int m = matrix [ 0 ] . size ( ) ; int k = 2 ; cout << minOperations ( n , m , k , matrix ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countDistinct ( int arr [ ] , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; } int main ( ) { int arr [ ] = { 12 , 10 , 9 , 45 , 2 , 10 , 10 , 45 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDistinct ( arr , n ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int countDistinct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; res ++ ; } return res ; } int main ( ) { int arr [ ] = { 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDistinct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void printMaxMean ( int arr [ ] , int n ) { int newArr [ n ] ; sort ( arr , arr + 2 * n ) ; for ( int i = 0 ; i < n ; i ++ ) newArr [ i ] = arr [ i + n ] ; printArray ( newArr , n ) ; } int main ( ) { int arr [ ] = { 4 , 8 , 3 , 1 , 3 , 7 , 0 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMaxMean ( arr , n / 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double average ( int arr [ ] , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; sort ( arr , arr + n ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << average ( arr , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; } return moves ; } int main ( ) { int arr [ ] = { 3 , 5 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minMovesToSort ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_sum ( int n , int k , int a [ ] ) { sort ( a , a + n ) ; if ( a [ 0 ] < 0 ) return -1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return -1 ; } else { int f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f ) return -1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int K = 1 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min_sum ( N , K , arr ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void merge ( int arr [ ] , int start , int mid , int end ) { int start2 = mid + 1 ; if ( arr [ mid ] <= arr [ start2 ] ) { return ; } while ( start <= mid && start2 <= end ) { if ( arr [ start ] <= arr [ start2 ] ) { start ++ ; } else { int value = arr [ start2 ] ; int index = start2 ; while ( index != start ) { arr [ index ] = arr [ index - 1 ] ; index -- ; } arr [ start ] = value ; start ++ ; mid ++ ; start2 ++ ; } } } void mergeSort ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; mergeSort ( arr , l , m ) ; mergeSort ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } void printArray ( int A [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << " ▁ " << A [ i ] ; cout << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; mergeSort ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int A [ ] , int n ) { int cost = 0 ; sort ( A , A + n ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += abs ( A [ i ] - K ) ; cost = min ( cost , tempCost ) ; } return cost ; } int main ( ) { int A [ ] = { 1 , 6 , 7 , 10 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minCost ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) cout << arr [ i ] << " ▁ " ; flag = 1 ; l = i ; } { for ( i = r ; i > r - k && i >= l ; i -- ) cout << arr [ i ] << " ▁ " ; flag = 0 ; r = i ; } k ++ ; } } int main ( ) { int n = 6 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime [ 100005 ] ; void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } void sortPrimes ( int arr [ ] , int n ) { SieveOfEratosthenes ( 100005 ) ; vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) v . push_back ( arr [ i ] ) ; } sort ( v . begin ( ) , v . end ( ) , greater < int > ( ) ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) arr [ i ] = v [ j ++ ] ; } } int main ( ) { int arr [ ] = { 4 , 3 , 2 , 6 , 100 , 17 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortPrimes ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next , * prev ; } ; int countPairs ( struct Node * first , struct Node * second , int value ) { int count = 0 ; while ( first != NULL && second != NULL && first != second && second -> next != first ) { if ( ( first -> data * second -> data ) == value ) { count ++ ; first = first -> next ; second = second -> prev ; } else if ( ( first -> data * second -> data ) > value ) second = second -> prev ; else first = first -> next ; } return count ; } int countTriplets ( struct Node * head , int x ) { if ( head == NULL ) return 0 ; struct Node * current , * first , * last ; int count = 0 ; last = head ; while ( last -> next != NULL ) last = last -> next ; for ( current = head ; current != NULL ; current = current -> next ) { first = current -> next ; count += countPairs ( first , last , x / current -> data ) ; } return count ; } void insert ( struct Node * * head , int data ) { struct Node * temp = new Node ( ) ; temp -> data = data ; temp -> next = temp -> prev = NULL ; if ( ( * head ) == NULL ) ( * head ) = temp ; else { temp -> next = * head ; ( * head ) -> prev = temp ; ( * head ) = temp ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 9 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 5 ) ; insert ( & head , 4 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; int x = 8 ; cout << " Count ▁ = ▁ " << countTriplets ( head , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isAlphabaticOrder ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; } int main ( ) { string s = " aabbbcc " ; if ( isAlphabaticOrder ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int rotateRec ( int n , int L [ ] , int B [ ] ) { int m = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( max ( L [ i ] , B [ i ] ) <= m ) m = max ( L [ i ] , B [ i ] ) ; else if ( min ( L [ i ] , B [ i ] ) <= m ) m = min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; } int main ( ) { int n = 3 ; int L [ ] = { 5 , 5 , 6 } ; int B [ ] = { 6 , 7 , 8 } ; rotateRec ( n , L , B ) == 1 ? cout << " YES " : cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minDistance ( int n , int k , vector < vector < int > > & point ) { for ( int i = 0 ; i < k ; ++ i ) sort ( point [ i ] . begin ( ) , point [ i ] . end ( ) ) ; for ( int i = 0 ; i < k ; ++ i ) cout << point [ i ] [ ( ceil ( ( double ) n / 2 ) - 1 ) ] << " ▁ " ; } int main ( ) { int n = 4 , k = 4 ; vector < vector < int > > point = { { 1 , 5 , 2 , 4 } , { 6 , 2 , 0 , 6 } , { 9 , 5 , 1 , 3 } , { 6 , 7 , 5 , 9 } } ; minDistance ( n , k , point ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printOrder ( int arr [ ] , int n , int k ) { int len1 = k , len2 = n - k ; int arr1 [ k ] , arr2 [ n - k ] ; for ( int i = 0 ; i < k ; i ++ ) arr1 [ i ] = arr [ i ] ; for ( int i = k ; i < n ; i ++ ) arr2 [ i - k ] = arr [ i ] ; sort ( arr1 , arr1 + len1 ) ; sort ( arr2 , arr2 + len2 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) arr [ i ] = arr1 [ i ] ; else { arr [ i ] = arr2 [ len2 - 1 ] ; len2 -- ; } } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , -1 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printOrder ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxNum ( int arr [ ] , int n ) { int hash [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 9 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) cout << i ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMaxNum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sortK ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int k = 3 ; int arr [ ] = { 2 , 6 , 3 , 12 , 56 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortK ( arr , n , k ) ; cout << " Following ▁ is ▁ sorted ▁ array STRNEWLINE " ; printArray ( arr , n ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int distribution ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return min ( count , n / 2 ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << distribution ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPairs ( int arr [ ] , int n ) { unordered_set < int > pairs ; bool pair_exists = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] > 0 ) pairs . insert ( arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) if ( pairs . find ( - arr [ i ] ) != pairs . end ( ) ) cout << arr [ i ] << " , ▁ " << - arr [ i ] << endl ; pair_exists = true ; } } if ( pair_exists == false ) cout << " No ▁ such ▁ pair ▁ exists " ; } int main ( ) { int arr [ ] = { 4 , 8 , 9 , -4 , 1 , -1 , -8 , -9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) cout << arr [ i ] << " , ▁ " << arr [ j ] << " , ▁ " << arr [ k ] << endl ; } } } int main ( ) { int arr [ ] = { 5 , 1 , 3 , 4 , 7 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int sum = 12 ; printTriplets ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int arr [ ] , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) ans ++ ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int a = 8 , b = 16 ; cout << countTriplets ( arr , n , a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areSame ( vector < int > & a , vector < int > & b ) { if ( a . size ( ) != b . size ( ) ) return false ; unordered_map < int , int > m1 , m2 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { m1 [ a [ i ] ] ++ ; m2 [ b [ i ] ] ++ ; } for ( auto x : m1 ) { if ( m2 . find ( x . first ) == m2 . end ( ) m2 [ x . first ] != x . second ) return false ; } return true ; } int main ( ) { vector < int > a ( { 7 , 7 , 5 } ) , b ( { 7 , 7 , 5 } ) ; if ( areSame ( a , b ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findOptimalPairs ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; for ( int i = 0 , j = N - 1 ; i <= j ; i ++ , j -- ) cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << " ▁ " ; } int main ( ) { int arr [ ] = { 9 , 6 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findOptimalPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxTotalRectangleArea ( int a [ ] , int n ) { sort ( a , a + n , greater < int > ( ) ) ; int sum = 0 ; bool flag = false ; int len ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; } int main ( ) { int a [ ] = { 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MaxTotalRectangleArea ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isSortedDesc ( struct Node * head ) { if ( head == NULL head -> next == NULL ) return true ; return ( head -> data > head -> next -> data && isSortedDesc ( head -> next ) ) ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> next = NULL ; temp -> data = data ; } int main ( ) { struct Node * head = newNode ( 7 ) ; head -> next = newNode ( 5 ) ; head -> next -> next = newNode ( 4 ) ; head -> next -> next -> next = newNode ( 3 ) ; isSortedDesc ( head ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE void evenOddInsertionSort ( int arr [ ] , int n ) { for ( int i = 2 ; i < n ; i ++ ) { int j = i - 2 ; int temp = arr [ i ] ; if ( ( i + 1 ) & 1 == 1 ) { while ( temp >= arr [ j ] && j >= 0 ) { arr [ j + 2 ] = arr [ j ] ; j -= 2 ; } arr [ j + 2 ] = temp ; } else { while ( temp <= arr [ j ] && j >= 0 ) { arr [ j + 2 ] = arr [ j ] ; j -= 2 ; } arr [ j + 2 ] = temp ; } } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; printf ( " STRNEWLINE " ) ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; evenOddInsertionSort ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void print ( vector < int > a , int n ) { for ( int i = 0 ; i <= n ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; } void sort ( vector < int > a , int n ) { for ( int i = n ; i >= 0 ; i -- ) for ( int j = n ; j > n - i ; j -- ) if ( a [ j ] > a [ j - 1 ] ) swap ( a [ j ] , a [ j - 1 ] ) ; print ( a , n ) ; } int main ( ) { int n = 7 ; vector < int > a ; a . push_back ( 2 ) ; a . push_back ( 4 ) ; a . push_back ( 3 ) ; a . push_back ( 2 ) ; a . push_back ( 4 ) ; a . push_back ( 5 ) ; a . push_back ( 3 ) ; sort ( a , n - 1 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void sort012 ( int * arr , int n ) { int count0 = 0 , count1 = 0 , count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; if ( arr [ i ] == 1 ) count1 ++ ; if ( arr [ i ] == 2 ) count2 ++ ; } for ( int i = 0 ; i < count0 ; i ++ ) arr [ i ] = 0 ; for ( int i = count0 ; i < ( count0 + count1 ) ; i ++ ) arr [ i ] = 1 ; for ( int i = ( count0 + count1 ) ; i < n ; i ++ ) arr [ i ] = 2 ; return ; } void printArray ( int * arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort012 ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE void alternateSort ( string & s ) { int n = s . length ( ) ; int lCount [ MAX ] = { 0 } , uCount [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( isupper ( s [ i ] ) ) uCount [ s [ i ] - ' A ' ] ++ ; else lCount [ s [ i ] - ' a ' ] ++ ; } int i = 0 , j = 0 , k = 0 ; while ( k < n ) { while ( i < MAX && uCount [ i ] == 0 ) i ++ ; if ( i < MAX ) { s [ k ++ ] = ' A ' + i ; uCount [ i ] -- ; } while ( j < MAX && lCount [ j ] == 0 ) j ++ ; if ( j < MAX ) { s [ k ++ ] = ' a ' + j ; lCount [ j ] -- ; } } } int main ( ) { string str = " bAwutndekWEdkd " ; alternateSort ( str ) ; cout << str << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void optimum_sequence_jobs ( vector < int > & V , double P ) { int j = 1 , N = V . size ( ) - 1 ; double result = 0 ; priority_queue < int , vector < int > , greater < int > > Queue ; for ( int i = 1 ; i <= N ; i ++ ) Queue . push ( V [ i ] ) ; while ( ! Queue . empty ( ) ) { cout << Queue . top ( ) << " ▁ " ; V [ j ++ ] = Queue . top ( ) ; Queue . pop ( ) ; } for ( int i = N ; i >= 1 ; i -- ) result += pow ( ( 1 - P ) , N - i ) * V [ i ] ; cout << endl << result << endl ; } int main ( ) { vector < int > V { -1 , 3 , 5 , 4 , 1 , 2 , 7 , 6 , 8 , 9 , 10 } ; double P = 0.10 ; optimum_sequence_jobs ( V , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) ; return sum ; } int main ( ) { int x [ ] = { -1 , 1 , 3 , 2 } ; int y [ ] = { 5 , 6 , 5 , 3 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; cout << distancesum ( x , y , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distancesum ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int res = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += ( arr [ i ] * i - sum ) ; sum += arr [ i ] ; } return res ; } int totaldistancesum ( int x [ ] , int y [ ] , int n ) { return distancesum ( x , n ) + distancesum ( y , n ) ; } int main ( ) { int x [ ] = { -1 , 1 , 3 , 2 } ; int y [ ] = { 5 , 6 , 5 , 3 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; cout << totaldistancesum ( x , y , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortRec ( int arr [ ] , int index , int k , int n ) { if ( k == 0 ) { for ( int i = 1 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << 999 ; return ; } else if ( k > 0 && index == 0 ) { index = n - 2 ; for ( int i = 1 ; i <= index ; i ++ ) { arr [ i - 1 ] = arr [ i ] ; } arr [ index ] = 999 ; } if ( index - 1 >= 0 && index + 1 < n && arr [ index - 1 ] > arr [ index + 1 ] ) { swap ( arr [ index ] , arr [ index + 1 ] ) ; swap ( arr [ index - 1 ] , arr [ index + 1 ] ) ; } else swap ( arr [ index ] , arr [ index - 1 ] ) ; sortRec ( arr , index - 1 , k - 1 , n ) ; } void sort ( int arr [ ] , int n ) { int index = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 999 ) { index = i ; break ; } } if ( index == -1 ) return ; sortRec ( arr , index , n , n ) ; } int main ( ) { int arr [ ] = { 3 , 2 , 999 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void unsort ( int l , int r , int a [ ] , int & k ) { if ( k < 1 l + 1 == r ) return ; k -= 2 ; int mid = ( l + r ) / 2 ; swap ( a [ mid - 1 ] , a [ mid ] ) ; unsort ( l , mid , a , k ) ; unsort ( mid , r , a , k ) ; } void arrayWithKCalls ( int n , int k ) { if ( k % 2 == 0 ) { cout << " ▁ NO ▁ SOLUTION ▁ " ; return ; } int a [ n + 1 ] ; a [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) a [ i ] = i + 1 ; k -- ; unsort ( 0 , n , a , k ) ; for ( int i = 0 ; i < n ; ++ i ) cout << a [ i ] << ' ▁ ' ; } int main ( ) { int n = 10 , k = 17 ; arrayWithKCalls ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; void sortString ( string & str ) { int charCount [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) charCount [ str [ i ] - ' a ' ] ++ ; for ( int i = MAX_CHAR - 1 ; i >= 0 ; i -- ) for ( int j = 0 ; j < charCount [ i ] ; j ++ ) cout << ( char ) ( ' a ' + i ) ; } int main ( ) { string s = " alkasingh " ; sortString ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMedian ( int arr [ ] , int n , int K ) { sort ( arr , arr + n ) ; cout << arr [ ( n + K ) / 2 ] ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 , 8 } ; int k = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMedian ( arr , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int partition ( int * arr , int low , int high , int * lp ) ; void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; } void DualPivotQuickSort ( int * arr , int low , int high ) { if ( low < high ) { int lp , rp ; rp = partition ( arr , low , high , & lp ) ; DualPivotQuickSort ( arr , low , lp - 1 ) ; DualPivotQuickSort ( arr , lp + 1 , rp - 1 ) ; DualPivotQuickSort ( arr , rp + 1 , high ) ; } } int partition ( int * arr , int low , int high , int * lp ) { if ( arr [ low ] > arr [ high ] ) swap ( & arr [ low ] , & arr [ high ] ) ; int j = low + 1 ; int g = high - 1 , k = low + 1 , p = arr [ low ] , q = arr [ high ] ; while ( k <= g ) { if ( arr [ k ] < p ) { swap ( & arr [ k ] , & arr [ j ] ) ; j ++ ; } else if ( arr [ k ] >= q ) { while ( arr [ g ] > q && k < g ) g -- ; swap ( & arr [ k ] , & arr [ g ] ) ; g -- ; if ( arr [ k ] < p ) { swap ( & arr [ k ] , & arr [ j ] ) ; j ++ ; } } k ++ ; } j -- ; g ++ ; swap ( & arr [ low ] , & arr [ j ] ) ; swap ( & arr [ high ] , & arr [ g ] ) ; return g ; } int main ( ) { int arr [ ] = { 24 , 8 , 42 , 75 , 29 , 77 , 38 , 57 } ; DualPivotQuickSort ( arr , 0 , 7 ) ; cout << " Sorted ▁ array : ▁ " ; for ( int i = 0 ; i < 8 ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; }
#include <iostream> NEW_LINE using namespace std ; void minMaxSelectionSort ( int * arr , int n ) { for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { int min = arr [ i ] , max = arr [ i ] ; int min_i = i , max_i = i ; for ( int k = i ; k <= j ; k ++ ) { if ( arr [ k ] > max ) { max = arr [ k ] ; max_i = k ; } else if ( arr [ k ] < min ) { min = arr [ k ] ; min_i = k ; } } swap ( arr [ i ] , arr [ min_i ] ) ; if ( arr [ min_i ] == max ) swap ( arr [ j ] , arr [ min_i ] ) ; else swap ( arr [ j ] , arr [ max_i ] ) ; } } int main ( ) { int arr [ ] = { 23 , 78 , 45 , 8 , 32 , 56 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minMaxSelectionSort ( arr , n ) ; printf ( " Sorted ▁ array : STRNEWLINE " ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mergeArray ( int a [ ] , int b [ ] , int n , int m ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = max ( mx , a [ i ] ) ; } for ( int i = 0 ; i < m ; i ++ ) { mx = max ( mx , b [ i ] ) ; } mx ++ ; int i = 0 , j = 0 , k = 0 ; while ( i < n && j < m && k < ( n + m ) ) { int e1 = a [ i ] % mx ; int e2 = b [ j ] % mx ; if ( e1 <= e2 ) { if ( k < n ) a [ k ] += ( e1 * mx ) ; else b [ k - n ] += ( e1 * mx ) ; i ++ ; k ++ ; } else { if ( k < n ) a [ k ] += ( e2 * mx ) ; else b [ k - n ] += ( e2 * mx ) ; j ++ ; k ++ ; } } while ( i < n ) { int el = a [ i ] % mx ; if ( k < n ) a [ k ] += ( el * mx ) ; else b [ k - n ] += ( el * mx ) ; i ++ ; k ++ ; } while ( j < m ) { int el = b [ j ] % mx ; if ( k < n ) a [ k ] += ( el * mx ) ; else b [ k - n ] += ( el * mx ) ; j ++ ; k ++ ; } for ( int i = 0 ; i < n ; i ++ ) a [ i ] = a [ i ] / mx ; for ( int i = 0 ; i < m ; i ++ ) b [ i ] = b [ i ] / mx ; return ; } int main ( ) { int a [ ] = { 3 , 5 , 6 , 8 , 12 } ; int b [ ] = { 1 , 4 , 9 , 13 } ; int n = sizeof ( a ) / sizeof ( int ) ; int m = sizeof ( b ) / sizeof ( int ) ; mergeArray ( a , b , n , m ) ; cout << " First ▁ array ▁ : ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; cout << " Second ▁ array ▁ : ▁ " ; for ( int i = 0 ; i < m ; i ++ ) cout << b [ i ] << " ▁ " ; cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrange ( int arr [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { int diff = abs ( arr [ i ] - x ) ; int j = i - 1 ; if ( abs ( arr [ j ] - x ) > diff ) { int temp = arr [ i ] ; while ( abs ( arr [ j ] - x ) > diff && j >= 0 ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } } } void print ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 10 , 5 , 3 , 9 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 7 ; arrange ( arr , n , x ) ; print ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( vector < string > v , int len ) { int n = v . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) sort ( v [ i ] . begin ( ) , v [ i ] . end ( ) ) ; for ( int i = 0 ; i < len - 1 ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( v [ i ] [ j ] > v [ i + 1 ] [ j ] ) return false ; return true ; } int main ( ) { vector < string > v = { " ebcda " , " ihgfj " , " klmno " , " pqrst " , " yvwxu " } ; check ( v , len ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printOrder ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) cout << arr [ i ] << " ▁ " ; for ( int j = n - 1 ; j >= n / 2 ; j -- ) cout << arr [ j ] << " ▁ " ; } int main ( ) { int arr [ ] = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , -1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printOrder ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < int , int > findSubArray ( int arr [ ] , int n ) { int start , end , min_sum = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = arr [ i ] ; if ( min_sum > abs ( curr_sum ) ) { min_sum = abs ( curr_sum ) ; start = i ; end = i ; } for ( int j = i + 1 ; j < n ; j ++ ) { curr_sum = curr_sum + arr [ j ] ; if ( min_sum > abs ( curr_sum ) ) { min_sum = abs ( curr_sum ) ; start = i ; end = j ; } } } pair < int , int > p = make_pair ( start , end ) ; return p ; } int main ( ) { int arr [ ] = { 2 , -5 , 4 , -6 , -3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pair < int , int > point = findSubArray ( arr , n ) ; cout << " Subarray ▁ starting ▁ from ▁ " ; cout << point . first << " ▁ to ▁ " << point . second ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < string > uniquePrefix ( vector < string > & a ) { int size = a . size ( ) ; vector < string > res ( size ) ; sort ( a . begin ( ) , a . end ( ) ) ; int j = 0 ; while ( j < min ( a [ 0 ] . length ( ) - 1 , a [ 1 ] . length ( ) - 1 ) ) { if ( a [ 0 ] [ j ] == a [ 1 ] [ j ] ) j ++ ; else break ; } int ind = 0 ; res [ ind ++ ] = a [ 0 ] . substr ( 0 , j + 1 ) ; string temp_prefix = a [ 1 ] . substr ( 0 , j + 1 ) ; for ( int i = 1 ; i < size - 1 ; i ++ ) { j = 0 ; while ( j < min ( a [ i ] . length ( ) - 1 , a [ i + 1 ] . length ( ) - 1 ) ) { if ( a [ i ] [ j ] == a [ i + 1 ] [ j ] ) j ++ ; else break ; } string new_prefix = a [ i ] . substr ( 0 , j + 1 ) ; if ( temp_prefix . length ( ) > new_prefix . length ( ) ) res [ ind ++ ] = temp_prefix ; else res [ ind ++ ] = new_prefix ; temp_prefix = a [ i + 1 ] . substr ( 0 , j + 1 ) ; } j = 0 ; string sec_last = a [ size - 2 ] ; string last = a [ size - 1 ] ; while ( j < min ( sec_last . length ( ) - 1 , last . length ( ) - 1 ) ) { if ( sec_last [ j ] == last [ j ] ) j ++ ; else break ; } res [ ind ] = last . substr ( 0 , j + 1 ) ; return res ; } int main ( ) { vector < string > input = { " zebra " , " dog " , " duck " , " dove " } ; vector < string > output = uniquePrefix ( input ) ; cout << " The ▁ shortest ▁ unique ▁ prefixes ▁ in ▁ sorted ▁ order ▁ are ▁ : ▁ STRNEWLINE " ; for ( auto i : output ) cout << i << ' ▁ ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimum ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += arr [ i ] ; n = n - k ; } return res ; } int findMaximum ( int arr [ ] , int n , int k ) { int res = 0 , index = 0 ; for ( int i = n - 1 ; i >= index ; i -- ) { res += arr [ i ] ; index += k ; } return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; sort ( arr , arr + n ) ; cout << findMinimum ( arr , n , k ) << " ▁ " << findMaximum ( arr , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mergeArrays ( int a [ ] , int b [ ] , int n , int m ) { map < int , bool > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ a [ i ] ] = true ; for ( int i = 0 ; i < m ; i ++ ) mp [ b [ i ] ] = true ; for ( auto i : mp ) cout << i . first << " ▁ " ; } int main ( ) { int a [ ] = { 1 , 3 , 5 , 7 } , b [ ] = { 2 , 4 , 6 , 8 } ; int size = sizeof ( a ) / sizeof ( int ) ; int size1 = sizeof ( b ) / sizeof ( int ) ; mergeArrays ( a , b , size , size1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printInSortedOrder ( string arr [ ] , int n ) { int index [ n ] ; int i , j , min ; for ( i = 0 ; i < n ; i ++ ) index [ i ] = i ; for ( i = 0 ; i < n - 1 ; i ++ ) { min = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ index [ min ] ] . compare ( arr [ index [ j ] ] ) > 0 ) min = j ; } if ( min != i ) { int temp = index [ min ] ; index [ min ] = index [ i ] ; index [ i ] = temp ; } } for ( i = 0 ; i < n ; i ++ ) cout << arr [ index [ i ] ] << " ▁ " ; } int main ( ) { string arr [ ] = { " geeks " , " quiz " , " geeks " , " for " } ; int n = 4 ; printInSortedOrder ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  10 NEW_LINE void sortArrayUsingCounts ( int arr [ ] , int n ) { int count [ MAX_SIZE ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int index = 0 ; for ( int i = 0 ; i < MAX_SIZE ; i ++ ) while ( count [ i ] > 0 ) arr [ index ++ ] = i , count [ i ] -- ; } bool removeAndPrintResult ( int arr [ ] , int n , int ind1 , int ind2 = -1 ) { for ( int i = n - 1 ; i >= 0 ; i -- ) if ( i != ind1 && i != ind2 ) cout << arr [ i ] ; } bool largest3Multiple ( int arr [ ] , int n ) { int sum = accumulate ( arr , arr + n , 0 ) ; if ( sum % 3 == 0 ) return true ; sortArrayUsingCounts ( arr , n ) ; int remainder = sum % 3 ; if ( remainder == 1 ) { int rem_2 [ 2 ] ; rem_2 [ 0 ] = -1 , rem_2 [ 1 ] = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 3 == 1 ) { removeAndPrintResult ( arr , n , i ) ; return true ; } if ( arr [ i ] % 3 == 2 ) { if ( rem_2 [ 0 ] == -1 ) rem_2 [ 0 ] = i ; else if ( rem_2 [ 1 ] == -1 ) rem_2 [ 1 ] = i ; } } if ( rem_2 [ 0 ] != -1 && rem_2 [ 1 ] != -1 ) { removeAndPrintResult ( arr , n , rem_2 [ 0 ] , rem_2 [ 1 ] ) ; return true ; } } else if ( remainder == 2 ) { int rem_1 [ 2 ] ; rem_1 [ 0 ] = -1 , rem_1 [ 1 ] = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 3 == 2 ) { removeAndPrintResult ( arr , n , i ) ; return true ; } if ( arr [ i ] % 3 == 1 ) { if ( rem_1 [ 0 ] == -1 ) rem_1 [ 0 ] = i ; else if ( rem_1 [ 1 ] == -1 ) rem_1 [ 1 ] = i ; } } if ( rem_1 [ 0 ] != -1 && rem_1 [ 1 ] != -1 ) { removeAndPrintResult ( arr , n , rem_1 [ 0 ] , rem_1 [ 1 ] ) ; return true ; } } cout << " Not ▁ possible " ; return false ; } int main ( ) { int arr [ ] = { 4 , 4 , 1 , 1 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; largest3Multiple ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; } int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; } int mergeSort ( int arr [ ] , int array_size ) { int * temp = ( int * ) malloc ( sizeof ( int ) * array_size ) ; return _mergeSort ( arr , temp , 0 , array_size - 1 ) ; } int minSwapToReachArr ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] - 1 ) - i > 2 ) return -1 ; } int numOfInversion = mergeSort ( arr , N ) ; return numOfInversion ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int res = minSwapToReachArr ( arr , N ) ; if ( res == -1 ) cout << " Not ▁ Possible STRNEWLINE " ; else cout << res << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void twoWaySort ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] *= -1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= -1 ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 7 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; twoWaySort ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void bucketSort ( vector < float > & arr , int n ) { vector < float > b [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ bi ] . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) sort ( b [ i ] . begin ( ) , b [ i ] . end ( ) ) ; int index = 0 ; arr . clear ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < b [ i ] . size ( ) ; j ++ ) arr . push_back ( b [ i ] [ j ] ) ; } void sortMixed ( float arr [ ] , int n ) { vector < float > Neg ; vector < float > Pos ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) Neg . push_back ( -1 * arr [ i ] ) ; else Pos . push_back ( arr [ i ] ) ; } bucketSort ( Neg , ( int ) Neg . size ( ) ) ; bucketSort ( Pos , ( int ) Pos . size ( ) ) ; for ( int i = 0 ; i < Neg . size ( ) ; i ++ ) arr [ i ] = -1 * Neg [ Neg . size ( ) - 1 - i ] ; for ( int j = Neg . size ( ) ; j < n ; j ++ ) arr [ j ] = Pos [ j - Neg . size ( ) ] ; } int main ( ) { float arr [ ] = { -0.897 , 0.565 , 0.656 , -0.1234 , 0 , 0.3434 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortMixed ( arr , n ) ; cout << " Sorted ▁ array ▁ is ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  1000000 NEW_LINE using namespace std ; int ksmallest ( int arr [ ] , int n , int k ) { int b [ MAX ] ; memset ( b , 0 , sizeof b ) ; for ( int i = 0 ; i < n ; i ++ ) b [ arr [ i ] ] = 1 ; for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) k -- ; if ( ! k ) return j ; } } int main ( ) { int k = 1 ; int arr [ ] = { 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ksmallest ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mergeTwoHalf ( int A [ ] , int n ) { sort ( A , A + n ) ; } int main ( ) { int A [ ] = { 2 , 3 , 8 , -1 , 7 , 10 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; mergeTwoHalf ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << A [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDiff ( int arr [ ] , int n , int k ) { int result = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; } int main ( ) { int arr [ ] = { 10 , 100 , 300 , 200 , 1000 , 20 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << minDiff ( arr , n , k ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isEven ( int n ) { return ( n % 2 == 0 ) ; } int main ( ) { int n = 101 ; isEven ( n ) ? cout << " Even " : cout << " Odd " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countBits ( int a ) { int count = 0 ; while ( a ) { if ( a & 1 ) count += 1 ; a = a >> 1 ; } return count ; } void insertionSort ( int arr [ ] , int aux [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { int key1 = aux [ i ] ; int key2 = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && aux [ j ] < key1 ) { aux [ j + 1 ] = aux [ j ] ; arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } aux [ j + 1 ] = key1 ; arr [ j + 1 ] = key2 ; } } void sortBySetBitCount ( int arr [ ] , int n ) { int aux [ n ] ; for ( int i = 0 ; i < n ; i ++ ) aux [ i ] = countBits ( arr [ i ] ) ; insertionSort ( arr , aux , n ) ; } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSurpasser ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; cout << count << " ▁ " ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; printf ( " STRNEWLINE " ) ; } int main ( ) { int arr [ ] = { 2 , 7 , 5 , 3 , 0 , 8 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Given ▁ array ▁ is ▁ STRNEWLINE " ) ; printArray ( arr , n ) ; printf ( " Surpasser ▁ Count ▁ of ▁ array ▁ is ▁ STRNEWLINE " ) ; findSurpasser ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; int max_product = INT_MIN ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; } int main ( ) { int arr [ ] = { 10 , 3 , 5 , 6 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Triplet ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; vector < int > leftMin ( n , -1 ) ; vector < int > rightMin ( n , -1 ) ; vector < int > leftMax ( n , -1 ) ; vector < int > rightMax ( n , -1 ) ; int max_product = INT_MIN ; int max_sum = arr [ 0 ] ; int min_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { leftMax [ i ] = max_sum ; if ( arr [ i ] > max_sum ) max_sum = arr [ i ] ; leftMin [ i ] = min_sum ; if ( arr [ i ] < min_sum ) min_sum = arr [ i ] ; } max_sum = arr [ n - 1 ] ; min_sum = arr [ n - 1 ] ; for ( int j = n - 2 ; j >= 0 ; j -- ) { rightMax [ j ] = max_sum ; if ( arr [ j ] > max_sum ) max_sum = arr [ j ] ; rightMin [ j ] = min_sum ; if ( arr [ j ] < min_sum ) min_sum = arr [ j ] ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int max1 = max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) ; int max2 = max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) ; max_product = max ( max_product , max ( max1 , max2 ) ) ; } return max_product ; } int main ( ) { int arr [ ] = { 1 , 4 , 3 , -6 , -7 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Triplet ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; sort ( arr , arr + n ) ; return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; } int main ( ) { int arr [ ] = { -10 , -3 , 5 , 6 , -20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Triplet ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) return -1 ; int maxA = INT_MIN , maxB = INT_MIN , maxC = INT_MIN ; int minA = INT_MAX , minB = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) maxC = arr [ i ] ; if ( arr [ i ] < minA ) { minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) minB = arr [ i ] ; } return max ( minA * minB * maxA , maxA * maxB * maxC ) ; } int main ( ) { int arr [ ] = { 1 , -4 , 3 , -6 , 7 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Triplet ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMax ( int arr [ ] [ 3 ] , int n , int q ) { int maxi = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { maxi = max ( maxi , arr [ i ] [ q ] ) ; } return maxi ; } void sortDatesUtil ( int arr [ ] [ 3 ] , int n , int q ) { int maxi = getMax ( arr , n , q ) ; int p = 1 ; while ( maxi > 0 ) { int cnt [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { cnt [ ( arr [ i ] [ q ] / p ) % 10 ] ++ ; } for ( int i = 1 ; i < 10 ; i ++ ) { cnt [ i ] += cnt [ i - 1 ] ; } int ans [ n ] [ 3 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int lastDigit = ( arr [ i ] [ q ] / p ) % 10 ; for ( int j = 0 ; j < 3 ; j ++ ) { ans [ cnt [ lastDigit ] - 1 ] [ j ] = arr [ i ] [ j ] ; } cnt [ lastDigit ] -- ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { arr [ i ] [ j ] = ans [ i ] [ j ] ; } } p *= 10 ; maxi /= 10 ; } } void sortDates ( int dates [ ] [ 3 ] , int n ) { sortDatesUtil ( dates , n , 0 ) ; sortDatesUtil ( dates , n , 1 ) ; sortDatesUtil ( dates , n , 2 ) ; } void printArr ( int arr [ ] [ 3 ] , int n ) { for ( int i = 0 ; i < 6 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { cout << arr [ i ] [ j ] << " ▁ " ; } cout << endl ; } } int main ( ) { int dates [ ] [ 3 ] = { { 20 , 1 , 2014 } , { 25 , 3 , 2010 } , { 3 , 12 , 2000 } , { 18 , 11 , 2000 } , { 19 , 4 , 2015 } , { 9 , 7 , 2005 } } ; int n = sizeof ( dates ) / sizeof ( dates [ 0 ] ) ; sortDates ( dates , n ) ; cout << " Sorted Dates " printArr ( dates , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMoves ( vector < vector < char > > a , vector < vector < char > > b , int K ) { int n = a . size ( ) , m = a [ 0 ] . size ( ) ; int cntOperations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { cntOperations ++ ; if ( i + K - 1 >= n j + K - 1 >= m ) { return -1 ; } for ( int p = 0 ; p <= K - 1 ; p ++ ) { for ( int q = 0 ; q <= K - 1 ; q ++ ) { if ( a [ i + p ] [ j + q ] == '0' ) { a [ i + p ] [ j + q ] = '1' ; } else { a [ i + p ] [ j + q ] = '0' ; } } } } } } return cntOperations ; } int main ( ) { vector < vector < char > > A = { { '1' , '0' , '0' } , { '0' , '0' , '0' } , { '0' , '0' , '0' } } ; vector < vector < char > > B = { { '0' , '0' , '0' } , { '0' , '0' , '0' } , { '0' , '0' , '0' } } ; int K = 3 ; cout << minMoves ( A , B , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxConsecutiveCnt ( vector < int > arr ) { int X = 0 ; sort ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] <= ( X + 1 ) ) { X = X + arr [ i ] ; } else { break ; } } return X + 1 ; } int main ( ) { vector < int > arr = { 1 , 1 , 1 , 4 } ; cout << maxConsecutiveCnt ( arr ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int maxLength ( vector < int > & A , vector < int > & B ) { int n = A . size ( ) ; int maxSize = 0 ; unordered_map < int , int > pre ; int diff = 0 ; pre [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { diff += ( A [ i ] - B [ i ] ) ; if ( pre . find ( diff ) == pre . end ( ) ) { pre = i + 1 ; } else { maxSize = max ( maxSize , i - pre + 1 ) ; } } return maxSize ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 4 } ; vector < int > B = { 4 , 3 , 2 , 1 } ; cout << maxLength ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int prefix_sum_row [ 50 ] [ 51 ] ; int prefix_sum_col [ 51 ] [ 50 ] ; bool is_valid ( int r , int c , int size , vector < vector < int > > & grid ) { int r_end = r + size , c_end = c + size ; int sum = 0 ; for ( int i = r , j = c ; i < r_end ; i ++ , j ++ ) { sum += grid [ i ] [ j ] ; } for ( int i = r ; i < r_end ; i ++ ) { if ( prefix_sum_row [ i ] [ c_end ] - prefix_sum_row [ i ] != sum ) { return false ; } } for ( int i = c ; i < c_end ; i ++ ) { if ( prefix_sum_col [ r_end ] [ i ] - prefix_sum_col [ r ] [ i ] != sum ) { return false ; } } int ad_sum = 0 ; for ( int i = r , j = c_end - 1 ; i < r_end ; i ++ , j -- ) { ad_sum += grid [ i ] [ j ] ; } return ad_sum == sum ; } int largestSquareValidMatrix ( vector < vector < int > > & grid ) { int m = grid . size ( ) , n = grid [ 0 ] . size ( ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { prefix_sum_row [ i ] [ j ] = prefix_sum_row [ i ] [ j - 1 ] + grid [ i ] [ j - 1 ] ; } } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_sum_col [ i ] [ j ] = prefix_sum_col [ i - 1 ] [ j ] + grid [ i - 1 ] [ j ] ; } } for ( int size = min ( m , n ) ; size > 1 ; size -- ) { for ( int i = 0 ; i <= m - size ; i ++ ) { for ( int j = 0 ; j <= n - size ; j ++ ) { if ( is_valid ( i , j , size , grid ) ) { return size ; } } } } return 1 ; } int main ( ) { vector < vector < int > > grid = { { 7 , 1 , 4 , 5 , 6 } , { 2 , 5 , 1 , 6 , 4 } , { 1 , 5 , 4 , 3 , 2 } , { 1 , 2 , 7 , 3 , 4 } } ; cout << largestSquareValidMatrix ( grid ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumPossibleProduct ( int K ) { int res = 1 ; int range = ( 1 << K ) - 1 ; for ( int i = 0 ; i < K ; i ++ ) { res *= ( range - 1 ) ; } res *= range ; return res ; } int main ( ) { int K = 3 ; cout << minimumPossibleProduct ( K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximizeSubset ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int maxSize = 0 ; int i = 0 ; int j = i + 2 ; while ( i < N - 2 ) { while ( arr [ i ] + arr [ i + 1 ] > arr [ j ] ) { j ++ ; } maxSize = max ( maxSize , j - i ) ; i ++ ; j = max ( j , i + 2 ) ; } return maxSize ; } int main ( ) { int arr [ ] = { 2 , 7 , 4 , 1 , 6 , 9 , 5 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximizeSubset ( arr , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxShiftArrayValue ( int arr [ ] , int cap [ ] , int N ) { int sumVals = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumVals += arr [ i ] ; } int maxCapacity = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxCapacity = max ( cap [ i ] , maxCapacity ) ; } return min ( maxCapacity , sumVals ) ; } int main ( ) { int arr [ ] = { 2 , 3 } ; int cap [ ] = { 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxShiftArrayValue ( arr , cap , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Find ( vector < int > & parent , int a ) { return parent [ a ] = ( parent [ a ] == a ? a : Find ( parent , parent [ a ] ) ) ; } void Union ( vector < int > & parent , vector < int > & rank , vector < int > & minVal , int a , int b ) { a = Find ( parent , a ) ; b = Find ( parent , b ) ; if ( rank [ a ] == rank [ b ] ) rank [ a ] ++ ; if ( rank [ a ] > rank [ b ] ) { parent [ b ] = a ; if ( minVal [ a ] >= 0 && minVal [ b ] >= 0 ) { minVal [ a ] = min ( minVal [ a ] , minVal [ b ] ) ; } else if ( minVal [ a ] >= 0 && minVal [ b ] < 0 ) { minVal [ a ] = minVal [ a ] ; } else if ( minVal [ a ] < 0 && minVal [ b ] >= 0 ) { minVal [ a ] = minVal [ b ] ; } else { minVal [ a ] = max ( minVal [ a ] , minVal [ b ] ) ; } } else { parent [ a ] = b ; if ( minVal [ a ] >= 0 && minVal [ b ] >= 0 ) { minVal [ b ] = min ( minVal [ a ] , minVal [ b ] ) ; } else if ( minVal [ a ] >= 0 && minVal [ b ] < 0 ) { minVal [ b ] = minVal [ a ] ; } else if ( minVal [ a ] < 0 && minVal [ b ] >= 0 ) { minVal [ b ] = minVal [ b ] ; } else { minVal [ b ] = max ( minVal [ a ] , minVal [ b ] ) ; } } } void findMinCost ( vector < pair < int , int > > & G , vector < int > & cost , int N , int M ) { vector < int > parent ( N + 1 ) ; vector < int > rank ( N + 1 , 0 ) ; vector < int > minVal ( N + 1 ) ; for ( int i = 1 ; i < N + 1 ; i ++ ) { parent [ i ] = i ; minVal [ i ] = cost [ i - 1 ] ; } for ( auto i : G ) { Union ( parent , rank , minVal , i . first , i . second ) ; } set < int > s ; for ( int i = 1 ; i < N + 1 ; i ++ ) { s . insert ( Find ( parent , i ) ) ; } pair < int , int > min = { 0 , INT_MAX } ; bool flag = false ; for ( auto i : s ) { if ( minVal [ i ] < 0 ) { flag = true ; } if ( min . second > minVal [ i ] ) { min = { i , minVal [ i ] } ; } } int minCost = 0 ; if ( ! flag || ( flag && s . size ( ) == 1 ) ) { for ( auto i : s ) { if ( i != min . first ) { minCost += ( minVal [ i ] + min . second ) ; } } cout << minCost << endl ; } else { cout << -1 << endl ; } } int main ( ) { int N = 6 ; vector < pair < int , int > > G = { { 3 , 1 } , { 2 , 3 } , { 2 , 1 } , { 4 , 5 } , { 5 , 6 } , { 6 , 4 } } ; vector < int > cost { 2 , 1 , 5 , 3 , 2 , 9 } ; int M = G . size ( ) ; findMinCost ( G , cost , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPoints ( int D ) { int count = 0 ; for ( int x = 1 ; x * x < D * D ; x ++ ) { int y = ( int ) sqrt ( double ( D * D - x * x ) ) ; if ( x * x + y * y == D * D ) { count += 4 ; } } count += 4 ; return count ; } int main ( ) { int D = 5 ; cout << countPoints ( D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTotalDistance ( string S , int N ) { vector < int > prefixDistance ( N ) ; vector < int > suffixDistance ( N ) ; int cnt = 0 ; bool haveOne = false ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] == '1' ) { haveOne = true ; cnt = 0 ; prefixDistance [ i ] = 0 ; } else if ( haveOne ) { cnt ++ ; prefixDistance [ i ] = cnt ; } else prefixDistance [ i ] = INT_MAX ; } haveOne = false ; for ( int i = N - 1 ; i >= 0 ; -- i ) { if ( S [ i ] == '1' ) { haveOne = true ; cnt = 0 ; suffixDistance [ i ] = 0 ; } else if ( haveOne ) { cnt ++ ; suffixDistance [ i ] = cnt ; } else suffixDistance [ i ] = INT_MAX ; } int sum = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] == '0' ) { sum += min ( prefixDistance [ i ] , suffixDistance [ i ] ) ; } } cout << sum << endl ; } int main ( ) { string S = "100100" ; int N = S . length ( ) ; findTotalDistance ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimizeCost ( int A , int B , int C ) { int ans = A + B + C ; for ( int i = 1 ; i <= 2 * C ; i ++ ) { int j = 0 ; while ( i * j <= 2 * C ) { ans = min ( ans , abs ( A - i ) + abs ( B - j ) + abs ( i * j - C ) ) ; j ++ ; } } return ans ; } int main ( ) { int A = 19 , B = 28 , C = 522 ; cout << minimizeCost ( A , B , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double averageSetBits ( int N , int K , int arr [ ] ) { double p = N ; double q = 0 ; for ( int i = 0 ; i < K ; i ++ ) { double _p = p , _q = q ; p = _p - _p * arr [ i ] / N + _q * arr [ i ] / N ; q = _q - _q * arr [ i ] / N + _p * arr [ i ] / N ; } return p ; } int main ( ) { int N = 5 ; int arr [ ] = { 1 , 2 , 3 } ; int K = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << setprecision ( 10 ) << averageSetBits ( N , K , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateString ( int k1 , int k2 , string s ) { int C1s = 0 , C0s = 0 ; int flag = 0 ; vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { C0s ++ ; if ( ( i + 1 ) % k1 != 0 && ( i + 1 ) % k2 != 0 ) { pos . push_back ( i ) ; } } else { C1s ++ ; } if ( C0s >= C1s ) { if ( pos . size ( ) == 0 ) { cout << -1 ; flag = 1 ; break ; } else { int k = pos . back ( ) ; s [ k ] = '1' ; C0s -- ; C1s ++ ; pos . pop_back ( ) ; } } } if ( flag == 0 ) { cout << s ; } } int main ( ) { int K1 = 2 , K2 = 4 ; string S = "11000100" ; generateString ( K1 , K2 , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRange ( int arr [ ] , int N , int K ) { int L = INT_MIN ; int R = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { int l = ( int ) ceil ( 1.0 * arr [ i ] * K / ( i + 1 ) ) ; int r = ( int ) ceil ( ( 1.0 + arr [ i ] ) * K / ( i + 1 ) ) - 1 ; L = max ( L , l ) ; R = min ( R , r ) ; } cout << L << " ▁ " << R ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 9 , 11 } ; int K = 10 ; int N = sizeof ( arr ) / sizeof ( int ) ; findRange ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximizeProduct ( int N ) { int MSB = ( int ) log2 ( N ) ; int X = 1 << MSB ; int Y = N - ( 1 << MSB ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) { X += 1 << i ; Y += 1 << i ; } } cout << X << " ▁ " << Y ; } int main ( ) { int N = 45 ; maximizeProduct ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructPermutation ( string S , int N ) { int ans [ N ] ; ans [ 0 ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) { if ( S [ i - 1 ] == '0' ) { ans [ i ] = i + 1 ; } else { ans [ i ] = ans [ i - 1 ] ; } for ( int j = 0 ; j < i ; ++ j ) { if ( ans [ j ] >= ans [ i ] ) { ans [ j ] ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) { cout << ans [ i ] ; if ( i != N - 1 ) { cout << " ▁ " ; } } } int main ( ) { string S = "100101" ; constructPermutation ( S , S . length ( ) + 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long KthSolution ( long long X , long long K ) { long long ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ! ( X & ( 1LL << i ) ) ) { if ( K & 1 ) { ans |= ( 1LL << i ) ; } K >>= 1 ; if ( ! K ) { break ; } } } return ans ; } int main ( ) { long long X = 10 , K = 5 ; cout << KthSolution ( X , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumMoves ( int A [ ] , int B [ ] , int N ) { int ans = 0 ; int sum_A = 0 , sum_B = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum_A += A [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { sum_B += B [ i ] ; } if ( sum_A != sum_B ) { return -1 ; } int i = 0 ; while ( i < N ) { if ( A [ i ] > B [ i ] ) { int temp = A [ i ] - B [ i ] ; int j = i - 1 ; while ( j >= 0 && temp > 0 ) { if ( B [ j ] > A [ j ] ) { int cnt = min ( temp , ( B [ j ] - A [ j ] ) ) ; A [ j ] += cnt ; temp -= cnt ; ans += ( cnt * abs ( j - i ) ) ; } j -- ; } if ( temp > 0 ) { int j = i + 1 ; while ( j < N && temp > 0 ) { if ( B [ j ] > A [ j ] ) { int cnt = min ( temp , ( B [ j ] - A [ j ] ) ) ; A [ j ] += cnt ; temp -= cnt ; ans += ( cnt * abs ( j - i ) ) ; } j ++ ; } } } i ++ ; } return ans ; } int main ( ) { int A [ ] = { 1 , 5 , 7 } ; int B [ ] = { 13 , 0 , 0 } ; int N = sizeof ( A ) / sizeof ( int ) ; cout << minimumMoves ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int possibleReachingSequence ( int X , int D , int T ) { if ( X < T ) { cout << " NO " ; return 0 ; } if ( T * D < X ) { cout << " NO " ; return 0 ; } if ( ( X - T ) % ( D - 1 ) == 0 ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; } int main ( ) { int X = 10 , D = 3 , T = 6 ; possibleReachingSequence ( X , D , T ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int arrayDivisionByTwo ( int arr [ ] , int n ) { int cnt = 0 ; int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { cnt = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; cnt ++ ; } ans = min ( ans , cnt ) ; } return ans ; } int main ( ) { int arr [ ] = { 8 , 12 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << arrayDivisionByTwo ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMinInteger ( int P , int Q , int N ) { if ( Q > P ) { swap ( P , Q ) ; } if ( Q == 0 && ( P == 0 N % P != 0 ) ) { cout << " Not ▁ Possible " ; return ; } int count_P = 0 , count_Q = 0 ; while ( N > 0 ) { if ( N % P == 0 ) { count_P += N / P ; N = 0 ; } else { N = N - Q ; count_Q ++ ; } } if ( N == 0 ) { for ( int i = 0 ; i < count_Q ; i ++ ) cout << Q ; for ( int i = 0 ; i < count_P ; i ++ ) cout << P ; } else { cout << " Not ▁ Possible " ; } } int main ( ) { int N = 32 ; int P = 7 ; int Q = 4 ; printMinInteger ( P , Q , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minPushes ( int N , int K , vector < int > arr ) { vector < int > dp ( 100000 , -1 ) ; dp [ N ] = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { for ( int xx = 0 ; xx < 100000 ; xx ++ ) { int x = xx ; if ( dp [ x ] == -1 ) continue ; int next = ( x + arr [ i ] ) % 100000 ; while ( dp [ next ] == -1 dp [ next ] > dp [ x ] + 1 ) { dp [ next ] = dp [ x ] + 1 ; x = next ; next = ( next + arr [ i ] ) % 100000 ; } } } return dp [ K ] ; } int main ( ) { int N = 99880 , K = 89 ; vector < int > arr { 100 , 3 } ; cout << minPushes ( N , K , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minApples ( int M , int K , int N , int S , int W , int E ) { if ( M <= S * K ) return M ; else if ( M <= S * K + E + W ) return S * K + ( M - S * K ) * K ; else return -1 ; } int main ( ) { int M = 10 ; int K = 15 ; int N = 0 ; int S = 1 ; int W = 0 ; int E = 0 ; int ans = minApples ( M , K , N , S , W , E ) ; cout << ans << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumOperations ( int A [ ] , int N ) { int cur_prefix_1 = 0 ; int parity = -1 ; int minOperationsCase1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_prefix_1 += A [ i ] ; if ( cur_prefix_1 == 0 parity * cur_prefix_1 < 0 ) { minOperationsCase1 += abs ( parity - cur_prefix_1 ) ; cur_prefix_1 = parity ; } parity *= -1 ; } int cur_prefix_2 = 0 ; parity = 1 ; int minOperationsCase2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_prefix_2 += A [ i ] ; if ( cur_prefix_2 == 0 parity * cur_prefix_2 < 0 ) { minOperationsCase2 += abs ( parity - cur_prefix_2 ) ; cur_prefix_2 = parity ; } parity *= -1 ; } return min ( minOperationsCase1 , minOperationsCase2 ) ; } int main ( ) { int A [ ] = { 1 , -3 , 1 , 0 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minimumOperations ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minProductUtil ( int R1 , int B1 , int R2 , int B2 , int M ) { int x = min ( R1 - B1 , M ) ; M -= x ; R1 -= x ; if ( M > 0 ) { int y = min ( R2 - B2 , M ) ; M -= y ; R2 -= y ; } return R1 * R2 ; } int minProduct ( int R1 , int B1 , int R2 , int B2 , int M ) { int res1 = minProductUtil ( R1 , B1 , R2 , B2 , M ) ; int res2 = minProductUtil ( R2 , B2 , R1 , B1 , M ) ; return min ( res1 , res2 ) ; } int main ( ) { int R1 = 21 , B1 = 10 , R2 = 13 , B2 = 11 , M = 3 ; cout << ( minProduct ( R1 , B1 , R2 , B2 , M ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAmount ( int n , int k , int arr [ ] ) { int A [ 1000001 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { A [ arr [ i ] ] ++ ; } int j = 0 ; for ( int i = 0 ; i < 1000001 ; i ++ ) { while ( A [ i ] != 0 ) { arr [ j ++ ] = i ; A [ i ] -- ; } } long long int ans = 0 ; int mod = 1e9 + 7 ; int i = n - 1 ; j = n - 2 ; while ( k > 0 && j >= 0 ) { if ( arr [ i ] > arr [ j ] ) { ans = ans + min ( k , ( i - j ) ) * arr [ i ] ; k = k - ( i - j ) ; arr [ i ] -- ; } else { while ( j >= 0 && arr [ j ] == arr [ i ] ) j -- ; if ( j < 0 ) break ; ans = ans + min ( k , ( i - j ) ) * arr [ i ] ; k = k - ( i - j ) ; arr [ i ] -- ; } } while ( k > 0 && arr [ i ] != 0 ) { ans = ans + min ( n , k ) * arr [ i ] ; k -= n ; arr [ i ] -- ; } ans = ans % mod ; int x = ans ; return x ; } int main ( ) { int n = 5 ; int k = 3 ; int arr [ n ] = { 4 , 3 , 6 , 2 , 4 } ; int ans = maxAmount ( n , k , arr ) ; cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxAverage ( int A [ ] , int N , int X , int Y ) { sort ( A , A + N ) ; int sum = 0 ; double res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count ++ ; if ( count == X ) { if ( N - i - 1 < X ) { i ++ ; int cnt = 0 ; while ( i < N ) { cnt ++ ; sum += A [ i ] ; i ++ ; } X = X + cnt ; res += ( double ) sum / double ( X ) ; break ; } res += ( double ) sum / double ( X ) ; sum = 0 ; count = 0 ; } } cout << fixed << setprecision ( 2 ) << res << " STRNEWLINE " ; } int main ( ) { int A [ ] = { 4 , 10 , 6 , 5 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int X = 2 , Y = 3 ; maxAverage ( A , N , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isAdjChar ( string & s ) { for ( int i = 0 ; i < s . size ( ) - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) return true ; } return false ; } void rearrangeStringUtil ( string & S , int N ) { int i = 0 , j = 1 , k = 2 ; while ( k < N ) { if ( S [ i ] != S [ j ] ) { i ++ ; j ++ ; if ( j == k ) { k ++ ; } } else { if ( S [ j ] == S [ k ] ) { k ++ ; } else { swap ( S [ k ] , S [ j ] ) ; i ++ ; j ++ ; if ( j == k ) { k ++ ; } } } } } string rearrangeString ( string & S , int N ) { if ( isAdjChar ( S ) == false ) { return S ; } if ( S . size ( ) == 2 ) return " - 1" ; rearrangeStringUtil ( S , N ) ; reverse ( S . begin ( ) , S . end ( ) ) ; rearrangeStringUtil ( S , N ) ; if ( isAdjChar ( S ) == false ) { return S ; } return " - 1" ; } int main ( ) { string S = " aaabc " ; int N = S . length ( ) ; cout << rearrangeString ( S , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void maxTime ( string s ) { if ( s [ 0 ] == ' ? ' ) { if ( s [ 1 ] <= '3' s [ 1 ] == ' ? ' ) s [ 0 ] = '2' ; else s [ 0 ] = '1' ; } if ( s [ 1 ] == ' ? ' ) { if ( s [ 0 ] != '2' ) { s [ 1 ] = 9 ; } else s [ 1 ] = 3 ; } if ( s [ 3 ] == ' ? ' ) s [ 3 ] = '5' ; if ( s [ 4 ] == ' ? ' ) s [ 4 ] = '9' ; cout << s << endl ; } int main ( ) { string S = " ? 4:5 ? " ; maxTime ( S ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void maxGcd ( int a , int b ) { cout << abs ( a - b ) ; } int main ( ) { int a = 2231 ; int b = 343 ; maxGcd ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printBinaryString ( int arr [ ] [ 3 ] , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 ) { cout << 0 ; } else { cout << 1 ; } } } int main ( ) { int N = 5 , M = 3 ; int arr [ ] [ 3 ] = { { 1 , 3 } , { 2 , 4 } , { 2 , 5 } } ; printBinaryString ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinCost ( int days [ ] , int cost [ ] , int N ) { int size = days [ N - 1 ] + 1 ; int dp [ size ] ; dp [ size - 1 ] = min ( cost [ 0 ] , min ( cost [ 1 ] , cost [ 2 ] ) ) ; int ptr = N - 2 ; for ( int i = size - 2 ; i > 0 ; i -- ) { if ( ptr >= 0 && days [ ptr ] == i ) { int val1 = dp [ i + 1 ] + cost [ 0 ] ; int val2 = cost [ 1 ] + ( ( i + 7 >= size ) ? 0 : dp [ i + 7 ] ) ; int val3 = cost [ 2 ] + ( ( i + 30 >= size ) ? 0 : dp [ i + 30 ] ) ; dp [ i ] = min ( val1 , min ( val2 , val3 ) ) ; ptr -- ; } else { dp [ i ] = dp [ i + 1 ] ; } } return dp [ 1 ] ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 7 , 8 , 10 , 17 } ; int cost [ ] = { 3 , 8 , 20 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinCost ( arr , cost , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minElements ( int arr [ ] , int N , int K ) { int count = 0 ; long long requiredNum = 1 ; int i = 0 ; while ( requiredNum <= K ) { if ( i < N && requiredNum >= arr [ i ] ) { requiredNum += arr [ i ] ; i ++ ; } else { count ++ ; requiredNum += requiredNum ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 3 } ; int K = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minElements ( arr , N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumCount ( int arr [ ] , int N ) { int odd = 0 ; int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 ) odd ++ ; else even ++ ; } if ( odd and even ) return N - 2 ; else return N - 1 ; } int main ( ) { int arr [ ] = { 9 , 13 , 15 , 3 , 16 , 9 , 13 , 18 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumCount ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minPossibleValue ( int N , int K , int X ) { for ( int i = 1 ; i <= N ; i ++ ) { if ( X <= K ) { X = X * 2 ; } else { X = X + K ; } } return X ; } int main ( ) { int N = 7 , K = 4 , X = 1 ; cout << minPossibleValue ( N , K , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMissingValue ( int arr [ ] , int N ) { int minE = INT_MAX , maxE = INT_MIN ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == -1 && arr [ i + 1 ] != -1 ) { minE = min ( minE , arr [ i + 1 ] ) ; maxE = max ( maxE , arr [ i + 1 ] ) ; } if ( arr [ i ] != -1 && arr [ i + 1 ] == -1 ) { minE = min ( minE , arr [ i ] ) ; maxE = max ( maxE , arr [ i ] ) ; } } if ( minE == INT_MAX and maxE == INT_MIN ) { cout << "0" ; } else { cout << ( minE + maxE ) / 2 ; } } int main ( ) { int arr [ ] = { 1 , -1 , -1 , -1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMissingValue ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLastElement ( int N , vector < int > A ) { int l = A . size ( ) ; int j = 0 ; while ( N > l * ( pow ( 2 , j ) ) ) { N = N - l * pow ( 2 , j ) ; j += 1 ; } int k = 1 ; int r = pow ( 2 , j ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( N > r * i ) k += 1 ; } for ( int i = 0 ; i < l ; i ++ ) { if ( i + 1 == k ) { cout << ( A [ i ] ) ; return ; } } } int main ( ) { int K = 7 ; vector < int > A = { 1 , 2 , 3 } ; findLastElement ( K , A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int findMaxD ( int arr [ ] , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = abs ( arr [ i ] - K ) ; } int D = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { D = gcd ( D , arr [ i ] ) ; } return D ; } int main ( ) { int arr [ ] = { 1 , 7 , 11 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << findMaxD ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxOperations ( string S , int N ) { int X = 0 ; int Y = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '0' ) break ; Y ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '1' ) break ; X ++ ; } if ( N == X + Y ) return 0 ; return N - ( X + Y ) - 1 ; } int main ( ) { string S = "001111" ; int N = S . length ( ) ; cout << maxOperations ( S , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSum ( string S , int N , int K ) { int sum = 0 ; int freq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ int ( S [ i ] ) ] ++ ; } sort ( freq , freq + 256 , greater < int > ( ) ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( K > freq [ i ] ) { sum += freq [ i ] * freq [ i ] ; K -= freq [ i ] ; } else { sum += freq [ i ] * K ; break ; } } return sum ; } int main ( ) { string S = " GEEKSFORGEEKS " ; int K = 10 ; int N = S . length ( ) ; cout << maximumSum ( S , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100 ] [ 10 ] [ 10 ] ; int countOfNumbers ( int digit , int prev1 , int prev2 , int n ) { if ( digit == n + 1 ) { return 1 ; } int & val = dp [ digit ] [ prev1 ] [ prev2 ] ; if ( val != -1 ) { return val ; } val = 0 ; if ( digit == 1 ) { for ( int i = ( n == 1 ? 0 : 1 ) ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } else if ( digit == 2 ) { for ( int i = 0 ; i <= 9 ; ++ i ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } else { int diff = abs ( prev2 - prev1 ) ; for ( int i = 0 ; i <= 9 ; ++ i ) { if ( abs ( prev1 - i ) <= diff ) { val += countOfNumbers ( digit + 1 , i , prev1 , n ) ; } } } return val ; } int countNumbersUtil ( int N ) { memset ( dp , -1 , sizeof dp ) ; cout << countOfNumbers ( 1 , 0 , 0 , N ) ; } int main ( ) { int N = 3 ; countNumbersUtil ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSum ( int arr [ ] , int n ) { int sum = 0 ; int max_neg = INT_MAX ; int tempsum = 0 ; int small = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; small = min ( small , arr [ i ] ) ; if ( arr [ i ] > 0 ) { tempsum = 0 ; } else { tempsum += arr [ i ] ; } max_neg = min ( max_neg , tempsum ) ; } if ( max_neg == 0 ) { max_neg = small ; } cout << sum - max_neg ; } int main ( ) { int arr [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void convertXintoY ( int X , int Y ) { while ( Y > X ) { if ( Y % 2 == 0 ) Y /= 2 ; else if ( Y % 10 == 1 ) Y /= 10 ; else break ; } if ( X == Y ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int X = 100 , Y = 40021 ; convertXintoY ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumOperation ( string a , string b ) { int n = a . length ( ) ; int i = 0 ; int minoperation = 0 ; while ( i < n ) { if ( a [ i ] == b [ i ] ) { i = i + 1 ; continue ; } else if ( a [ i ] == b [ i + 1 ] && a [ i + 1 ] == b [ i ] && i < n - 1 ) { minoperation ++ ; i = i + 2 ; } else if ( a [ i ] != b [ i ] ) { minoperation ++ ; i = i + 1 ; } else { ++ i ; } } cout << minoperation ; } int main ( ) { string a = "10010010" , b = "00001000" ; minimumOperation ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinOperations ( int arr [ ] , int N , int K ) { int operations = 0 ; for ( int i = 0 ; i < K ; i ++ ) { unordered_map < int , int > freq ; for ( int j = i ; j < N ; j += K ) freq [ arr [ j ] ] ++ ; int max1 = 0 , num ; for ( auto x : freq ) { if ( x . second > max1 ) { max1 = x . second ; num = x . first ; } } for ( auto x : freq ) { if ( x . first != num ) operations += x . second ; } } cout << operations ; } int main ( ) { int arr [ ] = { 3 , 4 , 3 , 5 , 6 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMinOperations ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPermutations ( int N ) { vector < vector < int > > adj ( 105 ) ; int indeg = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i == j ) continue ; int sum = i + j ; if ( ceil ( sqrt ( sum ) ) == floor ( sqrt ( sum ) ) ) { adj [ i ] . push_back ( j ) ; } } if ( adj [ i ] . size ( ) == 1 ) indeg ++ ; } if ( indeg == 0 ) return N ; else if ( indeg <= 2 ) return 2 ; else return 0 ; } int main ( ) { int N = 17 ; cout << countPermutations ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void makeList ( int N , int K ) { int list [ N ] ; int left = 1 ; int right = N ; for ( int i = 0 ; i < N ; i ++ ) { if ( K % 2 == 0 ) { list [ i ] = left ; left = left + 1 ; } else { list [ i ] = right ; right = right - 1 ; } if ( K > 1 ) K -- ; } for ( int i = 0 ; i < N ; i ++ ) { cout << list [ i ] << " ▁ " ; } } int main ( ) { int N = 6 ; int K = 3 ; makeList ( N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxDiamonds ( int A [ ] , int N , int K ) { priority_queue < int > pq ; for ( int i = 0 ; i < N ; i ++ ) { pq . push ( A [ i ] ) ; } int ans = 0 ; while ( ! pq . empty ( ) && K -- ) { int top = pq . top ( ) ; pq . pop ( ) ; ans += top ; top = top / 2 ; pq . push ( top ) ; } cout << ans ; } int main ( ) { int A [ ] = { 2 , 1 , 7 , 4 , 2 } ; int K = 3 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maxDiamonds ( A , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long largestNumber ( int N ) { if ( N > 45 ) return -1 ; int num = 0 , digit = 9 ; while ( N > 0 && digit > 0 ) { if ( digit <= N ) { num *= 10 ; num += digit ; N -= digit ; } digit -= 1 ; } return num * 10 ; } int main ( ) { int N = 25 ; cout << largestNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSum ( int A [ ] , int N , string S ) { int mul = 0 ; for ( int i = 0 ; i < ( int ) S . size ( ) ; i ++ ) { if ( S [ i ] == ' * ' ) mul += 1 ; } int ans = 1000000 ; for ( int i = 0 ; i < ( 1 << ( N - 1 ) ) ; i ++ ) { int cnt = 0 ; vector < char > v ; for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( ( 1 << j ) & ( i ) ) { cnt += 1 ; v . push_back ( ' * ' ) ; } else { v . push_back ( ' + ' ) ; } } if ( cnt == mul ) { deque < int > d ; d . push_back ( A [ 0 ] ) ; for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( v [ j ] == ' * ' ) { int x = d . back ( ) ; d . pop_back ( ) ; x = x * A [ j + 1 ] ; d . push_back ( x ) ; } else { d . push_back ( A [ j + 1 ] ) ; } } int sum = 0 ; while ( d . size ( ) > 0 ) { int x = d . front ( ) ; sum += x ; d . pop_front ( ) ; } ans = min ( ans , sum ) ; } } return ans ; } int main ( ) { int A [ ] = { 2 , 2 , 2 , 2 } ; string S = " * * + " ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minimumSum ( A , N , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumOfMedians ( int arr [ ] , int N , int K ) { int selectMedian = ( K + 1 ) / 2 ; int totalArrays = N / K ; int minSum = 0 ; int i = selectMedian - 1 ; while ( i < N and totalArrays != 0 ) { minSum = minSum + arr [ i ] ; i = i + selectMedian ; totalArrays -- ; } cout << minSum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 2 ; sumOfMedians ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateString ( int K ) { string s = " " ; for ( int i = 97 ; i < 97 + K ; i ++ ) { s = s + char ( i ) ; for ( int j = i + 1 ; j < 97 + K ; j ++ ) { s += char ( i ) ; s += char ( j ) ; } } s += char ( 97 ) ; cout << s ; } int main ( ) { int K = 4 ; generateString ( K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumValue ( int N , int K ) { return ceil ( ( double ) K / ( double ) N ) ; } int main ( ) { int N = 4 , K = 50 ; cout << minimumValue ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSizeArr ( int A [ ] , int N , int K ) { int leftTaken = N , rightTaken = N ; int leftSum = 0 , rightSum = 0 ; for ( int left = -1 ; left < N ; left ++ ) { if ( left != -1 ) leftSum += A [ left ] ; rightSum = 0 ; for ( int right = N - 1 ; right > left ; right -- ) { rightSum += A [ right ] ; if ( leftSum + rightSum == K ) { if ( leftTaken + rightTaken > ( left + 1 ) + ( N - right ) ) { leftTaken = left + 1 ; rightTaken = N - right ; } break ; } if ( leftSum + rightSum > K ) break ; } } if ( leftTaken + rightTaken <= N ) { for ( int i = 0 ; i < leftTaken ; i ++ ) cout << A [ i ] << " ▁ " ; for ( int i = 0 ; i < rightTaken ; i ++ ) cout << A [ N - i - 1 ] << " ▁ " ; } else cout << -1 ; } int main ( ) { int N = 7 ; int A [ ] = { 3 , 2 , 1 , 1 , 1 , 1 , 3 } ; int K = 10 ; minSizeArr ( A , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; void minModulo ( int L , int R , int N ) { if ( R - L < N ) { int ans = INT_MAX ; for ( ll i = L ; i <= R ; i ++ ) for ( ll j = L ; j <= R ; j ++ ) if ( i != j ) ans = min ( 0ll + ans , ( i * j ) % N ) ; cout << ans ; } else { cout << 0 ; } } int main ( ) { int L = 6 , R = 10 , N = 2019 ; minModulo ( L , R , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { count ++ ; if ( N / i != i ) { count ++ ; } } } return count ; } int main ( ) { int N = 10 ; cout << countNumbers ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSize ( int a [ ] , int k , int n ) { int low = 1 ; int high = * max_element ( a , a + n ) ; int ans = -1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int count = 0 ; for ( int c = 0 ; c < n ; c ++ ) { count += a / mid ; } if ( count >= k ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 9 } ; int K = 6 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( maximumSize ( arr , K , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxValueOfEquation ( vector < vector < int > > & arr , int K ) { priority_queue < vector < int > > pq ; int res = INT_MIN ; for ( auto point : arr ) { while ( ! pq . empty ( ) && point [ 0 ] - pq . top ( ) [ 1 ] > K ) { pq . pop ( ) ; } if ( ! pq . empty ( ) ) { res = max ( res , pq . top ( ) [ 0 ] + point [ 0 ] + point [ 1 ] ) ; } pq . push ( { point [ 1 ] - point [ 0 ] , point [ 0 ] } ) ; } cout << res ; } int main ( ) { vector < vector < int > > arr = { { 1 , 3 } , { 2 , 0 } , { 5 , 10 } , { 6 , -10 } } ; int K = 1 ; findMaxValueOfEquation ( arr , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int arr [ ] , int n ) { int oddcount = 0 , evencount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) oddcount ++ ; else evencount ++ ; } return min ( oddcount , evencount ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 3 , 1 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long gcd ( long long a , long long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void countDistinctNumbers ( long long A , long long B , long long C ) { long long g = gcd ( A , B ) ; long long count = C / g ; cout << count ; } int main ( ) { long long A = 2 , B = 3 , C = 5 ; countDistinctNumbers ( A , B , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_min ( int N , int C , int K ) { int maximum , minimum ; if ( N == 1 ) { maximum = minimum = C ; } else if ( K >= C ) { maximum = C ; minimum = 0 ; } else { maximum = K ; minimum = 0 ; int remain_candy = C - K ; maximum += remain_candy / N ; minimum = remain_candy / N ; if ( remain_candy % N == N - 1 ) { minimum ++ ; } } cout << " Maximum ▁ = ▁ " << maximum << endl ; cout << " Minimum ▁ = ▁ " << minimum ; return 0 ; } int main ( ) { int N = 4 ; int C = 12 ; int K = 3 ; max_min ( N , C , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findEquation ( int S , int M ) { cout << "1 ▁ " << ( -1 ) * S << " ▁ " << M << endl ; } int main ( ) { int S = 5 , M = 6 ; findEquation ( S , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void shortestSubarray ( int * A , int N ) { int i ; int left_index ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] + 1 != A [ i + 1 ] ) break ; } left_index = i ; int right_index ; for ( i = N - 1 ; i >= 1 ; i -- ) { if ( A [ i ] != A [ i - 1 ] + 1 ) break ; } right_index = i ; int updated_right ; int minLength = min ( N - left_index - 1 , right_index ) ; if ( A [ right_index ] <= A [ left_index ] + 1 ) { updated_right = right_index + A [ left_index ] - A [ right_index ] + 1 ; if ( updated_right < N ) minLength = min ( minLength , updated_right - left_index - 1 ) ; } cout << minLength ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 7 , 4 , 3 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; shortestSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minLength ( string s ) { int i = 0 , j = s . length ( ) - 1 ; for ( ; i < j && s [ i ] == s [ j ] ; ) { char d = s [ i ] ; while ( i <= j && s [ i ] == d ) i ++ ; while ( i <= j && s [ j ] == d ) j -- ; } return j - i + 1 ; } int main ( ) { string S = " aacbcca " ; cout << minLength ( S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } int CountBST ( int H ) { return power ( 2 , H ) ; } int main ( ) { int H = 2 ; cout << CountBST ( H ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rotateString ( int n , int m , string s ) { vector < int > v ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { v . push_back ( i ) ; } } for ( int i = 1 ; i < ( int ) v . size ( ) ; i ++ ) { if ( ( v [ i ] - v [ i - 1 ] - 1 ) > m ) { cnt ++ ; } } if ( v . size ( ) >= 2 && ( n - ( v . back ( ) - v [ 0 ] ) - 1 ) > m ) { cnt ++ ; } if ( cnt <= 1 ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { string S = "101001" ; int M = 1 ; int N = S . size ( ) ; rotateString ( N , M , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumber ( int N ) { int ans [ 6 ] = { 1 , 2 , 4 , 8 , 7 , 5 } ; return ans [ N % 6 ] ; } int main ( ) { int N = 6 ; cout << findNumber ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canBeEmptied ( int A , int B ) { if ( max ( A , B ) > 2 * min ( A , B ) ) { cout << " No " ; return ; } if ( ( A + B ) % 3 == 0 ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int A = 1 , B = 2 ; canBeEmptied ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumIndex ( int N , int B ) { int i = 0 , j = 1 ; int cnt = 0 ; int sum = N * ( N + 1 ) / 2 ; bool flag = false ; while ( cnt < N ) { i += j ; j ++ ; cnt ++ ; if ( i == B ) { flag = true ; break ; } } if ( ! flag ) { cout << sum ; } else cout << sum - 1 ; } int main ( ) { int N = 4 , B = 6 ; maximumIndex ( N , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLongestArray ( int K ) { vector < pair < int , int > > primefactors ; int K_temp = K ; for ( int i = 2 ; i * i <= K ; i ++ ) { int count = 0 ; while ( K_temp % i == 0 ) { K_temp /= i ; count ++ ; } if ( count > 0 ) primefactors . push_back ( { count , i } ) ; } if ( K_temp != 1 ) primefactors . push_back ( { 1 , K_temp } ) ; sort ( primefactors . rbegin ( ) , primefactors . rend ( ) ) ; vector < int > answer ( primefactors [ 0 ] . first , primefactors [ 0 ] . second ) ; answer . back ( ) *= K ; for ( int i = 0 ; i < primefactors [ 0 ] . first ; i ++ ) { answer . back ( ) /= primefactors [ 0 ] . second ; } cout << " { " ; for ( int i = 0 ; i < ( int ) answer . size ( ) ; i ++ ) { if ( i == answer . size ( ) - 1 ) cout << answer [ i ] << " } " ; else cout << answer [ i ] << " , ▁ " ; } } int main ( ) { int K = 4 ; findLongestArray ( K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findScoreSum ( int n ) { int total = 0 ; int prev_monday = 0 , curr_day = 0 ; for ( int day = 1 ; day <= n ; day ++ ) { if ( day % 7 == 1 ) { prev_monday ++ ; curr_day = prev_monday ; } total += curr_day ++ ; } cout << total ; } int main ( ) { int N = 8 ; findScoreSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findScoreSum ( int n ) { int F = n / 7 ; int D = n % 7 ; int fullWeekScore = ( 49 + 7 * F ) * F / 2 ; int lastNonFullWeekScore = ( 2 * F + D + 1 ) * D / 2 ; cout << fullWeekScore + lastNonFullWeekScore ; } int main ( ) { int N = 8 ; findScoreSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( vector < int > a , int n ) { vector < int > prefix_sum ( n ) ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] + a [ i ] ; int mx = -1 ; for ( int subgroupsum : prefix_sum ) { int sum = 0 ; int i = 0 ; int grp_count = 0 ; while ( i < n ) { sum += a [ i ] ; if ( sum == subgroupsum ) { grp_count += 1 ; sum = 0 ; } else if ( sum > subgroupsum ) { grp_count = -1 ; break ; } i += 1 ; } if ( grp_count > mx ) mx = grp_count ; } return n - mx ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 2 , 1 , 3 } ; int N = A . size ( ) ; cout << minSteps ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long maximumNum ( long long X , long long Y , long long N ) { long long num = 0 ; if ( N - N % X + Y <= N ) { num = N - N % X + Y ; } else { num = N - N % X - ( X - Y ) ; } return num ; } int main ( ) { long long X = 10 ; long long Y = 5 ; long long N = 15 ; cout << maximumNum ( X , Y , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getArea ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2 ) ; } int isInside ( vector < vector < int > > triangle , vector < int > point ) { vector < int > A = triangle [ 0 ] ; vector < int > B = triangle [ 1 ] ; vector < int > C = triangle [ 2 ] ; int x = point [ 0 ] ; int y = point [ 1 ] ; int ABC = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) ; int BPC = getArea ( x , y , B [ 0 ] , B [ 1 ] , C [ 0 ] , C [ 1 ] ) ; int APC = getArea ( A [ 0 ] , A [ 1 ] , x , y , C [ 0 ] , C [ 1 ] ) ; int APB = getArea ( A [ 0 ] , A [ 1 ] , B [ 0 ] , B [ 1 ] , x , y ) ; return ABC == ( APC + APB + BPC ) ; } void countPoints ( vector < vector < int > > rectangle , vector < vector < int > > triangle , vector < vector < int > > points ) { int n = rectangle . size ( ) ; vector < vector < int > > triangle1 ; for ( int i = 1 ; i < n ; i ++ ) triangle1 . push_back ( rectangle [ i ] ) ; vector < vector < int > > triangle2 ; for ( int i = 0 ; i < 3 ; i ++ ) triangle2 . push_back ( rectangle [ i ] ) ; vector < vector < int > > triangle3 ; for ( int i = 0 ; i < 2 ; i ++ ) triangle3 . push_back ( rectangle [ i ] ) ; triangle3 . push_back ( rectangle [ 3 ] ) ; vector < vector < int > > triangle4 ; for ( int i = n - 2 ; i < n ; i ++ ) triangle4 . push_back ( rectangle [ i ] ) ; triangle4 . push_back ( rectangle [ 0 ] ) ; int ans = 0 ; for ( auto point : points ) { int condOne = isInside ( triangle1 , point ) ; int condTwo = isInside ( triangle2 , point ) ; int condThree = isInside ( triangle3 , point ) ; int condFour = isInside ( triangle4 , point ) ; int condFive = isInside ( triangle , point ) ; if ( ( condOne condTwo condThree condFour ) && condFive ) ans += 1 ; } cout << ans ; } int main ( ) { vector < vector < int > > rectangle = { { 6 , 5 } , { 2 , 2 } , { 2 , 1 } , { 5 , 5 } } ; vector < vector < int > > points = { { 1 , 1 } , { 6 , 1 } , { 6 , 6 } , { 1 , 6 } } ; vector < vector < int > > triangle = { { 4 , 4 } , { 0 , 4 } , { 0 , -2 } } ; countPoints ( points , triangle , rectangle ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( ! b ) return a ; return GCD ( b , a % b ) ; } int GCDArr ( vector < int > a ) { int ans = a [ 0 ] ; for ( int i : a ) ans = GCD ( ans , i ) ; return ans ; } bool findSubseqUtil ( vector < int > a , vector < int > b , vector < int > & ans , int k , int i ) { if ( ans . size ( ) == a . size ( ) ) { if ( GCDArr ( ans ) == k ) { cout << " [ " ; int m = ans . size ( ) ; for ( int i = 0 ; i < m - 1 ; i ++ ) cout << ans [ i ] << " , ▁ " ; cout << ans [ m - 1 ] << " ] " ; return true ; } else return false ; } ans . push_back ( a [ i ] ) ; bool temp = findSubseqUtil ( a , b , ans , k , i + 1 ) ; if ( temp ) return true ; ans . pop_back ( ) ; ans . push_back ( b [ i ] ) ; temp = findSubseqUtil ( a , b , ans , k , i + 1 ) ; if ( temp ) return true ; ans . pop_back ( ) ; return false ; } void findSubseq ( vector < int > A , vector < int > B , int K , int i ) { vector < int > ans ; findSubseqUtil ( A , B , ans , K , i ) ; if ( ! ans . size ( ) ) cout << -1 ; } int main ( ) { vector < int > A = { 5 , 3 , 6 , 2 , 9 } ; vector < int > B = { 21 , 7 , 14 , 12 , 28 } ; int K = 3 ; findSubseq ( A , B , K , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumOperations ( int A [ ] , int n ) { int cnt = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != ( i + 1 ) ) { if ( ( ( i - 1 ) >= 0 ) && A [ i - 1 ] == ( i + 1 ) ) { cnt ++ ; swap ( A [ i ] , A [ i - 1 ] ) ; } else if ( ( ( i - 2 ) >= 0 ) && A [ i - 2 ] == ( i + 1 ) ) { cnt += 2 ; A [ i - 2 ] = A [ i - 1 ] ; A [ i - 1 ] = A [ i ] ; A [ i ] = i + 1 ; } else { cout << -1 ; return ; } } } cout << cnt ; } int main ( ) { int A [ ] = { 7 , 3 , 2 , 1 , 4 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minimumOperations ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOccurrences ( int n , int x ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( x % i == 0 ) { if ( x / i <= n ) count ++ ; } } cout << count ; } int main ( ) { int N = 7 , X = 12 ; countOccurrences ( N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumCost ( int A [ ] , int B [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int mod_A = B [ i ] % A [ i ] ; int totalCost_A = min ( mod_A , A [ i ] - mod_A ) ; int mod_B = A [ i ] % B [ i ] ; int totalCost_B = min ( mod_B , B [ i ] - mod_B ) ; totalCost += min ( totalCost_A , totalCost_B ) ; } return totalCost ; } int main ( ) { int A [ ] = { 3 , 6 , 3 } ; int B [ ] = { 4 , 8 , 13 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << MinimumCost ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxOccuringCharacter ( string s ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { count1 ++ ; } else if ( s [ i ] == '0' ) { count0 ++ ; } } int prev = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != ' X ' ) { if ( s [ i ] == '1' ) { count1 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == '1' ) { flag = false ; prev = j ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } prev = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '0' ) { prev = i ; break ; } } for ( int i = prev + 1 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != ' X ' ) { if ( s [ i ] == '0' ) { count0 += i - prev - 1 ; prev = i ; } else { bool flag = true ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == '0' ) { prev = j ; flag = false ; break ; } } if ( ! flag ) { i = prev ; } else { i = s . length ( ) ; } } } } if ( s [ 0 ] == ' X ' ) { int count = 0 ; int i = 0 ; while ( s [ i ] == ' X ' ) { count ++ ; i ++ ; } if ( s [ i ] == '1' ) { count1 += count ; } } if ( s [ ( s . length ( ) - 1 ) ] == ' X ' ) { int count = 0 ; int i = s . length ( ) - 1 ; while ( s [ i ] == ' X ' ) { count ++ ; i -- ; } if ( s [ i ] == '0' ) { count0 += count ; } } if ( count0 == count1 ) { cout << " X " << endl ; } else if ( count0 > count1 ) { cout << 0 << endl ; } else cout << 1 << endl ; } int main ( ) { string S = " XX10XX10XXX1XX " ; maxOccuringCharacter ( S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumDeletions ( string s ) { int n = s . length ( ) ; int ans = n ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int t = s [ i ] - '0' ; if ( t % 2 == 0 ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { int num = ( s [ j ] - '0' ) * 10 + t ; if ( num % 4 == 0 ) { int k1 = i - j - 1 ; int k2 = n - i - 1 ; ans = min ( ans , k1 + k2 ) ; } } } } if ( ans == n ) { for ( int i = 0 ; i < n ; i ++ ) { int num = s [ i ] - '0' ; if ( num % 4 == 0 ) { ans = n - 1 ; } } } cout << ans ; } int main ( ) { string str = "12367" ; minimumDeletions ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateSequence ( int arr [ ] , int n ) { string ans ; ans = to_string ( arr [ 0 ] ) ; if ( n == 1 ) cout << ans ; else if ( n == 2 ) { cout << ans + " / " << to_string ( arr [ 1 ] ) ; } else { ans += " / ( " + to_string ( arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { ans += " / " + to_string ( arr [ i ] ) ; } ans += " ) " ; cout << ans ; } } int main ( ) { int arr [ ] = { 1000 , 100 , 10 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; generateSequence ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void LCMPairs ( int arr [ ] , int N ) { int total_pairs = ( N * ( N - 1 ) ) / 2 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } odd = ( odd * ( odd - 1 ) ) / 2 ; cout << " Even ▁ = ▁ " << total_pairs - odd << " , ▁ Odd ▁ = ▁ " << odd ; } int main ( ) { int arr [ ] = { 3 , 6 , 5 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; LCMPairs ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; static int printNumber ( int N , int K , int M ) { int sum = K * ( M * ( M + 1 ) / 2 ) ; return sum - N ; } int main ( ) { int N = 17 ; int K = 3 ; int M = 4 ; cout << printNumber ( N , K , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSwaps ( string S , string T ) { int value [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) value [ i ] = i + 1 ; int N = S . size ( ) ; int sum1 = 0 ; int sum2 = 0 ; bool flag = false ; for ( int i = 0 ; i < N ; i ++ ) { sum1 += value [ S [ i ] - ' a ' ] ; sum2 += value [ T [ i ] - ' a ' ] ; if ( ( value [ S [ i ] - ' a ' ] % 2 == 0 && value [ T [ i ] - ' a ' ] % 2 == 1 ) || ( value [ S [ i ] - ' a ' ] % 2 == 1 && value [ T [ i ] - ' a ' ] % 2 == 0 ) ) flag = false ; } if ( sum1 % 2 == 1 && sum2 % 2 == 1 ) cout << "0 STRNEWLINE " ; else if ( sum1 % 2 == 0 && sum2 % 2 == 0 ) { if ( flag ) cout << "1" ; else cout << " - 1" ; } else { cout << " - 1" ; } } int main ( ) { string S = " acd " ; string T = " dbf " ; countSwaps ( S , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int N ) { if ( N <= 1 ) return false ; for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; } void countPrimeTuples ( int N ) { int count = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( isPrime ( i ) && isPrime ( i - 2 ) ) count ++ ; } cout << count ; } int main ( ) { int N = 6 ; countPrimeTuples ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int A [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( A [ i ] A [ j ] ) > ( A [ i ] & A [ j ] ) ) { count ++ ; } } cout << count ; } int main ( ) { int A [ ] = { 1 , 4 , 7 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countPairs ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkArrays ( int arr1 [ ] , int arr2 [ ] , int N ) { int count = 0 ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { if ( arr1 [ i ] == 0 ) count ++ ; else { count -- ; if ( count < 0 ) { flag = 0 ; break ; } } } } if ( flag && count == 0 ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { int arr1 [ ] = { 0 , 0 , 1 , 1 } ; int arr2 [ ] = { 1 , 1 , 0 , 0 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; checkArrays ( arr1 , arr2 , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLargestDivisible ( int arr [ ] , int N ) { int i , count0 = 0 , count7 = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count0 ++ ; else count7 ++ ; } if ( count7 % 50 == 0 ) { while ( count7 -- ) cout << 7 ; while ( count0 -- ) cout << 0 ; } else if ( count7 < 5 ) { if ( count0 == 0 ) cout << " No " ; else cout << "0" ; } else { count7 = count7 - count7 % 5 ; while ( count7 -- ) cout << 7 ; while ( count0 -- ) cout << 0 ; } } int main ( ) { int arr [ ] = { 0 , 7 , 0 , 7 , 7 , 7 , 7 , 0 , 0 , 0 , 0 , 0 , 0 , 7 , 7 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printLargestDivisible ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSheets ( int A , int B ) { int area = A * B ; int count = 1 ; while ( area % 2 == 0 ) { area /= 2 ; count *= 2 ; } return count ; } int main ( ) { int A = 5 , B = 10 ; cout << maxSheets ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxNum ( int num ) { bitset < 4 > b ( num ) ; string binaryNumber = b . to_string ( ) ; string maxBinaryNumber = " " ; int count0 = 0 , count1 = 0 ; int N = 4 ; for ( int i = 0 ; i < N ; i ++ ) { if ( binaryNumber [ i ] == '1' ) { count1 ++ ; } else { count0 ++ ; } } for ( int i = 0 ; i < count1 ; i ++ ) { maxBinaryNumber += '1' ; } for ( int i = 0 ; i < count0 ; i ++ ) { maxBinaryNumber += '0' ; } return stoi ( maxBinaryNumber , 0 , 2 ) ; } int main ( ) { int N = 11 ; cout << findMaxNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinMoves ( int a , int b ) { int ans = 0 ; if ( a == b || abs ( a - b ) == 1 ) { ans = a + b ; } else { int k = min ( a , b ) ; int j = max ( a , b ) ; ans = 2 * k + 2 * ( j - k ) - 1 ; } cout << ans ; } int main ( ) { int a = 3 , b = 5 ; findMinMoves ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperations ( string & N ) { int even = 0 ; int odd = 0 ; for ( auto it : N ) { if ( ( it - '0' ) % 2 == 0 ) { even ++ ; } else { odd ++ ; } } if ( odd == 0 odd == 1 ) { cout << " Not ▁ Possible " << " STRNEWLINE " ; } else { int ans = 0 ; for ( auto it : N ) { if ( ( it - '0' ) % 2 == 0 ) { ans ++ ; } else { ans = 0 ; } } if ( odd % 2 ) { ans ++ ; } cout << ans << endl ; } } int main ( ) { string N = "12345" ; minOperations ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generatepermutation ( int N ) { vector < int > answer ; answer . push_back ( N ) ; for ( int i = 1 ; i < N ; i ++ ) { answer . push_back ( i ) ; } for ( int i : answer ) cout << i << " ▁ " ; } int main ( ) { int N = 4 ; generatepermutation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long cntEvenSumPairs ( long long X , long long Y ) { long long cntXEvenNums = X / 2 ; long long cntXOddNums = ( X + 1 ) / 2 ; long long cntYEvenNums = Y / 2 ; long long cntYOddNums = ( Y + 1 ) / 2 ; long long cntPairs = ( cntXEvenNums * 1LL * cntYEvenNums ) + ( cntXOddNums * 1LL * cntYOddNums ) ; return cntPairs ; } int main ( ) { long long X = 2 ; long long Y = 3 ; cout << cntEvenSumPairs ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxValueAtIndexK ( int N , int K , int M ) { int S1 = 0 , S2 = 0 ; S1 = K * ( K + 1 ) / 2 ; S2 = ( N - K - 1 ) * ( N - K ) / 2 ; int X = ( M + S1 + S2 ) / N ; cout << X ; } int main ( ) { int N = 3 , K = 1 , M = 7 ; maxValueAtIndexK ( N , K , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void farthestCellDistance ( int N , int M , int R , int C ) { int d1 = N + M - R - C ; int d2 = R + C - 2 ; int d3 = N - R + C - 1 ; int d4 = M - C + R - 1 ; int maxDistance = max ( d1 , max ( d2 , max ( d3 , d4 ) ) ) ; cout << maxDistance ; } int main ( ) { int N = 15 , M = 12 , R = 1 , C = 6 ; farthestCellDistance ( N , M , R , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int N ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int t = i ; if ( t + arr [ i ] < N ) { arr [ i ] += arr [ t + arr [ i ] ] ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 1 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxSum ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findInGrid ( int i , int j ) { if ( i == j ) return ( i * i - ( i - 1 ) ) ; else if ( i > j ) { if ( i % 2 == 0 ) return i * i - ( j - 1 ) ; else return ( i - 1 ) * ( i - 1 ) + 1 + ( j - 1 ) ; } else { if ( j % 2 == 0 ) return ( j - 1 ) * ( j - 1 ) + 1 + ( i - 1 ) ; else return j * j - ( i - 1 ) ; } } int main ( ) { int i = 3 , j = 4 ; cout << findInGrid ( i , j ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void splitArray ( int arr [ ] , int N ) { map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int G = 0 ; for ( auto i : mp ) { G = gcd ( G , i . second ) ; } if ( G > 1 ) cout << " YES " ; else cout << " NO " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; splitArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void querySum ( int arr [ ] , int N , int Q [ ] [ 2 ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int x = Q [ i ] [ 0 ] ; int y = Q [ i ] [ 1 ] ; int sum = 0 ; while ( x < N ) { sum += arr [ x ] ; x += y ; } cout << sum << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 5 , 4 } ; int Q [ ] [ 2 ] = { { 2 , 1 } , { 3 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; querySum ( arr , N , Q , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string greatestReducedNumber ( string num , string s ) { vector < bool > vis_s ( 10 , false ) ; for ( int i = 0 ; i < ( int ) s . size ( ) ; i ++ ) { vis_s [ int ( s [ i ] ) - 48 ] = true ; } int n = num . size ( ) ; int in = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis_s [ ( int ) num [ i ] - '0' ] ) { in = i ; break ; } } if ( in == -1 ) { return num ; } for ( char dig = num [ in ] ; dig >= '0' ; dig -- ) { if ( vis_s [ ( int ) dig - '0' ] == 0 ) { num [ in ] = dig ; break ; } } char LargestDig = '0' ; for ( char dig = '9' ; dig >= '0' ; dig -- ) { if ( vis_s [ dig - '0' ] == false ) { LargestDig = dig ; break ; } } for ( int i = in + 1 ; i < n ; i ++ ) { num [ i ] = LargestDig ; } int Count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( num [ i ] == '0' ) Count ++ ; else break ; } num . erase ( 0 , Count ) ; if ( ( int ) num . size ( ) == 0 ) return "0" ; return num ; } int main ( ) { string N = "12345" ; string S = "23" ; cout << greatestReducedNumber ( N , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minXOR ( vector < int > & Arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( Arr [ i ] == 2 ) { cout << ( Arr [ i ] ^ 3 ) << " ▁ " ; } else { cout << ( Arr [ i ] ^ 2 ) << " ▁ " ; } } } int main ( ) { vector < int > Arr = { 5 , 4 , 7 , 6 } ; int N = Arr . size ( ) ; minXOR ( Arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findArray ( int n ) { vector < int > Arr ( n + 1 ) ; Arr [ 0 ] = 0 ; Arr [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { Arr [ i ] = Arr [ i / 2 ] ; } else { Arr [ i ] = Arr [ ( i - 1 ) / 2 ] + Arr [ ( i - 1 ) / 2 + 1 ] ; } } return Arr ; } int maxElement ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; vector < int > Arr = findArray ( n ) ; return * max_element ( Arr . begin ( ) , Arr . end ( ) ) ; } int main ( ) { int N = 7 ; cout << maxElement ( N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void constGraphWithCon ( int N , int K ) { int Max = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; if ( K > Max ) { cout << -1 << endl ; return ; } vector < pair < int , int > > ans ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { ans . emplace_back ( make_pair ( i , j ) ) ; } } for ( int i = 0 ; i < ( N - 1 ) + Max - K ; i ++ ) { cout << ans [ i ] . first << " ▁ " << ans [ i ] . second << endl ; } } int main ( ) { int N = 5 , K = 3 ; constGraphWithCon ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_steps_required ( int n , int m , int r , int c ) { int i , j ; int corner_steps_req = INT_MAX ; i = 1 ; j = 1 ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = n ; j = 1 ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = 1 ; j = m ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; i = n ; j = m ; corner_steps_req = min ( corner_steps_req , abs ( r - i ) + abs ( j - c ) ) ; int minimum_steps = min ( 2 * ( n - 1 ) + m - 1 , 2 * ( m - 1 ) + n - 1 ) ; return minimum_steps + corner_steps_req ; } int main ( ) { int n = 3 ; int m = 2 ; int r = 1 ; int c = 1 ; cout << min_steps_required ( n , m , r , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_elements ( int arr [ ] , int N , int K ) { map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } vector < int > Freq ; for ( auto it : mp ) { int i = it . first ; Freq . push_back ( mp [ i ] ) ; } sort ( Freq . rbegin ( ) , Freq . rend ( ) ) ; int len = Freq . size ( ) ; if ( len <= K ) { return 0 ; } int cntMin = 0 ; for ( int i = K ; i < len ; i ++ ) { cntMin += Freq [ i ] ; } return cntMin ; } int main ( ) { int arr [ ] = { 5 , 1 , 3 , 2 , 4 , 1 , 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << min_elements ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntOnesArrWithGivenOp ( int arr [ ] , int N ) { int cntOnes = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i - 1 ; j < N ; j += i ) { arr [ j ] = ! ( arr [ j ] ) ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) { cntOnes += 1 ; } } return cntOnes ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntOnesArrWithGivenOp ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntOnesArrWithGivenOp ( int arr [ ] , int N ) { int cntOnes = 0 ; cntOnes = sqrt ( N ) ; return cntOnes ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntOnesArrWithGivenOp ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntKnightsAttackPawn ( int knights [ ] [ 2 ] , int pawn [ ] , int M ) { int cntKnights = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int X = abs ( knights [ i ] [ 0 ] - pawn [ 0 ] ) ; int Y = abs ( knights [ i ] [ 1 ] - pawn [ 1 ] ) ; if ( ( X == 1 && Y == 2 ) || ( X == 2 && Y == 1 ) ) { cntKnights ++ ; } } return cntKnights ; } int main ( ) { int knights [ ] [ 2 ] = { { 0 , 4 } , { 4 , 5 } , { 1 , 4 } , { 3 , 1 } } ; int pawn [ ] = { 2 , 3 } ; int M = sizeof ( knights ) / sizeof ( knights [ 0 ] ) ; cout << cntKnightsAttackPawn ( knights , pawn , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinnerGameRemoveGCD ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 ; j * j <= arr [ i ] ; j ++ ) { if ( arr [ i ] % j == 0 ) { mp [ j ] ++ ; while ( arr [ i ] % j == 0 ) { arr [ i ] = arr [ i ] / j ; } } } if ( arr [ i ] > 1 ) { mp [ arr [ i ] ] ++ ; } } int maxCnt = 0 ; for ( auto i : mp ) { maxCnt = max ( maxCnt , i . second ) ; } if ( n % 2 == 0 ) { if ( maxCnt >= n - 1 ) { cout << " Player ▁ 1" ; } else { cout << " Player ▁ 2" ; } } else { if ( maxCnt == n ) { cout << " Player ▁ 1" ; } else { cout << " Player ▁ 2" ; } } } int main ( ) { int arr [ ] = { 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findWinnerGameRemoveGCD ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumSwaps ( int arr1 [ ] , int arr2 [ ] , int n ) { int sumArr1 = 0 , sumArr2 = 0 ; for ( int i = 0 ; i < n ; ++ i ) { sumArr1 += arr1 [ i ] ; sumArr2 += arr2 [ i ] ; } if ( sumArr1 % 2 == 0 && sumArr2 % 2 == 0 ) { cout << 0 ; return ; } if ( sumArr1 % 2 != 0 && sumArr2 % 2 != 0 ) { int flag = -1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( arr1 [ i ] + arr2 [ i ] ) % 2 == 1 ) { flag = 1 ; break ; } } cout << flag ; return ; } cout << -1 ; } int main ( ) { int arr1 [ ] = { 11 , 14 , 20 , 2 } ; int arr2 [ ] = { 5 , 9 , 6 , 3 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; minimumSwaps ( arr1 , arr2 , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void corpFlightBookings ( vector < vector < int > > & Bookings , int N ) { vector < int > res ( N , 0 ) ; for ( int i = 0 ; i < Bookings . size ( ) ; i ++ ) { int l = Bookings [ i ] [ 0 ] ; int r = Bookings [ i ] [ 1 ] ; int K = Bookings [ i ] [ 2 ] ; res [ l - 1 ] = res [ l - 1 ] + K ; if ( r <= res . size ( ) - 1 ) res [ r ] = ( - K ) + res [ r ] ; } for ( int i = 1 ; i < res . size ( ) ; i ++ ) res [ i ] = res [ i ] + res [ i - 1 ] ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) { cout << res [ i ] << " ▁ " ; } } int main ( ) { vector < vector < int > > bookings { { 1 , 3 , 100 } , { 2 , 6 , 100 } , { 3 , 4 , 100 } } ; int N = 6 ; corpFlightBookings ( bookings , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findXOR ( int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } } void findOddXOR ( int n ) { if ( n % 2 == 0 ) cout << ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( n / 2 ) ) ) ; else cout << ( ( findXOR ( n ) ) ^ ( 2 * findXOR ( ( n - 1 ) / 2 ) ) ) ; } int main ( ) { int N = 11 ; findOddXOR ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSmallestNumber ( int n ) { for ( int i = n ; i <= ( n + 2520 ) ; ++ i ) { bool possible = 1 ; int temp = i ; while ( temp ) { if ( temp % 10 != 0 ) { int digit = temp % 10 ; if ( i % digit != 0 ) { possible = 0 ; break ; } } temp /= 10 ; } if ( possible == 1 ) { cout << i ; return ; } } } int main ( ) { int N = 31 ; findSmallestNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minValue ( int arr [ ] , int n ) { int minimum = * min_element ( arr , arr + n ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] - minimum ) ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minValue ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countEvenPairs ( int N , int M ) { int count = 0 ; int nEven = floor ( N / 2 ) ; int nOdd = ceil ( N / 2 ) ; int mEven = floor ( M / 2 ) ; int mOdd = ceil ( M / 2 ) ; count = nEven * mEven + nOdd * mOdd ; return count ; } int main ( ) { int N = 4 ; int M = 6 ; cout << countEvenPairs ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void string_palindrome ( int N , int K ) { for ( int i = 0 ; i < K ; i ++ ) cout << " a " ; string s = " bcd " ; for ( int i = 0 ; i < N - K ; i ++ ) cout << s [ i % 3 ] ; } int main ( ) { int N = 5 , K = 3 ; string_palindrome ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char lastRemovedCharacter ( string str ) { int n = str . length ( ) ; if ( n == 1 ) return str [ 0 ] ; if ( str [ n - 2 ] == '0' ) { return ( '1' - str [ n - 1 ] + '0' ) ; } else return str [ n - 1 ] ; } int main ( ) { string str = "10010" ; cout << lastRemovedCharacter ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findArray ( int N , int K ) { if ( N == 1 ) { cout << " ▁ " << K ; return ; } if ( N == 2 ) { cout << 0 << " ▁ " << K ; return ; } int P = N - 2 ; int Q = N - 1 ; int VAL = 0 ; for ( int i = 1 ; i <= ( N - 3 ) ; i ++ ) { cout << " ▁ " << i ; VAL ^= i ; } if ( VAL == K ) { cout << P << " ▁ " << Q << " ▁ " << ( P ^ Q ) ; } else { cout << 0 << " ▁ " << P << " ▁ " << ( P ^ K ^ VAL ) ; } } int main ( ) { int N = 4 , X = 6 ; findArray ( N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumber ( int N ) { int count = 0 ; while ( ( N & 1 ) == 1 ) { N = N >> 1 ; count ++ ; } return N << count ; } int main ( ) { int N = 39 ; cout << findNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_elements ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int cntMinRem = 0 ; for ( auto it : mp ) { int i = it . first ; if ( mp [ i ] < i ) { cntMinRem += mp [ i ] ; } else if ( mp [ i ] > i ) { cntMinRem += ( mp [ i ] - i ) ; } } return cntMinRem ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min_elements ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool CheckAllarrayEqual ( int arr [ ] , int N ) { if ( N == 1 ) { return true ; } int totalSum = arr [ 0 ] ; int secMax = INT_MIN ; int Max = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] >= Max ) { secMax = Max ; Max = arr [ i ] ; } else if ( arr [ i ] > secMax ) { secMax = arr [ i ] ; } totalSum += arr [ i ] ; } if ( ( secMax * ( N - 1 ) ) > totalSum ) { return false ; } if ( totalSum % ( N - 1 ) ) { return false ; } return true ; } int main ( ) { int arr [ ] = { 6 , 2 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( CheckAllarrayEqual ( arr , N ) ) { cout << " YES " ; } else { cout << " NO " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < string > subString ( string s , int n ) { vector < string > v ; for ( int i = 0 ; i < n ; i ++ ) { for ( int len = 1 ; len <= n - i ; len ++ ) { string find = s . substr ( i , len ) ; v . push_back ( find ) ; } } return v ; } int IsPresent ( string & str , string & target ) { if ( str . find ( target ) != string :: npos ) { return 1 ; } return -1 ; } void countSubstrings ( string & S , string & T ) { vector < string > v = subString ( S , S . length ( ) ) ; int ans = 0 ; for ( auto it : v ) { if ( IsPresent ( it , T ) != -1 ) { ans ++ ; } } cout << ans ; } int main ( ) { string S = " dabc " ; string T = " ab " ; countSubstrings ( S , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumcntOperationReq ( int arr [ ] , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { cntOp ++ ; } } return ( cntOp + 1 ) / 2 ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumcntOperationReq ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isSequenceValid ( vector < int > & B , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( ( i + 1 ) % B [ i ] != 0 ) { cout << " No " ; return ; } } cout << " Yes " ; } int main ( ) { int N = 4 ; vector < int > arr { 1 , 2 , 3 , 2 } ; isSequenceValid ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ConstArrayAdjacentCoprime ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << i << " ▁ " ; } } int main ( ) { int N = 6 ; ConstArrayAdjacentCoprime ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntIndexesToMakeBalance ( int arr [ ] , int n ) { if ( n == 1 ) { return 1 ; } if ( n == 2 ) return 0 ; int sumEven = 0 ; int sumOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { sumEven += arr [ i ] ; } else { sumOdd += arr [ i ] ; } } int currOdd = 0 ; int currEven = arr [ 0 ] ; int res = 0 ; int newEvenSum = 0 ; int newOddSum = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( i % 2 ) { currOdd += arr [ i ] ; newEvenSum = currEven + sumOdd - currOdd ; newOddSum = currOdd + sumEven - currEven - arr [ i ] ; } else { currEven += arr [ i ] ; newOddSum = currOdd + sumEven - currEven ; newEvenSum = currEven + sumOdd - currOdd - arr [ i ] ; } if ( newEvenSum == newOddSum ) { res ++ ; } } if ( sumOdd == sumEven - arr [ 0 ] ) { res ++ ; } if ( n % 2 == 1 ) { if ( sumOdd == sumEven - arr [ n - 1 ] ) { res ++ ; } } else { if ( sumEven == sumOdd - arr [ n - 1 ] ) { res ++ ; } } return res ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntIndexesToMakeBalance ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNums ( int X , int Y ) { int A , B ; if ( X < Y ) { A = -1 ; B = -1 ; } else if ( abs ( X - Y ) & 1 ) { A = -1 ; B = -1 ; } else if ( X == Y ) { A = 0 ; B = Y ; } else { A = ( X - Y ) / 2 ; if ( ( A & Y ) == 0 ) { B = ( A + Y ) ; } else { A = -1 ; B = -1 ; } } cout << A << " ▁ " << B ; } int main ( ) { int X = 17 , Y = 13 ; findNums ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxEqrows ( vector < vector < int > > & mat , int N , int M ) { map < vector < int > , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ mat [ i ] ] ++ ; } int cntMaxRows = 0 ; for ( int i = 0 ; i < N ; i ++ ) { vector < int > onesCompRow ( M , 0 ) ; for ( int j = 0 ; j < M ; j ++ ) { onesCompRow [ j ] = ( mat [ i ] [ j ] ^ 1 ) ; } cntMaxRows = max ( cntMaxRows , mp [ mat [ i ] ] + mp [ onesCompRow ] ) ; } return cntMaxRows ; } int main ( ) { vector < vector < int > > mat = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 1 , 0 , 1 , 1 } , { 1 , 0 , 1 , 1 , 0 } } ; int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; cout << maxEqrows ( mat , N , M ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumCost ( string a , string b ) { vector < int > fre1 ( 256 ) , fre2 ( 256 ) ; for ( char c : a ) fre1 [ ( int ) ( c ) ] ++ ; for ( char c : b ) fre2 [ ( int ) ( c ) ] ++ ; int mincost = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { mincost += abs ( fre1 [ i ] - fre2 [ i ] ) ; } cout << mincost << endl ; } int main ( ) { string A = "1AB + - " , B = " cc " ; minimumCost ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSumByAlternatingSign ( int arr [ ] , int N ) { int cntNeg = 0 ; int MaxAltSum = 0 ; int SmValue = 0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { cntNeg += 1 ; } sum += abs ( arr [ i ] ) ; SmValue = min ( SmValue , abs ( arr [ i ] ) ) ; } MaxAltSum = sum ; if ( cntNeg & 1 ) { MaxAltSum -= 2 * SmValue ; } return MaxAltSum ; } int main ( ) { int arr [ ] = { 1 , 1 , -2 , -4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSumByAlternatingSign ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructNewArraySumZero ( int arr [ ] , int N ) { int newArr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { newArr [ i ] = arr [ i + 1 ] ; } else { newArr [ i ] = - arr [ i - 1 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << newArr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , -5 , -6 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; constructNewArraySumZero ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void bitonicSequence ( int num , int lower , int upper ) { if ( num > ( upper - lower ) * 2 + 1 ) { cout << -1 ; return ; } deque < int > ans ; deque < int > :: iterator j = ans . begin ( ) ; for ( int i = 0 ; i < min ( upper - lower + 1 , num - 1 ) ; i ++ ) ans . push_back ( upper - i ) ; for ( int i = 0 ; i < num - ans . size ( ) ; i ++ ) ans . push_front ( upper - i - 1 ) ; cout << ' [ ' ; for ( j = ans . begin ( ) ; j != ans . end ( ) ; ++ j ) cout << ' ▁ ' << * j ; cout << ' ▁ ' << ' ] ' ; } int main ( ) { int N = 5 , L = 3 , R = 10 ; bitonicSequence ( N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstrings ( string s , string t ) { int answ = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { for ( int j = 0 ; j < t . size ( ) ; j ++ ) { if ( t [ j ] != s [ i ] ) { answ += 1 ; int k = 1 ; int z = -1 ; int q = 1 ; while ( j + z >= 0 && 0 <= i + z && s [ i + z ] == t [ j + z ] ) { z -= 1 ; answ += 1 ; q += 1 ; } while ( s . size ( ) > i + k && j + k < t . size ( ) && s [ i + k ] == t [ j + k ] ) { k += 1 ; answ += q ; z = -1 ; } } } } return answ ; } int main ( ) { string S = " aba " ; string T = " baba " ; cout << ( countSubstrings ( S , T ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCntOfFlipsRequired ( string str ) { int n = str . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { zeros ++ ; } } if ( zeros == 0 zeros == n ) { return 0 ; } int minFlips = INT_MAX ; int currOnes = 0 ; int flips ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { currOnes ++ ; } flips = currOnes + ( zeros - ( i + 1 - currOnes ) ) ; minFlips = min ( minFlips , flips ) ; } return minFlips ; } int main ( ) { string str = "100101" ; cout << minimumCntOfFlipsRequired ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCount ( int A [ ] , int Q [ ] [ 2 ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int L = Q [ i ] [ 0 ] ; int R = Q [ i ] [ 1 ] ; L -- , R -- ; if ( ( A [ L ] < A [ L + 1 ] ) != ( A [ R - 1 ] < A [ R ] ) ) { cout << " Yes STRNEWLINE " ; } else { cout << " No STRNEWLINE " ; } } } int main ( ) { int arr [ ] = { 11 , 13 , 12 , 14 } ; int Q [ ] [ 2 ] = { { 1 , 4 } , { 2 , 4 } } ; int q = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; checkCount ( arr , Q , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } void canReach ( int N , int A , int B , int K ) { int gcd = GCD ( N , K ) ; if ( abs ( A - B ) % gcd == 0 ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int N = 5 , A = 2 , B = 1 , K = 2 ; canReach ( N , A , B , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int separate ( int arr [ ] , int n , int parity ) { int count = 1 , res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( ( arr [ i ] + parity ) & 1 ) && ( ( arr [ i - 1 ] + parity ) & 1 ) ) count ++ ; else { if ( count > 1 ) res += count - 1 ; count = 1 ; } } return res ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void requiredOps ( int arr [ ] , int N ) { int res1 = separate ( arr , N , 0 ) ; int res2 = separate ( arr , N , 1 ) ; cout << max ( res1 , res2 ) ; } int main ( ) { int arr [ ] = { 13 , 2 , 6 , 8 , 3 , 5 , 7 , 10 , 14 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; requiredOps ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < bool > SieveOfEratosthenes ( int N ) { vector < bool > isPrime ( N , true ) ; isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( isPrime [ p ] ) { for ( int i = p * p ; i <= N ; i += p ) { isPrime [ i ] = false ; } } } return isPrime ; } int cntPairsdiffOfPrimeisPrime ( int N ) { int cntPairs = 0 ; vector < bool > isPrime = SieveOfEratosthenes ( N ) ; for ( int i = 2 ; i <= N ; i ++ ) { if ( isPrime [ i ] && isPrime [ i - 2 ] ) { cntPairs += 2 ; } } return cntPairs ; } int main ( ) { int N = 5 ; cout << cntPairsdiffOfPrimeisPrime ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubsequence ( int arr [ ] , int N ) { int count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] != arr [ i - 1 ] ) { count ++ ; } } cout << count << endl ; } int main ( ) { int arr [ ] = { 7 , 8 , 1 , 2 , 2 , 5 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; longestSubsequence ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int substringCount ( string s ) { vector < int > freq ( 26 , 0 ) ; char max_char = ' # ' ; int maxfreq = INT_MIN ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; if ( maxfreq < freq [ s [ i ] - ' a ' ] ) maxfreq = freq [ s [ i ] - ' a ' ] ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( maxfreq == freq [ i ] ) { max_char = ( char ) ( i + ' a ' ) ; break ; } } int ans = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { char ch = s [ i ] ; if ( max_char == ch ) { ans += ( s . size ( ) - i ) ; } } return ans ; } int main ( ) { string S = " abcab " ; cout << ( substringCount ( S ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minSum ( int * arr , int n ) { vector < int > ans ( n , 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) { ans [ i ] = max ( ans [ i ] , ans [ i - 1 ] + 1 ) ; } } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) { ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] + 1 ) ; } } int s = 0 ; for ( auto x : ans ) { s = s + x ; } cout << s << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( string S ) { string new_str ; int N = S . length ( ) ; int i = 0 ; while ( i < N ) { new_str += S [ i ] ; int j = i ; while ( i < N && S [ i ] == S [ j ] ) ++ i ; } cout << ceil ( ( new_str . size ( ) + 1 ) / 2.0 ) ; } int main ( ) { string S = "0010100" ; minSteps ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int N ) { int cntPairs = 0 ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } for ( auto freq : mp ) { cntPairs += ( freq . second * ( freq . second - 1 ) ) / 2 ; } return cntPairs ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 1 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumMoves ( int n ) { int cnt2 = 0 , cnt5 = 0 ; while ( n % 2 == 0 ) { n /= 2 ; cnt2 ++ ; } while ( n % 5 == 0 ) { n /= 5 ; cnt5 ++ ; } if ( n == 1 && cnt2 <= cnt5 ) { return 2 * cnt5 - cnt2 ; } else return -1 ; } int main ( ) { int N = 25 ; cout << minimumMoves ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( int n ) { if ( ( n & n - 1 ) != 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; } int main ( ) { int n = 5 ; check ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long int binCoff ( unsigned int n , unsigned int r ) { unsigned long int val = 1 ; int i ; if ( r > ( n - r ) ) r = ( n - r ) ; for ( i = 0 ; i < r ; i ++ ) { val *= ( n - i ) ; val /= ( i + 1 ) ; } return val ; } void findWays ( int M ) { int n = M / 2 ; unsigned long int a , b , ans ; a = binCoff ( 2 * n , n ) ; b = a / ( n + 1 ) ; cout << b ; } int main ( ) { int M = 4 , X = 5 ; findWays ( M ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int Moves_Calculator ( int x , int y , int row , int col ) { int total_moves = 0 ; if ( ( row - x ) > 0 && ( col - y ) > 0 ) total_moves += min ( ( row - x ) , ( col - y ) ) ; if ( ( y - 1 ) > 0 && ( x - 1 ) > 0 ) total_moves += min ( ( y - 1 ) , ( x - 1 ) ) ; if ( ( x - 1 ) > 0 && ( col - y ) > 0 ) total_moves += min ( ( x - 1 ) , ( col - y ) ) ; if ( ( row - x ) > 0 && ( y - 1 ) > 0 ) total_moves += min ( ( row - x ) , ( y - 1 ) ) ; total_moves += ( row - 1 ) + ( col - 1 ) ; int king_moves = 0 ; if ( x + 1 <= row ) king_moves += 1 ; if ( x - 1 > 0 ) king_moves += 1 ; if ( y + 1 <= col ) king_moves += 1 ; if ( y - 1 > 0 ) king_moves += 1 ; if ( x + 1 <= row && y + 1 <= col ) king_moves += 1 ; if ( x + 1 <= row && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y - 1 > 0 ) king_moves += 1 ; if ( x - 1 > 0 && y + 1 <= col ) king_moves += 1 ; return total_moves - king_moves ; } int main ( ) { int n = 8 , m = 8 ; int x = 1 , y = 1 ; cout << ( Moves_Calculator ( x , y , m , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int equvInverse ( int arr [ ] , int N , int P ) { int cntElem = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] * arr [ i ] ) % P == 1 ) { cntElem ++ ; } } return cntElem ; } int main ( ) { int arr [ ] = { 1 , 6 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int P = 7 ; cout << equvInverse ( arr , N , P ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int K , int M ) { int res = 1 ; while ( M > 0 ) { if ( ( M & 1 ) == 1 ) { res = ( res * K ) ; } M = M >> 1 ; K = ( K * K ) ; } return res ; } int cntWays ( int arr [ ] , int N , int K ) { int cntways = 0 ; int M = 0 ; unordered_set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { st . insert ( arr [ i ] ) ; } M = st . size ( ) ; cntways = power ( K , M ) ; return cntways ; } int main ( ) { int arr [ ] = { 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << cntWays ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1e9 + 7 ; void minProduct ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= ( n - 4 ) / 2 ; i ++ ) { ans = ( 1LL * ans * ( n - 2 ) ) % mod ; } ans = ( 1LL * ans * ( n - 2 ) * ( n - 1 ) ) % mod ; cout << ans << endl ; } int main ( ) { int N = 8 ; minProduct ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int N ) { int sumSet1 = 0 ; int sumSet2 = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( sumSet1 <= sumSet2 ) { sumSet1 += i ; } else { sumSet2 += i ; } } return abs ( sumSet1 - sumSet2 ) ; } int main ( ) { int N = 6 ; cout << minAbsDiff ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int n ) { int oneCount = 0 ; int desiredPair = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { oneCount ++ ; } if ( arr [ i ] == 0 ) { desiredPair += oneCount ; } } return desiredPair ; } int main ( ) { int arr [ ] = { 3 , 1 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void smlstNonNeg ( int arr [ ] , int N ) { int smNonNeg = 0 ; bool hash [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= 0 and arr [ i ] < N ) { hash [ arr [ i ] ] = true ; } while ( hash [ smNonNeg ] ) { smNonNeg ++ ; } cout << smNonNeg << " ▁ " ; } } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 3 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; smlstNonNeg ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int arr [ ] , int N , int X ) { vector < int > A , B ; int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( 2 * arr [ i ] ) < X ) { A . push_back ( arr [ i ] ) ; } else if ( ( 2 * arr [ i ] ) > X ) { B . push_back ( arr [ i ] ) ; } else { if ( c % 2 == 0 ) { A . push_back ( arr [ i ] ) ; } else { B . push_back ( arr [ i ] ) ; } c ++ ; } } cout << " The ▁ First ▁ Array ▁ is ▁ - ▁ " ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { cout << A [ i ] << " ▁ " ; } cout << endl ; cout << " The ▁ Second ▁ Array ▁ is ▁ - ▁ " ; for ( int i = 0 ; i < B . size ( ) ; i ++ ) { cout << B [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 5 , 4 , 3 , 6 , 2 , 4 , 3 } ; int X = 7 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; solve ( arr , N , X ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntMinSub ( int arr [ ] , int N , int K ) { int res = 0 ; int start = 0 ; int end = N - 1 ; sort ( arr , arr + N ) ; while ( end - start > 1 ) { if ( arr [ start ] + arr [ end ] <= K ) { start ++ ; } else { res ++ ; end -- ; } } if ( end - start == 1 ) { if ( arr [ start ] + arr [ end ] <= K ) { res ++ ; start ++ ; end -- ; } else { res ++ ; end -- ; } } if ( start == end ) { res ++ ; } return res ; } int main ( ) { int arr [ ] = { 2 , 6 , 8 , 10 , 20 , 25 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 26 ; cout << cntMinSub ( arr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int condition ( int a , int b ) { int d = abs ( a - b ) , count = 0 ; for ( int i = 1 ; i <= sqrt ( d ) ; i ++ ) { if ( d % i == 0 ) { if ( d / i == i ) count += 1 ; else count += 2 ; } } return count ; } int main ( ) { int x = 2 , y = 6 ; cout << condition ( x , y ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; long long power ( int x , int y ) { if ( y == 0 ) return 1 ; long long int p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( y & 1 ) { p = ( x * p ) % mod ; } return p ; } int TotalNumber ( int N ) { int ans = ( power ( 10 , N ) - 2 * power ( 9 , N ) + power ( 8 , N ) + 2 * mod ) % mod ; return ans ; } int main ( ) { int N = 10 , X = 3 , Y = 4 ; cout << TotalNumber ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkDigits ( int n ) { do { int r = n % 10 ; if ( r == 3 r == 4 r == 6 r == 7 r == 9 ) return false ; n /= 10 ; } while ( n != 0 ) ; return true ; } bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } int isAllPrime ( int n ) { return isPrime ( n ) && checkDigits ( n ) ; } int main ( ) { int N = 101 ; if ( isAllPrime ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateArray ( int arr [ ] , int n ) { deque < int > ans ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) ans . push_front ( arr [ i ] ) ; else ans . push_back ( arr [ i ] ) ; } if ( n & 1 ) { reverse ( ans . begin ( ) , ans . end ( ) ) ; } for ( auto x : ans ) { cout << x << " ▁ " ; } cout << endl ; } int32_t main ( ) { int n = 4 ; int arr [ n ] = { 1 , 2 , 3 , 4 } ; generateArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPlayer ( string str [ ] , int n ) { int move_first = 0 ; int move_sec = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] [ 0 ] == str [ i ] [ str [ i ] . length ( ) - 1 ] ) { if ( str [ i ] [ 0 ] == 48 ) move_first ++ ; else move_sec ++ ; } } if ( move_first <= move_sec ) { cout << " Player ▁ 2 ▁ wins " ; } else { cout << " Player ▁ 1 ▁ wins " ; } } int main ( ) { string str [ ] = { "010" , "101" } ; int N = sizeof ( str ) / sizeof ( str [ 0 ] ) ; findPlayer ( str , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string closestgtNum ( string str ) { string res = " " ; int n = str . length ( ) ; if ( str [ 0 ] < '9' ) { res . push_back ( str [ 0 ] + 1 ) ; } else { res . push_back ( '1' ) ; res . push_back ( '0' ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { res . push_back ( '0' ) ; } return res ; } int main ( ) { string str = "120" ; cout << closestgtNum ( str ) ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int find_next ( int n , int k ) { int ans = 0 ; if ( ( n & ( 1ll << k ) ) == 0 ) { int cur = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( n & ( 1ll << i ) ) cur += 1ll << i ; } ans = n - cur + ( 1ll << k ) ; } else { int first_unset_bit = -1 , cur = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( n & ( 1ll << i ) ) == 0 ) { first_unset_bit = i ; break ; } else cur += ( 1ll << i ) ; } ans = n - cur + ( 1ll << first_unset_bit ) ; if ( ( ans & ( 1ll << k ) ) == 0 ) ans += ( 1ll << k ) ; } return ans ; } int main ( ) { int N = 15 , K = 2 ; cout << find_next ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y ) { int temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } void maximumPossibleSum ( int N , int X ) { cout << ( X * ( power ( 2 , N ) - 1 ) ) << endl ; } int main ( ) { int N = 3 , X = 5 ; maximumPossibleSum ( N , X ) ; }
#include <iostream> NEW_LINE using namespace std ; int countOfPairs ( int x , int y ) { int counter = 1 ; while ( x y ) { int bit1 = x % 2 ; int bit2 = y % 2 ; x >>= 1 ; y >>= 1 ; if ( bit1 == 1 and bit2 == 0 ) { counter *= 2 ; continue ; } if ( bit1 & bit2 ) { counter = 0 ; break ; } } return counter ; } int main ( ) { int X = 2 , Y = 5 ; cout << countOfPairs ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int findGCD ( int arr [ ] , int N ) { int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) { result = gcd ( result , arr [ i ] ) ; if ( result == 1 ) { return 1 ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findGCD ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check_digits ( long N ) { while ( N > 0 ) { int n = N % 10 ; if ( ( n != 0 ) && ( n != 1 ) && ( n != 4 ) && ( n != 9 ) ) { return 0 ; } N = N / 10 ; } return 1 ; } bool is_perfect ( long N ) { long double n = sqrt ( N ) ; if ( floor ( n ) != ceil ( n ) ) { return 0 ; } return 1 ; } void isFullSquare ( long N ) { if ( is_perfect ( N ) && check_digits ( N ) ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { long N = 144 ; isFullSquare ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstring ( string s , int n ) { map < char , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ s [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; m [ s [ i ] ] -- ; for ( auto value : m ) { if ( value . first == s [ i ] ) { continue ; } else { cnt += value . second ; } } ans += cnt ; } cout << ans ; } int main ( ) { string S = " abcab " ; int N = 5 ; countSubstring ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPosition ( int N , int M ) { if ( M > ( N / 2 ) ) { return ( M - ( N / 2 ) ) ; } return ( M + ( N / 2 ) ) ; } int main ( ) { int N = 8 , M = 5 ; cout << getPosition ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void number_of_strings ( int N , int M ) { int ans = 0 ; while ( N > 0 && M > 0 ) { if ( N > M ) { if ( N >= 2 ) { N -= 2 ; -- M ; ++ ans ; } else { break ; } } else { if ( M >= 2 ) { M -= 2 ; -- N ; ++ ans ; } else { break ; } } } cout << ans ; } int main ( ) { int N = 4 , M = 19 ; number_of_strings ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool NegEqu ( int N , int X , int Y ) { while ( X -- and N > N / 2 + 10 ) { N = N / 2 + 10 ; } while ( Y -- ) { N = N - 10 ; } if ( N <= 0 ) return true ; return false ; } int main ( ) { int N = 100 ; int X = 3 ; int Y = 4 ; if ( NegEqu ( N , X , Y ) ) { cout << " Yes " ; } else { cout << " No " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSoln ( int n , int x , int y ) { int ans = INT_MIN ; for ( int k = 0 ; k <= n ; k ++ ) { if ( k % x == y ) { ans = max ( ans , k ) ; } } return ( ( ans >= 0 && ans <= n ) ? ans : -1 ) ; } int main ( ) { int n = 15 , x = 10 , y = 5 ; cout << findMaxSoln ( n , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int RightAngled ( int a [ ] [ 2 ] , int n ) { unordered_map < int , int > xpoints ; unordered_map < int , int > ypoints ; for ( int i = 0 ; i < n ; i ++ ) { xpoints [ a [ i ] [ 0 ] ] ++ ; ypoints [ a [ i ] [ 1 ] ] ++ ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( xpoints [ a [ i ] [ 0 ] ] >= 1 && ypoints [ a [ i ] [ 1 ] ] >= 1 ) { count += ( xpoints [ a [ i ] [ 0 ] ] - 1 ) * ( ypoints [ a [ i ] [ 1 ] ] - 1 ) ; } } return count ; } int main ( ) { int N = 5 ; int arr [ ] [ 2 ] = { { 1 , 2 } , { 2 , 1 } , { 2 , 2 } , { 2 , 3 } , { 3 , 2 } } ; cout << RightAngled ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void printArray ( vector < int > & brr ) { for ( auto & it : brr ) { cout << it << ' ▁ ' ; } } void RepeatingSubarray ( int arr [ ] , int N ) { if ( N < 2 ) { cout << " - 1" ; } vector < int > brr ; brr . push_back ( arr [ 0 ] ) ; brr . push_back ( arr [ 1 ] ) ; for ( int i = 2 ; i < N / 2 + 1 ; i ++ ) { if ( N % i == 0 ) { bool a = false ; int n = brr . size ( ) ; int j = i ; while ( j < N ) { int K = j % i ; if ( arr [ j ] == brr [ K ] ) { j ++ ; } else { a = true ; break ; } } if ( ! a && j == N ) { printArray ( brr ) ; return ; } } brr . push_back ( arr [ i ] ) ; } cout << " - 1" ; return ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 1 , 2 , 2 , 1 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RepeatingSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long smallestCommon ( long a , long b , long c , long d ) { if ( a == c ) return a ; if ( a > c ) { swap ( a , c ) ; swap ( b , d ) ; } long first_term_diff = ( c - a ) ; long possible_y ; for ( possible_y = 0 ; possible_y < b ; possible_y ++ ) { if ( ( first_term_diff % b + possible_y * d ) % b == 0 ) { break ; } } if ( possible_y != b ) { return c + possible_y * d ; } return -1 ; } int main ( ) { long A = 2 , B = 20 , C = 19 , D = 9 ; cout << smallestCommon ( A , B , C , D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumFlips ( string s , int n ) { int a [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( s [ i ] == '1' ? 1 : 0 ) ; } int oddone [ n + 1 ] ; int evenone [ n + 1 ] ; oddone [ 0 ] = 0 ; evenone [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) { oddone [ i + 1 ] = oddone [ i ] + ( a [ i ] == 1 ? 1 : 0 ) ; evenone [ i + 1 ] = evenone [ i ] + ( a [ i ] == 0 ? 1 : 0 ) ; } else { oddone [ i + 1 ] = oddone [ i ] + ( a [ i ] == 0 ? 1 : 0 ) ; evenone [ i + 1 ] = evenone [ i ] + ( a [ i ] == 1 ? 1 : 0 ) ; } } int minimum = min ( oddone [ n ] , evenone [ n ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( n % 2 != 0 ) { minimum = min ( minimum , oddone [ n ] - oddone [ i + 1 ] + evenone [ i + 1 ] ) ; minimum = min ( minimum , evenone [ n ] - evenone [ i + 1 ] + oddone [ i + 1 ] ) ; } } return minimum ; } int main ( ) { string S = "000001100" ; int n = S . length ( ) ; cout << ( MinimumFlips ( S , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isprm ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 1 ; if ( n % 2 == 0 n % 3 == 0 ) return 0 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return 0 ; return 1 ; } void shortestpath ( int m , int n ) { vector < int > mfactor , nfactor ; map < int , int > fre ; mfactor . push_back ( m ) ; fre [ m ] = 1 ; while ( m != 1 ) { if ( isprm ( m ) ) { mfactor . push_back ( 1 ) ; fre [ 1 ] = 1 ; m = 1 ; } else { for ( int i = 2 ; i <= sqrt ( m ) ; i ++ ) { if ( m % i == 0 ) { mfactor . push_back ( m / i ) ; fre [ m / i ] = 1 ; m = ( m / i ) ; break ; } } } } nfactor . push_back ( n ) ; while ( fre [ n ] != 1 ) { if ( isprm ( n ) ) { nfactor . push_back ( 1 ) ; n = 1 ; } else { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { nfactor . push_back ( n / i ) ; n = ( n / i ) ; break ; } } } } for ( int i = 0 ; i < mfactor . size ( ) ; i ++ ) { if ( mfactor [ i ] == n ) break ; cout << mfactor [ i ] << " ▁ < - - > ▁ " ; } for ( int i = nfactor . size ( ) - 1 ; i >= 0 ; i -- ) { if ( i == 0 ) cout << nfactor [ i ] ; else cout << nfactor [ i ] << " ▁ < - - > ▁ " ; } } int main ( ) { int m = 18 , n = 19 ; shortestpath ( m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; int NumberOfTrees ( int arr [ ] , int N ) { int maxElement = * max_element ( arr , arr + N ) ; int level [ maxElement + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < maxElement ; i ++ ) { for ( int j = 0 ; j < level [ i + 1 ] ; j ++ ) { ans = ( ans * level [ i ] ) % mod ; } } return ans ; } int main ( ) { int N = 7 ; int arr [ ] = { 0 , 3 , 2 , 1 , 2 , 2 , 1 } ; cout << NumberOfTrees ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string gameMax ( string S ) { int N = S . length ( ) ; vector < int > list ; int one = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) { one ++ ; } else { if ( one != 0 ) { list . push_back ( one ) ; } one = 0 ; } } if ( one != 0 ) { list . push_back ( one ) ; } sort ( list . begin ( ) , list . end ( ) , greater < int > ( ) ) ; int score_1 = 0 , score_2 = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { if ( list [ i ] % 2 == 1 ) { score_1 += list [ i ] ; } else { score_2 += list [ i ] ; } } if ( score_1 == score_2 ) return " - 1" ; return ( score_1 > score_2 ) ? " Player ▁ 1" : " Player ▁ 2" ; } int main ( ) { string S = "11111101" ; cout << gameMax ( S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( string str , int a , int b ) { int openUnbalanced = 0 ; int closedUnbalanced = 0 ; int openCount = 0 ; int closedCount = 0 ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == ' ( ' ) { openUnbalanced ++ ; openCount ++ ; } else { if ( openUnbalanced == 0 ) closedUnbalanced ++ ; else openUnbalanced -- ; closedCount ++ ; } } int result = a * ( abs ( openCount - closedCount ) ) ; if ( closedCount > openCount ) closedUnbalanced -= ( closedCount - openCount ) ; if ( openCount > closedCount ) openUnbalanced -= ( openCount - closedCount ) ; result += min ( a * ( openUnbalanced + closedUnbalanced ) , b * closedUnbalanced ) ; cout << result << endl ; } int main ( ) { string str = " ) ) ( ) ( ( ) ( ) ( " ; int A = 1 , B = 3 ; minCost ( str , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int Mod = 1e9 + 7 ; int power ( int X , int Y , int Mod ) { if ( Y == 0 ) return 1 ; int p = power ( X , Y / 2 , Mod ) % Mod ; p = ( p * p ) % Mod ; if ( Y & 1 ) { p = ( X * p ) % Mod ; } return p ; } int Inversefactorial ( int N ) { if ( N <= 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( fact * i ) % Mod ; } return power ( fact , Mod - 2 , Mod ) ; } int factorial ( int N ) { if ( N <= 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( fact * i ) % Mod ; } return fact ; } int nck ( int N , int K ) { int factN = factorial ( N ) ; int inv = Inversefactorial ( K ) ; int invFact = Inversefactorial ( N - K ) ; return ( ( ( factN * inv ) % Mod ) * invFact ) % Mod ; } int TotalWaYs ( int N , int M ) { if ( ( N + M ) % 3 != 0 ) return 0 ; int X = N - ( N + M ) / 3 ; int Y = M - ( N + M ) / 3 ; if ( X < 0 Y < 0 ) return 0 ; return nck ( X + Y , Y ) ; } int main ( ) { int N = 3 , M = 3 ; cout << TotalWaYs ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkEvenSum ( int arr [ ] , int N , int size ) { int even_freq = 0 , odd_freq = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & 1 ) odd_freq ++ ; else even_freq ++ ; } if ( even_freq >= N ) return true ; else { if ( odd_freq & 1 ) { int taken = odd_freq - 1 ; int req = N - taken ; if ( even_freq < req ) { return false ; } else return true ; } else { int taken = odd_freq ; int req = N - taken ; if ( even_freq < req ) { return false ; } else return true ; } } return false ; } int main ( ) { int arr [ ] = { 9 , 2 , 3 , 4 , 18 , 7 , 7 , 6 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int N = 5 ; if ( checkEvenSum ( arr , N , size ) ) cout << " Yes " << endl ; else cout << " No " << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mindigits ( int n ) { if ( n % 9 == 0 ) { cout << n / 9 << endl ; } else { cout << ( n / 9 ) + 1 << endl ; } } int main ( ) { int n1 = 24 ; int n2 = 14 ; mindigits ( n1 ) ; mindigits ( n2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkEquall ( int arr [ ] , int N ) { int sumEven = 0 , sumOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i & 1 ) sumOdd += arr [ i ] ; else sumEven += arr [ i ] ; } if ( sumEven == sumOdd ) return true ; else return false ; } int main ( ) { int arr [ ] = { 2 , 7 , 3 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkEquall ( arr , N ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSumOfPower ( int n ) { bool isSum [ n + 1 ] ; vector < int > perfectPowers ; perfectPowers . push_back ( 1 ) ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { isSum [ i ] = false ; } for ( long long int i = 2 ; i < ( n + 1 ) ; i ++ ) { if ( isSum [ i ] == true ) { perfectPowers . push_back ( i ) ; continue ; } for ( long long int j = i * i ; j > 0 && j < ( n + 1 ) ; j *= i ) { isSum [ j ] = true ; } } for ( int i = 0 ; i < perfectPowers . size ( ) ; i ++ ) { isSum [ perfectPowers [ i ] ] = false ; } for ( int i = 0 ; i < perfectPowers . size ( ) ; i ++ ) { for ( int j = i ; j < perfectPowers . size ( ) ; j ++ ) { int sum = perfectPowers [ i ] + perfectPowers [ j ] ; if ( sum < ( n + 1 ) ) isSum [ sum ] = true ; } } return isSum [ n ] ; } int main ( ) { int n = 9 ; if ( isSumOfPower ( n ) ) { cout << " true STRNEWLINE " ; } else { cout << " false STRNEWLINE " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countEvenSum ( int low , int high , int k ) { int even_count = high / 2 - ( low - 1 ) / 2 ; int odd_count = ( high + 1 ) / 2 - low / 2 ; long even_sum = 1 ; long odd_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { long prev_even = even_sum ; long prev_odd = odd_sum ; even_sum = ( prev_even * even_count ) + ( prev_odd * odd_count ) ; odd_sum = ( prev_even * odd_count ) + ( prev_odd * even_count ) ; } cout << ( even_sum ) ; } int main ( ) { int low = 4 ; int high = 5 ; int K = 3 ; countEvenSum ( low , high , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void update ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] += ( i + 1 ) ; } } bool check ( int arr [ ] , int N ) { bool f = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { count ++ ; } } if ( count >= 2 ) { f = 1 ; break ; } } if ( f == 1 ) return true ; else return false ; } void incrementCount ( int arr [ ] , int N ) { int min = 0 ; while ( check ( arr , N ) != true ) { update ( arr , N ) ; min ++ ; } cout << min ; } int main ( ) { int N = 3 ; int arr [ N ] = { 12 , 8 , 4 } ; incrementCount ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkPossible ( int a [ ] , int n ) { int even_no_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) even_no_count ++ ; } if ( n / 2 > even_no_count ) { cout << " No " << endl ; return ; } cout << " Yes " << endl ; int j = 0 ; for ( int i = 1 ; i < n ; i += 2 ) { if ( a [ i ] % 2 == 0 ) continue ; else { while ( j < n && a [ j ] % 2 != 0 ) j += 2 ; a [ i ] += a [ j ] ; a [ j ] = a [ i ] - a [ j ] ; a [ i ] -= a [ j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkPossible ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxORminusXOR ( int N ) { int MSB = log2 ( N ) ; int M = 0 ; for ( int i = 0 ; i <= MSB ; i ++ ) M += ( 1 << i ) ; return M ; } int main ( ) { int N = 10 ; cout << maxORminusXOR ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int No_of_Triangle ( int N , int K ) { if ( N < K ) return -1 ; else { int Tri_up = 0 ; Tri_up = ( ( N - K + 1 ) * ( N - K + 2 ) ) / 2 ; int Tri_down = 0 ; Tri_down = ( ( N - 2 * K + 1 ) * ( N - 2 * K + 2 ) ) / 2 ; return Tri_up + Tri_down ; } } int main ( ) { int N = 4 , K = 2 ; cout << No_of_Triangle ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canMake ( int n , int ar [ ] ) { if ( n == 1 ) return true ; else { if ( ar [ 0 ] < ar [ 1 ] ) { int i = 1 ; while ( i < n && ar [ i - 1 ] < ar [ i ] ) { i ++ ; } while ( i + 1 < n && ar [ i ] > ar [ i + 1 ] ) { i ++ ; } if ( i >= n - 1 ) return true ; else return false ; } else if ( ar [ 0 ] > ar [ 1 ] ) { int i = 1 ; while ( i < n && ar [ i - 1 ] > ar [ i ] ) { i ++ ; } while ( i + 1 < n && ar [ i ] < ar [ i + 1 ] ) { i ++ ; } if ( i >= n - 1 ) return true ; else return false ; } else { for ( int i = 2 ; i < n ; i ++ ) { if ( ar [ i - 1 ] <= ar [ i ] ) return false ; } return true ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof arr / sizeof arr [ 0 ] ; if ( canMake ( n , arr ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int check_length ( int n ) { int ans = 0 ; while ( n ) { n = n >> 1 ; ans ++ ; } return ans ; } int check_ith_bit ( int n , int i ) { return ( n & ( 1 << ( i - 1 ) ) ) ? true : false ; } int no_of_flips ( int n ) { int len = check_length ( n ) ; int ans = 0 ; int right = 1 ; int left = len ; while ( right < left ) { if ( check_ith_bit ( n , right ) != check_ith_bit ( n , left ) ) ans ++ ; left -- ; right ++ ; } return ans ; } int main ( ) { int n = 12 ; cout << no_of_flips ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRank ( int A [ ] , int N ) { int rank [ N ] = { } ; stack < int > s ; s . push ( A [ N - 1 ] ) ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( A [ i ] < s . top ( ) ) { s . push ( A [ i ] ) ; rank [ i ] = s . size ( ) - 1 ; } else { while ( ! s . empty ( ) && A [ i ] >= s . top ( ) ) { s . pop ( ) ; } s . push ( A [ i ] ) ; rank [ i ] = s . size ( ) - 1 ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << rank [ i ] << " ▁ " ; } } int main ( ) { int A [ ] = { 1 , 2 , 3 , 5 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findRank ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestString ( int n , int k , string s ) { deque < char > deq ; for ( int i = 0 ; i < n ; ++ i ) { while ( deq . size ( ) > 0 && deq . back ( ) < s [ i ] && k > 0 ) { deq . pop_front ( ) ; k -- ; } deq . push_back ( s [ i ] ) ; } string st = " " ; for ( char c : deq ) st = st + c ; return st ; } int main ( ) { int n = 4 ; int k = 2 ; string sc = " ritz " ; string result = largestString ( n , k , sc ) ; cout << result << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBit ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = 0 ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; } int countSetBits ( int L , int R ) { return abs ( countSetBit ( R ) - countSetBit ( L - 1 ) ) ; } int main ( ) { int L = 3 , R = 5 ; cout << " Total ▁ set ▁ bit ▁ count ▁ is ▁ " << countSetBits ( L , R ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { int n = i ; while ( n > 0 ) { count += ( n & 1 ) ; n = n >> 1 ; } } return count ; } int main ( ) { int L = 3 , R = 5 ; cout << " Total ▁ set ▁ Bit ▁ count ▁ is ▁ " << countSetBits ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countElement ( int A [ ] , int N , int B [ ] , int M , int K ) { int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { int currentElement = B [ i ] ; for ( int j = 0 ; j < N ; j ++ ) { int diff = abs ( currentElement - A [ j ] ) ; if ( diff <= K ) { cnt ++ ; break ; } } } cout << cnt ; } int main ( ) { int A [ ] = { 100 , 65 , 35 , 85 , 55 } ; int B [ ] = { 30 , 60 , 75 , 95 } ; int K = 5 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int M = sizeof ( B ) / sizeof ( B [ 0 ] ) ; countElement ( A , N , B , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createString ( int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << ' a ' ; } for ( int i = 0 ; i < N ; i ++ ) { cout << ' b ' ; } } int main ( ) { int N = 4 ; createString ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestString ( string num , int k ) { string ans = " " ; for ( auto i : num ) { while ( ans . length ( ) && ans . back ( ) < i && k > 0 ) { ans . pop_back ( ) ; k -- ; } ans . push_back ( i ) ; } while ( ans . length ( ) and k -- ) { ans . pop_back ( ) ; } return ans ; } int main ( ) { string str = " zyxedcba " ; int k = 1 ; cout << largestString ( str , k ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubset ( vector < int > & A , bool flag ) { int n = A . size ( ) ; int sum = 0 ; if ( flag ) { for ( int i = 1 ; i < n ; i ++ ) A [ i ] = - A [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( A [ i ] > 0 ) { sum += A [ i ] ; } } return sum ; } int findBest ( vector < int > A ) { int x = maxSubset ( A , 0 ) ; int y = maxSubset ( A , 1 ) ; y = - y ; y += A [ 0 ] ; y = - y ; return max ( x , y ) ; } int main ( ) { vector < int > A = { 1 , 10 , 4 , -6 , 3 } ; cout << findBest ( A ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < string > solve ( int n , int arr [ ] ) { string s = string ( n , ' a ' ) ; vector < string > ans ; ans . push_back ( s ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = s [ arr [ i ] ] ; if ( ch == ' b ' ) ch = ' a ' ; else ch = ' b ' ; s [ arr [ i ] ] = ch ; ans . push_back ( s ) ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 0 , 3 } ; int n = sizeof arr / sizeof arr [ 0 ] ; vector < string > ans = solve ( n , arr ) ; for ( int i = ans . size ( ) - 1 ; i >= 0 ; i -- ) { cout << ans [ i ] << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSwaps ( int A [ ] , int n ) { map < int , int > mp ; int max_frequency = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mp [ A [ i ] ] ++ ; max_frequency = max ( max_frequency , mp [ A [ i ] ] ) ; } return n - max_frequency ; } int main ( ) { int A [ ] = { 6 , 5 , 4 , 3 , 2 , 1 } ; cout << countSwaps ( A , 6 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_operation ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) ans += abs ( a [ i ] - a [ i - 1 ] ) ; else ans += abs ( a [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min_operation ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void FindMatrix ( int n , int m , int x , int y ) { int a , b , i , j ; if ( n * m == 1 ) { if ( x > y ) { cout << y << " STRNEWLINE " ; } else { cout << x << " STRNEWLINE " ; } return ; } a = min ( x , y ) ; b = min ( 2 * x , y ) - a ; bool flag = true ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( flag ) cout << a << ' ▁ ' ; else cout << b << ' ▁ ' ; flag = ! flag ; } if ( ( ( n % 2 != 0 && m % 2 == 0 ) || ( n % 2 == 0 && m % 2 == 0 ) ) ) flag = ! flag ; cout << " STRNEWLINE " ; } } int main ( ) { int N , M , X , Y ; N = 3 ; M = 3 ; X = 5 ; Y = 3 ; FindMatrix ( N , M , X , Y ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinRoute ( vector < vector < int > > tsp ) { int sum = 0 ; int counter = 0 ; int j = 0 , i = 0 ; int min = INT_MAX ; map < int , int > visitedRouteList ; visitedRouteList [ 0 ] = 1 ; int route [ tsp . size ( ) ] ; while ( i < tsp . size ( ) && j < tsp [ i ] . size ( ) ) { if ( counter >= tsp [ i ] . size ( ) - 1 ) { break ; } if ( j != i && ( visitedRouteList [ j ] == 0 ) ) { if ( tsp [ i ] [ j ] < min ) { min = tsp [ i ] [ j ] ; route [ counter ] = j + 1 ; } } j ++ ; if ( j == tsp [ i ] . size ( ) ) { sum += min ; min = INT_MAX ; visitedRouteList [ route [ counter ] - 1 ] = 1 ; j = 0 ; i = route [ counter ] - 1 ; counter ++ ; } } i = route [ counter - 1 ] - 1 ; for ( j = 0 ; j < tsp . size ( ) ; j ++ ) { if ( ( i != j ) && tsp [ i ] [ j ] < min ) { min = tsp [ i ] [ j ] ; route [ counter ] = j + 1 ; } } sum += min ; cout << ( " Minimum ▁ Cost ▁ is ▁ : ▁ " ) ; cout << ( sum ) ; } int main ( ) { vector < vector < int > > tsp = { { -1 , 10 , 15 , 20 } , { 10 , -1 , 35 , 25 } , { 15 , 35 , -1 , 30 } , { 20 , 25 , 30 , -1 } } ; findMinRoute ( tsp ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCount ( vector < int > & Arr1 , vector < int > & Arr2 ) { int MAX = max ( * max_element ( Arr1 . begin ( ) , Arr1 . end ( ) ) , * max_element ( Arr2 . begin ( ) , Arr2 . end ( ) ) ) ; vector < int > Count ( 2 * MAX + 1 , 0 ) ; int n = Arr1 . size ( ) , m = Arr2 . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int element = Arr1 [ i ] + Arr2 [ j ] ; Count [ element ] ++ ; } } for ( int i = 1 ; i <= 2 * MAX ; i ++ ) { if ( Count [ i ] > 0 ) { cout << i << " - > " << Count [ i ] << endl ; } } } int main ( ) { vector < int > arr1 = { 1 , 2 } ; vector < int > arr2 = { 1 , 2 , 1 } ; findCount ( arr1 , arr2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void count ( int n , int k ) { long count = ( long ) ( pow ( 10 , k ) - pow ( 10 , k - 1 ) ) ; cout << ( count ) ; } int main ( ) { int n = 2 , k = 1 ; count ( n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findAandB ( double N ) { if ( N == 1 ) { cout << " No " ; return ; } double a = N * N / ( N - 1 ) ; double b = a / N ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; } int main ( ) { double N = 6 ; findAandB ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSelections ( int A [ ] , int n , int k ) { sort ( A , A + n ) ; int sum = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + A [ i ] ; if ( sum > k ) { break ; } count ++ ; } return count ; } int main ( ) { int A [ ] = { 3 , 7 , 2 , 9 , 4 } ; int k = 15 ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << maxSelections ( A , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void computePair ( double K ) { if ( K == 1 ) { cout << " No " ; return ; } else { cout << K * K / ( K - 1 ) << " ▁ " ; cout << K / ( K - 1 ) << endl ; } } int main ( ) { double K = 6 ; computePair ( K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int func ( int N , int P ) { int sumUptoN = ( N * ( N + 1 ) / 2 ) ; int sumOfMultiplesOfP ; if ( N < P ) { return sumUptoN ; } else if ( ( N / P ) == 1 ) { return sumUptoN - P + 1 ; } sumOfMultiplesOfP = ( ( N / P ) * ( 2 * P + ( N / P - 1 ) * P ) ) / 2 ; return ( sumUptoN + func ( N / P , P ) - sumOfMultiplesOfP ) ; } int main ( ) { int N = 10 , P = 5 ; cout << func ( N , P ) << " STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void number ( int num ) { int a [ 20 ] , r , i = 0 , j ; while ( num > 0 ) { r = num % 10 ; if ( 9 - r > r ) a [ i ] = r ; else a [ i ] = 9 - r ; i ++ ; num = num / 10 ; } if ( a [ i - 1 ] == 0 ) { cout << 9 ; i -- ; } for ( j = i - 1 ; j >= 0 ; j -- ) cout << a [ j ] ; } int main ( ) { long long int num = 4545 ; number ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findShifts ( int A [ ] , int N ) { int shift [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == A [ i ] - 1 ) shift [ i ] = 0 ; else shift [ i ] = ( A [ i ] - 1 - i + N ) % N ; } for ( int i = 0 ; i < N ; i ++ ) cout << shift [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 4 , 3 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findShifts ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisible ( int N ) { return ( N - 1 ) % 3 != 0 ; } int main ( ) { int N = 6 ; if ( isDivisible ( N ) ) cout << ( " Yes " ) ; else cout << ( " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxLengthSubArray ( int A [ ] , int N ) { int forward [ N ] , backward [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 A [ i ] != A [ i - 1 ] ) { forward [ i ] = 1 ; } else forward [ i ] = forward [ i - 1 ] + 1 ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 A [ i ] != A [ i + 1 ] ) { backward [ i ] = 1 ; } else backward [ i ] = backward [ i + 1 ] + 1 ; } int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] != A [ i + 1 ] ) ans = max ( ans , min ( forward [ i ] , backward [ i + 1 ] ) * 2 ) ; } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 6 , 6 , 6 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxLengthSubArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigitSum ( int N , int K ) { int l = ( int ) pow ( 10 , N - 1 ) , r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; int digits [ N ] ; for ( int j = N - 1 ; j >= 0 ; j -- ) { digits [ j ] = num % 10 ; num /= 10 ; } int sum = 0 , flag = 0 ; for ( int j = 0 ; j < K ; j ++ ) sum += digits [ j ] ; for ( int j = 1 ; j < N - K + 1 ; j ++ ) { int curr_sum = 0 ; for ( int m = j ; m < j + K ; m ++ ) curr_sum += digits [ m ] ; if ( sum != curr_sum ) { flag = 1 ; break ; } } if ( flag == 0 ) { count ++ ; } } return count ; } int main ( ) { int N = 2 , K = 1 ; cout << countDigitSum ( N , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool possible ( int N , int a , int b , int n ) { int sum_of_angle = 180 * ( N - 2 ) ; int Total_angle = ( N * ( ( 2 * a ) + ( N - 1 ) * b ) ) / 2 ; if ( sum_of_angle != Total_angle ) return false ; else return true ; } int nth_angle ( int N , int a , int b , int n ) { int nth = 0 ; nth = a + ( n - 1 ) * b ; return nth ; } int main ( ) { int N = 3 , a = 30 , b = 30 , n = 3 ; if ( possible ( N , a , b , n ) ) cout << nth_angle ( N , a , b , n ) ; else cout << " Not ▁ Possible " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int is_linear ( string s ) { int tmp = 0 ; char first = s [ 0 ] ; for ( int pos = 0 ; pos < s . length ( ) ; pos += tmp ) { if ( s [ pos ] != first ) { return false ; } tmp ++ ; } return true ; } int main ( ) { string str = " aapaxyayziabcde " ; if ( is_linear ( str ) ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void DFS ( int U , int * vis , vector < int > adj [ ] ) { vis [ U ] = 1 ; for ( int V : adj [ U ] ) { if ( vis [ V ] == 0 ) DFS ( V , vis , adj ) ; } } void minCost ( int N , int M , int vCost , int eCost , int sorc [ ] , vector < int > colored , int destination [ ] ) { vector < int > adj [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { adj [ sorc [ i ] ] . push_back ( destination [ i ] ) ; adj [ destination [ i ] ] . push_back ( sorc [ i ] ) ; } int vis [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < colored . size ( ) ; i ++ ) { DFS ( colored [ i ] , vis , adj ) ; } int X = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( vis [ i ] == 0 ) { X ++ ; DFS ( i , vis , adj ) ; } } int mincost = X * min ( vCost , eCost ) ; cout << mincost << endl ; } int main ( ) { int N = 3 , M = 1 ; int sorc [ ] = { 1 } ; int destination [ ] = { 2 } ; int vCost = 3 , eCost = 2 ; vector < int > colored = { 1 } ; minCost ( N , M , vCost , eCost , sorc , colored , destination ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_cost ( int n , int x , int p , int q ) { if ( x == 1 ) { cout << ( n - 1 ) * p << endl ; return 0 ; } int ans = ( n - 1 ) * p ; int pre = 0 ; while ( n > 1 ) { int tmp = n / x ; if ( tmp < 0 ) break ; pre += ( n - tmp * x ) * p ; n /= x ; pre += q ; ans = min ( ans , pre + ( n - 1 ) * p ) ; } return ans ; } int main ( ) { int n = 5 , x = 2 , p = 2 , q = 3 ; cout << min_cost ( n , x , p , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateWays ( int arr1 [ ] , int arr2 [ ] , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= ( N ) ; b ++ ) for ( int c = 0 ; c <= C && b * 5 + c * 10 <= ( N ) ; c ++ ) for ( int d = 0 ; d <= D && b * 5 + c * 10 + d * 20 <= ( N ) ; d ++ ) if ( ( b * 5 ) + ( c * 10 ) + ( d * 20 ) >= ( N - A ) ) ans ++ ; return ans ; } int main ( ) { int N = 123 ; int arr1 [ ] = { 1 , 5 , 10 , 20 } ; int arr2 [ ] = { 6 , 4 , 3 , 5 } ; cout << calculateWays ( arr1 , arr2 , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ways [ 1010 ] ; int calculateWays ( int arr1 [ ] , int arr2 [ ] , int N ) { int A = arr2 [ 0 ] , B = arr2 [ 1 ] ; int C = arr2 [ 2 ] , D = arr2 [ 3 ] ; int ans = 0 ; for ( int b = 0 ; b <= B && b * 5 <= N ; b ++ ) { for ( int a = 0 ; a <= A && a * 1 + b * 5 <= N ; a ++ ) { ways [ a + b * 5 ] ++ ; } } for ( int c = 0 ; c <= C && c * 10 <= ( N ) ; c ++ ) { for ( int d = 0 ; d <= D && c * 10 + d * 20 <= ( N ) ; d ++ ) { ans += ways [ N - c * 10 - d * 20 ] ; } } return ans ; } int main ( ) { int N = 123 ; int arr1 [ ] = { 1 , 5 , 10 , 20 } ; int arr2 [ ] = { 6 , 4 , 3 , 5 } ; cout << calculateWays ( arr1 , arr2 , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minNum ( int n ) { if ( n < 3 ) cout << -1 ; else cout << ( 210 * ( ( int ) ( pow ( 10 , n - 1 ) / 210 ) + 1 ) ) ; } int main ( ) { int n = 5 ; minNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countMissingNum ( int a [ ] , int N ) { int count = a [ N - 1 ] - a [ 0 ] + 1 - N ; cout << count << endl ; } int main ( ) { int arr [ ] = { 5 , 10 , 20 , 40 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countMissingNum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructmatrix ( int N ) { bool check = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) { cout << 1 << " ▁ " ; } else if ( check ) { cout << 2 << " ▁ " ; check = false ; } else { cout << -2 << " ▁ " ; check = true ; } } cout << endl ; } } int main ( ) { int N = 5 ; constructmatrix ( 5 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int maxXORSubsequence ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; else even ++ ; } int maxlen ; if ( odd == n ) { if ( odd % 2 == 0 ) maxlen = n - 1 ; else maxlen = n ; } else if ( even == n ) { maxlen = 0 ; } else { if ( odd % 2 == 0 ) maxlen = even + odd - 1 ; else maxlen = even + odd ; } } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxXORSubsequence ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int good_pair ( string str [ ] , int N ) { int countStr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { string res = str [ i ] + str [ j ] ; int vowel [ 5 ] = { 0 } ; for ( int k = 0 ; k < res . length ( ) ; k ++ ) { if ( res [ k ] == ' a ' ) vowel [ 0 ] = 1 ; else if ( res [ k ] == ' e ' ) vowel [ 1 ] = 1 ; else if ( res [ k ] == ' i ' ) vowel [ 2 ] = 1 ; else if ( res [ k ] == ' o ' ) vowel [ 3 ] = 1 ; else if ( res [ k ] == ' u ' ) vowel [ 4 ] = 1 ; } int temp = 0 ; for ( int ind = 0 ; ind < 5 ; ind ++ ) { if ( vowel [ ind ] == 1 ) temp ++ ; } if ( temp == 5 ) countStr ++ ; } } return countStr ; } int main ( ) { string arr [ ] = { " aaweiolkju " , " oxdfgujkmi " } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << good_pair ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sieveOfEratosthenes ( int N , int s [ ] ) { vector < bool > prime ( N + 1 , false ) ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } int generatePrimeFactors ( int N ) { int s [ N + 1 ] ; int sum = 0 ; sieveOfEratosthenes ( N , s ) ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } sum = sum + cnt ; curr = s [ N ] ; cnt = 1 ; } return sum ; } void findSum ( int N ) { int sum = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { sum += generatePrimeFactors ( i ) ; } cout << sum << endl ; } int main ( ) { int N = 4 ; findSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCM ( int a , int b ) { int lcm = a > b ? a : b ; while ( true ) { if ( lcm % a == 0 && lcm % b == 0 ) break ; else lcm ++ ; } return lcm ; } void findMinLCM ( int arr [ ] , int n ) { int minLCM = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int val = LCM ( arr [ i ] , arr [ i + 1 ] ) ; if ( val < minLCM ) { minLCM = val ; } } cout << minLCM << endl ; } int main ( ) { int arr [ ] = { 4 , 8 , 12 , 16 , 20 , 24 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMinLCM ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_max ( int n , int k ) { bitset < 32 > X ( 0 ) ; int cnt = 0 ; for ( int i = 31 ; i >= 0 && cnt != k ; i -- ) { if ( n & ( 1 << i ) ) { X [ i ] = 1 ; cnt ++ ; } } return X . to_ulong ( ) ; } int main ( ) { int n = 10 , k = 2 ; cout << find_max ( n , k ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void convert ( string s ) { int num = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + ( int ( s [ i ] ) - 48 ) ; cout << num ; } int main ( ) { char s [ ] = "123" ; convert ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define hell  1000000007 NEW_LINE #define N  100005 NEW_LINE void count_k ( vector < int > & arr , int & c_0 , int & c_1 , int & c_2 , stack < int > & ones , stack < int > & twos , stack < int > & zeros ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] % 3 == 0 ) { c_0 ++ ; zeros . push ( arr [ i ] ) ; } else if ( arr [ i ] % 3 == 1 ) { c_1 ++ ; ones . push ( arr [ i ] ) ; } else { c_2 ++ ; twos . push ( arr [ i ] ) ; } } return ; } void printArrangement ( vector < int > & arr , int & c_0 , int & c_1 , int & c_2 , stack < int > & ones , stack < int > & twos , stack < int > & zeros ) { if ( ( c_0 == 0 && c_1 != 0 && c_2 != 0 ) or c_0 > c_1 + c_2 + 1 ) { cout << " - 1" ; return ; } if ( c_0 == 0 ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { cout << arr [ i ] << " ▁ " ; } return ; } int i , j , ans [ N ] ; memset ( ans , -1 , sizeof ( ans ) ) ; for ( i = 1 , j = 0 ; j < c_1 ; i += 2 , j ++ ) { ans [ i ] = ones . top ( ) ; ones . pop ( ) ; } ans [ i - 1 ] = zeros . top ( ) ; zeros . pop ( ) ; c_0 -- ; for ( j = 0 ; j < c_2 ; j ++ , i += 2 ) { ans [ i ] = twos . top ( ) ; twos . pop ( ) ; } for ( int k = 0 ; c_0 > 0 ; k += 2 ) { if ( ans [ k ] == -1 ) { ans [ k ] = zeros . top ( ) ; c_0 -- ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( ans [ i ] != -1 ) cout << ans [ i ] << " ▁ " ; } return ; } void solve ( int n , vector < int > & arr ) { stack < int > ones , zeros , twos ; int c_0 = 0 , c_1 = 0 , c_2 = 0 ; count_k ( arr , c_0 , c_1 , c_2 , ones , twos , zeros ) ; printArrangement ( arr , c_0 , c_1 , c_2 , ones , twos , zeros ) ; } signed main ( ) { int n = 5 ; vector < int > arr { 1 , 2 , 3 , 4 , 5 } ; solve ( n , arr ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countUniqueDigits ( int N ) { int res = 0 ; int cnt [ 10 ] = { 0 } ; while ( N > 0 ) { int rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( cnt [ i ] == 1 ) { res ++ ; } } return res ; } int main ( ) { int N = 2234262 ; cout << countUniqueDigits ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkUniqueFrequency ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } unordered_set < int > uniqueFreq ; for ( auto & i : freq ) { if ( uniqueFreq . count ( i . second ) ) return false ; else uniqueFreq . insert ( i . second ) ; } return true ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 5 } ; int n = sizeof arr / sizeof arr [ 0 ] ; bool res = checkUniqueFrequency ( arr , n ) ; if ( res ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double power ( int N , int P ) { return pow ( N , P ) ; } int Log2 ( int N ) { int result = ( int ) ( log ( N ) / log ( 2 ) ) ; return result ; } double specialSum ( int n ) { double sum = n * ( n + 1 ) / 2 ; int a = Log2 ( n ) ; sum = sum + power ( 2 , a + 1 ) - 1 ; return sum ; } int main ( ) { int n = 4 ; cout << ( specialSum ( n ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Permute ( vector < int > & arr , int n ) { int odd = 0 , four = 0 ; int non_four = 0 ; vector < int > ODD , FOUR , NON_FOUR ; for ( auto x : arr ) { if ( x & 1 ) { odd ++ ; ODD . push_back ( x ) ; } else if ( x % 4 == 0 ) { four ++ ; FOUR . push_back ( x ) ; } else { non_four ++ ; NON_FOUR . push_back ( x ) ; } } if ( non_four == 0 && four >= odd - 1 ) { int x = ODD . size ( ) ; int y = FOUR . size ( ) ; int i ; for ( i = 0 ; i < x ; i ++ ) { cout << ODD [ i ] << " ▁ " ; if ( i < y ) cout << FOUR [ i ] << " ▁ " ; } while ( i < y ) cout << FOUR [ i ] << " ▁ " ; cout << endl ; } else if ( non_four > 0 and four >= odd ) { int x = ODD . size ( ) ; int y = FOUR . size ( ) ; int i ; for ( i = 0 ; i < x ; i ++ ) { cout << ODD [ i ] << " ▁ " ; if ( i < y ) cout << FOUR [ i ] << " ▁ " ; } while ( i < y ) cout << FOUR [ i ] << " ▁ " ; for ( int j = 0 ; j < ( int ) NON_FOUR . size ( ) ; j ++ ) cout << NON_FOUR [ j ] << " ▁ " ; cout << endl ; } else cout << " Not ▁ Possible " << endl ; } signed main ( ) { vector < int > arr = { 2 , 7 , 1 , 8 , 2 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr ) ; Permute ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findArray ( int sum , int xorr ) { if ( xorr > sum sum % 2 != xorr % 2 ) { cout << " No ▁ Array ▁ Possible STRNEWLINE " ; return ; } if ( sum == xorr ) { if ( sum == 0 ) cout << " Array ▁ is ▁ empty " << " ▁ with ▁ size ▁ 0 STRNEWLINE " ; else cout << " Array ▁ size ▁ is ▁ " << 1 << " Array is " << sum << " STRNEWLINE " ; return ; } int mid = ( sum - xorr ) / 2 ; if ( xorr & mid == 1 ) { cout << " Array ▁ size ▁ is ▁ " << 3 << " STRNEWLINE " ; cout << " Array ▁ is ▁ " << xorr << " ▁ " << mid << " ▁ " << mid << " STRNEWLINE " ; } else { cout << " Array ▁ size ▁ is ▁ " << 2 << " STRNEWLINE " ; cout << " Array ▁ is ▁ " << ( xorr + mid ) << " ▁ " << mid << " STRNEWLINE " ; } } int main ( ) { int sum = 4 , xorr = 2 ; findArray ( sum , xorr ) ; cout << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string Kperiodicinteger ( string X , int N , int K ) { string temp = X ; for ( int i = 0 ; i < K ; i ++ ) { int j = i ; while ( j < N ) { X [ j ] = X [ i ] ; j += K ; } } if ( X >= temp ) { return X ; } int POS ; for ( int i = K - 1 ; i >= 0 ; i -- ) { if ( X [ i ] != '9' ) { X [ i ] ++ ; POS = i ; break ; } } for ( int i = POS + 1 ; i < K ; i ++ ) { X [ i ] = '0' ; } for ( int i = 0 ; i < K ; i ++ ) { int j = i ; while ( j < N ) { X [ j ] = X [ i ] ; j += K ; } } return X ; } int main ( ) { int N = 4 , K = 2 ; string X = "1215" ; cout << Kperiodicinteger ( X , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string helper ( int d , int s ) { string ans ( d , '0' ) ; for ( int i = d - 1 ; i >= 0 ; i -- ) { if ( s >= 9 ) { ans [ i ] = '9' ; s -= 9 ; } else { char c = ( char ) s + '0' ; ans [ i ] = c ; s = 0 ; } } return ans ; } string findMin ( int x , int Y ) { string y = to_string ( Y ) ; int n = y . size ( ) ; vector < int > p ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { p [ i ] = y [ i ] - '0' ; if ( i > 0 ) p [ i ] += p [ i - 1 ] ; } for ( int i = n - 1 , k = 0 ; ; i -- , k ++ ) { int d = 0 ; if ( i >= 0 ) d = y [ i ] - '0' ; for ( int j = d + 1 ; j <= 9 ; j ++ ) { int r = ( i > 0 ) * p [ i - 1 ] + j ; if ( x - r >= 0 and x - r <= 9 * k ) { string suf = helper ( k , x - r ) ; string pre = " " ; if ( i > 0 ) pre = y . substr ( 0 , i ) ; char cur = ( char ) j + '0' ; pre += cur ; return pre + suf ; } } } } int main ( ) { int x = 18 ; int y = 99 ; cout << findMin ( x , y ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void largestNumber ( int n , int X , int Y ) { int maxm = max ( X , Y ) ; Y = X + Y - maxm ; X = maxm ; int Xs = 0 ; int Ys = 0 ; while ( n > 0 ) { if ( n % Y == 0 ) { Xs += n ; n = 0 ; } else { n -= X ; Ys += X ; } } if ( n == 0 ) { while ( Xs -- > 0 ) cout << X ; while ( Ys -- > 0 ) cout << Y ; } else cout << " - 1" ; } int main ( ) { int n = 19 , X = 7 , Y = 5 ; largestNumber ( n , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( int unit_digit , int X ) { int times , digit ; for ( int times = 1 ; times <= 10 ; times ++ ) { digit = ( X * times ) % 10 ; if ( digit == unit_digit ) return times ; } return -1 ; } int getNum ( int N , int X ) { int unit_digit ; unit_digit = N % 10 ; int times = check ( unit_digit , X ) ; if ( times == -1 ) return times ; else { if ( N >= ( times * X ) ) return times ; else return -1 ; } } int main ( ) { int N = 58 , X = 7 ; cout << getNum ( N , X ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  5 NEW_LINE using namespace std ; int after_rev ( vector < int > v ) { int mini = 0 , count = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { count += v [ i ] ; if ( count > 0 ) count = 0 ; if ( mini > count ) mini = count ; } return mini ; } void print ( int arr [ N ] ) { int sum = 0 ; for ( int i = 0 ; i < N ; i += 2 ) sum += arr [ i ] ; vector < int > v1 , v2 ; for ( int i = 0 ; i + 1 < N ; i += 2 ) v1 . push_back ( arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 1 ; i + 1 < N ; i += 2 ) v2 . push_back ( arr [ i ] - arr [ i + 1 ] ) ; int change = min ( after_rev ( v1 ) , after_rev ( v2 ) ) ; if ( change < 0 ) sum += change ; cout << sum << endl ; } int main ( ) { int arr [ N ] = { 0 , 1 , 4 , 3 } ; print ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int moduloEquality ( int A [ ] , int B [ ] , int n , int m ) { map < int , int > mapA , mapB ; for ( int i = 0 ; i < n ; i ++ ) { mapA [ A [ i ] ] ++ ; mapB [ B [ i ] ] ++ ; } set < int > possibleValues ; int FirstElement = B [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int cur = A [ i ] ; possibleValues . insert ( cur > FirstElement ? m - cur + FirstElement : FirstElement - cur ) ; } int ans = INT_MAX ; for ( auto it : possibleValues ) { bool possible = true ; for ( auto it2 : mapA ) { if ( it2 . second != mapB [ ( it2 . first + it ) % m ] ) { possible = false ; break ; } } if ( possible ) { ans = min ( ans , it ) ; } } return ans ; } int main ( ) { int n = 4 ; int m = 3 ; int A [ ] = { 0 , 0 , 2 , 1 } ; int B [ ] = { 2 , 0 , 1 , 1 } ; cout << moduloEquality ( A , B , n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countCyclicShifts ( string & S , int n ) { int aux [ n ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) { if ( S [ i ] == ' ( ' ) aux [ i ] = 1 ; else aux [ i ] = -1 ; } int mn = aux [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { aux [ i ] += aux [ i - 1 ] ; mn = min ( mn , aux [ i ] ) ; } if ( aux [ n - 1 ] != 0 ) return 0 ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( aux [ i ] == mn ) count ++ ; } return count ; } int main ( ) { string S = " ) ( ) ( " ; int N = S . length ( ) ; cout << countCyclicShifts ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProfit ( int * prices , int n ) { int profit = 0 , currentDay = n - 1 ; while ( currentDay > 0 ) { int day = currentDay - 1 ; while ( day >= 0 && ( prices [ currentDay ] > prices [ day ] ) ) { profit += ( prices [ currentDay ] - prices [ day ] ) ; day -- ; } currentDay = day ; } return profit ; } int main ( ) { int prices [ ] = { 2 , 3 , 5 } ; int N = sizeof ( prices ) / sizeof ( prices [ 0 ] ) ; cout << maxProfit ( prices , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isOddStringPalindrome ( string str , int n ) { int oddStringSize = n / 2 ; bool lengthOdd = ( ( oddStringSize % 2 == 1 ) ? true : false ) ; stack < char > s ; int i = 1 ; int c = 0 ; while ( i < n && c < oddStringSize / 2 ) { s . push ( str [ i ] ) ; i += 2 ; c ++ ; } if ( lengthOdd ) i = i + 2 ; while ( i < n && s . size ( ) > 0 ) { if ( s . top ( ) == str [ i ] ) s . pop ( ) ; else break ; i = i + 2 ; } if ( s . size ( ) == 0 ) return true ; return false ; } int main ( ) { int N = 10 ; string s = " aeafacafae " ; if ( isOddStringPalindrome ( s , N ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isOddStringPalindrome ( string str , int n ) { int left , right ; if ( n % 2 == 0 ) { left = 1 ; right = n - 1 ; } else { left = 1 ; right = n - 2 ; } while ( left < n && right >= 0 && left < right ) { if ( str [ left ] != str [ right ] ) return false ; left += 2 ; right -= 2 ; } return true ; } int main ( ) { int n = 10 ; string s = " aeafacafae " ; if ( isOddStringPalindrome ( s , n ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void min_remove ( string str ) { int N = str . length ( ) ; int prefix_a [ N + 1 ] ; int prefix_b [ N + 1 ] ; int prefix_c [ N + 1 ] ; prefix_a [ 0 ] = 0 ; prefix_b [ 0 ] = 0 ; prefix_c [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix_a [ i ] = prefix_a [ i - 1 ] + ( str [ i - 1 ] == ' a ' ) ; prefix_b [ i ] = prefix_b [ i - 1 ] + ( str [ i - 1 ] == ' b ' ) ; prefix_c [ i ] = prefix_c [ i - 1 ] + ( str [ i - 1 ] == ' c ' ) ; } int maxi = INT_MIN ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = i ; j <= N ; j ++ ) { maxi = max ( maxi , ( prefix_a [ i ] + ( prefix_b [ j ] - prefix_b [ i ] ) + ( prefix_c [ N ] - prefix_c [ j ] ) ) ) ; } } cout << ( N - maxi ) << endl ; } int main ( ) { string str = " aaaabaaxccac " ; min_remove ( str ) ; return 0 ; }
#include using namespace std ; int maximum_partition ( string str ) { int i = 0 , j = 0 , k = 0 ; int c = 0 , r = 0 ; unordered_map m ; for ( i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( m [ str [ i ] ] == 0 ) { m [ str [ i ] ] = i ; } } i = 0 ; k = m [ str [ i ] ] ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( i <= k ) { c = c + 1 ; k = max ( k , m [ str [ i ] ] ) ; } else { r = r + 1 ; c = 1 ; k = max ( k , m [ str [ i ] ] ) ; } } if ( c != 0 ) { r = r + 1 ; } return r ; } int main ( ) { string str = " ababcbacadefegdehijhklij " ; cout << maximum_partition ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findAns ( vector < vector < int > > mat , int x , int y , int n , int m ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { ans += abs ( x - i ) + abs ( y - j ) ; } } } return ans ; } int main ( ) { vector < vector < int > > mat = { { 1 , 0 , 0 , 0 } , { 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 1 } } ; int x = 0 , y = 2 ; cout << findAns ( mat , x , y , mat . size ( ) , mat [ 0 ] . size ( ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countReversebitonic ( int arr [ ] , int n ) { int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int temp = arr [ i ] , f = 0 ; if ( j == i ) { c ++ ; continue ; } int k = i + 1 ; while ( temp > arr [ k ] && k <= j ) { temp = arr [ k ] ; k ++ ; } if ( k > j ) { c ++ ; f = 2 ; } while ( temp < arr [ k ] && k <= j && f != 2 ) { temp = arr [ k ] ; k ++ ; } if ( k > j && f != 2 ) { c ++ ; f = 0 ; } } } cout << c << endl ; } int main ( ) { int arr [ ] = { 2 , 3 , 1 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countReversebitonic ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSequence ( int n , int arr [ ] ) { int l = 0 , r = n - 1 ; int prev = INT_MIN ; int ans = 0 ; while ( l <= r ) { if ( arr [ l ] > prev && arr [ r ] > prev ) { if ( arr [ l ] < arr [ r ] ) { ans += 1 ; prev = arr [ l ] ; l += 1 ; } else { ans += 1 ; prev = arr [ r ] ; r -= 1 ; } } else if ( arr [ l ] > prev ) { ans += 1 ; prev = arr [ l ] ; l += 1 ; } else if ( arr [ r ] > prev ) { ans += 1 ; prev = arr [ r ] ; r -= 1 ; } else { break ; } } return ans ; } int main ( ) { int arr [ ] = { 3 , 5 , 1 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestSequence ( n , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int n , int m , int x , int y , int d ) { int top = min ( d , x - 1 ) ; int down = min ( d , n - x ) ; int left = min ( d , y - 1 ) ; int right = min ( d , m - y ) ; int quad1 = top * left ; int quad2 = left * down ; int quad3 = down * right ; int quad4 = right * top ; int totalsq = quad1 + quad2 + quad3 + quad4 ; int singleBlocks = top + down + left + right + 1 ; return totalsq + singleBlocks ; } int main ( ) { int n , m , x , y , d ; n = 10 , m = 10 ; x = 7 , y = 8 ; d = 4 ; d -- ; cout << solve ( n , m , x , y , d ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getSubsequence ( vector < int > & arr , int n ) { vector < int > req ; req . push_back ( arr [ 0 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] && arr [ i ] > arr [ i - 1 ] ) req . push_back ( arr [ i ] ) ; else if ( arr [ i ] < arr [ i + 1 ] && arr [ i ] < arr [ i - 1 ] ) req . push_back ( arr [ i ] ) ; } req . push_back ( arr [ n - 1 ] ) ; cout << req . size ( ) << endl ; for ( auto x : req ) cout << x << " ▁ " ; } int main ( ) { vector < int > arr = { 1 , 2 , 5 , 3 , 6 , 7 , 4 } ; int n = arr . size ( ) ; getSubsequence ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  3 NEW_LINE #define N  3 NEW_LINE int minchanges ( int mat [ N ] [ M ] ) { int count = 0 ; int left = 0 , right = N + M - 2 ; while ( left < right ) { unordered_map < int , int > mp ; int totalsize = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i + j == left ) { mp [ mat [ i ] [ j ] ] ++ ; totalsize ++ ; } else if ( i + j == right ) { mp [ mat [ i ] [ j ] ] ++ ; totalsize ++ ; } } } unordered_map < int , int > :: iterator itr = mp . begin ( ) ; int changes = 0 ; for ( ; itr != mp . end ( ) ; itr ++ ) changes = max ( changes , itr -> second ) ; count += totalsize - changes ; left ++ ; right -- ; } return count ; } int main ( ) { int mat [ ] [ M ] = { { 1 , 4 , 1 } , { 2 , 5 , 3 } , { 1 , 3 , 1 } } ; cout << minchanges ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountLongestSubarrays ( int arr [ ] , int n , int k ) { int i , s = 0 ; for ( i = 0 ; i < n ; ++ i ) { s += arr [ i ] ; } if ( s % k ) { return 1 ; } else { int ini = 0 ; while ( ini < n && arr [ ini ] % k == 0 ) { ++ ini ; } int final = n - 1 ; while ( final >= 0 && arr [ final ] % k == 0 ) { -- final ; } int len , sum = 0 , count = 0 ; if ( ini == n ) { return -1 ; } else { len = max ( n - 1 - ini , final ) ; } for ( i = 0 ; i < len ; i ++ ) { sum += arr [ i ] ; } if ( sum % k != 0 ) { count ++ ; } for ( i = len ; i < n ; i ++ ) { sum = sum + arr [ i ] ; sum = sum - arr [ i - len ] ; if ( sum % k != 0 ) { count ++ ; } } return count ; } } int main ( ) { int arr [ ] = { 3 , 2 , 2 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << CountLongestSubarrays ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAXN = 1e6 + 1 ; int freq [ MAXN ] = { 0 } ; int mul [ MAXN ] = { 0 } ; int cnt [ MAXN ] = { 0 } ; int nC3 ( int n ) { if ( n < 3 ) return 0 ; return ( n * ( n - 1 ) * ( n - 2 ) ) / 6 ; } void count_triplet ( vector < int > arr , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 1 ; i <= 1000000 ; i ++ ) { for ( int j = i ; j <= 1000000 ; j += i ) { mul [ i ] += freq [ j ] ; } cnt [ i ] = nC3 ( mul [ i ] ) ; } for ( int i = 1000000 ; i >= 1 ; i -- ) { for ( int j = 2 * i ; j <= 1000000 ; j += i ) { cnt [ i ] -= cnt [ j ] ; } } cout << " Number ▁ of ▁ triplets ▁ " << " with ▁ GCD ▁ " << K ; cout << " ▁ are ▁ " << cnt [ K ] ; } int main ( ) { vector < int > arr = { 1 , 7 , 12 , 6 , 15 , 9 } ; int N = 6 , K = 3 ; count_triplet ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSubseqPossible ( int arr [ ] , int N , int K ) { int i ; int odd = 0 , even = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 || ( even == 0 && K % 2 == 0 ) ) return false ; return true ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << ( isSubseqPossible ( arr , N , K ) ? " Yes " : " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INF  1e9 NEW_LINE void findMinHike ( vector < int > arr , int n ) { arr . insert ( arr . begin ( ) , INF ) ; arr . push_back ( INF ) ; vector < int > hike ( n + 2 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] && arr [ i ] <= arr [ i + 1 ] ) { hike [ i ] = 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] <= arr [ i + 1 ] ) { hike [ i ] = hike [ i - 1 ] + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { hike [ i ] = hike [ i + 1 ] + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] < arr [ i ] && arr [ i ] > arr [ i + 1 ] ) { hike [ i ] = max ( hike [ i - 1 ] , hike [ i + 1 ] ) + 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { cout << hike [ i ] << " ▁ " ; } } int main ( ) { vector < int > arr = { 5 , 3 , 4 , 2 , 1 , 6 } ; findMinHike ( arr , arr . size ( ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumCost ( int arr [ ] , int cost [ ] , int N ) { vector < vector < int > > dp ( N , vector < int > ( 3 ) ) ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = cost [ 0 ] ; dp [ 0 ] [ 2 ] = cost [ 0 ] * 2 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { int minimum = 1e6 ; if ( j + arr [ i ] != arr [ i - 1 ] ) minimum = min ( minimum , dp [ i - 1 ] [ 0 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 1 ) minimum = min ( minimum , dp [ i - 1 ] [ 1 ] ) ; if ( j + arr [ i ] != arr [ i - 1 ] + 2 ) minimum = min ( minimum , dp [ i - 1 ] [ 2 ] ) ; dp [ i ] [ j ] = j * cost [ i ] + minimum ; } } int ans = 1e6 ; for ( int i = 0 ; i < 3 ; i ++ ) ans = min ( ans , dp [ N - 1 ] [ i ] ) ; cout << ans << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 2 , 3 , 4 } ; int cost [ ] = { 3 , 2 , 5 , 4 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumCost ( arr , cost , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100 ] [ 100 ] [ 100 ] ; int maxProfit ( int profit [ ] , int weight [ ] , int n , int max_W , int max_E ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= max_W ; j ++ ) { for ( int k = 1 ; k <= max_E ; k ++ ) { if ( j >= weight [ i - 1 ] ) { dp [ i ] [ j ] [ k ] = max ( dp [ i - 1 ] [ j ] [ k ] , dp [ i - 1 ] [ j - weight [ i - 1 ] ] [ k - 1 ] + profit [ i - 1 ] ) ; } else { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; } } } } return dp [ n ] [ max_W ] [ max_E ] ; } int main ( ) { memset ( dp , 0 , sizeof ( dp ) ) ; int n = 5 ; int profit [ ] = { 2 , 7 , 1 , 5 , 3 } ; int weight [ ] = { 2 , 5 , 2 , 3 , 4 } ; int max_weight = 8 ; int max_element = 2 ; cout << maxProfit ( profit , weight , n , max_weight , max_element ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAXX = 10000 , INF = 1e9 ; vector < vector < pair < int , int > > > adj ( MAXX * 10 + 3 ) ; vector < int > dist ( MAXX * 10 + 3 , INF ) ; int even ( int x ) { return x * 10 + 2 ; } int odd ( int x ) { return x * 10 + 1 ; } void addEdge ( int a , int b , int cost ) { adj [ even ( a ) ] . push_back ( { odd ( b ) , cost } ) ; adj [ odd ( a ) ] . push_back ( { even ( b ) , cost } ) ; adj [ odd ( b ) ] . push_back ( { even ( a ) , cost } ) ; adj [ even ( b ) ] . push_back ( { odd ( a ) , cost } ) ; } int dijkstra ( int source , int destination ) { priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > pq ; pq . push ( { 0 , even ( source ) } ) ; dist [ even ( source ) ] = 0 ; while ( ! pq . empty ( ) ) { int u = pq . top ( ) . second ; pq . pop ( ) ; for ( pair < int , int > p : adj [ u ] ) { int v = p . first ; int c = p . second ; if ( dist [ u ] + c < dist [ v ] ) { dist [ v ] = dist [ u ] + c ; pq . push ( { dist [ v ] , v } ) ; } } } return dist [ even ( destination ) ] ; } int main ( ) { int n = 5 , m = 6 ; addEdge ( 1 , 2 , 1 ) ; addEdge ( 2 , 3 , 2 ) ; addEdge ( 2 , 5 , 15 ) ; addEdge ( 3 , 5 , 1 ) ; addEdge ( 3 , 4 , 4 ) ; addEdge ( 5 , 4 , 3 ) ; int source = 1 ; int destination = n ; int ans = dijkstra ( source , destination ) ; if ( ans == INF ) cout << " - 1" << " STRNEWLINE " ; else cout << ans << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int make_xor_half ( vector < int > & arr ) { int sum = 0 , xr = 0 ; for ( int a : arr ) { sum += a ; xr ^= a ; } if ( 2 * xr == sum ) return -1 ; if ( xr == 0 ) { arr . push_back ( sum ) ; return 1 ; } arr . push_back ( xr ) ; arr . push_back ( sum + xr ) ; return 2 ; } int main ( ) { int N = 7 ; vector < int > nums = { 3 , 4 , 7 , 1 , 2 , 5 , 6 } ; int count = make_xor_half ( nums ) ; if ( count == -1 ) cout << " - 1" << endl ; else if ( count == 1 ) cout << nums [ N ] << endl ; else cout << nums [ N ] << " ▁ " << nums [ N + 1 ] << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void colorRequired ( int arr [ ] , int n ) { bool all_same = true ; bool one_adjacent_same = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { all_same = false ; } if ( arr [ i ] == arr [ i + 1 ] ) { one_adjacent_same = true ; } } if ( all_same == true ) { cout << 1 << endl ; return ; } if ( n % 2 == 0 one_adjacent_same == true ) { cout << 2 << endl ; return ; } cout << 3 << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; colorRequired ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int maxRemainingSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int i = 0 ; int j = n - 1 ; int result = 0 ; while ( i < j ) { if ( arr [ i ] < arr [ j ] ) { sum -= arr [ i ] ; i ++ ; } else { sum -= arr [ j ] ; j -- ; } result += sum ; } return result ; } int main ( ) { int arr [ ] = { 3 , 1 , 7 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxRemainingSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE string getLargestString ( string s , ll k ) { vector < int > frequency_array ( 26 , 0 ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { frequency_array [ s [ i ] - ' a ' ] ++ ; } string ans = " " ; for ( int i = 25 ; i >= 0 ; ) { if ( frequency_array [ i ] > k ) { int temp = k ; string st ( 1 , i + ' a ' ) ; while ( temp > 0 ) { ans += st ; temp -- ; } frequency_array [ i ] -= k ; int j = i - 1 ; while ( frequency_array [ j ] <= 0 && j >= 0 ) { j -- ; } if ( frequency_array [ j ] > 0 && j >= 0 ) { string str ( 1 , j + ' a ' ) ; ans += str ; frequency_array [ j ] -= 1 ; } else { break ; } } else if ( frequency_array [ i ] > 0 ) { int temp = frequency_array [ i ] ; frequency_array [ i ] -= temp ; string st ( 1 , i + ' a ' ) ; while ( temp > 0 ) { ans += st ; temp -- ; } } else { i -- ; } } return ans ; } int main ( ) { string S = " xxxxzza " ; int k = 3 ; cout << getLargestString ( S , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string s , int len ) { int operationCnt = 0 ; stack < char > st ; int cntClosing = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == ' { ' ) { if ( cntClosing > 0 ) { operationCnt ++ ; st . pop ( ) ; } st . push ( s [ i ] ) ; cntClosing = 0 ; } else if ( st . empty ( ) ) { st . push ( ' { ' ) ; operationCnt ++ ; cntClosing = 1 ; } else { cntClosing = ( cntClosing + 1 ) % 2 ; if ( cntClosing == 0 ) { st . pop ( ) ; } } } operationCnt += st . size ( ) * 2 - cntClosing ; return operationCnt ; } int main ( ) { string str = " } } { " ; int len = str . length ( ) ; cout << minOperations ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubsequence ( string s ) { int n = s . length ( ) ; int answer = 0 ; char prev = ' - ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( prev != s [ i ] ) { prev = s [ i ] ; answer ++ ; } } return answer ; } int main ( ) { string str = " ababa " ; cout << longestSubsequence ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int maximumGcdSubarray ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int k = 1 ; for ( int i = 1 ; i < n ; ++ i ) { k = max ( k , gcd ( arr [ i ] , arr [ i - 1 ] ) ) ; } int cnt = 0 ; int maxLength = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { cnt ++ ; } else { maxLength = max ( maxLength , cnt ) ; cnt = 0 ; } } maxLength = max ( maxLength , cnt ) ; return maxLength ; } int main ( ) { int arr [ ] = { 18 , 3 , 6 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumGcdSubarray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingnumber ( int n , int arr [ ] ) { int mn = INT_MAX , mx = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 && arr [ i ] == -1 && arr [ i - 1 ] != -1 ) { mn = min ( mn , arr [ i - 1 ] ) ; mx = max ( mx , arr [ i - 1 ] ) ; } if ( i < ( n - 1 ) && arr [ i ] == -1 && arr [ i + 1 ] != -1 ) { mn = min ( mn , arr [ i + 1 ] ) ; mx = max ( mx , arr [ i + 1 ] ) ; } } long long int res = ( mx + mn ) / 2 ; return res ; } int main ( ) { int n = 5 ; int arr [ 5 ] = { -1 , 10 , -1 , 12 , -1 } ; int ans = 0 ; int res = missingnumber ( n , arr ) ; cout << res ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int a [ ] , int b [ ] , int n ) { int minA = * min_element ( a , a + n ) ; for ( int x = minA ; x >= 0 ; x -- ) { bool check = 1 ; int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( x % b [ i ] == a [ i ] % b [ i ] ) { operations += ( a [ i ] - x ) / b [ i ] ; } else { check = 0 ; break ; } } if ( check ) return operations ; } return -1 ; } int main ( ) { int N = 5 ; int A [ N ] = { 5 , 7 , 10 , 5 , 15 } ; int B [ N ] = { 2 , 2 , 1 , 3 , 5 } ; cout << minOperations ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countDist ( int arr1 [ ] , int n , int arr2 [ ] , int m , int k ) { int count = 0 ; int smallest = arr2 [ 0 ] ; int largest = arr2 [ 0 ] ; for ( int i = 0 ; i < m ; i ++ ) { smallest = max ( smallest , arr2 [ i ] ) ; largest = min ( largest , arr1 [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( abs ( arr1 [ i ] - smallest ) > k || abs ( arr1 [ i ] - largest ) > k ) count ++ ; } cout << count ; } int main ( ) { int arr1 [ ] = { 3 , 1 , 4 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int arr2 [ ] = { 5 , 1 , 2 } ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int k = 2 ; countDist ( arr1 , n , arr2 , m , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MakeArray ( int a [ ] , int n , int k ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . find ( a [ i ] ) == mp . end ( ) ) mp [ a [ i ] ] = 1 ; } if ( mp . size ( ) > k ) { cout << " Not ▁ possible STRNEWLINE " ; return ; } vector < int > ans ; for ( auto i : mp ) { ans . push_back ( i . first ) ; } while ( ans . size ( ) < k ) { ans . push_back ( 1 ) ; } for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) cout << ans [ j ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 1 } ; int K = 2 ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; MakeArray ( arr , size , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxNormalSubstring ( string & P , set < char > Q , int K , int N ) { if ( K == 0 ) return 0 ; int count = 0 ; int left = 0 , right = 0 ; int ans = 0 ; while ( right < N ) { while ( right < N && count <= K ) { if ( Q . find ( P [ right ] ) != Q . end ( ) ) { if ( count + 1 > K ) break ; else count ++ ; } right ++ ; if ( count <= K ) ans = max ( ans , right - left ) ; } while ( left < right ) { left ++ ; if ( Q . find ( P [ left - 1 ] ) != Q . end ( ) ) count -- ; if ( count < K ) break ; } } return ans ; } int main ( ) { string P = " giraffe " ; set < char > Q ; Q . insert ( ' a ' ) ; Q . insert ( ' f ' ) ; Q . insert ( ' g ' ) ; Q . insert ( ' r ' ) ; int K = 2 ; int N = P . length ( ) ; cout << maxNormalSubstring ( P , Q , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_element ( int N , int K , int * arr ) { map < int , int > mp ; for ( int i = 0 ; i < N ; ++ i ) mp [ arr [ i ] ] ++ ; int answer = 0 ; for ( auto i : mp ) { if ( mp . find ( i . first + K ) != mp . end ( ) ) answer += i . second ; } return answer ; } int main ( ) { int arr [ ] = { 3 , 6 , 2 , 8 , 7 , 6 , 5 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << count_element ( N , K , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digit_prod ( int x ) { int prod = 1 ; while ( x ) { prod *= x % 10 ; x = x / 10 ; } return prod ; } int find_count ( int n ) { map < int , int > mpp ; for ( int i = 1 ; i <= n ; i ++ ) { mpp [ digit_prod ( i ) ] += 1 ; } int ans = 1 ; int maxm = 0 ; for ( auto x : mpp ) { if ( x . second > maxm ) { maxm = x . second ; ans = 1 ; } else if ( x . second == maxm ) { ans ++ ; } } return ans ; } int main ( ) { int N = 13 ; cout << find_count ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { int i ; if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } int findSubarraySum ( int arr [ ] , int n , int K ) { unordered_map < int , int > prevSum ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . find ( currsum - K ) != prevSum . end ( ) ) res += ( prevSum [ currsum - K ] ) ; prevSum [ currsum ] ++ ; } return res ; } void countSubarray ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } cout << findSubarraySum ( arr , n , K ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_maxm ( int arr [ ] , int n ) { map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) { mpp [ arr [ i ] ] += 1 ; } int ans = 0 ; for ( auto x : mpp ) { int value = x . first ; int freq = x . second ; if ( value == freq ) { ans ++ ; } } return ans ; } int main ( ) { int arr [ ] = { 3 , 2 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find_maxm ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pow ( int x , int y ) { if ( y == 1 ) return x ; if ( y == 0 ) return 1 ; int temp = pow ( x , y / 2 ) ; temp *= temp ; if ( y & 1 ) temp *= x ; return temp ; } int noOfPermutations ( int * a , int n ) { if ( n == 1 ) { return 1 ; } sort ( a , a + n ) ; if ( a [ n - 1 ] == a [ n - 2 ] ) { return 0 ; } int x = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( a [ i ] == a [ i + 1 ] ) { if ( a [ i ] == a [ i + 2 ] ) { return 0 ; } x ++ ; i ++ ; } } return pow ( 2 , n - 2 * x - 1 ) ; } int main ( ) { int a [ ] = { 1 , 2 , 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int num = noOfPermutations ( a , n ) ; cout << num ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GetMinSubarrayLength ( int a [ ] , int n ) { int ans = max ( a [ 0 ] , a [ n - 1 ] ) ; int lo = 0 , hi = n - 1 ; while ( lo < n and a [ lo ] % ans == 0 ) lo ++ ; while ( hi > lo and a [ hi ] % ans == 0 ) hi -- ; return ( hi - lo + 1 ) ; } int main ( ) { int arr [ ] = { 4 , 8 , 2 , 1 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int length = GetMinSubarrayLength ( arr , N ) ; cout << length << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int arr [ ] , int N ) { unordered_map < int , int > M ; for ( int i = 0 ; i < N ; i ++ ) { M [ arr [ i ] ] ++ ; } int maxFreq = 0 ; for ( auto & it : M ) { maxFreq = max ( maxFreq , it . second ) ; } cout << N - maxFreq << endl ; } int main ( ) { int arr [ ] = { 1 , 8 , 5 , 9 , 8 , 8 , 7 , 7 , 5 , 7 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; } int maxSum ( int a [ ] , int n ) { int S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; int X = maxSubArraySum ( a , n ) ; return 2 * X - S ; } int main ( ) { int a [ ] = { -1 , -2 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int max_sum = maxSum ( a , n ) ; cout << max_sum ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumValue ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; } int main ( ) { int arr [ ] = { 4 , 21 , 5 , 3 , 8 } , k = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumValue ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { int flag = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { flag = 0 ; break ; } } return ( flag == 1 ? true : false ) ; } bool isPerfectSquare ( int x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } int countInterestingPrimes ( int n ) { int answer = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) { for ( int j = 1 ; j * j * j * j <= i ; j ++ ) { if ( isPerfectSquare ( i - j * j * j * j ) ) { answer ++ ; break ; } } } } return answer ; } int main ( ) { int N = 10 ; cout << countInterestingPrimes ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void noOfMoves ( int arr [ ] , int n ) { int cnt = 0 ; int maxCnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { cnt ++ ; } else { if ( cnt != 0 ) { maxCnt = max ( maxCnt , cnt ) ; cnt = 0 ; } } } cout << maxCnt << endl ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; noOfMoves ( arr , N ) ; int arr1 [ ] = { 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 } ; N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; noOfMoves ( arr1 , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void knowPair ( int a , int b , int n , int s , int m ) { int i = 0 , rem = 0 ; int count_b = 0 , flag = 0 ; while ( i <= a ) { rem = s - ( n * i ) ; count_b = rem / m ; if ( rem % m == 0 && count_b <= b ) { flag = 1 ; } i ++ ; } if ( flag == 1 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } int main ( ) { int A = 1 ; int B = 2 ; int n = 3 ; int S = 4 ; int m = 2 ; knowPair ( A , B , n , S , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSmallNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; } int findLargeNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; } int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; int first = findSmallNum ( A , M ) ; int last = findLargeNum ( B , M ) ; if ( first < A ) first += M ; if ( last > B ) first -= M ; int n = ( B / M ) - ( A - 1 ) / M ; return n * ( first + last ) / 2 ; } int main ( ) { int A = 6 , B = 15 , M = 3 ; cout << sumDivisibles ( A , B , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinctSubstring ( string & P , int N ) { unordered_set < string > S ; for ( int i = 0 ; i < N ; ++ i ) { vector < bool > freq ( 26 , false ) ; string s ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; if ( freq [ pos ] == true ) break ; freq [ pos ] = true ; s += P [ j ] ; S . insert ( s ) ; } } return S . size ( ) ; } int main ( ) { string S = " abba " ; int N = S . length ( ) ; cout << distinctSubstring ( S , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int calcSum ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i <= n - k ; i ++ ) { int sum = 0 ; for ( int j = i ; j < k + i ; j ++ ) sum += arr [ j ] ; cout << sum << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; calcSum ( arr , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int calcSum ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += arr [ i ] ; cout << sum << " ▁ " ; for ( int i = k ; i < n ; i ++ ) { sum = ( sum - arr [ i - k ] ) + arr [ i ] ; cout << sum << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; calcSum ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int a , int b ) { return ( a * b ) / gcd ( a , b ) ; } int countPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( lcm ( arr [ i ] , arr [ j ] ) == gcd ( arr [ i ] , arr [ j ] ) ) ans ++ ; return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxValue ( int arr [ ] , int n , int moves ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { int distance = n - 1 - i ; if ( moves < distance ) break ; int can_take = moves / distance ; int take = min ( arr [ i ] , can_take ) ; arr [ n - 1 ] += take ; moves -= take * distance ; } } return arr [ n - 1 ] ; } int main ( ) { int arr [ ] = { 2 , 3 , 0 , 1 } ; int M = 5 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxValue ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLCS ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; } return mp . size ( ) ; } int main ( ) { int n = 3 ; int arr [ ] = { 3 , 2 , 1 } ; cout << findLCS ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  3 NEW_LINE int maxProductPath ( int arr [ N ] [ M ] ) { vector < vector < int > > maxPath ( N , vector < int > ( M , INT_MIN ) ) ; vector < vector < int > > minPath ( N , vector < int > ( M , INT_MAX ) ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int minVal = INT_MAX ; int maxVal = INT_MIN ; if ( i == 0 && j == 0 ) { maxVal = arr [ i ] [ j ] ; minVal = arr [ i ] [ j ] ; } if ( i > 0 ) { int tempMax = max ( maxPath [ i - 1 ] [ j ] * arr [ i ] [ j ] , minPath [ i - 1 ] [ j ] * arr [ i ] [ j ] ) ; maxVal = max ( maxVal , tempMax ) ; int tempMin = min ( maxPath [ i - 1 ] [ j ] * arr [ i ] [ j ] , minPath [ i - 1 ] [ j ] * arr [ i ] [ j ] ) ; minVal = min ( minVal , tempMin ) ; } if ( j > 0 ) { int tempMax = max ( maxPath [ i ] [ j - 1 ] * arr [ i ] [ j ] , minPath [ i ] [ j - 1 ] * arr [ i ] [ j ] ) ; maxVal = max ( maxVal , tempMax ) ; int tempMin = min ( maxPath [ i ] [ j - 1 ] * arr [ i ] [ j ] , minPath [ i ] [ j - 1 ] * arr [ i ] [ j ] ) ; minVal = min ( minVal , tempMin ) ; } maxPath [ i ] [ j ] = maxVal ; minPath [ i ] [ j ] = minVal ; } } return maxPath [ N - 1 ] [ M - 1 ] ; } int main ( ) { int arr [ N ] [ M ] = { { 1 , -2 , 3 } , { 4 , -5 , 6 } , { -7 , -8 , 9 } } ; cout << maxProductPath ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define z  1000000007 NEW_LINE #define sh  100000 NEW_LINE #define pb  push_back NEW_LINE #define pr ( x )  printf("%d ", x) NEW_LINE struct util { int id ; int at ; int bt ; int ct ; int tat ; int wt ; } ar [ sh + 1 ] ; struct util1 { int p_id ; int bt1 ; } ; util1 range ; util1 tr [ 4 * sh + 5 ] ; int mp [ sh + 1 ] ; bool cmp ( util a , util b ) { if ( a . at == b . at ) return a . id < b . id ; return a . at < b . at ; } void update ( int node , int st , int end , int ind , int id1 , int b_t ) { if ( st == end ) { tr [ node ] . p_id = id1 ; tr [ node ] . bt1 = b_t ; return ; } int mid = ( st + end ) / 2 ; if ( ind <= mid ) update ( 2 * node , st , mid , ind , id1 , b_t ) ; else update ( 2 * node + 1 , mid + 1 , end , ind , id1 , b_t ) ; if ( tr [ 2 * node ] . bt1 < tr [ 2 * node + 1 ] . bt1 ) { tr [ node ] . bt1 = tr [ 2 * node ] . bt1 ; tr [ node ] . p_id = tr [ 2 * node ] . p_id ; } else { tr [ node ] . bt1 = tr [ 2 * node + 1 ] . bt1 ; tr [ node ] . p_id = tr [ 2 * node + 1 ] . p_id ; } } util1 query ( int node , int st , int end , int lt , int rt ) { if ( end < lt st > rt ) return range ; if ( st >= lt && end <= rt ) return tr [ node ] ; int mid = ( st + end ) / 2 ; util1 lm = query ( 2 * node , st , mid , lt , rt ) ; util1 rm = query ( 2 * node + 1 , mid + 1 , end , lt , rt ) ; if ( lm . bt1 < rm . bt1 ) return lm ; return rm ; } void non_preemptive_sjf ( int n ) { int counter = n ; int upper_range = 0 ; int tm = min ( INT_MAX , ar [ upper_range + 1 ] . at ) ; while ( counter ) { for ( ; upper_range <= n ; ) { upper_range ++ ; if ( ar [ upper_range ] . at > tm upper_range > n ) { upper_range -- ; break ; } update ( 1 , 1 , n , upper_range , ar [ upper_range ] . id , ar [ upper_range ] . bt ) ; } util1 res = query ( 1 , 1 , n , 1 , upper_range ) ; if ( res . bt1 != INT_MAX ) { counter -- ; int index = mp [ res . p_id ] ; tm += ( res . bt1 ) ; ar [ index ] . ct = tm ; ar [ index ] . tat = ar [ index ] . ct - ar [ index ] . at ; ar [ index ] . wt = ar [ index ] . tat - ar [ index ] . bt ; update ( 1 , 1 , n , index , INT_MAX , INT_MAX ) ; } else { tm = ar [ upper_range + 1 ] . at ; } } } void execute ( int n ) { sort ( ar + 1 , ar + n + 1 , cmp ) ; for ( int i = 1 ; i <= n ; i ++ ) mp [ ar [ i ] . id ] = i ; non_premptive_sjf ( n ) ; } void print ( int n ) { cout << " ProcessId ▁ " << " Arrival ▁ Time ▁ " << " Burst ▁ Time ▁ " << " Completion ▁ Time ▁ " << " Turn ▁ Around ▁ Time ▁ " << " Waiting ▁ Time STRNEWLINE " ; for ( int i = 1 ; i <= n ; i ++ ) { cout << ar [ i ] . id << " ▁ TABSYMBOL TABSYMBOL ▁ " << ar [ i ] . at << " ▁ TABSYMBOL TABSYMBOL ▁ " << ar [ i ] . bt << " ▁ TABSYMBOL TABSYMBOL ▁ " << ar [ i ] . ct << " ▁ TABSYMBOL TABSYMBOL ▁ " << ar [ i ] . tat << " ▁ TABSYMBOL TABSYMBOL ▁ " << ar [ i ] . wt << " ▁ STRNEWLINE " ; } } int main ( ) { int n = 5 ; range . p_id = INT_MAX ; range . bt1 = INT_MAX ; for ( int i = 1 ; i <= 4 * sh + 1 ; i ++ ) { tr [ i ] . p_id = INT_MAX ; tr [ i ] . bt1 = INT_MAX ; } ar [ 1 ] . at = 1 ; ar [ 1 ] . bt = 7 ; ar [ 1 ] . id = 1 ; ar [ 2 ] . at = 2 ; ar [ 2 ] . bt = 5 ; ar [ 2 ] . id = 2 ; ar [ 3 ] . at = 3 ; ar [ 3 ] . bt = 1 ; ar [ 3 ] . id = 3 ; ar [ 4 ] . at = 4 ; ar [ 4 ] . bt = 2 ; ar [ 4 ] . id = 4 ; ar [ 5 ] . at = 5 ; ar [ 5 ] . bt = 8 ; ar [ 5 ] . id = 5 ; execute ( n ) ; print ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void vertical_Fill ( int records [ ] , int tape [ ] , int m , int n ) { int v [ m ] [ n ] = { 0 } ; int sum = 0 ; int Retrieval_Time = 0 ; double Mrt ; int z = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { sum = 0 ; for ( int k = 0 ; k < i ; k ++ ) { sum += v [ j ] [ k ] ; } if ( sum + records [ z ] <= tape [ j ] ) { v [ j ] [ i ] = records [ z ] ; z ++ ; } } if ( v [ 2 ] [ i ] == 0 ) { break ; } } for ( int i = 0 ; i < m ; i ++ ) { Retrieval_Time = 0 ; cout << " tape ▁ " << i + 1 << " ▁ : ▁ [ ▁ " ; for ( j = 0 ; j < n ; j ++ ) { if ( v [ i ] [ j ] != 0 ) { cout << v [ i ] [ j ] << " ▁ " ; } else { break ; } } cout << " ] " ; for ( int k = 0 ; v [ i ] [ k ] != 0 ; k ++ ) { Retrieval_Time += v [ i ] [ k ] * ( j - k ) ; } Mrt = ( double ) Retrieval_Time / j ; cout << " TABSYMBOL MRT ▁ : ▁ " << Mrt << endl ; } } int main ( ) { int records [ ] = { 15 , 2 , 8 , 23 , 45 , 50 , 60 , 120 } ; int tape [ ] = { 25 , 80 , 160 } ; int n = sizeof ( records ) / sizeof ( records [ 0 ] ) ; int m = sizeof ( tape ) / sizeof ( tape [ 0 ] ) ; sort ( records , records + n ) ; vertical_Fill ( records , tape , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; int maxLength ( string str , int len ) { int res = 0 ; int lastPos [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { lastPos [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int C = str [ i ] - ' a ' ; if ( lastPos [ C ] != -1 ) { res = max ( len - ( i - lastPos [ C ] - 1 ) - 1 , res ) ; } lastPos [ C ] = i ; } return res ; } int main ( ) { string str = " geeksforgeeks " ; int len = str . length ( ) ; cout << maxLength ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPartitions ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int min_elem = * min_element ( A , A + N ) ; if ( min_elem == INT_MAX ) break ; count ++ ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % min_elem == 0 ) A [ i ] = INT_MAX ; } } return count ; } int main ( ) { int arr [ ] = { 7 , 6 , 5 , 4 , 3 , 2 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPartitions ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSwaps ( string & s1 , string & s2 ) { int c0 = 0 , c1 = 0 ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( s1 [ i ] == '0' && s2 [ i ] == '1' ) { c0 ++ ; } else if ( s1 [ i ] == '1' && s2 [ i ] == '0' ) { c1 ++ ; } } int ans = c0 / 2 + c1 / 2 ; if ( c0 % 2 == 0 && c1 % 2 == 0 ) { return ans ; } else if ( ( c0 + c1 ) % 2 == 0 ) { return ans + 2 ; } else { return -1 ; } } int main ( ) { string s1 = "0011" , s2 = "1111" ; int ans = minSwaps ( s1 , s2 ) ; cout << ans << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minChanges ( int arr [ ] , int n ) { unordered_map < int , int > umap ; for ( int i = 0 ; i < n ; i ++ ) { umap [ arr [ i ] ] ++ ; } int maxFreq = 0 ; for ( auto p : umap ) { maxFreq = max ( maxFreq , p . second ) ; } return n - maxFreq ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minChanges ( arr , n ) << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int n , int m ) { int a = 0 , k = 1 ; int p = max ( n , m ) ; while ( n != m ) { float s = ( float ) ( p - n + p - m ) ; float q = ( -1 + sqrt ( 8 * s + 1 ) ) / 2 ; if ( q - floor ( q ) == 0 ) { a = q ; n = m ; } p = p + 1 ; } return a ; } int main ( ) { int n = 1 , m = 3 ; cout << minOperations ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubSeq ( int arr [ ] , int n , int sum ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( sum < arr [ i ] ) arr [ i ] = -1 ; else sum -= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != -1 ) cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 17 , 25 , 46 , 94 , 201 , 400 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int sum = 272 ; findSubSeq ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool hasCrest ( int arr [ ] , int n , int L , int R ) { int present [ n ] = { 0 } ; for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( ( arr [ i ] <= arr [ i + 1 ] ) && ( arr [ i ] <= arr [ i - 1 ] ) ) { present [ i ] = 1 ; } } for ( int i = 1 ; i < n ; i ++ ) { present [ i ] += present [ i - 1 ] ; } if ( present [ L ] == present [ R - 1 ] ) return true ; return false ; } int main ( ) { int arr [ ] = { 2 , 1 , 3 , 5 , 12 , 11 , 7 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 2 ; int R = 6 ; if ( hasCrest ( arr , N , L , R ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool IsLarger ( int X [ ] , int Y [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( X [ i ] < Y [ i ] ) { return false ; } } return true ; } int solve ( int X [ ] , int Y [ ] , int n ) { int ans = 0 ; if ( IsLarger ( X , Y , n ) ) { ans = 0 ; } else { int d = Y [ 0 ] - X [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { X [ i ] += d ; } if ( IsLarger ( X , Y , n ) ) { ans = d ; } else { ans = d + 1 ; } } return ans ; } int main ( ) { int X [ ] = { 2 , 3 , 6 , 9 } ; int Y [ ] = { 3 , 4 , 8 , 1 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << solve ( X , Y , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int max_bitwise_or ( long long int L , long long int R ) { vector < long long int > v1 , v2 , v3 ; long long int z = 0 , i , ans = 0 , cnt = 1 ; while ( L > 0 ) { v1 . push_back ( L % 2 ) ; L = L / 2 ; } while ( R > 0 ) { v2 . push_back ( R % 2 ) ; R = R / 2 ; } while ( v1 . size ( ) != v2 . size ( ) ) { v1 . push_back ( 0 ) ; } for ( i = v2 . size ( ) - 1 ; i >= 0 ; i -- ) { if ( v2 [ i ] == 1 && v1 [ i ] == 0 && z == 0 ) { z = 1 ; continue ; } if ( z == 1 ) { v1 [ i ] = 1 ; } } for ( i = 0 ; i < v2 . size ( ) ; i ++ ) { v3 . push_back ( v2 [ i ] v1 [ i ] ) ; } for ( i = 0 ; i < v2 . size ( ) ; i ++ ) { if ( v3 [ i ] == 1 ) { ans += cnt ; } cnt *= 2 ; } return ans ; } int main ( ) { long long int L = 10 , R = 20 ; cout << max_bitwise_or ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int valueofX ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ar [ i ] ; } if ( sum % n == 0 ) { return sum / n ; } else { int A = sum / n , B = sum / n + 1 ; int ValueA = 0 , ValueB = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ValueA += ( ar [ i ] - A ) * ( ar [ i ] - A ) ; ValueB += ( ar [ i ] - B ) * ( ar [ i ] - B ) ; } if ( ValueA < ValueB ) { return A ; } else { return B ; } } } int main ( ) { int n = 7 ; int arr [ 7 ] = { 6 , 9 , 1 , 6 , 1 , 3 , 7 } ; cout << valueofX ( arr , n ) << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minLength ( int n ) { int ans = n / 26 ; if ( n % 26 != 0 ) ans ++ ; return ans ; } string minString ( int n ) { int ans = n / 26 ; string res = " " ; while ( ans -- ) { res = res + " z " ; } if ( n % 26 != 0 ) { res = res + ( char ) ( ( n % 26 ) + 96 ) ; } return res ; } int main ( ) { int n = 50 ; cout << minLength ( n ) << endl << minString ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE int minHalls ( int lectures [ ] [ 2 ] , int n ) { int prefix_sum [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { prefix_sum [ lectures [ i ] [ 0 ] ] ++ ; prefix_sum [ lectures [ i ] [ 1 ] + 1 ] -- ; } int ans = prefix_sum [ 0 ] ; for ( int i = 1 ; i < MAX ; i ++ ) { prefix_sum [ i ] += prefix_sum [ i - 1 ] ; ans = max ( ans , prefix_sum [ i ] ) ; } return ans ; } int main ( ) { int lectures [ ] [ 2 ] = { { 0 , 5 } , { 1 , 2 } , { 1 , 10 } } ; int n = sizeof ( lectures ) / sizeof ( lectures [ 0 ] ) ; cout << minHalls ( lectures , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  543210 NEW_LINE vector < string > ans ; bool isValidNum ( string x ) { map < int , int > mp ; for ( int i = 0 ; i < x . length ( ) ; i ++ ) { if ( mp . find ( x [ i ] - '0' ) != mp . end ( ) ) { return false ; } else if ( x [ i ] - '0' > 5 ) { return false ; } else { mp [ x [ i ] - '0' ] = 1 ; } } return true ; } void generate ( ) { queue < string > q ; q . push ( "1" ) ; q . push ( "2" ) ; q . push ( "3" ) ; q . push ( "4" ) ; q . push ( "5" ) ; bool flag = true ; ans . push_back ( "0" ) ; while ( ! q . empty ( ) ) { string x = q . front ( ) ; q . pop ( ) ; if ( isValidNum ( x ) ) { ans . push_back ( x ) ; } if ( x . length ( ) == 6 ) continue ; for ( int i = 0 ; i <= 5 ; i ++ ) { string z = to_string ( i ) ; string temp = x + z ; q . push ( temp ) ; } } } bool comp ( string a , string b ) { if ( a . size ( ) == b . size ( ) ) return a < b ; else return a . size ( ) < b . size ( ) ; } int findcount ( string l , string r ) { generate ( ) ; int count = 0 ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { string a = ans [ i ] ; if ( comp ( l , a ) && comp ( a , r ) ) { count ++ ; } else if ( a == l a == r ) { count ++ ; } } return count ; } int main ( ) { string l = "1" , r = "1000" ; cout << findcount ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > Findpermutation ( int n ) { vector < int > a ( n + 1 ) ; a [ 1 ] = n ; for ( int i = 2 ; i <= n ; i ++ ) a [ i ] = i - 1 ; return a ; } int main ( ) { int n = 8 ; vector < int > v = Findpermutation ( n ) ; for ( int i = 1 ; i <= n ; i ++ ) cout << v [ i ] << ' ▁ ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string lexo_small ( int n , int k ) { string arr = " " ; for ( int i = 0 ; i < n ; i ++ ) arr += ' a ' ; for ( int i = n - 1 ; i >= 0 ; i -- ) { k -= i ; if ( k >= 0 ) { if ( k >= 26 ) { arr [ i ] = ' z ' ; k -= 26 ; } else { char c = ( char ) ( k + 97 - 1 ) ; arr [ i ] = c ; k -= arr [ i ] - ' a ' + 1 ; } } else break ; k += i ; } return arr ; } int main ( ) { int n = 5 , k = 42 ; string arr = lexo_small ( n , k ) ; cout << arr ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool IsPossible ( string s ) { int n = s . length ( ) ; set < char > count ; map < char , int > map ; for ( int i = 0 ; i < n ; i ++ ) { count . insert ( s [ i ] ) ; map [ s [ i ] ] += 1 ; } if ( count . size ( ) == 1 ) { return true ; } if ( count . size ( ) > 2 ) { return false ; } auto it = count . begin ( ) ; int x = 0 , y = 0 ; x = map [ * it ] ; it ++ ; y = map [ * it ] ; if ( abs ( x - y ) <= 1 ) { return true ; } return false ; } int main ( ) { string s = " aaaddad " ; if ( IsPossible ( s ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Substring ( string s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = max ( ans , temp ) ; temp = 1 ; } } ans = max ( ans , temp ) ; return ans ; } int main ( ) { string s = " abcdddddeff " ; cout << Substring ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Balanced_Substring ( string str , int n ) { int ans = 0 ; vector < int > arr ( n / 2 + 1 , 0 ) ; int d = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) d ++ ; else { if ( d == 1 ) { for ( int j = 2 ; j <= n / 2 + 1 && arr [ j ] != 0 ; j ++ ) arr [ j ] = 0 ; } ++ ans ; ans += arr [ d ] ; arr [ d ] ++ ; d -- ; } } return ans ; } int main ( ) { string str = " ( ) ( ) ( ) " ; int n = str . size ( ) ; cout << Balanced_Substring ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( long long x , int y , int mod ) { long long res = 1 ; while ( y ) { if ( y & 1 ) res = ( res * x ) % mod ; x = ( x * x ) % mod ; y = ( y >> 1 ) ; } return ( int ) ( res % mod ) ; } int ncr ( int n , int r , int mod ) { long long res = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { res = ( res * ( n - i + 1 ) ) % mod ; int inv = power ( i , mod - 2 , mod ) ; res = ( res * inv ) % mod ; } return ( int ) ( res % mod ) ; } int NoOfChords ( int A ) { int mod = 1e9 + 7 ; long long ans = ncr ( 2 * A , A , mod ) ; int inv = power ( A + 1 , mod - 2 , mod ) ; ans = ( ans * inv ) % mod ; return ( int ) ( ans % mod ) ; } int main ( ) { int N = 2 ; cout << NoOfChords ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int StrictlyPositiveXor ( int A [ ] , int N ) { int allxor = 0 ; bool checkallzero = true ; for ( int i = 0 ; i < N ; i += 1 ) { allxor ^= A [ i ] ; if ( A [ i ] > 0 ) checkallzero = false ; } if ( allxor != 0 ) return N ; if ( checkallzero ) return -1 ; int l = N , r = -1 ; for ( int i = 0 ; i < N ; i += 1 ) { if ( A [ i ] > 0 ) { l = i + 1 ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -= 1 ) { if ( A [ i ] > 0 ) { r = i + 1 ; break ; } } return max ( N - l , r - 1 ) ; } int main ( ) { int A [ ] = { 1 , 0 , 0 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << StrictlyPositiveXor ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_INT  1000000 NEW_LINE int solve ( int Array [ ] , int N ) { vector < int > pos [ 5 ] ; int pref [ 5 ] = { 0 } ; if ( Array [ 0 ] == 0 ) { pref [ 0 ] = 1 ; pos [ 0 ] . push_back ( 0 ) ; } int ans = MAX_INT ; for ( int i = 1 ; i < N ; i ++ ) { if ( Array [ i ] == 0 ) { pref [ 0 ] ++ ; pos [ 0 ] . push_back ( i ) ; } else { if ( pref [ Array [ i ] - 1 ] > 0 ) { pref [ Array [ i ] ] ++ ; pos [ Array [ i ] ] . push_back ( i ) ; if ( Array [ i ] == 4 ) { int end = i ; int start = i ; for ( int j = 3 ; j >= 0 ; j -- ) { int s = 0 ; int e = pos [ j ] . size ( ) - 1 ; int temp = -1 ; while ( s <= e ) { int m = ( s + e ) / 2 ; if ( pos [ j ] [ m ] <= start ) { temp = pos [ j ] [ m ] ; s = m + 1 ; } else { e = m - 1 ; } } start = temp ; } ans = min ( ans , end - start + 1 ) ; } } } } return ans ; } int main ( ) { int Array [ ] = { 0 , 1 , 2 , 3 , 4 , 2 , 0 , 3 , 4 } ; int N = sizeof ( Array ) / sizeof ( Array [ 0 ] ) ; cout << solve ( Array , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWeights ( int X ) { int sum = 0 ; int power = 0 ; while ( sum < X ) { sum = pow ( 3 , power + 1 ) - 1 ; sum /= 2 ; power ++ ; } int ans = 1 ; for ( int i = 1 ; i <= power ; i ++ ) { cout << ans << " ▁ " ; ans = ans * 3 ; } } int main ( ) { int X = 2 ; findWeights ( X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE void find_distinct ( int a [ ] , int n , int q , int queries [ ] ) { int check [ MAX ] = { 0 } ; int idx [ MAX ] ; int cnt = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( check [ a [ i ] ] == 0 ) { idx [ i ] = cnt ; check [ a [ i ] ] = 1 ; cnt ++ ; } else { idx [ i ] = cnt - 1 ; } } for ( int i = 0 ; i < q ; i ++ ) { int m = queries [ i ] ; cout << idx [ m ] << " ▁ " ; } } int main ( ) { int a [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( int ) ; int queries [ ] = { 0 , 3 , 5 , 7 } ; int q = sizeof ( queries ) / sizeof ( int ) ; find_distinct ( a , n , q , queries ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > solve ( int X , vector < int > & A ) { int min = INT_MAX ; int ind = -1 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( A [ i ] < min ) { min = A [ i ] ; ind = i ; } } int maxIndChosen = X / min ; vector < int > ans ; if ( maxIndChosen == 0 ) { return ans ; } for ( int i = 0 ; i < maxIndChosen ; i ++ ) { ans . push_back ( ind ) ; } int temp = maxIndChosen ; int sum = maxIndChosen * A [ ind ] ; for ( int i = 0 ; i < ind ; i ++ ) { if ( sum - X == 0 temp == 0 ) break ; while ( ( sum - A [ ind ] + A [ i ] ) <= X && temp != 0 ) { ans . erase ( ans . begin ( ) ) ; ans . push_back ( i ) ; temp -- ; sum += ( A [ i ] - A [ ind ] ) ; } } sort ( ans . begin ( ) , ans . end ( ) ) ; return ans ; } int main ( ) { vector < int > A = { 5 , 6 , 4 , 8 } ; int X = 18 ; vector < int > ans = solve ( X , A ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool matrix_exist ( int row [ ] , int column [ ] , int r , int c ) { int row_sum = 0 ; int column_sum = 0 ; int row_max = -1 ; int column_max = -1 ; int row_non_zero = 0 ; int column_non_zero = 0 ; for ( int i = 0 ; i < r ; i ++ ) { row_sum += row [ i ] ; row_max = max ( row_max , row [ i ] ) ; if ( row [ i ] ) row_non_zero ++ ; } for ( int i = 0 ; i < c ; i ++ ) { column_sum += column [ i ] ; column_max = max ( column_max , column [ i ] ) ; if ( column [ i ] ) column_non_zero ++ ; } if ( ( row_sum != column_sum ) || ( row_max > column_non_zero ) || ( column_max > row_non_zero ) ) return false ; return true ; } int main ( ) { int row [ ] = { 2 , 2 , 2 , 2 , 2 } ; int column [ ] = { 5 , 5 , 0 , 0 } ; int r = sizeof ( row ) / sizeof ( row [ 0 ] ) ; int c = sizeof ( column ) / sizeof ( column [ 0 ] ) ; if ( matrix_exist ( row , column , r , c ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDistance ( int arr [ ] , int n ) { if ( arr [ 0 ] != arr [ n - 1 ] ) return ( n - 1 ) ; int i = n - 1 ; while ( i > 0 ) { if ( arr [ i ] != arr [ 0 ] ) break ; i -- ; } int distFirst = ( i == 0 ) ? -1 : i ; i = 0 ; while ( i < n - 1 ) { if ( arr [ i ] != arr [ n - 1 ] ) break ; i ++ ; } int distLast = ( i == n - 1 ) ? -1 : ( n - 1 - i ) ; int maxDist = max ( distFirst , distLast ) ; return maxDist ; } int main ( ) { int arr [ ] = { 4 , 4 , 1 , 2 , 1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxDistance ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int n , int k ) { int mini = 0 ; int x1 = 1 ; int a [ k ] ; for ( int i = 1 ; i <= k ; i ++ ) { mini += x1 ; a [ i - 1 ] = x1 ; x1 += 1 ; } if ( n < mini ) { cout << " - 1" ; return ; } int rem = n - mini ; int cnt = rem / k ; rem = rem % k ; for ( int i = 0 ; i < k ; i ++ ) a [ i ] += cnt ; for ( int i = k - 1 ; i > 0 && rem > 0 ; i -- ) { int xx = a [ i - 1 ] * 2 ; int left = xx - a [ i ] ; if ( rem >= left ) { a [ i ] = xx ; rem -= left ; } else { a [ i ] += rem ; rem = 0 ; } } int sum = a [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) { if ( a [ i ] > 2 * a [ i - 1 ] ) { cout << " - 1" ; return ; } sum += a [ i ] ; } if ( sum != n ) { cout << " - 1" ; return ; } for ( int i = 0 ; i < k ; i ++ ) cout << a [ i ] << " ▁ " ; } int main ( ) { int n = 26 , k = 6 ; solve ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int * arr , int n ) { int maxi , result = 0 ; vector < int > freq ( 1000001 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = * ( max_element ( arr , arr + n ) ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; } int main ( ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 25 ; int getMinSum ( int arr [ ] , int n ) { int bits_count [ MAX ] , max_bit = 0 , sum = 0 , ans = 0 ; memset ( bits_count , 0 , sizeof ( bits_count ) ) ; for ( int d = 0 ; d < n ; d ++ ) { int e = arr [ d ] , f = 0 ; while ( e > 0 ) { int rem = e % 2 ; e = e / 2 ; if ( rem == 1 ) { bits_count [ f ] += rem ; } f ++ ; } max_bit = max ( max_bit , f ) ; } for ( int d = 0 ; d < max_bit ; d ++ ) { int temp = pow ( 2 , d ) ; if ( bits_count [ d ] > n / 2 ) ans = ans + temp ; } for ( int d = 0 ; d < n ; d ++ ) { arr [ d ] = arr [ d ] ^ ans ; sum = sum + arr [ d ] ; } return sum ; } int main ( ) { int arr [ ] = { 3 , 5 , 7 , 11 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMinSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumX ( int a [ ] , int n ) { set < int > st ; for ( int i = 0 ; i < n ; i ++ ) st . insert ( a [ i ] ) ; if ( st . size ( ) == 1 ) return 0 ; if ( st . size ( ) == 2 ) { int el1 = * st . begin ( ) ; int el2 = * st . rbegin ( ) ; if ( ( el2 - el1 ) % 2 == 0 ) return ( el2 - el1 ) / 2 ; else return ( el2 - el1 ) ; } if ( st . size ( ) == 3 ) { auto it = st . begin ( ) ; int el1 = * it ; it ++ ; int el2 = * it ; it ++ ; int el3 = * it ; if ( ( el2 - el1 ) == ( el3 - el2 ) ) return el2 - el1 ; else return -1 ; } return -1 ; } int main ( ) { int a [ ] = { 1 , 4 , 4 , 7 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findMinimumX ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findElementsCrossed ( int arr [ ] , int a , int b , int n ) { int aa = a ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a == 0 && b == 0 ) break ; else if ( a == 0 ) { if ( arr [ i ] == 1 ) { b -= 1 ; a = min ( aa , a + 1 ) ; } else b -= 1 ; } else if ( b == 0 ) a -- ; else if ( arr [ i ] == 1 && a < aa ) { b -= 1 ; a = min ( aa , a + 1 ) ; } else a -- ; ans ++ ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int a = 1 ; int b = 2 ; cout << findElementsCrossed ( arr , a , b , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void pushBinaryToBorder ( int arr [ ] , int n ) { int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != 1 ) arr [ count1 ++ ] = arr [ i ] ; while ( count1 < n ) arr [ count1 ++ ] = 1 ; int lastNonOne = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] == 1 ) continue ; if ( ! lastNonOne ) { lastNonOne = i ; } if ( arr [ i ] != 0 ) arr [ lastNonOne -- ] = arr [ i ] ; } while ( lastNonOne >= 0 ) arr [ lastNonOne -- ] = 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 0 , 0 , 0 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pushBinaryToBorder ( arr , n ) ; printArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int solve ( int * health , int n ) { int currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ; for ( int i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; } int main ( ) { int health [ ] = { 4 , 6 , 8 , 12 } ; int n = sizeof ( health ) / sizeof ( health [ 0 ] ) ; cout << solve ( health , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Find_Sequence ( int arr [ ] , int n ) { vector < int > inc_arr , dec_arr ; int flag = 0 ; long inc = -1 , dec = 1e7 ; for ( int i = 0 ; i < n ; i ++ ) { if ( inc < arr [ i ] && arr [ i ] < dec ) { if ( arr [ i ] < arr [ i + 1 ] ) { inc = arr [ i ] ; inc_arr . emplace_back ( arr [ i ] ) ; } else { dec = arr [ i ] ; dec_arr . emplace_back ( arr [ i ] ) ; } } else if ( inc < arr [ i ] ) { inc = arr [ i ] ; inc_arr . emplace_back ( arr [ i ] ) ; } else if ( dec > arr [ i ] ) { dec = arr [ i ] ; dec_arr . emplace_back ( arr [ i ] ) ; } else { cout << -1 << endl ; flag = 1 ; break ; } } if ( ! flag ) { for ( auto i = inc_arr . begin ( ) ; i != inc_arr . end ( ) ; i ++ ) cout << * i << " ▁ " ; cout << endl ; for ( auto i = dec_arr . begin ( ) ; i != dec_arr . end ( ) ; i ++ ) cout << * i << " ▁ " ; cout << endl ; } } int main ( ) { int arr [ ] = { 5 , 1 , 3 , 6 , 8 , 2 , 9 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Find_Sequence ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverse ( int n ) { int rev = 0 ; while ( n != 0 ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; } void getSum ( int n ) { n = reverse ( n ) ; int sumOdd = 0 , sumEven = 0 , c = 1 ; while ( n != 0 ) { if ( c % 2 == 0 ) sumEven += n % 10 ; else sumOdd += n % 10 ; n /= 10 ; c ++ ; } cout << " Sum ▁ odd ▁ = ▁ " << sumOdd << " STRNEWLINE " ; cout << " Sum ▁ even ▁ = ▁ " << sumEven ; } int main ( ) { int n = 457892 ; getSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getSum ( int n ) { bool isOdd = ( n % 2 == 1 ) ? true : false ; int sumOdd = 0 , sumEven = 0 ; while ( n != 0 ) { if ( isOdd ) sumOdd += n % 10 ; else sumEven += n % 10 ; isOdd = ! isOdd ; n /= 10 ; } cout << " Sum ▁ odd ▁ = ▁ " << sumOdd << " STRNEWLINE " ; cout << " Sum ▁ even ▁ = ▁ " << sumEven ; } int main ( ) { int n = 457892 ; getSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return -1 ; } int main ( ) { int A = 1 , B = 2 , S = 7 , N = 5 ; cout << bankNotes ( A , B , S , N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void twoParts ( string str ) { int flag = 0 ; string a = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '4' ) { str [ i ] = '3' ; a += '1' ; flag = 1 ; } else if ( flag ) a += '0' ; } cout << str << " ▁ " << a ; } int main ( ) { string str = "9441" ; twoParts ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubstring ( string s ) { int cnt = 1 ; int maxi = 1 ; int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; else { maxi = max ( cnt , maxi ) ; cnt = 1 ; } } maxi = max ( cnt , maxi ) ; return maxi ; } int main ( ) { string s = " ccccdeededff " ; cout << longestSubstring ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Minimum_Operations ( int a [ ] , int n ) { int np [ n + 1 ] ; np [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } int pos = 0 ; int ans = n ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = min ( ans , pos + np [ i + 1 ] ) ; } return ans ; } int main ( ) { int a [ ] = { -1 , 0 , 1 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Minimum_Operations ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findSumofEle ( int arr1 [ ] , int m , int arr2 [ ] , int n , int k ) { float arraySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ; int sumOfElements = 0 ; float difference ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( -1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 , 4 , 7 , 9 } ; int arr2 [ ] = { 0 , 1 , 2 , 1 , 1 , 4 } ; int k = 2 ; int m , n ; m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << findSumofEle ( arr1 , m , arr2 , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findIntegers ( int n , int x , int y ) { vector < int > ans ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans . push_back ( 1 ) ; if ( y - ( n - 1 ) <= 0 ) { cout << " - 1" ; return ; } ans . push_back ( y - ( n - 1 ) ) ; int store = 0 ; for ( int i = 0 ; i < n ; i ++ ) store += ans [ i ] * ans [ i ] ; if ( store < x ) { cout << " - 1" ; return ; } for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { int n = 3 , x = 254 , y = 18 ; findIntegers ( n , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; } int main ( ) { int n = 4 , m = 6 ; cout << Minsteps ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getsum ( int x ) { return ( x * ( x + 1 ) ) / 2 ; } int countJumps ( int n ) { n = abs ( n ) ; int ans = 0 ; while ( getsum ( ans ) < n or ( getsum ( ans ) - n ) & 1 ) ans ++ ; return ans ; } int main ( ) { int n = 9 ; cout << countJumps ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCandies ( int arr [ ] , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxCandies ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string s ) { for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s [ i ] != s [ s . length ( ) - i - 1 ] ) { return false ; } } return true ; } bool ans ( string s ) { string s2 = s ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { s2 = s2 . back ( ) + s2 ; s2 . pop_back ( ) ; if ( s != s2 && isPalindrome ( s2 ) ) { return true ; } } return false ; } int solve ( string s ) { if ( s . length ( ) <= 3 ) { return -1 ; } int cnt [ 25 ] = { } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ s [ i ] - ' a ' ] ++ ; } if ( * max_element ( cnt , cnt + 25 ) >= ( s . length ( ) - 1 ) ) { return -1 ; } else { return ( ans ( s ) ? 1 : 2 ) ; } } int main ( ) { string s = " nolon " ; cout << solve ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solveEven ( string s ) { if ( s . length ( ) % 2 == 1 ) return 2 ; string ls = s . substr ( 0 , s . length ( ) / 2 ) ; string rs = s . substr ( s . length ( ) / 2 , s . length ( ) ) ; if ( ls != rs ) return 1 ; return solveEven ( ls ) ; } int solveOdd ( string s ) { return 2 ; } int solve ( string s ) { if ( s . length ( ) <= 3 ) { return -1 ; } int cnt [ 25 ] = { } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { cnt [ s [ i ] - ' a ' ] ++ ; } if ( * max_element ( cnt , cnt + 25 ) >= s . length ( ) - 1 ) { return -1 ; } if ( s . length ( ) % 2 == 0 ) return solveEven ( s ) ; if ( s . length ( ) % 2 == 1 ) return solveOdd ( s ) ; } int main ( ) { string s = " nolon " ; cout << solve ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minChanges ( string str , int n ) { int count = 0 , zeros = 0 , ones = 0 ; if ( str [ 0 ] != '1' ) { count ++ ; ones ++ ; } for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeros ++ ; else ones ++ ; if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; } int main ( ) { string str = "0000" ; int n = str . length ( ) ; cout << minChanges ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minGCD ( int arr [ ] , int n ) { int minGCD = 0 ; for ( int i = 0 ; i < n ; i ++ ) minGCD = __gcd ( minGCD , arr [ i ] ) ; return minGCD ; } int minLCM ( int arr [ ] , int n ) { int minLCM = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minLCM = min ( minLCM , arr [ i ] ) ; return minLCM ; } int main ( ) { int arr [ ] = { 2 , 66 , 14 , 521 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " LCM ▁ = ▁ " << minLCM ( arr , n ) << " , ▁ GCD ▁ = ▁ " << minGCD ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define int  long long NEW_LINE using namespace std ; int steps ( int cur , int x , int n ) { if ( x == 0 ) return INT_MAX ; if ( x > 0 ) return abs ( ( n - cur ) / x ) ; else return abs ( ( cur - 1 ) / x ) ; } int countSteps ( int curx , int cury , int n , int m , vector < pair < int , int > > moves ) { int count = 0 ; int k = moves . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int x = moves [ i ] . first ; int y = moves [ i ] . second ; int stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return count ; } main ( ) { int n = 4 , m = 5 , x = 1 , y = 1 ; vector < pair < int , int > > moves = { { 1 , 1 } , { 1 , 1 } , { 0 , -2 } } ; int k = moves . size ( ) ; cout << countSteps ( x , y , n , m , moves ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumRemoval ( int n , int a [ ] ) { map < int , int > c ; for ( int i = 0 ; i < n ; i ++ ) c [ a [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool ok = false ; for ( int j = 0 ; j < 31 ; j ++ ) { int x = ( 1 << j ) - a [ i ] ; if ( c . count ( x ) && ( c [ x ] > 1 || ( c [ x ] == 1 && x != a [ i ] ) ) ) { ok = true ; break ; } } if ( ! ok ) ans ++ ; } return ans ; } int main ( ) { int a [ ] = { 4 , 7 , 1 , 5 , 4 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minimumRemoval ( n , a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string getCount ( int N ) { if ( N % 2 == 1 ) return 0 ; string result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; } int main ( ) { int N = 4 ; cout << getCount ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canFormTeam ( int n , int m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; } int maxTeams ( int n , int m ) { int count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; } int main ( ) { int n = 4 , m = 5 ; cout << maxTeams ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string formStringMinOperations ( string s ) { int count [ 3 ] = { 0 } ; for ( auto & c : s ) count ++ ; int processed [ 3 ] = { 0 } ; int reqd = ( int ) s . size ( ) / 3 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( count [ s [ i ] - '0' ] == reqd ) continue ; if ( s [ i ] == '0' && count [ 0 ] > reqd && processed [ 0 ] >= reqd ) { if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 0 ] -- ; } else if ( count [ 2 ] < reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 0 ] -- ; } } if ( s [ i ] == '1' && count [ 1 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 1 ] -- ; } else if ( count [ 2 ] < reqd && processed [ 1 ] >= reqd ) { s [ i ] = '2' ; count [ 2 ] ++ ; count [ 1 ] -- ; } } if ( s [ i ] == '2' && count [ 2 ] > reqd ) { if ( count [ 0 ] < reqd ) { s [ i ] = '0' ; count [ 0 ] ++ ; count [ 2 ] -- ; } else if ( count [ 1 ] < reqd ) { s [ i ] = '1' ; count [ 1 ] ++ ; count [ 2 ] -- ; } } processed [ s [ i ] - '0' ] ++ ; } return s ; } int main ( ) { string s = "011200" ; cout << formStringMinOperations ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_rectangle ( int area ) { int l , b ; int M = sqrt ( area ) , ans ; for ( int i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } cout << " l ▁ = ▁ " << l << " , ▁ b ▁ = ▁ " << b << endl ; } int main ( ) { int area = 99 ; find_rectangle ( area ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_rectangle ( int area ) { for ( int i = ceil ( sqrt ( area ) ) ; i <= area ; i ++ ) { if ( area / i * i == area ) { printf ( " % d ▁ % d " , i , area / i ) ; return ; } } } int main ( ) { int area = 99 ; find_rectangle ( area ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sizeSubSet ( int a [ ] , int k , int n ) { sort ( a , a + n ) ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . count ( a [ i ] / k ) == 0 ) s . insert ( a [ i ] ) ; } return s . size ( ) ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 2 ; cout << sizeSubSet ( a , k , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSets ( string s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . length ( ) ; int f = 0 ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - '0' ) ; if ( num <= y ) f = 1 ; { if ( f ) cnt += 1 ; num = s [ i ] - '0' ; f = 0 ; if ( num <= y ) f = 1 ; else num = 0 ; } } if ( f ) cnt += 1 ; return cnt ; } int main ( ) { string s = "1234" ; int y = 30 ; cout << minimumSets ( s , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int b [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << b [ i ] << " ▁ " ; } void ModifiedArray ( int a [ ] , int n ) { int l = 0 , r = INT_MAX ; int b [ n ] = { 0 } ; for ( int i = 0 ; i < n / 2 ; i ++ ) { b [ i ] = max ( l , a [ i ] - r ) ; b [ n - i - 1 ] = a [ i ] - b [ i ] ; l = b [ i ] ; r = b [ n - i - 1 ] ; } printArr ( b , n ) ; } int main ( ) { int a [ ] = { 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; ModifiedArray ( a , 2 * n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < int , int > numberOfLines ( string S , int * widths ) { if ( S . empty ( ) ) return { 0 , 0 } ; int lines = 1 , width = 0 ; for ( auto character : S ) { int w = widths [ character - ' a ' ] ; width += w ; if ( width >= 10 ) { lines ++ ; width = w ; } } return { lines , width } ; } int main ( ) { string S = " bbbcccdddaa " ; int widths [ ] = { 4 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; pair < int , int > ans = numberOfLines ( S , widths ) ; cout << ans . first << " ▁ " << ans . second << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string canReorder ( int A [ ] , int n ) { map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ A [ i ] ] ++ ; sort ( A , A + n ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( m [ A [ i ] ] == 0 ) continue ; if ( m [ 2 * A [ i ] ] ) { count += 2 ; m [ A [ i ] ] -= 1 ; m [ 2 * A [ i ] ] -= 1 ; } } if ( count == n ) return " true " ; else return " false " ; } int main ( ) { int A [ ] = { 4 , -2 , 2 , -4 } ; int n = sizeof ( A ) / sizeof ( int ) ; cout << ( canReorder ( A , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimizeDiff ( int * arr , int n , int k ) { int max = * ( max_element ( arr , arr + n ) ) ; int min = * ( min_element ( arr , arr + n ) ) ; if ( ( max - min ) <= k ) { return ( max - min ) ; } int avg = ( max + min ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > avg ) arr [ i ] -= k ; else arr [ i ] += k ; } max = * ( max_element ( arr , arr + n ) ) ; min = * ( min_element ( arr , arr + n ) ) ; return ( max - min ) ; } int main ( ) { int arr [ ] = { 3 , 16 , 12 , 9 , 20 } ; int n = 5 ; int k = 3 ; cout << " Max ▁ height ▁ difference ▁ = ▁ " << minimizeDiff ( arr , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; cout << ans << endl ; } else cout << ( budget / plastic ) << endl ; } int main ( ) { int budget = 10 , plastic = 11 , glass = 9 , refund = 8 ; maxLitres ( budget , plastic , glass , refund ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int leastValue ( int P , int A , int N , int a [ ] ) { int ans = -1 ; float tmp = ( float ) INFINITY ; for ( int i = 0 ; i < N ; i ++ ) { float t = P - a [ i ] * 0.006 ; if ( abs ( t - A ) < tmp ) { tmp = abs ( t - A ) ; ans = i ; } } return a [ ans ] ; } int main ( ) { int N = 2 , P = 12 , A = 2005 ; int a [ ] = { 1000 , 2000 } ; cout << leastValue ( P , A , N , a ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPermutation ( int n ) { int len = ceil ( log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) ; continue ; } } return -1 ; } int main ( ) { int n = 132 ; cout << findPermutation ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSellingPossible ( int n , int a [ ] ) { int i , c25 = 0 , c50 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 25 ) c25 ++ ; else if ( a [ i ] == 50 ) { c50 ++ ; if ( c25 == 0 ) break ; c25 -- ; } else { if ( c50 > 0 && c25 > 0 ) { c50 -- ; c25 -- ; } else if ( c25 >= 3 ) c25 -= 3 ; else break ; } } if ( i == n ) return true ; else return false ; } int main ( ) { int a [ ] = { 25 , 25 , 50 , 100 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isSellingPossible ( n , a ) ) { cout << " YES " ; } else { cout << " NO " ; } }
#include <iostream> NEW_LINE using namespace std ; void printCoins ( int arr [ ] , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr1 [ ] = { 8 , 15 , 3 , 7 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; printCoins ( arr1 , n ) ; cout << endl ; int arr2 [ ] = { 2 , 2 , 2 , 2 } ; n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printCoins ( arr2 , n ) ; cout << endl ; int arr3 [ ] = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; printCoins ( arr3 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void finalPos ( char command [ ] , int n , int x , int y ) { int cup , cdown , cleft , cright ; int final_x , final_y ; cup = cdown = cleft = cright = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( command [ i ] == ' U ' ) cup ++ ; else if ( command [ i ] == ' D ' ) cdown ++ ; else if ( command [ i ] == ' L ' ) cleft ++ ; else if ( command [ i ] == ' R ' ) cright ++ ; } final_x = x + ( cright - cleft ) ; final_y = y + ( cdown - cup ) ; cout << " Final ▁ Position : ▁ " << " ( " << final_x << " , ▁ " << final_y << " ) " ; } int main ( ) { char command [ ] = " DDLRULL " ; int n = ( sizeof ( command ) / sizeof ( char ) ) - 1 ; int x = 3 , y = 4 ; finalPos ( command , n , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLandB ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; vector < double > arr_pairs ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { arr_pairs . push_back ( arr [ i ] ) ; i ++ ; } } double length = arr_pairs [ 0 ] ; double breadth = arr_pairs [ 1 ] ; double size = arr_pairs . size ( ) ; for ( int i = 2 ; i < size ; i ++ ) { if ( ( length / breadth + breadth / length ) > ( arr_pairs [ i ] / arr_pairs [ i - 1 ] + arr_pairs [ i - 1 ] / arr_pairs [ i ] ) ) { length = arr_pairs [ i ] ; breadth = arr_pairs [ i - 1 ] ; } } cout << length << " , ▁ " << breadth << endl ; } int main ( ) { int arr [ ] = { 4 , 2 , 2 , 2 , 5 , 6 , 5 , 6 , 7 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findLandB ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestSumSubarr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = max ( max_sum , sum_here ) ; } return ( -1 ) * max_sum ; } int main ( ) { int arr [ ] = { 3 , -4 , 2 , -3 , -1 , 7 , -5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Smallest ▁ sum : ▁ " << smallestSumSubarr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef struct _pair { int first , second ; } _pair ; void printKPairs ( int a1 [ ] , int a2 [ ] , int size1 , int size2 , int k ) { if ( k > ( size2 * size1 ) ) { cout << " k ▁ pairs ▁ don ' t ▁ exist STRNEWLINE " ; return ; } _pair _one , _two ; _one . first = _one . second = _two . first = _two . second = 0 ; int cnt = 0 ; while ( cnt < k ) { if ( _one . first == _two . second && _two . first == _one . second ) { if ( a1 [ _one . first ] < a2 [ _one . second ] ) { cout << " [ " << a1 [ _one . first ] << " , ▁ " << a2 [ _one . second ] << " ] ▁ " ; _one . second = ( _one . second + 1 ) % size2 ; _one . first = ( _one . first + 1 ) % size1 ; _two . second = ( _two . second + 1 ) % size2 ; if ( _two . second == 0 ) _two . first = ( _two . first + 1 ) % size2 ; } else { cout << " [ " << a2 [ _one . second ] << " , ▁ " << a1 [ _one . first ] << " ] ▁ " ; _one . first = ( _one . first + 1 ) % size1 ; _one . second = ( _one . second + 1 ) % size2 ; _two . first = ( _two . first + 1 ) % size2 ; _two . second = ( _two . second + 1 ) % size1 ; } } else if ( a1 [ _one . first ] + a2 [ _one . second ] <= a2 [ _two . first ] + a1 [ _two . second ] ) { if ( a1 [ _one . first ] < a2 [ _one . second ] ) { cout << " [ " << a1 [ _one . first ] << " , ▁ " << a2 [ _one . second ] << " ] ▁ " ; _one . second = ( ( _one . second + 1 ) % size2 ) ; _one . first = ( _one . first + 1 ) % size1 ; } else { cout << " [ " << a2 [ _one . second ] << " , ▁ " << a1 [ _one . first ] << " ] ▁ " ; _one . first = ( ( _one . first + 1 ) % size1 ) ; _one . second = ( _one . second + 1 ) % size2 ; } } else if ( a1 [ _one . first ] + a2 [ _one . second ] > a2 [ _two . first ] + a1 [ _two . second ] ) { if ( a2 [ _two . first ] < a1 [ _two . second ] ) { cout << " [ " << a2 [ _two . first ] << " , ▁ " << a1 [ _two . second ] << " ] ▁ " ; _two . first = ( ( _two . first + 1 ) % size2 ) ; _two . second = ( _two . second + 1 ) % size1 ; } else { cout << " [ " << a1 [ _two . second ] << " , ▁ " << a2 [ _two . first ] << " ] ▁ " ; _two . second = ( ( _two . second + 1 ) % size1 ) ; _two . first = ( _two . first + 1 ) % size1 ; } } cnt ++ ; } } int main ( ) { int a1 [ ] = { 2 , 3 , 4 } ; int a2 [ ] = { 1 , 6 , 5 , 8 } ; int size1 = sizeof ( a1 ) / sizeof ( a1 [ 0 ] ) ; int size2 = sizeof ( a2 ) / sizeof ( a2 [ 0 ] ) ; int k = 4 ; printKPairs ( a1 , a2 , size1 , size2 , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLargest ( int a [ ] , int n ) { int max = -1 ; int ind = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( int i = ind ; i < n ; i ++ ) cout << a [ i ] ; for ( int i = 0 ; i < ind ; i ++ ) cout << a [ i ] ; } int main ( ) { int a [ ] = { 54 , 546 , 548 , 60 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printLargest ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findOrderMRT ( int L [ ] , int n ) { sort ( L , L + n ) ; cout << " Optimal ▁ order ▁ in ▁ which ▁ programs ▁ are ▁ to ▁ be " " stored ▁ is : ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << L [ i ] << " ▁ " ; cout << endl ; double MRT = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j <= i ; j ++ ) sum += L [ j ] ; MRT += sum ; } MRT /= n ; cout << " Minimum ▁ Retrieval ▁ Time ▁ of ▁ this " " ▁ order ▁ is ▁ " << MRT ; } int main ( ) { int L [ ] = { 2 , 5 , 4 } ; int n = sizeof ( L ) / sizeof ( L [ 0 ] ) ; findOrderMRT ( L , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = INT_MIN ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) return 0 ; if ( count_neg & 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0 ; prod = prod / max_neg ; } return prod ; } int main ( ) { int a [ ] = { -1 , -1 , -2 , 4 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxProductSubset ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( vector < int > arr , int pos , int m , vector < bool > isRunning ) { vector < int > d ( m + 1 , 0 ) ; for ( int i = m ; i > pos ; i -- ) { if ( isRunning [ arr [ i ] ] ) d [ arr [ i ] ] = i ; } int maxipos = 0 ; for ( int ele : d ) maxipos = max ( ele , maxipos ) ; return maxipos ; } int mincost ( int n , int m , vector < int > arr ) { vector < vector < int > > freqarr ( m ) ; vector < int > newvec ( m + 1 , 0 ) ; freqarr [ m - 1 ] = newvec ; for ( int i = m - 2 ; i >= 0 ; i -- ) { vector < int > nv ; nv = freqarr [ i + 1 ] ; nv [ arr [ i + 1 ] ] += 1 ; freqarr [ i ] = nv ; } vector < bool > isRunning ( m + 1 , false ) ; int cost = 0 ; int truecount = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int ele = arr [ i ] ; if ( isRunning [ ele ] == true ) continue ; else { if ( truecount < n ) { cost += 1 ; truecount += 1 ; isRunning [ ele ] = true ; } else { int mini = 100000 ; int miniind = 0 ; for ( int j = 1 ; j <= m ; j ++ ) { if ( isRunning [ j ] && mini > freqarr [ i ] [ j ] ) { mini = freqarr [ i ] [ j ] ; miniind = j ; } } if ( mini == 0 ) { isRunning [ miniind ] = false ; isRunning [ ele ] = true ; cost += 1 ; } else { int farpos = find ( arr , i , m , isRunning ) ; isRunning [ arr [ farpos ] ] = false ; isRunning [ ele ] = true ; cost += 1 ; } } } } return cost ; } int main ( ) { int n1 = 3 ; int m1 = 6 ; vector < int > arr1 { 1 , 2 , 1 , 3 , 4 , 1 } ; cout << mincost ( n1 , m1 , arr1 ) << endl ; int n2 = 2 ; int m2 = 6 ; vector < int > arr2 { 1 , 2 , 1 , 3 , 2 , 1 } ; cout << mincost ( n2 , m2 , arr2 ) << endl ; int n3 = 3 ; int m3 = 31 ; vector < int > arr3 { 7 , 11 , 17 , 10 , 7 , 10 , 2 , 9 , 2 , 18 , 8 , 10 , 20 , 10 , 3 , 20 , 17 , 17 , 17 , 1 , 15 , 10 , 8 , 3 , 3 , 18 , 13 , 2 , 10 , 10 , 11 } ; cout << mincost ( n3 , m3 , arr3 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool possibility ( unordered_map < int , int > m , int length , string s ) { int countodd = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( m [ s [ i ] - '0' ] & 1 ) countodd ++ ; if ( countodd > 1 ) return false ; } return true ; } void largestPalindrome ( string s ) { int l = s . length ( ) ; unordered_map < int , int > m ; for ( int i = 0 ; i < l ; i ++ ) m [ s [ i ] - '0' ] ++ ; if ( possibility ( m , l , s ) == false ) { cout << " Palindrome ▁ cannot ▁ be ▁ formed " ; return ; } char largest [ l ] ; int front = 0 ; for ( int i = 9 ; i >= 0 ; i -- ) { if ( m [ i ] & 1 ) { largest [ l / 2 ] = char ( i + 48 ) ; m [ i ] -- ; while ( m [ i ] > 0 ) { largest [ front ] = char ( i + 48 ) ; largest [ l - front - 1 ] = char ( i + 48 ) ; m [ i ] -= 2 ; front ++ ; } } else { while ( m [ i ] > 0 ) { largest [ front ] = char ( i + 48 ) ; largest [ l - front - 1 ] = char ( i + 48 ) ; m [ i ] -= 2 ; front ++ ; } } } for ( int i = 0 ; i < l ; i ++ ) cout << largest [ i ] ; } int main ( ) { string s = "313551" ; largestPalindrome ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void calcFiboTerms ( vector < int > & fiboTerms , int K ) { int i = 3 , nextTerm ; fiboTerms . push_back ( 0 ) ; fiboTerms . push_back ( 1 ) ; fiboTerms . push_back ( 1 ) ; while ( 1 ) { nextTerm = fiboTerms [ i - 1 ] + fiboTerms [ i - 2 ] ; if ( nextTerm > K ) return ; fiboTerms . push_back ( nextTerm ) ; i ++ ; } } int findMinTerms ( int K ) { vector < int > fiboTerms ; calcFiboTerms ( fiboTerms , K ) ; int count = 0 , j = fiboTerms . size ( ) - 1 ; while ( K > 0 ) { count += ( K / fiboTerms [ j ] ) ; K %= ( fiboTerms [ j ] ) ; j -- ; } return count ; } int main ( ) { int K = 17 ; cout << findMinTerms ( K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void digitsNum ( int N ) { if ( N == 0 ) cout << "0 STRNEWLINE " ; if ( N % 9 != 0 ) cout << ( N % 9 ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) cout << "9" ; for ( int i = 1 ; i <= N ; ++ i ) cout << "0" ; cout << " STRNEWLINE " ; } int main ( ) { int N = 5 ; cout << " The ▁ number ▁ is ▁ : ▁ " ; digitsNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; sort ( arr , arr + N , greater < int > ( ) ) ; M = max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; } int main ( ) { int arr [ ] = { 8 , 4 , 5 , 2 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << maxDifference ( arr , N , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; } int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 4 } ; int b [ ] = { 3 , 4 , 2 , 3 , 2 } ; int n = 5 , k = 3 ; cout << minproduct ( a , b , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { if ( n < 4 ) return -1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return -1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return -1 ; return ( n - 15 ) / 4 + 2 ; } } int main ( ) { int n = 90 ; cout << count ( n ) << endl ; n = 143 ; cout << count ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE #include <cmath> NEW_LINE using namespace std ; int policeThief ( char arr [ ] , int n , int k ) { int res = 0 ; vector < int > thi ; vector < int > pol ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == ' P ' ) pol . push_back ( i ) ; else if ( arr [ i ] == ' T ' ) thi . push_back ( i ) ; } int l = 0 , r = 0 ; while ( l < thi . size ( ) && r < pol . size ( ) ) { if ( abs ( thi [ l ] - pol [ r ] ) <= k ) { res ++ ; l ++ ; r ++ ; } else if ( thi [ l ] < pol [ r ] ) l ++ ; else r ++ ; } return res ; } int main ( ) { int k , n ; char arr1 [ ] = { ' P ' , ' T ' , ' T ' , ' P ' , ' T ' } ; k = 2 ; n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << " Maximum ▁ thieves ▁ caught : ▁ " << policeThief ( arr1 , n , k ) << endl ; char arr2 [ ] = { ' T ' , ' T ' , ' P ' , ' P ' , ' T ' , ' P ' } ; k = 2 ; n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << " Maximum ▁ thieves ▁ caught : ▁ " << policeThief ( arr2 , n , k ) << endl ; char arr3 [ ] = { ' P ' , ' T ' , ' P ' , ' T ' , ' T ' , ' P ' } ; k = 3 ; n = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << " Maximum ▁ thieves ▁ caught : ▁ " << policeThief ( arr3 , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input unlock_code ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; } int main ( ) { int input = 28756 ; int unlock_code = 98234 ; cout << " Minimum ▁ Rotation ▁ = ▁ " << minRotation ( input , unlock_code ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void preprocess ( int coin [ ] , int n ) { sort ( coin , coin + n ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) coin [ i ] += coin [ i - 1 ] ; } int minCost ( int coin [ ] , int n , int k ) { int coins_needed = ceil ( 1.0 * n / ( k + 1 ) ) ; return coin [ coins_needed - 1 ] ; } int main ( ) { int coin [ ] = { 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 } ; int n = sizeof ( coin ) / sizeof ( coin [ 0 ] ) ; preprocess ( coin , n ) ; int k = 3 ; cout << minCost ( coin , n , k ) << endl ; k = 7 ; cout << minCost ( coin , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void worstFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ n ] ; memset ( allocation , -1 , sizeof ( allocation ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int wstIdx = -1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( wstIdx == -1 ) wstIdx = j ; else if ( blockSize [ wstIdx ] < blockSize [ j ] ) wstIdx = j ; } } if ( wstIdx != -1 ) { allocation [ i ] = wstIdx ; blockSize [ wstIdx ] -= processSize [ i ] ; } } cout << " Process No . Process Size Block no . " ; for ( int i = 0 ; i < n ; i ++ ) { cout << " ▁ " << i + 1 << " TABSYMBOL TABSYMBOL " << processSize [ i ] << " TABSYMBOL TABSYMBOL " ; if ( allocation [ i ] != -1 ) cout << allocation [ i ] + 1 ; else cout << " Not ▁ Allocated " ; cout << endl ; } } int main ( ) { int blockSize [ ] = { 100 , 500 , 200 , 300 , 600 } ; int processSize [ ] = { 212 , 417 , 112 , 426 } ; int m = sizeof ( blockSize ) / sizeof ( blockSize [ 0 ] ) ; int n = sizeof ( processSize ) / sizeof ( processSize [ 0 ] ) ; worstFit ( blockSize , m , processSize , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCostOfBreaking ( int X [ ] , int Y [ ] , int m , int n ) { int res = 0 ; sort ( X , X + m , greater < int > ( ) ) ; sort ( Y , Y + n , greater < int > ( ) ) ; int hzntl = 1 , vert = 1 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( X [ i ] > Y [ j ] ) { res += X [ i ] * vert ; hzntl ++ ; i ++ ; } else { res += Y [ j ] * hzntl ; vert ++ ; j ++ ; } } int total = 0 ; while ( i < m ) total += X [ i ++ ] ; res += total * vert ; total = 0 ; while ( j < n ) total += Y [ j ++ ] ; res += total * hzntl ; return res ; } int main ( ) { int m = 6 , n = 4 ; int X [ m - 1 ] = { 2 , 1 , 3 , 1 , 4 } ; int Y [ n - 1 ] = { 4 , 1 , 2 } ; cout << minimumCostOfBreaking ( X , Y , m - 1 , n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSum ( int arr [ ] , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = INT_MAX ; int index = -1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } int main ( ) { int arr [ ] = { -2 , 0 , 5 , -1 , 2 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumSum ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sol ( int arr [ ] , int n , int k ) { int sum = 0 ; int i = 0 ; sort ( arr , arr + n ) ; while ( k > 0 ) { if ( arr [ i ] >= 0 ) k = 0 ; else { arr [ i ] = ( -1 ) * arr [ i ] ; k = k - 1 ; } i ++ ; } for ( int j = 0 ; j < n ; j ++ ) { sum += arr [ j ] ; } return sum ; } int main ( ) { int arr [ ] = { -2 , 0 , 5 , -1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sol ( arr , n , 4 ) << endl ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; long long int sumArray ( long long int * arr , int n ) { long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } return sum ; } long long int maximizeSum ( long long int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( k && arr [ i ] < 0 ) { arr [ i ] *= -1 ; k -- ; continue ; } break ; } if ( i == n ) i -- ; if ( k == 0 k % 2 == 0 ) { return sumArray ( arr , n ) ; } if ( i != 0 && abs ( arr [ i ] ) >= abs ( arr [ i - 1 ] ) ) { i -- ; } arr [ i ] *= -1 ; return sumArray ( arr , n ) ; } int main ( ) { int n = 5 ; int k = 4 ; long long int arr [ 5 ] = { -3 , -2 , -1 , 5 , 6 } ; cout << maximizeSum ( arr , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstFit ( int weight [ ] , int n , int c ) { int res = 0 ; int bin_rem [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < res ; j ++ ) { if ( bin_rem [ j ] >= weight [ i ] ) { bin_rem [ j ] = bin_rem [ j ] - weight [ i ] ; break ; } } if ( j == res ) { bin_rem [ res ] = c - weight [ i ] ; res ++ ; } } return res ; } int main ( ) { int weight [ ] = { 2 , 5 , 4 , 7 , 1 , 3 , 8 } ; int c = 10 ; int n = sizeof ( weight ) / sizeof ( weight [ 0 ] ) ; cout << " Number ▁ of ▁ bins ▁ required ▁ in ▁ First ▁ Fit ▁ : ▁ " << firstFit ( weight , n , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinOperations ( int A , int B , int prevA , int prevB , vector < vector < int > > & dp ) { if ( A == prevA and B == prevB ) { return INT_MAX ; } if ( A == 0 and B == 0 ) { return 0 ; } if ( dp [ A ] [ B ] != -1 ) { return dp [ A ] [ B ] ; } int ans1 = getMinOperations ( A / 2 , B , A , B , dp ) ; if ( ans1 != INT_MAX ) { ans1 += 1 ; } int ans2 = getMinOperations ( A , B / 2 , A , B , dp ) ; if ( ans2 != INT_MAX ) { ans2 += 1 ; } int ans3 = getMinOperations ( sqrt ( A * B ) , sqrt ( A * B ) , A , B , dp ) ; if ( ans3 != INT_MAX ) { ans3 += 2 ; } return dp [ A ] [ B ] = min ( { ans1 , ans2 , ans3 } ) ; } int main ( ) { int A = 53 , B = 16 ; int mx = max ( A , B ) ; vector < vector < int > > dp ( mx + 1 , vector < int > ( mx + 1 , -1 ) ) ; cout << getMinOperations ( A , B , -1 , -1 , dp ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDiffSum ( int arr [ ] , int n ) { int dp [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int maxVal = arr [ i ] , minVal = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { minVal = min ( minVal , arr [ j ] ) ; maxVal = max ( maxVal , arr [ j ] ) ; if ( j - 1 >= 0 ) dp [ i ] = max ( dp [ i ] , maxVal - minVal + dp [ j - 1 ] ) ; else dp [ i ] = max ( dp [ i ] , maxVal - minVal ) ; } } return dp [ n - 1 ] ; } int main ( ) { int arr [ ] = { 8 , 1 , 7 , 9 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxDiffSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MOD = 1000000007 ; long modPow ( long x , long y ) { long r = 1 , a = x ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) { r = ( r * a ) % MOD ; } a = ( a * a ) % MOD ; y /= 2 ; } return r ; } long modInverse ( long x ) { return modPow ( x , MOD - 2 ) ; } long modDivision ( long p , long q ) { return ( p * modInverse ( q ) ) % MOD ; } long C ( long n , int k ) { if ( k > n ) { return 0 ; } long p = 1 , q = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { q = ( q * i ) % MOD ; p = ( p * ( n - i + 1 ) ) % MOD ; } return modDivision ( p , q ) ; } int countArrays ( int N , int K ) { long res = 1 ; for ( int p = 2 ; p <= K / p ; p ++ ) { int c = 0 ; while ( K % p == 0 ) { K /= p ; c ++ ; } res = ( res * C ( N - 1 + c , c ) ) % MOD ; } if ( N > 1 ) { res = ( res * N ) % MOD ; } return res ; } int main ( ) { int N = 3 , K = 5 ; cout << countArrays ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSessions ( vector < int > & codeTime , vector < vector < int > > & dp , int ones , int n , int mask , int currTime , int WorkingSessionTime ) { if ( currTime > WorkingSessionTime ) return INT_MAX ; if ( mask == ones ) return 1 ; if ( dp [ mask ] [ currTime ] != -1 ) return dp [ mask ] [ currTime ] ; int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( mask & ( 1 << i ) ) == 0 ) { int inc = minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , currTime + codeTime [ i ] , WorkingSessionTime ) ; int inc_next = 1 + minSessions ( codeTime , dp , ones , n , mask | ( 1 << i ) , codeTime [ i ] , WorkingSessionTime ) ; ans = min ( { ans , inc , inc_next } ) ; } } return dp [ mask ] [ currTime ] = ans ; } int solve ( vector < int > codeTime , int n , int WorkingSessionTime ) { vector < vector < int > > dp ( ( 1 << 14 ) , vector < int > ( 15 , -1 ) ) ; int ones = ( 1 << n ) - 1 ; int ans = minSessions ( codeTime , dp , ones , n , 0 , 0 , WorkingSessionTime ) ; if ( WorkingSessionTime < 6 ) { if ( ans % 2 == 0 ) ans = ans / 2 ; else ans = ( ans / 2 ) + 1 ; } return ans ; } int main ( ) { vector < int > codeTime = { 1 , 2 , 3 , 1 , 1 , 3 } ; int n = codeTime . size ( ) ; int WorkingSessionTime = 4 ; cout << solve ( codeTime , n , WorkingSessionTime ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  100005 NEW_LINE int dp [ MAXN ] [ 10 ] ; int solve ( int len , int gap ) { if ( dp [ len ] [ gap ] != -1 ) { return dp [ len ] [ gap ] ; } if ( len == 0 gap == 0 ) { return 1 ; } if ( gap < 0 ) { return 0 ; } int ans = 0 ; for ( int i = 0 ; i <= gap ; i ++ ) { ans += solve ( len - 1 , gap - i ) ; } return dp [ len ] [ gap ] = ans ; } int countValidStrings ( string S ) { memset ( dp , -1 , sizeof ( dp ) ) ; int N = S . length ( ) ; int L = 1 , R = 9 ; int cnt = 0 ; int ans = 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] != ' ? ' ) { R = S [ i ] - '0' ; ans *= solve ( cnt , R - L ) ; L = R ; R = 9 ; cnt = 0 ; } else { cnt ++ ; } } ans *= solve ( cnt , R - L ) ; return ans ; } int main ( ) { string S = "1 ? ? ?2" ; cout << countValidStrings ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string KthString ( int A , int B , long long K , vector < vector < int > > & dp ) { if ( A == 0 ) { return string ( B , '1' ) ; } if ( B == 0 ) { return string ( A , '0' ) ; } if ( K <= dp [ A - 1 ] [ B ] ) { return "0" + KthString ( A - 1 , B , K , dp ) ; } else { return "1" + KthString ( A , B - 1 , K - dp [ A - 1 ] [ B ] , dp ) ; } } int KthStringUtil ( int A , int B , int K ) { vector < vector < int > > dp ( A + 1 , vector < int > ( B + 1 ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i <= A ; ++ i ) { for ( int j = 0 ; j <= B ; ++ j ) { if ( i > 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j > 0 ) { dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } cout << KthString ( A , B , K , dp ) ; return 0 ; } int main ( ) { int A = 3 , B = 3 , K = 7 ; KthStringUtil ( A , B , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int combinationsPossible ( int N , int idx , int prev , int val , int K , vector < vector < vector < int > > > & dp ) { if ( val > K ) { return 0 ; } if ( dp [ val ] [ idx ] [ prev ] != -1 ) { return dp [ val ] [ idx ] [ prev ] ; } if ( idx == N - 1 ) { if ( val == K ) { return 1 ; } return 0 ; } int ans = 0 ; if ( prev == 1 ) { ans += combinationsPossible ( N , idx + 1 , 1 , val + 1 , K , dp ) ; ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) ; } else { ans += combinationsPossible ( N , idx + 1 , 1 , val , K , dp ) ; ans += combinationsPossible ( N , idx + 1 , 0 , val , K , dp ) ; } return dp [ val ] [ idx ] [ prev ] = ans ; } int main ( ) { int N = 5 ; int K = 3 ; vector < vector < vector < int > > > dp ( K + 1 , vector < vector < int > > ( N + 1 , vector < int > ( 2 , -1 ) ) ) ; cout << ( combinationsPossible ( N , 0 , 0 , 0 , K , dp ) + combinationsPossible ( N , 0 , 1 , 0 , K , dp ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMin ( int x , int y , int z ) { return min ( min ( x , y ) , z ) ; } int editDistance ( string str1 , string str2 , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else { dp [ i ] [ j ] = 1 + getMin ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } } } return dp [ m ] [ n ] ; } void minimumSteps ( string & S , int N ) { int ans = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { string S1 = S . substr ( 0 , i ) ; string S2 = S . substr ( i ) ; int count = editDistance ( S1 , S2 , S1 . length ( ) , S2 . length ( ) ) ; ans = min ( ans , count ) ; } cout << ans << ' ' ; } int main ( ) { string S = " aabb " ; int N = S . length ( ) ; minimumSteps ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfWays ( int arr [ ] , int N ) { int pre [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { pre [ i + 1 ] = pre [ i ] + arr [ i ] ; } int dp [ N + 1 ] [ N + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] ++ ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N ; j >= 1 ; j -- ) { dp [ j + 1 ] [ pre [ i + 1 ] % ( j + 1 ) ] += dp [ j ] [ pre [ i + 1 ] % j ] ; if ( i == N - 1 ) { ans += dp [ j ] [ pre [ i + 1 ] % j ] ; } } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countOfWays ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  500 NEW_LINE int lookup [ MAX ] [ MAX ] ; struct Query { int L , R ; } ; void preprocess ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] [ 0 ] = i ; for ( int j = 1 ; ( 1 << j ) <= n ; j ++ ) { for ( int i = 0 ; ( i + ( 1 << j ) - 1 ) < n ; i ++ ) { if ( arr [ lookup [ i ] [ j - 1 ] ] < arr [ lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ] ) lookup [ i ] [ j ] = lookup [ i ] [ j - 1 ] ; else lookup [ i ] [ j ] = lookup [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ; } } } int query ( int arr [ ] , int L , int R ) { int j = ( int ) log2 ( R - L + 1 ) ; if ( arr [ lookup [ L ] [ j ] ] <= arr [ lookup [ R - ( 1 << j ) + 1 ] [ j ] ] ) return arr [ lookup [ L ] [ j ] ] ; else return arr [ lookup [ R - ( 1 << j ) + 1 ] [ j ] ] ; } void Min_difference ( int arr [ ] , int n , Query q [ ] , int m ) { preprocess ( arr , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] . L , R = q [ i ] . R ; cout << query ( arr , L , R - 1 ) << ' ' ; } } void minimumDifference ( int arr [ ] , Query q [ ] , int N , int m ) { int diff [ N ] ; for ( int i = 0 ; i < N - 1 ; i ++ ) diff [ i ] = abs ( arr [ i ] - arr [ i + 1 ] ) ; Min_difference ( diff , N - 1 , q , m ) ; } int main ( ) { int arr [ ] = { 2 , 6 , 1 , 8 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Query Q [ ] = { { 0 , 3 } , { 1 , 5 } , { 4 , 5 } } ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; minimumDifference ( arr , Q , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumOperations ( int N ) { int dp [ N + 1 ] ; int i ; for ( int i = 0 ; i <= N ; i ++ ) { dp [ i ] = 1e9 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { if ( dp [ i ] == 1e9 ) continue ; if ( i * 5 <= N ) { dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= N ) { dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } if ( dp [ N ] == 1e9 ) return -1 ; return dp [ N ] ; } int main ( ) { int N = 25 ; cout << minimumOperations ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const long long MOD = 1e9 + 7 ; int numTilings ( int N ) { if ( N < 3 ) { return N ; } vector < vector < long long > > dp ( N + 1 , vector < long long > ( 3 , 0 ) ) ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = dp [ 1 ] [ 2 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 2 ] [ 0 ] + dp [ i - 2 ] [ 1 ] + dp [ i - 2 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 2 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) % MOD ; } return dp [ N ] [ 0 ] ; } int main ( ) { int N = 3 ; cout << numTilings ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > dp ; int countStrings ( int N ) { if ( N == 1 ) return 0 ; if ( dp . find ( N ) != dp . end ( ) ) return dp [ N ] ; int ret = 0 ; for ( int div = 1 ; div <= sqrt ( N ) ; div ++ ) { if ( N % div == 0 ) { ret += ( 1 << div ) - countStrings ( div ) ; int div2 = N / div ; if ( div2 != div and div != 1 ) ret += ( 1 << div2 ) - countStrings ( div2 ) ; } } dp [ N ] = ret ; return ret ; } int main ( ) { int N = 6 ; cout << countStrings ( N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxProfit ( int arr [ ] , int n , int transactionFee ) { int buy = - arr [ 0 ] ; int sell = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = buy ; buy = max ( buy , sell - arr [ i ] ) ; sell = max ( sell , temp + arr [ i ] - transactionFee ) ; } return max ( sell , buy ) ; } int main ( ) { int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int transactionFee = 2 ; cout << MaxProfit ( arr , n , transactionFee ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCSubStr ( char * A , char * B , int m , int n ) { int LCSuff [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( A [ i - 1 ] == B [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; } int main ( ) { char A [ ] = "0110" ; char B [ ] = "1101" ; int M = strlen ( A ) ; int N = strlen ( B ) ; cout << LCSubStr ( A , B , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxJumps ( int arr [ ] , int N ) { int dp [ N ] = { 0 } ; int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { dp [ i ] = arr [ i ] ; int j = i + arr [ i ] ; if ( j < N ) { dp [ i ] = dp [ i ] + dp [ j ] ; } ans = max ( ans , dp [ i ] ) ; } cout << ans ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMaxJumps ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100 ] [ 10 ] [ 2 ] ; int solve ( int i , int n , int prev , bool sign ) { if ( i == n ) { return 1 ; } int & val = dp [ i ] [ prev ] [ sign ] ; if ( val != -1 ) return val ; val = 0 ; if ( i == 0 ) { for ( int digit = ( n == 1 ? 0 : 1 ) ; digit <= 9 ; ++ digit ) { val += solve ( i + 1 , n , digit , sign ) ; } } else if ( i == 1 ) { for ( int digit = 0 ; digit <= 9 ; ++ digit ) { if ( digit != prev ) { val += solve ( i + 1 , n , digit , ( digit > prev ) ) ; } } } else { if ( sign == 1 ) { for ( int digit = prev - 1 ; digit >= 0 ; -- digit ) { val += solve ( i + 1 , n , digit , 0 ) ; } } else { for ( int digit = prev + 1 ; digit <= 9 ; ++ digit ) { val += solve ( i + 1 , n , digit , 1 ) ; } } } return val ; } void countNdigitNumber ( int N ) { memset ( dp , -1 , sizeof dp ) ; cout << solve ( 0 , N , 0 , 0 ) ; } int main ( ) { int N = 3 ; countNdigitNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count ( int N , int L , int R ) { vector < vector < int > > dp ( N , vector < int > ( R - L + 1 , 0 ) ) ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; } for ( int i = 1 ; i < dp [ 0 ] . size ( ) ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 1 ; } ans = dp [ 0 ] [ R - L ] ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < dp [ 0 ] . size ( ) ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } ans += dp [ i ] [ R - L ] ; } return ans ; } int main ( ) { int N = 3 ; int L = 6 ; int R = 9 ; cout << Count ( N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestCommonSubarray ( vector < vector < int > > arr , int n , int m ) { int dp [ n ] [ m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { dp [ i ] [ arr [ i ] [ j ] ] = j ; } } int ans = 1 ; int len = 1 ; for ( int i = 1 ; i < m ; i ++ ) { bool check = true ; for ( int j = 1 ; j < n ; j ++ ) { if ( dp [ j ] [ arr [ 0 ] [ i - 1 ] ] + 1 != dp [ j ] [ arr [ 0 ] [ i ] ] ) { check = false ; break ; } } if ( check ) { len ++ ; ans = max ( ans , len ) ; } else { len = 1 ; } } return ans ; } int main ( ) { int n = 4 ; int m = 5 ; vector < vector < int > > arr { { 4 , 5 , 1 , 2 , 3 , 6 , 7 } , { 1 , 2 , 4 , 5 , 7 , 6 , 3 } , { 2 , 7 , 3 , 4 , 5 , 1 , 6 } } ; int N = arr . size ( ) ; int M = arr [ 0 ] . size ( ) ; cout << largestCommonSubarray ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumSum ( int a [ ] , int b [ ] , int n ) { int dp [ n ] [ 2 ] ; dp [ 0 ] [ 0 ] = a [ 0 ] ; dp [ 0 ] [ 1 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i ] ; dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; if ( i - 2 >= 0 ) { dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , max ( dp [ i - 2 ] [ 0 ] , dp [ i - 2 ] [ 1 ] ) + b [ i ] ) ; } else { dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , b [ i ] ) ; } } return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; } int main ( ) { int A [ ] = { 10 , 1 , 10 , 10 } ; int B [ ] = { 5 , 50 , 1 , 5 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << MaximumSum ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 30 ; void findNumString ( int X , int Y , int dp [ ] [ MAX ] ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i <= X ; ++ i ) { for ( int j = 0 ; j <= Y ; ++ j ) { if ( i > 0 ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; } if ( j > 0 ) { dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } } string kthString ( int X , int Y , int K , int dp [ ] [ MAX ] ) { if ( X == 0 ) { return string ( Y , ' b ' ) ; } if ( Y == 0 ) { return string ( X , ' a ' ) ; } if ( K <= dp [ X - 1 ] [ Y ] ) { return string ( " a " ) + kthString ( X - 1 , Y , K , dp ) ; } else { return string ( " b " ) + kthString ( X , Y - 1 , K - dp [ X - 1 ] [ Y ] , dp ) ; } } void kthStringUtil ( int X , int Y , int K ) { int dp [ MAX ] [ MAX ] ; findNumString ( X , Y , dp ) ; cout << kthString ( X , Y , K , dp ) << ' ' ; } int main ( ) { int X = 4 ; int Y = 3 ; int K = 4 ; kthStringUtil ( X , Y , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumTip ( vector < int > & arr1 , vector < int > & arr2 , int n , int x , int y ) { if ( n == 0 ) return 0 ; if ( x != 0 and y != 0 ) return max ( arr1 [ n - 1 ] + maximumTip ( arr1 , arr2 , n - 1 , x - 1 , y ) , arr2 [ n - 1 ] + maximumTip ( arr1 , arr2 , n - 1 , x , y - 1 ) ) ; if ( y == 0 ) return arr1 [ n - 1 ] + maximumTip ( arr1 , arr2 , n - 1 , x - 1 , y ) ; else return arr2 [ n - 1 ] + maximumTip ( arr1 , arr2 , n - 1 , x , y - 1 ) ; } int main ( ) { int N = 5 ; int X = 3 ; int Y = 3 ; vector < int > A = { 1 , 2 , 3 , 4 , 5 } ; vector < int > B = { 5 , 4 , 3 , 2 , 1 } ; cout << ( maximumTip ( A , B , N , X , Y ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumDeletions ( int A [ ] , int N ) { int ans = INT_MAX ; for ( int i = 1 ; i < ( 1 << N ) ; i ++ ) { vector < int > temp ; for ( int j = 0 ; j < N ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { temp . push_back ( A [ j ] ) ; } } int flag = 0 ; for ( int j = 1 ; j < temp . size ( ) ; j ++ ) if ( temp [ j ] < temp [ j - 1 ] ) flag = 1 ; for ( int j = 1 ; j < temp . size ( ) - 1 ; j ++ ) if ( temp [ j ] - temp [ j - 1 ] > temp [ j + 1 ] - temp [ j ] ) flag = 1 ; if ( flag == 0 ) { ans = min ( ans , N - ( int ) temp . size ( ) ) ; } } return ans ; } int main ( ) { int A [ ] = { 1 , 4 , 5 , 7 , 20 , 21 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minimumDeletions ( A , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE int minimumDeletions ( int A [ ] , int N ) { int dp [ N ] [ MAX ] ; int pref [ N ] [ MAX ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; pref [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( A [ i ] >= A [ j ] ) { int diff = A [ i ] - A [ j ] ; dp [ i ] = max ( dp [ i ] , pref [ j ] + 1 ) ; } } pref [ i ] [ 0 ] = dp [ i ] [ 0 ] ; for ( int j = 1 ; j < MAX ; j ++ ) pref [ i ] [ j ] = max ( dp [ i ] [ j ] , pref [ i ] [ j - 1 ] ) ; } int maxSetSize = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) maxSetSize = max ( maxSetSize , dp [ N - 1 ] [ i ] ) ; return N - maxSetSize ; } int main ( ) { int A [ ] = { 1 , 4 , 5 , 7 , 20 , 21 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minimumDeletions ( A , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSum ( vector < int > A , int N , int K , int D ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) { int sum = 0 ; int c = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i >> j & 1 ) { sum += A [ j ] ; c ++ ; } } if ( sum % D == 0 && c <= K ) ans = max ( ans , sum ) ; } return ans ; } int main ( ) { int N = 5 , K = 3 , D = 7 ; vector < int > A = { 1 , 11 , 5 , 5 , 18 } ; cout << maximumSum ( A , N , K , D ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string longestSubsequence ( string X , string Y ) { int n = X . size ( ) ; int m = Y . size ( ) ; vector < vector < int > > mat ( n + 1 , vector < int > ( m + 1 ) ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < m + 1 ; j ++ ) { if ( i == 0 j == 0 ) mat [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i < n + 1 ; i ++ ) { for ( int j = 1 ; j < m + 1 ; j ++ ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { mat [ i ] [ j ] = 1 + mat [ i - 1 ] [ j - 1 ] ; } else { mat [ i ] [ j ] = mat [ i - 1 ] [ j ] ; } } } int len = 0 , col = 0 ; for ( int i = 0 ; i < m + 1 ; i ++ ) { if ( mat [ n ] [ i ] > len ) { len = mat [ n ] [ i ] ; col = i ; } } string res = " " ; int i = n ; int j = col ; while ( len > 0 ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { res = X [ i - 1 ] + res ; i -- ; j -- ; len -- ; } else { i -- ; } } return res ; } int main ( ) { string X = " ABCD " ; string Y = " ACDBDCD " ; cout << ( longestSubsequence ( X , Y ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 1001 ; bool ok [ sz ] [ sz ] = { } ; int dp [ sz ] [ sz ] ; int minInvalidAreaUtil ( int l , int b ) { if ( dp [ l ] [ b ] == -1 ) { if ( ok [ l ] [ b ] ) { return dp [ l ] [ b ] = 0 ; } int ans = l * b ; for ( int i = 1 ; i < b ; i ++ ) { ans = min ( ans , minInvalidAreaUtil ( l , i ) + minInvalidAreaUtil ( l , b - i ) ) ; } for ( int i = 1 ; i < l ; i ++ ) { ans = min ( ans , minInvalidAreaUtil ( i , b ) + minInvalidAreaUtil ( l - i , b ) ) ; } dp [ l ] [ b ] = ans ; } return dp [ l ] [ b ] ; } void minInvalidArea ( int N , int M , vector < pair < int , int > > & dimensions ) { int K = dimensions . size ( ) ; for ( int i = 0 ; i < K ; i ++ ) { ok [ dimensions [ i ] . first ] [ dimensions [ i ] . second ] = 1 ; ok [ dimensions [ i ] . second ] [ dimensions [ i ] . first ] = 1 ; } for ( int i = 0 ; i < sz ; i ++ ) { for ( int j = 0 ; j < sz ; j ++ ) { dp [ i ] [ j ] = -1 ; } } int minArea = minInvalidAreaUtil ( N , M ) ; cout << minArea << endl ; } int main ( ) { int N = 10 , M = 10 ; vector < pair < int , int > > dimensions = { { 3 , 5 } } ; minInvalidArea ( N , M , dimensions ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( vector < int > arr ) { int N = arr . size ( ) ; int ans = 0 ; map < int , vector < int > > M ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { M [ arr [ i ] ] . push_back ( i ) ; } for ( auto it : M ) { vector < int > v = it . second ; int sum = 0 ; for ( int j = 0 ; j < v . size ( ) ; j ++ ) { ans += sum * ( N - v [ j ] ) ; sum += v [ j ] + 1 ; } } cout << ans ; } int main ( ) { vector < int > arr = { 1 , 2 , 1 , 1 } ; countPairs ( arr ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int start [ 3 ] [ 3 ] ; int ending [ 3 ] [ 3 ] ; void calculateStart ( int n , int m ) { for ( int i = 1 ; i < m ; ++ i ) { start [ 0 ] [ i ] += start [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; ++ i ) { start [ i ] [ 0 ] += start [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { start [ i ] [ j ] += max ( start [ i - 1 ] [ j ] , start [ i ] [ j - 1 ] ) ; } } } void calculateEnd ( int n , int m ) { for ( int i = n - 2 ; i >= 0 ; -- i ) { ending [ i ] [ m - 1 ] += ending [ i + 1 ] [ m - 1 ] ; } for ( int i = m - 2 ; i >= 0 ; -- i ) { ending [ n - 1 ] [ i ] += ending [ n - 1 ] [ i + 1 ] ; } for ( int i = n - 2 ; i >= 0 ; -- i ) { for ( int j = m - 2 ; j >= 0 ; -- j ) { ending [ i ] [ j ] += max ( ending [ i + 1 ] [ j ] , ending [ i ] [ j + 1 ] ) ; } } } void maximumPathSum ( int mat [ ] [ 3 ] , int n , int m , int q , int coordinates [ ] [ 2 ] ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { start [ i ] [ j ] = mat [ i ] [ j ] ; ending [ i ] [ j ] = mat [ i ] [ j ] ; } } calculateStart ( n , m ) ; calculateEnd ( n , m ) ; int ans = 0 ; for ( int i = 0 ; i < q ; ++ i ) { int X = coordinates [ i ] [ 0 ] - 1 ; int Y = coordinates [ i ] [ 1 ] - 1 ; ans = max ( ans , start [ X ] [ Y ] + ending [ X ] [ Y ] - mat [ X ] [ Y ] ) ; } cout << ans ; } int main ( ) { int mat [ ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int N = 3 ; int M = 3 ; int Q = 2 ; int coordinates [ ] [ 2 ] = { { 1 , 2 } , { 2 , 2 } } ; maximumPathSum ( mat , N , M , Q , coordinates ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countAlternatingSubstrings ( string S , int N ) { vector < vector < int > > dp ( 2 , vector < int > ( N , 0 ) ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 ) { if ( S [ i ] == '1' ) dp [ 1 ] [ i ] = 1 ; else dp [ 0 ] [ i ] = 1 ; } else { if ( S [ i ] == '0' ) dp [ 0 ] [ i ] = 1 + dp [ 1 ] [ i + 1 ] ; else dp [ 1 ] [ i ] = 1 + dp [ 0 ] [ i + 1 ] ; } } int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { ans += max ( dp [ 0 ] [ i ] , dp [ 1 ] [ i ] ) ; } return ans ; } int main ( ) { string S = "0010" ; int N = S . length ( ) ; cout << countAlternatingSubstrings ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int A [ ] , int N , int K ) { int sum = 0 ; int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( A [ i ] == 0 ) c ++ ; } if ( K > sum || ( sum + K ) % 2 ) return 0 ; sum = ( sum + K ) / 2 ; int dp [ N + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= sum ; i ++ ) dp [ 0 ] [ i ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( A [ i - 1 ] <= j && A [ i - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - A [ i - 1 ] ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ N ] [ sum ] + pow ( 2 , c ) ; } int main ( ) { int A [ ] = { 1 , 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int K = 3 ; cout << solve ( A , N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100 ] [ 2 ] [ 10 ] [ 2 ] ; int noncoprimeCount ( int i , int N , string & S , bool bound , int prev , bool allZeros ) { if ( i == N ) return 1 ; int & val = dp [ i ] [ bound ] [ prev ] [ allZeros ] ; if ( val != -1 ) return val ; int cnt = 0 ; for ( int j = 0 ; j <= ( bound ? ( S [ i ] - '0' ) : 9 ) ; ++ j ) { if ( ( __gcd ( j , prev ) != 1 ) || ( i == 0 ) allZeros == 1 ) { cnt += noncoprimeCount ( i + 1 , N , S , bound & ( j == ( S [ i ] - '0' ) ) , j , allZeros & ( j == 0 ) ) ; } } return val = cnt ; } void noncoprimeCountUtil ( int R ) { string S = to_string ( R ) ; int N = S . length ( ) ; memset ( dp , -1 , sizeof dp ) ; int ans = noncoprimeCount ( 0 , N , S , 1 , 0 , 1 ) ; cout << ans - 1 << endl ; } int main ( ) { int N = 10000 ; noncoprimeCountUtil ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumStonesUtil ( int * arr , int n , int i , vector < int > & dp ) { if ( i >= n ) return 0 ; int & ans = dp [ i ] ; if ( ans != -1 ) return ans ; ans = INT_MIN ; ans = max ( ans , arr [ i ] - maximumStonesUtil ( arr , n , i + 1 , dp ) ) ; if ( i + 1 < n ) ans = max ( ans , arr [ i ] + arr [ i + 1 ] - maximumStonesUtil ( arr , n , i + 2 , dp ) ) ; if ( i + 2 < n ) ans = max ( ans , arr [ i ] + arr [ i + 1 ] + arr [ i + 2 ] - maximumStonesUtil ( arr , n , i + 3 , dp ) ) ; return ans ; } string maximumStones ( int * arr , int n ) { vector < int > dp ( n , -1 ) ; int res = maximumStonesUtil ( arr , n , 0 , dp ) ; if ( res > 0 ) return " Player1" ; else if ( res < 0 ) return " Player2" ; else return " Tie " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumStones ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfWays ( int N ) { int DP [ N + 1 ] [ 5 ] ; memset ( DP , 0 , sizeof ( DP ) ) ; DP [ 1 ] [ 1 ] = 1 ; DP [ 1 ] [ 2 ] = 1 ; DP [ 1 ] [ 3 ] = 1 ; DP [ 1 ] [ 4 ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( i - 1 > 0 && DP [ i - 1 ] [ 1 ] > 0 ) DP [ i ] [ 1 ] = DP [ i - 1 ] [ 4 ] ; if ( i - 2 > 0 && DP [ i - 2 ] [ 2 ] > 0 ) DP [ i ] [ 2 ] = DP [ i - 2 ] [ 4 ] ; if ( i - 3 > 0 && DP [ i - 3 ] [ 3 ] > 0 ) DP [ i ] [ 3 ] = DP [ i - 3 ] [ 4 ] ; DP [ i ] [ 4 ] = ( DP [ i ] [ 1 ] + DP [ i ] [ 2 ] + DP [ i ] [ 3 ] ) ; } return DP [ N ] [ 4 ] ; } int main ( ) { int N = 15 ; cout << numberOfWays ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSortedArrays ( int start , int m , int size , int n ) { if ( size == m ) return 1 ; if ( start > n ) return 0 ; int notTaken = 0 , taken = 0 ; taken = countSortedArrays ( start , m , size + 1 , n ) ; notTaken = countSortedArrays ( start + 1 , m , size , n ) ; return taken + notTaken ; } int main ( ) { int n = 2 , m = 3 ; cout << countSortedArrays ( 1 , m , 0 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSum ( int arr [ ] , int n ) { int preSum [ n ] ; int sum = 0 ; int maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = max ( arr [ i ] , sum + arr [ i ] ) ; maxSum = max ( maxSum , sum ) ; preSum [ i ] = maxSum ; } sum = 0 ; maxSum = 0 ; int postSum [ n + 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum = max ( arr [ i ] , sum + arr [ i ] ) ; maxSum = max ( maxSum , sum ) ; postSum [ i ] = maxSum ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , preSum [ i ] + postSum [ i ] ) ; } cout << ( ans ) ; } int main ( ) { int arr [ ] = { 7 , 6 , -1 , -4 , -5 , 7 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximumSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxSubsetlength ( vector < string > arr , int A , int B ) { int dp [ A + 1 ] [ B + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( auto & str : arr ) { int zeros = count ( str . begin ( ) , str . end ( ) , '0' ) ; int ones = count ( str . begin ( ) , str . end ( ) , '1' ) ; for ( int i = A ; i >= zeros ; i -- ) for ( int j = B ; j >= ones ; j -- ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - zeros ] [ j - ones ] + 1 ) ; } return dp [ A ] [ B ] ; } int main ( ) { vector < string > arr = { "1" , "0" , "0001" , "10" , "111001" } ; int A = 5 , B = 3 ; cout << MaxSubsetlength ( arr , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfUniqueOutcomes ( int N , int S ) { if ( S < N ) return 0 ; if ( N == 1 N == S ) return 1 ; return ( numberOfUniqueOutcomes ( N - 1 , S - 1 ) + numberOfUniqueOutcomes ( N - 1 , S - 2 ) ) ; } int main ( ) { int N = 3 , S = 4 ; cout << numberOfUniqueOutcomes ( N , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int const size = 20 ; int dp [ size ] ; int ans ; void insertVector ( int mask ) { for ( int i = 0 ; i < 20 ; i ++ ) { if ( ( mask & 1 << i ) == 0 ) continue ; if ( ! dp [ i ] ) { dp [ i ] = mask ; ++ ans ; return ; } mask ^= dp [ i ] ; } } void maxSizeSet ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { insertVector ( arr [ i ] ) ; } cout << ( 1 << ans ) << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxSizeSet ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( int arr [ ] , int n ) { if ( n < 3 ) { cout << arr [ 0 ] ; return ; } int * dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = dp [ 0 ] + arr [ 1 ] + arr [ 2 ] ; for ( int i = 2 ; i < n - 1 ; i ++ ) dp [ i ] = min ( dp [ i - 2 ] + arr [ i ] , dp [ i - 1 ] + arr [ i ] + arr [ i + 1 ] ) ; dp [ n - 1 ] = min ( dp [ n - 2 ] , dp [ n - 3 ] + arr [ n - 1 ] ) ; cout << dp [ n - 1 ] ; } int main ( ) { int arr [ ] = { 9 , 4 , 6 , 8 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minCost ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSum ( int arr [ ] , int N , int K ) { int dp [ N + 2 ] = { 0 } ; int maxval = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( ( i + K * arr [ i ] ) >= N ) { dp [ i ] = arr [ i ] ; } else { dp [ i ] = dp [ i + K * arr [ i ] ] + arr [ i ] ; } maxval = max ( maxval , dp [ i ] ) ; } cout << maxval ; } int main ( ) { int arr [ ] = { 2 , 1 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; maxSum ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSubmatrixSum ( vector < vector < int > > matrix ) { int r = matrix . size ( ) ; int c = matrix [ 0 ] . size ( ) ; int maxSubmatrix = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { for ( int k = i ; k < r ; k ++ ) { for ( int l = j ; l < c ; l ++ ) { int sumSubmatrix = 0 ; for ( int m = i ; m <= k ; m ++ ) { for ( int n = j ; n <= l ; n ++ ) { sumSubmatrix += matrix [ m ] [ n ] ; } } maxSubmatrix = max ( maxSubmatrix , sumSubmatrix ) ; } } } } cout << maxSubmatrix ; } int main ( ) { vector < vector < int > > matrix = { { 0 , -2 , -7 , 0 } , { 9 , 2 , -6 , 2 } , { -4 , 1 , -4 , 1 } , { -1 , 8 , 0 , -2 } } ; maxSubmatrixSum ( matrix ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxSum  50 NEW_LINE #define minSum  50 NEW_LINE #define base  50 NEW_LINE int dp [ maxN ] [ maxSum + minSum ] ; bool v [ maxN ] [ maxSum + minSum ] ; int findCnt ( int * arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; } void countSubsets ( int * arr , int K , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int S1 = ( sum + K ) / 2 ; cout << findCnt ( arr , 0 , S1 , n ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 1 ; countSubsets ( arr , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSubsetSum ( int arr1 [ ] , int arr2 [ ] , int length ) { int dp [ length + 1 ] ; if ( length == 1 ) { cout << ( max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ; return ; } if ( length == 2 ) { cout << ( max ( max ( arr1 [ 1 ] , arr2 [ 1 ] ) , max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ) ; return ; } else { dp [ 0 ] = max ( arr1 [ 0 ] , arr2 [ 0 ] ) ; dp [ 1 ] = max ( max ( arr1 [ 1 ] , arr2 [ 1 ] ) , max ( arr1 [ 0 ] , arr2 [ 0 ] ) ) ; int index = 2 ; while ( index < length ) { dp [ index ] = max ( max ( arr1 [ index ] , arr2 [ index ] ) , max ( max ( arr1 [ index ] + dp [ index - 2 ] , arr2 [ index ] + dp [ index - 2 ] ) , dp [ index - 1 ] ) ) ; ++ index ; } cout << ( dp [ length - 1 ] ) ; } } int main ( ) { int arr1 [ ] = { -1 , -2 , 4 , -4 , 5 } ; int arr2 [ ] = { -1 , -2 , -3 , 4 , 10 } ; int length = 5 ; maximumSubsetSum ( arr1 , arr2 , length ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minAtEachIndex ( int n , int arr [ ] ) { int dp1 [ n ] ; int dp2 [ n ] ; int i ; dp1 [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) dp1 [ i ] = min ( arr [ i ] , dp1 [ i - 1 ] + 1 ) ; dp2 [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) dp2 [ i ] = min ( arr [ i ] , dp2 [ i + 1 ] + 1 ) ; vector < int > v ; for ( i = 0 ; i < n ; i ++ ) v . push_back ( min ( dp1 [ i ] , dp2 [ i ] ) ) ; for ( auto x : v ) cout << x << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 4 , 2 , 5 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minAtEachIndex ( N , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int prodOfDigit ( int N ) { int res = 1 ; while ( N ) { res = res * ( N % 10 ) ; N /= 10 ; } return res ; } int cntNumRange ( int L , int R , int K ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( prodOfDigit ( i ) == K ) { cnt ++ ; } } return cnt ; } int main ( ) { int L = 20 , R = 10000 , K = 14 ; cout << cntNumRange ( L , R , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000007 NEW_LINE long long power ( long long X , long long Y ) { long long res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( Y & 1 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } long long findValue ( long long N ) { long long dp [ N + 1 ] ; dp [ 1 ] = 2 ; dp [ 2 ] = 1024 ; for ( int i = 3 ; i <= N ; i ++ ) { int y = ( i & ( - i ) ) ; int x = i - y ; if ( x == 0 ) { dp [ i ] = power ( dp [ i / 2 ] , 10 ) ; } else { dp [ i ] = ( dp [ x ] * dp [ y ] ) % M ; } } return ( dp [ N ] * dp [ N ] ) % M ; } int main ( ) { long long n = 150 ; cout << findValue ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void FindSub ( string str , string res , int i ) { if ( i == str . length ( ) ) { if ( res . length ( ) > 0 ) { cout << res << " ▁ " ; } return ; } char ch = str [ i ] ; FindSub ( str , res , i + 1 ) ; FindSub ( str , res + ch , i + 1 ) ; FindSub ( str , res + to_string ( int ( ch ) ) , i + 1 ) ; } int main ( ) { string str = " ab " ; string res = " " ; int N = str . length ( ) ; FindSub ( str , res , 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOp ( int N ) { if ( N <= 1 ) return N ; int bit = log2 ( N ) + 1 ; return ( ( 1 << bit ) - 1 ) - MinOp ( N - ( 1 << ( bit - 1 ) ) ) ; } int main ( ) { int N = 4 ; cout << MinOp ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProductPath ( vector < vector < int > > grid ) { int n = grid . size ( ) ; int m = grid [ 0 ] . size ( ) ; vector < vector < int > > maxPath ( n , vector < int > ( m , 0 ) ) ; vector < vector < int > > minPath ( n , vector < int > ( m , 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int mn = INT_MAX ; int mx = INT_MIN ; if ( i == 0 and j == 0 ) { mx = grid [ i ] [ j ] ; mn = grid [ i ] [ j ] ; } if ( i > 0 ) { int tempmx = max ( ( maxPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) , ( minPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) ) ; mx = max ( mx , tempmx ) ; int tempmn = min ( ( maxPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) , ( minPath [ i - 1 ] [ j ] * grid [ i ] [ j ] ) ) ; mn = min ( mn , tempmn ) ; } if ( j > 0 ) { int tempmx = max ( ( maxPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) , ( minPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) ) ; mx = max ( mx , tempmx ) ; int tempmn = min ( ( maxPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) , ( minPath [ i ] [ j - 1 ] * grid [ i ] [ j ] ) ) ; mn = min ( mn , tempmn ) ; } maxPath [ i ] [ j ] = mx ; minPath [ i ] [ j ] = mn ; } } if ( maxPath [ n - 1 ] [ m - 1 ] < 0 ) return -1 ; else return ( maxPath [ n - 1 ] [ m - 1 ] ) ; } int main ( ) { vector < vector < int > > mat = { { 1 , -2 , 1 } , { 1 , -2 , 1 } , { 3 , -4 , 1 } } ; cout << ( maxProductPath ( mat ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int bin [ 3000 ] [ 3000 ] ; void countWays ( const vector < int > & arr ) { int mod = 1e9 + 7 ; bin [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i < 3000 ; i ++ ) { bin [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { bin [ i ] [ j ] = ( bin [ i - 1 ] [ j ] + bin [ i - 1 ] [ j - 1 ] ) % mod ; } } int n = 0 ; for ( auto x : arr ) n += x ; vector < int > ways ( n + 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { ways [ i ] = 1 ; for ( int j = 0 ; j < ( int ) arr . size ( ) ; j ++ ) { ways [ i ] = ( ways [ i ] * bin [ arr [ j ] + i - 1 ] [ i - 1 ] ) % mod ; } for ( int j = 1 ; j < i ; j ++ ) { ways [ i ] = ( ( ways [ i ] - bin [ i ] [ j ] * ways [ j ] ) % mod + mod ) % mod ; } } int ans = 0 ; for ( auto x : ways ) ans = ( ans + x ) % mod ; cout << ans << endl ; } int main ( ) { vector < int > arr = { 1 , 1 } ; countWays ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxScore ( vector < int > & arr ) { int N = arr . size ( ) ; N ++ ; vector < vector < int > > dp ( N + 1 , vector < int > ( 2 * N , -100000 ) ) ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int s = 1 ; s <= 2 * ( N - 1 ) ; s ++ ) { for ( int j = 1 ; j <= N - 1 and j <= s ; j ++ ) { dp [ i ] [ s ] = max ( dp [ i ] [ s ] , arr [ j - 1 ] + dp [ i - 1 ] [ s - j ] ) ; } } } return dp [ N ] [ 2 * ( N - 1 ) ] ; } int main ( ) { vector < int > arr = { 1 , 3 , 0 } ; cout << maxScore ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumCost ( int * cost , int n , int x ) { vector < int > dp ( n + 2 , 0 ) ; dp [ 0 ] = cost [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( i == 1 ) dp [ i ] = cost [ i ] + dp [ i - 1 ] ; if ( i == 2 ) dp [ i ] = cost [ i ] + min ( dp [ i - 1 ] , x + dp [ i - 2 ] ) ; if ( i >= 3 ) dp [ i ] = cost [ i ] + min ( dp [ i - 1 ] , min ( x + dp [ i - 2 ] , 2 * x + dp [ i - 3 ] ) ) ; } cout << dp [ n - 1 ] ; } int main ( ) { int X = 4 ; int cost [ ] = { 6 , 3 , 9 , 2 , 1 , 3 } ; int N = sizeof ( cost ) / sizeof ( cost [ 0 ] ) ; minimumCost ( cost , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int a [ ] , int n , int k ) { if ( n <= 0 ) return 0 ; int option = maxSum ( a , n - 1 , k ) ; if ( k >= a [ n - 1 ] ) option = max ( option , a [ n - 1 ] + maxSum ( a , n - 2 , k - a [ n - 1 ] ) ) ; return option ; } int main ( ) { int arr [ ] = { 50 , 10 , 20 , 30 , 40 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 100 ; cout << ( maxSum ( arr , N , K ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkStr ( string str , int P , int Q ) { int N = str . size ( ) ; char prev = str [ 0 ] ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == prev ) { cnt ++ ; } else { if ( prev == '1' && cnt >= Q ) { return false ; } if ( prev == '0' && cnt >= P ) { return false ; } cnt = 1 ; } prev = str [ i ] ; } if ( prev == '1' && cnt >= Q ) { return false ; } if ( prev == '0' && cnt >= P ) { return false ; } return true ; } int cntBinStr ( string str , int N , int P , int Q ) { int len = str . size ( ) ; if ( len == N ) { if ( checkStr ( str , P , Q ) ) return 1 ; return 0 ; } int X = cntBinStr ( str + '0' , N , P , Q ) ; int Y = cntBinStr ( str + '1' , N , P , Q ) ; return X + Y ; } int main ( ) { int N = 5 , P = 2 , Q = 3 ; cout << cntBinStr ( " " , N , P , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallestPosition ( int m [ ] [ 3 ] , int k , int row ) { int n = row ; int mm = row ; int xors [ n ] [ mm ] ; priority_queue < int , vector < int > , greater < int > > minHeap ; map < int , vector < int > > map ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < mm ; j ++ ) { int a = i - 1 >= 0 ? xors [ i - 1 ] [ j ] : 0 ; int b = j - 1 >= 0 ? xors [ i ] [ j - 1 ] : 0 ; int c = ( i - 1 >= 0 && j - 1 >= 0 ) ? xors [ i - 1 ] [ j - 1 ] : 0 ; xors [ i ] [ j ] = m [ i ] [ j ] ^ a ^ b ^ c ; minHeap . push ( xors [ i ] [ j ] ) ; if ( minHeap . size ( ) > k ) { minHeap . pop ( ) ; } if ( map . find ( xors [ i ] [ j ] ) == map . end ( ) ) map [ xors [ i ] [ j ] ] = { i , j } ; } } int kth_max_e = minHeap . top ( ) ; cout << ( map [ kth_max_e ] [ 0 ] + 1 ) << " ▁ " << ( map [ kth_max_e ] [ 1 ] + 1 ) ; } int main ( ) { int m [ ] [ 3 ] = { { 1 , 2 , 3 } , { 2 , 2 , 1 } , { 2 , 4 , 2 } } ; int k = 1 ; smallestPosition ( m , k , 3 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestPalSubstr ( string str ) { int n = str . size ( ) ; int maxLength = 1 , start = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = i ; j < str . length ( ) ; j ++ ) { int flag = 1 ; for ( int k = 0 ; k < ( j - i + 1 ) / 2 ; k ++ ) if ( str [ i + k ] != str [ j - k ] ) flag = 0 ; if ( flag && ( j - i + 1 ) > maxLength ) { start = i ; maxLength = j - i + 1 ; } } } return maxLength ; } int main ( ) { string str = " forgeeksskeegfor " ; cout << longestPalSubstr ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 101 ] [ 101 ] [ 101 ] ; int helper ( int arr [ ] , int left , int right , int count , int m ) { if ( left > right ) return 0 ; if ( dp [ left ] [ right ] [ count ] != -1 ) { return dp [ left ] [ right ] [ count ] ; } int ans = ( count + 1 ) * m + helper ( arr , left + 1 , right , 0 , m ) ; for ( int i = left + 1 ; i <= right ; ++ i ) { if ( arr [ i ] == arr [ left ] ) { ans = max ( ans , helper ( arr , left + 1 , i - 1 , 0 , m ) + helper ( arr , i , right , count + 1 , m ) ) ; } } dp [ left ] [ right ] [ count ] = ans ; return ans ; } int maxPoints ( int arr [ ] , int n , int m ) { int len = n ; memset ( dp , -1 , sizeof ( dp ) ) ; return helper ( arr , 0 , len - 1 , 0 , m ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 2 , 2 , 3 , 4 , 3 , 1 } ; int M = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxPoints ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWays ( int N ) { if ( N == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i ) ; } } return cnt ; } int main ( ) { int N = 4 ; cout << findWays ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int inf = 1000000008 ; int minSteps ( int m , int n ) { if ( n == m ) return 0 ; if ( m > n ) return inf ; int min_cost = inf ; for ( int i = 2 ; i < m ; i += 2 ) { if ( m % i == 0 ) { min_cost = min ( min_cost , m / i + minSteps ( m + i , n ) ) ; } } return min_cost ; } int main ( ) { int M = 6 ; int N = 24 ; int minimum_cost = minSteps ( M , N ) ; if ( minimum_cost == inf ) minimum_cost = -1 ; cout << minimum_cost ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCountOfNumbers ( int N ) { int k = N % 10 ; int z = N - ( 9 * ( 9 - k ) ) ; if ( z >= 9 && z % 10 == 9 ) { return 10 - k ; } else return -1 ; } int main ( ) { int N = 156 ; cout << minCountOfNumbers ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int INF = 1e7 ; int min_op ( int cur , int M ) { if ( cur > M ) return INF ; if ( cur == M ) return 0 ; int op = INF ; for ( int i = 2 ; i * i <= cur ; i ++ ) { if ( cur % i == 0 ) { if ( i % 2 == 0 ) { op = min ( op , 1 + min_op ( cur + i , M ) ) ; } if ( ( cur / i ) != i && ( cur / i ) % 2 == 0 ) { op = min ( op , 1 + min_op ( cur + ( cur / i ) , M ) ) ; } } } return op ; } int min_operations ( int N , int M ) { int op = min_op ( N , M ) ; if ( op >= INF ) cout << " - 1" ; else cout << op << " STRNEWLINE " ; } int main ( ) { int N = 6 , M = 24 ; min_operations ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findPrimeFactors ( int n ) { vector < int > primeFactors ( 9 , 0 ) ; int j = 0 ; if ( n % 2 == 0 ) { primeFactors [ j ++ ] = 2 ; while ( n % 2 == 0 ) n >>= 1 ; } for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) { primeFactors [ j ++ ] = i ; while ( n % i == 0 ) n /= i ; } } if ( n > 2 ) primeFactors [ j ++ ] = n ; vector < int > PrimeFactors ( j ) ; for ( int i = 0 ; i < j ; i ++ ) { PrimeFactors [ i ] = primeFactors [ i ] ; } return PrimeFactors ; } void findShortestSubsequence ( vector < int > & dp , vector < int > a , int index , vector < int > primeFactors ) { int n = a . size ( ) ; for ( int j = index ; j < n ; j ++ ) { int bitmask = 0 ; for ( int p = 0 ; p < primeFactors . size ( ) ; p ++ ) { if ( ( a [ j ] % primeFactors [ p ] ) == 0 ) { bitmask ^= ( 1 << p ) ; } } for ( int i = 0 ; i < dp . size ( ) ; i ++ ) { if ( dp [ i ] == n + 1 ) continue ; dp [ bitmask & i ] = min ( dp [ bitmask & i ] , dp [ i ] + 1 ) ; } } } void printMinimumLength ( vector < int > a ) { int Min = a . size ( ) + 1 ; for ( int i = 0 ; i < a . size ( ) - 1 ; i ++ ) { vector < int > primeFactors = findPrimeFactors ( a [ i ] ) ; int n = primeFactors . size ( ) ; vector < int > dp ( 1 << n , a . size ( ) + 1 ) ; int setBits = ( 1 << n ) - 1 ; dp [ setBits ] = 1 ; findShortestSubsequence ( dp , a , i + 1 , primeFactors ) ; Min = min ( dp [ 0 ] , Min ) ; } if ( Min == ( a . size ( ) + 1 ) ) cout << -1 << endl ; else cout << Min << endl ; } int main ( ) { vector < int > arr = { 2 , 6 , 12 , 3 } ; printMinimumLength ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { map < int , int > dp ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; if ( ( dp . find ( n ) == dp . end ( ) ) ) dp [ n ] = 1 + min ( n % 2 + count ( n / 2 ) , n % 3 + count ( n / 3 ) ) ; return dp [ n ] ; } int main ( ) { int N = 6 ; cout << count ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorSum ( int a [ ] , int n , int mask , int dp [ ] ) { if ( dp [ mask ] != -1 ) { return dp [ mask ] ; } int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( i != j && ( mask & ( 1 << i ) ) == 0 && ( mask & ( 1 << j ) ) == 0 ) { max_value = max ( max_value , ( a [ i ] ^ a [ j ] ) + xorSum ( a , n , ( mask | ( 1 << i ) | ( 1 << j ) ) , dp ) ) ; } } } return dp [ mask ] = max_value ; } int main ( ) { int n = 4 ; int arr [ ] = { 1 , 2 , 3 , 4 } ; int dp [ ( 1 << n ) + 5 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << ( xorSum ( arr , n , 0 , dp ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void main_fun ( int arr [ ] , int n ) { int dp [ 4 ] [ n ] ; memset ( dp , 0 , sizeof ( dp [ 0 ] [ 0 ] * 4 * n ) ) ; if ( arr [ 0 ] == 0 ) dp [ 0 ] [ 0 ] = 1 ; else dp [ 1 ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + 1 ; else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) dp [ 1 ] [ i ] = max ( dp [ 1 ] [ i - 1 ] + 1 , dp [ 0 ] [ i - 1 ] + 1 ) ; else dp [ 1 ] [ i ] = dp [ 1 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { dp [ 2 ] [ i ] = max ( dp [ 2 ] [ i - 1 ] + 1 , max ( dp [ 1 ] [ i - 1 ] + 1 , dp [ 0 ] [ i - 1 ] + 1 ) ) ; } else dp [ 2 ] [ i ] = dp [ 2 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) { dp [ 3 ] [ i ] = max ( dp [ 3 ] [ i - 1 ] + 1 , max ( dp [ 2 ] [ i - 1 ] + 1 , max ( dp [ 1 ] [ i - 1 ] + 1 , dp [ 0 ] [ i - 1 ] + 1 ) ) ) ; } else dp [ 3 ] [ i ] = dp [ 3 ] [ i - 1 ] ; } int ans = max ( dp [ 2 ] [ n - 1 ] , max ( dp [ 1 ] [ n - 1 ] , max ( dp [ 0 ] [ n - 1 ] , dp [ 3 ] [ n - 1 ] ) ) ) ; cout << ( ans ) ; } int main ( ) { int n = 4 ; int arr [ ] = { 0 , 1 , 0 , 1 } ; main_fun ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; static vector < int > primes ; int M = 100005 ; void sieve ( ) { bool mark [ M ] ; for ( int i = 0 ; i < M ; i ++ ) mark [ i ] = false ; for ( int i = 2 ; i < M ; i ++ ) mark [ i ] = true ; for ( int i = 2 ; i * i < M ; i ++ ) { if ( mark [ i ] ) { for ( int j = i * i ; j < M ; j += i ) mark [ j ] = false ; } } for ( int i = 2 ; i < M ; i ++ ) if ( mark [ i ] ) primes . push_back ( i ) ; } void countPrimonacci ( int l , int r ) { vector < int > dp ; dp . push_back ( 1 ) ; dp . push_back ( 1 ) ; int i = 2 ; set < int > s ; while ( true ) { int x = 0 ; for ( int j = 0 ; j < primes . size ( ) ; j ++ ) { int p = primes [ j ] ; if ( p >= i ) break ; x += dp [ i - p ] ; } if ( x >= l && x <= r ) s . insert ( x ) ; if ( x > r ) break ; dp . push_back ( x ) ; i ++ ; } cout << s . size ( ) ; } int main ( ) { sieve ( ) ; int L = 1 , R = 10 ; countPrimonacci ( L , R ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1e5 + 5 ; const int MOD = 1000000007 ; long int dp [ N ] ; void countStrings ( int K , vector < vector < int > > Q ) { dp [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( i >= K ) dp [ i ] = ( dp [ i ] + dp [ i - K ] ) % MOD ; } for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = ( dp [ i ] + dp [ i - 1 ] ) % MOD ; } for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { long int ans = dp [ Q [ i ] [ 1 ] ] - dp [ Q [ i ] [ 0 ] - 1 ] ; if ( ans < 0 ) ans = ans + MOD ; cout << ans << endl ; } } int main ( ) { int K = 3 ; vector < vector < int > > Q = { { 1 , 4 } , { 3 , 7 } } ; countStrings ( K , Q ) ; return 0 ; }
#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; long minSum ( int n , int num [ ] , int price [ ] ) { long dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = INT_MAX ; long ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( num [ j ] > num [ i ] ) { dp [ j ] = ( long ) min ( ( long ) dp [ j ] , ( long ) price [ i ] + ( long ) price [ j ] ) ; ans = min ( ans , ( long ) dp [ i ] + ( long ) price [ j ] ) ; } } } return ans != INT_MAX ? ans : -1 ; } int main ( ) { int num [ ] = { 2 , 4 , 6 , 7 , 8 } ; int price [ ] = { 10 , 20 , 100 , 20 , 40 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; cout << ( minSum ( n , num , price ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } unsigned long int countStrings ( unsigned int N ) { if ( N % 2 == 1 ) return 0 ; else { N /= 2 ; unsigned long int c = binomialCoeff ( 2 * N , N ) ; return c / ( N + 1 ) ; } } int main ( ) { int N = 6 ; cout << countStrings ( N ) << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int n , int k , int mod , int dp [ ] ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; int cnt = 0 ; for ( int i = 2 ; i <= k ; i += 2 ) { cnt = ( cnt % mod + solve ( n - i , k , mod , dp ) % mod ) % mod ; } dp [ n ] = cnt ; return cnt ; } int main ( ) { const int mod = 1e9 + 7 ; int n = 4 , k = 2 ; int dp [ n + 1 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; int ans = solve ( n , k , mod , dp ) ; cout << ans << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long f [ 12 ] ; void fact ( ) { f [ 0 ] = f [ 1 ] = 1 ; for ( int i = 2 ; i <= 10 ; i ++ ) f [ i ] = i * 1LL * f [ i - 1 ] ; } void solve ( int arr [ ] , int n , int k ) { fact ( ) ; int even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; } if ( k > even ) cout << 0 << endl ; else { cout << f [ even ] / ( f [ k ] * f [ even - k ] ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int k = 1 ; solve ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE int nCrModp ( int n , int r ) { if ( n % 2 == 1 ) { return -1 ; } int C [ r + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % MOD ; } return C [ r ] ; } int main ( ) { int N = 6 ; cout << nCrModp ( N , N / 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMinOperations ( int N ) { int dp [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = N ; dp [ 1 ] = 0 ; for ( int i = 2 ; i < N + 1 ; i ++ ) { if ( i % 2 == 0 && dp [ i ] > dp [ i / 2 ] + 1 ) dp [ i ] = dp [ i / 2 ] + 1 ; if ( i % 3 == 0 && dp [ i ] > dp [ i / 3 ] + 1 ) dp [ i ] = dp [ i / 3 ] + 1 ; if ( dp [ i ] > dp [ i - 1 ] + 1 ) dp [ i ] = dp [ i - 1 ] + 1 ; } cout << dp [ N ] << endl ; vector < int > seq ; while ( N > 1 ) { seq . push_back ( N ) ; if ( dp [ N - 1 ] == dp [ N ] - 1 ) N = N - 1 ; else if ( N % 2 == 0 && dp [ N / 2 ] == dp [ N ] - 1 ) N = N / 2 ; else N = N / 3 ; } seq . push_back ( 1 ) ; for ( int i = seq . size ( ) - 1 ; i >= 0 ; i -- ) cout << seq [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int X = 96234 ; printMinOperations ( X ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxLength ( int arr [ ] , int n ) { vector < int > dp ( n , 1 ) ; for ( int i = n - 1 ; i > 1 ; i -- ) { for ( int j = 1 ; j <= sqrt ( i ) ; j ++ ) { if ( i % j == 0 ) { int s = i / j ; if ( s == j ) { if ( arr [ i ] > arr [ s ] ) { dp [ s ] = max ( dp [ i ] + 1 , dp [ s ] ) ; } } else { if ( s != i && arr [ i ] > arr [ s ] ) dp [ s ] = max ( dp [ i ] + 1 , dp [ s ] ) ; if ( arr [ i ] > arr [ j ] ) { dp [ j ] = max ( dp [ i ] + 1 , dp [ j ] ) ; } } } } } int max = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( dp [ i ] > max ) max = dp [ i ] ; } cout << max << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 0 , 1 , 4 , 2 , 3 , 6 , 4 , 9 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxLength ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProfit ( int price [ ] , int n ) { int buy1 , profit1 , buy2 , profit2 ; buy1 = buy2 = INT_MAX ; profit1 = profit2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { buy1 = min ( buy1 , price [ i ] ) ; profit1 = max ( profit1 , price [ i ] - buy1 ) ; buy2 = min ( buy2 , price [ i ] - profit1 ) ; profit2 = max ( profit2 , price [ i ] - buy2 ) ; } return profit2 ; } int main ( ) { int price [ ] = { 2 , 30 , 15 , 10 , 8 , 25 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; cout << " Maximum ▁ Profit ▁ = ▁ " << maxProfit ( price , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximumScore ( vector < int > a , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; } vector < int > dp ( * max_element ( a . begin ( ) , a . end ( ) ) + 1 , 0 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = freq [ 1 ] ; for ( int i = 2 ; i < dp . size ( ) ; i ++ ) dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + freq [ i ] * i ) ; return dp [ dp . size ( ) - 1 ] ; } int main ( ) { int n ; n = 3 ; vector < int > a { 1 , 2 , 3 } ; cout << findMaximumScore ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long prime [ 1000001 ] = { 0 } ; void seiveOfEratosthenes ( ) { for ( int i = 2 ; i < 1000001 ; i ++ ) { prime [ i ] = 1 ; } for ( int i = 2 ; i * i < 1000001 ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j < 1000001 ; j += i ) { prime [ j ] = 0 ; } } } } void CountElements ( int arr [ ] , int n , int L , int R ) { seiveOfEratosthenes ( ) ; long long countPrime [ n + 1 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) { countPrime [ i ] = countPrime [ i - 1 ] + prime [ arr [ i - 1 ] ] ; } cout << countPrime [ R ] - countPrime [ L - 1 ] << endl ; return ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 8 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int L = 1 , R = 3 ; CountElements ( arr , N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_minimum_operations ( int n , int b [ ] , int k ) { int d [ n + 1 ] = { 0 } ; int operations = 0 , need ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) { d [ i ] += d [ i - 1 ] ; } if ( b [ i ] > d [ i ] ) { operations += b [ i ] - d [ i ] ; need = b [ i ] - d [ i ] ; d [ i ] += need ; if ( i + k <= n ) { d [ i + k ] -= need ; } } } cout << operations << endl ; } int main ( ) { int n = 5 ; int b [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 2 ; find_minimum_operations ( n , b , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int n , k ; int dp [ 1024 ] [ 2048 ] [ 2 ] [ 2 ] ; int Ways ( int col , int comp , int row1 , int row2 ) { if ( comp > k ) return 0 ; if ( col > n ) { if ( comp == k ) return 1 ; else return 0 ; } if ( dp [ col ] [ comp ] [ row1 ] [ row2 ] != -1 ) return dp [ col ] [ comp ] [ row1 ] [ row2 ] ; else { int ans = 0 ; if ( col == 1 ) { ans = ( ans + Ways ( col + 1 , comp + 1 , 0 , 0 ) + Ways ( col + 1 , comp + 1 , 1 , 1 ) ) ; ans = ( ans + Ways ( col + 1 , comp + 2 , 0 , 1 ) + Ways ( col + 1 , comp + 2 , 1 , 0 ) ) ; } else { if ( ( row1 && row2 ) || ( ! row1 && ! row2 ) ) { ans = ( ( ( ans + Ways ( col + 1 , comp + 1 , 0 , 0 ) ) + Ways ( col + 1 , comp + 1 , 1 , 0 ) ) + Ways ( col + 1 , comp + 1 , 0 , 1 ) ) ; ans = ( ans + Ways ( col + 1 , comp , 1 , 1 ) ) ; } if ( row1 && ! row2 ) { ans = ( ( ( ans + Ways ( col + 1 , comp , 0 , 0 ) ) + Ways ( col + 1 , comp , 1 , 1 ) ) + Ways ( col + 1 , comp , 1 , 0 ) ) ; ans = ( ans + Ways ( col + 1 , comp + 2 , 0 , 1 ) ) ; } if ( ! row1 && row2 ) { ans = ( ( ( ans + Ways ( col + 1 , comp , 0 , 0 ) ) + Ways ( col + 1 , comp , 1 , 1 ) ) + Ways ( col + 1 , comp , 0 , 1 ) ) ; ans = ( ans + Ways ( col + 1 , comp + 2 , 1 , 0 ) ) ; } } return dp [ col ] [ comp ] [ row1 ] [ row2 ] = ans ; } } signed main ( ) { n = 2 ; k = 1 ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << Ways ( 1 , 0 , 0 , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool primes [ 1000000 ] ; const int maxn = 1000000 ; void sieve ( ) { memset ( primes , true , sizeof ( primes ) ) ; primes [ 0 ] = primes [ 1 ] = 0 ; for ( int i = 2 ; i * i <= maxn ; i ++ ) { if ( primes [ i ] ) { for ( int j = i * i ; j <= maxn ; j += i ) primes [ j ] = false ; } } } string toBinary ( int n ) { string r = " " ; while ( n != 0 ) { r = ( n % 2 == 0 ? "0" : "1" ) + r ; n /= 2 ; } return ( r == " " ) ? "0" : r ; } void PrimeSplit ( string str ) { string temp ; int cnt = 0 ; vector < string > ans ; int bt = 1 << ( str . size ( ) - 1 ) ; int n = str . size ( ) ; for ( int i = 0 ; i < bt ; i ++ ) { temp = toBinary ( i ) + "0" ; int j = 0 , x = n - temp . size ( ) , y ; while ( j < x ) { temp = "0" + temp ; j ++ ; } j = 0 ; x = 0 ; y = -1 ; string sp = " " , tp = " " ; bool flag = 0 ; while ( j < n ) { sp += str [ j ] ; if ( temp [ j ] == '1' ) { tp += sp + ' , ' ; y = stoi ( sp ) ; if ( ! primes [ y ] ) { flag = 1 ; break ; } sp = " " ; } j ++ ; } tp += sp ; if ( sp != " " ) { y = stoi ( sp ) ; if ( ! primes [ y ] ) flag = 1 ; } if ( ! flag ) ans . push_back ( tp ) ; } if ( ans . size ( ) == 0 ) { cout << -1 << endl ; } for ( auto i : ans ) { cout << i << endl ; } } int main ( ) { string str = "11373" ; sieve ( ) ; PrimeSplit ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  10000000007 NEW_LINE long long countWays ( string s , string t , int k ) { int n = s . size ( ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string p = s . substr ( i , n - i ) + s . substr ( 0 , i ) ; if ( p == t ) a ++ ; else b ++ ; } vector < long long > dp1 ( k + 1 ) , dp2 ( k + 1 ) ; if ( s == t ) { dp1 [ 0 ] = 1 ; dp2 [ 0 ] = 0 ; } else { dp1 [ 0 ] = 0 ; dp2 [ 0 ] = 1 ; } for ( int i = 1 ; i <= k ; i ++ ) { dp1 [ i ] = ( ( dp1 [ i - 1 ] * ( a - 1 ) ) % mod + ( dp2 [ i - 1 ] * a ) % mod ) % mod ; dp2 [ i ] = ( ( dp1 [ i - 1 ] * ( b ) ) % mod + ( dp2 [ i - 1 ] * ( b - 1 ) ) % mod ) % mod ; } return dp1 [ k ] ; } int main ( ) { string S = " ab " , T = " ab " ; int K = 2 ; cout << countWays ( S , T , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubsequenceUtil ( int ind , int sum , int * A , int N , vector < vector < int > > & dp ) { if ( ind == N ) return 1 ; if ( dp [ ind ] [ sum ] != -1 ) return dp [ ind ] [ sum ] ; if ( A [ ind ] <= sum ) { dp [ ind ] [ sum ] = countSubsequenceUtil ( ind + 1 , sum , A , N , dp ) + countSubsequenceUtil ( ind + 1 , sum - A [ ind ] , A , N , dp ) ; } else { dp [ ind ] [ sum ] = countSubsequenceUtil ( ind + 1 , sum , A , N , dp ) ; } return dp [ ind ] [ sum ] ; } int countSubsequence ( int * A , int N , int X ) { vector < vector < int > > dp ( N , vector < int > ( X + 1 , -1 ) ) ; return countSubsequenceUtil ( 0 , X , A , N , dp ) - 1 ; } int main ( ) { int arr [ ] = { 25 , 13 , 40 } , X = 50 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubsequence ( arr , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int waysToDecode2 ( string s ) { int n = s . size ( ) ; vector < int > dp ( n + 1 , 0 ) ; dp [ 0 ] = 1 ; if ( s [ 0 ] == '0' ) return 0 ; dp [ 1 ] = ( ( s [ 0 ] == ' * ' ) ? 9 : 1 ) ; for ( int i = 2 ; i <= n ; i ++ ) { char first = s [ i - 2 ] ; char second = s [ i - 1 ] ; if ( second == ' * ' ) { dp [ i ] += 9 * dp [ i - 1 ] ; } else if ( second > '0' ) dp [ i ] += dp [ i - 1 ] ; if ( first == '1' first == '2' ) { if ( second == ' * ' ) { if ( first == '1' ) dp [ i ] += 9 * dp [ i - 2 ] ; else if ( first == '2' ) dp [ i ] += 6 * dp [ i - 2 ] ; } else if ( ( ( first - '0' ) * 10 + ( second - '0' ) ) <= 26 ) dp [ i ] += dp [ i - 2 ] ; } else if ( first == ' * ' ) { if ( second == ' * ' ) { dp [ i ] += 15 * dp [ i - 2 ] ; } else if ( second <= '6' ) dp [ i ] += 2 * dp [ i - 2 ] ; else dp [ i ] += dp [ i - 2 ] ; } } return dp [ n ] ; } int main ( ) { string str = "12*3" ; cout << waysToDecode2 ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void goodInteger ( int arr [ ] , int n , int h , int l , int r ) { vector < vector < int > > dp ( n + 1 , vector < int > ( h , -1 ) ) ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < h ; j ++ ) { if ( dp [ i ] [ j ] != -1 ) { int h1 = ( j + arr [ i ] ) % h ; int h2 = ( j + arr [ i ] - 1 ) % h ; dp [ i + 1 ] [ h1 ] = max ( dp [ i + 1 ] [ h1 ] , dp [ i ] [ j ] + ( h1 >= l && h1 <= r ) ) ; dp [ i + 1 ] [ h2 ] = max ( dp [ i + 1 ] [ h2 ] , dp [ i ] [ j ] + ( h2 >= l && h2 <= r ) ) ; } } } int ans = 0 ; for ( int i = 0 ; i < h ; i ++ ) { if ( dp [ n ] [ i ] != -1 ) ans = max ( ans , dp [ n ] [ i ] ) ; } cout << ans << " STRNEWLINE " ; } int main ( ) { int A [ ] = { 16 , 17 , 14 , 20 , 20 , 11 , 22 } ; int H = 24 ; int L = 21 ; int R = 23 ; int size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; goodInteger ( A , size , H , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Query { int L , R ; } ; void fillPrefixArray ( int arr [ ] , int n , int prefixArray [ ] ) { prefixArray [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { prefixArray [ i ] = prefixArray [ i - 1 ] + arr [ i ] ; } else { prefixArray [ i ] = prefixArray [ i - 1 ] - arr [ i ] ; } } } int findResultUtil ( int prefixArray [ ] , int L , int R ) { int result ; if ( L == 0 ) { result = prefixArray [ R ] ; } else { result = prefixArray [ R ] - prefixArray [ L - 1 ] ; } if ( L & 1 ) { result = result * ( -1 ) ; } return result ; } void findResult ( int arr [ ] , int n , Query q [ ] , int m ) { int prefixArray [ n ] ; fillPrefixArray ( arr , n , prefixArray ) ; for ( int i = 0 ; i < m ; i ++ ) { cout << findResultUtil ( prefixArray , q [ i ] . L , q [ i ] . R ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 10 , 13 , 15 , 2 , 45 , 31 , 22 , 3 , 27 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Query q [ ] = { { 2 , 5 } , { 6 , 8 } , { 1 , 7 } , { 4 , 8 } , { 0 , 5 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; findResult ( arr , n , q , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int validSubArrLength ( int arr [ ] , int N , int K ) { int dp [ N + 1 ] ; int pos = 0 ; int ans = 0 ; int mx = 0 ; int pre = 0 ; deque < int > q ; for ( int i = 0 ; i < N ; i ++ ) { while ( ! q . empty ( ) && arr [ q . back ( ) ] < arr [ i ] ) q . pop_back ( ) ; q . push_back ( i ) ; if ( i == 0 ) { mx = arr [ i ] ; dp [ i ] = arr [ i ] ; } else if ( mx <= arr [ i ] ) { dp [ i ] = dp [ i - 1 ] + arr [ i ] ; mx = arr [ i ] ; } else { dp [ i ] = dp [ i - 1 ] + arr [ i ] ; } if ( pre == 0 ) pos = 0 ; else pos = pre - 1 ; while ( ( i - pre + 1 ) * mx - ( dp [ i ] - dp [ pos ] ) > K && pre < i ) { pos = pre ; pre ++ ; while ( ! q . empty ( ) && q . front ( ) < pre && pre < i ) { q . pop_front ( ) ; mx = arr [ q . front ( ) ] ; } } ans = max ( ans , i - pre + 1 ) ; } return ans ; } int main ( ) { int N = 6 ; int K = 8 ; int arr [ ] = { 2 , 7 , 1 , 3 , 4 , 5 } ; cout << validSubArrLength ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isKPartitionPossible ( int arr [ ] , int N , int K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; int target = sum / K ; int dp [ ( 1 << 15 ) ] ; for ( int i = 0 ; i < ( 1 << N ) ; i ++ ) dp [ i ] = -1 ; dp [ 0 ] = 0 ; for ( int mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { if ( dp [ mask ] == -1 ) continue ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! ( mask & ( 1 << i ) ) && dp [ mask ] + arr [ i ] <= target ) { dp [ mask ( 1 << i ) ] = ( dp [ mask ] + arr [ i ] ) % target ; } } } if ( dp [ ( 1 << N ) - 1 ] == 0 ) return true ; else return false ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 5 , 3 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; if ( isKPartitionPossible ( arr , N , K ) ) { cout << " Partitions ▁ into ▁ equal ▁ " ; cout << " sum ▁ is ▁ possible . STRNEWLINE " ; } else { cout << " Partitions ▁ into ▁ equal ▁ " ; cout << " sum ▁ is ▁ not ▁ possible . STRNEWLINE " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printAllSubsetsRec ( int arr [ ] , int n , vector < int > v , int sum ) { if ( sum == 0 ) { return ( int ) v . size ( ) ; } if ( sum < 0 ) return INT_MAX ; if ( n == 0 ) return INT_MAX ; int x = printAllSubsetsRec ( arr , n - 1 , v , sum ) ; v . push_back ( arr [ n - 1 ] ) ; int y = printAllSubsetsRec ( arr , n , v , sum - arr [ n - 1 ] ) ; return min ( x , y ) ; } int printAllSubsets ( int arr [ ] , int n , int sum ) { vector < int > v ; return printAllSubsetsRec ( arr , n , v , sum ) ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 3 , 5 , 6 } ; int sum = 6 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << printAllSubsets ( arr , n , sum ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count ( int S [ ] , int m , int n ) { vector < vector < int > > table ( m + 1 , vector < int > ( n + 1 , 0 ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { table [ 0 ] [ i ] = INT_MAX - 1 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( S [ i - 1 ] > j ) { table [ i ] [ j ] = table [ i - 1 ] [ j ] ; } else { table [ i ] [ j ] = min ( table [ i - 1 ] [ j ] , table [ i ] [ j - S [ i - 1 ] ] + 1 ) ; } } } return table [ m ] [ n ] ; } int main ( ) { int arr [ ] = { 9 , 6 , 5 , 1 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count ( arr , m , 11 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INF  10000000 NEW_LINE int maximum ( int A , int B , int C , int D ) { return max ( max ( A , B ) , max ( C , D ) ) ; } int maxProductUtil ( int X , int Y , int * A , int * B , vector < vector < int > > & dp ) { if ( X < 0 or Y < 0 ) return - INF ; if ( dp [ X ] [ Y ] != -1 ) return dp [ X ] [ Y ] ; dp [ X ] [ Y ] = maximum ( A [ X ] * B [ Y ] + maxProductUtil ( X - 1 , Y - 1 , A , B , dp ) , A [ X ] * B [ Y ] , maxProductUtil ( X - 1 , Y , A , B , dp ) , maxProductUtil ( X , Y - 1 , A , B , dp ) ) ; return dp [ X ] [ Y ] ; } int maxProduct ( int A [ ] , int N , int B [ ] , int M ) { vector < vector < int > > dp ( N , vector < int > ( M , -1 ) ) ; return maxProductUtil ( N - 1 , M - 1 , A , B , dp ) ; } int main ( ) { int a [ ] = { -2 , 6 , -2 , -5 } ; int b [ ] = { -3 , 4 , -2 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << maxProduct ( a , n , b , m ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperation ( int k ) { vector < int > dp ( k + 1 , 0 ) ; for ( int i = 1 ; i <= k ; i ++ ) { dp [ i ] = dp [ i - 1 ] + 1 ; if ( i % 2 == 0 ) { dp [ i ] = min ( dp [ i ] , dp [ i / 2 ] + 1 ) ; } } return dp [ k ] ; } int main ( ) { int K = 12 ; cout << minOperation ( k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int * arr , int n ) { int totalSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; } int dp [ 2 ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ 0 ] [ i ] = 1 ; dp [ 1 ] [ i ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { if ( dp [ 0 ] [ i ] < dp [ 0 ] [ j ] + 1 ) { dp [ 0 ] [ i ] = dp [ 0 ] [ j ] + 1 ; dp [ 1 ] [ i ] = dp [ 1 ] [ j ] + arr [ i ] ; } else if ( dp [ 0 ] [ i ] == dp [ 0 ] [ j ] + 1 ) { dp [ 1 ] [ i ] = min ( dp [ 1 ] [ i ] , dp [ 1 ] [ j ] + arr [ i ] ) ; } } } } int maxm = 0 ; int subtractSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ 0 ] [ i ] > maxm ) { maxm = dp [ 0 ] [ i ] ; subtractSum = dp [ 1 ] [ i ] ; } else if ( dp [ 0 ] [ i ] == maxm ) { subtractSum = min ( subtractSum , dp [ 1 ] [ i ] ) ; } } return totalSum - subtractSum ; } int main ( ) { int arr [ ] = { 4 , 6 , 1 , 2 , 3 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { if ( n == 2 ) return 1 ; else if ( n == 4 ) return 2 ; else if ( n == 6 ) return 4 ; int table [ n + 1 ] , i ; for ( i = 0 ; i < n + 1 ; i ++ ) table [ i ] = 0 ; table [ 0 ] = 0 ; table [ 2 ] = 1 ; table [ 4 ] = 2 ; table [ 6 ] = 4 ; for ( i = 8 ; i <= n ; i = i + 2 ) { table [ i ] = table [ i - 2 ] + table [ i - 4 ] + table [ i - 6 ] ; } return table [ n ] ; } int main ( void ) { int n = 8 ; cout << count ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE bool isPrime ( string number ) { int num = stoi ( number ) ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( ( num % i ) == 0 ) return false ; return num > 1 ? true : false ; } int countPrimeStrings ( string & number , int i ) { if ( i == 0 ) return 1 ; int cnt = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 && number [ i - j ] != '0' && isPrime ( number . substr ( i - j , j ) ) ) { cnt += countPrimeStrings ( number , i - j ) ; cnt %= MOD ; } } return cnt ; } int main ( ) { string s1 = "3175" ; int l = s1 . length ( ) ; cout << countPrimeStrings ( s1 , l ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 1000000007 ; bool sieve [ 1000000 ] ; void buildSieve ( ) { for ( auto & i : sieve ) i = true ; sieve [ 0 ] = false ; sieve [ 1 ] = false ; for ( int p = 2 ; p * p <= 1000000 ; p ++ ) { if ( sieve [ p ] == true ) { for ( int i = p * p ; i <= 1000000 ; i += p ) sieve [ i ] = false ; } } } bool isPrime ( string number ) { int num = stoi ( number ) ; return sieve [ num ] ; } int rec ( string & number , int i , vector < int > & dp ) { if ( dp [ i ] != -1 ) return dp [ i ] ; int cnt = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 && number [ i - j ] != '0' && isPrime ( number . substr ( i - j , j ) ) ) { cnt += rec ( number , i - j , dp ) ; cnt %= MOD ; } } return dp [ i ] = cnt ; } int countPrimeStrings ( string & number ) { int n = number . length ( ) ; vector < int > dp ( n + 1 , -1 ) ; dp [ 0 ] = 1 ; return rec ( number , n , dp ) ; } int main ( ) { buildSieve ( ) ; string s1 = "3175" ; cout << countPrimeStrings ( s1 ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CountWays ( int a , int b , int c ) { int x = b + c + 1 ; int arr [ x ] = { 0 } ; for ( int i = a ; i <= b ; i ++ ) { for ( int j = b ; j <= c ; j ++ ) { arr [ i + j ] ++ ; } } for ( int i = 1 ; i < x ; i ++ ) { cout << arr [ i ] << " ▁ " ; } cout << endl ; } int main ( ) { int a = 1 ; int b = 2 ; int c = 2 ; CountWays ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CountWays ( int a , int b , int c ) { int x = b + c + 2 ; int arr [ x ] = { 0 } ; for ( int i = 1 ; i <= b ; i ++ ) { arr [ i + b ] ++ ; arr [ i + c + 1 ] -- ; } for ( int i = 1 ; i < x - 1 ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; cout << arr [ i ] << " ▁ " ; } cout << endl ; } int main ( ) { int a = 1 ; int b = 2 ; int c = 2 ; CountWays ( a , b , c ) ; return 0 ; }
#include using namespace std ; void differentStrings ( string s ) { int n = s . length ( ) ; vector dp ( n + 1 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] && ( s [ i ] == '1' s [ i ] == '2' ) ) dp [ i + 1 ] = dp [ i ] + dp [ i - 1 ] ; else dp [ i + 1 ] = dp [ i ] ; } cout << dp [ n ] << " STRNEWLINE " ; } int main ( ) { string S = "0111022110" ; differentStrings ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ways ( vector < vector < int > > & arr , int K ) { int R = arr . size ( ) ; int C = arr [ 0 ] . size ( ) ; int preSum [ R ] [ C ] ; for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { preSum [ r ] = arr [ r ] ; if ( r + 1 < R ) preSum [ r ] += preSum [ r + 1 ] ; if ( c + 1 < C ) preSum [ r ] += preSum [ r ] ; if ( r + 1 < R && c + 1 < C ) preSum [ r ] -= preSum [ r + 1 ] ; } } int dp [ K + 1 ] [ R ] [ C ] ; for ( int k = 1 ; k <= K ; k ++ ) { for ( int r = R - 1 ; r >= 0 ; r -- ) { for ( int c = C - 1 ; c >= 0 ; c -- ) { if ( k == 1 ) { dp [ k ] [ r ] = ( preSum [ r ] > 0 ) ? 1 : 0 ; } else { dp [ k ] [ r ] = 0 ; for ( int r1 = r + 1 ; r1 < R ; r1 ++ ) { if ( preSum [ r ] - preSum [ r1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r1 ] ; } for ( int c1 = c + 1 ; c1 < C ; c1 ++ ) { if ( preSum [ r ] - preSum [ r ] [ c1 ] > 0 ) dp [ k ] [ r ] += dp [ k - 1 ] [ r ] [ c1 ] ; } } } } } return dp [ K ] [ 0 ] [ 0 ] ; } int main ( ) { vector < vector < int > > arr = { { 1 , 0 , 0 } , { 1 , 1 , 1 } , { 0 , 0 , 0 } } ; int k = 3 ; cout << ways ( arr , k ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int Col = 3 ; int fact ( int n ) ; int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int sumPathCost ( int grid [ ] [ Col ] , int m , int n ) { int sum = 0 , count ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { count = nCr ( i + j , i ) * nCr ( m + n - i - j , m - i ) ; sum += count * grid [ i ] [ j ] ; } } return sum ; } int main ( ) { int m = 2 ; int n = 2 ; int grid [ ] [ Col ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; cout << sumPathCost ( grid , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSumProd ( string S , int K ) { int len = S . length ( ) ; if ( K > len ) return -1 ; if ( K == len ) return 0 ; vector < int > dp ( len ) ; int count_zero = 0 , count_one = 0 ; for ( int j = 0 ; j < len ; j ++ ) { ( S [ j ] == '0' ) ? count_zero ++ : count_one ++ ; dp [ j ] = count_zero * count_one ; } for ( int i = 1 ; i < K ; i ++ ) { for ( int j = len ; j >= i ; j -- ) { count_zero = 0 , count_one = 0 ; dp [ j ] = INT_MAX ; for ( int k = j ; k >= i ; k -- ) { ( S [ k ] == '0' ) ? count_zero ++ : count_one ++ ; dp [ j ] = min ( dp [ j ] , count_zero * count_one + dp [ k - 1 ] ) ; } } } return dp [ len - 1 ] ; } int main ( ) { string S = "1011000110110100" ; int K = 5 ; cout << minSumProd ( S , K ) << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minPrizes ( int arr [ ] , int n ) { int dpLeft [ n ] ; dpLeft [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] ) { dpLeft [ i ] = dpLeft [ i - 1 ] + 1 ; } else { dpLeft [ i ] = 1 ; } } int dpRight [ n ] ; dpRight [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > arr [ i + 1 ] ) { dpRight [ i ] = dpRight [ i + 1 ] + 1 ; } else { dpRight [ i ] = 1 ; } } int totalPrizes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalPrizes += max ( dpLeft [ i ] , dpRight [ i ] ) ; } cout << totalPrizes << endl ; return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minPrizes ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int get_max_sum ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int dp [ 100001 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; dp [ 1 ] = freq [ 0 ] ; for ( int i = 2 ; i <= 100000 ; i ++ ) { dp [ i ] = max ( dp [ i - 1 ] , dp [ i - 2 ] + i * freq [ i ] ) ; } return dp [ 100000 ] ; } int main ( ) { int N = 3 ; int arr [ ] = { 2 , 2 , 3 } ; cout << get_max_sum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minFlip ( string a ) { int n = a . size ( ) ; vector < vector < int > > dp ( n + 1 , vector < int > ( 2 , 0 ) ) ; dp [ 0 ] [ 0 ] = ( a [ 0 ] == '1' ) ; dp [ 0 ] [ 1 ] = ( a [ 0 ] == '0' ) ; for ( int i = 1 ; i < n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + ( a [ i ] == '1' ) ; dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + ( a [ i ] == '0' ) ; } int answer = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { answer = min ( answer , dp [ i ] [ 1 ] + dp [ n - 1 ] [ 0 ] - dp [ i ] [ 0 ] ) ; } return min ( answer , dp [ n - 1 ] [ 0 ] ) ; } int main ( ) { string s = "1100111000101" ; cout << ( minFlip ( s ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LIIDS ( int arr [ ] , int N ) { int dp [ N + 1 ] ; int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + i ; j <= N ; j += i ) { if ( arr [ j ] > arr [ i ] ) { dp [ j ] = max ( dp [ j ] , dp [ i ] + 1 ) ; } } ans = max ( ans , dp [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 7 , 9 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << LIIDS ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return answer ; } int countWaystoDivide ( int n , int k , int L , int R ) { return calculate ( 0 , n , k , L , R ) ; } int main ( ) { int N = 12 ; int K = 3 ; int L = 1 ; int R = 5 ; cout << countWaystoDivide ( N , K , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PossibleSum ( int n , int m , vector < vector < int > > v , int k ) { int dp [ n + 1 ] [ k + 1 ] = { 0 } ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { if ( dp [ i ] [ j ] == 1 ) { for ( int d = 0 ; d < m ; d ++ ) { if ( ( j + v [ i ] [ d ] ) <= k ) { dp [ i + 1 ] [ j + v [ i ] [ d ] ] = 1 ; } } } } } if ( dp [ n ] [ k ] == 1 ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; } int main ( ) { int N = 2 , M = 10 , K = 5 ; vector < vector < int > > arr = { { 4 , 0 , 15 , 3 , 2 , 20 , 10 , 1 , 5 , 4 } , { 4 , 0 , 10 , 3 , 2 , 25 , 4 , 1 , 5 , 4 } } ; PossibleSum ( N , M , arr , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool dp [ 1 << 20 ] ; bool isprime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } int solve ( int arr [ ] , int curr , int mask , int n ) { if ( isprime ( curr ) ) { if ( mask == ( 1 << n ) - 1 ) { return true ; } curr = 0 ; } if ( mask == ( 1 << n ) - 1 ) { if ( ! isprime ( curr ) ) { return false ; } } if ( dp [ mask ] ) return dp [ mask ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( mask & 1 << i ) ) { if ( solve ( arr , curr + arr [ i ] , mask 1 << i , n ) ) { return true ; } } } return dp [ mask ] = false ; } int main ( ) { int arr [ ] = { 3 , 6 , 7 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( solve ( arr , 0 , 0 , n ) ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int p = 1000000007 ; long long int power ( long long int x , long long int y , long long int p ) { long long int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } void nCr ( long long int n , long long int p , int f [ ] [ 100 ] , int m ) { for ( long long int i = 0 ; i <= n ; i ++ ) { for ( long long int j = 0 ; j <= m ; j ++ ) { if ( j > i ) { f [ i ] [ j ] = 0 ; } else if ( j == 0 j == i ) { f [ i ] [ j ] = 1 ; } else { f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } } void ProductOfSubsets ( int arr [ ] , int n , int m ) { int f [ n + 1 ] [ 100 ] ; nCr ( n , p - 1 , f , m ) ; sort ( arr , arr + n ) ; long long int ans = 1 ; for ( long long int i = 0 ; i < n ; i ++ ) { long long int x = 0 ; for ( long long int j = 1 ; j <= m ; j ++ ) { if ( m % j == 0 ) { x = ( x + ( f [ n - i - 1 ] [ m - j ] * f [ i ] [ j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ; } } ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) ; } cout << ans << endl ; } int main ( ) { int arr [ ] = { 4 , 5 , 7 , 9 , 3 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ProductOfSubsets ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > dp ; int maxSum ( int i , vector < int > & subarr ) { if ( i >= subarr . size ( ) ) return 0 ; if ( dp [ i ] != -1 ) return dp [ i ] ; return dp [ i ] = max ( maxSum ( i + 1 , subarr ) , subarr [ i ] + maxSum ( i + 2 , subarr ) ) ; } int Func ( vector < int > arr ) { vector < int > subarr = arr ; subarr . pop_back ( ) ; dp . resize ( subarr . size ( ) , -1 ) ; int max1 = maxSum ( 0 , subarr ) ; subarr = arr ; subarr . erase ( subarr . begin ( ) ) ; dp . clear ( ) ; dp . resize ( subarr . size ( ) , -1 ) ; int max2 = maxSum ( 0 , subarr ) ; cout << max ( max1 , max2 ) << endl ; } int main ( ) { vector < int > arr = { 1 , 2 , 3 , 1 } ; Func ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int dp [ 1000 ] [ MAX ] [ MAX ] ; int productDigitSum ( int x , int y ) { int sumx = 0 ; while ( x ) { sumx += ( x % 10 ) ; x /= 10 ; } int sumy = 0 ; while ( y ) { sumy += ( y % 10 ) ; y /= 10 ; } return ( sumx * sumy ) ; } int solve ( int arr [ ] , int i , int len , int prev , int n , int k ) { if ( len == k ) return 0 ; if ( i == n ) return INT_MIN ; if ( dp [ i ] [ len ] [ prev ] ) return dp [ i ] [ len ] [ prev ] ; int inc = 0 , exc = 0 ; if ( len & 1 ) { inc = productDigitSum ( arr [ prev ] , arr [ i ] ) + solve ( arr , i + 1 , len + 1 , 0 , n , k ) ; } else { inc = solve ( arr , i + 1 , len + 1 , i , n , k ) ; } exc = solve ( arr , i + 1 , len , prev , n , k ) ; return dp [ i ] [ len ] [ prev ] = max ( inc , exc ) ; } int main ( ) { int arr [ ] = { 10 , 5 , 9 , 101 , 24 , 2 , 20 , 14 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 6 ; cout << solve ( arr , 0 , 0 , 0 , n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > factors [ 100005 ] ; int dp [ 100005 ] ; void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { for ( int j = i ; j <= 100000 ; j += i ) { factors [ j ] . push_back ( i ) ; } } } int solve ( int arr [ ] , int k , int n ) { if ( k == n - 1 ) { return 0 ; } if ( k >= n ) { return INT_MAX ; } if ( dp [ k ] ) { return dp [ k ] ; } int ans = INT_MAX ; for ( auto j : factors [ arr [ k ] ] ) { int res = solve ( arr , k + j , n ) ; if ( res != INT_MAX ) { ans = min ( ans , res + 1 ) ; } } return dp [ k ] = ans ; } int main ( ) { precompute ( ) ; int arr [ ] = { 2 , 8 , 16 , 55 , 99 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << solve ( arr , 0 , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDistance ( vector < vector < int > > & grid ) { vector < pair < int , int > > one ; int M = grid . size ( ) ; int N = grid [ 0 ] . size ( ) ; int ans = -1 ; for ( int i = 0 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { if ( grid [ i ] [ j ] == 1 ) one . emplace_back ( i , j ) ; } } if ( one . empty ( ) || M * N == one . size ( ) ) return -1 ; for ( int i = 0 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { if ( grid [ i ] [ j ] == 1 ) continue ; int dist = INT_MAX ; for ( auto & p : one ) { int d = abs ( p . first - i ) + abs ( p . second - j ) ; dist = min ( dist , d ) ; if ( dist <= ans ) break ; } ans = max ( ans , dist ) ; } } return ans ; } int main ( ) { vector < vector < int > > arr = { { 0 , 0 , 1 } , { 0 , 0 , 0 } , { 0 , 0 , 0 } } ; cout << maxDistance ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDistance ( vector < vector < int > > & grid ) { queue < pair < int , int > > q ; int M = grid . size ( ) ; int N = grid [ 0 ] . size ( ) ; int ans = -1 ; int dirs [ 4 ] [ 2 ] = { { 0 , 1 } , { 1 , 0 } , { 0 , -1 } , { -1 , 0 } } ; for ( int i = 0 ; i < M ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { if ( grid [ i ] [ j ] == 1 ) q . emplace ( i , j ) ; } } if ( q . empty ( ) || M * N == q . size ( ) ) return -1 ; while ( q . size ( ) ) { int cnt = q . size ( ) ; while ( cnt -- ) { auto p = q . front ( ) ; q . pop ( ) ; for ( auto & dir : dirs ) { int x = p . first + dir [ 0 ] ; int y = p . second + dir [ 1 ] ; if ( x < 0 x > = M y < 0 y > = N grid [ x ] [ y ] ) continue ; q . emplace ( x , y ) ; grid [ x ] [ y ] = 1 ; } } ++ ans ; } return ans ; } int main ( ) { vector < vector < int > > arr = { { 0 , 0 , 1 } , { 0 , 0 , 0 } , { 0 , 0 , 1 } } ; cout << maxDistance ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; vector < vector < int > > dp ; int f ( int n , int k ) { if ( n < k ) return 0 ; if ( n == k ) return 1 ; if ( k == 1 ) return 1 ; if ( dp [ n ] [ k ] != -1 ) return dp [ n ] [ k ] ; return dp [ n ] [ k ] = ( ( k * f ( n - 1 , k ) ) % mod + ( f ( n - 1 , k - 1 ) ) % mod ) % mod ; } long operation ( int n ) { dp . resize ( n + 1 , vector < int > ( n + 1 , -1 ) ) ; long ans = 0 , fac = 1 ; for ( int k = 1 ; k <= n ; k ++ ) { fac *= k ; ans = ( ans + ( fac * f ( n , k ) ) % mod ) % mod ; } return ans ; } int main ( ) { int n = 5 ; cout << operation ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; } int sum ; for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { sum = 0 ; for ( int k = 0 ; k <= j ; k ++ ) { sum += dp [ i - 1 ] [ k ] ; } dp [ i ] [ j ] = sum ; } } return dp [ m ] [ n ] ; } int main ( ) { int N = 2 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountSets ( int x , int pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; int answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return answer ; } int CountOrderedSets ( int n ) { int factorial [ 10000 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; } int main ( ) { int N = 3 ; cout << CountOrderedSets ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_set < int > kPowKform ; int func ( int n ) { if ( n <= 0 ) return 0 ; if ( kPowKform . count ( n ) ) return 1 ; int answer = 0 ; int x = n ; while ( x > 0 ) { int d = x % 10 ; if ( d != 0 ) { if ( func ( n - d * d ) ) { answer = 1 ; break ; } } x /= 10 ; } return answer ; } void canBeConverted ( int n ) { if ( func ( n ) ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int N = 90 ; for ( int i = 1 ; i <= 8 ; i ++ ) { int val = 1 ; for ( int j = 1 ; j <= i ; j ++ ) val *= i ; kPowKform . insert ( val ) ; } canBeConverted ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100005 ; int totBackEdges ; int countAdj [ MAX ] , small [ MAX ] ; int isPossible [ MAX ] , depth [ MAX ] ; vector < int > adj [ MAX ] ; int vis [ MAX ] ; void change ( pair < int , int > & p , int x ) { if ( p . second > x ) p . second = x ; if ( p . first > p . second ) swap ( p . first , p . second ) ; } pair < int , int > dfs ( int v , int p = -1 , int de = 0 ) { pair < int , int > answer ( 100000000 , 100000000 ) ; depth [ v ] = de ; vis [ v ] = 1 ; isPossible [ v ] = 1 ; for ( int u : adj [ v ] ) { if ( u ^ p ) { if ( ! vis [ u ] ) { auto x = dfs ( u , v , de + 1 ) ; small [ v ] += small [ u ] ; change ( answer , x . second ) ; change ( answer , x . first ) ; if ( x . second < de ) isPossible [ v ] = 0 ; } else if ( vis [ u ] == 1 ) { totBackEdges ++ ; countAdj [ v ] ++ ; countAdj [ u ] ++ ; small [ p ] ++ ; small [ u ] -- ; change ( answer , depth [ u ] ) ; } } } vis [ v ] = 2 ; return answer ; } int minNodetoRemove ( int n , vector < pair < int , int > > edges ) { for ( int i = 0 ; i < edges . size ( ) ; i ++ ) { adj [ edges [ i ] . first ] . push_back ( edges [ i ] . second ) ; adj [ edges [ i ] . second ] . push_back ( edges [ i ] . first ) ; } memset ( vis , 0 , sizeof ( vis ) ) ; totBackEdges = 0 ; for ( int v = 1 ; v <= n ; v ++ ) { if ( ! vis [ v ] ) dfs ( v ) ; } if ( totBackEdges == 0 ) return -1 ; int node = -1 ; for ( int v = 1 ; v <= n ; v ++ ) { if ( countAdj [ v ] + small [ v ] == totBackEdges && isPossible [ v ] ) { node = v ; } if ( node != -1 ) break ; } return node ; } int main ( ) { int N = 5 ; vector < pair < int , int > > edges ; edges . push_back ( make_pair ( 5 , 1 ) ) ; edges . push_back ( make_pair ( 5 , 2 ) ) ; edges . push_back ( make_pair ( 1 , 2 ) ) ; edges . push_back ( make_pair ( 2 , 3 ) ) ; edges . push_back ( make_pair ( 2 , 4 ) ) ; cout << minNodetoRemove ( N , edges ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  5 NEW_LINE int Large = 1e6 ; vector < int > prime ; void SieveOfEratosthenes ( ) { bool isPrime [ Large + 1 ] ; memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p <= Large ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= Large ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= Large ; p ++ ) if ( isPrime [ p ] ) prime . push_back ( p ) ; } void Display ( int arr [ ] [ M ] , int row ) { for ( int i = 0 ; i < M ; i ++ ) cout << arr [ row ] [ i ] << " ▁ " ; } void countDivisorsMult ( int arr [ ] [ M ] ) { unordered_map < int , int > mp ; int row_no = 0 ; long long max_factor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int no = arr [ i ] [ j ] ; for ( int k = 0 ; k < prime . size ( ) ; k ++ ) { while ( no > 1 && no % prime [ k ] == 0 ) { no /= prime [ k ] ; mp [ prime [ k ] ] ++ ; } if ( no == 1 ) break ; } } long long int res = 1 ; for ( auto it : mp ) { res *= ( it . second + 1L ) ; } if ( max_factor < res ) { row_no = i ; max_factor = res ; } mp . clear ( ) ; } Display ( arr , row_no ) ; } int main ( ) { int arr [ N ] [ M ] = { { 1 , 2 , 3 , 10 , 23 } , { 4 , 5 , 6 , 7 , 8 } , { 7 , 8 , 9 , 15 , 45 } } ; SieveOfEratosthenes ( ) ; countDivisorsMult ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isSquare ( int n ) { int k = sqrt ( n ) ; return ( k * k == n ) ; } int calculate ( int pos , int prev , int sum , vector < int > & v ) { if ( pos == v . size ( ) ) return isSquare ( sum ) ; for ( int i = prev ; i <= 9 ; i ++ ) { v [ pos ] = i ; sum += i * i ; if ( calculate ( pos + 1 , i , sum , v ) ) return 1 ; sum -= i * i ; } return 0 ; } string minValue ( int n ) { vector < int > v ( n ) ; if ( calculate ( 0 , 1 , 0 , v ) ) { string answer = " " ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) answer += char ( v [ i ] + '0' ) ; return answer ; } else return " - 1" ; } int main ( ) { int N = 2 ; cout << minValue ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = ( int ) 1e9 + 7 ; int calculate ( int pos , int g , int n , int k ) { if ( pos == n ) { return g ; } int answer = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { answer = ( answer % MOD + calculate ( pos + 1 , __gcd ( g , i ) , n , k ) % MOD ) ; answer %= MOD ; } return answer ; } int sumofGCD ( int n , int k ) { return calculate ( 0 , 0 , n , k ) ; } int main ( ) { int N = 3 , K = 2 ; cout << sumofGCD ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = ( int ) 1e9 + 7 ; int fastexpo ( int a , int b ) { int res = 1 ; a %= MOD ; while ( b ) { if ( b & 1 ) res = ( res * a ) % MOD ; a *= a ; a %= MOD ; b >>= 1 ; } return res ; } int sumofGCD ( int n , int k ) { int count [ k + 1 ] = { 0 } ; for ( int g = k ; g >= 1 ; g -- ) { int count_multiples = k / g ; int temp ; temp = fastexpo ( count_multiples , n ) ; temp %= MOD ; int extra = 0 ; for ( int j = g * 2 ; j <= k ; j += g ) { extra = ( extra + count [ j ] ) ; extra %= MOD ; } count [ g ] = ( temp - extra + MOD ) ; count [ g ] %= MOD ; } int sum = 0 ; int add ; for ( int i = 1 ; i <= k ; ++ i ) { add = ( count [ i ] % MOD * i % MOD ) ; add %= MOD ; sum += add ; sum %= MOD ; } return sum ; } int main ( ) { int N = 3 , K = 2 ; cout << sumofGCD ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkOdd ( string number ) { int n = number . length ( ) ; int num = number [ n - 1 ] - '0' ; return ( num & 1 ) ; } int splitIntoOdds ( string number ) { int numLen = number . length ( ) ; int splitDP [ numLen + 1 ] ; memset ( splitDP , -1 , sizeof ( splitDP ) ) ; for ( int i = 1 ; i <= numLen ; i ++ ) { if ( i <= 9 && checkOdd ( number . substr ( 0 , i ) ) ) splitDP [ i ] = 1 ; if ( splitDP [ i ] != -1 ) { for ( int j = 1 ; j <= 9 && i + j <= numLen ; j ++ ) { if ( checkOdd ( number . substr ( i , j ) ) ) { if ( splitDP [ i + j ] == -1 ) splitDP [ i + j ] = 1 + splitDP [ i ] ; else splitDP [ i + j ] = min ( splitDP [ i + j ] , 1 + splitDP [ i ] ) ; } } } } return splitDP [ numLen ] ; } int main ( ) { cout << splitIntoOdds ( "123456789123456789123" ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll m , n , d ; vector < int > v ; ll const k = 1e9 + 7 ; ll dp [ 2001 ] [ 2001 ] [ 2 ] ; void init ( string s ) { memset ( dp , -1 , sizeof ( dp ) ) ; v . clear ( ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { v . push_back ( s [ i ] - '0' ) ; } n = s . size ( ) ; } string number_minus_one ( string a ) { string s = a . substr ( 1 ) ; string s1 = " " ; for ( int i = 0 ; i < s . size ( ) - 1 ; i ++ ) s1 += '0' ; if ( a [ 0 ] == 1 and s == s1 ) { ll l = s . size ( ) ; a = " " ; a += '0' ; for ( int i = 0 ; i < l ; i ++ ) a += '9' ; } else { for ( int i = a . size ( ) - 1 ; i >= 0 ; i -- ) { if ( a [ i ] == '0' ) a [ i ] = '9' ; else { a [ i ] = ( ( ( a [ i ] - '0' ) - 1 ) + '0' ) ; break ; } } } return a ; } ll fun ( ll pos , ll sum , ll f ) { if ( pos == n ) { if ( sum == 0 ) { return 1 ; } return 0 ; } if ( dp [ pos ] [ sum ] [ f ] != -1 ) return dp [ pos ] [ sum ] [ f ] ; ll lmt = 9 ; if ( ! f ) lmt = v [ pos ] ; ll ans = 0 ; for ( ll i = 0 ; i <= lmt ; i ++ ) { if ( i == d and pos % 2 == 1 ) ans += 0 ; else if ( i != d and pos % 2 == 0 ) ans += 0 ; else { ll new_f = f ; if ( f == 0 and i < lmt ) new_f = 1 ; ll new_sum = sum ; new_sum *= 10 ; new_sum += i ; new_sum %= m ; ans += fun ( pos + 1 , new_sum , new_f ) ; ans %= k ; } } return dp [ pos ] [ sum ] [ f ] = ans ; } void operations ( string L , string R ) { init ( R ) ; ll ans = fun ( 0 , 0 , 0 ) ; L = number_minus_one ( L ) ; init ( L ) ; ans -= fun ( 0 , 0 , 0 ) ; if ( ans < 0 ) ans += k ; cout << ans << " STRNEWLINE " ; } int main ( ) { m = 2 , d = 2 ; ll Q = 1 ; string arr [ ] [ 2 ] = { { "20" , "32" } } ; for ( ll i = 0 ; i < Q ; i ++ ) { operations ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; bool checkPrime ( string number ) { int num = stoi ( number ) ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( ( num % i ) == 0 ) return false ; return true ; } int splitIntoPrimes ( string number ) { if ( number . length ( ) == 0 ) return 0 ; if ( number . length ( ) <= 6 and checkPrime ( number ) ) return 1 ; else { int numLen = number . length ( ) ; int ans = 1000000 ; for ( int i = 1 ; i <= 6 && i <= numLen ; i ++ ) { if ( checkPrime ( number . substr ( 0 , i ) ) ) { int val = splitIntoPrimes ( number . substr ( i ) ) ; if ( val != -1 ) { ans = min ( ans , 1 + val ) ; } } } if ( ans == 1000000 ) return -1 ; return ans ; } } int main ( ) { cout << splitIntoPrimes ( "13499315" ) << " STRNEWLINE " ; cout << splitIntoPrimes ( "43" ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int k_nonzero_numbers ( string s , int n , int k ) { int dp [ n + 1 ] [ 2 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) for ( int x = 0 ; x <= k ; x ++ ) dp [ i ] [ j ] [ x ] = 0 ; dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; ++ i ) { int sm = 0 ; while ( sm < 2 ) { for ( int j = 0 ; j < k + 1 ; ++ j ) { int x = 0 ; while ( x <= ( sm ? 9 : s [ i ] - '0' ) ) { dp [ i + 1 ] [ sm || x < ( s [ i ] - '0' ) ] [ j + ( x > 0 ) ] += dp [ i ] [ sm ] [ j ] ; ++ x ; } } ++ sm ; } } return dp [ n ] [ 0 ] [ k ] + dp [ n ] [ 1 ] [ k ] ; } int main ( ) { string s = "25" ; int k = 2 ; int n = s . size ( ) ; cout << k_nonzero_numbers ( s , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinctChars ( string s ) { int freq [ 26 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] > 0 ) count ++ ; } return count ; } int waysToSplit ( string s ) { int n = s . length ( ) ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { string left = s . substr ( 0 , i ) ; string right = s . substr ( i , n - i ) ; if ( distinctChars ( left ) == distinctChars ( right ) ) answer ++ ; } return answer ; } int main ( ) { string s = " ababa " ; cout << waysToSplit ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int waysToSplit ( string s ) { int n = s . length ( ) ; int answer = 0 ; int prefix [ n ] = { 0 } ; int suffix [ n ] = { 0 } ; int seen [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int prev = ( i - 1 >= 0 ? prefix [ i - 1 ] : 0 ) ; if ( seen [ s [ i ] - ' a ' ] == 0 ) { prefix [ i ] += ( prev + 1 ) ; } else prefix [ i ] = prev ; seen [ s [ i ] - ' a ' ] = 1 ; } memset ( seen , 0 , sizeof ( seen ) ) ; suffix [ n - 1 ] = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int prev = suffix [ i ] ; if ( seen [ s [ i ] - ' a ' ] == 0 ) { suffix [ i - 1 ] += ( prev + 1 ) ; } else suffix [ i - 1 ] = prev ; seen [ s [ i ] - ' a ' ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( prefix [ i ] == suffix [ i ] ) answer ++ ; } return answer ; } int main ( ) { string s = " ababa " ; cout << waysToSplit ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int p0 , int p1 , int a [ ] , int pos , int n ) { if ( pos == n ) { if ( p0 == p1 ) return p0 ; else return 0 ; } int ans = maxSum ( p0 , p1 , a , pos + 1 , n ) ; ans = max ( ans , maxSum ( p0 + a [ pos ] , p1 , a , pos + 1 , n ) ) ; ans = max ( ans , maxSum ( p0 , p1 + a [ pos ] , a , pos + 1 , n ) ) ; return ans ; } int main ( ) { int n = 4 ; int a [ n ] = { 1 , 2 , 3 , 6 } ; cout << maxSum ( 0 , 0 , a , 0 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; int limit = 2 * sum + 1 ; int dp [ n + 1 ] [ limit ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) dp [ i ] [ j ] = INT_MIN ; } dp [ 0 ] [ sum ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < limit ; j ++ ) { if ( ( j - a [ i - 1 ] ) >= 0 && dp [ i - 1 ] [ j - a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - a [ i - 1 ] ] + a [ i - 1 ] ) ; if ( ( j + a [ i - 1 ] ) < limit && dp [ i - 1 ] [ j + a [ i - 1 ] ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j + a [ i - 1 ] ] ) ; if ( dp [ i - 1 ] [ j ] != INT_MIN ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ sum ] ; } int main ( ) { int n = 4 ; int a [ n ] = { 1 , 2 , 3 , 6 } ; cout << maxSum ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cstring> NEW_LINE using namespace std ; long Count_Paths ( int x , int y ) { if ( x == 0 && y == 0 ) return 0 ; if ( x == 0 y == 0 ) return 1 ; long dp [ max ( x , y ) + 1 ] , p = max ( x , y ) , q = min ( x , y ) ; for ( int i = 0 ; i <= p ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i <= q ; i ++ ) for ( int j = 1 ; j <= p ; j ++ ) dp [ j ] += dp [ j - 1 ] ; return dp [ p ] ; } int main ( ) { int x = 3 , y = 3 ; cout << " Number ▁ of ▁ Paths ▁ " << Count_Paths ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_SIZE  100005 NEW_LINE int fib [ MAX_SIZE + 1 ] ; void fibonacci ( ) { int i ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( i = 2 ; i <= MAX_SIZE ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } void printLevel ( int level ) { int left_index = pow ( 2 , level - 1 ) ; int right_index = pow ( 2 , level ) - 1 ; for ( int i = left_index ; i <= right_index ; i ++ ) { cout << fib [ i - 1 ] << " ▁ " ; } cout << endl ; } int main ( ) { fibonacci ( ) ; int K = 4 ; printLevel ( K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return answer ; } int countWaystoDivide ( int n , int k ) { return calculate ( 0 , 1 , n , k ) ; } int main ( ) { int N = 8 ; int K = 4 ; cout << countWaystoDivide ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxScore ( int l , int r , int prefix_sum [ ] , int num ) { if ( l > r ) return 0 ; int current_sum = prefix_sum [ r ] - ( l - 1 >= 0 ? prefix_sum [ l - 1 ] : 0 ) ; if ( num % 2 == 0 ) current_sum *= -1 ; return current_sum + max ( maxScore ( l + 1 , r , prefix_sum , num + 1 ) , maxScore ( l , r - 1 , prefix_sum , num + 1 ) ) ; } int findMaxScore ( int a [ ] , int n ) { int prefix_sum [ n ] = { 0 } ; prefix_sum [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix_sum [ i ] = prefix_sum [ i - 1 ] + a [ i ] ; } return maxScore ( 0 , n - 1 , prefix_sum , 1 ) ; } int main ( ) { int n = 6 ; int A [ n ] = { 1 , 2 , 3 , 4 , 2 , 6 } ; cout << findMaxScore ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fib [ 100005 ] ; void computeFibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 100005 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } int countString ( string str ) { int ans = 1 ; int cnt = 1 ; for ( int i = 1 ; str [ i ] ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) { cnt ++ ; } else { ans = ans * fib [ cnt ] ; cnt = 1 ; } } ans = ans * fib [ cnt ] ; return ans ; } int main ( ) { string str = " abdllldefkkkk " ; computeFibonacci ( ) ; cout << countString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_map < int , int > Map ; void findPrimeFactors ( int N ) { int i ; Map . clear ( ) ; while ( N % 2 == 0 ) { Map [ 2 ] += 1 ; N /= 2 ; } for ( i = 3 ; i <= sqrt ( N ) ; i += 2 ) { while ( N % i == 0 ) { Map [ i ] += 1 ; N /= i ; } } if ( N > 2 ) { Map [ N ] += 1 ; } } int PowInFactN ( int N , int P ) { int ans = 0 ; int temp = P ; while ( temp <= N ) { ans += N / temp ; temp = temp * P ; } return ans ; } int findPowers ( int N , int P ) { findPrimeFactors ( P ) ; vector < int > Powers ; for ( auto & it : Map ) { int primeFac = it . first ; int facPow = it . second ; int p = PowInFactN ( N , primeFac ) ; p /= facPow ; Powers . push_back ( p ) ; } return * min_element ( Powers . begin ( ) , Powers . end ( ) ) ; } int main ( ) { int N = 24 , P = 4 ; cout << findPowers ( N , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindMaxLength ( int A [ ] , int B [ ] , int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = m - 1 ; j >= 0 ; j -- ) { if ( A [ i ] == B [ j ] ) dp [ j ] [ i ] = dp [ j + 1 ] [ i + 1 ] + 1 ; } } int maxm = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { maxm = max ( maxm , dp [ i ] [ j ] ) ; } } return maxm ; } int main ( ) { int A [ ] = { 1 , 2 , 8 , 2 , 1 } ; int B [ ] = { 8 , 2 , 1 , 4 , 7 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int m = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << ( FindMaxLength ( A , B , n , m ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LAS [ 1000 ] [ 2 ] = { false } ; int solve ( int arr [ ] , int n , int i , bool pos ) { if ( i == n ) return 0 ; if ( LAS [ i ] [ pos ] ) return LAS [ i ] [ pos ] ; int inc = 0 , exc = 0 ; if ( arr [ i ] > 0 && pos == true ) { pos = false ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } else if ( arr [ i ] < 0 && pos == false ) { pos = true ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } exc = solve ( arr , n , i + 1 , pos ) ; LAS [ i ] [ pos ] = max ( inc , exc ) ; return LAS [ i ] [ pos ] ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , 4 , 5 , -6 , 8 , -99 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << max ( solve ( arr , n , 0 , 0 ) , solve ( arr , n , 0 , 1 ) ) ; }
#include " bits / stdc + + . h " NEW_LINE #define MAX  100001 NEW_LINE using namespace std ; void printGolombSequence ( int N ) { int arr [ MAX ] ; int cnt = 0 ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; map < int , int > M ; M [ 2 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( cnt == 0 ) { arr [ i ] = 1 + arr [ i - 1 ] ; cnt = M [ arr [ i ] ] ; cnt -- ; } else { arr [ i ] = arr [ i - 1 ] ; cnt -- ; } M [ i ] = arr [ i ] ; } for ( int i = 1 ; i <= N ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } int main ( ) { int N = 11 ; printGolombSequence ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int number_of_ways ( int n ) { int includes_3 [ n + 1 ] = { } ; int not_includes_3 [ n + 1 ] = { } ; includes_3 [ 3 ] = 1 ; not_includes_3 [ 1 ] = 1 ; not_includes_3 [ 2 ] = 2 ; not_includes_3 [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { includes_3 [ i ] = includes_3 [ i - 1 ] + includes_3 [ i - 2 ] + not_includes_3 [ i - 3 ] ; not_includes_3 [ i ] = not_includes_3 [ i - 1 ] + not_includes_3 [ i - 2 ] ; } return includes_3 [ n ] ; } int main ( ) { int n = 7 ; cout << number_of_ways ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= pow ( 2 , neg_count - 1 ) ; else result = 0 ; return result ; } int main ( ) { int arr [ ] = { 3 , -4 , -1 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntSubSeq ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( string str , int n , int k ) { if ( str [ n - 1 ] == '0' ) return -1 ; if ( n == 1 ) return 0 ; if ( n < 4 ) return 1 ; int dp [ n ] ; dp [ n - 1 ] = 0 ; dp [ n - 2 ] = 1 ; dp [ n - 3 ] = 1 ; for ( int i = n - 4 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) continue ; int steps = INT_MAX ; if ( i + k < n && str [ i + k ] == '1' ) steps = min ( steps , dp [ i + k ] ) ; if ( str [ i + 1 ] == '1' ) steps = min ( steps , dp [ i + 1 ] ) ; if ( str [ i + 2 ] == '1' ) steps = min ( steps , dp [ i + 2 ] ) ; dp [ i ] = ( steps == INT_MAX ) ? steps : 1 + steps ; } if ( dp [ 0 ] == INT_MAX ) return -1 ; return dp [ 0 ] ; } int main ( ) { string str = "101000011" ; int n = str . length ( ) ; int k = 5 ; cout << minSteps ( str , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  10000 NEW_LINE int seg [ 3 * N ] ; int update ( int in , int l , int r , int up_in , int val ) { if ( r < up_in l > up_in ) return seg [ in ] ; if ( l == up_in and r == up_in ) return seg [ in ] = val ; int m = ( l + r ) / 2 ; return seg [ in ] = update ( 2 * in + 1 , l , m , up_in , val ) + update ( 2 * in + 2 , m + 1 , r , up_in , val ) ; } int query ( int in , int l , int r , int l1 , int r1 ) { if ( l > r ) return 0 ; if ( r < l1 l > r1 ) return 0 ; if ( l1 <= l and r <= r1 ) return seg [ in ] ; int m = ( l + r ) / 2 ; return query ( 2 * in + 1 , l , m , l1 , r1 ) + query ( 2 * in + 2 , m + 1 , r , l1 , r1 ) ; } int findCnt ( int * arr , int n ) { int brr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; sort ( brr , brr + n ) ; map < int , int > r ; for ( int i = 0 ; i < n ; i ++ ) r [ brr [ i ] ] = i + 1 ; int dp [ n ] = { 0 } ; int ans = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int rank = r [ arr [ i ] ] ; dp [ i ] = 1 + query ( 0 , 0 , n - 1 , rank , n - 1 ) ; ans += dp [ i ] ; update ( 0 , 0 , n - 1 , rank - 1 , dp [ i ] + query ( 0 , 0 , n - 1 , rank - 1 , rank - 1 ) ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 10 , 9 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findCnt ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int n , int x , int y , int z ) { int dp [ n + 1 ] = { 0 } ; dp [ 0 ] = dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) { dp [ i ] = min ( dp [ ( i + 1 ) / 2 ] + x + z , dp [ i - 1 ] + y ) ; } else { dp [ i ] = min ( dp [ i / 2 ] + x , dp [ i - 1 ] + y ) ; } } return dp [ n ] ; } int main ( ) { int n = 5 , x = 2 , y = 1 , z = 3 ; cout << minCost ( n , x , y , z ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005 NEW_LINE int maximum_set ( int a [ ] , int n ) { int dp [ N ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) dp [ a [ i ] ] = 1 ; int ans = 1 ; for ( int i = N - 1 ; i >= 1 ; i -- ) { if ( dp [ i ] != 0 ) { for ( int j = 2 * i ; j < N ; j += i ) { dp [ i ] = max ( dp [ i ] , 1 + dp [ j ] ) ; ans = max ( ans , dp [ i ] ) ; } } } return ans ; } int main ( ) { int arr [ ] = { 3 , 4 , 6 , 8 , 10 , 18 , 21 , 24 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximum_set ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100 NEW_LINE int dp [ N ] [ 3 ] ; bool v [ N ] [ 3 ] ; int findLargestString ( string & s , int i , int r ) { if ( i == s . size ( ) ) { if ( r == 0 ) return 0 ; else return INT_MIN ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = max ( 1 + findLargestString ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) , findLargestString ( s , i + 1 , r ) ) ; return dp [ i ] [ r ] ; } int main ( ) { string s = "101" ; cout << findLargestString ( s , 0 , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100 NEW_LINE int dp [ N ] [ 3 ] ; bool v [ N ] [ 3 ] ; int findCnt ( string & s , int i , int r ) { if ( i == s . size ( ) ) { if ( r == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = findCnt ( s , i + 1 , ( r * 2 + ( s [ i ] - '0' ) ) % 3 ) + findCnt ( s , i + 1 , r ) ; return dp [ i ] [ r ] ; } int main ( ) { string s = "11" ; cout << ( findCnt ( s , 0 , 0 ) - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCount ( int * arr , int n , int k ) { int ans = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum -= k ; int l = 0 ; int r = 0 ; int tot = 0 ; while ( l < n ) { if ( tot <= sum ) { ans = max ( ans , r - l ) ; if ( r == n ) break ; tot += arr [ r ++ ] ; } else { tot -= arr [ l ++ ] ; } } return ( n - ans ) ; } int main ( ) { int arr [ ] = { 1 , 11 , 5 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 11 ; cout << minCount ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  401 NEW_LINE int dp [ N ] [ N ] ; bool v [ N ] [ N ] ; int minMergeCost ( int i , int j , int * arr ) { if ( i == j ) return 0 ; if ( v [ i ] [ j ] ) return dp [ i ] [ j ] ; v [ i ] [ j ] = 1 ; int & x = dp [ i ] [ j ] ; x = INT_MAX ; int tot = 0 ; for ( int k = i ; k <= j ; k ++ ) tot += arr [ k ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { x = min ( x , tot + minMergeCost ( i , k - 1 , arr ) + minMergeCost ( k , j , arr ) ) ; } return x ; } int main ( ) { int arr [ ] = { 1 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << minMergeCost ( 0 , n - 1 , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define maxSize  50 NEW_LINE using namespace std ; double dp [ maxSize ] ; int v [ maxSize ] ; double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 5 ) return 6 ; if ( v [ x ] ) return dp [ x ] ; v [ x ] = 1 ; dp [ x ] = 1 + ( expectedSteps ( x - 1 ) + expectedSteps ( x - 2 ) + expectedSteps ( x - 3 ) + expectedSteps ( x - 4 ) + expectedSteps ( x - 5 ) + expectedSteps ( x - 6 ) ) / 6 ; return dp [ x ] ; } int main ( ) { int n = 10 ; cout << expectedSteps ( n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubSeq ( string str , int len ) { int ans = 0 ; int mul = 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) ans += mul ; mul *= 2 ; } return ans ; } int main ( ) { string str = "10010" ; int len = str . length ( ) ; cout << countSubSeq ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 1e5 ; int n ; vector < int > tree [ sz ] ; int subtree_size [ sz ] ; int vis [ sz ] ; void addEdge ( int a , int b ) { tree [ a ] . push_back ( b ) ; tree [ b ] . push_back ( a ) ; } int dfs ( int node ) { vis [ node ] = 1 ; subtree_size [ node ] = 1 ; for ( auto child : tree [ node ] ) { if ( ! vis [ child ] ) { subtree_size [ node ] += dfs ( child ) ; } } return subtree_size [ node ] ; } void contribution ( int node , int & ans ) { vis [ node ] = true ; for ( int child : tree [ node ] ) { if ( ! vis [ child ] ) { ans += ( subtree_size [ child ] * ( n - subtree_size [ child ] ) ) ; contribution ( child , ans ) ; } } } int getSum ( ) { memset ( vis , 0 , sizeof ( vis ) ) ; dfs ( 0 ) ; int ans = 0 ; memset ( vis , 0 , sizeof ( vis ) ) ; contribution ( 0 , ans ) ; return ans ; } int main ( ) { n = 5 ; addEdge ( 0 , 1 ) ; addEdge ( 0 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 1 , 4 ) ; cout << getSum ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 3 ; int numberOfCells ( int mat [ ] [ N ] ) { bool row [ N ] [ N ] = { { false } } ; bool col [ N ] [ N ] = { { false } } ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) { row [ i ] [ j ] = ( j + 1 < N ) ? row [ i ] [ j + 1 ] : true ; } else { row [ i ] [ j ] = false ; } } } for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) { col [ i ] [ j ] = ( i + 1 < N ) ? col [ i + 1 ] [ j ] : true ; } else { col [ i ] [ j ] = false ; } } } int cnt = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ i ] [ j ] && col [ i ] [ j ] ) { cnt ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) { if ( col [ i ] [ N - 1 ] ) cnt ++ ; } for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ N - 1 ] [ j ] ) cnt ++ ; } return cnt ; } int main ( ) { int mat [ ] [ N ] = { { 0 , 1 , 1 } , { 0 , 1 , 1 } , { 0 , 1 , 1 } } ; cout << numberOfCells ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumSubarray ( vector < int > arr , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + arr [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } void getUpdatedArray ( vector < int > & arr , vector < int > & copy , int i ) { for ( int j = 0 ; j <= ( i / 2 ) ; j ++ ) { copy [ j ] = arr [ i - j ] ; copy [ i - j ] = arr [ j ] ; } return ; } int maxSum ( vector < int > arr , int size ) { int resSum = INT_MIN ; resSum = max ( resSum , maxSumSubarray ( arr , size ) ) ; vector < int > copyArr = arr ; for ( int i = 1 ; i < size ; i ++ ) { getUpdatedArray ( arr , copyArr , i ) ; resSum = max ( resSum , maxSumSubarray ( copyArr , size ) ) ; } reverse ( arr . begin ( ) , arr . end ( ) ) ; copyArr = arr ; for ( int i = 1 ; i < size ; i ++ ) { getUpdatedArray ( arr , copyArr , i ) ; resSum = max ( resSum , maxSumSubarray ( copyArr , size ) ) ; } return resSum ; } int main ( ) { vector < int > arr { -9 , 21 , 24 , 24 , -51 , -6 , 17 , -42 , -39 , 33 } ; int size = arr . size ( ) ; cout << maxSum ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxGCD ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = __gcd ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = __gcd ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = max ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = max ( ans , __gcd ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } int main ( ) { int a [ ] = { 6 , 7 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MaxGCD ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfProduct ( int arr [ ] , int n , int k ) { int dp [ n + 1 ] [ n + 1 ] = { 0 } ; int cur_sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = arr [ i - 1 ] ; cur_sum += arr [ i - 1 ] ; } for ( int i = 2 ; i <= k ; i ++ ) { int temp_sum = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { cur_sum -= dp [ i - 1 ] [ j ] ; dp [ i ] [ j ] = arr [ j - 1 ] * cur_sum ; temp_sum += dp [ i ] [ j ] ; } cur_sum = temp_sum ; } return cur_sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 2 ; cout << sumOfProduct ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  (int)(1e9 + 7) NEW_LINE int subsequence ( int S [ ] , int T [ ] , int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int j = 0 ; j <= m ; j ++ ) dp [ 0 ] [ j ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= m ; ++ j ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; if ( S [ i - 1 ] == T [ j - 1 ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ j - 1 ] ; dp [ i ] [ j ] += mod ; dp [ i ] [ j ] %= mod ; } } return dp [ n ] [ m ] ; } int main ( ) { int S [ ] = { 1 , 1 } ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; int T [ ] = { 1 , 1 } ; int m = sizeof ( T ) / sizeof ( T [ 0 ] ) ; cout << subsequence ( S , T , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMax ( int arr [ ] , int n ) { int res = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( j = 0 ; j < i ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) count += 1 ; } res = max ( count , res ) ; } return res ; } int main ( ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMax ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMax ( int arr [ ] , int n ) { bool divisible [ n ] = { false } ; int res = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( divisible [ i ] ) continue ; int cnt = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] % arr [ i ] ) == 0 ) { divisible [ j ] = true ; cnt ++ ; } } res = max ( res , cnt ) ; } return res ; } int main ( ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMax ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxM  10 NEW_LINE int dp [ maxN ] [ maxM ] ; bool v [ maxN ] [ maxM ] ; int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; return dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; } int main ( ) { int arr [ ] = { 3 , 3 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 6 ; cout << findCnt ( arr , 0 , 0 , n , m ) - 1 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxM  64 NEW_LINE int dp [ maxN ] [ maxM ] ; bool v [ maxN ] [ maxM ] ; int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr & arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } int main ( ) { int arr [ ] = { 3 , 7 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 3 ; int ans = findLen ( arr , 0 , ( ( 1 << 8 ) - 1 ) , n , m ) ; if ( ans == -1 ) cout << 0 ; else cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxSum  50 NEW_LINE #define minSum  50 NEW_LINE #define base  50 NEW_LINE int dp [ maxN ] [ maxSum + minSum ] ; bool v [ maxN ] [ maxSum + minSum ] ; int findCnt ( int * arr , int i , int required_sum , int n ) { if ( i == n ) { if ( required_sum == 0 ) return 1 ; else return 0 ; } if ( v [ i ] [ required_sum + base ] ) return dp [ i ] [ required_sum + base ] ; v [ i ] [ required_sum + base ] = 1 ; dp [ i ] [ required_sum + base ] = findCnt ( arr , i + 1 , required_sum , n ) + findCnt ( arr , i + 1 , required_sum - arr [ i ] , n ) ; return dp [ i ] [ required_sum + base ] ; } int main ( ) { int arr [ ] = { 3 , 3 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int x = 6 ; cout << findCnt ( arr , 0 , x , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxM  64 NEW_LINE int dp [ maxN ] [ maxM ] ; bool v [ maxN ] [ maxM ] ; int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ) ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; dp [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr arr [ i ] ) , n , m ) ; return dp [ i ] [ curr ] ; } int main ( ) { int arr [ ] = { 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 3 ; cout << findCnt ( arr , 0 , 0 , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  (int)(1e9 + 7) NEW_LINE int modulo_13 ( string s , int n ) { long long dp [ n + 1 ] [ 13 ] = { { 0 } } ; dp [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { int nxt = s [ i ] - '0' ; if ( s [ i ] == ' ? ' ) nxt = j ; for ( int k = 0 ; k < 13 ; k ++ ) { int rem = ( 10 * k + nxt ) % 13 ; dp [ i + 1 ] [ rem ] += dp [ i ] [ k ] ; dp [ i + 1 ] [ rem ] %= MOD ; } if ( s [ i ] != ' ? ' ) break ; } } return ( int ) dp [ n ] [ 5 ] ; } int main ( ) { string s = " ? 44" ; int n = s . size ( ) ; cout << modulo_13 ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LISusingLCS ( vector < int > & seq ) { int n = seq . size ( ) ; vector < vector < int > > L ( n + 1 , vector < int > ( n + 1 ) ) ; vector < int > sortedseq ( seq ) ; sort ( sortedseq . begin ( ) , sortedseq . end ( ) ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; } int main ( ) { vector < int > sequence { 12 , 34 , 1 , 5 , 40 , 80 } ; cout << LISusingLCS ( sequence ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_numbers ( int k , int n , bool flag ) { if ( n == 1 ) { if ( flag ) { return ( k - 1 ) ; } else { return 1 ; } } if ( flag ) return ( k - 1 ) * ( count_numbers ( k , n - 1 , 0 ) + count_numbers ( k , n - 1 , 1 ) ) ; else return count_numbers ( k , n - 1 , 1 ) ; } int main ( ) { int n = 3 ; int k = 10 ; cout << count_numbers ( k , n , true ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_numbers ( int k , int n ) { int dp [ n + 1 ] [ 2 ] ; dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = k - 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] ) * ( k - 1 ) ; } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; } int main ( ) { int k = 10 ; int n = 3 ; cout << count_numbers ( k , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int cntSubsets ( int * arr , int n ) { unsigned int max = pow ( 2 , n ) ; int result = 0 ; for ( int i = 0 ; i < max ; i ++ ) { int counter = i ; if ( counter & ( counter >> 1 ) ) continue ; result ++ ; } return result ; } int main ( ) { int arr [ ] = { 3 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntSubsets ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int cntSubsets ( int * arr , int n ) { int a [ n ] , b [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } int result = a [ n - 1 ] + b [ n - 1 ] ; return result ; } int main ( ) { int arr [ ] = { 3 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntSubsets ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void perfix_calculate ( vector < vector < int > > & A , vector < vector < int > > & row , vector < vector < int > > & col ) { int n = ( int ) A . size ( ) ; int m = ( int ) A [ 0 ] . size ( ) ; for ( int i = 0 ; i < n ; ++ i ) { row [ i ] [ 0 ] = A [ i ] [ 0 ] ; } for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 1 ; j < m ; ++ j ) { row [ i ] [ j ] = row [ i ] [ j - 1 ] + A [ i ] [ j ] ; } } for ( int i = 0 ; i < m ; ++ i ) { col [ 0 ] [ i ] = A [ 0 ] [ i ] ; } for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 1 ; j < n ; ++ j ) { col [ j ] [ i ] = A [ j ] [ i ] + col [ j - 1 ] [ i ] ; } } } int perimeter ( int i , int j , int k , vector < vector < int > > & row , vector < vector < int > > & col , vector < vector < int > > & A ) { int row_s , col_s ; if ( j == 0 ) row_s = 0 ; else row_s = row [ i ] [ j - 1 ] ; if ( i == 0 ) col_s = 0 ; else col_s = col [ i - 1 ] [ j ] ; int upper_row = row [ i ] [ j + k ] - row_s ; int left_col = col [ i + k ] [ j ] - col_s ; if ( j == 0 ) row_s = 0 ; else row_s = row [ i + k ] [ j - 1 ] ; if ( i == 0 ) col_s = 0 ; else col_s = col [ i - 1 ] [ j + k ] ; int lower_row = row [ i + k ] [ j + k ] - row_s ; int right_col = col [ i + k ] [ j + k ] - col_s ; int sum = upper_row + lower_row + left_col + right_col ; sum -= ( A [ i ] [ j ] + A [ i + k ] [ j ] + A [ i ] [ j + k ] + A [ i + k ] [ j + k ] ) ; return sum ; } int maxPerimeter ( vector < vector < int > > & A ) { int n = ( int ) A . size ( ) ; int m = ( int ) A [ 0 ] . size ( ) ; vector < vector < int > > row ( n , vector < int > ( m , 0 ) ) ; vector < vector < int > > col ( n , vector < int > ( m , 0 ) ) ; perfix_calculate ( A , row , col ) ; int maxPer = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { for ( int k = 0 ; k < min ( n - i , m - j ) ; ++ k ) { int perimtr = perimeter ( i , j , k , row , col , A ) ; maxPer = max ( maxPer , perimtr ) ; } } } return maxPer ; } int main ( ) { vector < vector < int > > A = { { 1 , 1 , 0 } , { 1 , 1 , 1 } , { 0 , 1 , 1 } } ; cout << maxPerimeter ( A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1e9 NEW_LINE int minJumps ( int arr [ ] , int N ) { int fib [ 30 ] ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int DP [ N + 2 ] ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { for ( int j = 1 ; j < 30 ; j ++ ) { if ( ( arr [ i - 1 ] == 1 i == N + 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return -1 ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minJumps ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int recur ( int ind , int cnt , int last , int a [ ] , int n , int k , int dp [ ] [ MAX ] ) { if ( cnt == k ) return 0 ; if ( ind == n ) return -1e9 ; if ( dp [ ind ] [ cnt ] != -1 ) return dp [ ind ] [ cnt ] ; int ans = 0 ; for ( int i = ind ; i < n ; i ++ ) { if ( cnt % 2 == 0 ) ans = max ( ans , recur ( i + 1 , cnt + 1 , i , a , n , k , dp ) ) ; else ans = max ( ans , __gcd ( a [ last ] , a [ i ] ) + recur ( i + 1 , cnt + 1 , 0 , a , n , k , dp ) ) ; } return dp [ ind ] [ cnt ] = ans ; } int main ( ) { int a [ ] = { 4 , 5 , 3 , 7 , 8 , 10 , 9 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 4 ; int dp [ n ] [ MAX ] ; memset ( dp , -1 , sizeof dp ) ; cout << recur ( 0 , 0 , 0 , a , n , k , dp ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( string s ) { if ( s . length ( ) == 0 ) return 0 ; int c = 1 ; string d = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { d += s [ i ] ; string s2 = s . substr ( i + 1 , d . length ( ) ) ; if ( s2 == d ) { c = 1 + find ( s . substr ( i + 1 ) ) ; break ; } } return c ; } int main ( ) { string s = " abababab " ; cout << find ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10 ; int maximizeSum ( int a [ ] , int n , int ind , int k , int dp [ MAX ] [ MAX ] ) { if ( k == 0 ) { if ( ind == n ) return 0 ; else return -1e9 ; } else if ( ind == n ) return -1e9 ; else if ( dp [ ind ] [ k ] != -1 ) return dp [ ind ] [ k ] ; else { int ans = 0 ; int mini = a [ ind ] ; for ( int i = ind ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; ans = max ( ans , maximizeSum ( a , n , i + 1 , k - 1 , dp ) + mini ) ; } return dp [ ind ] [ k ] = ans ; } } int main ( ) { int a [ ] = { 5 , 7 , 4 , 2 , 8 , 1 , 6 } ; int k = 3 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int dp [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof dp ) ; cout << maximizeSum ( a , n , 0 , k , dp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int MAX , vector < int > & primes ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( long long p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( long long i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } for ( long long i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] ) primes . push_back ( i ) ; } } int findLongest ( int A [ ] , int n ) { unordered_map < int , int > mpp ; vector < int > primes ; SieveOfEratosthenes ( A [ n - 1 ] , primes ) ; int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ; dp [ n - 1 ] = 1 ; mpp [ A [ n - 1 ] ] = n - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int num = A [ i ] ; dp [ i ] = 1 ; int maxi = 0 ; for ( auto it : primes ) { int xx = num * it ; if ( xx > A [ n - 1 ] ) break ; else if ( mpp [ xx ] != 0 ) { dp [ i ] = max ( dp [ i ] , 1 + dp [ mpp [ xx ] ] ) ; } } mpp [ A [ i ] ] = i ; } int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , dp [ i ] ) ; } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 5 , 6 , 12 , 35 , 60 , 385 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findLongest ( a , n ) ; }
#include <iostream> NEW_LINE #include <list> NEW_LINE using namespace std ; #define MAX  10 NEW_LINE int getCount ( int n ) { list < int > mylist [ MAX ] ; mylist [ 0 ] . assign ( { 0 , 8 } ) ; mylist [ 1 ] . assign ( { 1 , 2 , 4 } ) ; mylist [ 2 ] . assign ( { 2 , 1 , 3 , 5 } ) ; mylist [ 3 ] . assign ( { 3 , 6 , 2 } ) ; mylist [ 4 ] . assign ( { 4 , 1 , 7 , 5 } ) ; mylist [ 5 ] . assign ( { 5 , 4 , 6 , 2 , 8 } ) ; mylist [ 6 ] . assign ( { 6 , 3 , 5 , 9 } ) ; mylist [ 7 ] . assign ( { 7 , 4 , 8 } ) ; mylist [ 8 ] . assign ( { 8 , 5 , 0 , 7 , 9 } ) ; mylist [ 9 ] . assign ( { 9 , 6 , 8 } ) ; int Arr [ MAX ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; for ( int i = 2 ; i <= n ; i ++ ) { int Arr2 [ MAX ] = { 0 } ; for ( int j = 0 ; j < MAX ; j ++ ) { for ( int x : mylist [ j ] ) { Arr2 [ x ] += Arr [ j ] ; } } for ( int j = 0 ; j < MAX ; j ++ ) Arr [ j ] = Arr2 [ j ] ; } int sum = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) sum += Arr [ i ] ; return sum ; } int main ( ) { int n = 2 ; cout << getCount ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < int > > dp ; int solveUtil ( int start , int bucket , string str , int K ) { int N = str . size ( ) ; if ( start == N ) { if ( bucket == K ) return 0 ; return INT_MAX ; } if ( bucket == K ) return INT_MAX ; if ( dp [ start ] [ bucket ] != -1 ) return dp [ start ] [ bucket ] ; int zeroes = 0 ; int ones = 0 ; int ans = INT_MAX ; for ( int i = start ; i < N ; ++ i ) { if ( str [ i ] == '1' ) ones ++ ; else zeroes ++ ; if ( ones * zeroes > ans ) break ; int temp = solveUtil ( i + 1 , bucket + 1 , str , K ) ; if ( temp != INT_MAX ) { ans = min ( ans , temp + ( ones * zeroes ) ) ; } } return dp [ start ] [ bucket ] = ans ; } int solve ( string str , int K ) { int N = str . size ( ) ; dp . clear ( ) ; dp . resize ( N , vector < int > ( K , -1 ) ) ; int ans = solveUtil ( 0 , 0 , str , K ) ; return ans == INT_MAX ? -1 : ans ; } int main ( ) { string S = "0101" ; int K = 2 ; cout << solve ( S , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double Probability ( double p [ ] , int n ) { double dp [ n + 1 ] [ n + 1 ] ; memset ( dp , 0.0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1.0 ; for ( int i = 1 ; i <= n ; i += 1 ) { for ( int j = 0 ; j <= i ; j += 1 ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] * ( 1.0 - p [ i ] ) + dp [ i - 1 ] [ j - 1 ] * p [ i ] ; } } double ans = 0.0 ; for ( int i = ( n + 1 ) / 2 ; i <= n ; i += 1 ) ans += dp [ n ] [ i ] ; return ans ; } int main ( ) { double p [ ] = { 0.0 , 0.3 , 0.4 , 0.7 } ; int n = sizeof ( p ) / sizeof ( p [ 0 ] ) - 1 ; cout << Probability ( p , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define C_MAX  30 NEW_LINE #define max_arr_len  10 NEW_LINE using namespace std ; int dp [ max_arr_len ] [ C_MAX + 1 ] ; bool v [ max_arr_len ] [ C_MAX + 1 ] ; int findMax ( int i , int r , int w [ ] , int n ) { if ( r < 0 ) return INT_MIN ; if ( i == n ) return 0 ; if ( v [ i ] [ r ] ) return dp [ i ] [ r ] ; v [ i ] [ r ] = 1 ; dp [ i ] [ r ] = max ( w [ i ] + findMax ( i + 1 , r - w [ i ] , w , n ) , findMax ( i + 1 , r , w , n ) ) ; return dp [ i ] [ r ] ; } void preCompute ( int w [ ] , int n ) { for ( int i = C_MAX ; i >= 0 ; i -- ) findMax ( 0 , i , w , n ) ; } int ansQuery ( int w ) { return dp [ 0 ] [ w ] ; } int main ( ) { int w [ ] = { 3 , 8 , 9 } ; int n = sizeof ( w ) / sizeof ( int ) ; preCompute ( w , n ) ; int queries [ ] = { 11 , 10 , 4 } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) cout << ansQuery ( queries [ i ] ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define maxLen  10 NEW_LINE using namespace std ; int dp [ maxLen ] ; bool v [ maxLen ] ; int prefix_sum [ maxLen ] ; void findPrefixSum ( int arr [ ] , int n ) { prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = arr [ i ] + prefix_sum [ i - 1 ] ; } int maxSum ( int arr [ ] , int i , int n , int k ) { if ( i + k > n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; int x ; if ( i == 0 ) x = prefix_sum [ k - 1 ] ; else x = prefix_sum [ i + k - 1 ] - prefix_sum [ i - 1 ] ; dp [ i ] = max ( maxSum ( arr , i + 1 , n , k ) , x + maxSum ( arr , i + k + 1 , n , k ) ) ; return dp [ i ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 7 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 1 ; findPrefixSum ( arr , n ) ; cout << maxSum ( arr , 0 , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE #define M  3 NEW_LINE using namespace std ; int findMaxSum ( int arr [ ] [ M ] ) { int sum = 0 ; int b [ N ] [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { b [ i ] [ M - 1 ] = arr [ i ] [ M - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = M - 2 ; j >= 0 ; j -- ) { b [ i ] [ j ] = arr [ i ] [ j ] + b [ i ] [ j + 1 ] ; } } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { sum = max ( sum , b [ i ] [ j ] + b [ i - 1 ] [ j ] ) ; b [ i ] [ j ] = max ( b [ i ] [ j ] , b [ i - 1 ] [ j ] + arr [ i ] [ j ] ) ; } } return sum ; } int main ( ) { int arr [ N ] [ M ] = { { 3 , 7 , 4 } , { 1 , 9 , 6 } , { 1 , 7 , 7 } } ; cout << findMaxSum ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define mod  3803 NEW_LINE #define d  26 NEW_LINE using namespace std ; int hash_b ; int * hash_a ; int * mul ; int mi ( int x ) { int p = mod - 2 ; int s = 1 ; while ( p != 1 ) { if ( p % 2 == 1 ) s = ( s * x ) % mod ; x = ( x * x ) % mod ; p /= 2 ; } return ( s * x ) % mod ; } void genHash ( string & a , string & b ) { hash_a = new int [ a . size ( ) ] ; mul = new int [ a . size ( ) ] ; for ( int i = b . size ( ) - 1 ; i >= 0 ; i -- ) hash_b = ( hash_b * d + ( b [ i ] - 97 ) ) % mod ; mul [ 0 ] = 1 ; hash_a [ 0 ] = ( a [ 0 ] - 97 ) % mod ; for ( int i = 1 ; i < a . size ( ) ; i ++ ) { mul [ i ] = ( mul [ i - 1 ] * d ) % mod ; hash_a [ i ] = ( hash_a [ i - 1 ] + mul [ i ] * ( a [ i ] - 97 ) ) % mod ; } } bool checkEqual ( int i , int len_a , int len_b ) { int x ; if ( i == 0 ) x = hash_a [ len_b - 1 ] ; else { x = ( hash_a [ i + len_b - 1 ] - hash_a [ i - 1 ] + 2 * mod ) % mod ; x = ( x * mi ( mul [ i ] ) ) % mod ; } if ( x == hash_b ) return true ; return false ; } int main ( ) { string a = " abababababa " ; string b = " aba " ; genHash ( a , b ) ; int queries [ ] = { 0 , 1 , 2 , 3 } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) { if ( checkEqual ( queries [ i ] , a . size ( ) , b . size ( ) ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define max_size  20 NEW_LINE #define max_k  20 NEW_LINE using namespace std ; int dp [ max_size ] [ max_k ] ; bool v [ max_size ] [ max_k ] ; int sum = 0 ; void findSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; } int cntWays ( int arr [ ] , int i , int ck , int k , int n , int curr_sum ) { if ( sum % k != 0 ) return 0 ; if ( i != n and ck == k + 1 ) return 0 ; if ( i == n ) { if ( ck == k + 1 ) return 1 ; else return 0 ; } if ( v [ i ] [ ck ] ) return dp [ i ] [ ck ] ; curr_sum += arr [ i ] ; v [ i ] [ ck ] = 1 ; dp [ i ] [ ck ] = cntWays ( arr , i + 1 , ck , k , n , curr_sum ) ; if ( curr_sum == ( sum / k ) * ck ) dp [ i ] [ ck ] += cntWays ( arr , i + 1 , ck + 1 , k , n , curr_sum ) ; return dp [ i ] [ ck ] ; } int main ( ) { int arr [ ] = { 1 , -1 , 1 , -1 , 1 , -1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 2 ; findSum ( arr , n ) ; cout << cntWays ( arr , 0 , 1 , k , n , 0 ) ; }
#include <bits/stdc++.h> NEW_LINE #define arrSize  51 NEW_LINE using namespace std ; int dp [ arrSize ] ; bool v [ arrSize ] ; int sumMax ( int i , int arr [ ] , int n ) { if ( i >= n - 1 ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = max ( arr [ i ] + arr [ i + 1 ] + sumMax ( i + 3 , arr , n ) , sumMax ( i + 1 , arr , n ) ) ; return dp [ i ] ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << sumMax ( 0 , arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxIncreasingSub ( int arr [ ] , int n , int k ) { int dp [ n ] [ k + 1 ] , ans = -1 ; memset ( dp , -1 , sizeof ( dp ) ) ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 1 ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { for ( int l = 1 ; l <= k - 1 ; l ++ ) { if ( dp [ j ] [ l ] != -1 ) { dp [ i ] [ l + 1 ] = max ( dp [ i ] [ l + 1 ] , dp [ j ] [ l ] + arr [ i ] ) ; } } } } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans < dp [ i ] [ k ] ) ans = dp [ i ] [ k ] ; } return ( ans == -1 ) ? 0 : ans ; } int main ( ) { int n = 8 , k = 3 ; int arr [ n ] = { 8 , 5 , 9 , 10 , 5 , 6 , 21 , 8 } ; int ans = MaxIncreasingSub ( arr , n , k ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 200 ] ; int count = 0 ; void print ( int idx ) { for ( int i = 1 ; i < idx ; i ++ ) { cout << dp [ i ] << " ▁ " ; } cout << endl ; } void solve ( int remSum , int maxVal , int idx , int & count ) { if ( remSum == 0 ) { print ( idx ) ; count ++ ; return ; } for ( int i = maxVal ; i >= 1 ; i -- ) { if ( i > remSum ) { continue ; } else if ( i <= remSum ) { dp [ idx ] = i ; solve ( remSum - i , i , idx + 1 , count ) ; } } } int main ( ) { int n = 4 , count = 0 ; solve ( n , n , 1 , count ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define bitscount  32 NEW_LINE #define n  3 NEW_LINE using namespace std ; int prefix_count [ bitscount ] [ n ] [ n ] ; void findPrefixCount ( int arr [ ] [ n ] ) { for ( int i = 0 ; i < bitscount ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] ; } } } for ( int i = 0 ; i < bitscount ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] ; } int rangeOr ( int x1 , int y1 , int x2 , int y2 ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int p ; if ( x1 == 0 and y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] ; else if ( x1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] ; else if ( y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] ; else p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] + prefix_count [ i ] [ x1 - 1 ] [ y1 - 1 ] ; if ( p != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; } int main ( ) { int arr [ ] [ n ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; findPrefixCount ( arr ) ; int queries [ ] [ 4 ] = { { 1 , 1 , 1 , 1 } , { 1 , 2 , 2 , 2 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) cout << rangeOr ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , queries [ i ] [ 2 ] , queries [ i ] [ 3 ] ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define maxLen  10 NEW_LINE using namespace std ; int dp [ maxLen ] ; bool v [ maxLen ] ; int maxSum ( int arr [ ] , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; } int main ( ) { int arr [ ] = { 12 , 9 , 7 , 33 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxSum ( arr , 0 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE #define maxV  20 NEW_LINE using namespace std ; int dp [ n ] [ n ] [ maxV ] ; int v [ n ] [ n ] [ maxV ] ; int countWays ( int i , int j , int x , int arr [ ] [ n ] ) { if ( i == n j == n ) return 0 ; x = ( x & arr [ i ] [ j ] ) ; if ( x == 0 ) return 0 ; if ( i == n - 1 && j == n - 1 ) return 1 ; if ( v [ i ] [ j ] [ x ] ) return dp [ i ] [ j ] [ x ] ; v [ i ] [ j ] [ x ] = 1 ; dp [ i ] [ j ] [ x ] = countWays ( i + 1 , j , x , arr ) + countWays ( i , j + 1 , x , arr ) ; return dp [ i ] [ j ] [ x ] ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 2 , 1 } , { 1 , 1 , 0 } , { 2 , 1 , 1 } } ; cout << countWays ( 0 , 0 , arr [ 0 ] [ 0 ] , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int memo [ MAX ] [ MAX ] ; int oSRec ( int arr [ ] , int i , int j , int sum ) { if ( j == i + 1 ) return max ( arr [ i ] , arr [ j ] ) ; if ( memo [ i ] [ j ] != -1 ) return memo [ i ] [ j ] ; memo [ i ] [ j ] = max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; return memo [ i ] [ j ] ; } int optimalStrategyOfGame ( int * arr , int n ) { int sum = 0 ; sum = accumulate ( arr , arr + n , sum ) ; memset ( memo , -1 , sizeof ( memo ) ) ; return oSRec ( arr , 0 , n - 1 , sum ) ; } int main ( ) { int arr1 [ ] = { 8 , 15 , 3 , 7 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; printf ( " % d STRNEWLINE " , optimalStrategyOfGame ( arr1 , n ) ) ; int arr2 [ ] = { 2 , 2 , 2 , 2 } ; n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printf ( " % d STRNEWLINE " , optimalStrategyOfGame ( arr2 , n ) ) ; int arr3 [ ] = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; printf ( " % d STRNEWLINE " , optimalStrategyOfGame ( arr3 , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int func ( int idx , int cur , int a [ ] , int dp [ N ] [ 3 ] , int n , int x ) { if ( idx == n ) return 0 ; if ( dp [ idx ] [ cur ] != -1 ) return dp [ idx ] [ cur ] ; int ans = 0 ; if ( cur == 0 ) { ans = max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) ; ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) ; } else if ( cur == 1 ) { ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) ; ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) ; } else ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) ; return dp [ idx ] [ cur ] = ans ; } int getMaximumSum ( int a [ ] , int n , int x ) { int dp [ n ] [ 3 ] ; memset ( dp , -1 , sizeof dp ) ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxi = max ( maxi , func ( i , 0 , a , dp , n , x ) ) ; return maxi ; } int main ( ) { int a [ ] = { -3 , 8 , -2 , 1 , -6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int x = -1 ; cout << getMaximumSum ( a , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100 NEW_LINE void pre_process ( bool dp [ N ] [ N ] , string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = false ; } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = true ; } else if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } } int countPairs ( string s ) { bool dp [ N ] [ N ] ; pre_process ( dp , s ) ; int n = s . length ( ) ; int left [ n ] ; memset ( left , 0 , sizeof left ) ; int right [ n ] ; memset ( right , 0 , sizeof right ) ; left [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( dp [ j ] [ i ] == 1 ) left [ i ] ++ ; } } right [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] ; for ( int j = n - 1 ; j >= i ; j -- ) { if ( dp [ i ] [ j ] == 1 ) right [ i ] ++ ; } } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans += left [ i ] * right [ i + 1 ] ; return ans ; } int main ( ) { string s = " abacaba " ; cout << countPairs ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100 NEW_LINE void pre_process ( bool dp [ N ] [ N ] , string s ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = false ; } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = true ; } else if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } } void answerQuery ( int l , int r , bool dp [ N ] [ N ] ) { if ( dp [ l ] [ r ] ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; } int main ( ) { string s = " abaaab " ; bool dp [ N ] [ N ] ; pre_process ( dp , s ) ; int queries [ ] [ 2 ] = { { 0 , 1 } , { 1 , 5 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) answerQuery ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , dp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string & s ) { int n = s . length ( ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( s [ i ] == '1' && s [ i - 1 ] == '1' && s [ i - 2 ] == '1' ) return 1 ; } return 0 ; } int countStr ( int i , string & s ) { if ( i < 0 ) { if ( check ( s ) ) return 1 ; return 0 ; } s [ i ] = '0' ; int ans = countStr ( i - 1 , s ) ; s [ i ] = '1' ; ans += countStr ( i - 1 , s ) ; s [ i ] = '0' ; return ans ; } int main ( ) { int N = 4 ; string s ( N , '0' ) ; cout << countStr ( N - 1 , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int n ) { int dp [ n + 1 ] ; dp [ 1 ] = 1 ; dp [ 0 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( 4 * ( i * i ) ) - 6 * ( i - 1 ) + dp [ i - 2 ] ; } return dp [ n ] ; } int main ( ) { int n = 4 ; cout << findSum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define n  3 NEW_LINE #define MAX  30 NEW_LINE int dp [ n ] [ n ] [ MAX ] ; bool v [ n ] [ n ] [ MAX ] ; int findCount ( int mat [ ] [ n ] , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int m = 5 ; cout << findCount ( mat , n - 1 , n - 1 , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE #define RUNMAX  300 NEW_LINE #define BALLMAX  50 NEW_LINE #define WICKETMAX  10 NEW_LINE int CountWays ( int r , int b , int l , int R , int B , int W , int dp [ RUNMAX ] [ BALLMAX ] [ WICKETMAX ] ) { if ( l > W ) return 0 ; if ( r > R ) return 0 ; if ( b == B && r == R ) return 1 ; if ( b == B ) return 0 ; if ( dp [ r ] [ b ] [ l ] != -1 ) return dp [ r ] [ b ] [ l ] ; int ans = 0 ; ans += CountWays ( r , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 1 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 2 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 3 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 4 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r + 6 , b + 1 , l , R , B , W , dp ) ; ans = ans % mod ; ans += CountWays ( r , b + 1 , l + 1 , R , B , W , dp ) ; ans = ans % mod ; return dp [ r ] [ b ] [ l ] = ans ; } int main ( ) { int R = 40 , B = 10 , W = 4 ; int dp [ RUNMAX ] [ BALLMAX ] [ WICKETMAX ] ; memset ( dp , -1 , sizeof dp ) ; cout << CountWays ( 0 , 0 , 0 , R , B , W , dp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 3 ; int FindMaximumSum ( int ind , int kon , int a [ ] , int b [ ] , int c [ ] , int n , int dp [ ] [ N ] ) { if ( ind == n ) return 0 ; if ( dp [ ind ] [ kon ] != -1 ) return dp [ ind ] [ kon ] ; int ans = -1e9 + 5 ; if ( kon == 0 ) { ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 1 ) { ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; ans = max ( ans , c [ ind ] + FindMaximumSum ( ind + 1 , 2 , a , b , c , n , dp ) ) ; } else if ( kon == 2 ) { ans = max ( ans , a [ ind ] + FindMaximumSum ( ind + 1 , 1 , a , b , c , n , dp ) ) ; ans = max ( ans , b [ ind ] + FindMaximumSum ( ind + 1 , 0 , a , b , c , n , dp ) ) ; } return dp [ ind ] [ kon ] = ans ; } int main ( ) { int a [ ] = { 6 , 8 , 2 , 7 , 4 , 2 , 7 } ; int b [ ] = { 7 , 8 , 5 , 8 , 6 , 3 , 5 } ; int c [ ] = { 8 , 3 , 2 , 6 , 8 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int dp [ n ] [ N ] ; memset ( dp , -1 , sizeof dp ) ; int x = FindMaximumSum ( 0 , 0 , a , b , c , n , dp ) ; int y = FindMaximumSum ( 0 , 1 , a , b , c , n , dp ) ; int z = FindMaximumSum ( 0 , 2 , a , b , c , n , dp ) ; cout << max ( x , max ( y , z ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 10 ; int findMinimumDeletion ( int l , int r , int dp [ N ] [ N ] , string s ) { if ( l > r ) return 0 ; if ( l == r ) return 1 ; if ( dp [ l ] [ r ] != -1 ) return dp [ l ] [ r ] ; int res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) ; for ( int i = l + 1 ; i <= r ; ++ i ) { if ( s [ l ] == s [ i ] ) res = min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) ; } return dp [ l ] [ r ] = res ; } int main ( ) { string s = " abcddcba " ; int n = s . length ( ) ; int dp [ N ] [ N ] ; memset ( dp , -1 , sizeof dp ) ; cout << findMinimumDeletion ( 0 , n - 1 , dp , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int noOfBinaryStrings ( int N , int k ) { int dp [ 100002 ] ; for ( int i = 1 ; i <= k - 1 ; i ++ ) { dp [ i ] = 1 ; } dp [ k ] = 2 ; for ( int i = k + 1 ; i <= N ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] + dp [ i - k ] ) % mod ; } return dp [ N ] ; } int main ( ) { int N = 4 ; int K = 2 ; cout << noOfBinaryStrings ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWaysToPair ( int p ) { int dp [ p + 1 ] ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= p ; i ++ ) { dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ p ] ; } int main ( ) { int p = 3 ; cout << findWaysToPair ( p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int C [ 1000 ] [ 1000 ] ; void binomialCoeff ( int n ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } int numberOfWays ( int x , int y , int z ) { binomialCoeff ( max ( x , max ( y , z ) ) ) ; int sum = 0 ; for ( int i = 1 ; i <= z ; i ++ ) { sum = ( sum + C [ z ] [ i ] ) ; } int sum1 = 0 ; for ( int i = 1 ; i <= y ; i ++ ) { for ( int j = i + 1 ; j <= x ; j ++ ) { sum1 = ( sum1 + ( C [ y ] [ i ] * C [ x ] [ j ] ) ) ; } } sum1 = ( sum * sum1 ) ; return sum1 ; } int main ( ) { int x = 3 ; int y = 2 ; int z = 1 ; cout << numberOfWays ( x , y , z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCost ( string str , int arr [ ] , int n ) { long long costofC = 0 , costofO = 0 , costofD = 0 , costofE = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' c ' ) costofC += arr [ i ] ; else if ( str [ i ] == ' o ' ) costofO = min ( costofC , costofO + arr [ i ] ) ; else if ( str [ i ] == ' d ' ) costofD = min ( costofO , costofD + arr [ i ] ) ; else if ( str [ i ] == ' e ' ) costofE = min ( costofD , costofE + arr [ i ] ) ; } return costofE ; } int main ( ) { string str = " geekcodergeeks " ; int arr [ ] = { 1 , 2 , 1 , 3 , 4 , 2 , 6 , 4 , 6 , 2 , 3 , 3 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findCost ( str , arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubsequence ( int arr [ ] , int n ) { int len = 1 ; int tmp ; int i , j , d ; int dp [ n ] [ 10 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int cnt [ 10 ] ; int locMax ; tmp = arr [ 0 ] ; while ( tmp > 0 ) { dp [ 0 ] [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; locMax = 1 ; memset ( cnt , 0 , sizeof ( cnt ) ) ; while ( tmp > 0 ) { cnt [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] ) { dp [ i ] [ d ] = 1 ; for ( j = 0 ; j < i ; j ++ ) { dp [ i ] [ d ] = max ( dp [ i ] [ d ] , dp [ j ] [ d ] + 1 ) ; locMax = max ( dp [ i ] [ d ] , locMax ) ; } } } for ( d = 0 ; d <= 9 ; d ++ ) { if ( cnt [ d ] ) { dp [ i ] [ d ] = locMax ; } } len = max ( len , locMax ) ; } return len ; } int main ( ) { int arr [ ] = { 1 , 12 , 44 , 29 , 33 , 96 , 89 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSubsequence ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 18 ; int a , b , dp [ M ] [ 90 ] [ 90 ] [ 2 ] ; int prime [ ] = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 } ; int count ( int pos , int even , int odd , int tight , vector < int > num ) { if ( pos == num . size ( ) ) { if ( num . size ( ) & 1 ) swap ( odd , even ) ; int d = even - odd ; for ( int i = 0 ; i < 24 ; i ++ ) if ( d == prime [ i ] ) return 1 ; return 0 ; } if ( dp [ pos ] [ even ] [ odd ] [ tight ] != -1 ) return dp [ pos ] [ even ] [ odd ] [ tight ] ; int ans = 0 ; int limit = ( tight ? 9 : num [ pos ] ) ; for ( int d = 0 ; d <= limit ; d ++ ) { int currF = tight , currEven = even ; int currOdd = odd ; if ( d < num [ pos ] ) currF = 1 ; if ( pos & 1 ) currOdd += d ; else currEven += d ; ans += count ( pos + 1 , currEven , currOdd , currF , num ) ; } return dp [ pos ] [ even ] [ odd ] [ tight ] = ans ; } int solve ( int x ) { vector < int > num ; while ( x ) { num . push_back ( x % 10 ) ; x /= 10 ; } reverse ( num . begin ( ) , num . end ( ) ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return count ( 0 , 0 , 0 , 0 , num ) ; } int main ( ) { int L = 1 , R = 50 ; cout << solve ( R ) - solve ( L - 1 ) << endl ; L = 50 , R = 100 ; cout << solve ( R ) - solve ( L - 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5005 NEW_LINE int n , k ; vector < int > gr [ N ] ; int d [ N ] [ 505 ] ; int ans = 0 ; void Add_edge ( int x , int y ) { gr [ x ] . push_back ( y ) ; gr [ y ] . push_back ( x ) ; } void dfs ( int v , int par ) { d [ v ] [ 0 ] = 1 ; for ( auto i : gr [ v ] ) { if ( i != par ) { dfs ( i , v ) ; for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] ; for ( int j = 1 ; j <= k ; j ++ ) d [ v ] [ j ] += d [ i ] [ j - 1 ] ; } } } int main ( ) { n = 5 , k = 2 ; Add_edge ( 1 , 2 ) ; Add_edge ( 2 , 3 ) ; Add_edge ( 3 , 4 ) ; Add_edge ( 2 , 5 ) ; dfs ( 1 , 0 ) ; cout << ans ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; int findXorSum ( int arr [ ] , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { int c_odd = 0 ; bool odd = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) odd = ( ! odd ) ; if ( odd ) c_odd ++ ; } for ( int j = 0 ; j < n ; j ++ ) { sum += ( mul * c_odd ) ; if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) c_odd = ( n - j - c_odd ) ; } mul *= 2 ; } return sum ; } int main ( ) { int arr [ ] = { 3 , 8 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findXorSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int charVal ( string s , int i ) { if ( s [ i ] == '0' ) return 0 ; else if ( s [ i ] == '1' ) return 1 ; else return 2 ; } int countMinimalReplacements ( string s , int i , int prev , int dp [ ] [ 3 ] , int n ) { if ( i == n ) { return 0 ; } if ( dp [ i ] [ prev ] != -1 ) return dp [ i ] [ prev ] ; int val = charVal ( s , i ) ; int ans = INT_MAX ; if ( val == prev ) { int val = 0 ; for ( int cur = 0 ; cur <= 2 ; cur ++ ) { if ( cur == prev ) continue ; val = 1 + countMinimalReplacements ( s , i + 1 , cur , dp , n ) ; ans = min ( ans , val ) ; } } ans = countMinimalReplacements ( s , i + 1 , val , dp , n ) ; return dp [ i ] [ val ] = ans ; } int main ( ) { string s = "201220211" ; int n = s . length ( ) ; int dp [ n ] [ 3 ] ; memset ( dp , -1 , sizeof dp ) ; int val = charVal ( s , 0 ) ; cout << countMinimalReplacements ( s , 1 , val , dp , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX  50 NEW_LINE bool hasPath ( int maze [ ] [ MAX ] , int sol [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) sol [ i ] [ j ] = 0 ; bool * * CRF = new bool * [ N ] ; for ( int i = 0 ; i < N ; i ++ ) CRF [ i ] = new bool [ N ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) CRF [ i ] [ j ] = false ; CRF [ N - 1 ] [ N - 1 ] = true ; for ( int k = N - 1 ; k >= 0 ; k -- ) { for ( int j = k ; j >= 0 ; j -- ) { if ( ! ( k == N - 1 && j == N - 1 ) ) { for ( int a = 0 ; a <= maze [ k ] [ j ] ; a ++ ) { if ( ( j + a < N && CRF [ k ] [ j + a ] == true ) || ( k + a < N && CRF [ k + a ] [ j ] == true ) ) { CRF [ k ] [ j ] = true ; break ; } } for ( int a = 0 ; a <= maze [ j ] [ k ] ; a ++ ) { if ( ( k + a < N && CRF [ j ] [ k + a ] == true ) || ( j + a < N && CRF [ j + a ] [ k ] == true ) ) { CRF [ j ] [ k ] = true ; break ; } } } } } if ( CRF [ 0 ] [ 0 ] == false ) return false ; int i = 0 , j = 0 ; while ( ! ( i == N - 1 && j == N - 1 ) ) { sol [ i ] [ j ] = 1 ; if ( maze [ i ] [ j ] > 0 ) for ( int a = 1 ; a <= maze [ i ] [ j ] ; a ++ ) { if ( ( j + a < N && CRF [ i ] [ j + a ] == true ) ) { j = j + a ; break ; } else if ( ( i + a < N && CRF [ i + a ] [ j ] == true ) ) { i = i + a ; break ; } } } sol [ N - 1 ] [ N - 1 ] = 1 ; return true ; } void printMatrix ( int sol [ ] [ MAX ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << sol [ i ] [ j ] << " ▁ " ; cout << " STRNEWLINE " ; } } int main ( ) { int maze [ ] [ MAX ] = { { 2 , 2 , 1 , 1 , 0 } , { 0 , 0 , 3 , 0 , 0 } , { 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 2 , 0 , 1 } , { 0 , 0 , 3 , 0 , 0 } } ; int N = sizeof ( maze ) / sizeof ( maze [ 0 ] ) ; int sol [ N ] [ MAX ] ; if ( hasPath ( maze , sol , N ) ) printMatrix ( sol , N ) ; else cout << " No ▁ path ▁ exists " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define n  4 NEW_LINE #define m  4 NEW_LINE using namespace std ; float calcProbability ( int M [ ] [ m ] , int k ) { float dp [ m ] [ n ] , sum [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { dp [ 0 ] [ j ] = M [ 0 ] [ j ] ; sum [ 0 ] += dp [ 0 ] [ j ] ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] / sum [ i - 1 ] + M [ i ] [ j ] ; sum [ i ] += dp [ i ] [ j ] ; } } return dp [ n - 1 ] [ k - 1 ] / sum [ n - 1 ] ; } int main ( ) { int M [ m ] [ n ] = { { 1 , 1 , 0 , 3 } , { 2 , 3 , 2 , 3 } , { 9 , 3 , 0 , 2 } , { 2 , 3 , 2 , 2 } } ; int k = 3 ; cout << calcProbability ( M , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumNumbers ( string s ) { int n = s . length ( ) ; vector < int > remIndex ( 3 , -1 ) ; remIndex [ 0 ] = 0 ; vector < int > res ( n + 1 ) ; int r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { r = ( r + s [ i - 1 ] - '0' ) % 3 ; res [ i ] = res [ i - 1 ] ; if ( remIndex [ r ] != -1 ) res [ i ] = max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) ; remIndex [ r ] = i + 1 ; } return res [ n ] ; } int main ( ) { string s = "12345" ; cout << MaximumNumbers ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INF  99999 NEW_LINE #define size  10 NEW_LINE int findMinimumSteps ( int mat [ size ] [ size ] , int x , int y , int n ) { int dist [ n ] [ n ] , i , j , k ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 0 ) dist [ i ] [ j ] = INF ; else dist [ i ] [ j ] = 1 ; if ( i == j ) dist [ i ] [ j ] = 1 ; } } for ( k = 0 ; k < n ; k ++ ) { for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } if ( dist [ x ] [ y ] < INF ) return dist [ x ] [ y ] ; else return -1 ; } int main ( ) { int mat [ size ] [ size ] = { { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 } } ; int x = 2 , y = 3 ; cout << findMinimumSteps ( mat , x , y , size ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define max  4 NEW_LINE #define c  2 NEW_LINE int countPaths ( int sum , int get , int m , int n , int dp [ ] ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != -1 ) return dp [ sum ] [ get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; } int main ( ) { int n = 3 , m = 2 , x = 3 ; int dp [ max + 1 ] ; for ( int i = 0 ; i <= max ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = -1 ; cout << countPaths ( x , 0 , m , n , dp ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_K = 15 ; long long unsigned int fac [ MAX_K ] ; void factorial ( int k ) { fac [ 0 ] = 1 ; for ( int i = 1 ; i <= k + 1 ; i ++ ) { fac [ i ] = ( i * fac [ i - 1 ] ) ; } } long long unsigned int bin ( int a , int b ) { long long unsigned int ans = ( ( fac [ a ] ) / ( fac [ a - b ] * fac [ b ] ) ) ; return ans ; } long int sumofn ( int n , int k ) { int p = 0 ; long long unsigned int num1 , temp , arr [ 1000 ] ; for ( int j = 1 ; j <= k ; j ++ ) { if ( j == 1 ) { num1 = ( n * ( n + 1 ) ) / 2 ; arr [ p ++ ] = num1 ; temp = num1 ; } else { temp = ( pow ( n + 1 , j + 1 ) - 1 - n ) ; for ( int s = 1 ; s < j ; s ++ ) { temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) ; } temp = temp / ( j + 1 ) ; arr [ p ++ ] = temp ; } } temp = arr [ p - 1 ] ; return temp ; } int main ( ) { int n = 5 , k = 2 ; factorial ( k ) ; cout << sumofn ( n , k ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define max  4 NEW_LINE int countWays ( int index , int cnt , int dp [ ] [ max ] , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != -1 ) return dp [ index ] [ cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; } int main ( ) { int n = 3 , m = 3 , k = 2 ; int dp [ n + 1 ] [ max ] ; memset ( dp , -1 , sizeof dp ) ; cout << m * countWays ( 1 , 0 , dp , n , m , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int waysToKAdjacentSetBits ( int n , int k , int currentIndex , int adjacentSetBits , int lastBit ) { if ( currentIndex == n ) { if ( adjacentSetBits == k ) return 1 ; return 0 ; } int noOfWays = 0 ; if ( lastBit == 1 ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits + 1 , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } else if ( ! lastBit ) { noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 1 ) ; noOfWays += waysToKAdjacentSetBits ( n , k , currentIndex + 1 , adjacentSetBits , 0 ) ; } return noOfWays ; } int main ( ) { int n = 5 , k = 2 ; int totalWays = waysToKAdjacentSetBits ( n , k , 1 , 0 , 1 ) + waysToKAdjacentSetBits ( n , k , 1 , 0 , 0 ) ; cout << " Number ▁ of ▁ ways ▁ = ▁ " << totalWays << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int lli ; const int MAX = 300 ; int checkFunc ( int i , int j , string st ) { if ( st [ i ] == ' ( ' && st [ j ] == ' ) ' ) return 1 ; if ( st [ i ] == ' ( ' && st [ j ] == ' ? ' ) return 1 ; if ( st [ i ] == ' ? ' && st [ j ] == ' ) ' ) return 1 ; if ( st [ i ] == ' [ ' && st [ j ] == ' ] ' ) return 1 ; if ( st [ i ] == ' [ ' && st [ j ] == ' ? ' ) return 1 ; if ( st [ i ] == ' ? ' && st [ j ] == ' ] ' ) return 1 ; if ( st [ i ] == ' { ' && st [ j ] == ' } ' ) return 1 ; if ( st [ i ] == ' { ' && st [ j ] == ' ? ' ) return 1 ; if ( st [ i ] == ' ? ' && st [ j ] == ' } ' ) return 1 ; return 0 ; } int countRec ( int start , int end , int dp [ ] [ MAX ] , string st ) { int sum = 0 ; if ( start > end ) return 1 ; if ( dp [ start ] [ end ] != -1 ) return dp [ start ] [ end ] ; lli i , r = 0 ; for ( i = start + 1 ; i <= end ; i += 2 ) { if ( checkFunc ( start , i , st ) ) { sum = sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) ; } else if ( st [ start ] == ' ? ' && st [ i ] == ' ? ' ) { sum = sum + countRec ( start + 1 , i - 1 , dp , st ) * countRec ( i + 1 , end , dp , st ) * 3 ; } } return dp [ start ] [ end ] = sum ; } int countWays ( string st ) { int n = st . length ( ) ; if ( n % 2 == 1 ) return 0 ; int dp [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof ( dp ) ) ; return countRec ( 0 , n - 1 , dp , st ) ; } int main ( ) { string st = " ( ? ( [ ? ) ] ? } ? " ; cout << countWays ( st ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 64 ] [ 64 ] [ 64 ] [ 2 ] ; int func ( int third , int seta , int setb , int carry , int number ) { if ( dp [ third ] [ seta ] [ setb ] [ carry ] != -1 ) return dp [ third ] [ seta ] [ setb ] [ carry ] ; int shift = ( number >> third ) ; if ( shift == 0 and seta == 0 and setb == 0 and carry == 0 ) return 1 ; if ( shift == 0 or seta < 0 or setb < 0 ) return 0 ; int mask = shift & 1 ; dp [ third ] [ seta ] [ setb ] [ carry ] = 0 ; if ( ( mask ) && carry ) { dp [ third ] [ seta ] [ setb ] [ carry ] += func ( third + 1 , seta , setb , 0 , number ) + func ( third + 1 , seta - 1 , setb - 1 , 1 , number ) ; } else if ( mask && ! carry ) { dp [ third ] [ seta ] [ setb ] [ carry ] += func ( third + 1 , seta - 1 , setb , 0 , number ) + func ( third + 1 , seta , setb - 1 , 0 , number ) ; } else if ( ! mask && carry ) { dp [ third ] [ seta ] [ setb ] [ carry ] += func ( third + 1 , seta - 1 , setb , 1 , number ) + func ( third + 1 , seta , setb - 1 , 1 , number ) ; } else if ( ! mask && ! carry ) { dp [ third ] [ seta ] [ setb ] [ carry ] += func ( third + 1 , seta , setb , 0 , number ) + func ( third + 1 , seta - 1 , setb - 1 , 1 , number ) ; } return dp [ third ] [ seta ] [ setb ] [ carry ] ; } int possibleSwaps ( int a , int b , int c ) { memset ( dp , -1 , sizeof ( dp ) ) ; int ans = func ( 0 , a , b , 0 , c ) ; return ans ; } int main ( ) { int x = 2 , y = 2 , c = 20 ; cout << possibleSwaps ( x , y , c ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int CountWays ( int n ) { if ( n == 0 ) { return 1 ; } if ( n == 1 ) { return 1 ; } if ( n == 2 ) { return 1 + 1 ; } return CountWays ( n - 1 ) + CountWays ( n - 3 ) ; } int main ( ) { int n = 10 ; cout << CountWays ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ 2 * n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; } int main ( ) { int n = 8 ; cout << " Even ▁ indexed ▁ Fibonacci ▁ Sum ▁ upto ▁ " << n << " ▁ terms : ▁ " << calculateEvenSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ; int f [ MAX ] = { 0 } ; int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] ) return f [ n ] ; int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } int calculateEvenSum ( int n ) { return ( fib ( 2 * n + 1 ) - 1 ) ; } int main ( ) { int n = 8 ; cout << " Even ▁ indexed ▁ Fibonacci ▁ Sum ▁ upto ▁ " << n << " ▁ terms : ▁ " << calculateEvenSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  32768 NEW_LINE int arr [ 2 * MAX ] ; int gouldSequence ( ) { arr [ 0 ] = 1 ; int i = 1 ; int p = 1 ; while ( i <= MAX ) { int j = 0 ; while ( j < i ) { arr [ i + j ] = 2 * arr [ j ] ; j ++ ; } i = ( 1 << p ) ; p ++ ; } } void printSequence ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } int main ( ) { gouldSequence ( ) ; int n = 16 ; printSequence ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; } int countWays ( int m , int n ) { m = m - 1 ; n = n - 1 ; return factorial ( m + n ) / ( factorial ( m ) * factorial ( n ) ) ; } int main ( ) { int m = 5 ; int n = 5 ; int result = countWays ( m , n ) ; cout << result ; }
#include <iostream> NEW_LINE using namespace std ; int MatrixChainOrder ( int p [ ] , int n ) { int dp [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 40 , 30 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ % d ▁ " , MatrixChainOrder ( arr , size ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CommomSubsequencesCount ( string s , string t ) { int n1 = s . length ( ) ; int n2 = t . length ( ) ; int dp [ n1 + 1 ] [ n2 + 1 ] ; for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= n1 ; i ++ ) { for ( int j = 1 ; j <= n2 ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] ; } } return dp [ n1 ] [ n2 ] ; } int main ( ) { string s = " ajblqcpdz " ; string t = " aefcnbtdi " ; cout << CommomSubsequencesCount ( s , t ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int createPalindrome ( int input , bool isOdd ) { int n = input ; int palin = input ; if ( isOdd ) n /= 10 ; while ( n > 0 ) { palin = palin * 10 + ( n % 10 ) ; n /= 10 ; } return palin ; } vector < int > generatePalindromes ( int N ) { vector < int > palindromes ; int number ; for ( int j = 0 ; j < 2 ; j ++ ) { int i = 1 ; while ( ( number = createPalindrome ( i ++ , j ) ) <= N ) palindromes . push_back ( number ) ; } return palindromes ; } int minimumNoOfPalindromes ( int N ) { string a , b = a = to_string ( N ) ; reverse ( b . begin ( ) , b . end ( ) ) ; if ( a == b ) return 1 ; vector < int > palindromes = generatePalindromes ( N ) ; sort ( palindromes . begin ( ) , palindromes . end ( ) ) ; int l = 0 , r = palindromes . size ( ) - 1 ; while ( l < r ) { if ( palindromes [ l ] + palindromes [ r ] == N ) return 2 ; else if ( palindromes [ l ] + palindromes [ r ] < N ) ++ l ; else -- r ; } return 3 ; } int main ( ) { int N = 65 ; cout << minimumNoOfPalindromes ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int ll ; int lcs ( int dp [ 101 ] [ 101 ] , string a , string b , int m , int n ) { for ( int i = 0 ; i < 100 ; i ++ ) for ( int j = 0 ; j < 100 ; j ++ ) dp [ i ] [ j ] = -1 ; if ( m < 0 n < 0 ) { return 0 ; } if ( dp [ m ] [ n ] != -1 ) return dp [ m ] [ n ] ; int ans = 0 ; if ( a [ m ] == b [ n ] ) { ans = int ( a [ m ] - 48 ) + lcs ( dp , a , b , m - 1 , n - 1 ) ; } else ans = max ( lcs ( dp , a , b , m - 1 , n ) , lcs ( dp , a , b , m , n - 1 ) ) ; dp [ m ] [ n ] = ans ; return ans ; } int costOfString ( string str ) { int cost = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) cost += int ( str [ i ] - 48 ) ; return cost ; } int main ( ) { string a , b ; a = "9142" ; b = "1429" ; int dp [ 101 ] [ 101 ] ; cout << ( costOfString ( a ) + costOfString ( b ) - 2 * lcs ( dp , a , b , a . length ( ) - 1 , b . length ( ) - 1 ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; bool sumEqualToK ( int arr [ ] , int & start , int & end , int n , int k ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == k ) { maxLen = i + 1 ; start = 0 ; end = i ; } if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - k ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - k ] ) ) { maxLen = i - um [ sum - k ] ; start = um [ sum - k ] + 1 ; end = i ; } } } return ( maxLen != 0 ) ; } void sumZeroMatrix ( int mat [ ] [ MAX ] , int row , int col , int k ) { int temp [ row ] , area ; bool sum ; int up , down ; int fup = 0 , fdown = 0 , fleft = 0 , fright = 0 ; int maxArea = INT_MIN ; for ( int left = 0 ; left < col ; left ++ ) { memset ( temp , 0 , sizeof ( temp ) ) ; for ( int right = left ; right < col ; right ++ ) { for ( int i = 0 ; i < row ; i ++ ) temp [ i ] += mat [ i ] [ right ] ; sum = sumEqualToK ( temp , up , down , row , k ) ; area = ( down - up + 1 ) * ( right - left + 1 ) ; if ( sum && maxArea < area ) { fup = up ; fdown = down ; fleft = left ; fright = right ; maxArea = area ; } } } if ( fup == 0 && fdown == 0 && fleft == 0 && fright == 0 && mat [ 0 ] [ 0 ] != k ) { cout << " No ▁ sub - matrix ▁ with ▁ sum ▁ " << k << " ▁ exists " ; return ; } cout << " ( Top , ▁ Left ) : ▁ " << " ( " << fup << " , ▁ " << fleft << " ) " << endl ; cout << " ( Bottom , ▁ Right ) : ▁ " << " ( " << fdown << " , ▁ " << fright << " ) " << endl ; for ( int j = fup ; j <= fdown ; j ++ ) { for ( int i = fleft ; i <= fright ; i ++ ) cout << mat [ j ] [ i ] << " ▁ " ; cout << endl ; } } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 7 , -6 , 5 } , { -8 , 6 , 7 , -2 } , { 10 , -15 , 3 , 2 } , { -5 , 2 , 0 , 9 } } ; int row = 4 , col = 4 ; int k = 7 ; sumZeroMatrix ( mat , row , col , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countPartitions ( int n , int k ) { long long int dp [ 201 ] [ 201 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = -1 ; } } if ( dp [ n ] [ k ] >= 0 ) return dp [ n ] [ k ] ; if ( n < k ) return 0 ; if ( n < 2 * k ) return 1 ; long long int answer = 1 ; for ( int i = k ; i < n ; i ++ ) answer = answer + countPartitions ( n - i , i ) ; dp [ n ] [ k ] = answer ; return answer ; } int main ( ) { int n = 10 , k = 3 ; cout << " Total ▁ Aggregate ▁ sum ▁ of ▁ all ▁ Valid ▁ Partitions : ▁ " << countPartitions ( n , k ) * n ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll recursive ( ll idx , ll sum , ll tight , string st , ll dp [ 20 ] [ 2 ] [ 166 ] , ll num ) { if ( idx == num ) return sum == 0 ; if ( dp [ idx ] [ tight ] [ sum ] != -1 ) return dp [ idx ] [ tight ] [ sum ] ; bool newTight ; ll ans = 0 ; ll d ; for ( d = 0 ; d < 10 ; ++ d ) { newTight = false ; if ( tight && st [ idx ] - '0' < d ) continue ; if ( tight && st [ idx ] - '0' == d ) newTight = true ; if ( sum >= d ) ans += recursive ( idx + 1 , sum - d , newTight , st , dp , num ) ; } return dp [ idx ] [ tight ] [ sum ] = ans ; } vector < ll > formArray ( ll N ) { ll dp [ 20 ] [ 2 ] [ 166 ] ; memset ( dp , -1 , sizeof dp ) ; ostringstream x ; x << N ; string st = x . str ( ) ; ll num = st . size ( ) ; vector < ll > arr ; for ( int i = 1 ; i <= 162 ; ++ i ) { arr . push_back ( recursive ( 0 , i , 1 , st , dp , num ) ) ; } return arr ; } ll findPair ( ll a , ll b ) { vector < ll > arr_smaller = formArray ( a - 1 ) ; vector < ll > arr_greater = formArray ( b ) ; for ( int i = 0 ; i < arr_greater . size ( ) ; ++ i ) arr_greater [ i ] -= arr_smaller [ i ] ; int ans = 0 ; for ( int i = 1 ; i <= 162 ; ++ i ) { for ( int j = i + 1 ; j <= 162 ; ++ j ) { if ( __gcd ( i , j ) == 1 ) ans = ( ans + arr_greater [ i - 1 ] * arr_greater [ j - 1 ] ) ; } } return ans ; } int main ( ) { ll a = 12 , b = 15 ; cout << findPair ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > factors ( int n ) { vector < int > v ; v . push_back ( 1 ) ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v . push_back ( i ) ; if ( n / i != i ) { v . push_back ( n / i ) ; } } } return v ; } bool checkAbundant ( int n ) { vector < int > v ; int sum = 0 ; v = factors ( n ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { sum += v [ i ] ; } if ( sum > n ) return true ; else return false ; } bool checkSemiPerfect ( int n ) { vector < int > v ; v = factors ( n ) ; sort ( v . begin ( ) , v . end ( ) ) ; int r = v . size ( ) ; bool subset [ r + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j < v [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v [ i - 1 ] ] ; } } } if ( ( subset [ r ] [ n ] ) == 0 ) return false ; else return true ; } bool checkweird ( int n ) { if ( checkAbundant ( n ) == true && checkSemiPerfect ( n ) == false ) return true ; else return false ; } int main ( ) { int n = 70 ; if ( checkweird ( n ) ) cout << " Weird ▁ Number " ; else cout << " Not ▁ Weird ▁ Number " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > factors ( int n ) { vector < int > v ; v . push_back ( 1 ) ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v . push_back ( i ) ; if ( n / i != i ) { v . push_back ( n / i ) ; } } } return v ; } bool check ( int n ) { vector < int > v ; v = factors ( n ) ; sort ( v . begin ( ) , v . end ( ) ) ; int r = v . size ( ) ; bool subset [ r + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= r ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j < v [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; else { subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - v [ i - 1 ] ] ; } } } if ( ( subset [ r ] [ n ] ) == 0 ) return false ; else return true ; } int main ( ) { int n = 40 ; if ( check ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fib [ 43 ] = { 0 } ; void fibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i < 43 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } int rec ( int x , int y , int last ) { if ( y == 0 ) { if ( x == 0 ) return 1 ; return 0 ; } int sum = 0 ; for ( int i = last ; i >= 0 and fib [ i ] * y >= x ; i -- ) { if ( fib [ i ] > x ) continue ; sum += rec ( x - fib [ i ] , y - 1 , i ) ; } return sum ; } int main ( ) { fibonacci ( ) ; int n = 13 , k = 3 ; cout << " Possible ▁ ways ▁ are : ▁ " << rec ( n , k , 42 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCost ( int cost [ ] , int n ) { int dp [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; } int main ( ) { int a [ ] = { 16 , 19 , 10 , 12 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minimumCost ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return min ( dp1 , dp2 ) ; } int main ( ) { int a [ ] = { 2 , 5 , 3 , 1 , 7 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minimumCost ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int size = 1000 ; int maxCost ( int a [ ] [ size ] , int m , int n , int dp [ ] [ size ] ) { if ( n < 0 m < 0 ) return -1e9 ; else if ( m == 0 && n == 0 ) return 0 ; else if ( dp [ m ] [ n ] != -1 ) return dp [ m ] [ n ] ; else { int num = m + n ; if ( ( num & ( num - 1 ) ) == 0 ) return dp [ m ] [ n ] = a [ m ] [ n ] + maxCost ( a , m - 1 , n - 1 , dp ) ; else return dp [ m ] [ n ] = ( a [ m ] [ n ] + max ( maxCost ( a , m - 1 , n , dp ) , maxCost ( a , m , n - 1 , dp ) ) ) ; } } int answer ( int a [ ] [ size ] , int n ) { int dp [ size ] [ size ] ; memset ( dp , -1 , sizeof dp ) ; return maxCost ( a , n - 1 , n - 1 , dp ) ; } int main ( ) { int a [ ] [ size ] = { { 1 , 2 , 3 , 1 } , { 4 , 5 , 6 , 1 } , { 7 , 8 , 9 , 1 } , { 1 , 1 , 1 , 1 } } ; int n = 4 ; cout << answer ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int editDistanceWith2Ops ( string & X , string & Y ) { int m = X . length ( ) , n = Y . length ( ) ; int L [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } int lcs = L [ m ] [ n ] ; return ( m - lcs ) + ( n - lcs ) ; } int main ( ) { string X = " abc " , Y = " acd " ; cout << editDistanceWith2Ops ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcs ( string X , string Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } int main ( ) { string X = " AGGTAB " ; string Y = " GXTXAYB " ; int m = X . length ( ) ; int n = Y . length ( ) ; cout << " Length ▁ of ▁ LCS : ▁ " << lcs ( X , Y , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; } int main ( ) { int n = 3 ; cout << countPaths ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  10 NEW_LINE int lenOfLongSubarr ( int arr [ ] , int n , int & start , int & finish ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == 1 ) { start = 0 ; finish = i ; maxLen = i + 1 ; } else if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - 1 ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) start = um [ sum - 1 ] + 1 ; finish = i ; maxLen = i - um [ sum - 1 ] ; } } return maxLen ; } void largestSubmatrix ( int mat [ SIZE ] [ SIZE ] , int n ) { int finalLeft , finalRight , finalTop , finalBottom ; int temp [ n ] , maxArea = 0 , len , start , finish ; for ( int left = 0 ; left < n ; left ++ ) { memset ( temp , 0 , sizeof ( temp ) ) ; for ( int right = left ; right < n ; right ++ ) { for ( int i = 0 ; i < n ; ++ i ) temp [ i ] += mat [ i ] [ right ] == 0 ? -1 : 1 ; len = lenOfLongSubarr ( temp , n , start , finish ) ; if ( ( len != 0 ) && ( maxArea < ( finish - start + 1 ) * ( right - left + 1 ) ) ) { finalLeft = left ; finalRight = right ; finalTop = start ; finalBottom = finish ; maxArea = ( finish - start + 1 ) * ( right - left + 1 ) ; } } } cout << " ( Top , ▁ Left ) : ▁ ( " << finalTop << " , ▁ " << finalLeft << " ) STRNEWLINE " ; cout << " ( Bottom , ▁ Right ) : ▁ ( " << finalBottom << " , ▁ " << finalRight << " ) STRNEWLINE " ; cout << " Maximum ▁ area : ▁ " << maxArea ; } int main ( ) { int mat [ SIZE ] [ SIZE ] = { { 1 , 0 , 0 , 1 } , { 0 , 1 , 1 , 1 } , { 1 , 0 , 0 , 0 } , { 0 , 1 , 0 , 1 } } ; int n = 4 ; largestSubmatrix ( mat , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 8 ] [ 8 ] = { 0 } ; int getsteps ( int x , int y , int tx , int ty ) { if ( x == tx && y == ty ) return dp [ 0 ] [ 0 ] ; else { if ( dp [ abs ( x - tx ) ] [ abs ( y - ty ) ] != 0 ) return dp [ abs ( x - tx ) ] [ abs ( y - ty ) ] ; else { int x1 , y1 , x2 , y2 ; if ( x <= tx ) { if ( y <= ty ) { x1 = x + 2 ; y1 = y + 1 ; x2 = x + 1 ; y2 = y + 2 ; } else { x1 = x + 2 ; y1 = y - 1 ; x2 = x + 1 ; y2 = y - 2 ; } } else { if ( y <= ty ) { x1 = x - 2 ; y1 = y + 1 ; x2 = x - 1 ; y2 = y + 2 ; } else { x1 = x - 2 ; y1 = y - 1 ; x2 = x - 1 ; y2 = y - 2 ; } } dp [ abs ( x - tx ) ] [ abs ( y - ty ) ] = min ( getsteps ( x1 , y1 , tx , ty ) , getsteps ( x2 , y2 , tx , ty ) ) + 1 ; dp [ abs ( y - ty ) ] [ abs ( x - tx ) ] = dp [ abs ( x - tx ) ] [ abs ( y - ty ) ] ; return dp [ abs ( x - tx ) ] [ abs ( y - ty ) ] ; } } } int main ( ) { int i , n , x , y , tx , ty , ans ; n = 100 ; x = 4 ; y = 5 ; tx = 1 ; ty = 1 ; if ( ( x == 1 && y == 1 && tx == 2 && ty == 2 ) || ( x == 2 && y == 2 && tx == 1 && ty == 1 ) ) ans = 4 ; else if ( ( x == 1 && y == n && tx == 2 && ty == n - 1 ) || ( x == 2 && y == n - 1 && tx == 1 && ty == n ) ) ans = 4 ; else if ( ( x == n && y == 1 && tx == n - 1 && ty == 2 ) || ( x == n - 1 && y == 2 && tx == n && ty == 1 ) ) ans = 4 ; else if ( ( x == n && y == n && tx == n - 1 && ty == n - 1 ) || ( x == n - 1 && y == n - 1 && tx == n && ty == n ) ) ans = 4 ; else { dp [ 1 ] [ 0 ] = 3 ; dp [ 0 ] [ 1 ] = 3 ; dp [ 1 ] [ 1 ] = 2 ; dp [ 2 ] [ 0 ] = 2 ; dp [ 0 ] [ 2 ] = 2 ; dp [ 2 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 1 ; ans = getsteps ( x , y , tx , ty ) ; } cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getMinimumPenalty ( string x , string y , int pxy , int pgap ) { int dp [ m + 1 ] [ n + 1 ] = { 0 } ; for ( i = 0 ; i <= ( n + m ) ; i ++ ) { dp [ i ] [ 0 ] = i * pgap ; dp [ 0 ] [ i ] = i * pgap ; } for ( i = 1 ; i <= m ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = min ( { dp [ i - 1 ] [ j - 1 ] + pxy , dp [ i - 1 ] [ j ] + pgap , dp [ i ] [ j - 1 ] + pgap } ) ; } } } i = m ; j = n ; int xpos = l ; int ypos = l ; int xans [ l + 1 ] , yans [ l + 1 ] ; while ( ! ( i == 0 j == 0 ) ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { xans [ xpos -- ] = ( int ) x [ i - 1 ] ; yans [ ypos -- ] = ( int ) y [ j - 1 ] ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j - 1 ] + pxy == dp [ i ] [ j ] ) { xans [ xpos -- ] = ( int ) x [ i - 1 ] ; yans [ ypos -- ] = ( int ) y [ j - 1 ] ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j ] + pgap == dp [ i ] [ j ] ) { xans [ xpos -- ] = ( int ) x [ i - 1 ] ; yans [ ypos -- ] = ( int ) ' _ ' ; i -- ; } else if ( dp [ i ] [ j - 1 ] + pgap == dp [ i ] [ j ] ) { xans [ xpos -- ] = ( int ) ' _ ' ; yans [ ypos -- ] = ( int ) y [ j - 1 ] ; j -- ; } } while ( xpos > 0 ) { if ( i > 0 ) xans [ xpos -- ] = ( int ) x [ -- i ] ; else xans [ xpos -- ] = ( int ) ' _ ' ; } while ( ypos > 0 ) { if ( j > 0 ) yans [ ypos -- ] = ( int ) y [ -- j ] ; else yans [ ypos -- ] = ( int ) ' _ ' ; } int id = 1 ; for ( i = l ; i >= 1 ; i -- ) { if ( ( char ) yans [ i ] == ' _ ' && ( char ) xans [ i ] == ' _ ' ) { id = i + 1 ; break ; } } cout << " Minimum ▁ Penalty ▁ in ▁ aligning ▁ the ▁ genes ▁ = ▁ " ; cout << dp [ m ] [ n ] << " STRNEWLINE " ; cout << " The ▁ aligned ▁ genes ▁ are ▁ : STRNEWLINE " ; for ( i = id ; i <= l ; i ++ ) { cout << ( char ) xans [ i ] ; } cout << " STRNEWLINE " ; for ( i = id ; i <= l ; i ++ ) { cout << ( char ) yans [ i ] ; } return ; } int main ( ) { string gene1 = " AGGGCT " ; string gene2 = " AGGCA " ; int misMatchPenalty = 3 ; int gapPenalty = 2 ; getMinimumPenalty ( gene1 , gene2 , misMatchPenalty , gapPenalty ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumSubSequence ( vector < int > arr , int len , int m ) { int sum = 0 ; for ( auto x : arr ) sum += x ; vector < vector < int > > dp ( len + 1 , vector < int > ( sum + 1 , 0 ) ) ; for ( int i = 0 ; i <= len ; i ++ ) dp [ i ] [ 0 ] ++ ; for ( int i = 1 ; i <= len ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] ++ ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] > 0 ) { dp [ i ] [ j ] ++ ; dp [ i ] [ j + arr [ i - 1 ] ] ++ ; } } } int count = 0 ; for ( int j = 1 ; j <= sum ; j ++ ) if ( dp [ len ] [ j ] > 0 ) if ( j % m == 0 ) count += dp [ len ] [ j ] ; return count ; } int main ( ) { vector < int > arr { 1 , 2 , 3 } ; int m = 3 ; int len = arr . size ( ) ; cout << sumSubSequence ( arr , len , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lds ( int arr [ ] , int n ) { int lds [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; } int main ( ) { int arr [ ] = { 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Length ▁ of ▁ LDS ▁ is ▁ " << lds ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE void binomialCoeff ( int C [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } } int sumOfproduct ( int n ) { int sum = 0 ; int C [ MAX ] = { 0 } ; binomialCoeff ( C , n ) ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ i ] * C [ i + 1 ] ; return sum ; } int main ( ) { int n = 3 ; cout << sumOfproduct ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE void binomialCoeff ( int n , int C [ ] ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } } int summation ( int n ) { int C [ MAX ] ; memset ( C , 0 , sizeof ( C ) ) ; binomialCoeff ( n , C ) ; int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( i * C [ i ] ) ; return sum ; } int main ( ) { int n = 2 ; cout << summation ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int countArray ( int N , int K ) { return binomialCoeff ( K - 1 , N - 1 ) ; } int main ( ) { int N = 2 , K = 3 ; cout << countArray ( N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100 NEW_LINE int count ( int n , int c , int a [ ] , int b [ ] ) { int need [ N ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i + n ] = a [ i ] ; b [ i + n ] = b [ i ] ; } int s = 0 ; int tank = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { tank += a [ i ] ; tank = min ( tank , c ) ; tank -= b [ i ] ; if ( tank < 0 ) { tank = 0 ; s = i + 1 ; } } if ( s >= n ) return 0 ; int ans = 1 ; need [ s + n ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int id = s + n - i ; need [ id ] = max ( 0 , need [ id + 1 ] + b [ id ] - min ( a [ id ] , c ) ) ; if ( need [ id ] == 0 ) ans ++ ; } return ans ; } int main ( ) { int n = 3 ; int c = 3 ; int a [ 2 * N ] = { 3 , 1 , 2 } ; int b [ 2 * N ] = { 2 , 2 , 2 } ; cout << count ( n , c , a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printEqualSumSets ( int arr [ ] , int n ) { int i , currSum ; int sum = accumulate ( arr , arr + n , 0 ) ; if ( sum & 1 ) { cout << " - 1" ; return ; } int k = sum >> 1 ; bool dp [ n + 1 ] [ k + 1 ] ; for ( i = 1 ; i <= k ; i ++ ) dp [ 0 ] [ i ] = false ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( i = 1 ; i <= n ; i ++ ) { for ( currSum = 1 ; currSum <= k ; currSum ++ ) { dp [ i ] [ currSum ] = dp [ i - 1 ] [ currSum ] ; if ( arr [ i - 1 ] <= currSum ) dp [ i ] [ currSum ] = dp [ i ] [ currSum ] | dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ; } } vector < int > set1 , set2 ; if ( ! dp [ n ] [ k ] ) { cout << " - 1 STRNEWLINE " ; return ; } i = n ; currSum = k ; while ( i > 0 && currSum >= 0 ) { if ( dp [ i - 1 ] [ currSum ] ) { i -- ; set2 . push_back ( arr [ i ] ) ; } else if ( dp [ i - 1 ] [ currSum - arr [ i - 1 ] ] ) { i -- ; currSum -= arr [ i ] ; set1 . push_back ( arr [ i ] ) ; } } cout << " Set ▁ 1 ▁ elements : ▁ " ; for ( i = 0 ; i < set1 . size ( ) ; i ++ ) cout << set1 [ i ] << " ▁ " ; cout << " Set 2 elements : " for ( i = 0 ; i < set2 . size ( ) ; i ++ ) cout << set2 [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 5 , 5 , 1 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printEqualSumSets ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double largestSumOfAverages ( vector < int > & A , int K ) { int n = A . size ( ) ; double pre_sum [ n + 1 ] ; pre_sum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) pre_sum [ i + 1 ] = pre_sum [ i ] + A [ i ] ; double dp [ n ] = { 0 } ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = ( pre_sum [ n ] - pre_sum [ i ] ) / ( n - i ) ; for ( int k = 0 ; k < K - 1 ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) dp [ i ] = max ( dp [ i ] , ( pre_sum [ j ] - pre_sum [ i ] ) / ( j - i ) + dp [ j ] ) ; return dp [ 0 ] ; } int main ( ) { vector < int > A = { 9 , 1 , 2 , 3 , 9 } ; cout << largestSumOfAverages ( A , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  105  NEW_LINE #define M  1001  NEW_LINE #define INF  -1111111111  NEW_LINE int maxSum ( int arr [ ] [ N ] ) { int dp [ N ] [ M ] ; int current_arr [ M ] ; int maxsum [ M ] ; memset ( dp , -1 , sizeof ( dp [ 0 ] [ 0 ] ) * N * M ) ; current_arr [ 0 ] = 0 ; dp [ 0 ] [ 0 ] = 0 ; for ( int i = 1 ; i <= 5 ; i ++ ) { int len = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j <= len ; j ++ ) { current_arr [ j ] = arr [ i - 1 ] [ j ] ; current_arr [ j ] += current_arr [ j - 1 ] ; maxsum [ j ] = INF ; } for ( int j = 1 ; j <= len && j <= 6 ; j ++ ) for ( int k = 1 ; k <= len ; k ++ ) if ( j + k - 1 <= len ) maxsum [ j ] = max ( maxsum [ j ] , current_arr [ j + k - 1 ] - current_arr [ k - 1 ] ) ; for ( int j = 0 ; j <= 6 ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; for ( int j = 1 ; j <= 6 ; j ++ ) for ( int cur = 1 ; cur <= j && cur <= len ; cur ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - cur ] + maxsum [ cur ] ) ; } int ans = 0 ; for ( int i = 0 ; i <= 6 ; i ++ ) ans = max ( ans , dp [ 5 ] [ i ] ) ; return ans ; } int main ( ) { int arr [ ] [ N ] = { { 3 , 2 , 3 , 5 } , { 2 , 7 , -1 } , { 2 , 8 , 10 } , { 4 , 5 , 2 , 6 , 1 } , { 3 , 2 , 3 , -2 } } ; cout << " Maximum ▁ sum ▁ can ▁ be ▁ obtained ▁ " << " is ▁ : ▁ " << maxSum ( arr ) << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxVal ( int arr [ ] , int n , int num , int maxLimit ) { int ind ; int val ; int dp [ n ] [ maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] || dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] ) { return val ; } } return -1 ; } int main ( ) { int num = 1 ; int arr [ ] = { 3 , 10 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxLimit = 15 ; cout << findMaxVal ( arr , n , num , maxLimit ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gen ( int n ) { if ( n == 0 ) return 0 ; else if ( n == 1 ) return 1 ; else if ( n % 2 == 0 ) return 4 * gen ( n / 2 ) ; else if ( n % 2 == 1 ) return 4 * gen ( n / 2 ) + 1 ; } void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << gen ( i ) << " ▁ " ; cout << " STRNEWLINE " ; } int main ( ) { int n = 15 ; cout << " First ▁ " << n << " ▁ terms ▁ of ▁ " << " Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ STRNEWLINE " ; moserDeBruijn ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSumPath ( vector < vector < int > > & A ) { int memo [ A . size ( ) ] ; int n = A . size ( ) - 1 ; for ( int i = 0 ; i < A [ n ] . size ( ) ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . size ( ) - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; } int main ( ) { vector < vector < int > > A { { 2 } , { 3 , 9 } , { 1 , 6 , 7 } } ; cout << minSumPath ( A ) ; return 0 ; }
bool isPossible ( int index , int sum ) { if ( index == n ) { if ( ( sum % M ) == 0 ) return true ; return false ; } bool placeAdd = isPossible ( index + 1 , sum + arr [ index ] ) ; bool placeMinus = isPossible ( index + 1 , sum - arr [ index ] ) ; if ( placeAdd placeMinus ) return true ; return false ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } return count ; } int main ( ) { int a [ ] = { 3 , 4 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 15 ; long long countPairs ( int a [ ] , int n ) { unordered_map < int , int > hash ; long long dp [ 1 << N ] [ N + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) hash [ a [ i ] ] += 1 ; for ( long long mask = 0 ; mask < ( 1 << N ) ; ++ mask ) { if ( mask & 1 ) dp [ mask ] [ 0 ] = hash [ mask ] + hash [ mask ^ 1 ] ; dp [ mask ] [ 0 ] = hash [ mask ] ; for ( int i = 1 ; i <= N ; ++ i ) { if ( mask & ( 1 << i ) ) { dp [ mask ] [ i ] = dp [ mask ] [ i - 1 ] + dp [ mask ^ ( 1 << i ) ] [ i - 1 ] ; } dp [ mask ] [ i ] = dp [ mask ] [ i - 1 ] ; } } long long ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += dp [ ( ( 1 << N ) - 1 ) ^ a [ i ] ] [ N ] ; return ans ; } int main ( ) { int a [ ] = { 5 , 4 , 1 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void postfix ( int a [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) a [ i - 1 ] = a [ i - 1 ] + a [ i ] ; } void modify ( int a [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) a [ i - 1 ] = i * a [ i ] ; } void allCombination ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i ; cout << " f ( 1 ) ▁ - - > ▁ " << sum << " STRNEWLINE " ; for ( int i = 1 ; i < n ; i ++ ) { postfix ( a , n - i + 1 ) ; sum = 0 ; for ( int j = 1 ; j <= n - i ; j ++ ) { sum += ( j * a [ j ] ) ; } cout << " f ( " << i + 1 << " ) ▁ - - > ▁ " << sum << " STRNEWLINE " ; modify ( a , n ) ; } } int main ( ) { int n = 5 ; int * a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = i + 1 ; allCombination ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long dp [ 1000 ] [ 1000 ] ; long long sum ( int a [ ] , int i , int j ) { long long ans = 0 ; for ( int m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; } long long solve ( int a [ ] , int i , int j ) { if ( i == j ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; dp [ i ] [ j ] = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; } return dp [ i ] [ j ] ; } void initialize ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = -1 ; } int main ( ) { int a [ ] = { 40 , 60 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; initialize ( n ) ; cout << solve ( a , 0 , n - 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverseFibonacci ( int n ) { int a [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { cout << a [ i ] << " ▁ " ; } } int main ( ) { int n = 5 ; reverseFibonacci ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s1 , string s2 ) { int n = s1 . length ( ) ; int m = s2 . length ( ) ; bool dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { for ( int j = 0 ; j <= s2 . length ( ) ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( j < s2 . length ( ) && ( toupper ( s1 [ i ] ) == s2 [ j ] ) ) dp [ i + 1 ] [ j + 1 ] = true ; if ( ! isupper ( s1 [ i ] ) ) dp [ i + 1 ] [ j ] = true ; } } } return ( dp [ n ] [ m ] ) ; } int main ( ) { string s1 = " daBcd " ; string s2 = " ABC " ; if ( check ( s1 , s2 ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float find_prob ( int N , float P ) { double dp [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return dp [ N ] ; } int main ( ) { int n = 5 ; float p = 0.2 ; cout << find_prob ( n , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySumRepeated ( int a [ ] , int n , int k ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n * k ; i ++ ) { max_ending_here = max_ending_here + a [ i % n ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } int main ( ) { int a [ ] = { 10 , 20 , -30 , -1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; cout << " Maximum ▁ contiguous ▁ sum ▁ is ▁ " << maxSubArraySumRepeated ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLevenstein ( string const & input ) { string revInput ( input . rbegin ( ) , input . rend ( ) ) ; int n = input . size ( ) ; vector < vector < int > > dp ( n + 1 , vector < int > ( n + 1 , -1 ) ) ; for ( int i = 0 ; i <= n ; ++ i ) { dp [ 0 ] [ i ] = i ; dp [ i ] [ 0 ] = i ; } for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j <= n ; ++ j ) { if ( input [ i - 1 ] == revInput [ j - 1 ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( { dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] } ) ; } } int res = numeric_limits < int > :: max ( ) ; for ( int i = n , j = 0 ; i >= 0 ; -- i , ++ j ) { res = min ( res , dp [ i ] [ j ] ) ; if ( i < n ) res = min ( res , dp [ i + 1 ] [ j ] ) ; if ( i > 0 ) res = min ( res , dp [ i - 1 ] [ j ] ) ; } return res ; } int main ( ) { string input ( " myfirstgeekarticle " ) ; cout << getLevenstein ( input ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int dp [ MAXN ] ; int nck [ MAXN ] [ MAXN ] ; int log2 [ MAXN ] ; int choose ( int n , int k ) { if ( k > n ) return 0 ; if ( n <= 1 ) return 1 ; if ( k == 0 ) return 1 ; if ( nck [ n ] [ k ] != -1 ) return nck [ n ] [ k ] ; int answer = choose ( n - 1 , k - 1 ) + choose ( n - 1 , k ) ; nck [ n ] [ k ] = answer ; return answer ; } int getLeft ( int n ) { if ( n == 1 ) return 0 ; int h = log2 [ n ] ; int last = n - ( ( 1 << h ) - 1 ) ; if ( last >= ( numh / 2 ) ) else return ( 1 << h ) - 1 - ( ( numh / 2 ) - last ) ; } int numberOfHeaps ( int n ) { if ( n <= 1 ) return 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; int left = getLeft ( n ) ; int ans = ( choose ( n - 1 , left ) * numberOfHeaps ( left ) ) * ( numberOfHeaps ( n - 1 - left ) ) ; dp [ n ] = ans ; return ans ; } int solve ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = -1 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) nck [ i ] [ j ] = -1 ; int currLog2 = -1 ; int currPower2 = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( currPower2 == i ) { currLog2 ++ ; currPower2 *= 2 ; } log2 [ i ] = currLog2 ; } return numberOfHeaps ( n ) ; } int main ( ) { int n = 10 ; cout << solve ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  5 NEW_LINE using namespace std ; void printHosoya ( int n ) { int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) cout << dp [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int n = 5 ; printHosoya ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int numberofways ( int n , int m ) { int dp [ n + 2 ] [ n + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; } int main ( ) { int n = 3 , m = 1 ; cout << numberofways ( n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; } int main ( ) { int n = 4 , k = 3 ; cout << zigzag ( n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int eulerian ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; } int main ( ) { int n = 3 , m = 1 ; cout << eulerian ( n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longOddEvenIncSeq ( int arr [ ] , int n ) { int lioes [ n ] ; int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) lioes [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && ( arr [ i ] + arr [ j ] ) % 2 != 0 && lioes [ i ] < lioes [ j ] + 1 ) lioes [ i ] = lioes [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( maxLen < lioes [ i ] ) maxLen = lioes [ i ] ; return maxLen ; } int main ( ) { int arr [ ] = { 1 , 12 , 2 , 22 , 5 , 30 , 31 , 14 , 17 , 11 } ; int n = sizeof ( arr ) / sizeof ( n ) ; cout << " Longest ▁ Increasing ▁ Odd ▁ Even ▁ " << " Subsequence : ▁ " << longOddEvenIncSeq ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dealnnoy ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; } int main ( ) { int n = 3 , m = 4 ; cout << dealnnoy ( n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestAlternating ( int arr [ ] , int n ) { int count [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count [ i ] << " ▁ " ; } int main ( ) { int a [ ] = { -5 , -1 , -1 , 2 , -2 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; longestAlternating ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDP ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; } int main ( ) { int n = 60 ; cout << " MaxSum ▁ = " << maxDP ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int N , int k ) { int MS [ N ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; } int main ( ) { int N = 10 , k = 2 ; int arr [ ] = { 50 , 70 , 40 , 50 , 90 , 70 , 60 , 40 , 70 , 50 } ; cout << maxSum ( arr , N , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void alternateSubarray ( bool arr [ ] , int n ) { int len [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) cout << len [ i ] << " ▁ " ; } int main ( ) { bool arr [ ] = { 1 , 0 , 1 , 0 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; alternateSubarray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void alternateSubarray ( bool arr [ ] , int n ) { int count = 1 ; int prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == 0 ) { while ( count ) cout << count -- << " ▁ " ; } ++ count ; prev = arr [ i ] ; } while ( count ) cout << count -- << " ▁ " ; } int main ( ) { bool arr [ ] = { 1 , 0 , 1 , 0 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; alternateSubarray ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countways ( long long n ) { long long A [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 3 ; A [ 2 ] = 7 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = 2 * A [ i - 1 ] + A [ i - 2 ] ; } return A [ n ] ; } int main ( ) { int n = 5 ; cout << countways ( 5 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int uniquePathsWithObstacles ( vector < vector < int > > & A ) { int r = A . size ( ) ; int c = A [ 0 ] . size ( ) ; if ( A [ 0 ] [ 0 ] ) return 0 ; A [ 0 ] [ 0 ] = 1 ; for ( int j = 1 ; j < c ; j ++ ) { if ( A [ 0 ] [ j ] == 0 ) { A [ 0 ] [ j ] = A [ 0 ] [ j - 1 ] ; } else { A [ 0 ] [ j ] = 0 ; } } for ( int i = 1 ; i < r ; i ++ ) { if ( A [ i ] [ 0 ] == 0 ) { A [ i ] [ 0 ] = A [ i - 1 ] [ 0 ] ; } else { A [ i ] [ 0 ] = 0 ; } } for ( int i = 1 ; i < r ; i ++ ) { for ( int j = 1 ; j < c ; j ++ ) { if ( A [ i ] [ j ] == 0 ) { A [ i ] [ j ] = A [ i - 1 ] [ j ] + A [ i ] [ j - 1 ] ; } else { A [ i ] [ j ] = 0 ; } } } return A [ r - 1 ] ; } int main ( ) { vector < vector < int > > A = { { 0 , 0 , 0 } , { 0 , 1 , 0 } , { 0 , 0 , 0 } } ; cout << uniquePathsWithObstacles ( A ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findWinner ( int x , int y , int n ) { int dp [ n + 1 ] ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 and ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 and ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 and ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; } int main ( ) { int x = 3 , y = 4 , n = 5 ; if ( findWinner ( x , y , n ) ) cout << ' A ' ; else cout << ' B ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxGameByWinner ( int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; } int main ( ) { int N = 10 ; cout << maxGameByWinner ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minRemove ( int arr [ ] , int n ) { int LIS [ n ] , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) { LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } len = max ( len , LIS [ i ] ) ; } return n - len ; } int main ( ) { int arr [ ] = { 1 , 2 , 6 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minRemove ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTransformation ( string a , string b ) { int n = a . size ( ) , m = b . size ( ) ; if ( m == 0 ) return 1 ; int dp [ m ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( i == 0 ) { if ( j == 0 ) dp [ i ] [ j ] = ( a [ j ] == b [ i ] ) ? 1 : 0 ; else if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + 1 ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } else { if ( a [ j ] == b [ i ] ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } } return dp [ m - 1 ] [ n - 1 ] ; } int main ( ) { string a = " abcccdf " , b = " abccdf " ; cout << countTransformation ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxWeightRec ( int wt [ ] , int val [ ] , int K , map < pair < int , int > , int > & mp , int last , int diff ) { if ( last == -1 ) { if ( diff == 0 ) return 0 ; else return INT_MIN ; } pair < int , int > tmp = make_pair ( last , diff ) ; if ( mp . find ( tmp ) != mp . end ( ) ) return mp [ tmp ] ; mp [ tmp ] = max ( maxWeightRec ( wt , val , K , mp , last - 1 , diff ) , wt [ last ] + maxWeightRec ( wt , val , K , mp , last - 1 , diff + wt [ last ] - val [ last ] * K ) ) ; return mp [ tmp ] ; } int maxWeight ( int wt [ ] , int val [ ] , int K , int N ) { map < pair < int , int > , int > mp ; return maxWeightRec ( wt , val , K , mp , N - 1 , 0 ) ; } int main ( ) { int wt [ ] = { 4 , 8 , 9 } ; int val [ ] = { 2 , 4 , 6 } ; int N = sizeof ( wt ) / sizeof ( int ) ; int K = 2 ; cout << maxWeight ( wt , val , K , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define ull  unsigned long long NEW_LINE ull minPyramidCost ( ull arr [ ] , ull N ) { ull * left = new ull [ N ] ; ull * right = new ull [ N ] ; left [ 0 ] = min ( arr [ 0 ] , ( ull ) 1 ) ; for ( int i = 1 ; i < N ; ++ i ) left [ i ] = min ( arr [ i ] , min ( left [ i - 1 ] + 1 , ( ull ) i + 1 ) ) ; right [ N - 1 ] = min ( arr [ N - 1 ] , ( ull ) 1 ) ; for ( int i = N - 2 ; i >= 0 ; -- i ) right [ i ] = min ( arr [ i ] , min ( right [ i + 1 ] + 1 , N - i ) ) ; ull tot [ N ] ; for ( int i = 0 ; i < N ; ++ i ) tot [ i ] = min ( right [ i ] , left [ i ] ) ; ull max_ind = 0 ; for ( int i = 0 ; i < N ; ++ i ) if ( tot [ i ] > tot [ max_ind ] ) max_ind = i ; ull cost = 0 ; ull height = tot [ max_ind ] ; for ( int x = max_ind ; x >= 0 ; -- x ) { cost += arr [ x ] - height ; if ( height > 0 ) -- height ; } height = tot [ max_ind ] - 1 ; for ( int x = max_ind + 1 ; x < N ; ++ x ) { cost += arr [ x ] - height ; if ( height > 0 ) -- height ; } return cost ; } int main ( ) { ull arr [ ] = { 1 , 2 , 3 , 4 , 2 , 1 } ; ull N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minPyramidCost ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  1000 NEW_LINE using namespace std ; int maxSum ( int grid [ 2 ] [ MAX ] , int n ) { int incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = max ( excl , incl ) ; incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return max ( excl , incl ) ; } int main ( ) { int grid [ 2 ] [ MAX ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 10 } } ; int n = 5 ; cout << maxSum ( grid , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minInsertionStepToSortArray ( int arr [ ] , int N ) { int lis [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 1 , 4 , 7 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minInsertionStepToSortArray ( arr , N ) ; return 0 ; }
# include <iostream> NEW_LINE using namespace std ; # define NO_OF_CHARS  256 NEW_LINE void printDistinct ( char * str ) { int count [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; * ( str + i ) ; i ++ ) if ( * ( str + i ) != ' ▁ ' ) count [ * ( str + i ) ] ++ ; int n = i ; for ( i = 0 ; i < n ; i ++ ) if ( count [ * ( str + i ) ] == 1 ) cout << str [ i ] ; } int main ( ) { char str [ ] = " GeeksforGeeks " ; printDistinct ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1005 NEW_LINE int shortestSeq ( char * S , char * T , int m , int n ) { if ( m == 0 ) return MAX ; if ( n <= 0 ) return 1 ; int k ; for ( k = 0 ; k < n ; k ++ ) if ( T [ k ] == S [ 0 ] ) break ; if ( k == n ) return 1 ; return min ( shortestSeq ( S + 1 , T , m - 1 , n ) , 1 + shortestSeq ( S + 1 , T + k + 1 , m - 1 , n - k - 1 ) ) ; } int main ( ) { char S [ ] = " babab " ; char T [ ] = " babba " ; int m = strlen ( S ) , n = strlen ( T ) ; int ans = shortestSeq ( S , T , m , n ) ; if ( ans >= MAX ) ans = -1 ; cout << " Length ▁ of ▁ shortest ▁ subsequence ▁ is : ▁ " << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1005 NEW_LINE int shortestSeq ( char * S , char * T ) { int m = strlen ( S ) , n = strlen ( T ) ; int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ 0 ] [ i ] = MAX ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = S [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) if ( T [ k ] == ch ) break ; if ( k == -1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } int ans = dp [ m ] [ n ] ; if ( ans >= MAX ) ans = -1 ; return ans ; } int main ( ) { char S [ ] = " babab " ; char T [ ] = " babba " ; int m = strlen ( S ) , n = strlen ( T ) ; cout << " Length ▁ of ▁ shortest ▁ subsequence ▁ is ▁ : ▁ " << shortestSeq ( S , T ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minStepToDeleteString ( string str ) { int N = str . length ( ) ; int dp [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; } int main ( ) { string str = "2553432" ; cout << minStepToDeleteString ( str ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int inf = 1000000000 ; int ans = inf ; void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; } int main ( ) { int k = 2 ; int a [ ] = { 1 , 5 , 8 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; solve ( -1 , 0 , a , n , k , 0 ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinSteps ( int n , int * memo ) { if ( n == 1 ) return 0 ; if ( memo [ n ] != -1 ) return memo [ n ] ; int res = getMinSteps ( n - 1 , memo ) ; if ( n % 2 == 0 ) res = min ( res , getMinSteps ( n / 2 , memo ) ) ; if ( n % 3 == 0 ) res = min ( res , getMinSteps ( n / 3 , memo ) ) ; memo [ n ] = 1 + res ; return memo [ n ] ; } int getMinSteps ( int n ) { int memo [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) memo [ i ] = -1 ; return getMinSteps ( n , memo ) ; } int main ( ) { int n = 10 ; cout << getMinSteps ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct Temple { int L ; int R ; } ; int offeringNumber ( int n , int templeHeight [ ] ) { Temple chainSize [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { chainSize [ i ] . L = -1 ; chainSize [ i ] . R = -1 ; } chainSize [ 0 ] . L = 1 ; chainSize [ n - 1 ] . R = 1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( templeHeight [ i - 1 ] < templeHeight [ i ] ) chainSize [ i ] . L = chainSize [ i - 1 ] . L + 1 ; else chainSize [ i ] . L = 1 ; } for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( templeHeight [ i + 1 ] < templeHeight [ i ] ) chainSize [ i ] . R = chainSize [ i + 1 ] . R + 1 ; else chainSize [ i ] . R = 1 ; } int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += max ( chainSize [ i ] . L , chainSize [ i ] . R ) ; return sum ; } int main ( ) { int arr1 [ 3 ] = { 1 , 2 , 2 } ; cout << offeringNumber ( 3 , arr1 ) << " STRNEWLINE " ; int arr2 [ 6 ] = { 1 , 4 , 3 , 6 , 2 , 1 } ; cout << offeringNumber ( 6 , arr2 ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int stringReduction ( string str ) { int n = str . length ( ) ; int count [ 3 ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) count [ str [ i ] - ' a ' ] ++ ; if ( count [ 0 ] == n count [ 1 ] == n count [ 2 ] == n ) return n ; if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) return 2 ; return 1 ; } int main ( ) { string str = " abcbbaacb " ; cout << stringReduction ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int dp [ MAX ] [ MAX ] ; int largestZigZagSumRec ( int mat [ ] [ MAX ] , int i , int j , int n ) { if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; if ( i == n - 1 ) return ( dp [ i ] [ j ] = mat [ i ] [ j ] ) ; int zzs = 0 ; for ( int k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return ( dp [ i ] [ j ] = ( zzs + mat [ i ] [ j ] ) ) ; } int largestZigZag ( int mat [ ] [ MAX ] , int n ) { memset ( dp , -1 , sizeof ( dp ) ) ; int res = 0 ; for ( int j = 0 ; j < n ; j ++ ) res = max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; } int main ( ) { int n = 3 ; int mat [ ] [ MAX ] = { { 4 , 2 , 1 } , { 3 , 9 , 6 } , { 11 , 3 , 15 } } ; cout << " Largest ▁ zigzag ▁ sum : ▁ " << largestZigZag ( mat , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubsequences ( string s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( unsigned int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' a ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' b ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' c ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; } int main ( ) { string s = " abbc " ; cout << countSubsequences ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n , int t ) { int maxRev [ m + 1 ] ; memset ( maxRev , 0 , sizeof ( maxRev ) ) ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; } int main ( ) { int m = 20 ; int x [ ] = { 6 , 7 , 12 , 13 , 14 } ; int revenue [ ] = { 5 , 6 , 5 , 3 , 1 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; int t = 5 ; cout << maxRevenue ( m , x , revenue , n , t ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findLIS ( vector < int > arr , int n ) { vector < vector < int > > L ( n ) ; L [ 0 ] . push_back ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( L [ i ] . size ( ) < L [ j ] . size ( ) ) ) L [ i ] = L [ j ] ; } L [ i ] . push_back ( arr [ i ] ) ; } int maxSize = 1 ; vector < int > lis ; for ( vector < int > x : L ) { if ( x . size ( ) > maxSize ) { lis = x ; maxSize = x . size ( ) ; } } return lis ; } void minimize ( int input [ ] , int n ) { vector < int > arr ( input , input + n ) ; while ( arr . size ( ) ) { vector < int > lis = findLIS ( arr , arr . size ( ) ) ; if ( lis . size ( ) < 2 ) break ; for ( int i = 0 ; i < arr . size ( ) && lis . size ( ) > 0 ; i ++ ) { if ( arr [ i ] == lis [ 0 ] ) { arr . erase ( arr . begin ( ) + i ) ; i -- ; lis . erase ( lis . begin ( ) ) ; } } } int i ; for ( i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << " ▁ " ; if ( i == 0 ) cout << " - 1" ; } int main ( ) { int input [ ] = { 3 , 2 , 6 , 4 , 5 , 1 } ; int n = sizeof ( input ) / sizeof ( input [ 0 ] ) ; minimize ( input , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  21 NEW_LINE double fact [ MAX ] ; double probability ( int k , int n ) { double ans = 0 ; for ( int i = k ; i <= n ; ++ i ) ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) ; ans = ans / ( 1LL << n ) ; return ans ; } void precompute ( ) { fact [ 0 ] = fact [ 1 ] = 1 ; for ( int i = 2 ; i < 20 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; } int main ( ) { precompute ( ) ; cout << probability ( 2 , 3 ) << " STRNEWLINE " ; cout << probability ( 3 , 6 ) << " STRNEWLINE " ; cout << probability ( 12 , 18 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countStrings ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; } int main ( ) { int n = 5 , k = 2 ; cout << countStrings ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 1000 ] ; int countFriendsPairings ( int n ) { if ( dp [ n ] != -1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; } int main ( ) { memset ( dp , -1 , sizeof ( dp ) ) ; int n = 4 ; cout << countFriendsPairings ( n ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void preComputeFact ( vector < long long int > & fact , int n ) { for ( int i = 1 ; i <= n ; i ++ ) fact . push_back ( fact [ i - 1 ] * i ) ; } int countFriendsPairings ( vector < long long int > fact , int n ) { int ones = n , twos = 1 , ans = 0 ; while ( ones >= 0 ) { ans += fact [ n ] / ( twos * fact [ ones ] * fact [ ( n - ones ) / 2 ] ) ; ones -= 2 ; twos *= 2 ; } return ans ; } int main ( ) { vector < long long int > fact ; fact . push_back ( 1 ) ; preComputeFact ( fact , 100 ) ; int n = 4 ; cout << countFriendsPairings ( fact , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define l  3 NEW_LINE #define m  3 NEW_LINE #define n  3 NEW_LINE int min ( int x , int y , int z ) { return ( x < y ) ? ( ( x < z ) ? x : z ) : ( ( y < z ) ? y : z ) ; } int minPathSum ( int arr [ ] [ m ] [ n ] ) { int i , j , k ; int tSum [ l ] [ m ] [ n ] ; tSum [ 0 ] [ 0 ] [ 0 ] = arr [ 0 ] [ 0 ] [ 0 ] ; for ( i = 1 ; i < l ; i ++ ) tSum [ i ] [ 0 ] [ 0 ] = tSum [ i - 1 ] [ 0 ] [ 0 ] + arr [ i ] [ 0 ] [ 0 ] ; for ( j = 1 ; j < m ; j ++ ) tSum [ 0 ] [ j ] [ 0 ] = tSum [ 0 ] [ j - 1 ] [ 0 ] + arr [ 0 ] [ j ] [ 0 ] ; for ( k = 1 ; k < n ; k ++ ) tSum [ 0 ] [ 0 ] [ k ] = tSum [ 0 ] [ 0 ] [ k - 1 ] + arr [ 0 ] [ 0 ] [ k ] ; for ( i = 1 ; i < l ; i ++ ) for ( j = 1 ; j < m ; j ++ ) tSum [ i ] [ j ] [ 0 ] = min ( tSum [ i - 1 ] [ j ] [ 0 ] , tSum [ i ] [ j - 1 ] [ 0 ] , INT_MAX ) + arr [ i ] [ j ] [ 0 ] ; for ( i = 1 ; i < l ; i ++ ) for ( k = 1 ; k < n ; k ++ ) tSum [ i ] [ 0 ] [ k ] = min ( tSum [ i - 1 ] [ 0 ] [ k ] , tSum [ i ] [ 0 ] [ k - 1 ] , INT_MAX ) + arr [ i ] [ 0 ] [ k ] ; for ( k = 1 ; k < n ; k ++ ) for ( j = 1 ; j < m ; j ++ ) tSum [ 0 ] [ j ] [ k ] = min ( tSum [ 0 ] [ j ] [ k - 1 ] , tSum [ 0 ] [ j - 1 ] [ k ] , INT_MAX ) + arr [ 0 ] [ j ] [ k ] ; for ( i = 1 ; i < l ; i ++ ) for ( j = 1 ; j < m ; j ++ ) for ( k = 1 ; k < n ; k ++ ) tSum [ i ] [ j ] [ k ] = min ( tSum [ i - 1 ] [ j ] [ k ] , tSum [ i ] [ j - 1 ] [ k ] , tSum [ i ] [ j ] [ k - 1 ] ) + arr [ i ] [ j ] [ k ] ; return tSum [ l - 1 ] [ m - 1 ] [ n - 1 ] ; } int main ( ) { int arr [ l ] [ m ] [ n ] = { { { 1 , 2 , 4 } , { 3 , 4 , 5 } , { 5 , 2 , 1 } } , { { 4 , 8 , 3 } , { 5 , 2 , 1 } , { 3 , 4 , 2 } } , { { 2 , 4 , 1 } , { 3 , 1 , 4 } , { 6 , 3 , 8 } } } ; cout << minPathSum ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printParenthesis ( int i , int j , int n , int * bracket , char & name ) { if ( i == j ) { cout << name ++ ; return ; } cout << " ( " ; printParenthesis ( i , * ( ( bracket + i * n ) + j ) , n , bracket , name ) ; printParenthesis ( * ( ( bracket + i * n ) + j ) + 1 , j , n , bracket , name ) ; cout << " ) " ; } void matrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int bracket [ n ] [ n ] ; for ( int i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( int L = 2 ; L < n ; L ++ ) { for ( int i = 1 ; i < n - L + 1 ; i ++ ) { int j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( int k = i ; k <= j - 1 ; k ++ ) { int q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) { m [ i ] [ j ] = q ; bracket [ i ] [ j ] = k ; } } } } char name = ' A ' ; cout << " Optimal ▁ Parenthesization ▁ is ▁ : ▁ " ; printParenthesis ( 1 , n - 1 , n , ( int * ) bracket , name ) ; cout << " nOptimal ▁ Cost ▁ is ▁ : ▁ " << m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 40 , 20 , 30 , 10 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; matrixChainOrder ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE int maxPathSum ( int tri [ ] [ N ] , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; } int main ( ) { int tri [ N ] [ N ] = { { 1 , 0 , 0 } , { 4 , 8 , 0 } , { 1 , 5 , 3 } } ; cout << maxPathSum ( tri , 2 , 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int MaxDotProduct ( int A [ ] , int B [ ] , int m , int n ) { long long int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= m ; j ++ ) dp [ i ] [ j ] = max ( ( dp [ i - 1 ] [ j - 1 ] + ( A [ j - 1 ] * B [ i - 1 ] ) ) , dp [ i ] [ j - 1 ] ) ; return dp [ n ] [ m ] ; } int main ( ) { int A [ ] = { 2 , 3 , 1 , 7 , 8 } ; int B [ ] = { 3 , 6 , 7 } ; int m = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int n = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << MaxDotProduct ( A , B , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string X = " AGGT12" ; string Y = "12TXAYB " ; string Z = "12XBA " ; int dp [ 100 ] [ 100 ] [ 100 ] ; int lcsOf3 ( int i , int j , int k ) { if ( i == -1 j == -1 k == -1 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != -1 ) return dp [ i ] [ j ] [ k ] ; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; else return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; } int main ( ) { memset ( dp , -1 , sizeof ( dp ) ) ; int m = X . length ( ) ; int n = Y . length ( ) ; int o = Z . length ( ) ; cout << " Length ▁ of ▁ LCS ▁ is ▁ " << lcsOf3 ( m - 1 , n - 1 , o - 1 ) ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  102 NEW_LINE using namespace std ; int countMin ( int arr [ ] , int dp [ MAX ] [ MAX ] [ MAX ] , int n , int dec , int inc , int i ) { if ( dp [ dec ] [ inc ] [ i ] != -1 ) return dp [ dec ] [ inc ] [ i ] ; if ( i == n ) return 0 ; if ( arr [ i ] < arr [ dec ] ) dp [ dec ] [ inc ] [ i ] = countMin ( arr , dp , n , i , inc , i + 1 ) ; if ( arr [ i ] > arr [ inc ] ) { if ( dp [ dec ] [ inc ] [ i ] == -1 ) dp [ dec ] [ inc ] [ i ] = countMin ( arr , dp , n , dec , i , i + 1 ) ; else dp [ dec ] [ inc ] [ i ] = min ( countMin ( arr , dp , n , dec , i , i + 1 ) , dp [ dec ] [ inc ] [ i ] ) ; } if ( dp [ dec ] [ inc ] [ i ] == -1 ) dp [ dec ] [ inc ] [ i ] = 1 + countMin ( arr , dp , n , dec , inc , i + 1 ) ; else dp [ dec ] [ inc ] [ i ] = min ( 1 + countMin ( arr , dp , n , dec , inc , i + 1 ) , dp [ dec ] [ inc ] [ i ] ) ; return dp [ dec ] [ inc ] [ i ] ; } int wrapper ( int arr [ ] , int n ) { arr [ MAX - 2 ] = INT_MAX ; arr [ MAX - 1 ] = INT_MIN ; int dp [ MAX ] [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof dp ) ; return countMin ( arr , dp , n , MAX - 2 , MAX - 1 , 0 ) ; } int main ( ) { int n = 12 ; int arr [ MAX ] = { 7 , 8 , 1 , 2 , 4 , 6 , 3 , 5 , 2 , 1 , 8 , 7 } ; cout << wrapper ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void distSumRec ( int arr [ ] , int n , int sum , int currindex , unordered_set < int > & s ) { if ( currindex > n ) return ; if ( currindex == n ) { s . insert ( sum ) ; return ; } distSumRec ( arr , n , sum + arr [ currindex ] , currindex + 1 , s ) ; distSumRec ( arr , n , sum , currindex + 1 , s ) ; } void printDistSum ( int arr [ ] , int n ) { unordered_set < int > s ; distSumRec ( arr , n , 0 , 0 , s ) ; for ( auto i = s . begin ( ) ; i != s . end ( ) ; i ++ ) cout << * i << " ▁ " ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printDistSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printDistSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool dp [ n + 1 ] [ sum + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i - 1 ] ] = true ; for ( int j = 1 ; j <= sum ; j ++ ) { if ( dp [ i - 1 ] [ j ] == true ) { dp [ i ] [ j ] = true ; dp [ i ] [ j + arr [ i - 1 ] ] = true ; } } } for ( int j = 0 ; j <= sum ; j ++ ) if ( dp [ n ] [ j ] == true ) cout << j << " ▁ " ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printDistSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  4 NEW_LINE #define C  4 NEW_LINE int countPaths ( int maze [ ] [ C ] ) { if ( maze [ 0 ] [ 0 ] == -1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == -1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; } int main ( ) { int maze [ R ] [ C ] = { { 0 , 0 , 0 , 0 } , { 0 , -1 , 0 , 0 } , { -1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; cout << countPaths ( maze ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minSum ( int arr [ ] , int n ) { int dp [ n ] ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return min ( arr [ 0 ] , arr [ 1 ] ) ; if ( n == 3 ) return min ( arr [ 0 ] , min ( arr [ 1 ] , arr [ 2 ] ) ) ; if ( n == 4 ) return min ( min ( arr [ 0 ] , arr [ 1 ] ) , min ( arr [ 2 ] , arr [ 3 ] ) ) ; dp [ 0 ] = arr [ 0 ] ; dp [ 1 ] = arr [ 1 ] ; dp [ 2 ] = arr [ 2 ] ; dp [ 3 ] = arr [ 3 ] ; for ( int i = 4 ; i < n ; i ++ ) dp [ i ] = arr [ i ] + min ( min ( dp [ i - 1 ] , dp [ i - 2 ] ) , min ( dp [ i - 3 ] , dp [ i - 4 ] ) ) ; return min ( min ( dp [ n - 1 ] , dp [ n - 2 ] ) , min ( dp [ n - 4 ] , dp [ n - 3 ] ) ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 4 , 5 , 6 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isOperator ( char op ) { return ( op == ' + ' op == ' * ' ) ; } void printMinAndMaxValueOfExp ( string exp ) { vector < int > num ; vector < char > opr ; string tmp = " " ; for ( int i = 0 ; i < exp . length ( ) ; i ++ ) { if ( isOperator ( exp [ i ] ) ) { opr . push_back ( exp [ i ] ) ; num . push_back ( atoi ( tmp . c_str ( ) ) ) ; tmp = " " ; } else { tmp += exp [ i ] ; } } num . push_back ( atoi ( tmp . c_str ( ) ) ) ; int len = num . size ( ) ; int minVal [ len ] [ len ] ; int maxVal [ len ] [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = 0 ; j < len ; j ++ ) { minVal [ i ] [ j ] = INT_MAX ; maxVal [ i ] [ j ] = 0 ; if ( i == j ) minVal [ i ] [ j ] = maxVal [ i ] [ j ] = num [ i ] ; } } for ( int L = 2 ; L <= len ; L ++ ) { for ( int i = 0 ; i < len - L + 1 ; i ++ ) { int j = i + L - 1 ; for ( int k = i ; k < j ; k ++ ) { int minTmp = 0 , maxTmp = 0 ; if ( opr [ k ] == ' + ' ) { minTmp = minVal [ i ] [ k ] + minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] + maxVal [ k + 1 ] [ j ] ; } else if ( opr [ k ] == ' * ' ) { minTmp = minVal [ i ] [ k ] * minVal [ k + 1 ] [ j ] ; maxTmp = maxVal [ i ] [ k ] * maxVal [ k + 1 ] [ j ] ; } if ( minTmp < minVal [ i ] [ j ] ) minVal [ i ] [ j ] = minTmp ; if ( maxTmp > maxVal [ i ] [ j ] ) maxVal [ i ] [ j ] = maxTmp ; } } } cout << " Minimum ▁ value ▁ : ▁ " << minVal [ 0 ] [ len - 1 ] << " , ▁ Maximum ▁ value ▁ : ▁ " << maxVal [ 0 ] [ len - 1 ] ; } int main ( ) { string expression = "1 + 2*3 + 4*5" ; printMinAndMaxValueOfExp ( expression ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountPS ( char str [ ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; bool P [ n ] [ n ] ; memset ( P , false , sizeof ( P ) ) ; for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; } int main ( ) { char str [ ] = " abaab " ; int n = strlen ( str ) ; cout << CountPS ( str , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumWO3Consec ( int arr [ ] , int n ) { int sum [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; } int main ( ) { int arr [ ] = { 100 , 1000 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSumWO3Consec ( arr , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE int lucas ( int n ) { if ( n == 0 ) return 2 ; if ( n == 1 ) return 1 ; return lucas ( n - 1 ) + lucas ( n - 2 ) ; } int main ( ) { int n = 9 ; printf ( " % d " , lucas ( n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int breakSum ( int n ) { if ( n == 0 n == 1 ) return n ; return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; } int main ( ) { int n = 12 ; cout << breakSum ( n ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int countPS ( string str ) { int N = str . length ( ) ; int cps [ N + 1 ] [ N + 1 ] ; memset ( cps , 0 , sizeof ( cps ) ) ; for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } return cps [ 0 ] [ N - 1 ] ; } int main ( ) { string str = " abcb " ; cout << " Total ▁ palindromic ▁ subsequence ▁ are ▁ : ▁ " << countPS ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int n , dp [ 1000 ] [ 1000 ] ; string str = " abcb " ; int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; } int main ( ) { memset ( dp , -1 , sizeof ( dp ) ) ; n = str . size ( ) ; cout << " Total ▁ palindromic ▁ subsequence ▁ are ▁ : ▁ " << countPS ( 0 , n - 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSub ( int arr [ ] , int n ) { int count [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - 1 ; j >= 0 ; j -- ) count [ arr [ i ] ] += count [ j ] ; count [ arr [ i ] ] ++ ; } int result = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) result += count [ i ] ; return result ; } int main ( ) { int arr [ ] = { 3 , 2 , 4 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSub ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minimum ( int a , int b , int c ) { return min ( min ( a , b ) , c ) ; } int findMinSum ( int arr [ ] , int n ) { int sum [ n ] ; sum [ 0 ] = arr [ 0 ] ; sum [ 1 ] = arr [ 1 ] ; sum [ 2 ] = arr [ 2 ] ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ; return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 20 , 2 , 10 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Min ▁ Sum ▁ is ▁ " << findMinSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSub ( string s ) { map < char , int > Map ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { Map [ s [ i ] ] = -1 ; } int allCount = 0 ; int levelCount = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char c = s [ i ] ; if ( i == 0 ) { allCount = 1 ; Map = 1 ; levelCount = 1 ; continue ; } levelCount = allCount + 1 ; if ( Map < 0 ) { allCount = allCount + levelCount ; } else { allCount = allCount + levelCount - Map ; } Map = levelCount ; } return allCount ; } int main ( ) { string list [ ] = { " abab " , " gfg " } ; for ( string s : list ) { int cnt = countSub ( s ) ; int withEmptyString = cnt + 1 ; cout << " With ▁ empty ▁ string ▁ count ▁ for ▁ " << s << " ▁ is ▁ " << withEmptyString << endl ; cout << " Without ▁ empty ▁ string ▁ count ▁ for ▁ " << s << " ▁ is ▁ " << cnt << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define INF  1000000 NEW_LINE using namespace std ; int MinimumCost ( int cost [ ] , int n , int W ) { vector < int > val , wt ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != -1 ) { val . push_back ( cost [ i ] ) ; wt . push_back ( i + 1 ) ; size ++ ; } } n = size ; int min_cost [ n + 1 ] [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = INF ; for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } return ( min_cost [ n ] [ W ] == INF ) ? -1 : min_cost [ n ] [ W ] ; } int main ( ) { int cost [ ] = { 1 , 2 , 3 , 4 , 5 } , W = 5 ; int n = sizeof ( cost ) / sizeof ( cost [ 0 ] ) ; cout << MinimumCost ( cost , n , W ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int count ( string a , string b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; } int main ( ) { string a = " GeeksforGeeks " ; string b = " Gks " ; cout << count ( a , b , a . size ( ) , b . size ( ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } int findMinCost ( char X [ ] , char Y [ ] , int costX , int costY ) { int m = strlen ( X ) , n = strlen ( Y ) ; int len_LCS = lcs ( X , Y , m , n ) ; return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ; } int main ( ) { char X [ ] = " ef " ; char Y [ ] = " gh " ; cout << " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ " << " ▁ identical ▁ is ▁ = ▁ " << findMinCost ( X , Y , 10 , 20 ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; struct Job { int start , finish , profit ; } ; int findSum ( vector < Job > arr ) { int sum = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) sum += arr [ i ] . profit ; return sum ; } int compare ( Job x , Job y ) { return x . start < y . start ; } void findMaxProfit ( vector < Job > & arr ) { sort ( arr . begin ( ) , arr . end ( ) , compare ) ; vector < vector < Job > > L ( arr . size ( ) ) ; L [ 0 ] . push_back ( arr [ 0 ] ) ; for ( int i = 1 ; i < arr . size ( ) ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] . finish <= arr [ i ] . start ) && ( findSum ( L [ j ] ) > findSum ( L [ i ] ) ) ) L [ i ] = L [ j ] ; } L [ i ] . push_back ( arr [ i ] ) ; } vector < Job > maxChain ; for ( int i = 0 ; i < L . size ( ) ; i ++ ) if ( findSum ( L [ i ] ) > findSum ( maxChain ) ) maxChain = L [ i ] ; for ( int i = 0 ; i < maxChain . size ( ) ; i ++ ) cout << " ( " << maxChain [ i ] . start << " , ▁ " << maxChain [ i ] . finish << " , ▁ " << maxChain [ i ] . profit << " ) ▁ " ; } int main ( ) { Job a [ ] = { { 3 , 10 , 20 } , { 1 , 2 , 50 } , { 6 , 19 , 100 } , { 2 , 100 , 200 } } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; vector < Job > arr ( a , a + n ) ; findMaxProfit ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; } int main ( ) { int n = 3 ; cout << countIntegralSolutions ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLeftSubArraySum ( int a [ ] , int size , int sum [ ] ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; sum [ 0 ] = max_so_far ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; sum [ i ] = max_so_far ; } return max_so_far ; } int maxRightSubArraySum ( int a [ ] , int n , int sum [ ] ) { int max_so_far = a [ n ] ; int curr_max = a [ n ] ; sum [ n ] = max_so_far ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; sum [ i ] = max_so_far ; } return max_so_far ; } int findMaxAbsDiff ( int arr [ ] , int n ) { int leftMax [ n ] ; maxLeftSubArraySum ( arr , n , leftMax ) ; int rightMax [ n ] ; maxRightSubArraySum ( arr , n - 1 , rightMax ) ; int invertArr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) invertArr [ i ] = - arr [ i ] ; int leftMin [ n ] ; maxLeftSubArraySum ( invertArr , n , leftMin ) ; for ( int i = 0 ; i < n ; i ++ ) leftMin [ i ] = - leftMin [ i ] ; int rightMin [ n ] ; maxRightSubArraySum ( invertArr , n - 1 , rightMin ) ; for ( int i = 0 ; i < n ; i ++ ) rightMin [ i ] = - rightMin [ i ] ; int result = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int absValue = max ( abs ( leftMax [ i ] - rightMin [ i + 1 ] ) , abs ( leftMin [ i ] - rightMax [ i + 1 ] ) ) ; if ( absValue > result ) result = absValue ; } return result ; } int main ( ) { int a [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findMaxAbsDiff ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  4 NEW_LINE #define N  4 NEW_LINE struct Point { int x , y ; } ; list < Point > findPath ( int grid [ M ] [ N ] , int mat [ M ] [ N ] , int i , int j ) { list < Point > path ; Point pt = { i , j } ; path . push_front ( pt ) ; while ( grid [ i ] [ j ] != 0 ) { if ( i > 0 && grid [ i ] [ j ] - 1 == grid [ i - 1 ] [ j ] ) { pt = { i - 1 , j } ; path . push_front ( pt ) ; i -- ; } else if ( j > 0 && grid [ i ] [ j ] - 1 == grid [ i ] [ j - 1 ] ) { pt = { i , j - 1 } ; path . push_front ( pt ) ; j -- ; } } return path ; } void findSnakeSequence ( int mat [ M ] [ N ] ) { int lookup [ M ] [ N ] ; memset ( lookup , 0 , sizeof lookup ) ; int max_len = 0 ; int max_row = 0 ; int max_col = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i j ) { if ( i > 0 && abs ( mat [ i - 1 ] [ j ] - mat [ i ] [ j ] ) == 1 ) { lookup [ i ] [ j ] = max ( lookup [ i ] [ j ] , lookup [ i - 1 ] [ j ] + 1 ) ; if ( max_len < lookup [ i ] [ j ] ) { max_len = lookup [ i ] [ j ] ; max_row = i , max_col = j ; } } if ( j > 0 && abs ( mat [ i ] [ j - 1 ] - mat [ i ] [ j ] ) == 1 ) { lookup [ i ] [ j ] = max ( lookup [ i ] [ j ] , lookup [ i ] [ j - 1 ] + 1 ) ; if ( max_len < lookup [ i ] [ j ] ) { max_len = lookup [ i ] [ j ] ; max_row = i , max_col = j ; } } } } } cout << " Maximum ▁ length ▁ of ▁ Snake ▁ sequence ▁ is : ▁ " << max_len << endl ; list < Point > path = findPath ( lookup , mat , max_row , max_col ) ; cout << " Snake ▁ sequence ▁ is : " ; for ( auto it = path . begin ( ) ; it != path . end ( ) ; it ++ ) cout << endl << mat [ it -> x ] [ it -> y ] << " ▁ ( " << it -> x << " , ▁ " << it -> y << " ) " ; } int main ( ) { int mat [ M ] [ N ] = { { 9 , 6 , 5 , 2 } , { 8 , 7 , 6 , 5 } , { 7 , 3 , 1 , 6 } , { 1 , 1 , 1 , 7 } , } ; findSnakeSequence ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( last == 0 ) return countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; if ( last == 1 ) return countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; if ( last == 2 ) return countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; } int countUtil ( int p , int q , int r ) { } int main ( ) { int p = 1 , q = 1 , r = 1 ; printf ( " % d " , countUtil ( p , q , r ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinRec ( int arr [ ] , int i , int sumCalculated , int sumTotal ) { if ( i == 0 ) return abs ( ( sumTotal - sumCalculated ) - sumCalculated ) ; return min ( findMinRec ( arr , i - 1 , sumCalculated + arr [ i - 1 ] , sumTotal ) , findMinRec ( arr , i - 1 , sumCalculated , sumTotal ) ) ; } int findMin ( int arr [ ] , int n ) { int sumTotal = 0 ; for ( int i = 0 ; i < n ; i ++ ) sumTotal += arr [ i ] ; return findMinRec ( arr , n , 0 , sumTotal ) ; } int main ( ) { int arr [ ] = { 3 , 1 , 4 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ minimum ▁ difference ▁ between ▁ two ▁ sets ▁ is ▁ " << findMin ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minDifference ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int y = sum / 2 + 1 ; bool dp [ y ] , dd [ y ] ; for ( int i = 0 ; i < y ; i ++ ) { dp [ i ] = dd [ i ] = false ; } dd [ 0 ] = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j + arr [ i ] < y ; j ++ ) { if ( dp [ j ] ) dd [ j + arr [ i ] ] = true ; } for ( int j = 0 ; j < y ; j ++ ) { if ( dd [ j ] ) dp [ j ] = true ; } } for ( int i = y - 1 ; i >= 0 ; i -- ) { if ( dp [ i ] ) return ( sum - 2 * i ) ; } } int main ( ) { int arr [ ] = { 1 , 6 , 11 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ Minimum ▁ difference ▁ of ▁ 2 ▁ sets ▁ is ▁ " << minDifference ( arr , n ) << ' ' ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ; } int main ( ) { cout << countP ( 3 , 2 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countP ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; } int main ( ) { cout << countP ( 5 , 2 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; } int main ( ) { int dist = 4 ; cout << printCountRec ( dist ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int printCountDP ( int dist ) { int ways [ 3 ] , n = dist ; ways [ 0 ] = 1 ; ways [ 1 ] = 1 ; ways [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) ways [ i % 3 ] = ways [ ( i - 1 ) % 3 ] + ways [ ( i - 2 ) % 3 ] + ways [ ( i - 3 ) % 3 ] ; return ways [ n % 3 ] ; } int main ( ) { int dist = 4 ; cout << printCountDP ( dist ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool has4 ( int x ) ; int countNumbersWith4 ( int n ) { for ( int x = 1 ; x <= n ; x ++ ) result += has4 ( x ) ? 1 : 0 ; return result ; } bool has4 ( int x ) { while ( x != 0 ) { if ( x % 10 == 4 ) return true ; x = x / 10 ; } return false ; } int main ( ) { int n = 328 ; cout << " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ a ▁ digit ▁ is ▁ " << countNumbersWith4 ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = log10 ( n ) ; int * a = new int [ d + 1 ] ; a [ 0 ] = 0 , a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ceil ( pow ( 10 , i - 1 ) ) ; int p = ceil ( pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; } int main ( ) { int n = 328 ; cout << " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ a ▁ digit ▁ is ▁ " << countNumbersWith4 ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; int minRemovalsDP ( int arr [ ] , int n ) { int longest_start = -1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = INT_MAX , max = INT_MIN ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) min = val ; if ( val > max ) max = val ; if ( 2 * min <= max ) break ; if ( end - start > longest_end - longest_start longest_start == -1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == -1 ) return n ; return ( n - ( longest_end - longest_start + 1 ) ) ; } int main ( ) { int arr [ ] = { 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minRemovalsDP ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int optimalStrategyOfGame ( int * arr , int n ) { int table [ n ] [ n ] ; for ( int gap = 0 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) { int x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; int y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; int z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; } int main ( ) { int arr1 [ ] = { 8 , 15 , 3 , 7 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; printf ( " % d STRNEWLINE " , optimalStrategyOfGame ( arr1 , n ) ) ; int arr2 [ ] = { 2 , 2 , 2 , 2 } ; n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printf ( " % d STRNEWLINE " , optimalStrategyOfGame ( arr2 , n ) ) ; int arr3 [ ] = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; printf ( " % d STRNEWLINE " , optimalStrategyOfGame ( arr3 , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; bool part [ sum / 2 + 1 ] ; for ( i = 0 ; i <= sum / 2 ; i ++ ) { part [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = sum / 2 ; j >= arr [ i ] ; if ( part [ j - arr [ i ] ] == 1 j == arr [ i ] ) part [ j ] = 1 ; } } return part [ sum / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << " Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ of ▁ equal ▁ " " sum " ; else cout << " Can ▁ not ▁ be ▁ divided ▁ into " << " ▁ two ▁ subsets ▁ of ▁ equal ▁ sum " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int r ) { if ( r > n ) return 0 ; long long int m = 1000000007 ; long long int inv [ r + 1 ] = { 0 } ; inv [ 0 ] = 1 ; if ( r + 1 >= 2 ) inv [ 1 ] = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { inv [ i ] = m - ( m / i ) * inv [ m % i ] % m ; } int ans = 1 ; for ( int i = 2 ; i <= r ; i ++ ) { ans = ( ( ans % m ) * ( inv [ i ] % m ) ) % m ; } for ( int i = n ; i >= ( n - r + 1 ) ; i -- ) { ans = ( ( ans % m ) * ( i % m ) ) % m ; } return ans ; } int main ( ) { int n = 5 , r = 2 ; cout << " Value ▁ of ▁ C ( " << n << " , ▁ " << r << " ) ▁ is ▁ " << binomialCoeff ( n , r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100 ] [ 100 ] ; int matrixChainMemoised ( int * p , int i , int j ) { if ( i == j ) { return 0 ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] = INT_MAX ; for ( int k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , matrixChainMemoised ( p , i , k ) + matrixChainMemoised ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) ; } return dp [ i ] [ j ] ; } int MatrixChainOrder ( int * p , int n ) { int i = 1 , j = n - 1 ; return matrixChainMemoised ( p , i , j ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; memset ( dp , -1 , sizeof dp ) ; cout << " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " << MatrixChainOrder ( arr , n ) ; }
#include <iostream> NEW_LINE using namespace std ; int checkArray ( int arr [ ] , int N , int k ) { if ( N < 3 ) return -1 ; int i , Sum = 0 , temp = 0 ; for ( i = 0 ; i < N ; i ++ ) Sum += arr [ i ] ; int R = ( k * k + k + 1 ) ; if ( Sum % R != 0 ) return 0 ; int Mid = k * ( Sum / R ) ; for ( i = 1 ; i < N - 1 ; i ++ ) { temp += arr [ i - 1 ] ; if ( arr [ i ] == Mid ) { if ( temp == Mid / k ) return i + 1 ; else return 0 ; } } return 0 ; } int main ( ) { int arr [ ] = { 5 , 1 , 4 , 20 , 6 , 15 , 9 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << checkArray ( arr , N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumPalindromicStrings ( string S ) { int N = S . length ( ) ; vector < int > freq ( 26 ) ; for ( int i = 0 ; i < N ; i ++ ) { freq [ S [ i ] - ' a ' ] ++ ; } vector < int > oddFreqCharacters ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] & 1 ) { oddFreqCharacters . push_back ( i ) ; freq [ i ] -- ; } freq [ i ] /= 2 ; } vector < string > ans ; if ( oddFreqCharacters . empty ( ) ) { string left = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < freq [ i ] ; j ++ ) { left += char ( i + ' a ' ) ; } } string right = left ; reverse ( right . begin ( ) , right . end ( ) ) ; ans . push_back ( left + right ) ; } else { string middle = " " ; int c = oddFreqCharacters . back ( ) ; oddFreqCharacters . pop_back ( ) ; middle += char ( c + ' a ' ) ; string left = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < freq [ i ] ; j ++ ) { left += char ( i + ' a ' ) ; } } string right = left ; reverse ( right . begin ( ) , right . end ( ) ) ; ans . push_back ( left + middle + right ) ; while ( ! oddFreqCharacters . empty ( ) ) { int c = oddFreqCharacters . back ( ) ; oddFreqCharacters . pop_back ( ) ; string middle = " " ; middle += char ( c + ' a ' ) ; ans . push_back ( middle ) ; } } cout << " [ " ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] ; if ( i != ans . size ( ) - 1 ) { cout << " , ▁ " ; } } cout << " ] " ; return 0 ; } int main ( ) { string S = " geeksforgeeks " ; minimumPalindromicStrings ( S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void possibleEqualArray ( int A [ ] , int N ) { vector < int > pref ( N ) ; pref [ 0 ] = A [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { pref [ i ] = pref [ i - 1 ] ^ A [ i ] ; } if ( pref [ N - 1 ] == 0 ) { cout << " YES " ; return ; } int cur_xor = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { cur_xor ^= A [ i ] ; for ( int j = 0 ; j < i ; j ++ ) { if ( j ) { int middle_xor = pref [ j - 1 ] ^ pref [ i - 1 ] ; int left_xor = pref [ j - 1 ] ; int right_xor = cur_xor ; if ( left_xor == middle_xor && middle_xor == right_xor ) { cout << " YES " ; return ; } } } } cout << " NO " ; } int main ( ) { int A [ ] = { 0 , 2 , 2 } ; int N = sizeof ( A ) / sizeof ( int ) ; possibleEqualArray ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void GenerateArray ( int N , int X ) { int prev_xor = X ; for ( int i = 1 ; i <= N ; i ++ ) { cout << ( i ^ prev_xor ) ; if ( i != N ) { cout << " ▁ " ; } prev_xor = i ; } } int main ( ) { int N = 4 , X = 3 ; cout << " The ▁ generated ▁ array ▁ is ▁ " ; GenerateArray ( N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const long long INF64 = 1000000000000000000ll ; const int N = 200 * 1000 + 13 ; int n ; long long arr [ N ] , brr [ N ] ; void brute ( int ind , long long l , long long r ) { if ( ind == n / 2 ) { for ( int i = 0 ; i < int ( n ) ; i ++ ) printf ( " % lld ▁ " , brr [ i ] ) ; puts ( " " ) ; exit ( 0 ) ; } for ( long long i = l ; i <= arr [ ind ] / 2 ; ++ i ) if ( arr [ ind ] - i <= r ) { brr [ ind ] = i ; brr [ n - ind - 1 ] = arr [ ind ] - i ; brute ( ind + 1 , i , arr [ ind ] - i ) ; } } int main ( ) { n = 2 ; n *= 2 ; arr [ 0 ] = 5 ; arr [ 1 ] = 6 ; brute ( 0 , 0 , INF64 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCount ( int N , int K ) { int SmallestNumber [ 10 ] ; int MinimumSteps [ 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) { SmallestNumber [ i ] = INT_MAX ; MinimumSteps [ i ] = INT_MAX ; } for ( int i = 1 ; i <= 10 ; i ++ ) { int num = K * i ; SmallestNumber [ num % 10 ] = min ( SmallestNumber [ num % 10 ] , num ) ; MinimumSteps [ num % 10 ] = min ( MinimumSteps [ num % 10 ] , i ) ; } if ( N < SmallestNumber [ N % 10 ] ) { return -1 ; } else { return MinimumSteps [ N % 10 ] ; } } int main ( ) { int N = 42 , K = 7 ; cout << minCount ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinSteps ( int arr [ ] , int N ) { int val = 0 ; int mx = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { int curr = arr [ i ] ; mx = max ( mx , curr ) ; val = max ( val , mx - curr ) ; } long long res = 0 ; while ( ( 1LL << res ) - 1 < val ) { ++ res ; } return res ; } int main ( ) { int arr [ ] = { 1 , 7 , 6 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countMinSteps ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int func2 ( int L , int R , int K ) { if ( R - L >= 2 ) return 1 ; return min ( L , L ^ R ) ; } int func3 ( int L , int R , int K ) { if ( ( R ^ L ) > L && ( R ^ L ) < R ) return 0 ; return func2 ( L , R , K ) ; } int func4 ( int L , int R , int K ) { if ( R - L >= 4 ) return 0 ; int minval = L ^ ( L + 1 ) ^ ( L + 2 ) ^ ( L + 3 ) ; return min ( minval , func3 ( L , R , K ) ) ; } int minimumXor ( int L , int R , int K ) { if ( K > 4 ) return 0 ; else if ( K == 4 ) return func4 ( L , R , K ) ; else if ( K == 3 ) return func3 ( L , R , K ) ; else if ( K == 2 ) return func2 ( L , R , K ) ; else return L ; } int main ( ) { int L = 1 , R = 3 , K = 3 ; cout << minimumXor ( L , R , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int setBits ( long n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } void findNthTerm ( int N ) { int x = setBits ( N ^ ( N - 1 ) ) ; cout << x ; } int main ( ) { int N = 8 ; findNthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findEquation ( int A , int B , int C ) { cout << " ( " << C << " ) " << " x ^ 2 ▁ + ( " << B << " ) x ▁ + ▁ ( " << A << " ) ▁ = ▁ 0" ; } int main ( ) { int A = 1 , B = -5 , C = 6 ; findEquation ( A , B , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkPattern ( int arr [ ] , int m , int k , int n ) { int count = 1 , t = 0 ; for ( int i = 0 ; i < n - m ; i ++ ) { if ( arr [ i ] == arr [ i + m ] ) { t ++ ; if ( t == m ) { t = 0 ; count ++ ; if ( count == k ) { return " Yes " ; } } } else { t = 0 ; count = 1 ; } } return " No " ; } int main ( ) { int arr [ ] = { 6 , 1 , 3 , 3 , 3 , 3 } ; int M = 1 , K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << checkPattern ( arr , M , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findOccurrences ( string S , string T ) { int n1 = S . size ( ) ; int n2 = T . size ( ) ; int ans = 0 ; int last = 0 ; for ( int i = 0 ; i <= n1 - n2 ; i ++ ) { bool chk = true ; for ( int j = 0 ; j < n2 ; j ++ ) { if ( T [ j ] != S [ i + j ] ) { chk = false ; break ; } } if ( chk ) { ans += ( i + 1 - last ) * ( n1 - ( i + n2 - 1 ) ) ; last = i + 1 ; } } cout << ans ; } int main ( ) { string S = " dabc " , T = " ab " ; findOccurrences ( S , T ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void LargestArray ( int N , int low , int high ) { int high_index = N - ( high - low + 1 ) ; if ( high_index > ( N - 1 ) / 2 ) { cout << " Not ▁ Possible " ; return ; } if ( high_index <= 0 ) high_index = 1 ; int A [ N ] ; int temp = high ; for ( int i = high_index ; i >= 0 ; i -- ) { A [ i ] = temp -- ; } high -= 1 ; for ( int i = high_index + 1 ; i < N ; i ++ ) A [ i ] = high -- ; for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << ' ▁ ' ; } } int main ( ) { int N = 5 , low = 2 , high = 6 ; LargestArray ( N , low , high ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void flipBitsOfAandB ( int A , int B ) { A = A ^ ( A & B ) ; B = B ^ ( A & B ) ; cout << A << " ▁ " << B ; } int main ( ) { int A = 10 , B = 20 ; flipBitsOfAandB ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isValid ( string s ) { int n = sqrt ( s . length ( ) ) ; char check = s [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = i , y = i ; while ( x >= 0 && y < n ) { if ( s [ ( n * x ) + y ] != check || s [ ( n * y ) + x ] != check ) { cout << " No " << endl ; return ; } x -- ; y ++ ; } } cout << " Yes " << endl ; } int main ( ) { string str = " abacdaeaafaghaia " ; isValid ( str ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a % b == 0 ) return b ; return gcd ( b , a % b ) ; } void printAnswer ( int x , int y ) { int val = gcd ( x , y ) ; if ( ( val & ( val - 1 ) ) == 0 ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int x = 4 ; int y = 7 ; printAnswer ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 10 ; int pref [ N ] , power [ N ] ; int toDigit ( char ch ) { return ( ch - '0' ) ; } void powerOf10 ( ) { power [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) power [ i ] = power [ i - 1 ] * 10 ; } void precomputePrefix ( string str , int n ) { pref [ 0 ] = str [ 0 ] - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + toDigit ( str [ i ] ) ; } int triangularNumber ( int i ) { int res = i * ( i + 1 ) / 2 ; return res ; } int sumOfSubstrings ( string str ) { int n = str . size ( ) ; powerOf10 ( ) ; precomputePrefix ( str , n ) ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += ( pref [ n - i - 2 ] * ( i + 1 ) + toDigit ( str [ n - i - 1 ] ) * triangularNumber ( n - i - 1 ) ) * power [ i ] ; } return ans ; } int main ( ) { string str = "1234" ; cout << sumOfSubstrings ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int OddLengthSum ( vector < int > & arr ) { int sum = 0 ; int l = arr . size ( ) ; for ( int i = 0 ; i < l ; i ++ ) { sum += ( ( ( i + 1 ) * ( l - i ) + 1 ) / 2 ) * arr [ i ] ; } return sum ; } int main ( ) { vector < int > arr = { 1 , 5 , 3 , 1 , 2 } ; cout << OddLengthSum ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sameEulerTotient ( int N ) { return ( N & 1 ) ; } int main ( ) { int N = 13 ; if ( sameEulerTotient ( N ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int arr [ ] , int N ) { map < int , int > M ; for ( int i = 0 ; i < N ; i ++ ) { M [ i ] = arr [ i ] ; } sort ( arr , arr + N ) ; unordered_map < int , int > Count ; for ( int i = 0 ; i < N ; i ++ ) { Count [ arr [ i ] ] = pow ( 2 , N - i - 1 ) ; } for ( auto & it : M ) { cout << Count [ M [ it . second ] ] << ' ▁ ' ; } } int main ( ) { int arr [ ] = { 5 , 2 , 1 } ; int N = sizeof arr / sizeof arr [ 0 ] ; solve ( arr , N ) ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; bool checkOdd ( char ch ) { return ( ( ch - '0' ) & 1 ) ; } string Insert_dash ( string num_str ) { string result_str = num_str ; for ( int x = 0 ; x < num_str . length ( ) - 1 ; x ++ ) { if ( checkOdd ( num_str [ x ] ) && checkOdd ( num_str [ x + 1 ] ) ) { result_str . insert ( x + 1 , " - " ) ; num_str = result_str ; x ++ ; } } return result_str ; } int main ( ) { string str = "1745389" ; cout << Insert_dash ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 3 , M = 3 ; bool checkReverseBitonic ( int arr [ ] , int n ) { int i , j , f = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { f = 1 ; break ; } } if ( i == n ) return true ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) continue ; if ( arr [ i ] == arr [ i - 1 ] ) return false ; else { if ( f == 1 ) return false ; } } return true ; } void check ( int arr [ N ] [ M ] ) { int f = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! checkReverseBitonic ( arr [ i ] , M ) ) { cout << " No " << endl ; return ; } } for ( int i = 0 ; i < N ; i ++ ) { int temp [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { temp [ j ] = arr [ j ] [ i ] ; } if ( ! checkReverseBitonic ( temp , N ) ) { cout << " No " << endl ; return ; } } cout << " Yes " ; } int main ( ) { int m [ N ] [ M ] = { { 2 , 3 , 4 } , { 1 , 2 , 3 } , { 4 , 5 , 6 } } ; check ( m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int SpiralElement ( int x , int y ) { int r ; if ( x < y ) { if ( y % 2 == 1 ) { r = y * y ; return ( r - x + 1 ) ; } else { r = ( y - 1 ) * ( y - 1 ) ; return ( r + x ) ; } } else { if ( x % 2 == 0 ) { r = x * x ; return ( r - y + 1 ) ; } else { r = ( x - 1 ) * ( x - 1 ) ; return ( r + y ) ; } } } int main ( ) { int x = 2 , y = 3 ; cout << SpiralElement ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void string_modify ( string s ) { char alphabets [ 26 ] ; int flag = 0 , hold_i ; char hold_l ; int i ; for ( i = 0 ; i < 26 ; i ++ ) { alphabets [ i ] = i + ' a ' ; } set < int > difference ; string reconstruct = " " ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { difference . insert ( s [ i ] - s [ i - 1 ] ) ; } if ( difference . size ( ) == 1 ) { cout << " No ▁ modifications ▁ required " ; return ; } for ( auto it = difference . begin ( ) ; it != difference . end ( ) ; it ++ ) { int index = s [ 0 ] - ' a ' ; reconstruct = " " ; flag = 0 ; for ( int i = 0 ; i < s . size ( ) && flag <= 1 ; i ++ ) { reconstruct += alphabets [ index ] ; index += * it ; if ( index < 0 ) { index += 26 ; } index %= 26 ; if ( reconstruct [ i ] != s [ i ] ) { flag ++ ; hold_i = i ; hold_l = s [ i ] ; } } if ( flag == 1 ) { s [ hold_i ] = reconstruct [ hold_i ] ; break ; } } if ( flag > 1 ) { hold_i = 0 ; hold_l = s [ 0 ] ; int temp = ( s [ 1 ] - ' a ' - ( s [ 2 ] - s [ 1 ] ) ) % 26 ; if ( temp < 0 ) { temp += 26 ; } s [ 0 ] = alphabets [ temp ] ; } cout << hold_i << " ▁ - > ▁ " << hold_l << endl << s << endl ; } int main ( ) { string s = " aeimqux " ; string_modify ( s ) ; }
#include <iostream> NEW_LINE using namespace std ; void evenSubMatrix ( int N ) { int even = 1 ; int odd = 2 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( i + j ) % 2 == 0 ) { cout << even << " ▁ " ; even += 2 ; } else { cout << odd << " ▁ " ; odd += 2 ; } } cout << " STRNEWLINE " ; } } int main ( ) { int N = 4 ; evenSubMatrix ( N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <regex> NEW_LINE using namespace std ; void removeLeadingZeros ( string str ) { const regex pattern ( " ^ 0 + ( ? ! $ ) " ) ; str = regex_replace ( str , pattern , " " ) ; cout << str ; } int main ( ) { string str = "0001234" ; removeLeadingZeros ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int TotalHammingDistance ( int n ) { int i = 1 , sum = 0 ; while ( n / i > 0 ) { sum = sum + n / i ; i = i * 2 ; } return sum ; } int main ( ) { int N = 9 ; cout << TotalHammingDistance ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum_inversion ( int n , int k ) { int answer = 0 ; k = min ( k , n / 2 ) ; int left = 1 ; int right = n ; while ( k -- ) { answer += 2 * ( right - left ) - 1 ; left ++ ; right -- ; } cout << answer << endl ; } int main ( ) { int N = 5 ; int K = 3 ; maximum_inversion ( N , K ) ; N = 4 ; K = 1 ; maximum_inversion ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; } int oddFirst ( int a , int b ) { int steps_a = getFirstSetBitPos ( a ) ; int steps_b = getFirstSetBitPos ( b ) ; if ( steps_a == steps_b ) { return -1 ; } if ( steps_a > steps_b ) { return b ; } if ( steps_a < steps_b ) { return a ; } } int main ( ) { int a = 10 ; int b = 8 ; cout << oddFirst ( a , b ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool helper ( string & s , int pos ) { int len = s . size ( ) ; if ( pos >= len ) return true ; if ( ! isdigit ( s [ pos ] ) ) return false ; int num = 0 ; for ( int i = pos ; i < len ; i ++ ) { num = num * 10 + s [ pos ] - '0' ; if ( i + 1 + num > len ) return false ; if ( helper ( s , i + 1 + num ) ) return true ; } return false ; } int main ( ) { string s = "123abc4db1c " ; if ( helper ( s , 0 ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long int NEW_LINE #define m  1000000007 NEW_LINE void solve ( long long n ) { long long s = 0 ; for ( int l = 1 ; l <= n ; ) { int r = n / floor ( n / l ) ; int x = ( ( ( r % m ) * ( ( r + 1 ) % m ) ) / 2 ) % m ; int y = ( ( ( l % m ) * ( ( l - 1 ) % m ) ) / 2 ) % m ; int p = ( ( n / l ) % m ) ; s = ( s + ( ( ( x - y ) % m ) * p ) % m + m ) % m ; s %= m ; l = r + 1 ; } cout << ( s + m ) % m ; } signed main ( ) { long long n = 12 ; solve ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; typedef long long int ll ; void solve ( int n , int k ) { int x1 , d ; d = k * ( k + 1 ) ; if ( ( 2 * n ) % d != 0 ) { cout << " - 1" ; return ; } x1 = 2 * n / d ; for ( int i = 1 ; i <= k ; i ++ ) { cout << x1 * i << " ▁ " ; } cout << endl ; } int main ( ) { int n = 10 , k = 4 ; solve ( n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int N ) { if ( N % 2 == 0 ) { cout << N / 2 << " ▁ " << N << endl ; } else { cout << ( N - 1 ) / 2 << " ▁ " << ( N - 1 ) << endl ; } } int main ( ) { int N = 10 ; solve ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findArray ( int * a , int n , int P ) { int mi = * min_element ( a , a + n ) ; int ctr = 0 ; mi = max ( 0 , mi - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] -= mi ; ctr += mi ; } int i = P - 1 ; int start = -1 ; while ( 1 ) { if ( a [ i ] == 0 ) { start = i ; break ; } a [ i ] -= 1 ; ctr += 1 ; i = ( i - 1 + n ) % n ; } a [ start ] = ctr ; for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " , ▁ " ; } } int main ( ) { int N = 5 ; int P = 2 ; int arr [ ] = { 3 , 2 , 0 , 2 , 7 } ; findArray ( arr , N , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_time_to_cut ( int N ) { if ( N == 0 ) return 0 ; return ceil ( log2 ( N ) ) ; } int main ( ) { int N = 100 ; cout << min_time_to_cut ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int k1 = 2 ; int k2 = 2 ; int gap = 5 ; int printPattern ( int i , int j , int n ) { if ( j >= n ) { k1 = 2 ; k2 = 2 ; k1 -- ; k2 ++ ; if ( i == 2 ) { k1 = 0 ; k2 = n - 1 ; } return 0 ; } if ( i >= 3 ) { return 1 ; } if ( j > k2 ) { k1 += gap ; k2 += gap ; } if ( j >= k1 && j <= k2 i == 2 ) { cout << " * " ; } else { cout << " ▁ " ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } cout << endl ; return printPattern ( i + 1 , 0 , n ) ; } int main ( ) { int N = 3 ; printPattern ( 0 , 0 , N * 5 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void stateA ( string ) ; void stateB ( string ) ; void stateC ( string ) ; void stateD ( string ) ; void stateE ( string ) ; void stateF ( string ) ; void checkstateA ( string n ) { if ( n [ 0 ] == '0' ) stateB ( n . substr ( 1 ) ) ; else stateD ( n . substr ( 1 ) ) ; } void stateB ( string n ) { if ( n . length ( ) == 0 ) cout << " string ▁ not ▁ accepted " ; else { if ( n [ 0 ] == '1' ) stateC ( n . substr ( 1 ) ) ; else stateD ( n . substr ( 1 ) ) ; } } void stateC ( string n ) { cout << " String ▁ accepted " ; } void stateD ( string n ) { if ( n . length ( ) == 0 ) cout << " string ▁ not ▁ accepted " ; else { if ( n [ 0 ] == '1' ) stateD ( n . substr ( 1 ) ) ; else stateE ( n . substr ( 1 ) ) ; } } void stateE ( string n ) { if ( n . length ( ) == 0 ) cout << " string ▁ not ▁ accepted " ; else { if ( n [ 0 ] == '0' ) stateE ( n . substr ( 1 ) ) ; else stateF ( n . substr ( 1 ) ) ; } } void stateF ( string n ) { if ( n . length ( ) == 0 ) cout << " string ▁ accepred " ; else { if ( n [ 0 ] == '1' ) stateD ( n . substr ( 1 ) ) ; else stateE ( n . substr ( 1 ) ) ; } } int main ( ) { string n = "0100101" ; checkstateA ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int HogbenNumber ( int a ) { int p = ( pow ( a , 2 ) - a + 1 ) ; return p ; } int main ( ) { int N = 10 ; cout << HogbenNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDistinctSums ( int n ) { set < int > s ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j ++ ) { s . insert ( i + j ) ; } } return s . size ( ) ; } int main ( ) { int N = 3 ; cout << findDistinctSums ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check_string_exist ( string S ) { int size = S . length ( ) ; bool check = true ; for ( int i = 0 ; i < size ; i ++ ) { if ( S [ i ] != S [ ( i + 2 ) % size ] ) { check = false ; break ; } } if ( check ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { string S = " papa " ; check_string_exist ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; } int productinRange ( int l , int r ) { if ( r - l > 9 ) return 0 ; else { int p = 1 ; for ( int i = l ; i <= r ; i ++ ) p *= getProduct ( i ) ; return p ; } } int main ( ) { int l = 11 , r = 15 ; cout << productinRange ( l , r ) << endl ; l = 1 , r = 15 ; cout << productinRange ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthTerm ( int N ) { if ( N == 1 ) { return 2 ; } return ( ( N - 1 ) * 13 ) + nthTerm ( N - 1 ) ; } int main ( ) { int N = 17 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSubsequence ( int arr [ ] , int N ) { unordered_map < int , int > M ; for ( int i = 0 ; i < N ; i ++ ) { M [ arr [ i ] ] ++ ; } int distinct_size = M . size ( ) ; int maxFreq = 1 ; for ( auto & it : M ) { maxFreq = max ( maxFreq , it . second ) ; } cout << max ( min ( distinct_size , maxFreq - 1 ) , min ( distinct_size - 1 , maxFreq ) ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximumSubsequence ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrayConstruct ( int N ) { for ( int i = 2 ; i <= N ; i = i + 2 ) cout << i << " ▁ " ; for ( int i = 1 ; i < N - 1 ; i = i + 2 ) cout << i << " ▁ " ; cout << N - 1 + ( N / 2 ) << endl ; } void createArray ( int N ) { if ( N % 4 == 0 ) arrayConstruct ( N ) ; else cout << -1 << endl ; } int main ( ) { int N = 8 ; createArray ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinctSubstring ( string & P , string & Q , int K , int N ) { unordered_set < string > S ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; string s ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; sum += Q [ pos ] - '0' ; s += P [ j ] ; if ( sum <= K ) { S . insert ( s ) ; } else { break ; } } } return S . size ( ) ; } int main ( ) { string S = " abcde " ; string W = "12345678912345678912345678" ; int K = 5 ; int N = S . length ( ) ; cout << distinctSubstring ( S , W , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinctSubstring ( string & P , string & Q , int K , int N ) { unordered_set < string > S ; for ( int i = 0 ; i < N ; ++ i ) { int sum = 0 ; string s ; for ( int j = i ; j < N ; ++ j ) { int pos = P [ j ] - ' a ' ; sum += Q [ pos ] - '0' ; s += P [ j ] ; if ( sum <= K ) { S . insert ( s ) ; } else { break ; } } } return S . size ( ) ; } int main ( ) { string P = " abcde " ; string Q = "12345678912345678912345678" ; int K = 5 ; int N = P . length ( ) ; cout << distinctSubstring ( P , Q , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPattern ( int n ) { int i , j ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j < 2 * n ; j ++ ) { if ( j == ( n - i + 1 ) || j == ( n + i - 1 ) ) { cout << " * ▁ " ; } else if ( ( i >= 4 && i <= n - 4 ) && ( j == n - i + 4 j == n + i - 4 ) ) { cout << " * ▁ " ; } else if ( i == n || ( i == n - 4 && j >= n - ( n - 2 * 4 ) && j <= n + n - 2 * 4 ) ) { cout << " * ▁ " ; } else { cout << " ▁ " << " ▁ " ; } } cout << " STRNEWLINE " ; } } int main ( ) { int N = 9 ; printPattern ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isKAlternating ( string s , int k ) { if ( s . length ( ) < k ) return false ; int checker = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int bitAtIndex = s [ i ] - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } for ( int i = k ; i < s . length ( ) ; i ++ ) if ( s [ i - k ] != s [ i ] ) return false ; return true ; } int main ( ) { string str = " acdeac " ; int K = 4 ; if ( isKAlternating ( str , K ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int MAX = 100000 ; void findFactors ( int N ) { int temp = sqrt ( N ) ; int factor [ MAX ] = { 1 } ; int i , j , k ; int len1 = 1 ; while ( temp % 2 == 0 ) { factor [ len1 ++ ] = 2 ; factor [ len1 ++ ] = 2 ; temp /= 2 ; } for ( j = 3 ; j < sqrt ( temp ) ; j += 2 ) { while ( temp % j == 0 ) { factor [ len1 ++ ] = j ; factor [ len1 ++ ] = j ; temp /= j ; } } if ( temp > 2 ) { factor [ len1 ++ ] = temp ; factor [ len1 ++ ] = temp ; } int M [ len1 ] [ MAX ] = { 0 } ; int tpc = 0 , tpr = 0 ; M [ 0 ] [ 0 ] = 1 ; j = 1 ; while ( j < len1 ) { if ( factor [ j ] != factor [ j - 1 ] ) { tpr ++ ; M [ tpr ] [ 0 ] = factor [ j ] ; j ++ ; tpc = 1 ; } else { M [ tpr ] [ tpc ] = M [ tpr ] [ tpc - 1 ] * factor [ j ] ; j ++ ; tpc ++ ; } } int arr1 [ MAX ] , arr2 [ MAX ] ; int l1 , l2 ; l1 = l2 = 1 ; arr1 [ 0 ] = arr2 [ 0 ] = 1 ; for ( i = 1 ; i < tpr + 1 ; i ++ ) { for ( j = 0 ; M [ i ] [ j ] != 0 ; j ++ ) { for ( k = 0 ; k < l1 ; k ++ ) { arr2 [ l2 ++ ] = arr1 [ k ] * M [ i ] [ j ] ; } } for ( j = l1 ; j < l2 ; j ++ ) { arr1 [ j ] = arr2 [ j ] ; } l1 = l2 ; } for ( i = 0 ; i < l2 ; i ++ ) { cout << arr2 [ i ] << ' ▁ ' ; } } int main ( ) { int N = 900 ; findFactors ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int matrix [ 100 ] [ 100 ] ; void printRequiredMatrix ( int n ) { if ( n == 1 ) { cout << "1" << " STRNEWLINE " ; } else if ( n % 2 != 0 ) { cout << " - 1" << " STRNEWLINE " ; } else { for ( int i = 0 ; i < n ; i ++ ) { matrix [ i ] [ i ] = n ; } int u = n - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { matrix [ i ] [ u ] = i + 1 ; for ( int j = 1 ; j < n / 2 ; j ++ ) { int a = ( i + j ) % ( n - 1 ) ; int b = ( i - j + n - 1 ) % ( n - 1 ) ; if ( a < b ) swap ( a , b ) ; matrix [ b ] [ a ] = i + 1 ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) matrix [ i ] [ j ] = matrix [ j ] [ i ] + n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << matrix [ i ] [ j ] << " ▁ " ; cout << " STRNEWLINE " ; } } cout << " STRNEWLINE " ; } int main ( ) { int n = 1 ; printRequiredMatrix ( n ) ; n = 3 ; printRequiredMatrix ( n ) ; n = 6 ; printRequiredMatrix ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstring ( string & S , int & n ) { int ans = 0 ; int i = 0 ; while ( i < n ) { int cnt0 = 0 , cnt1 = 0 ; if ( S [ i ] == '0' ) { while ( i < n && S [ i ] == '0' ) { cnt0 ++ ; i ++ ; } int j = i ; while ( j < n && S [ j ] == '1' ) { cnt1 ++ ; j ++ ; } } else { while ( i < n && S [ i ] == '1' ) { cnt1 ++ ; i ++ ; } int j = i ; while ( j < n && S [ j ] == '0' ) { cnt0 ++ ; j ++ ; } } ans += min ( cnt0 , cnt1 ) ; } return ans ; } int main ( ) { string S = "0001110010" ; int n = S . length ( ) ; cout << countSubstring ( S , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void decToOctal ( int n ) { int octalNum [ 100 ] ; int i = 0 ; while ( n != 0 ) { octalNum [ i ] = n % 8 ; n = n / 8 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) cout << octalNum [ j ] ; cout << " STRNEWLINE " ; } void nDigitPerfectSquares ( int n ) { int decimal = pow ( ceil ( sqrt ( pow ( 8 , n ) ) ) - 1 , 2 ) ; decToOctal ( decimal ) ; } int main ( ) { int n = 2 ; nDigitPerfectSquares ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > zArray ( vector < int > arr ) { int n = arr . size ( ) ; vector < int > z ( n ) ; int r = 0 , l = 0 ; for ( int k = 1 ; k < n ; k ++ ) { if ( k > r ) { r = l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } else { int k1 = k - l ; if ( z [ k1 ] < r - k + 1 ) z [ k ] = z [ k1 ] ; else { l = k ; while ( r < n && arr [ r ] == arr [ r - l ] ) r ++ ; z [ k ] = r - l ; r -- ; } } } return z ; } vector < int > mergeArray ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; int m = B . size ( ) ; vector < int > z ; vector < int > c ( n + m + 1 ) ; for ( int i = 0 ; i < m ; i ++ ) c [ i ] = B [ i ] ; c [ m ] = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) c [ m + i + 1 ] = A [ i ] ; z = zArray ( c ) ; return z ; } void findZArray ( vector < int > A , vector < int > B , int n ) { int flag = 0 ; vector < int > z ; z = mergeArray ( A , B ) ; for ( int i = 0 ; i < z . size ( ) ; i ++ ) { if ( z [ i ] == n ) { cout << ( i - n - 1 ) << " ▁ " ; flag = 1 ; } } if ( flag == 0 ) { cout << ( " Not ▁ Found " ) ; } } int main ( ) { vector < int > A { 1 , 2 , 3 , 2 , 3 , 2 } ; vector < int > B { 2 , 3 } ; int n = B . size ( ) ; findZArray ( A , B , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool Formatted ( string s ) { vector < char > k ; int i = 0 ; while ( i < s . size ( ) ) { if ( s [ i ] == ' ) ' or s [ i ] == ' ( ' ) { k . push_back ( s [ i ] ) ; i += 1 ; } else { char st ; while ( s [ i ] != ' ) ' and s [ i ] != ' ) ' ) { st = s [ i ] ; i = i + 1 ; } k . push_back ( st ) ; } } int depth = 0 , flag = 1 ; int open = 0 , close = 0 ; for ( char i : k ) { if ( i == ' ( ' ) { depth += 1 ; open += 1 ; } else if ( i == ' ) ' ) { depth -= 1 ; close += 1 ; } else { if ( i - '0' != depth ) { flag = 0 ; break ; } } } if ( open != close ) flag = 0 ; return ( flag == 1 ) ? true : false ; } int main ( ) { string s = " ( (2 ) ( (3 ) ) ) " ; bool k = Formatted ( s ) ; if ( k == true ) printf ( " Yes " ) ; else printf ( " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int * arr , int n , int k ) { if ( k <= n - 2 ) return ( arr [ n - 1 ] - arr [ 0 ] ) ; return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 1 ; cout << findSum ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubStr ( string str , int n ) { int count0 = 0 , count1 = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { count0 ++ ; } else { count1 ++ ; } if ( count0 == count1 ) { cnt ++ ; } } if ( cnt == 0 ) { return -1 ; } return cnt ; } int main ( ) { string str = "0100110101" ; int n = str . length ( ) ; cout << maxSubStr ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lli  long long int NEW_LINE lli squareDigitSum ( string s ) { lli lengthN = s . length ( ) ; lli result = ( lengthN / 9 ) * 81 + pow ( ( lengthN % 9 ) , 2 ) ; return result ; } int main ( ) { string s = "1111" ; cout << squareDigitSum ( s ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; string getString ( char x ) { string s ( 1 , x ) ; return s ; } bool solve ( string s1 , string s2 ) { string a = getString ( s1 [ 0 ] ) , b = getString ( s2 [ 0 ] ) ; for ( int i = 1 ; i < s1 . length ( ) ; i ++ ) if ( s1 [ i ] != s1 [ i - 1 ] ) { a += getString ( s1 [ i ] ) ; } for ( int i = 1 ; i < s2 . length ( ) ; i ++ ) if ( s2 [ i ] != s2 [ i - 1 ] ) { b += getString ( s2 [ i ] ) ; } if ( a == b ) return true ; return false ; } int main ( ) { string s1 = " Geeks " , s2 = " Geks " ; if ( solve ( s1 , s2 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define x  26 NEW_LINE #define mod  3001 NEW_LINE using namespace std ; int CntSubstr ( string s , int l ) { int hash = 0 ; for ( int i = 0 ; i < l ; i ++ ) { hash = ( hash * x + ( s [ i ] - 97 ) ) % mod ; } int pow_l = 1 ; for ( int i = 0 ; i < l - 1 ; i ++ ) pow_l = ( pow_l * x ) % mod ; unordered_set < int > result ; result . insert ( hash ) ; for ( int i = l ; i < s . size ( ) ; i ++ ) { hash = ( ( hash - pow_l * ( s [ i - l ] - 97 ) + 2 * mod ) * x + ( s [ i ] - 97 ) ) % mod ; result . insert ( hash ) ; } cout << result . size ( ) << endl ; } int main ( ) { string s = " abcba " ; int l = 2 ; CntSubstr ( s , l ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidString ( string str , int n ) { int index = find ( str . begin ( ) , str . end ( ) , ' b ' ) - str . begin ( ) ; if ( index == 0 ) return false ; while ( index <= n - 1 ) { if ( str [ index - 1 ] != ' a ' ) return false ; if ( index + 1 < n && str [ index + 1 ] != ' b ' ) return false ; if ( index + 2 < n && str [ index + 2 ] == ' b ' ) return false ; if ( index == n - 1 ) return false ; index = find ( str . begin ( ) + index + 2 , str . end ( ) , ' b ' ) - str . begin ( ) ; } return true ; } int main ( ) { string str = " abbaaabbabba " ; int n = str . length ( ) ; isValidString ( str , n ) ? cout << " true " : cout << " false " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool endsWith ( string str , string pat ) { int patLen = pat . length ( ) ; int strLen = str . length ( ) ; if ( patLen > strLen ) return false ; patLen -- ; strLen -- ; while ( patLen >= 0 ) { if ( pat [ patLen ] != str [ strLen ] ) return false ; patLen -- ; strLen -- ; } return true ; } int countOfStrings ( string pat , int n , string sArr [ ] ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( endsWith ( sArr [ i ] , pat ) ) count ++ ; return count ; } int main ( ) { string pat = " ks " ; int n = 4 ; string sArr [ ] = { " geeks " , " geeksforgeeks " , " games " , " unit " } ; cout << countOfStrings ( pat , n , sArr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( string a , string b ) { if ( b . length ( ) % a . length ( ) != 0 ) return -1 ; int count = b . length ( ) / a . length ( ) ; string str = " " ; for ( int i = 0 ; i < count ; i ++ ) { str = str + a ; } if ( str == b ) return count ; return -1 ; } int main ( ) { string a = " geeks " ; string b = " geeksgeeks " ; cout << ( getCount ( a , b ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll getSum ( ll n , int d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; ll k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; } int main ( ) { ll n = 30 ; int d = 3 ; cout << getSum ( n , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > getFrequencyMap ( int arr [ ] , int n ) { map < int , int > hashMap ; for ( int i = 0 ; i < n ; i ++ ) { hashMap [ arr [ i ] ] ++ ; } return hashMap ; } bool hasDigit ( map < int , int > * hashMap , int digit ) { if ( ( * hashMap ) [ digit ] ) { ( * hashMap ) [ digit ] -- ; return true ; } return false ; } string getMaxtime_value ( int arr [ ] , int n ) { map < int , int > hashMap = getFrequencyMap ( arr , n ) ; int i ; bool flag ; string time_value = " " ; flag = false ; for ( i = 2 ; i >= 0 ; i -- ) { if ( hasDigit ( & hashMap , i ) ) { flag = true ; time_value += ( char ) i + 48 ; break ; } } if ( ! flag ) return " - 1" ; flag = false ; if ( time_value [ 0 ] == '2' ) { for ( i = 3 ; i >= 0 ; i -- ) { if ( hasDigit ( & hashMap , i ) ) { flag = true ; time_value += ( char ) i + 48 ; break ; } } } else { for ( i = 9 ; i >= 0 ; i -- ) { if ( hasDigit ( & hashMap , i ) ) { flag = true ; time_value += ( char ) i + 48 ; break ; } } } if ( ! flag ) return " - 1" ; time_value += " : " ; flag = false ; for ( i = 5 ; i >= 0 ; i -- ) { if ( hasDigit ( & hashMap , i ) ) { flag = true ; time_value += ( char ) i + 48 ; break ; } } if ( ! flag ) return " - 1" ; flag = false ; for ( i = 9 ; i >= 0 ; i -- ) { if ( hasDigit ( & hashMap , i ) ) { flag = true ; time_value += ( char ) i + 48 ; break ; } } if ( ! flag ) return " - 1" ; return time_value ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << ( getMaxtime_value ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int replace ( string A , string B ) { int n = A . length ( ) , m = B . length ( ) ; int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( A [ i + j ] != B [ j ] ) break ; } if ( j == m ) { count ++ ; i += m - 1 ; } } return count ; } int main ( ) { string str1 = " aaaaaaaa " ; string str2 = " aaa " ; cout << replace ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 6 ; const int m = 8 ; int visited [ n ] [ m ] ; int result [ n ] [ m ] ; int COUNT ; bool is_valid ( int x , int y , int key , int input [ n ] [ m ] ) { if ( x < n && y < m && x >= 0 && y >= 0 ) { if ( visited [ x ] [ y ] == false && input [ x ] [ y ] == key ) return true ; else return false ; } else return false ; } void BFS ( int x , int y , int i , int j , int input [ n ] [ m ] ) { if ( x != y ) return ; visited [ i ] [ j ] = 1 ; COUNT ++ ; int x_move [ ] = { 0 , 0 , 1 , -1 } ; int y_move [ ] = { 1 , -1 , 0 , 0 } ; for ( int u = 0 ; u < 4 ; u ++ ) if ( is_valid ( i + y_move [ u ] , j + x_move [ u ] , x , input ) ) BFS ( x , y , i + y_move [ u ] , j + x_move [ u ] , input ) ; } void reset_visited ( ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) visited [ i ] [ j ] = 0 ; } void reset_result ( int key , int input [ n ] [ m ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( visited [ i ] [ j ] && input [ i ] [ j ] == key ) result [ i ] [ j ] = visited [ i ] [ j ] ; else result [ i ] [ j ] = 0 ; } } } void print_result ( int res ) { cout << " The ▁ largest ▁ connected ▁ " << " component ▁ of ▁ the ▁ grid ▁ is ▁ : " << res << " STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( result [ i ] [ j ] ) cout << result [ i ] [ j ] << " ▁ " ; else cout << " . ▁ " ; } cout << " STRNEWLINE " ; } } void computeLargestConnectedGrid ( int input [ n ] [ m ] ) { int current_max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { reset_visited ( ) ; COUNT = 0 ; if ( j + 1 < m ) BFS ( input [ i ] [ j ] , input [ i ] [ j + 1 ] , i , j , input ) ; if ( COUNT >= current_max ) { current_max = COUNT ; reset_result ( input [ i ] [ j ] , input ) ; } reset_visited ( ) ; COUNT = 0 ; if ( i + 1 < n ) BFS ( input [ i ] [ j ] , input [ i + 1 ] [ j ] , i , j , input ) ; if ( COUNT >= current_max ) { current_max = COUNT ; reset_result ( input [ i ] [ j ] , input ) ; } } } print_result ( current_max ) ; } int main ( ) { int input [ n ] [ m ] = { { 1 , 4 , 4 , 4 , 4 , 3 , 3 , 1 } , { 2 , 1 , 1 , 4 , 3 , 3 , 1 , 1 } , { 3 , 2 , 1 , 1 , 2 , 3 , 2 , 1 } , { 3 , 3 , 2 , 1 , 2 , 2 , 2 , 2 } , { 3 , 1 , 3 , 1 , 1 , 4 , 4 , 4 } , { 1 , 1 , 3 , 1 , 1 , 4 , 4 , 4 } } ; computeLargestConnectedGrid ( input ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void split ( string str ) { int len = str . length ( ) ; if ( len == 1 ) { cout << ( " Not ▁ Possible " ) ; return ; } string s1 = " " , s2 = " " ; long num1 , num2 ; for ( int i = 0 ; i <= len / 2 ; i ++ ) { int flag = 0 ; s1 = str . substr ( 0 , i + 1 ) ; num1 = stoi ( ( s1 ) ) ; num2 = num1 + 1 ; s2 = to_string ( num2 ) ; int k = i + 1 ; while ( flag == 0 ) { int l = s2 . length ( ) ; if ( k + l > len ) { flag = 1 ; break ; } if ( ( str . substr ( k , k + l ) == s2 ) ) { flag = 0 ; num2 ++ ; k = k + l ; if ( k == len ) break ; s2 = to_string ( num2 ) ; l = s2 . length ( ) ; if ( k + 1 > len ) { flag = 1 ; break ; } } else flag = 1 ; } if ( flag == 0 ) { cout << " Possible ▁ " << s1 << endl ; break ; } else if ( flag == 1 && i > len / 2 - 1 ) { cout << " Not ▁ Possible " << endl ; break ; } } } int main ( ) { string str = "99100" ; split ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ARRAY_SIZE ( a )  (sizeof(a) / sizeof(*a)) NEW_LINE int internalSearch ( string needle , int row , int col , string hay [ ] , int row_max , int col_max , int xx ) { int found = 0 ; if ( row >= 0 && row <= row_max && col >= 0 && col <= col_max && needle [ xx ] == hay [ row ] [ col ] ) { char match = needle [ xx ] ; xx += 1 ; hay [ row ] [ col ] = 0 ; if ( needle [ xx ] == 0 ) { found = 1 ; } else { found += internalSearch ( needle , row , col + 1 , hay , row_max , col_max , xx ) ; found += internalSearch ( needle , row , col - 1 , hay , row_max , col_max , xx ) ; found += internalSearch ( needle , row + 1 , col , hay , row_max , col_max , xx ) ; found += internalSearch ( needle , row - 1 , col , hay , row_max , col_max , xx ) ; } hay [ row ] [ col ] = match ; } return found ; } int searchString ( string needle , int row , int col , string str [ ] , int row_count , int col_count ) { int found = 0 ; int r , c ; for ( r = 0 ; r < row_count ; ++ r ) { for ( c = 0 ; c < col_count ; ++ c ) { found += internalSearch ( needle , r , c , str , row_count - 1 , col_count - 1 , 0 ) ; } } return found ; } int main ( ) { string needle = " MAGIC " ; string input [ ] = { " BBABBM " , " CBMBBA " , " IBABBG " , " GOZBBI " , " ABBBBC " , " MCIGAM " } ; string str [ ARRAY_SIZE ( input ) ] ; int i ; for ( i = 0 ; i < ARRAY_SIZE ( input ) ; ++ i ) { str [ i ] = input [ i ] ; } cout << " count : ▁ " << searchString ( needle , 0 , 0 , str , ARRAY_SIZE ( str ) , str [ 0 ] . size ( ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void KMP ( int m , int n , string str2 , string str1 ) { int pos = 0 , len = 0 ; int p [ m + 1 ] ; int k = 0 ; p [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { while ( k > 0 && str1 [ k ] != str1 [ i - 1 ] ) k = p [ k ] ; if ( str1 [ k ] == str1 [ i - 1 ] ) ++ k ; p [ i ] = k ; } for ( int j = 0 , i = 0 ; i < m ; i ++ ) { while ( j > 0 && str1 [ j ] != str2 [ i ] ) j = p [ j ] ; if ( str1 [ j ] == str2 [ i ] ) j ++ ; if ( j > len ) { len = j ; pos = i - j + 1 ; } } cout << " Shift ▁ = ▁ " << pos << endl ; cout << " Prefix ▁ = ▁ " << str1 . substr ( 0 , len ) ; } int main ( ) { string str1 = " geeksforgeeks " ; string str2 = " forgeeksgeeks " ; int n = str1 . size ( ) ; str2 = str2 + str2 ; KMP ( 2 * n , n , str2 , str1 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countPattern ( string str ) { int len = str . size ( ) ; bool oneSeen = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '1' && oneSeen == 1 ) if ( str [ i - 1 ] == '0' ) count ++ ; if ( str [ i ] == '1' && oneSeen == 0 ) { oneSeen = 1 ; continue ; } if ( str [ i ] != '0' && str [ i ] != '1' ) oneSeen = 0 ; } return count ; } int main ( ) { string str = "100001abc101" ; cout << countPattern ( str ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE void preprocess_strong_suffix ( int * shift , int * bpos , char * pat , int m ) { int i = m , j = m + 1 ; bpos [ i ] = j ; while ( i > 0 ) { while ( j <= m && pat [ i - 1 ] != pat [ j - 1 ] ) { if ( shift [ j ] == 0 ) shift [ j ] = j - i ; j = bpos [ j ] ; } i -- ; j -- ; bpos [ i ] = j ; } } void preprocess_case2 ( int * shift , int * bpos , char * pat , int m ) { int i , j ; j = bpos [ 0 ] ; for ( i = 0 ; i <= m ; i ++ ) { if ( shift [ i ] == 0 ) shift [ i ] = j ; if ( i == j ) j = bpos [ j ] ; } } void search ( char * text , char * pat ) { int s = 0 , j ; int m = strlen ( pat ) ; int n = strlen ( text ) ; int bpos [ m + 1 ] , shift [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) shift [ i ] = 0 ; preprocess_strong_suffix ( shift , bpos , pat , m ) ; preprocess_case2 ( shift , bpos , pat , m ) ; while ( s <= n - m ) { j = m - 1 ; while ( j >= 0 && pat [ j ] == text [ s + j ] ) j -- ; if ( j < 0 ) { printf ( " pattern ▁ occurs ▁ at ▁ shift ▁ = ▁ % d STRNEWLINE " , s ) ; s += shift [ 0 ] ; } else s += shift [ j + 1 ] ; } } int main ( ) { char text [ ] = " ABAAAABAACD " ; char pat [ ] = " ABA " ; search ( text , pat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrefix ( char s [ ] , char t [ ] ) { int count = 0 ; for ( int i = 0 ; i < strlen ( t ) ; i ++ ) { if ( count == strlen ( s ) ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; } int main ( ) { char S [ ] = " digger " ; char T [ ] = " biggerdiagram " ; cout << maxPrefix ( S , T ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void translate ( char * str ) { if ( str [ 0 ] == ' ' ) return ; for ( int i = 1 ; str [ i ] != ' ' ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; for ( int j = i ; str [ j ] != ' ' ; j ++ ) str [ j ] = str [ j + 1 ] ; } } return ; } int main ( ) { char str [ ] = " helloABworldABGfG " ; translate ( str ) ; printf ( " The ▁ modified ▁ string ▁ is ▁ : STRNEWLINE " ) ; printf ( " % s " , str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ROW  3 NEW_LINE #define COL  5 NEW_LINE bool isvalid ( int row , int col , int prevRow , int prevCol ) { return ( row >= 0 ) && ( row < ROW ) && ( col >= 0 ) && ( col < COL ) && ! ( row == prevRow && col == prevCol ) ; } int rowNum [ ] = { -1 , -1 , -1 , 0 , 0 , 1 , 1 , 1 } ; int colNum [ ] = { -1 , 0 , 1 , -1 , 1 , -1 , 0 , 1 } ; void DFS ( char mat [ ] [ COL ] , int row , int col , int prevRow , int prevCol , char * word , string path , int index , int n ) { if ( index > n mat [ row ] [ col ] != word [ index ] ) return ; path += string ( 1 , word [ index ] ) + " ( " + to_string ( row ) + " , ▁ " + to_string ( col ) + " ) ▁ " ; if ( index == n ) { cout << path << endl ; return ; } for ( int k = 0 ; k < 8 ; ++ k ) if ( isvalid ( row + rowNum [ k ] , col + colNum [ k ] , prevRow , prevCol ) ) DFS ( mat , row + rowNum [ k ] , col + colNum [ k ] , row , col , word , path , index + 1 , n ) ; } void findWords ( char mat [ ] [ COL ] , char * word , int n ) { for ( int i = 0 ; i < ROW ; ++ i ) for ( int j = 0 ; j < COL ; ++ j ) if ( mat [ i ] [ j ] == word [ 0 ] ) DFS ( mat , i , j , -1 , -1 , word , " " , 0 , n ) ; } int main ( ) { char mat [ ROW ] [ COL ] = { { ' B ' , ' N ' , ' E ' , ' Y ' , ' S ' } , { ' H ' , ' E ' , ' D ' , ' E ' , ' S ' } , { ' S ' , ' G ' , ' N ' , ' D ' , ' E ' } } ; char word [ ] = " DES " ; findWords ( mat , word , strlen ( word ) - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string generateNumber ( string number ) { int temp = 0 , adding_number = 0 ; string result = " " ; int len = number . size ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { int digit = number [ i ] - '0' ; if ( temp % 2 == 0 ) { adding_number += 1 ; digit += adding_number ; if ( digit >= 10 ) { digit %= 9 ; if ( digit == 0 ) digit = 9 ; } } result = to_string ( digit ) + result ; temp += 1 ; } return result ; } int main ( ) { string S = "1345" ; cout << generateNumber ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findK ( string s , char c ) { int n = s . length ( ) ; int diff ; int max = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == c ) { diff = i - prev ; prev = i ; if ( diff > max ) { max = diff ; } } } if ( max == 0 ) return -1 ; return max ; } int main ( ) { string S = " abdegb " ; char ch = ' b ' ; cout << findK ( S , ch ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubsequence ( string S , int N , int K ) { int C = 0 , C1 = 0 , C0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) C1 ++ ; else if ( S [ i ] == '0' ) C0 ++ ; } int B1 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) B1 ++ ; else if ( S [ i ] == '0' ) C = C + ( C1 - B1 ) ; } int ans = C * K ; ans += ( C1 * C0 * ( ( ( K ) * ( K - 1 ) ) / 2 ) ) ; return ans ; } int main ( ) { string S = "230013110087" ; int K = 2 ; int N = S . length ( ) ; cout << countSubsequence ( S , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSwaps ( string s ) { int ones = 0 , zeros = 0 ; int N = s . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) ones ++ ; else zeros ++ ; } if ( ( N % 2 == 0 && ones != zeros ) || ( N % 2 == 1 && abs ( ones - zeros ) != 1 ) ) { return -1 ; } int ans_1 = 0 ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) { ans_1 += abs ( j - i ) ; j += 2 ; } } int ans_0 = 0 ; int k = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '0' ) { ans_0 += abs ( k - i ) ; k += 2 ; } } if ( N % 2 == 0 ) return min ( ans_1 , ans_0 ) ; else { if ( ones > zeros ) return ans_1 ; else return ans_0 ; } } int main ( ) { string S = "110100" ; cout << minSwaps ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < string > TotalPossibleJumps ( int N ) { if ( ( N - 1 ) == 0 ) { vector < string > newvec ; newvec . push_back ( " " ) ; return newvec ; } else { if ( N < 0 ) { vector < string > newvec ; return newvec ; } } vector < string > jump1 = TotalPossibleJumps ( N - 1 ) ; vector < string > jump2 = TotalPossibleJumps ( N - 2 ) ; vector < string > totaljumps ; for ( string s : jump1 ) { totaljumps . push_back ( "1" + s ) ; } for ( string s : jump2 ) { totaljumps . push_back ( "2" + s ) ; } return totaljumps ; } int main ( ) { int N = 3 ; vector < string > Ans = TotalPossibleJumps ( N ) ; for ( auto & it : Ans ) cout << it << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findString ( vector < string > & arr , int N ) { string ans = " " ; for ( int i = 0 ; i < N ; i ++ ) { ans += arr [ i ] [ i ] == '0' ? '1' : '0' ; } return ans ; } int main ( ) { vector < string > arr { "111" , "011" , "001" } ; int N = arr . size ( ) ; cout << findString ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void commonSubstring ( string s ) { int n = s . size ( ) ; int i = 0 ; int j = n - 1 ; string ans = " " ; while ( j >= 0 ) { if ( s [ i ] == s [ j ] ) { ans += s [ i ] ; i ++ ; j -- ; } else { break ; } } if ( ans . size ( ) == 0 ) cout << " False " ; else { cout << " True ▁ STRNEWLINE " << ans ; } } int main ( ) { string S = " abca " ; commonSubstring ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinimumSubsequence ( string S ) { bool flag = false ; string dummy ; for ( int j = 0 ; j < S . length ( ) ; j ++ ) { if ( S [ j ] != '2' && S [ j ] != '3' && S [ j ] != '5' && S [ j ] != '7' ) { cout << 1 ; flag = true ; break ; } } if ( ! flag ) { for ( int j = 0 ; j < S . length ( ) - 1 ; j ++ ) { for ( int j1 = j + 1 ; j1 < S . length ( ) ; j1 ++ ) { dummy = S [ j ] + S [ j1 ] ; if ( dummy != "23" && dummy != "37" && dummy != "53" && dummy != "73" ) { cout << 2 ; } if ( flag = true ) break ; } if ( flag = true ) break ; } } if ( ! flag ) { if ( S . length ( ) >= 3 ) { cout << 3 ; } else { cout << -1 ; } } } int main ( ) { string S = "237" ; findMinimumSubsequence ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 505 ] [ 505 ] , choose [ 502 ] [ 502 ] ; int calc ( int l , int r , string & s ) { if ( abs ( r - l ) % 2 == 0 ) { return 0 ; } if ( l > r ) { return dp [ l ] [ r ] = 1 ; } if ( dp [ l ] [ r ] != -1 ) { return dp [ l ] [ r ] ; } if ( ( r - l ) == 1 ) { if ( s [ l ] == s [ r ] ) { dp [ l ] [ r ] = 1 ; } else { dp [ l ] [ r ] = 0 ; } return dp [ l ] [ r ] ; } int ans = 0 ; for ( int k = l + 1 ; k <= r ; k += 2 ) { int temp = 1 ; if ( s [ l ] == s [ k ] ) { temp = calc ( l + 1 , k - 1 , s ) * calc ( k + 1 , r , s ) * choose [ ( r - l + 1 ) / 2 ] [ ( r - k ) / 2 ] ; ans += temp ; } } return dp [ l ] [ r ] = ans ; } int waysToClearString ( string S ) { memset ( dp , -1 , sizeof ( dp ) ) ; int n = S . length ( ) ; choose [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n / 2 ; ++ i ) { choose [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; ++ j ) { choose [ i ] [ j ] = ( choose [ i - 1 ] [ j ] + choose [ i - 1 ] [ j - 1 ] ) ; } } return calc ( 0 , n - 1 , S ) ; } int main ( ) { string S = " aabccb " ; cout << waysToClearString ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int BalancedStringBySwapping ( string s ) { int unbalancedPair = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( unbalancedPair > 0 && s [ i ] == ' ] ' ) { -- unbalancedPair ; } else if ( s [ i ] == ' [ ' ) { ++ unbalancedPair ; } } return ( unbalancedPair + 1 ) / 2 ; } int main ( ) { string s = " ] ] ] [ [ [ " ; cout << ( BalancedStringBySwapping ( s ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long LL ; const int MOD = 1000000007 ; int exp_mod ( LL a , LL b ) { LL ret = 1 ; for ( ; b ; b >>= 1 , a = a * a % MOD ) { if ( b & 1 ) ret = ret * a % MOD ; } return ret ; } int countOfWays ( string s , int k ) { int N = s . size ( ) ; LL ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '5' s [ i ] == '0' ) { ans = ( ans + exp_mod ( 2 , i ) ) % MOD ; } } LL q = exp_mod ( 2 , N ) ; LL qk = exp_mod ( q , k ) ; LL inv = exp_mod ( q - 1 , MOD - 2 ) ; ans = ans * ( qk - 1 ) % MOD ; ans = ans * inv % MOD ; return ans ; } int main ( ) { string S = "1256" ; int K = 1 ; cout << countOfWays ( S , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printMiddleString ( string S , string T , int N ) { vector < int > a1 ( N + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { a1 [ i + 1 ] = S [ i ] - ' a ' + T [ i ] - ' a ' ; } for ( int i = N ; i >= 1 ; i -- ) { a1 [ i - 1 ] += a1 [ i ] / 26 ; a1 [ i ] %= 26 ; } for ( int i = 0 ; i <= N ; i ++ ) { if ( a1 [ i ] & 1 ) { if ( i + 1 <= N ) { a1 [ i + 1 ] += 26 ; } } a1 [ i ] /= 2 ; } for ( int i = 1 ; i <= N ; i ++ ) { cout << char ( a1 [ i ] + ' a ' ) ; } return 0 ; } int main ( ) { int N = 5 ; string S = " afogk " ; string T = " asdji " ; printMiddleString ( S , T , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char KthCharacter ( string s , string t , long k ) { long f = 1 ; long ss = 2 ; string tmp = " " ; int len = tmp . length ( ) ; while ( len < k ) { long tf = f ; long ts = ss ; while ( tf -- != 0 ) { tmp += s ; } while ( ts -- != 0 ) { tmp += t ; } f += 2 ; ss += 2 ; len = tmp . length ( ) ; } char output = tmp [ k - 1 ] ; return output ; } int main ( ) { string S1 = " a " , S2 = " bc " ; int k = 4 ; char ans = KthCharacter ( S1 , S2 , k ) ; cout << ans ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void makeContiguous ( string S , int N ) { int fst_occur , lst_occur ; for ( int x = 0 ; x < N ; x ++ ) { if ( S [ x ] == '1' ) { fst_occur = x ; break ; } } for ( int x = N - 1 ; x >= 0 ; x -- ) { if ( S [ x ] == '1' ) { lst_occur = x ; break ; } } int count = 0 ; for ( int x = fst_occur ; x <= lst_occur ; x ++ ) { if ( S [ x ] == '0' ) { count ++ ; } } cout << count ; } int main ( ) { string S = "010001011" ; int N = S . size ( ) ; makeContiguous ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int ans = 1 ; for ( int i = 2 ; i <= n ; i ++ ) ans = ans * i ; return ans ; } int findComb ( int N , int M ) { int x = fact ( N + 1 ) ; int y = fact ( M ) ; return ( x * y ) ; } int main ( ) { int N = 2 ; cout << findComb ( N , M ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countCamelCase ( string & S ) { int count = 0 ; for ( int i = 0 ; S [ i ] ; i ++ ) { if ( S [ i ] >= 65 && S [ i ] <= 91 ) { count ++ ; } } cout << count ; } int main ( ) { string S = " ckjkUUYII " ; countCamelCase ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findRepitition ( char a ) { if ( a <= ' z ' && a >= ' a ' ) { return a - ' a ' ; } else if ( a <= ' Z ' && a >= ' A ' ) { return a - ' A ' ; } return 0 ; } void decodeString ( string str ) { string output = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { output . push_back ( str [ i ] ) ; i += findRepitition ( str [ i ] ) ; } cout << " Decrypted ▁ code ▁ is ▁ { " << output << " } " << endl ; } int main ( ) { string str = " abbbb ▁ acccdddd " ; decodeString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printString ( string S , int N ) { string plaintext [ 5 ] ; int freq [ 26 ] = { 0 } ; int freqSorted [ 26 ] ; int Used [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] != ' ▁ ' ) { freq [ S [ i ] - ' A ' ] ++ ; } } for ( int i = 0 ; i < 26 ; i ++ ) { freqSorted [ i ] = freq [ i ] ; } string T = " ETAOINSHRDLCUMWFGYPBVKJXQZ " ; sort ( freqSorted , freqSorted + 26 , greater < int > ( ) ) ; for ( int i = 0 ; i < 5 ; i ++ ) { int ch = -1 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( freqSorted [ i ] == freq [ j ] && Used [ j ] == 0 ) { Used [ j ] = 1 ; ch = j ; break ; } } if ( ch == -1 ) break ; int x = T [ i ] - ' A ' ; x = x - ch ; string curr = " " ; for ( int k = 0 ; k < N ; k ++ ) { if ( S [ k ] == ' ▁ ' ) { curr += ' ▁ ' ; continue ; } int y = S [ k ] - ' A ' ; y += x ; if ( y < 0 ) y += 26 ; if ( y > 25 ) y -= 26 ; curr += ' A ' + y ; } plaintext [ i ] = curr ; } for ( int i = 0 ; i < 5 ; i ++ ) { cout << plaintext [ i ] << endl ; } } int main ( ) { string S = " B ▁ TJNQMF ▁ NFTTBHF " ; int N = S . length ( ) ; printString ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string canMadeEmpty ( string s , int n ) { stack < char > St ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' c ' ) { if ( St . size ( ) >= 2 ) { char b = St . top ( ) ; St . pop ( ) ; char a = St . top ( ) ; St . pop ( ) ; if ( a != ' a ' b != ' b ' ) return " No " ; } else return " No " ; } else St . push ( s [ i ] ) ; } if ( St . size ( ) == 0 ) { return " Yes " ; } else { return " No " ; } } int main ( ) { string S = " aabcbc " ; int N = S . length ( ) ; cout << canMadeEmpty ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string divisibleByk ( string s , int n , int k ) { int poweroftwo [ n ] ; poweroftwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { poweroftwo [ i ] = ( poweroftwo [ i - 1 ] * ( 2 % k ) ) % k ; } int rem = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ n - i - 1 ] == '1' ) { rem += ( poweroftwo [ i ] ) ; rem %= k ; } } if ( rem == 0 ) { return " Yes " ; } else return " No " ; } int main ( ) { string s = "1010001" ; int k = 9 ; int n = s . length ( ) ; cout << divisibleByk ( s , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string check ( string S ) { int N = S . length ( ) ; deque < int > A ; deque < int > B ; deque < int > C ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' A ' ) { A . push_back ( i ) ; } else if ( S [ i ] == ' B ' ) { B . push_back ( i ) ; } else { C . push_back ( i ) ; } } if ( N % 3 || A . size ( ) != B . size ( ) || A . size ( ) != C . size ( ) ) { return " No " ; } for ( int i = 0 ; i < B . size ( ) ; i ++ ) { if ( ! A . empty ( ) && B [ i ] > A [ 0 ] ) { A . pop_front ( ) ; } else { return " No " ; } } for ( int i = B . size ( ) - 1 ; i >= 0 ; i -- ) { if ( ! C . empty ( ) && B [ i ] < C . back ( ) ) { C . pop_back ( ) ; } else { return " No " ; } } return " Yes " ; } int main ( ) { string S = " ABABCC " ; cout << check ( S ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string isSumEqual ( string A , string B , string C ) { int L = A . length ( ) ; int M = B . length ( ) ; int N = A . length ( ) ; reverse ( A . begin ( ) , A . end ( ) ) ; reverse ( B . begin ( ) , B . end ( ) ) ; reverse ( C . begin ( ) , C . end ( ) ) ; int rem = 0 ; for ( int i = 0 ; i < max ( L , max ( M , N ) ) ; i ++ ) { int curr = rem ; if ( i < L ) curr += A [ i ] - ' a ' ; if ( i < M ) curr += B [ i ] - ' a ' ; rem = curr / 10 ; curr %= 10 ; if ( i < N && curr != C [ i ] - ' a ' ) { return " No " ; } } if ( rem ) return " No " ; else return " Yes " ; } int main ( ) { string A = " acb " , B = " cba " , C = " cdb " ; cout << isSumEqual ( A , B , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumHammingDistance ( string S , int K ) { int n = S . size ( ) ; int pref [ n ] ; pref [ 0 ] = S [ 0 ] - '0' ; for ( int i = 1 ; i < n ; i ++ ) pref [ i ] = pref [ i - 1 ] + ( S [ i ] - '0' ) ; int cnt = pref [ n - 1 ] ; int ans = cnt ; for ( int i = 0 ; i < n - K ; i ++ ) { int value = pref [ i + K - 1 ] - ( i - 1 >= 0 ? pref [ i - 1 ] : 0 ) ; ans = min ( ans , cnt - value + ( K - value ) ) ; } return ans ; } int main ( ) { string s = "101" ; int K = 2 ; cout << minimumHammingDistance ( s , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( string S , int N ) { int ans = 0 ; for ( int mask = 0 ; mask < ( 1 << N ) ; mask ++ ) { string X , Y ; for ( int i = 0 ; i < N ; i ++ ) { if ( mask >> i & 1 ) { X += S [ i ] ; } else { Y += S [ i ] ; } } reverse ( Y . begin ( ) , Y . end ( ) ) ; if ( X == Y ) { ans ++ ; } } return ans ; } int main ( ) { string S = " mippiisssisssiipsspiim " ; int N = S . length ( ) ; cout << countWays ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isEqualSubstring ( string str , int x ) { int n = str . length ( ) ; int i = 0 ; while ( i < n && i < x ) { if ( str [ i ] != str [ n - i - 1 ] ) { cout << " false " ; return ; } i ++ ; } cout << " true " ; } int main ( ) { string str = " GeeksforGeeks " ; int x = 3 ; isEqualSubstring ( str , x ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void differentBitwiseOR ( string s1 , string s2 ) { int n = s1 . size ( ) ; int t00 = 0 , t10 = 0 , t01 = 0 , t11 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s1 [ i ] == '0' && s2 [ i ] == '0' ) { t00 ++ ; } if ( s1 [ i ] == '1' && s2 [ i ] == '0' ) { t10 ++ ; } if ( s1 [ i ] == '1' && s2 [ i ] == '1' ) { t11 ++ ; } if ( s1 [ i ] == '0' && s2 [ i ] == '1' ) { t01 ++ ; } } int ans = t00 * t10 + t01 * t10 + t00 * t11 ; cout << ans ; } int main ( ) { string S1 = "01001" ; string S2 = "11011" ; differentBitwiseOR ( S1 , S2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void RemoveCharacters ( string s ) { string ans = " " ; bool c [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) c [ i ] = 0 ; int pos = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( c [ s [ i ] - ' a ' ] == 0 ) { c [ s [ i ] - ' a ' ] = 1 ; pos = i ; ans += s [ i ] ; } } for ( int i = pos + 1 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == s [ 0 ] ) { ans += s [ i ] ; break ; } } cout << ans ; } int main ( ) { string S = " abcaadbcd " ; RemoveCharacters ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void changeCharacters ( string S , int N , int K ) { int flag = 1 ; int count = 0 ; stack < char > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . empty ( ) ) { if ( S [ i ] == '0' ) { flag = 0 ; break ; } count = 0 ; st . push ( S [ i ] ) ; } else { if ( S [ i ] == '0' ) { count ++ ; if ( count == K ) { st . pop ( ) ; count = 0 ; } } else { count = 0 ; } } } if ( flag ) cout << " YES " << endl ; else cout << " NO " << endl ; } int main ( ) { string S = "100100" ; int N = S . length ( ) ; int K = 2 ; changeCharacters ( S , N , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool prefixDivisble ( int n ) { int i = 1 ; while ( n > 0 ) { if ( n % i != 0 ) return false ; n = n / 10 ; i ++ ; } return true ; } int main ( ) { int n = 52248 ; if ( prefixDivisble ( n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generatePalindrome ( string S ) { unordered_map < char , int > Hash ; for ( auto ch : S ) { Hash [ ch ] ++ ; } set < string > st ; for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { if ( Hash [ i ] == 2 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = " " ; if ( Hash [ j ] && i != j ) { s += i ; s += j ; s += i ; st . insert ( s ) ; } } } if ( Hash [ i ] >= 3 ) { for ( char j = ' a ' ; j <= ' z ' ; j ++ ) { string s = " " ; if ( Hash [ j ] ) { s += i ; s += j ; s += i ; st . insert ( s ) ; } } } } for ( auto ans : st ) { cout << ans << " STRNEWLINE " ; } } int main ( ) { string S = " ddabdac " ; generatePalindrome ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinimumCost ( string S , int A , int B ) { int count = 0 ; int group = 0 ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( S [ i ] == '0' ) { count += 1 ; } else { if ( count > 0 ) { group += 1 ; } count = 0 ; } } if ( count > 0 ) group += 1 ; if ( group == 0 ) { cout << 0 << endl ; } else { cout << min ( A , B ) * ( group - 1 ) + B ; } } int main ( ) { int A = 1 ; int B = 5 ; string S = "01100" ; MinimumCost ( S , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countOccurrences ( string S , string X , string Y ) { int count = 0 ; int N = S . length ( ) , A = X . length ( ) ; int B = Y . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . substr ( i , B ) == Y ) count ++ ; if ( S . substr ( i , A ) == X ) cout << count << " ▁ " ; } } int main ( ) { string S = " abcdefdefabc " ; string X = " abc " ; string Y = " def " ; countOccurrences ( S , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinimumTime ( string & S , int N , int K ) { if ( N == 0 ) { cout << 0 ; return ; } int maxfreq = INT_MIN ; char maxchar ; unordered_map < char , int > um ; for ( int i = 0 ; i < N ; i ++ ) { um [ S [ i ] ] ++ ; if ( um [ S [ i ] ] > maxfreq ) { maxfreq = um [ S [ i ] ] ; maxchar = S [ i ] ; } } int emptySlots = ( maxfreq - 1 ) * K ; for ( auto & it : um ) { if ( it . first == maxchar ) continue ; emptySlots -= min ( it . second , maxfreq - 1 ) ; } int ans = N + max ( 0 , emptySlots ) ; cout << ans ; } int main ( ) { string S = " AAABBB " ; int K = 2 ; int N = S . length ( ) ; findMinimumTime ( S , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canMakeEqual ( string S ) { int N = S . size ( ) ; int weightOfString = 0 ; for ( int i = 0 ; i < N ; i ++ ) { weightOfString += S [ i ] - ' a ' + 1 ; } if ( weightOfString % N == 0 ) cout << " Yes " ; else cout << " No " ; } int main ( ) { string S = " beb " ; canMakeEqual ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void addFrequencyToCharacter ( string S ) { int frequency [ 26 ] = { 0 } ; int N = S . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ S [ i ] - ' a ' ] += 1 ; } for ( int i = 0 ; i < N ; i ++ ) { int add = frequency [ S [ i ] - ' a ' ] % 26 ; if ( int ( S [ i ] ) + add <= int ( ' z ' ) ) S [ i ] = char ( int ( S [ i ] ) + add ) ; else { add = ( int ( S [ i ] ) + add ) - ( int ( ' z ' ) ) ; S [ i ] = char ( int ( ' a ' ) + add - 1 ) ; } } cout << S ; } int main ( ) { string S = " geeksforgeeks " ; addFrequencyToCharacter ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinimumTime ( string tasks , int K ) { unordered_map < char , int > map ; int curr_time = 0 ; for ( char c : tasks ) { if ( map . find ( c ) != map . end ( ) ) { if ( curr_time - map <= K ) { curr_time += K - ( curr_time - map ) + 1 ; } } map = curr_time ; curr_time ++ ; } cout << curr_time ; } int main ( ) { string S = " ABACCA " ; int K = 2 ; findMinimumTime ( S , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkforSubsequence ( string S , string target ) { stack < char > s ; for ( int i = 0 ; i < target . size ( ) ; i ++ ) { s . push ( target [ i ] ) ; } for ( int i = ( int ) S . size ( ) - 1 ; i >= 0 ; i -- ) { if ( s . empty ( ) ) { cout << " Yes " << endl ; return ; } if ( S [ i ] == s . top ( ) ) { s . pop ( ) ; } } if ( s . empty ( ) ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { string S = " KOTTAYAM " ; string target = " KOTA " ; checkforSubsequence ( S , target ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; string digits = "0123456789" , sign = " + - " ; string dot = " . " , ex = " eE " ; int dfa [ 11 ] [ 5 ] ; void makeDFA ( ) { dfa [ 0 ] [ 0 ] = 1 ; dfa [ 1 ] [ 0 ] = 1 ; dfa [ 1 ] [ 2 ] = 3 ; dfa [ 1 ] [ 3 ] = 2 ; dfa [ 1 ] [ 4 ] = 6 ; dfa [ 3 ] [ 0 ] = 4 ; dfa [ 4 ] [ 0 ] = 4 ; dfa [ 4 ] [ 3 ] = 5 ; dfa [ 4 ] [ 4 ] = 6 ; dfa [ 6 ] [ 0 ] = 8 ; dfa [ 6 ] [ 1 ] = 7 ; dfa [ 7 ] [ 0 ] = 8 ; dfa [ 8 ] [ 0 ] = 8 ; dfa [ 8 ] [ 3 ] = 9 ; } void buildDFA ( ) { for ( int i = 0 ; i < 11 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) dfa [ i ] [ j ] = 10 ; makeDFA ( ) ; } void checkDFA ( string s ) { buildDFA ( ) ; int currentstate = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( digits . find ( s [ i ] ) != digits . npos ) currentstate = dfa [ currentstate ] [ 0 ] ; else if ( sign . find ( s [ i ] ) != sign . npos ) currentstate = dfa [ currentstate ] [ 1 ] ; else if ( dot . find ( s [ i ] ) != dot . npos ) currentstate = dfa [ currentstate ] [ 2 ] ; else if ( ex . find ( s [ i ] ) != ex . npos ) currentstate = dfa [ currentstate ] [ 4 ] ; else currentstate = dfa [ currentstate ] [ 3 ] ; } if ( currentstate == 1 currentstate == 4 currentstate == 8 ) { cout << " Unsigned ▁ integer " ; } else { cout << " Not ▁ an ▁ unsigned ▁ integer " ; } } int main ( ) { string S = "1729" ; checkDFA ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSentence ( string str ) { char nums [ ] [ 5 ] = { " " , " " , " ABC " , " DEF " , " GHI " , " JKL " , " MNO " , " PQRS " , " TUV " , " WXYZ " } ; int i = 0 ; while ( str [ i ] != ' \0' ) { if ( str [ i ] == ' . ' ) { i ++ ; continue ; } int count = 0 ; while ( str [ i + 1 ] && str [ i ] == str [ i + 1 ] ) { if ( count == 2 && ( ( str [ i ] >= '2' && str [ i ] <= '6' ) || ( str [ i ] == '8' ) ) ) break ; else if ( count == 3 && ( str [ i ] == '7' str [ i ] == '9' ) ) break ; count ++ ; i ++ ; if ( str [ i ] == ' \0' ) break ; } if ( str [ i ] == '7' str [ i ] == '9' ) { cout << nums [ str [ i ] - 48 ] [ count % 4 ] ; } else { cout << nums [ str [ i ] - 48 ] [ count % 3 ] ; } i ++ ; } } int main ( ) { string str = "234" ; printSentence ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string getString ( int N ) { string ans = " " ; while ( N >= 26 ) { ans += ' z ' ; N -= 26 ; } ans += char ( N + ' a ' - 1 ) ; return ans ; } int main ( ) { int N = 30 ; cout << getString ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSamePrefixSuffix ( string s , int n ) { string prefix = " " ; for ( int i = 0 ; i < n - 1 ; i ++ ) { prefix += s [ i ] ; string suffix = s . substr ( n - 1 - i , n - 1 ) ; if ( prefix == suffix ) { cout << prefix . size ( ) << " ▁ " ; } } } int main ( ) { string S = " ababababab " ; int N = S . size ( ) ; countSamePrefixSuffix ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countStringPairs ( string a [ ] , int n ) { int ans = 0 ; unordered_map < string , int > s ; for ( int i = 0 ; i < n ; i ++ ) { s [ a [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { string p = a [ i ] ; string q = a [ j ] ; if ( p [ 0 ] != q [ 0 ] ) { swap ( p [ 0 ] , q [ 0 ] ) ; if ( s . find ( p ) == s . end ( ) && s . find ( q ) == s . end ( ) ) { ans ++ ; } } } } cout << ans ; } int main ( ) { string arr [ ] = { " good " , " bad " , " food " } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countStringPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumMoves ( string s , int n , int k ) { if ( n & 1 ) { cout << " No " ; return ; } int countOpen = count ( s . begin ( ) , s . end ( ) , ' ( ' ) ; int countClose = count ( s . begin ( ) , s . end ( ) , ' ) ' ) ; if ( countOpen != countClose ) { cout << " No " ; return ; } int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( s [ i ] == ' ( ' ) ++ cnt ; else { -- cnt ; if ( cnt < 0 ) { cnt = 0 ; ++ ans ; } } } if ( ans <= k ) cout << " Yes " ; else cout << " No " ; } int main ( ) { string S = " ) ( " ; int K = 1 ; minimumMoves ( S , S . length ( ) , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findRandom ( ) { int num = ( ( int ) rand ( ) % 2 ) ; return num ; } void generateBinaryString ( int N ) { srand ( time ( NULL ) ) ; string S = " " ; for ( int i = 0 ; i < N ; i ++ ) { int x = findRandom ( ) ; S += to_string ( x ) ; } cout << S ; } int main ( ) { int N = 7 ; generateBinaryString ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void checkPalindrome ( string & s ) { int a [ 26 ] = { 0 } ; int o = 0 , e = 0 ; for ( int i = 0 ; s [ i ] != ' \0' ; i ++ ) a [ ( int ) s [ i ] - 97 ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( a [ i ] == 1 ) o ++ ; else if ( a [ i ] % 2 == 0 and a [ i ] != 0 ) e += ( a [ i ] / 2 ) ; } if ( e >= o ) cout << " Yes " ; else { o = o - e ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( o <= 0 ) break ; if ( o > 0 and a [ i ] % 2 == 1 and a [ i ] > 2 ) { int k = o ; o = o - a [ i ] / 2 ; if ( o > 0 or 2 * k + 1 == a [ i ] ) { o ++ ; a [ i ] = 1 ; } } } if ( o <= 0 ) cout << " Yes " ; else cout << " No " ; } } int main ( ) { string S = " abbbaddzcz " ; checkPalindrome ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string maximumTime ( string s ) { if ( s [ 0 ] == ' _ ' ) { if ( ( s [ 1 ] == ' _ ' ) || ( s [ 1 ] >= '0' && s [ 1 ] < '4' ) ) { s [ 0 ] = '2' ; } else { s [ 0 ] = '1' ; } } if ( s [ 1 ] == ' _ ' ) { if ( s [ 0 ] == '2' ) { s [ 1 ] = '3' ; } else { s [ 1 ] = '9' ; } } if ( s [ 3 ] == ' _ ' ) { s [ 3 ] = '5' ; } if ( s [ 4 ] == ' _ ' ) { s [ 4 ] = '9' ; } return s ; } int main ( ) { string S = "0 _ : 4 _ " ; cout << maximumTime ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nearestPowerOfTwoUtil ( unordered_map < char , int > & freq ) { for ( auto & it : freq ) { cout << it . first << " ▁ - > ▁ " ; int lg = log2 ( it . second ) ; int a = pow ( 2 , lg ) ; int b = pow ( 2 , lg + 1 ) ; if ( ( it . second - a ) < ( b - it . second ) ) { cout << a << endl ; } else { cout << b << endl ; } } } void nearestPowerOfTwo ( string & S ) { int N = S . size ( ) ; unordered_map < char , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ S [ i ] ] ++ ; } nearestPowerOfTwoUtil ( freq ) ; } int main ( ) { string N = "16333331163" ; nearestPowerOfTwo ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; } void findSmallestString ( string s , string t ) { int n = s . length ( ) , m = t . length ( ) ; int l = lcm ( n , m ) ; string s1 = " " , t1 = " " ; for ( int i = 0 ; i < l / n ; i ++ ) { s1 += s ; } for ( int i = 0 ; i < l / m ; i ++ ) { t1 += t ; } if ( s1 == t1 ) cout << s1 ; else cout << -1 ; } int main ( ) { string S = " baba " , T = " ba " ; findSmallestString ( S , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minRemovals ( string str , int N ) { int ans = 0 ; bool X = false ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '0' ) { ans ++ ; while ( str [ i ] == '0' ) { i ++ ; } } else { X = true ; } } if ( ! X ) return 1 ; if ( str [ 0 ] == '0' and str [ N - 1 ] == '0' ) { ans -- ; } return ans ; } int main ( ) { string S = "11010001" ; int N = S . size ( ) ; cout << minRemovals ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int canMakeSame ( string s1 , string s2 ) { int ans = 0 ; if ( s1 . size ( ) != s2 . size ( ) ) { return -1 ; } int N = s1 . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { while ( i < s1 . length ( ) && s1 [ i ] != s2 [ i ] ) { i ++ ; } ans ++ ; } } return ans ; } int main ( ) { string S1 = "100001" ; string S2 = "110111" ; cout << canMakeSame ( S1 , S2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int convert ( string str ) { str . replace ( 2 , 1 , " " ) ; int h1 = ( int ) str [ 1 ] - '0' ; int h2 = ( int ) str [ 0 ] - '0' ; int hh = ( h2 * 10 + h1 % 10 ) ; int time = 0 ; if ( str [ 5 ] == ' A ' ) { if ( hh == 12 ) time += stoi ( str . substr ( 2 , 2 ) ) ; else { time += stoi ( str . substr ( 0 , 2 ) ) ; } } else { if ( hh == 12 ) { time += stoi ( str . substr ( 0 , 4 ) ) ; } else { time += stoi ( str . substr ( 0 , 4 ) ) ; time += 1200 ; } } return time ; } int countOverlap ( string arr [ ] [ 2 ] , int n , string p ) { int ans = 0 ; int M = convert ( p ) ; for ( int i = 0 ; i < n ; i ++ ) { int L = convert ( arr [ i ] [ 0 ] ) ; int R = convert ( arr [ i ] [ 1 ] ) ; if ( ( L <= M && M <= R ) || ( M >= R && M <= L ) ) ans ++ ; } return ans ; } int main ( ) { string arr [ ] [ 2 ] = { { "12:00 : AM " , "11:55 : PM " } , { "12:01 : AM " , "11:50 : AM " } , { "12:30 : AM " , "12:00 : PM " } , { "11:57 : AM " , "11:59 : PM " } } ; string P = "12:01 : PM " ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countOverlap ( arr , N , P ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countTotalFrequencies ( string S1 , string S2 ) { set < char > bset ; for ( auto x : S1 ) bset . insert ( x ) ; int count = 0 ; for ( auto x : S2 ) { if ( bset . find ( x ) != bset . end ( ) ) count += 1 ; } cout << count << endl ; } int main ( ) { string S1 = " geEksFOR " ; string S2 = " GeEksforgeEKS " ; countTotalFrequencies ( S1 , S2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nonDecreasing ( string s ) { int size = s . length ( ) ; char c = ' a ' ; for ( int i = 0 ; i < size ; i ++ ) { if ( s [ i ] == ' ? ' ) { continue ; } else if ( ( s [ i ] != ' ? ' ) && ( s [ i ] < c ) ) { return 0 ; } else { c = s [ i ] ; } } return 1 ; } int main ( ) { string S = " abb ? xy ? " ; if ( nonDecreasing ( S ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_length ( string str ) { int n = str . length ( ) ; int total_zeros = 0 ; int total_ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) total_zeros ++ ; else total_ones ++ ; } int ans = min ( total_zeros , total_ones ) ; int cur_zeros = 0 , cur_ones = 0 ; for ( char x : str ) { if ( x == '0' ) cur_zeros ++ ; else cur_ones ++ ; ans = min ( ans , cur_ones + ( total_zeros - cur_zeros ) ) ; } cout << ans ; } int main ( ) { string str = "10011" ; min_length ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumbySplittingstring ( string str , int N ) { int cntOne = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '1' ) { cntOne ++ ; } } int zero = 0 ; int one = 0 ; int res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( str [ i ] == '0' ) { zero ++ ; } else { one ++ ; } res = max ( res , zero + cntOne - one ) ; } return res ; } int main ( ) { string str = "00111" ; int N = str . length ( ) ; cout << maxSumbySplittingstring ( str , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string make_palindrome ( string S1 , string S2 , string S3 ) { int maskA = 0 , maskC = 0 ; for ( char i : S1 ) maskA |= ( 1 << ( i - ' a ' ) ) ; for ( char i : S3 ) maskC |= ( 1 << ( i - ' a ' ) ) ; if ( ( maskA & maskC ) > 0 ) return " YES " ; return " NO " ; } int main ( ) { string S1 = " adcb " , S2 = " bcdb " , S3 = " abe " ; cout << make_palindrome ( S1 , S2 , S3 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE bool longHelper ( int freq1 [ ] , int freq2 [ ] ) { for ( int i = 0 ; i < SIZE ; ++ i ) { if ( freq1 [ i ] != freq2 [ i ] ) { return false ; } } return true ; } int longCommomPrefixAnagram ( string s1 , string s2 , int n1 , int n2 ) { int freq1 [ 26 ] = { 0 } ; int freq2 [ 26 ] = { 0 } ; int ans = 0 ; int mini_len = min ( n1 , n2 ) ; for ( int i = 0 ; i < mini_len ; ++ i ) { freq1 [ s1 [ i ] - ' a ' ] ++ ; freq2 [ s2 [ i ] - ' a ' ] ++ ; if ( longHelper ( freq1 , freq2 ) ) { ans = i + 1 ; } } cout << ans ; } int main ( ) { string str1 = " abaabcdezzwer " ; string str2 = " caaabbttyh " ; int N = str1 . length ( ) ; int M = str2 . length ( ) ; longCommomPrefixAnagram ( str1 , str2 , N , M ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void findRank ( string s ) { int N = s . size ( ) ; string bin ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '0' ) bin += "0" ; else bin += "1" ; } long long X = 1ll << N ; long long res = 0 , val = 1 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( bin [ i ] == '1' ) res += ( val ) ; val *= 2ll ; } long long Y = res ; long ans = X + Y - 1 ; cout << ans ; } int main ( ) { string S = "001" ; findRank ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void DFA ( string str , int N ) { if ( N <= 1 ) { cout << " No " ; return ; } int count = 0 ; if ( str [ 0 ] == ' C ' ) { count ++ ; for ( int i = 1 ; i < N ; i ++ ) { if ( str [ i ] == ' A ' str [ i ] == ' B ' ) count ++ ; else break ; } } else { cout << " No " ; return ; } if ( count == N ) cout << " Yes " ; else cout << " No " ; } int main ( ) { string str = " CAABBAAB " ; int N = str . size ( ) ; DFA ( str , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int lena , int lenb ) { if ( lena == 0 ) return lenb ; if ( lenb == 0 ) return lena ; if ( lena == lenb ) return lena ; if ( lena > lenb ) return GCD ( lena - lenb , lenb ) ; return GCD ( lena , lenb - lena ) ; } string StringGCD ( string a , string b ) { int gcd = GCD ( a . size ( ) , b . size ( ) ) ; if ( a . substr ( 0 , gcd ) == b . substr ( 0 , gcd ) ) { int x = ( ( int ) b . size ( ) / gcd ) ; int y = ( ( int ) a . size ( ) / gcd ) ; string r = " " , s = " " ; while ( x -- ) s += a ; while ( y -- ) r += b ; if ( s == r ) return a . substr ( 0 , gcd ) ; } return " - 1" ; } int main ( ) { string a = " geeksgeeks " ; string b = " geeks " ; cout << ( StringGCD ( a , b ) ) ; }
#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; long long scoreOfParentheses ( string S ) { stack < string > s ; int i = 0 ; long long ans = 0 ; while ( i < S . length ( ) ) { if ( S [ i ] == ' ( ' ) s . push ( " ( " ) ; else { if ( s . top ( ) == " ( " ) { s . pop ( ) ; s . push ( "1" ) ; } else { long long count = 0 ; while ( s . top ( ) != " ( " ) { count += stoi ( s . top ( ) ) ; s . pop ( ) ; } s . pop ( ) ; s . push ( to_string ( 2 * count ) ) ; } } i ++ ; } while ( ! s . empty ( ) ) { ans += stoi ( s . top ( ) ) ; s . pop ( ) ; } return ans ; } int main ( ) { string S1 = " ( ( ) ( ( ) ) ) " ; cout << scoreOfParentheses ( S1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct TrieNode { TrieNode * Trie [ 256 ] ; bool isEnd ; TrieNode ( ) { for ( int i = 0 ; i < 256 ; i ++ ) { Trie [ i ] = NULL ; } isEnd = false ; } } ; void InsertTrie ( TrieNode * root , string s ) { TrieNode * temp = root ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( temp -> Trie [ s [ i ] ] == NULL ) { temp -> Trie [ s [ i ] ] = new TrieNode ( ) ; } temp = temp -> Trie [ s [ i ] ] ; } temp -> isEnd = true ; } void printSuggestions ( TrieNode * root , string res ) { if ( root -> isEnd == true ) { cout << res << " ▁ " ; } for ( int i = 0 ; i < 256 ; i ++ ) { if ( root -> Trie [ i ] != NULL ) { res . push_back ( i ) ; printSuggestions ( root -> Trie [ i ] , res ) ; res . pop_back ( ) ; } } } bool checkPresent ( TrieNode * root , string key ) { for ( int i = 0 ; i < key . length ( ) ; i ++ ) { if ( root -> Trie [ key [ i ] ] == NULL ) { printSuggestions ( root , key . substr ( 0 , i ) ) ; return false ; } root = root -> Trie [ key [ i ] ] ; } if ( root -> isEnd == true ) { return true ; } printSuggestions ( root , key ) ; return false ; } int main ( ) { vector < string > str = { " gee " , " geeks " , " ape " , " apple " , " geeksforgeeks " } ; string key = " geek " ; TrieNode * root = new TrieNode ( ) ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { InsertTrie ( root , str [ i ] ) ; } if ( checkPresent ( root , key ) ) { cout << " YES " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countStrings ( string S , vector < string > & list ) { unordered_set < char > valid ; for ( auto x : S ) { valid . insert ( x ) ; } int cnt = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int j = 0 ; for ( j = 0 ; j < list [ i ] . size ( ) ; j ++ ) { if ( valid . count ( list [ i ] [ j ] ) ) continue ; else break ; } if ( j == list [ i ] . size ( ) ) cnt ++ ; } return cnt ; } int main ( ) { vector < string > arr = { " ab " , " aab " , " abaaaa " , " bbd " } ; string S = " ab " ; cout << countStrings ( S , arr ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minLength ( string str , int N , string K , int M ) { stack < char > stackOfChar ; for ( int i = 0 ; i < N ; i ++ ) { stackOfChar . push ( str [ i ] ) ; if ( stackOfChar . size ( ) >= M ) { string l = " " ; for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( K [ j ] != stackOfChar . top ( ) ) { int f = 0 ; while ( f != l . size ( ) ) { stackOfChar . push ( l [ f ] ) ; f ++ ; } break ; } else { l = stackOfChar . top ( ) + l ; stackOfChar . pop ( ) ; } } } } return stackOfChar . size ( ) ; } int main ( ) { string S1 = " fffoxoxoxfxo " ; string S2 = " fox " ; int N = S1 . length ( ) ; int M = S2 . length ( ) ; cout << minLength ( S1 , N , S2 , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void palindrome_prod ( string N ) { vector < int > palindrome_list ; for ( int i = 101 ; i < 1000 ; i ++ ) { for ( int j = 121 ; j < 1000 ; j += ( i % 11 == 0 ) ? 1 : 11 ) { int n = i * j ; string x = to_string ( n ) ; string y = x ; reverse ( y . begin ( ) , y . end ( ) ) ; if ( x == y ) { if ( n < stoi ( N ) ) { palindrome_list . push_back ( i * j ) ; } } } } cout << ( * max_element ( palindrome_list . begin ( ) , palindrome_list . end ( ) ) ) ; } int main ( ) { string N = "101110" ; palindrome_prod ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minMaxDigits ( string str , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = ( str [ i ] - '0' ) % 3 ; int zero = 0 , one = 0 , two = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zero ++ ; if ( arr [ i ] == 1 ) one ++ ; if ( arr [ i ] == 2 ) two ++ ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum = ( sum + arr [ i ] ) % 3 ; } if ( sum == 0 ) { cout << 0 << ' ▁ ' ; } if ( sum == 1 ) { if ( one && N > 1 ) cout << 1 << ' ▁ ' ; else if ( two > 1 && N > 2 ) cout << 2 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } if ( sum == 2 ) { if ( two && N > 1 ) cout << 1 << ' ▁ ' ; else if ( one > 1 && N > 2 ) cout << 2 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } if ( zero > 0 ) cout << N - 1 << ' ▁ ' ; else if ( one > 0 && two > 0 ) cout << N - 2 << ' ▁ ' ; else if ( one > 2 two > 2 ) cout << N - 3 << ' ▁ ' ; else cout << -1 << ' ▁ ' ; } int main ( ) { string str = "12345" ; int N = str . length ( ) ; minMaxDigits ( str , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double count_of_accident ( string a , string b ) { int n = a . size ( ) , m = b . size ( ) ; if ( n > m ) return ( m * ( m + 1 ) ) / 2 ; else return ( n * ( n + 1 ) ) / 2 + ( m - n ) * n ; } double count_of_collision ( string a , string b ) { int n = a . size ( ) , m = b . size ( ) ; int answer = 0 ; int count_of_truck_in_lane_b = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] == ' T ' ) count_of_truck_in_lane_b ++ ; for ( int i = 0 ; i < n && i < m ; i ++ ) { if ( a [ i ] == ' T ' ) answer += count_of_truck_in_lane_b ; if ( b [ i ] == ' T ' ) count_of_truck_in_lane_b -- ; } return answer ; } double findProbability ( string a , string b ) { double total_outcome = count_of_accident ( a , b ) ; double favourable_outcome = count_of_collision ( a , b ) ; cout << favourable_outcome / total_outcome ; } int main ( ) { string S = " TCCBCTTB " , T = " BTCCBBTT " ; findProbability ( S , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int arcIntersection ( string S , int len ) { stack < char > stk ; for ( int i = 0 ; i < len ; i ++ ) { stk . push ( S [ i ] ) ; if ( stk . size ( ) >= 2 ) { char temp = stk . top ( ) ; stk . pop ( ) ; if ( stk . top ( ) == temp ) { stk . pop ( ) ; } else { stk . push ( temp ) ; } } } if ( stk . empty ( ) ) return 1 ; return 0 ; } void countString ( string arr [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int len = arr [ i ] . length ( ) ; count += arcIntersection ( arr [ i ] , len ) ; } cout << count << endl ; } int main ( ) { string arr [ ] = { "0101" , "0011" , "0110" } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countString ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumChanges ( int N , int K , string S ) { int ans = 0 ; for ( int i = 0 ; i < ( K + 1 ) / 2 ; i ++ ) { map < char , int > mp ; for ( int j = i ; j < N ; j += K ) { mp [ S [ j ] ] ++ ; } for ( int j = N - i - 1 ; j >= 0 ; j -= K ) { if ( K & 1 and i == K / 2 ) break ; mp [ S [ j ] ] ++ ; } int curr_max = INT_MIN ; for ( auto p : mp ) curr_max = max ( curr_max , p . second ) ; if ( K & 1 and i == K / 2 ) ans += ( N / K - curr_max ) ; else ans += ( N / K * 2 - curr_max ) ; } return ans ; } int main ( ) { string S = " aabbcbbcb " ; int N = S . length ( ) ; int K = 3 ; cout << findMinimumChanges ( N , K , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } int main ( ) { int N = 3 ; int flag , k , m ; if ( ( N == 1 ) || ( N == 2 ) ) cout << 62 ; else m = 1000000000 + 7 ; if ( N % 2 == 0 ) { k = N / 2 ; flag = true ; } else { k = ( N - 1 ) / 2 ; flag = false ; } if ( flag != 0 ) { int a = power ( 62 , k , m ) ; cout << a ; } else { int a = power ( 62 , ( k + 1 ) , m ) ; cout << a ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lenOfLongestReqSubstr ( string s , int N ) { unordered_map < int , int > ind ; int mask = 0 ; ind [ 0 ] = -1 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = s [ i ] - '0' ; mask ^= ( 1 << val ) ; if ( ind . find ( mask ) != ind . end ( ) ) { ans = max ( ans , i - ind [ mask ] ) ; } else ind [ mask ] = i ; } return ans ; } int main ( ) { string s = "223015150" ; int N = s . length ( ) ; cout << lenOfLongestReqSubstr ( s , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string ConvertequivalentBase8 ( string S ) { map < string , char > mp ; mp [ "000" ] = '0' ; mp [ "001" ] = '1' ; mp [ "010" ] = '2' ; mp [ "011" ] = '3' ; mp [ "100" ] = '4' ; mp [ "101" ] = '5' ; mp [ "110" ] = '6' ; mp [ "111" ] = '7' ; int N = S . length ( ) ; if ( N % 3 == 2 ) { S = "0" + S ; } else if ( N % 3 == 1 ) { S = "00" + S ; } N = S . length ( ) ; string oct ; for ( int i = 0 ; i < N ; i += 3 ) { string temp = S . substr ( i , 3 ) ; oct . push_back ( mp [ temp ] ) ; } return oct ; } string binString_div_9 ( string S , int N ) { string oct ; oct = ConvertequivalentBase8 ( S ) ; int oddSum = 0 ; int evenSum = 0 ; int M = oct . length ( ) ; for ( int i = 0 ; i < M ; i += 2 ) { oddSum += int ( oct [ i ] - '0' ) ; } for ( int i = 1 ; i < M ; i += 2 ) { evenSum += int ( oct [ i ] - '0' ) ; } int Oct_9 = 11 ; if ( abs ( oddSum - evenSum ) % Oct_9 == 0 ) { return " Yes " ; } return " No " ; } int main ( ) { string S = "1010001" ; int N = S . length ( ) ; cout << binString_div_9 ( S , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int uniqueMorseRep ( vector < string > & arr ) { vector < string > morseCode = { " . - " , " - . . . " , " - . - . " , " - . . " , " . " , " . . - . " , " - - . " , " . . . . " , " . . " , " . - - - " , " - . - " , " . - . . " , " - - " , " - . " , " - - - " , " . - - . " , " - - . - " , " . - . " , " . . . " , " - " , " . . - " , " . . . - " , " . - - " , " - . . - " , " - . - - " , " - - . . " } ; set < string > st ; int N = arr . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { string temp = " " ; int M = arr [ i ] . length ( ) ; for ( int j = 0 ; j < M ; j ++ ) { temp += morseCode [ arr [ i ] [ j ] - ' a ' ] ; } st . insert ( temp ) ; } return st . size ( ) ; } int main ( ) { vector < string > arr = { " gig " , " zeg " , " gin " , " msn " } ; cout << uniqueMorseRep ( arr ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinCost ( string str , int pos ) { int n = str . length ( ) ; if ( pos >= n / 2 ) { reverse ( str . begin ( ) , str . end ( ) ) ; pos = n - pos - 1 ; } int left , right ; left = right = pos ; for ( int i = pos ; i >= 0 ; -- i ) { if ( str [ i ] != str [ n - i - 1 ] ) { left = i ; } } for ( int i = pos ; i < n / 2 ; ++ i ) { if ( str [ i ] != str [ n - i - 1 ] ) { right = i ; } } int ans = 0 ; for ( int i = left ; i <= right ; ++ i ) { if ( str [ i ] != str [ n - i - 1 ] ) ans += 1 ; } int dis = min ( ( 2 * ( pos - left ) + ( right - pos ) ) , ( 2 * ( right - pos ) + ( pos - left ) ) ) ; ans = ans + dis ; return ans ; } int main ( ) { string S = " bass " ; int P = 3 ; cout << findMinCost ( S , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( string s , int n ) { int minValue = 100000000 ; for ( int i = 0 ; i <= 25 ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < n ; j ++ ) { cnt += min ( abs ( i - ( s [ j ] - ' a ' ) ) , 26 - abs ( i - ( s [ j ] - ' a ' ) ) ) ; } minValue = min ( minValue , cnt ) ; } return minValue ; } int main ( ) { string str = " geeksforgeeks " ; int N = str . length ( ) ; cout << minCost ( str , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void max_len ( string s [ ] , int N , int M ) { unordered_set < string > set_str ; for ( int i = 0 ; i < N ; i ++ ) { set_str . insert ( s [ i ] ) ; } vector < string > left_ans , right_ans ; string mid ; for ( int i = 0 ; i < N ; i ++ ) { string t = s [ i ] ; reverse ( t . begin ( ) , t . end ( ) ) ; if ( t == s [ i ] ) { mid = t ; } else if ( set_str . find ( t ) != set_str . end ( ) ) { left_ans . push_back ( s [ i ] ) ; right_ans . push_back ( t ) ; set_str . erase ( s [ i ] ) ; set_str . erase ( t ) ; } } for ( auto x : left_ans ) { cout << x ; } cout << mid ; reverse ( right_ans . begin ( ) , right_ans . end ( ) ) ; for ( auto x : right_ans ) { cout << x ; } } int main ( ) { int N = 4 , M = 3 ; string s [ ] = { " omg " , " bbb " , " ffd " , " gmo " } ; max_len ( s , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimum_length ( int x1 , int y1 , int x2 , int y2 , string str ) { int n = str . size ( ) ; int pos1 , pos2 , pos3 , pos4 ; pos1 = -1 ; pos2 = -1 ; pos3 = -1 ; pos4 = -1 ; if ( x1 == x2 && y1 == y2 ) { cout << 0 << endl ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( x2 > x1 ) { if ( str [ i ] == ' E ' ) { x1 = x1 + 1 ; if ( x1 == x2 ) { pos1 = i ; } } } if ( x2 < x1 ) { if ( str [ i ] == ' W ' ) { x1 = x1 - 1 ; if ( x1 == x2 ) { pos2 = i ; } } } if ( y2 > y1 ) { if ( str [ i ] == ' N ' ) { y1 = y1 + 1 ; if ( y1 == y2 ) { pos3 = i ; } } } if ( y2 < y1 ) { if ( str [ i ] == ' S ' ) { y1 = y1 - 1 ; if ( y1 == y2 ) { pos4 = i ; } } } } int z ; z = max ( max ( max ( pos1 , pos2 ) , pos3 ) , pos4 ) ; if ( x1 == x2 && y1 == y2 ) { cout << z + 1 << endl ; } else { cout << " - 1" << endl ; } } } int main ( ) { string str = " SESNW " ; int x1 = 0 , x2 = 1 , y1 = 0 , y2 = 1 ; minimum_length ( x1 , y1 , x2 , y2 , str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { res = res * i ; } return res ; } int distinctWays ( string str1 , string str2 ) { int n = str1 . length ( ) ; int m = str2 . length ( ) ; if ( n == m ) { return 2 * fact ( n ) * fact ( m ) ; } return fact ( n ) * fact ( m ) ; } int main ( ) { string str1 = " aegh " ; string str2 = " rsw " ; cout << distinctWays ( str1 , str2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string len ( long A , long B ) { string res = " " ; long Log = 0 ; do { Log = ( long ) ( log ( B ) / log ( 2 ) ) ; if ( Log != 0 ) { res = res + to_string ( A ) + " < < " + to_string ( Log ) ; } else { res += A ; break ; } B = B - ( long ) pow ( 2 , Log ) ; if ( B != 0 ) { res += " + " ; } else break ; } while ( Log != 0 ) ; return res ; } void minimumString ( long A , long B ) { string res1 = len ( A , B ) ; string res2 = len ( B , A ) ; if ( res1 . length ( ) > res2 . length ( ) ) { cout << res2 << endl ; } else { cout << res1 << endl ; } } int main ( ) { long A = 6 ; long B = 10 ; minimumString ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubstring ( string s ) { int res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int x = 0 ; for ( int j = i ; j < s . length ( ) ; j ++ ) { int temp = 1 << s [ j ] - ' a ' ; x ^= temp ; if ( ( x & ( x - 1 ) ) == 0 ) res ++ ; } } cout << res ; } int main ( ) { string str = " aaa " ; countSubstring ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubstring ( string s ) { int answer = 0 ; unordered_map < int , int > m ; m [ 0 ] = 1 ; int x = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { x ^= 1 << ( s [ j ] - ' a ' ) ; answer += m [ x ] ; for ( int i = 0 ; i < 26 ; ++ i ) { answer += m [ x ^ ( 1 << i ) ] ; } m [ x ] += 1 ; } cout << answer ; } int main ( ) { string str = " abab " ; countSubstring ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printResult ( vector < int > result ) { reverse ( result . begin ( ) , result . end ( ) ) ; int i = 0 ; while ( i < result . size ( ) ) { cout << result [ i ] ; i ++ ; } } void sumOfLargeNumbers ( string v [ ] , int k , int N ) { vector < vector < int > > x ( 1000 ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { x [ i ] . push_back ( v [ i ] [ j ] - '0' ) ; } } int carry = 0 ; vector < int > result ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += x [ j ] [ i ] ; sum += carry ; int temp = sum ; int count = 0 ; while ( temp > 9 ) { temp = temp % 10 ; count ++ ; } long long int l = pow ( 10 , count ) ; if ( l != 1 ) carry = ( double ) sum / l ; sum = sum % 10 ; result . push_back ( sum ) ; } while ( carry != 0 ) { int a = carry % 10 ; result . push_back ( a ) ; carry = carry / 10 ; } printResult ( result ) ; } int main ( ) { int K = 10 ; int N = 5 ; string arr [ ] = { "1111111111" , "1111111111" , "1111111111" , "1111111111" , "1111111111" } ; sumOfLargeNumbers ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_cost ( string S ) { int cost = 0 ; int F = 0 ; int B = 0 ; int count = 0 ; for ( char c : S ) if ( c == ' ▁ ' ) count ++ ; int n = S . size ( ) - count ; if ( n == 1 ) return cost ; for ( char in : S ) { if ( in != ' ▁ ' ) { if ( B != 0 ) { cost += min ( n - F , F ) * B ; B = 0 ; } F += 1 ; } else { B += 1 ; } } return cost ; } int main ( ) { string S = " ▁ @ TABSYMBOL $ " ; cout << min_cost ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkString ( string s , int K ) { int n = s . length ( ) ; unordered_map < char , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ s [ i ] ] = i ; } int cnt = 0 , f = 0 ; unordered_set < int > st ; for ( int i = 0 ; i < n ; i ++ ) { st . insert ( s [ i ] ) ; if ( st . size ( ) > K ) { f = 1 ; break ; } if ( mp [ s [ i ] ] == i ) st . erase ( s [ i ] ) ; } return ( f == 1 ? " Yes " : " No " ) ; } int main ( ) { string s = " aabbcdca " ; int k = 2 ; cout << checkString ( s , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long int NEW_LINE const int mod = 1e9 + 7 ; int binExp ( int base , int power ) { int x = 1 ; while ( power ) { if ( power % 2 == 1 ) x = ( ( x % mod ) * ( base % mod ) ) % mod ; base = ( ( base % mod ) * ( base % mod ) ) % mod ; power = power / 2 ; } return x ; } int fact ( int num ) { int result = 1 ; for ( int i = 1 ; i <= num ; ++ i ) { result = ( ( result % mod ) * ( i % mod ) ) % mod ; } return result ; } int calculate_nCi ( int N , int i ) { int nfact = fact ( N ) ; int ifact = fact ( i ) ; int dfact = fact ( N - i ) ; int inv_ifact = binExp ( ifact , mod - 2 ) ; int inv_dfact = binExp ( dfact , mod - 2 ) ; int denm = ( ( inv_ifact % mod ) * ( inv_dfact % mod ) ) % mod ; int answer = ( ( nfact % mod ) * ( denm % mod ) ) % mod ; return answer ; } void countSubstring ( int N , int s , int k ) { int allWays = binExp ( 26 , N ) ; int noWays = 0 ; for ( int i = 0 ; i < s ; ++ i ) { int nCi = calculate_nCi ( N , i ) ; int remaining = binExp ( 25 , N - i ) ; int multiply = ( ( nCi % mod ) * ( remaining % mod ) ) % mod ; noWays = ( ( noWays % mod ) + ( multiply % mod ) ) % mod ; } int answer = ( ( allWays % mod ) - ( noWays % mod ) ) % mod ; if ( answer < 0 ) answer += mod ; cout << answer ; } int32_t main ( ) { string str = " abc " ; int k = 2 ; int s = str . length ( ) ; int N = s + k ; countSubstring ( N , s , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) return true ; else return false ; } int minCost ( string S ) { int cA = 0 ; int cE = 0 ; int cI = 0 ; int cO = 0 ; int cU = 0 ; for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( isVowel ( S [ i ] ) ) { cA += abs ( S [ i ] - ' a ' ) ; cE += abs ( S [ i ] - ' e ' ) ; cI += abs ( S [ i ] - ' i ' ) ; cO += abs ( S [ i ] - ' o ' ) ; cU += abs ( S [ i ] - ' u ' ) ; } } return min ( min ( min ( min ( cA , cE ) , cI ) , cO ) , cU ) ; } int main ( ) { string S = " geeksforgeeks " ; cout << minCost ( S ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void count_minimum ( string s ) { int n = s . length ( ) ; int ans = 0 ; int i = 0 ; while ( i < n ) { int j = i ; while ( s [ j ] == s [ i ] && j < n ) { j ++ ; } int diff = j - i ; ans += diff / 2 ; i = j ; } cout << ans << endl ; } int main ( ) { string str = " caaab " ; count_minimum ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_cost ( string st ) { string vow = " aeiou " ; int cost = 0 ; for ( int i = 0 ; i < st . size ( ) ; i ++ ) { vector < int > costs ; for ( int j = 0 ; j < 5 ; j ++ ) costs . push_back ( abs ( st [ i ] - vow [ j ] ) ) ; cost += * min_element ( costs . begin ( ) , costs . end ( ) ) ; } return cost ; } int main ( ) { string str = " abcde " ; cout << ( min_cost ( str ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int l = 0 ; int h = str . size ( ) - 1 ; while ( h > l ) { if ( str [ l ++ ] != str [ h -- ] ) { return false ; } } return true ; } string makeOddString ( string str ) { string odd = " " ; for ( int i = 1 ; i < str . size ( ) ; i += 2 ) { odd += str [ i ] ; } return odd ; } string makeevenString ( string str ) { string even = " " ; for ( int i = 0 ; i < str . size ( ) ; i += 2 ) { even += str [ i ] ; } return even ; } void checkevenOddPalindrome ( string str ) { string odd = makeOddString ( str ) ; string even = makeevenString ( str ) ; if ( isPalindrome ( odd ) && isPalindrome ( even ) ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { string str = " abzzab " ; checkevenOddPalindrome ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long count_strings ( long n ) { int x = 1 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( 1 << x ) ; } return x - 1 ; } int main ( ) { long n = 3 ; cout << count_strings ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void decrypt ( string Str , int Start , int End ) { if ( Start > End ) { return ; } int mid = ( Start + End ) >> 1 ; cout << Str [ mid ] ; decrypt ( Str , mid + 1 , End ) ; decrypt ( Str , Start , mid - 1 ) ; } int main ( ) { int N = 4 ; string Str = " abcd " ; decrypt ( Str , 0 , N - 1 ) ; cout << " STRNEWLINE " ; N = 6 ; Str = " gyuitp " ; decrypt ( Str , 0 , N - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; } bool CheckBinaryEquivalent ( int N , string str ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } string bin = to_string ( B_Number ) ; return isSuffix ( str , bin ) ; } int main ( ) { int N = 23 ; string str = "111" ; if ( CheckBinaryEquivalent ( N , str ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void decode_String ( string str , int K ) { string ans = " " ; for ( int i = 0 ; i < str . size ( ) ; i += K ) ans += str [ i ] ; for ( int i = str . size ( ) - ( K - 1 ) ; i < str . size ( ) ; i ++ ) ans += str [ i ] ; cout << ans << endl ; } int main ( ) { int K = 3 ; string str = " abcbcscsesesesd " ; decode_String ( str , K ) ; }
#include <iostream> NEW_LINE using namespace std ; bool isvowel ( char ch ) { return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) ; } bool isvalid ( string & s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! isvowel ( s [ i ] ) ) return false ; } return true ; } int CountTotal ( string & s ) { int ans = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = " " ; for ( int j = i ; j < n ; j ++ ) { temp += s [ j ] ; if ( isvalid ( temp ) ) ans += 1 ; } } return ans ; } int main ( ) { string s = " aeoibsddaaeiouudb " ; cout << ( CountTotal ( s ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } bool isValid ( string & s ) { int n = s . size ( ) ; if ( n == 1 ) return ( isVowel ( s [ 0 ] ) ) ; if ( isVowel ( s [ 0 ] ) == false ) return false ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] || ! isVowel ( s [ i ] ) ) return false ; } return true ; } int findMaxLen ( string & s ) { int maxLen = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = " " ; for ( int j = i ; j < n ; j ++ ) { temp = temp + s [ j ] ; if ( isValid ( temp ) ) maxLen = max ( maxLen , ( j - i + 1 ) ) ; } } return maxLen ; } int main ( ) { string Str = " aeoibsddaeiouudb " ; cout << findMaxLen ( Str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void depthFirst ( int v , vector < int > graph [ ] , vector < bool > & visited , vector < int > & storeChain ) { visited [ v ] = true ; storeChain . push_back ( v ) ; for ( auto i : graph [ v ] ) { if ( visited [ i ] == false ) { depthFirst ( i , graph , visited , storeChain ) ; } } } void createMap ( unordered_map < string , char > * um ) { ( * um ) [ "0000" ] = '0' ; ( * um ) [ "0001" ] = '1' ; ( * um ) [ "0010" ] = '2' ; ( * um ) [ "0011" ] = '3' ; ( * um ) [ "0100" ] = '4' ; ( * um ) [ "0101" ] = '5' ; ( * um ) [ "0110" ] = '6' ; ( * um ) [ "0111" ] = '7' ; ( * um ) [ "1000" ] = '8' ; ( * um ) [ "1001" ] = '9' ; ( * um ) [ "1010" ] = ' A ' ; ( * um ) [ "1011" ] = ' B ' ; ( * um ) [ "1100" ] = ' C ' ; ( * um ) [ "1101" ] = ' D ' ; ( * um ) [ "1110" ] = ' E ' ; ( * um ) [ "1111" ] = ' F ' ; } string hexaDecimal ( string bin ) { int l = bin . size ( ) ; int t = bin . find_first_of ( ' . ' ) ; int len_left = t != -1 ? t : l ; for ( int i = 1 ; i <= ( 4 - len_left % 4 ) % 4 ; i ++ ) bin = '0' + bin ; if ( t != -1 ) { int len_right = l - len_left - 1 ; for ( int i = 1 ; i <= ( 4 - len_right % 4 ) % 4 ; i ++ ) bin = bin + '0' ; } unordered_map < string , char > bin_hex_map ; createMap ( & bin_hex_map ) ; int i = 0 ; string hex = " " ; while ( 1 ) { hex += bin_hex_map [ bin . substr ( i , 4 ) ] ; i += 4 ; if ( i == bin . size ( ) ) break ; if ( bin . at ( i ) == ' . ' ) { hex += ' . ' ; i ++ ; } } return hex ; } void hexValue ( vector < int > graph [ ] , int vertices , vector < int > values ) { vector < bool > visited ( 10001 , false ) ; for ( int i = 1 ; i <= vertices ; i ++ ) { if ( visited [ i ] == false ) { int sizeChain ; vector < int > storeChain ; depthFirst ( i , graph , visited , storeChain ) ; sizeChain = storeChain . size ( ) ; int chainValues [ sizeChain + 1 ] ; for ( int i = 0 ; i < sizeChain ; i ++ ) { int temp = values [ storeChain [ i ] - 1 ] ; chainValues [ i ] = temp ; } cout << " Chain ▁ = ▁ " ; for ( int i = 0 ; i < sizeChain ; i ++ ) { cout << chainValues [ i ] << " ▁ " ; } cout << " TABSYMBOL " ; stringstream ss ; ss << chainValues [ 0 ] ; string s = ss . str ( ) ; for ( int i = 1 ; i < sizeChain ; i ++ ) { stringstream ss1 ; ss1 << chainValues [ i ] ; string s1 = ss1 . str ( ) ; s . append ( s1 ) ; } cout << " Hexadecimal ▁ " << " equivalent ▁ = ▁ " ; cout << hexaDecimal ( s ) << endl ; } } } int main ( ) { vector < int > graph [ 1001 ] ; int E , V ; E = 4 ; V = 7 ; vector < int > values ; values . push_back ( 0 ) ; values . push_back ( 1 ) ; values . push_back ( 1 ) ; values . push_back ( 1 ) ; values . push_back ( 0 ) ; values . push_back ( 1 ) ; values . push_back ( 1 ) ; graph [ 1 ] . push_back ( 2 ) ; graph [ 2 ] . push_back ( 1 ) ; graph [ 3 ] . push_back ( 4 ) ; graph [ 4 ] . push_back ( 3 ) ; graph [ 4 ] . push_back ( 5 ) ; graph [ 5 ] . push_back ( 4 ) ; graph [ 6 ] . push_back ( 5 ) ; graph [ 5 ] . push_back ( 6 ) ; graph [ 6 ] . push_back ( 7 ) ; graph [ 7 ] . push_back ( 6 ) ; hexValue ( graph , V , values ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void BalancedNumber ( string s ) { int Leftsum = 0 ; int Rightsum = 0 ; for ( int i = 0 ; i < s . size ( ) / 2 ; i ++ ) { Leftsum += int ( s [ i ] - '0' ) ; Rightsum += int ( s [ s . size ( ) - 1 - i ] - '0' ) ; } if ( Leftsum == Rightsum ) cout << " Balanced " << endl ; else cout << " Not ▁ Balanced " << endl ; } int main ( ) { string s = "12321" ; BalancedNumber ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const unsigned long long mod = 1e9 + 7 ; unsigned long long expo ( unsigned long long base , unsigned long long exponent ) { unsigned long long ans = 1 ; while ( exponent != 0 ) { if ( ( exponent & 1 ) == 1 ) { ans = ans * base ; ans = ans % mod ; } base = base * base ; base %= mod ; exponent >>= 1 ; } return ans % mod ; } unsigned long long findCount ( unsigned long long N ) { unsigned long long ans = ( expo ( 26 , N ) - expo ( 5 , N ) - expo ( 21 , N ) ) % mod ; ans += mod ; ans %= mod ; return ans ; } int main ( ) { unsigned long long N = 3 ; cout << findCount ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long int NEW_LINE int decompose ( vector < int > S ) { stack < int > s ; int N = S . size ( ) ; int ans = 0 ; int nix = INT_MAX ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( s . empty ( ) ) { s . push ( S [ i ] ) ; nix = S [ i ] ; } else { if ( S [ i ] < s . top ( ) ) { s . push ( S [ i ] ) ; nix = min ( nix , S [ i ] ) ; } else { int val = S [ i ] ; while ( ! s . empty ( ) && val >= s . top ( ) ) { s . pop ( ) ; } nix = min ( nix , S [ i ] ) ; s . push ( nix ) ; } } ans += s . size ( ) ; } return ans ; } signed main ( ) { vector < int > S = { 9 , 6 , 9 , 35 } ; cout << decompose ( S ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string maxVowelSubString ( string str , int K ) { int N = str . length ( ) ; int pref [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' a ' or str [ i ] == ' e ' or str [ i ] == ' i ' or str [ i ] == ' o ' or str [ i ] == ' u ' ) pref [ i ] = 1 ; else pref [ i ] = 0 ; if ( i ) pref [ i ] += pref [ i - 1 ] ; } int maxCount = pref [ K - 1 ] ; string res = str . substr ( 0 , K ) ; for ( int i = K ; i < N ; i ++ ) { int currCount = pref [ i ] - pref [ i - K ] ; if ( currCount > maxCount ) { maxCount = currCount ; res = str . substr ( i - K + 1 , K ) ; } else if ( currCount == maxCount ) { string temp = str . substr ( i - K + 1 , K ) ; if ( temp < res ) res = temp ; } } return res ; } int main ( ) { string str = " ceebbaceeffo " ; int K = 3 ; cout << maxVowelSubString ( str , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDel ( string s1 , string s2 ) { int i = s1 . length ( ) ; int j = s2 . length ( ) ; while ( i > 0 && j > 0 ) { if ( s1 [ i - 1 ] != s2 [ j - 1 ] ) { break ; } i -- ; j -- ; } return i + j ; } int main ( ) { string s1 = " geeksforgeeks " , s2 = " peeks " ; cout << minDel ( s1 , s2 ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDel ( string s1 , string s2 ) { int i = 0 ; while ( i < min ( s1 . length ( ) , s2 . length ( ) ) ) { if ( s1 [ i ] != s2 [ i ] ) { break ; } i ++ ; } int ans = ( s1 . length ( ) - i ) + ( s2 . length ( ) - i ) ; return ans ; } int main ( ) { string s1 = " geeks " , s2 = " geeksfor " ; cout << minDel ( s1 , s2 ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CountValidTriplet ( string s , int n ) { int count_a = 0 , count_b = 0 , count_c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' ) count_a ++ ; if ( s [ i ] == ' b ' ) count_b ++ ; if ( s [ i ] == ' c ' ) count_c ++ ; } int Total_triplet = count_a * count_b * count_c ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( 2 * j - i ) < n && s [ j ] != s [ i ] && s [ j * 2 - i ] != s [ j ] && s [ 2 * j - i ] != s [ i ] ) Total_triplet -- ; } } cout << Total_triplet ; } int main ( ) { string s = " abcbcabc " ; int n = s . length ( ) ; CountValidTriplet ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isBalanced ( string exp ) { bool flag = true ; int count = 0 ; for ( int i = 0 ; i < exp . length ( ) ; i ++ ) { if ( exp [ i ] == ' ( ' ) { count ++ ; } else { count -- ; } if ( count < 0 ) { flag = false ; break ; } } if ( count != 0 ) { flag = false ; } return flag ; } int main ( ) { string exp1 = " ( ( ( ) ) ) ( ) ( ) " ; if ( isBalanced ( exp1 ) ) cout << " Balanced ▁ STRNEWLINE " ; else cout << " Not ▁ Balanced ▁ STRNEWLINE " ; string exp2 = " ( ) ) ( ( ( ) ) " ; if ( isBalanced ( exp2 ) ) cout << " Balanced ▁ STRNEWLINE " ; else cout << " Not ▁ Balanced ▁ STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestPalindrome ( string s ) { int n = s . length ( ) ; vector < vector < int > > pref ( 26 , vector < int > ( n , 0 ) ) ; vector < vector < int > > pos ( 26 ) ; pref [ s [ 0 ] - ' a ' ] [ 0 ] ++ ; pos [ s [ 0 ] - ' a ' ] . push_back ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) pref [ j ] [ i ] += pref [ j ] [ i - 1 ] ; int index = s [ i ] - ' a ' ; pref [ index ] [ i ] ++ ; pos [ index ] . push_back ( i ) ; } int ans = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int size = pos [ i ] . size ( ) ; ans = max ( ans , size ) ; for ( int j = 0 ; j < size / 2 ; j ++ ) { int l = pos [ i ] [ j ] ; int r = pos [ i ] [ size - j - 1 ] - 1 ; for ( int k = 0 ; k < 26 ; k ++ ) { int sum = pref [ k ] [ r ] - pref [ k ] [ l ] ; ans = max ( ans , 2 * ( j + 1 ) + sum ) ; } } } cout << ans << " STRNEWLINE " ; } int main ( ) { string S = " bbccdcbb " ; longestPalindrome ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkWord ( vector < vector < char > > & board , string & word , int index , int row , int col ) { if ( row < 0 || col < 0 || row >= board . size ( ) || col >= board [ 0 ] . size ( ) ) return false ; if ( board [ row ] [ col ] != word [ index ] ) return false ; else if ( index == word . size ( ) - 1 ) return true ; char temp = board [ row ] [ col ] ; board [ row ] [ col ] = ' * ' ; if ( checkWord ( board , word , index + 1 , row + 1 , col ) || checkWord ( board , word , index + 1 , row - 1 , col ) || checkWord ( board , word , index + 1 , row , col + 1 ) || checkWord ( board , word , index + 1 , row , col - 1 ) ) { board [ row ] [ col ] = temp ; return true ; } board [ row ] [ col ] = temp ; return false ; } int main ( ) { vector < vector < char > > board = { { ' A ' , ' B ' , ' C ' , ' E ' } , { ' S ' , ' F ' , ' C ' , ' S ' } , { ' A ' , ' D ' , ' E ' , ' E ' } } ; string word = " CFDASABCESEE " ; for ( int i = 0 ; i < board . size ( ) ; i ++ ) { for ( int j = 0 ; j < board [ 0 ] . size ( ) ; j ++ ) { if ( board [ i ] [ j ] == word [ 0 ] && checkWord ( board , word , 0 , i , j ) ) { cout << " True " << ' ' ; return 0 ; } } } cout << " False " << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( string N , int X , string subStr , int index , int n ) { if ( index == n ) return 0 ; string a = subStr + N [ index ] ; int b = 0 ; if ( stoll ( a ) % X == 0 ) b = 1 ; int m1 = count ( N , X , a , index + 1 , n ) ; int m2 = b + count ( N , X , " " , index + 1 , n ) ; return max ( m1 , m2 ) ; } int main ( ) { string N = "00001242" ; int K = 3 ; int l = N . length ( ) ; cout << count ( N , K , " " , 0 , l ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <boost/algorithm/string.hpp> NEW_LINE using namespace std ; void checkSuffix ( int A , int B ) { string s1 = to_string ( A ) ; string s2 = to_string ( B ) ; bool result ; result = boost :: algorithm :: ends_with ( s1 , s2 ) ; if ( result ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int A = 12345 , B = 45 ; checkSuffix ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void depthFirst ( int v , vector < int > graph [ ] , vector < bool > & visited , vector < int > & storeChain ) { visited [ v ] = true ; storeChain . push_back ( v ) ; for ( auto i : graph [ v ] ) { if ( visited [ i ] == false ) { depthFirst ( i , graph , visited , storeChain ) ; } } } void createMap ( unordered_map < string , char > * um ) { ( * um ) [ "000" ] = '0' ; ( * um ) [ "001" ] = '1' ; ( * um ) [ "010" ] = '2' ; ( * um ) [ "011" ] = '3' ; ( * um ) [ "100" ] = '4' ; ( * um ) [ "101" ] = '5' ; ( * um ) [ "110" ] = '6' ; ( * um ) [ "111" ] = '7' ; } string Octal ( string bin ) { int l = bin . size ( ) ; int t = bin . find_first_of ( ' . ' ) ; int len_left = t != -1 ? t : l ; for ( int i = 1 ; i <= ( 3 - len_left % 3 ) % 3 ; i ++ ) bin = '0' + bin ; if ( t != -1 ) { int len_right = l - len_left - 1 ; for ( int i = 1 ; i <= ( 3 - len_right % 3 ) % 3 ; i ++ ) bin = bin + '0' ; } unordered_map < string , char > bin_oct_map ; createMap ( & bin_oct_map ) ; int i = 0 ; string octal = " " ; while ( 1 ) { octal += bin_oct_map [ bin . substr ( i , 3 ) ] ; i += 3 ; if ( i == bin . size ( ) ) break ; if ( bin . at ( i ) == ' . ' ) { octal += ' . ' ; i ++ ; } } return octal ; } void octalValue ( vector < int > graph [ ] , int vertices , vector < int > values ) { vector < bool > visited ( 1001 , false ) ; for ( int i = 1 ; i <= vertices ; i ++ ) { if ( visited [ i ] == false ) { int sizeChain ; vector < int > storeChain ; depthFirst ( i , graph , visited , storeChain ) ; sizeChain = storeChain . size ( ) ; int chainValues [ sizeChain + 1 ] ; for ( int i = 0 ; i < sizeChain ; i ++ ) { int temp = values [ storeChain [ i ] - 1 ] ; chainValues [ i ] = temp ; } cout << " Chain ▁ = ▁ " ; for ( int i = 0 ; i < sizeChain ; i ++ ) { cout << chainValues [ i ] << " ▁ " ; } cout << " TABSYMBOL " ; stringstream ss ; ss << chainValues [ 0 ] ; string s = ss . str ( ) ; for ( int i = 1 ; i < sizeChain ; i ++ ) { stringstream ss1 ; ss1 << chainValues [ i ] ; string s1 = ss1 . str ( ) ; s . append ( s1 ) ; } cout << " Octal ▁ equivalent ▁ = ▁ " ; cout << Octal ( s ) << endl ; } } } int main ( ) { vector < int > graph [ 1001 ] ; int E , V ; E = 4 ; V = 7 ; vector < int > values ; values . push_back ( 0 ) ; values . push_back ( 1 ) ; values . push_back ( 0 ) ; values . push_back ( 0 ) ; values . push_back ( 0 ) ; values . push_back ( 1 ) ; values . push_back ( 1 ) ; graph [ 1 ] . push_back ( 2 ) ; graph [ 2 ] . push_back ( 1 ) ; graph [ 3 ] . push_back ( 4 ) ; graph [ 4 ] . push_back ( 3 ) ; graph [ 4 ] . push_back ( 5 ) ; graph [ 5 ] . push_back ( 4 ) ; graph [ 6 ] . push_back ( 7 ) ; graph [ 7 ] . push_back ( 6 ) ; octalValue ( graph , V , values ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string build_binary_str ( int p , int q , int r ) { string ans = " " ; if ( q == 0 ) { if ( p != 0 && r != 0 ) { return " - 1" ; } else { if ( p ) { ans = string ( p + 1 , '0' ) ; } else { ans = string ( r + 1 , '1' ) ; } } } else { for ( int i = 1 ; i <= q + 1 ; i ++ ) { if ( i % 2 == 0 ) { ans += '0' ; } else { ans += '1' ; } } ans . insert ( 1 , string ( p , '0' ) ) ; ans . insert ( 0 , string ( r , '1' ) ) ; } return ans ; } int main ( ) { int p = 1 , q = 2 , r = 2 ; cout << build_binary_str ( p , q , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int get_index ( char ch ) { if ( ch == ' a ' ) return 0 ; else if ( ch == ' e ' ) return 1 ; else if ( ch == ' i ' ) return 2 ; else if ( ch == ' o ' ) return 3 ; else if ( ch == ' u ' ) return 4 ; else return -1 ; } int findMinLength ( string s ) { int n = s . size ( ) ; int ans = n + 1 ; int start = 0 ; int count [ 5 ] = { 0 } ; for ( int x = 0 ; x < n ; x ++ ) { int idx = get_index ( s [ x ] ) ; if ( idx != -1 ) { count [ idx ] ++ ; } int idx_start = get_index ( s [ start ] ) ; while ( idx_start == -1 count [ idx_start ] > 1 ) { if ( idx_start != -1 ) { count [ idx_start ] -- ; } start ++ ; if ( start < n ) idx_start = get_index ( s [ start ] ) ; } if ( count [ 0 ] > 0 && count [ 1 ] > 0 && count [ 2 ] > 0 && count [ 3 ] > 0 && count [ 4 ] > 0 ) { ans = min ( ans , x - start + 1 ) ; } } if ( ans == n + 1 ) return -1 ; return ans ; } int main ( ) { string s = " aaeebbeaccaaoiuooooooooiuu " ; cout << findMinLength ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countStrings ( string s ) { int cnt = 0 ; for ( int i = 1 ; s [ i ] ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { cnt ++ ; } } return cnt ; } int main ( ) { string str ( " aacbb " ) ; cout << countStrings ( str ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; bool checkValidString ( string str ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] != 0 ) { if ( freq [ i ] != i + 1 ) { return false ; } } } return true ; } int main ( ) { string str = " abbcccdddd " ; if ( checkValidString ( str ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; void removeRepeating ( string s1 , string s2 ) { string s3 = s1 + " ▁ " + s2 + " ▁ " ; string words = " " ; int i = 0 ; for ( auto x : s3 ) { if ( x == ' ▁ ' ) { if ( s1 . find ( words ) == string :: npos || s2 . find ( words ) == string :: npos ) cout << words ; words = " " ; } else { words = words + x ; } } } int main ( ) { string s1 = " I ▁ have ▁ go ▁ a ▁ pen " ; string s2 = " I ▁ want ▁ to ▁ go ▁ park " ; removeRepeating ( s1 , s2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string convert ( string input ) { int len = input . length ( ) ; for ( int i = 0 ; i < len ; ) { if ( input [ i ] == ' , ▁ ' ) { input . erase ( input . begin ( ) + i ) ; len -- ; i -- ; } else if ( input [ i ] == ' ▁ ' ) { input . erase ( input . begin ( ) + i ) ; len -- ; i -- ; } else { i ++ ; } } reverse ( input . begin ( ) , input . end ( ) ) ; string output ; for ( int i = 0 ; i < len ; i ++ ) { if ( i == 2 ) { output += input [ i ] ; output += " , ▁ " ; } else if ( i > 2 && i % 2 == 0 && i + 1 < len ) { output += input [ i ] ; output += " , ▁ " ; } else { output += input [ i ] ; } } reverse ( output . begin ( ) , output . end ( ) ) ; return output ; } int main ( ) { string input1 = "123 , ▁ 456 , ▁ 789" ; string input2 = "90 , ▁ 050 , ▁ 000 , ▁ 000" ; cout << convert ( input1 ) << endl ; cout << convert ( input2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void max_segments ( string str , int K ) { int n = str . length ( ) ; int s = 0 , sum = 0 , count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int a = str [ i ] - '0' ; sum += a * pow ( 2 , s ) ; s ++ ; if ( sum != 0 && sum % K == 0 ) { count ++ ; sum = 0 ; s = 0 ; } } if ( sum != 0 ) cout << " - 1" << endl ; else cout << count << endl ; } int main ( ) { string str = "10111001" ; int K = 5 ; max_segments ( str , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 26 ; int modulo_by_26 ( string num ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % MOD ; return res ; } string decrypt_message ( string s ) { string decrypted_str = " " ; string num_found_so_far = " " ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s [ i ] >= '0' && s [ i ] <= '9' ) { num_found_so_far += s [ i ] ; } else if ( num_found_so_far . length ( ) > 0 ) { decrypted_str += ' a ' + modulo_by_26 ( num_found_so_far ) ; num_found_so_far = " " ; } } if ( num_found_so_far . length ( ) > 0 ) { decrypted_str += ' a ' + modulo_by_26 ( num_found_so_far ) ; } return decrypted_str ; } int main ( ) { string s = "32ytAAcV4ui30hf10hj18" ; cout << decrypt_message ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void decodeStr ( string str , int len ) { char c [ len ] = " " ; int med , pos = 1 , k ; if ( len % 2 == 1 ) med = len / 2 ; else med = len / 2 - 1 ; c [ med ] = str [ 0 ] ; if ( len % 2 == 0 ) c [ med + 1 ] = str [ 1 ] ; if ( len & 1 ) k = 1 ; else k = 2 ; for ( int i = k ; i < len ; i += 2 ) { c [ med - pos ] = str [ i ] ; if ( len % 2 == 1 ) c [ med + pos ] = str [ i + 1 ] ; else c [ med + pos + 1 ] = str [ i + 1 ] ; pos ++ ; } for ( int i = 0 ; i < len ; i ++ ) cout << c [ i ] ; } int main ( ) { string str = " ofrsgkeeeekgs " ; int len = str . length ( ) ; decodeStr ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxOverlap ( string S , string T ) { string str = T ; int count [ T . length ( ) ] = { 0 } ; int overlap = 0 ; int max_overlap = 0 ; for ( int i = 0 ; i <= S . length ( ) ; i ++ ) { int index = str . find ( S [ i ] ) ; if ( index == 0 ) { overlap ++ ; if ( overlap >= 2 ) max_overlap = max ( overlap , max_overlap ) ; count [ index ] ++ ; } else { if ( count [ index - 1 ] <= 0 ) return -1 ; count [ index ] ++ ; count [ index - 1 ] -- ; } if ( index == 4 ) overlap -- ; } if ( overlap == 0 ) return max_overlap ; else return -1 ; } int main ( ) { string S = " chcirphirp " ; string T = " chirp " ; cout << maxOverlap ( S , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  500001 NEW_LINE using namespace std ; int parent [ MAX ] ; int Rank [ MAX ] ; int find ( int x ) { return parent [ x ] = parent [ x ] == x ? x : find ( parent [ x ] ) ; } void merge ( int r1 , int r2 ) { if ( r1 != r2 ) { if ( Rank [ r1 ] > Rank [ r2 ] ) { parent [ r2 ] = r1 ; Rank [ r1 ] += Rank [ r2 ] ; } else { parent [ r1 ] = r2 ; Rank [ r2 ] += Rank [ r1 ] ; } } } void minimumOperations ( string s1 , string s2 ) { for ( int i = 1 ; i <= 26 ; i ++ ) { parent [ i ] = i ; Rank [ i ] = 1 ; } vector < pair < char , char > > ans ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { if ( find ( s1 [ i ] - 96 ) != find ( s2 [ i ] - 96 ) ) { int x = find ( s1 [ i ] - 96 ) ; int y = find ( s2 [ i ] - 96 ) ; merge ( x , y ) ; ans . push_back ( { s1 [ i ] , s2 [ i ] } ) ; } } } cout << ans . size ( ) << endl ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] . first << " - > " << ans [ i ] . second << endl ; } int main ( ) { string s1 , s2 ; s1 = " abb " ; s2 = " dad " ; minimumOperations ( s1 , s2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void string_permutation ( long long int n , string str ) { stack < int > s ; string result ; n = n - 1 ; for ( int i = 1 ; i < str . size ( ) + 1 ; i ++ ) { s . push ( n % i ) ; n = n / i ; } for ( int i = 0 ; i < str . size ( ) ; i ++ ) { int a = s . top ( ) ; result += str [ a ] ; int j ; for ( j = a ; j < str . length ( ) ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j + 1 ] = ' \0' ; s . pop ( ) ; } cout << result << endl ; } int main ( ) { string str = " abcde " ; long long int n = 11 ; string_permutation ( n , str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string GeberateDefangIP ( string str ) { string defangIP = " " ; for ( char c : str ) ( c == ' . ' ) ? defangIP += " [ . ] " : defangIP += c ; return defangIP ; } int main ( ) { string str = "255.100.50.0" ; cout << GeberateDefangIP ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string generateTheString ( int n ) { string ans = " " ; if ( n % 2 ) { for ( int i = 0 ; i < min ( n , 24 ) ; i ++ ) { ans += ( char ) ( ' b ' + i ) ; } if ( n > 24 ) { for ( int i = 0 ; i < ( n - 24 ) ; i ++ ) ans += ' a ' ; } } else { for ( int i = 0 ; i < min ( n , 25 ) ; i ++ ) { ans += ( char ) ( ' b ' + i ) ; } if ( n > 25 ) { for ( int i = 0 ; i < ( n - 25 ) ; i ++ ) ans += ' a ' ; } } return ans ; } int main ( ) { int n = 34 ; cout << generateTheString ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void moveAtEnd ( string s , int i , int l ) { if ( i >= l ) return ; char curr = s [ i ] ; if ( curr != ' x ' ) cout << curr ; moveAtEnd ( s , i + 1 , l ) ; if ( curr == ' x ' ) cout << curr ; return ; } int main ( ) { string s = " geekxsforgexxeksxx " ; int l = s . length ( ) ; moveAtEnd ( s , 0 , l ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void finalCoordinates ( int SX , int SY , string D ) { for ( int i = 0 ; i < D . length ( ) ; i ++ ) { if ( D [ i ] == ' N ' ) SY += 1 ; else if ( D [ i ] == ' S ' ) SY -= 1 ; else if ( D [ i ] == ' E ' ) SX += 1 ; else SX -= 1 ; } string ans = ' ( ' + to_string ( SX ) + ' , ' + to_string ( SY ) + ' ) ' ; cout << ans << endl ; } int main ( ) { int SX = 2 , SY = 2 ; string D = " NSSE " ; finalCoordinates ( SX , SY , D ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinFreq ( string s ) { sort ( s . begin ( ) , s . end ( ) ) ; return count ( s . begin ( ) , s . end ( ) , s [ 0 ] ) ; } void countLessThan ( vector < string > & arr1 , vector < string > & arr2 ) { vector < int > freq ; for ( string s : arr2 ) { int f = countMinFreq ( s ) ; freq . push_back ( f ) ; } sort ( freq . begin ( ) , freq . end ( ) ) ; for ( string s : arr1 ) { int f = countMinFreq ( s ) ; auto it = upper_bound ( freq . begin ( ) , freq . end ( ) , f ) ; int cnt = freq . size ( ) - ( it - freq . begin ( ) ) ; cout << cnt << ' ▁ ' ; } } int main ( ) { vector < string > arr1 , arr2 ; arr1 = { " yyy " , " zz " } ; arr2 = { " x " , " xx " , " xxx " , " xxxx " } ; countLessThan ( arr1 , arr2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCount ( string s , int L , int R ) { int distinct = 0 ; int frequency [ 26 ] = { } ; for ( int i = L ; i <= R ; i ++ ) { frequency [ s [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( frequency [ i ] > 0 ) distinct ++ ; } cout << distinct << endl ; } int main ( ) { string s = " geeksforgeeksisacomputerscienceportal " ; int queries = 3 ; int Q [ queries ] [ 2 ] = { { 0 , 10 } , { 15 , 18 } , { 12 , 20 } } ; for ( int i = 0 ; i < queries ; i ++ ) findCount ( s , Q [ i ] [ 0 ] , Q [ i ] [ 1 ] ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void shortestPalindrome ( string s ) { int abcd [ 26 ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) abcd [ s [ i ] - 97 ] = 1 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( abcd [ i ] == 1 ) cout << char ( i + 97 ) << " ▁ " ; } } int main ( ) { string s = " geeksforgeeks " ; shortestPalindrome ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeDuplicates ( string str ) { int n = str . length ( ) ; unordered_set < char > s ; string res = " " ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s . find ( str [ i ] ) == s . end ( ) ) { res = res + str [ i ] ; s . insert ( str [ i ] ) ; } } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; } int main ( ) { string str = " geeksforgeeks " ; cout << removeDuplicates ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void contain ( int L , int U , int M ) { int count = 0 ; for ( int j = L ; j < U ; j ++ ) { set < string > num ; string str = to_string ( j ) ; num . insert ( str ) ; if ( j % M == 0 and num . find ( to_string ( M ) ) == num . end ( ) ) { count += 1 ; } } cout << count - 2 ; } int main ( ) { int L = 106 ; int U = 200 ; int M = 7 ; contain ( L , U , M ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max1 = 0 ; int MaxLength ( vector < string > v , int i , int m ) { if ( i >= m ) { return m - 1 ; } for ( int k = 0 ; k < 26 ; k ++ ) { char c = ' a ' + k ; vector < string > v1 ; for ( int j = 0 ; j < v . size ( ) ; j ++ ) { if ( v [ j ] [ i ] == c ) { v1 . push_back ( v [ j ] ) ; } } if ( v1 . size ( ) >= 2 ) { max1 = max ( max1 , MaxLength ( v1 , i + 1 , m ) ) ; } else { max1 = max ( max1 , i - 1 ) ; } } return max1 ; } int main ( ) { string s1 , s2 , s3 , s4 , s5 ; s1 = " abcde " ; s2 = " abcsd " ; s3 = " bcsdf " ; s4 = " abcda " ; s5 = " abced " ; vector < string > v ; v . push_back ( s1 ) ; v . push_back ( s2 ) ; v . push_back ( s3 ) ; v . push_back ( s4 ) ; v . push_back ( s5 ) ; int m = v [ 0 ] . size ( ) ; cout << MaxLength ( v , 0 , m ) + 1 << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool compare ( string s , string t ) { int ps , pt , i ; ps = -1 ; for ( i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == ' # ' && ps != -1 ) ps -= 1 ; else if ( s [ i ] != ' # ' ) { s = s [ i ] ; ps += 1 ; } } pt = -1 ; for ( i = 0 ; i < t . size ( ) ; i ++ ) { if ( t [ i ] == ' # ' && pt != -1 ) pt -= 1 ; else if ( t [ i ] != ' # ' ) { t [ pt + 1 ] = t [ i ] ; pt += 1 ; } } if ( pt != ps ) return false ; else if ( ps == -1 && pt == -1 ) return true ; else { for ( i = 0 ; i <= pt ; i ++ ) { if ( s [ i ] != t [ i ] ) return false ; } return true ; } } int main ( ) { string s = " geee # e # ks " ; string t = " gee # # eeks " ; if ( compare ( s , t ) ) cout << " True " ; else cout << " False " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( string a , string b ) { int l = a . length ( ) ; int min = 0 , max = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == ' + ' b [ i ] == ' + ' a [ i ] != b [ i ] ) max ++ ; if ( a [ i ] != ' + ' && b [ i ] != ' + ' && a [ i ] != b [ i ] ) min ++ ; } cout << min + max << endl ; } int main ( ) { string s1 = " a + c " , s2 = " + + b " ; solve ( s1 , s2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int noOfDeletions ( string str , char k ) { int ans = 0 , cnt = 0 , pos = 0 ; while ( pos < str . length ( ) && str [ pos ] != k ) { pos ++ ; } int i = pos ; while ( i < str . length ( ) ) { while ( i < str . length ( ) && str [ i ] == k ) { i = i + 1 ; } ans = ans + cnt ; cnt = 0 ; while ( i < str . length ( ) && str [ i ] != k ) { i = i + 1 ; cnt = cnt + 1 ; } } return ans ; } int main ( ) { string str1 = " ababababa " ; char k1 = ' a ' ; cout << noOfDeletions ( str1 , k1 ) << endl ; string str2 = " kprkkoinkopt " ; char k2 = ' k ' ; cout << noOfDeletions ( str2 , k2 ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } int toDeci ( string str , int base ) { int len = str . size ( ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { return -1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; } void checkCorrespond ( vector < string > str , int x ) { int counter = 0 ; int n = str . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 ; j <= 36 ; j ++ ) { if ( toDeci ( str [ i ] , j ) == x ) { counter ++ ; break ; } } } if ( counter == n ) cout << " YES " << " STRNEWLINE " ; else cout << " NO " << " STRNEWLINE " ; } int main ( ) { int x = 16 ; vector < string > str = { "10000" , "20" , "16" } ; checkCorrespond ( str , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeOddFrequencyCharacters ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] & 1 ) continue ; new_string += s [ i ] ; } return new_string ; } int main ( ) { string str = " geeksforgeeks " ; str = removeOddFrequencyCharacters ( str ) ; cout << str << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LexicoLesserStrings ( string s ) { int count = 0 ; int len ; len = s . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { count += ( s [ i ] - ' a ' ) * pow ( 26 , len - i - 1 ) ; } return count ; } int countString ( string S1 , string S2 ) { int countS1 , countS2 , totalString ; countS1 = LexicoLesserStrings ( S1 ) ; countS2 = LexicoLesserStrings ( S2 ) ; totalString = countS2 - countS1 - 1 ; return ( totalString < 0 ? 0 : totalString ) ; } int main ( ) { string S1 , S2 ; S1 = " cda " ; S2 = " cef " ; cout << countString ( S1 , S2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char x ) { x = tolower ( x ) ; return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } string longestVowelSubsequence ( string str ) { string answer = " " ; int n = str . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isVowel ( str [ i ] ) ) { answer += str [ i ] ; } } return answer ; } int main ( ) { string str = " geeksforgeeks " ; cout << longestVowelSubsequence ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxFrequency ( string s ) { int arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) arr [ s [ i ] - ' a ' ] ++ ; unordered_map < int , int > hash ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] != 0 ) hash [ arr [ i ] ] ++ ; int max_count = 0 , res = -1 ; for ( auto i : hash ) { if ( max_count < i . second ) { res = i . first ; max_count = i . second ; } } cout << " Frequency ▁ " << res << " ▁ is ▁ repeated ▁ " << max_count << " ▁ times " ; } int main ( ) { string s = " geeksgeeks " ; findMaxFrequency ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findString ( string A , string B ) { int dist = 0 ; for ( int i = 0 ; A [ i ] ; i ++ ) { if ( A [ i ] != B [ i ] ) { dist ++ ; } } if ( dist & 1 ) { cout << " Not ▁ Possible " << endl ; } else { string res = " " ; int K = dist / 2 ; for ( int i = 0 ; A [ i ] ; i ++ ) { if ( A [ i ] != B [ i ] && K > 0 ) { res . push_back ( B [ i ] ) ; K -- ; } else if ( A [ i ] != B [ i ] ) { res . push_back ( A [ i ] ) ; } else { res . push_back ( A [ i ] ) ; } } cout << res << endl ; } } int main ( ) { string A = "1001010" ; string B = "0101010" ; findString ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSuffix ( string s , int n , int k ) { int i = s . length ( ) - 1 ; int arr [ 26 ] = { 0 } ; string suffix = " " ; while ( i > -1 ) { int index = s [ i ] - ' a ' ; if ( arr [ index ] < n ) { arr [ index ] ++ ; suffix += s [ i ] ; i -- ; continue ; } if ( k == 0 ) break ; k -- ; i -- ; } reverse ( suffix . begin ( ) , suffix . end ( ) ) ; cout << suffix ; } int main ( ) { string str = " iahagafedcba " ; int n = 1 , k = 2 ; maximumSuffix ( str , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string xoring ( string a , string b , int n ) { string ans = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == b [ i ] ) ans += "0" ; else ans += "1" ; } return ans ; } int main ( ) { string a = "1010" ; string b = "1101" ; int n = a . length ( ) ; string c = xoring ( a , b , n ) ; cout << c << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findLargest ( int N ) { string largest = string ( N , '7' ) ; return largest ; } string findSmallest ( int N ) { string smallest = "1" + string ( ( N - 1 ) , '0' ) ; return smallest ; } void printLargestSmallest ( int N ) { cout << " Largest : ▁ " << findLargest ( N ) << endl ; cout << " Smallest : ▁ " << findSmallest ( N ) << endl ; } int main ( ) { int N = 4 ; printLargestSmallest ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long countSubstr ( string & s , int k ) { int n = s . length ( ) ; int l = n - 1 ; int r = n - 1 ; int arr [ n ] ; int last_indexof1 = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { arr [ i ] = i ; last_indexof1 = i ; } else { arr [ i ] = last_indexof1 ; } } unsigned long long no_of_substr = 0 ; for ( r = n - 1 ; r >= 0 ; r -- ) { l = r ; while ( l >= 0 && ( r - l + 1 ) <= 64 && stoull ( s . substr ( l , r - l + 1 ) , 0 , 2 ) < k ) { l -- ; } if ( r - l + 1 <= 64 ) no_of_substr += l + 1 ; else { no_of_substr += arr [ l + 1 ] + 1 ; } } return no_of_substr ; } int main ( ) { string s = "11100" ; unsigned long long int k = 3 ; cout << countSubstr ( s , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectCubeString ( string str ) { int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) sum += ( int ) str [ i ] ; long double cr = round ( cbrt ( sum ) ) ; return ( cr * cr * cr == sum ) ; } int main ( ) { string str = " ll " ; if ( isPerfectCubeString ( str ) ) cout << " Yes " ; else cout << " No " ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; void CamelCase ( vector < string > & words , string pattern ) { map < string , vector < string > > map ; for ( int i = 0 ; i < words . size ( ) ; i ++ ) { string str = " " ; int l = words [ i ] . length ( ) ; for ( int j = 0 ; j < l ; j ++ ) { if ( words [ i ] [ j ] >= ' A ' && words [ i ] [ j ] <= ' Z ' ) { str += words [ i ] [ j ] ; map [ str ] . push_back ( words [ i ] ) ; } } } bool wordFound = false ; for ( auto & it : map ) { if ( it . first == pattern ) { wordFound = true ; for ( auto & itt : it . second ) { cout << itt << endl ; } } } if ( ! wordFound ) { cout << " No ▁ match ▁ found " ; } } int main ( ) { vector < string > words = { " Hi " , " Hello " , " HelloWorld " , " HiTech " , " HiGeek " , " HiTechWorld " , " HiTechCity " , " HiTechLab " } ; string pattern = " HT " ; CamelCase ( words , pattern ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string encryption ( string s ) { int l = s . length ( ) ; int b = ceil ( sqrt ( l ) ) ; int a = floor ( sqrt ( l ) ) ; string encrypted ; if ( b * a < l ) { if ( min ( b , a ) == b ) { b = b + 1 ; } else { a = a + 1 ; } } char arr [ a ] [ b ] ; memset ( arr , ' ▁ ' , sizeof ( arr ) ) ; int k = 0 ; for ( int j = 0 ; j < a ; j ++ ) { for ( int i = 0 ; i < b ; i ++ ) { if ( k < l ) { arr [ j ] [ i ] = s [ k ] ; } k ++ ; } } for ( int j = 0 ; j < b ; j ++ ) { for ( int i = 0 ; i < a ; i ++ ) { encrypted = encrypted + arr [ i ] [ j ] ; } } return encrypted ; } string decryption ( string s ) { int l = s . length ( ) ; int b = ceil ( sqrt ( l ) ) ; int a = floor ( sqrt ( l ) ) ; string decrypted ; char arr [ a ] [ b ] ; memset ( arr , ' ▁ ' , sizeof ( arr ) ) ; int k = 0 ; for ( int j = 0 ; j < b ; j ++ ) { for ( int i = 0 ; i < a ; i ++ ) { if ( k < l ) { arr [ j ] [ i ] = s [ k ] ; } k ++ ; } } for ( int j = 0 ; j < a ; j ++ ) { for ( int i = 0 ; i < b ; i ++ ) { decrypted = decrypted + arr [ i ] [ j ] ; } } return decrypted ; } int main ( ) { string s = " Geeks ▁ For ▁ Geeks " ; string encrypted ; string decrypted ; encrypted = encryption ( s ) ; cout << encrypted << endl ; decrypted = decryption ( encrypted ) ; cout << decrypted ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int checkIfStartsWithCapital ( string str ) { if ( str [ 0 ] >= ' A ' && str [ 0 ] <= ' Z ' ) return 1 ; else return 0 ; } void check ( string str ) { if ( checkIfStartsWithCapital ( str ) ) cout << " Accepted STRNEWLINE " ; else cout << " Not ▁ Accepted STRNEWLINE " ; } int main ( ) { string str = " GeeksforGeeks " ; check ( str ) ; str = " geeksforgeeks " ; check ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMostOccurringChar ( vector < string > str ) { int hash [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { for ( int j = 0 ; j < str [ i ] . length ( ) ; j ++ ) { hash [ str [ i ] [ j ] ] ++ ; } } int max = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { max = hash [ i ] > hash [ max ] ? i : max ; } cout << ( char ) ( max + 97 ) << endl ; } int main ( ) { vector < string > str ; str . push_back ( " animal " ) ; str . push_back ( " zebra " ) ; str . push_back ( " lion " ) ; str . push_back ( " giraffe " ) ; findMostOccurringChar ( str ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int checkIfAllVowels ( string str ) { int hash [ 5 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' A ' str [ i ] == ' a ' ) hash [ 0 ] = 1 ; else if ( str [ i ] == ' E ' str [ i ] == ' e ' ) hash [ 1 ] = 1 ; else if ( str [ i ] == ' I ' str [ i ] == ' i ' ) hash [ 2 ] = 1 ; else if ( str [ i ] == ' O ' str [ i ] == ' o ' ) hash [ 3 ] = 1 ; else if ( str [ i ] == ' U ' str [ i ] == ' u ' ) hash [ 4 ] = 1 ; } for ( int i = 0 ; i < 5 ; i ++ ) { if ( hash [ i ] == 0 ) { return 1 ; } } return 0 ; } int checkIfAllVowelsArePresent ( string str ) { if ( checkIfAllVowels ( str ) ) cout << " Not ▁ Accepted STRNEWLINE " ; else cout << " Accepted STRNEWLINE " ; } int main ( ) { string str = " aeioubc " ; checkIfAllVowelsArePresent ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallest ( string s ) { vector < int > a ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) a [ i ] = s [ i ] - '0' ; vector < int > b ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) { if ( ( a [ i ] ) % 2 != 0 ) b . push_back ( a [ i ] ) ; } sort ( b . begin ( ) , b . end ( ) ) ; if ( b . size ( ) > 1 ) return ( b [ 0 ] ) * 10 + ( b [ 1 ] ) ; return -1 ; } int main ( ) { cout << ( smallest ( "15470" ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void converthenumber ( int n ) { string s = to_string ( n ) ; string res ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' s [ i ] == '3' s [ i ] == '5' s [ i ] == '7' s [ i ] == '9' ) res += s [ i ] ; if ( res . size ( ) == 2 ) break ; } if ( res . size ( ) == 2 ) cout << res << endl ; else cout << " - 1" << endl ; } int main ( ) { int n = 18720 ; converthenumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestPalindrome ( string a [ ] , int n ) { string pair1 [ n ] ; string pair2 [ n ] ; int r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string s = a [ i ] ; reverse ( s . begin ( ) , s . end ( ) ) ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] != " " && a [ j ] != " " ) { if ( s == a [ j ] ) { pair1 [ r ] = a [ i ] ; pair2 [ r ++ ] = a [ j ] ; a [ i ] = " " ; a [ j ] = " " ; break ; } } } } string s1 = " " ; for ( int i = 0 ; i < n ; i ++ ) { string s = a [ i ] ; reverse ( a [ i ] . begin ( ) , a [ i ] . end ( ) ) ; if ( a [ i ] != " " ) { if ( a [ i ] == s ) { s1 = a [ i ] ; break ; } } } string ans = " " ; for ( int i = 0 ; i < r ; i ++ ) { ans = ans + pair1 [ i ] ; } if ( s1 != " " ) { ans = ans + s1 ; } for ( int j = r - 1 ; j >= 0 ; j -- ) { ans = ans + pair2 [ j ] ; } cout << ans << endl ; } int main ( ) { string a1 [ 2 ] = { " aba " , " aba " } ; int n1 = sizeof ( a1 ) / sizeof ( a1 [ 0 ] ) ; longestPalindrome ( a1 , n1 ) ; string a2 [ 5 ] = { " abc " , " dba " , " kop " , " abd " , " cba " } ; int n2 = sizeof ( a2 ) / sizeof ( a2 [ 0 ] ) ; longestPalindrome ( a2 , n2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class TrieNode { public : char val ; map < char , TrieNode * > children ; int visited ; TrieNode ( char x ) { val = x ; visited = 0 ; } } ; class Trie { public : TrieNode * head ; Trie ( ) { head = new TrieNode ( ' \0' ) ; } void addWord ( string s ) { TrieNode * temp = head ; const unsigned int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s [ i ] ; if ( ! temp -> children [ ch ] ) { temp -> children [ ch ] = new TrieNode ( ch ) ; } temp = temp -> children [ ch ] ; temp -> visited ++ ; } } int dfs ( TrieNode * node , int & ans , int depth ) { int vis = 0 ; for ( auto child : node -> children ) { vis += dfs ( child . second , ans , depth + 1 ) ; } node -> visited -= vis ; int string_pair = 0 ; if ( node -> visited > 1 ) { string_pair = ( node -> visited / 2 ) ; ans += ( depth * string_pair ) ; node -> visited -= ( 2 * string_pair ) ; } return ( 2 * string_pair + vis ) ; } int dfshelper ( ) { int ans = 0 ; dfs ( head , ans , 0 ) ; return ans ; } } ; int main ( ) { Trie T ; string str [ ] = { " babab " , " ababb " , " abbab " , " aaaaa " , " babaa " , " babbb " } ; int n = 6 ; for ( int i = 0 ; i < n ; i ++ ) { T . addWord ( str [ i ] ) ; } int ans = T . dfshelper ( ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int ALPHABET_SIZE = 26 ; struct TrieNode { struct TrieNode * children [ ALPHABET_SIZE ] ; bool isEndOfWord ; } ; struct TrieNode * getNode ( void ) { struct TrieNode * pNode = new TrieNode ; pNode -> isEndOfWord = false ; for ( int i = 0 ; i < ALPHABET_SIZE ; i ++ ) pNode -> children [ i ] = NULL ; return pNode ; } void insert ( struct TrieNode * root , string key ) { struct TrieNode * pCrawl = root ; for ( int i = 0 ; i < key . length ( ) ; i ++ ) { int index = key [ i ] - ' a ' ; if ( ! pCrawl -> children [ index ] ) pCrawl -> children [ index ] = getNode ( ) ; pCrawl = pCrawl -> children [ index ] ; } pCrawl -> isEndOfWord = true ; } bool search ( struct TrieNode * root , string key ) { struct TrieNode * pCrawl = root ; for ( int i = 0 ; i < key . length ( ) ; i ++ ) { int index = key [ i ] - ' a ' ; if ( ! pCrawl -> children [ index ] ) return false ; pCrawl = pCrawl -> children [ index ] ; } return ( pCrawl != NULL && pCrawl -> isEndOfWord ) ; } void wordBreakAll ( TrieNode * root , string word , int n , string result ) { for ( int i = 1 ; i <= n ; i ++ ) { string prefix = word . substr ( 0 , i ) ; if ( search ( root , prefix ) ) { if ( i == n ) { result += prefix ; cout << " TABSYMBOL " << result << endl ; return ; } wordBreakAll ( root , word . substr ( i , n - i ) , n - i , result + prefix + " ▁ " ) ; } } } int main ( ) { struct TrieNode * root = getNode ( ) ; string dictionary [ ] = { " sam " , " sung " , " samsung " } ; int n = sizeof ( dictionary ) / sizeof ( string ) ; for ( int i = 0 ; i < n ; i ++ ) { insert ( root , dictionary [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << dictionary [ i ] << " : ▁ STRNEWLINE " ; wordBreakAll ( root , dictionary [ i ] , dictionary [ i ] . length ( ) , " " ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { char data ; int cnt ; node * left , * right ; } ; node * add ( char data ) { node * newnode = new node ; newnode -> data = data ; newnode -> cnt = 1 ; newnode -> left = newnode -> right = NULL ; return newnode ; } node * addinlvlorder ( node * root , char data ) { if ( root == NULL ) { return add ( data ) ; } queue < node * > Q ; Q . push ( root ) ; while ( ! Q . empty ( ) ) { node * temp = Q . front ( ) ; Q . pop ( ) ; if ( temp -> data == data ) { temp -> cnt ++ ; break ; } if ( temp -> left == NULL ) { temp -> left = add ( data ) ; break ; } else { if ( temp -> left -> data == data ) { temp -> left -> cnt ++ ; break ; } Q . push ( temp -> left ) ; } if ( temp -> right == NULL ) { temp -> right = add ( data ) ; break ; } else { if ( temp -> right -> data == data ) { temp -> right -> cnt ++ ; break ; } Q . push ( temp -> right ) ; } } return root ; } void printlvlorder ( node * root ) { queue < node * > Q ; Q . push ( root ) ; while ( ! Q . empty ( ) ) { node * temp = Q . front ( ) ; if ( temp -> cnt > 1 ) { cout << temp -> data << temp -> cnt ; } else { cout << temp -> data ; } Q . pop ( ) ; if ( temp -> left != NULL ) { Q . push ( temp -> left ) ; } if ( temp -> right != NULL ) { Q . push ( temp -> right ) ; } } } int main ( ) { string s = " geeksforgeeks " ; node * root = NULL ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { root = addinlvlorder ( root , s [ i ] ) ; } printlvlorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void replaceRemove ( string & s , char X , char Y , char Z ) { int start = 0 , end = s . size ( ) - 1 ; while ( start <= end ) { if ( s [ start ] == Z ) { while ( end >= 0 && s [ end ] == Z ) { end -- ; } if ( end > start ) { swap ( s [ start ] , s [ end ] ) ; if ( s [ start ] == X ) s [ start ] = Y ; start ++ ; } } else { if ( s [ start ] == X ) s [ start ] = Y ; start ++ ; } } while ( s . size ( ) > 0 && s [ s . size ( ) - 1 ] == Z ) { s . pop_back ( ) ; } } int main ( ) { string str = " batman " ; char X = ' a ' , Y = ' d ' , Z = ' b ' ; replaceRemove ( str , X , Y , Z ) ; if ( str . size ( ) == 0 ) { cout << -1 ; } else { cout << str ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string canMake ( string & s ) { int o = 0 , z = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] - '0' == 1 ) o ++ ; else z ++ ; } if ( o % 2 == 1 && z % 2 == 1 ) return " NO " ; else return " YES " ; } int main ( ) { string s = "01011" ; cout << canMake ( s ) << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countNumberOfStringsUtil ( vector < int > & freq , int & count ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] > 0 ) { freq [ i ] -- ; count ++ ; countNumberOfStringsUtil ( freq , count ) ; } } } int countNumberOfStrings ( string s ) { vector < int > freq ( 26 , 0 ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { freq [ s [ i ] - ' A ' ] ++ ; } int count = 0 ; countNumberOfStringsUtil ( freq , count ) ; return count ; } int main ( ) { string s = " AAABBC " ; cout << countNumberOfStrings ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubStr ( string str , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) ans += ( i + 1 ) ; } return ans ; } int main ( ) { string str = "10010" ; int len = str . length ( ) ; cout << countSubStr ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLength ( string s , int k ) { int ans = INT_MAX ; int l = 0 ; int r = 0 ; int cnt_zero = 0 , cnt_one = 0 ; while ( l < s . size ( ) and r <= s . size ( ) ) { if ( cnt_zero >= k and cnt_one >= 1 ) { ans = min ( ans , r - l ) ; l ++ ; if ( s [ l - 1 ] == '0' ) cnt_zero -- ; else cnt_one -- ; } else { if ( r == s . size ( ) ) break ; if ( s [ r ] == '0' ) cnt_zero ++ ; else cnt_one ++ ; r ++ ; } } if ( ans == INT_MAX ) return -1 ; return ans ; } int main ( ) { string s = "100" ; int k = 2 ; cout << findLength ( s , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestSubStr ( string s ) { while ( s . size ( ) and s [ s . size ( ) - 1 ] == '1' ) s . pop_back ( ) ; if ( s . size ( ) == 0 ) return " - 1" ; else return s ; } int main ( ) { string s = "11001" ; cout << largestSubStr ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; bool areEqual ( int * a , int * b ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( a [ i ] != b [ i ] ) return false ; return true ; } bool xExistsInY ( string x , string y ) { if ( x . size ( ) > y . size ( ) ) return false ; int cnt_x [ MAX ] = { 0 } ; int cnt [ MAX ] = { 0 } ; for ( int i = 0 ; i < x . size ( ) ; i ++ ) cnt_x [ x [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < x . size ( ) ; i ++ ) cnt [ y [ i ] - ' a ' ] ++ ; if ( areEqual ( cnt_x , cnt ) ) return true ; for ( int i = 1 ; i < y . size ( ) - x . size ( ) + 1 ; i ++ ) { cnt [ y [ i - 1 ] - ' a ' ] -- ; cnt [ y [ i + x . size ( ) - 1 ] - ' a ' ] ++ ; if ( areEqual ( cnt , cnt_x ) ) return true ; } return false ; } int main ( ) { string x = " skege " ; string y = " geeksforgeeks " ; if ( xExistsInY ( x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string reverseParentheses ( string str , int len ) { stack < int > st ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ( ' ) { st . push ( i ) ; } else if ( str [ i ] == ' ) ' ) { reverse ( str . begin ( ) + st . top ( ) + 1 , str . begin ( ) + i ) ; st . pop ( ) ; } } string res = " " ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != ' ) ' && str [ i ] != ' ( ' ) res += ( str [ i ] ) ; } return res ; } int main ( ) { string str = " ( skeeg ( for ) skeeg ) " ; int len = str . length ( ) ; cout << reverseParentheses ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; void updateFreq ( string str , int freq [ ] ) { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } } int maxCount ( string str , string patt ) { int strFreq [ MAX ] = { 0 } ; updateFreq ( str , strFreq ) ; int pattFreq [ MAX ] = { 0 } ; updateFreq ( patt , pattFreq ) ; int ans = INT_MAX ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( pattFreq [ i ] == 0 ) continue ; ans = min ( ans , strFreq [ i ] / pattFreq [ i ] ) ; } return ans ; } int main ( ) { string str = " geeksforgeeks " ; string patt = " geeks " ; cout << maxCount ( str , patt ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int TEN = 10 ; int minNum ( string str , int len ) { int res = INT_MAX ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '4' str [ i ] == '8' ) { res = min ( res , str [ i ] - '0' ) ; } } for ( int i = 0 ; i < len - 1 ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { int num = ( str [ i ] - '0' ) * TEN + ( str [ j ] - '0' ) ; if ( num % 4 == 0 ) { res = min ( res , num ) ; } } } return ( ( res == INT_MAX ) ? -1 : res ) ; } int main ( ) { string str = "17" ; int len = str . length ( ) ; cout << minNum ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canBeEqual ( string a , string b , int n ) { vector < char > A , B ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { A . push_back ( a [ i ] ) ; B . push_back ( b [ i ] ) ; } } if ( A . size ( ) == B . size ( ) and B . size ( ) == 0 ) return true ; if ( A . size ( ) == B . size ( ) and B . size ( ) == 2 ) { if ( A [ 0 ] == A [ 1 ] and B [ 0 ] == B [ 1 ] ) return true ; } return false ; } int main ( ) { string A = " SEEKSFORGEEKS " ; string B = " GEEKSFORGEEKG " ; if ( canBeEqual ( A , B , A . size ( ) ) ) printf ( " Yes " ) ; else printf ( " No " ) ; }
#include <iostream> NEW_LINE using namespace std ; void findPhoneNumber ( int n ) { int temp = n ; int sum ; while ( temp != 0 ) { sum += temp % 10 ; temp = temp / 10 ; } if ( sum < 10 ) cout << n << "0" << sum ; else cout << n << sum ; } int main ( ) { long int n = 98765432 ; findPhoneNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMidAlphabet ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int mid = ( s1 [ i ] + s2 [ i ] ) / 2 ; cout << ( char ) mid ; } } int main ( ) { string s1 = " akzbqzgw " ; string s2 = " efhctcsz " ; int n = s1 . length ( ) ; findMidAlphabet ( s1 , s2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { int digit = n % 10 ; sum += digit ; n /= 10 ; } return sum ; } bool isDivBySix ( string str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( int ) ( str [ i ] - ' a ' + 1 ) ; } if ( sum % 3 != 0 ) return false ; int lastDigit = ( ( int ) ( str [ n - 1 ] - ' a ' + 1 ) ) % 10 ; if ( lastDigit % 2 != 0 ) return false ; return true ; } int main ( ) { string str = " ab " ; int n = str . length ( ) ; if ( isDivBySix ( str , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const string CHARS = "0123456789ABCDEF " ; const int DIGITS = 16 ; bool isDivisible ( string s , int m ) { unordered_map < char , int > mp ; for ( int i = 0 ; i < DIGITS ; i ++ ) { mp [ CHARS [ i ] ] = i ; } int r = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { r = ( r * 16 + mp [ s [ i ] ] ) % m ; } if ( ! r ) return true ; return false ; } int main ( ) { string s = "10" ; int m = 3 ; if ( isDivisible ( s , m ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSplits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return -1 ; int ans = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) ans += ( s [ i ] == '0' ) ; return ans ; } int main ( ) { string s = "10010" ; cout << cntSplits ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( float num ) { stringstream ss ; ss << num ; string s ; ss >> s ; int low = 0 ; int high = s . size ( ) - 1 ; while ( low < high ) { if ( s [ low ] != s [ high ] ) return false ; low ++ ; high -- ; } return true ; } int main ( ) { float n = 123.321f ; if ( isPalindrome ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; int maxSubStr ( string str1 , int len1 , string str2 , int len2 ) { if ( len1 > len2 ) return 0 ; int freq1 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; int freq2 [ MAX ] = { 0 } ; for ( int i = 0 ; i < len2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; int minPoss = INT_MAX ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; if ( freq1 [ i ] > freq2 [ i ] ) return 0 ; minPoss = min ( minPoss , freq2 [ i ] / freq1 [ i ] ) ; } return minPoss ; } int main ( ) { string str1 = " geeks " , str2 = " gskefrgoekees " ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; cout << maxSubStr ( str1 , len1 , str2 , len2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntWays ( string str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; } int main ( ) { string str = " ab " ; int n = str . length ( ) ; cout << cntWays ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count ( string s , int pos ) { int c = s [ pos - 1 ] ; int counter = 0 ; for ( int i = 0 ; i < pos - 1 ; i ++ ) { if ( s [ i ] == c ) counter = counter + 1 ; } return counter ; } int main ( ) { string s = " abacsddaa " ; int pos ; int n = s . length ( ) ; int query [ ] = { 9 , 3 , 2 } ; int Q = sizeof ( query ) / sizeof ( query [ 0 ] ) ; for ( int i = 0 ; i < Q ; i ++ ) { pos = query [ i ] ; cout << Count ( s , pos ) << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Count ( vector < int > temp ) { int query [ ] = { 9 , 3 , 2 } ; int Q = sizeof ( query ) / sizeof ( query [ 0 ] ) ; for ( int i = 0 ; i < Q ; i ++ ) { int pos = query [ i ] ; cout << ( temp [ pos - 1 ] ) << endl ; } } vector < int > processing ( string s , int len ) { vector < int > temp ( len ) ; map < char , int > d ; for ( int i = 0 ; i < len ; i ++ ) { if ( d . find ( s [ i ] ) == d . end ( ) ) { d [ s [ i ] ] = i ; } else { temp [ i ] = temp [ d [ s [ i ] ] ] + 1 ; d [ s [ i ] ] = i ; } } return temp ; } int main ( ) { string s = " abacsddaa " ; int n = s . length ( ) ; vector < int > temp = processing ( s , n ) ; Count ( temp ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sticks [ ] = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; int countSticks ( string str , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cnt += ( sticks [ str [ i ] - '0' ] ) ; } return cnt ; } int main ( ) { string str = "56" ; int n = str . length ( ) ; cout << countSticks ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printChar ( string str , int len ) { unordered_map < char , int > occ ; for ( int i = 0 ; i < len ; i ++ ) occ [ str [ i ] ] ++ ; int size = occ . size ( ) ; unordered_map < char , int > :: iterator it ; while ( size -- ) { unsigned currentMax = 0 ; char arg_max ; for ( it = occ . begin ( ) ; it != occ . end ( ) ; ++ it ) { if ( it -> second > currentMax || ( it -> second == currentMax && it -> first > arg_max ) ) { arg_max = it -> first ; currentMax = it -> second ; } } cout << arg_max << " ▁ - ▁ " << currentMax << endl ; occ . erase ( arg_max ) ; } } int main ( ) { string str = " geeksforgeeks " ; int len = str . length ( ) ; printChar ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_set < string > uSet ; int minCnt = INT_MAX ; void findSubStr ( string str , int cnt , int start ) { if ( start == str . length ( ) ) { minCnt = min ( cnt , minCnt ) ; } for ( int len = 1 ; len <= ( str . length ( ) - start ) ; len ++ ) { string subStr = str . substr ( start , len ) ; if ( uSet . find ( subStr ) != uSet . end ( ) ) { findSubStr ( str , cnt + 1 , start + len ) ; } } } void findMinSubStr ( string arr [ ] , int n , string str ) { for ( int i = 0 ; i < n ; i ++ ) uSet . insert ( arr [ i ] ) ; findSubStr ( str , 0 , 0 ) ; } int main ( ) { string str = "123456" ; string arr [ ] = { "1" , "12345" , "2345" , "56" , "23" , "456" } ; int n = sizeof ( arr ) / sizeof ( string ) ; findMinSubStr ( arr , n , str ) ; cout << minCnt ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMod ( string str , int n , int k ) { int pwrTwo [ n ] ; pwrTwo [ 0 ] = 1 % k ; for ( int i = 1 ; i < n ; i ++ ) { pwrTwo [ i ] = pwrTwo [ i - 1 ] * ( 2 % k ) ; pwrTwo [ i ] %= k ; } int res = 0 ; int i = 0 , j = n - 1 ; while ( i < n ) { if ( str [ j ] == '1' ) { res += ( pwrTwo [ i ] ) ; res %= k ; } i ++ ; j -- ; } return res ; } int main ( ) { string str = "1101" ; int n = str . length ( ) ; int k = 45 ; cout << getMod ( str , n , k ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void result ( string s , int n ) { unordered_set < string > st ; for ( int i = 0 ; i < ( int ) s . size ( ) ; i ++ ) { string ans = " " ; for ( int j = i ; j < ( int ) s . size ( ) ; j ++ ) { ans += s [ j ] ; if ( ans . size ( ) == n ) { st . insert ( ans ) ; break ; } } } for ( auto it : st ) cout << it << " ▁ " ; } int main ( ) { string s = " abca " ; int n = 3 ; result ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( string s ) { if ( s . empty ( ) ) return 0 ; int n = s . size ( ) ; int count = 1 ; int result = 0 ; int left = 0 ; int right = 1 ; while ( right < n ) { if ( s [ left ] == s [ right ] ) { count ++ ; } else { result += count * ( count + 1 ) / 2 ; left = right ; count = 1 ; } right ++ ; } result += count * ( count + 1 ) / 2 ; cout << result << endl ; } int main ( ) { string s = " bbbcbb " ; findNumbers ( s ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canBeBalanced ( string s , int n ) { if ( n % 2 == 1 ) return false ; string k = " ( " ; k += s + " ) " ; vector < string > d ; int cnt = 0 ; for ( int i = 0 ; i < k . length ( ) ; i ++ ) { if ( k [ i ] == ' ( ' ) d . push_back ( " ( " ) ; else { if ( d . size ( ) != 0 ) d . pop_back ( ) ; else return false ; } } if ( d . empty ( ) ) return true ; return false ; } int main ( int argc , char const * argv [ ] ) { string s = " ) ( ( ) " ; int n = s . length ( ) ; ( canBeBalanced ( s , n ) ) ? cout << " Yes " << endl : cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Find_Index ( string str1 , string str2 ) { int n = str1 . size ( ) ; int m = str2 . size ( ) ; int l = 0 ; int r = 0 ; if ( n != m + 1 ) { return -1 ; } for ( int i = 0 ; i < m ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) { l += 1 ; } else { break ; } } int i = n - 1 ; int j = m - 1 ; while ( i >= 0 && j >= 0 && str1 [ i ] == str2 [ j ] ) { r += 1 ; i -= 1 ; j -= 1 ; } if ( l + r < m ) { return -1 ; } else { i = max ( n - r , 1 ) ; j = min ( l + 1 , n ) ; return ( j - i + 1 ) ; } } int main ( ) { string str1 = " aaa " , str2 = " aa " ; cout << Find_Index ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void expandString ( string strin ) { string temp = " " ; int j ; for ( int i = 0 ; i < strin . length ( ) ; i ++ ) { if ( strin [ i ] >= 0 ) { int num = strin [ i ] - '0' ; if ( strin [ i + 1 ] == ' ( ' ) { for ( j = i + 1 ; strin [ j ] != ' ) ' ; j ++ ) { if ( ( strin [ j ] >= ' a ' && strin [ j ] <= ' z ' ) || ( strin [ j ] >= ' A ' && strin [ j ] <= ' Z ' ) ) { temp += strin [ j ] ; } } for ( int k = 1 ; k <= num ; k ++ ) { cout << ( temp ) ; } num = 0 ; temp = " " ; if ( j < strin . length ( ) ) { i = j ; } } } } } int main ( ) { string strin = "3 ( ab ) 4 ( cd ) " ; expandString ( strin ) ; }
#include <iostream> NEW_LINE using namespace std ; string findPrefix ( string str1 , string str2 ) { int pos = -1 ; while ( ! str1 . empty ( ) ) { if ( str2 . find ( str1 ) == string :: npos ) str1 . pop_back ( ) ; else { pos = str2 . find ( str1 ) ; break ; } } if ( pos == -1 ) return " - 1" ; return str1 ; } int main ( ) { string str1 = " geeksfor " ; string str2 = " forgeeks " ; cout << findPrefix ( str1 , str2 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSubStr ( string s , int n ) { int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . substr ( i , 5 ) == " geeks " ) c1 ++ ; if ( s . substr ( i , 3 ) == " for " ) c2 = c2 + c1 ; } return c2 ; } int main ( ) { string s = " geeksforgeeksisforgeeks " ; int n = s . size ( ) ; cout << countSubStr ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string getSmallestStr ( string S , int K ) { string X = " " ; priority_queue < char , vector < char > , greater < char > > pq ; int i , n = S . length ( ) ; K = min ( K , n ) ; for ( i = 0 ; i < K ; i ++ ) pq . push ( S [ i ] ) ; while ( ! pq . empty ( ) ) { X += pq . top ( ) ; pq . pop ( ) ; if ( i < S . length ( ) ) pq . push ( S [ i ] ) ; i ++ ; } return X ; } int main ( ) { string S = " geeksforgeeks " ; int K = 5 ; cout << getSmallestStr ( S , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void roundToNearest ( string str , int n ) { if ( str == " " ) return ; if ( str [ n - 1 ] - '0' <= 5 ) { str [ n - 1 ] = '0' ; cout << str . substr ( 0 , n ) ; } else { int carry = 0 ; str [ n - 1 ] = '0' ; int i = n - 2 ; carry = 1 ; while ( i >= 0 && carry == 1 ) { int currentDigit = str [ i ] - '0' ; currentDigit += carry ; if ( currentDigit > 9 ) { carry = 1 ; currentDigit = 0 ; } else carry = 0 ; str [ i ] = ( char ) ( currentDigit + '0' ) ; i -- ; } if ( carry == 1 ) cout << carry ; cout << str . substr ( 0 , n ) ; } } int main ( ) { string str = "99999999999999993" ; int n = str . length ( ) ; roundToNearest ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDigit ( char ch ) { if ( ch >= '0' && ch <= '9' ) return true ; return false ; } int nextNonDigit ( string str , int i ) { while ( i < str . length ( ) && isDigit ( str [ i ] ) ) { i ++ ; } if ( i >= str . length ( ) ) return -1 ; return i ; } void appendRepeated ( string & sb , string str , int times ) { for ( int i = 0 ; i < times ; i ++ ) sb . append ( str ) ; } string findString ( string str , int n ) { string sb = " " ; int startStr = nextNonDigit ( str , 0 ) ; while ( startStr != -1 ) { int endStr = startStr ; while ( ( endStr + 1 ) < n && ! isDigit ( str [ endStr + 1 ] ) ) { endStr ++ ; } int startNum = endStr + 1 ; if ( startNum == -1 ) break ; int endNum = startNum ; while ( ( endNum + 1 ) < n && isDigit ( str [ endNum + 1 ] ) ) { endNum ++ ; } int num = str [ startNum ] - '0' ; appendRepeated ( sb , str . substr ( startStr , endStr + 1 - startStr ) , num ) ; startStr = nextNonDigit ( str , endStr + 1 ) ; } return sb ; } int main ( ) { string str = " g1ee1ks1for1g1e2ks1" ; int n = str . length ( ) ; cout << findString ( str , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) return true ; return false ; } bool isVowelPrime ( string str , int n ) { bool prime [ n ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i < n ; i += p ) prime [ i ] = false ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( isVowel ( str [ i ] ) && ! prime [ i ] ) return false ; } return true ; } int main ( ) { string str = " geeksforgeeks " ; int n = str . length ( ) ; if ( isVowelPrime ( str , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int stringToInt ( string str ) { if ( str . length ( ) == 1 ) return ( str [ 0 ] - '0' ) ; double y = stringToInt ( str . substr ( 1 ) ) ; double x = str [ 0 ] - '0' ; x = x * pow ( 10 , str . length ( ) - 1 ) + y ; return int ( x ) ; } int main ( ) { string str = "1235" ; cout << ( stringToInt ( str ) ) << endl ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE string smallestStr ( string str , int n ) { int i , j ; int chk [ MAX ] ; for ( i = 0 ; i < MAX ; i ++ ) chk [ i ] = -1 ; for ( i = 0 ; i < n ; i ++ ) { if ( chk [ str [ i ] - ' a ' ] == -1 ) chk [ str [ i ] - ' a ' ] = i ; } for ( i = 0 ; i < n ; i ++ ) { bool flag = false ; for ( j = 0 ; j < str [ i ] - ' a ' ; j ++ ) { if ( chk [ j ] > chk [ str [ i ] - ' a ' ] ) { flag = true ; break ; } } if ( flag ) break ; } if ( i < n ) { char ch1 = str [ i ] ; char ch2 = char ( j + ' a ' ) ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ch1 ) str [ i ] = ch2 ; else if ( str [ i ] == ch2 ) str [ i ] = ch1 ; } } return str ; } int main ( ) { string str = " ccad " ; int n = str . length ( ) ; cout << smallestStr ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longest_substring ( string s , int k ) { int n = s . size ( ) ; if ( k > 1 ) { s += s ; n *= 2 ; } int ans = 0 ; int i = 0 ; while ( i < n ) { int x = 0 ; while ( s [ i ] == '0' && i < n ) x ++ , i ++ ; ans = max ( ans , x ) ; i ++ ; } if ( k == 1 or ans != n ) return ans ; else return ( ans / 2 ) * k ; } int main ( ) { string s = "010001000" ; int k = 4 ; cout << longest_substring ( s , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Occurrence ( string s , int position ) { int count = 0 ; for ( int i = 0 ; i < position - 1 ; i ++ ) if ( s [ i ] == s [ position - 1 ] ) count ++ ; return count ; } int main ( ) { string s = " ababababab " ; int p = 9 ; cout << Occurrence ( s , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE bool canBeMapped ( string s1 , int l1 , string s2 , int l2 ) { if ( l1 != l2 ) return false ; int freq1 [ MAX ] = { 0 } ; int freq2 [ MAX ] = { 0 } ; for ( int i = 0 ; i < l1 ; i ++ ) freq1 [ s1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) freq2 [ s2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq1 [ i ] == 0 ) continue ; bool found = false ; for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq1 [ i ] == freq2 [ j ] ) { freq2 [ j ] = -1 ; found = true ; break ; } } if ( ! found ) return false ; } return true ; } int main ( ) { string s1 = " axx " ; string s2 = " cbc " ; int l1 = s1 . length ( ) ; int l2 = s2 . length ( ) ; if ( canBeMapped ( s1 , l1 , s2 , l2 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateStr ( char * a , char * b , string s , int count , int len ) { if ( count == len ) { cout << s << endl ; return ; } generateStr ( a + 1 , b + 1 , s + ( * a ) , count + 1 , len ) ; generateStr ( a + 1 , b + 1 , s + ( * b ) , count + 1 , len ) ; } int main ( ) { char * a = " abc " , * b = " def " ; int n = strlen ( a ) ; generateStr ( a , b , " " , 0 , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <map> NEW_LINE using namespace std ; void division_of_string ( string str , int k ) { int n = str . size ( ) ; map < char , bool > has ; int ans , cnt = 0 , i = 0 ; while ( i < n ) { if ( ! has [ str [ i ] ] ) { cnt ++ ; has [ str [ i ] ] = true ; } if ( cnt == k ) { ans = i ; break ; } i ++ ; } i ++ ; has . clear ( ) ; cnt = 0 ; while ( i < n ) { if ( ! has [ str [ i ] ] ) { cnt ++ ; has [ str [ i ] ] = true ; } if ( cnt == k ) { break ; } i ++ ; } if ( cnt < k ) { cout << " Not ▁ possible " << endl ; } else { i = 0 ; while ( i <= ans ) { cout << str [ i ] ; i ++ ; } cout << endl ; while ( i < n ) { cout << str [ i ] ; i ++ ; } cout << endl ; } cout << endl ; } int main ( ) { string str = " geeksforgeeks " ; int k = 4 ; division_of_string ( str , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } int countSubstringsUtil ( string s ) { int count = 0 ; map < char , int > mp ; int n = s . length ( ) ; int start = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mp [ s [ i ] ] ++ ; while ( mp [ ' a ' ] > 0 && mp [ ' e ' ] > 0 && mp [ ' i ' ] > 0 && mp [ ' o ' ] > 0 && mp [ ' u ' ] > 0 ) { count += n - i ; mp [ s [ start ] ] -- ; start ++ ; } } return count ; } int countSubstrings ( string s ) { int count = 0 ; string temp = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( isVowel ( s [ i ] ) ) { temp += s [ i ] ; } else { if ( temp . length ( ) > 0 ) count += countSubstringsUtil ( temp ) ; temp = " " ; } } if ( temp . length ( ) > 0 ) count += countSubstringsUtil ( temp ) ; return count ; } int main ( ) { string s = " aeouisddaaeeiouua " ; cout << countSubstrings ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeDuplicates ( string S ) { string ans = " " ; for ( auto it : S ) { if ( ans . empty ( ) or ans . back ( ) != it ) ans . push_back ( it ) ; else if ( ans . back ( ) == it ) ans . pop_back ( ) ; } return ans ; } int main ( ) { string str = " keexxllx " ; cout << removeDuplicates ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string reverseWords ( string str ) { int start = 0 ; for ( int i = 0 ; i <= str . size ( ) ; i ++ ) { if ( str [ i ] == ' ▁ ' || i == str . size ( ) ) { int end = i - 1 ; while ( start < end ) { swap ( str [ start ] , str [ end ] ) ; start ++ ; end -- ; } start = i + 1 ; } } return str ; } int main ( ) { string str = " Geeks ▁ for ▁ Geeks " ; cout << reverseWords ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubString ( string s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . length ( ) ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; } int main ( ) { string s = "3123231" ; char c = '3' ; int k = 2 ; cout << countSubString ( s , c , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE #define MOD  1000000007 NEW_LINE using namespace std ; int solve ( string test ) { int size = test . size ( ) ; int total = 0 ; for ( int i = 0 ; i <= 8 ; i ++ ) { int x = i ; int y = i + 1 ; string newtest ; for ( int j = 0 ; j < size ; j ++ ) { if ( test [ j ] == x + 48 test [ j ] == y + 48 ) { newtest += test [ j ] ; } } if ( newtest . size ( ) > 0 ) { int size1 = newtest . size ( ) ; int prefix [ size1 ] = { 0 } ; for ( int j = 0 ; j < size1 ; j ++ ) { if ( newtest [ j ] == y + 48 ) { prefix [ j ] ++ ; } } for ( int j = 1 ; j < size1 ; j ++ ) { prefix [ j ] += prefix [ j - 1 ] ; } int count = 0 ; int firstcount = 0 ; int ss = 0 ; int prev = 0 ; for ( int j = 0 ; j < size1 ; j ++ ) { if ( newtest [ j ] == x + 48 ) { count ++ ; firstcount ++ ; } else { ss += count * count ; int pairsum = ( firstcount * firstcount - ss ) / 2 ; int temp = pairsum ; pairsum -= prev ; prev = temp ; int secondway = prefix [ size1 - 1 ] ; if ( j != 0 ) secondway -= prefix [ j - 1 ] ; int answer = count * ( count - 1 ) * secondway * ( secondway - 1 ) ; answer /= 4 ; answer += ( pairsum * secondway * ( secondway - 1 ) ) / 2 ; total += answer ; count = 0 ; } } } } return total ; } int main ( ) { string test = "13134422" ; cout << solve ( test ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int l , int m , int x , int y ) { if ( l * m == x + y ) return true ; return false ; } int main ( ) { int l = 3 , m = 2 , x = 4 , y = 2 ; if ( isPossible ( l , m , x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE int countPairs ( string str , int k ) { int n = str . size ( ) ; int freq [ MAX ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int cnt = 0 ; if ( k == 0 ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( freq [ i ] > 1 ) cnt += ( ( freq [ i ] * ( freq [ i ] - 1 ) ) / 2 ) ; } else { for ( int i = 0 ; i < MAX ; i ++ ) if ( freq [ i ] > 0 && i + k < MAX && freq [ i + k ] > 0 ) cnt += ( freq [ i ] * freq [ i + k ] ) ; ; } return cnt ; } int main ( ) { string str = " abcdab " ; int k = 0 ; cout << countPairs ( str , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n == 0 n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int sumAscii ( string str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i + 1 ) ) sum += ( int ) ( str [ i ] ) ; } return sum ; } int main ( ) { string str = " geeksforgeeks " ; int n = str . size ( ) ; cout << sumAscii ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > graph [ 100 ] ; vector < string > weight ( 100 ) ; bool Pangram ( string x ) { map < char , int > mp ; int n = x . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp [ x [ i ] ] ++ ; if ( mp . size ( ) == 26 ) return true ; else return false ; } int countTotalPangram ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( Pangram ( weight [ i ] ) ) cnt ++ ; return cnt ; } void dfs ( int node , int parent ) { for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; weight [ node ] += weight [ to ] ; } } int main ( ) { int n = 6 ; weight [ 1 ] = " abcde " ; weight [ 2 ] = " fghijkl " ; weight [ 3 ] = " abcdefg " ; weight [ 4 ] = " mnopqr " ; weight [ 5 ] = " stuvwxy " ; weight [ 6 ] = " zabcdef " ; graph [ 1 ] . push_back ( 2 ) ; graph [ 2 ] . push_back ( 3 ) ; graph [ 2 ] . push_back ( 4 ) ; graph [ 1 ] . push_back ( 5 ) ; graph [ 5 ] . push_back ( 6 ) ; dfs ( 1 , 1 ) ; cout << countTotalPangram ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( char s [ ] ) { char * p ; if ( ( p = strstr ( s , " geek " ) ) && ( strstr ( p + 4 , " keeg " ) ) ) return true ; return false ; } int main ( ) { char s [ ] = " geekeekeeg " ; if ( isValid ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCount ( string s , int n , int a , int b ) { int res = 0 ; for ( int i = 0 ; i < b ; i ++ ) { if ( i == a ) res += ( s [ n - i - 1 ] != '1' ) ; else res += ( s [ n - i - 1 ] != '0' ) ; } return res ; } int main ( ) { string str = "1001011001" ; int N = str . size ( ) ; int A = 3 , B = 6 ; cout << findCount ( str , N , A , B ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int NUM = 31 ; void positions ( string str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << ( str [ i ] & NUM ) << " ▁ " ; } } int main ( ) { string str = " Geeks " ; int n = str . length ( ) ; positions ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void permute ( string & str , int l , int r ) { if ( l == r ) { if ( str . find ( " AB " ) == string :: npos ) cout << str << " ▁ " ; return ; } for ( int i = l ; i <= r ; i ++ ) { swap ( str [ l ] , str [ i ] ) ; permute ( str , l + 1 , r ) ; swap ( str [ l ] , str [ i ] ) ; } } int main ( ) { string str = " ABC " ; permute ( str , 0 , str . length ( ) - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lenoflongestnonpalindrome ( string s ) { int max1 = 1 , len = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) len = 0 ; else if ( s [ i + 1 ] == s [ i - 1 ] && i > 0 ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; } int main ( ) { string s = " synapse " ; cout << lenoflongestnonpalindrome ( s ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string makePalindrome ( string str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i <= j ) { if ( str [ i ] == ' * ' && str [ j ] == ' * ' ) { str [ i ] = ' a ' ; str [ j ] = ' a ' ; } else if ( str [ j ] == ' * ' ) str [ j ] = str [ i ] ; else if ( str [ i ] == ' * ' ) str [ i ] = str [ j ] ; else if ( str [ i ] != str [ j ] ) return " - 1" ; i ++ ; j -- ; } return str ; } int main ( ) { string str = " na * an " ; cout << makePalindrome ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calcScore ( string str ) { int score = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; ) { int chunkSize = 1 ; char currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == '1' ) score += pow ( chunkSize , 2 ) ; else score -= pow ( chunkSize , 2 ) ; } return score ; } int main ( ) { string str = "11011" ; cout << calcScore ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubString ( string s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . length ( ) ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; } int main ( ) { string s = " abada " ; char c = ' a ' ; int k = 2 ; cout << countSubString ( s , c , k ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( string str , int n ) { if ( ! ( ( str [ 0 ] >= ' a ' && str [ 0 ] <= ' z ' ) || ( str [ 0 ] >= ' A ' && str [ 0 ] <= ' Z ' ) str [ 0 ] == ' _ ' ) ) return false ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( ! ( ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) || ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= '0' && str [ i ] <= '9' ) str [ i ] == ' _ ' ) ) return false ; } return true ; } int main ( ) { string str = " _ geeks123" ; int n = str . length ( ) ; if ( isValid ( str , n ) ) cout << " Valid " ; else cout << " Invalid " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findM ( string s , int x ) { int cnt = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] - '0' != x ) cnt ++ ; } return cnt ; } int main ( ) { string s = "3662123" ; int x = 6 ; cout << findM ( s , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void FirstAndLast ( string str ) { int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( i == 0 ) cout << str [ i ] ; if ( i == str . length ( ) - 1 ) cout << str [ i ] ; if ( str [ i ] == ' ▁ ' ) { cout << str [ i - 1 ] << " ▁ " << str [ i + 1 ] ; } } } int main ( ) { string str = " Geeks ▁ for ▁ Geeks " ; FirstAndLast ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  64 NEW_LINE int getBitmask ( string s ) { int temp = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == ' s ' ) { temp = temp | ( 1 ) ; } else if ( s [ j ] == ' t ' ) { temp = temp | ( 2 ) ; } else if ( s [ j ] == ' r ' ) { temp = temp | ( 4 ) ; } else if ( s [ j ] == ' i ' ) { temp = temp | ( 8 ) ; } else if ( s [ j ] == ' n ' ) { temp = temp | ( 16 ) ; } else if ( s [ j ] == ' g ' ) { temp = temp | ( 32 ) ; } } return temp ; } int countPairs ( string arr [ ] , int n ) { int bitMask [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) bitMask [ getBitmask ( arr [ i ] ) ] ++ ; int cnt = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i ; j < MAX ; j ++ ) { if ( ( i j ) == ( MAX - 1 ) ) { if ( i == j ) cnt += ( ( bitMask [ i ] * bitMask [ i ] - 1 ) / 2 ) ; else cnt += ( bitMask [ i ] * bitMask [ j ] ) ; } } } return cnt ; } int main ( ) { string arr [ ] = { " strrr " , " string " , " gstrin " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOcc ( string s ) { int cnt = 0 ; for ( int i = 0 ; i < s . length ( ) - 3 ; i ++ ) { int c = 0 , l = 0 , a = 0 , p = 0 ; for ( int j = i ; j < i + 4 ; j ++ ) { switch ( s [ j ] ) { case ' c ' : c ++ ; break ; case ' l ' : l ++ ; break ; case ' a ' : a ++ ; break ; case ' p ' : p ++ ; break ; } } if ( c == 1 && l == 1 && a == 1 && p == 1 ) cnt ++ ; } return cnt ; } int main ( ) { string s = " clapc " ; transform ( s . begin ( ) , s . end ( ) , s . begin ( ) , :: tolower ) ; cout << ( countOcc ( s ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateWays ( string s , int n , int l , int r ) { int freq [ 26 ] ; memset ( freq , 0 , sizeof freq ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < l i > r ) freq [ s [ i ] - ' a ' ] ++ ; } int ways = 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( freq [ s [ i ] - ' a ' ] ) { ways = ways * freq [ s [ i ] - ' a ' ] ; freq [ s [ i ] - ' a ' ] -- ; } else { ways = 0 ; break ; } } return ways ; } int main ( ) { string s = " cabcaab " ; int n = s . length ( ) ; int l = 1 , r = 3 ; cout << calculateWays ( s , n , l , r ) ; return 0 ; }
#include <cstdlib> NEW_LINE #include <iostream> NEW_LINE using namespace std ; char findKthChar ( string s , int k ) { int len = s . length ( ) ; int i = 0 ; int total_len = 0 ; while ( i < len ) { if ( isalpha ( s [ i ] ) ) { total_len ++ ; if ( total_len == k ) return s [ i ] ; i ++ ; } else { int n = 0 ; while ( i < len && ! isalpha ( s [ i ] ) ) { n = n * 10 + ( s [ i ] - '0' ) ; i ++ ; } int next_total_len = total_len * n ; if ( k <= next_total_len ) { int pos = k % total_len ; if ( ! pos ) { pos = total_len ; } return findKthChar ( s , pos ) ; } else { total_len = next_total_len ; } } } return -1 ; } int main ( ) { string s = " ab2c3" ; int k = 5 ; cout << findKthChar ( s , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; bool check_char ( char * st , char ch ) { int l = strlen ( st ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( st [ i ] == ch ) return true ; } return false ; } char find_avg ( char * st ) { int i , sm = 0 ; int l = strlen ( st ) ; char ch ; for ( i = 0 ; i < l ; i ++ ) { ch = st [ i ] ; sm = sm + ( int ) ( ch ) ; } int avg = ( int ) ( floor ( sm / l ) ) ; return ( ( char ) ( avg ) ) ; } int main ( ) { char st [ ] = " ag23sdfa " ; char ch = find_avg ( st ) ; cout << ch << endl ; if ( check_char ( st , ch ) == true ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void asciiToSentence ( string str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; cout << ch ; num = 0 ; } } } int main ( ) { string str = "7110110110711510211111471101101107115" ; int len = str . length ( ) ; asciiToSentence ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDistinctCode ( string str ) { set < string > codes ; for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) codes . insert ( str . substr ( i , 2 ) ) ; return codes . size ( ) ; } int main ( ) { string str = " UPUP " ; cout << countDistinctCode ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int arr [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 } ; int countKeyPressed ( string str , int len ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) count = count + arr [ str [ i ] - ' a ' ] ; return count ; } int main ( ) { string str = " abcdef " ; int len = str . length ( ) ; cout << countKeyPressed ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isReverseEqual ( string s1 , string s2 ) { if ( s1 . length ( ) != s2 . length ( ) ) return false ; int len = s1 . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) if ( s1 [ i ] != s2 [ len - i - 1 ] ) return false ; return true ; } string getWord ( string str [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isReverseEqual ( str [ i ] , str [ j ] ) ) return str [ i ] ; return " - 1" ; } int main ( ) { string str [ ] = { " geeks " , " for " , " skeeg " } ; cout << ( getWord ( str , 3 ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; } int main ( ) { int n = 52 ; cout << minLettersNeeded ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinReversals ( string expr ) { int len = expr . length ( ) ; if ( len % 2 ) return -1 ; int ans = 0 ; int i ; int open = 0 ; int close = 0 ; for ( i = 0 ; i < len ; i ++ ) { if ( expr [ i ] == ' { ' ) open ++ ; else { if ( ! open ) close ++ ; else open -- ; } } ans = ( close / 2 ) + ( open / 2 ) ; close %= 2 ; open %= 2 ; if ( close ) ans += 2 ; return ans ; } int main ( ) { string expr = " } } { { " ; cout << countMinReversals ( expr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minReplacement ( string s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s [ i ] == '1' ) ans ++ ; if ( i % 2 == 1 && s [ i ] == '0' ) ans ++ ; } return min ( ans , len - ans ) ; } int main ( ) { string s = "1100" ; int len = s . size ( ) ; cout << minReplacement ( s , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int substrDeletion ( string str , int len ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count0 ++ ; else count1 ++ ; } return min ( count0 , count1 ) ; } int main ( ) { string str = "010" ; int len = str . length ( ) ; cout << substrDeletion ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string groupCharacters ( string s , int len ) { string temp = " " ; for ( int i = 0 ; i < len ; i ++ ) if ( s [ i ] != ' ▁ ' ) temp = temp + s [ i ] ; len = temp . length ( ) ; string ans = " " ; int i = 0 ; while ( i < len ) { if ( int ( temp [ i ] ) >= int ( ' A ' ) && int ( temp [ i ] ) <= int ( ' Z ' ) ) { while ( i < len && int ( temp [ i ] ) >= int ( ' A ' ) && int ( temp [ i ] ) <= int ( ' Z ' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " ▁ " ; } else if ( int ( temp [ i ] ) >= int ( '0' ) && int ( temp [ i ] ) <= int ( '9' ) ) { while ( i < len && int ( temp [ i ] ) >= int ( '0' ) && int ( temp [ i ] ) <= int ( '9' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " ▁ " ; } else { while ( i < len && int ( temp [ i ] ) >= int ( ' * ' ) && int ( temp [ i ] ) <= int ( ' / ' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " ▁ " ; } } return ans ; } int main ( ) { string s = "34FTG234 + ▁ + - ▁ * " ; int len = s . length ( ) ; cout << groupCharacters ( s , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int prefixOccurrences ( string str ) { char c = str [ 0 ] ; int countc = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == c ) countc ++ ; } return countc ; } int main ( ) { string str = " abbcdabbcd " ; cout << prefixOccurrences ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string leastLexiString ( string s ) { if ( s . size ( ) & 1 ) return s ; string x = leastLexiString ( s . substr ( 0 , s . size ( ) / 2 ) ) ; string y = leastLexiString ( s . substr ( s . size ( ) / 2 ) ) ; return min ( x + y , y + x ) ; } bool areEquivalent ( string a , string b ) { return ( leastLexiString ( a ) == leastLexiString ( b ) ) ; } int main ( ) { string a = " aaba " ; string b = " abaa " ; if ( areEquivalent ( a , b ) ) cout << " YES " << endl ; else cout << " NO " << endl ; a = " aabb " ; b = " abab " ; if ( areEquivalent ( a , b ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) return true ; return false ; } bool checkPossibility ( string s1 , string s2 ) { int l1 = s1 . length ( ) ; int l2 = s2 . length ( ) ; if ( l1 != l2 ) return false ; for ( int i = 0 ; i < l1 ; i ++ ) { if ( isVowel ( s1 [ i ] ) && isVowel ( s2 [ i ] ) ) continue ; else if ( ! ( isVowel ( s1 [ i ] ) ) && ! ( isVowel ( s2 [ i ] ) ) ) continue ; else return false ; } return true ; } int main ( ) { string S1 = " abcgle " , S2 = " ezggli " ; if ( checkPossibility ( S1 , S2 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateString ( int A , int B ) { string rt ; while ( 0 < A 0 < B ) { if ( A < B ) { if ( 0 < B -- ) rt . push_back ( ' b ' ) ; if ( 0 < B -- ) rt . push_back ( ' b ' ) ; if ( 0 < A -- ) rt . push_back ( ' a ' ) ; } else if ( B < A ) { if ( 0 < A -- ) rt . push_back ( ' a ' ) ; if ( 0 < A -- ) rt . push_back ( ' a ' ) ; if ( 0 < B -- ) rt . push_back ( ' b ' ) ; } else { if ( 0 < A -- ) rt . push_back ( ' a ' ) ; if ( 0 < B -- ) rt . push_back ( ' b ' ) ; } } cout << rt ; } int main ( ) { int A = 2 , B = 6 ; generateString ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countStrings ( int n , int m , string s [ ] ) { unordered_set < int > ind ; for ( int j = 0 ; j < m ; j ++ ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) mx = max ( mx , ( int ) s [ i ] [ j ] - '0' ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] [ j ] - '0' == mx ) ind . insert ( i ) ; } return ind . size ( ) ; } int main ( ) { string s [ ] = { "223" , "232" , "112" } ; int m = s [ 0 ] . length ( ) ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; cout << countStrings ( n , m , s ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string s , string t , int n ) { int ct0 = 0 , ct1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == t [ i ] ) continue ; if ( s [ i ] == '0' ) ct0 ++ ; else ct1 ++ ; } return max ( ct0 , ct1 ) ; } int main ( ) { string s = "010" , t = "101" ; int n = s . length ( ) ; cout << minOperations ( s , t , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string getSubSeq ( string s , int n ) { string res = " " ; int cr = 0 ; while ( cr < n ) { char mx = s [ cr ] ; for ( int i = cr + 1 ; i < n ; i ++ ) mx = max ( mx , s [ i ] ) ; int lst = cr ; for ( int i = cr ; i < n ; i ++ ) if ( s [ i ] == mx ) { res += s [ i ] ; lst = i ; } cr = lst + 1 ; } return res ; } int main ( ) { string s = " geeksforgeeks " ; int n = s . length ( ) ; cout << getSubSeq ( s , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinimalReplacements ( string s ) { int n = s . length ( ) ; int mini = INT_MAX ; string dup = "012" ; do { int dif = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] != dup [ i % 3 ] ) dif ++ ; mini = min ( mini , dif ) ; } while ( next_permutation ( dup . begin ( ) , dup . end ( ) ) ) ; return mini ; } int main ( ) { string s = "2101200" ; cout << countMinimalReplacements ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string decryptString ( string str , int n ) { int i = 0 , jump = 1 ; string decryptedStr = " " ; while ( i < n ) { decryptedStr += str [ i ] ; i += jump ; jump ++ ; } return decryptedStr ; } int main ( ) { string str = " geeeeekkkksssss " ; int n = str . length ( ) ; cout << decryptString ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubStr ( string str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; } int main ( ) { string str = "33445" ; int len = str . length ( ) ; int k = 11 ; cout << countSubStr ( str , len , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; char Colour_Combination ( string s ) { char temp = s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' B ' temp == ' G ' ) && ( s [ i ] == ' G ' s [ i ] == ' B ' ) ) temp = ' Y ' ; else if ( ( temp == ' B ' temp == ' Y ' ) && ( s [ i ] == ' Y ' s [ i ] == ' B ' ) ) temp = ' G ' ; else temp = ' B ' ; } } return temp ; } int main ( int argc , char * * argv ) { string s = " GBYGB " ; cout << Colour_Combination ( s ) ; }
#include <iostream> NEW_LINE using namespace std ; void reverse ( string str , int x ) { int n = ( str . length ( ) - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) cout << str [ i ] ; for ( int i = n + x - 1 ; i >= n ; i -- ) cout << str [ i ] ; for ( int i = n + x ; i < str . length ( ) ; i ++ ) cout << str [ i ] ; } int main ( ) { string str = " geeksforgeeks " ; int x = 3 ; reverse ( str , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSteps ( string str , int i , int j , int n ) { int k = i + 1 ; int steps = 0 ; char ch = str [ i ] ; while ( k <= j ) { if ( str [ k ] != ch ) { steps ++ ; ch = str [ k ] ; } k ++ ; } return steps ; } int getMinSteps ( string str , int i , int j , int n ) { if ( j < i ) { int temp = i ; i = j ; j = temp ; } int stepsToRight = getSteps ( str , i , j , n ) ; int stepsToLeft = getSteps ( str , 0 , i , n ) + getSteps ( str , j , n - 1 , n ) ; if ( str [ 0 ] != str [ n - 1 ] ) stepsToLeft ++ ; return min ( stepsToLeft , stepsToRight ) ; } int main ( ) { string str = " SSNSS " ; int n = str . length ( ) ; int i = 0 , j = 3 ; cout << getMinSteps ( str , i , j , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 256 ; int countSubStrings ( string s , string anotherStr , int k ) { bool illegal [ MAX_CHAR ] = { false } ; for ( int i = 0 ; i < anotherStr . size ( ) ; i ++ ) illegal [ anotherStr [ i ] ] = true ; unordered_set < string > us ; for ( int i = 0 ; i < s . size ( ) ; ++ i ) { string ss = " " ; int count = 0 ; for ( int j = i ; j < s . size ( ) ; ++ j ) { if ( illegal [ s [ j ] ] ) ++ count ; ss = ss + s [ j ] ; if ( count <= k ) { us . insert ( ss ) ; } else break ; } } return us . size ( ) ; } int main ( ) { string str = " acbacbacaa " ; string anotherStr = " abcdefghijklmnopqrstuvwxyz " ; int k = 2 ; cout << countSubStrings ( str , anotherStr , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( string bracks [ ] , int num ) { unordered_map < int , int > open , close ; int cnt = 0 ; for ( int i = 0 ; i < num ; i ++ ) { string s = bracks [ i ] ; int l = s . length ( ) ; int op = 0 , cl = 0 ; for ( int j = 0 ; j < l ; j ++ ) { if ( s [ j ] == ' ( ' ) op ++ ; { if ( op ) op -- ; cl ++ ; } } if ( op && ! cl ) open [ op ] ++ ; if ( cl && ! op ) close [ cl ] ++ ; if ( ! op && ! cl ) cnt ++ ; } cnt = cnt / 2 ; for ( auto it : open ) cnt += min ( it . second , close [ it . first ] ) ; return cnt ; } int main ( ) { string bracks [ ] = { " ) ( ) ) " , " ) " , " ( ( " , " ( ( " , " ( " , " ) " , " ) " } ; int num = sizeof ( bracks ) / sizeof ( bracks [ 0 ] ) ; cout << countPairs ( bracks , num ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string decrypt ( string s , int l ) { string ans = " " ; if ( l % 2 ) { int cnt = 0 ; int indl = 0 , indr = l - 1 ; while ( ans . size ( ) != l ) { if ( cnt % 2 == 0 ) ans += s [ indl ++ ] ; else ans += s [ indr -- ] ; cnt ++ ; } } else { int cnt = 0 ; int indl = 0 , indr = l - 1 ; while ( ans . size ( ) != l ) { if ( cnt % 2 == 0 ) ans += s [ indr -- ] ; else ans += s [ indl ++ ] ; cnt ++ ; } } reverse ( ans . begin ( ) , ans . end ( ) ) ; return ans ; } int main ( ) { string s = " segosegekfrek " ; int l = s . length ( ) ; cout << decrypt ( s , l ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len / 2 ; i ++ ) { if ( str [ i ] != str [ len - 1 - i ] ) return false ; } return true ; } bool createStringAndCheckPalindrome ( int N ) { ostringstream out ; out << N ; string result = out . str ( ) ; string sub = " " + result , res_str = " " ; int sum = 0 ; while ( N > 0 ) { int digit = N % 10 ; sum += digit ; N = N / 10 ; } while ( res_str . length ( ) < sum ) res_str += sub ; if ( res_str . length ( ) > sum ) res_str = res_str . substr ( 0 , sum ) ; if ( isPalindrome ( res_str ) ) return true ; return false ; } int main ( ) { int N = 10101 ; if ( createStringAndCheckPalindrome ( N ) ) cout << ( " Yes " ) ; else cout << ( " No " ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeChars ( string s ) { string modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( isupper ( s [ i ] ) && islower ( s [ i - 1 ] ) || islower ( s [ i ] ) && isupper ( s [ i - 1 ] ) ) modifiedStr += s [ i ] ; } return modifiedStr ; } int main ( ) { string s = " GeeksForGeeks " ; cout << removeChars ( s ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void pairStar ( string & input , string & output , int i = 0 ) { output = output + input [ i ] ; if ( i == input . length ( ) - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' * ' ; pairStar ( input , output , i + 1 ) ; } int main ( ) { string input = " geeks " , output = " " ; pairStar ( input , output ) ; cout << output << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxOperations ( string str ) { int i , g , gk , gks ; i = g = gk = gks = 0 ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' g ' ) { g ++ ; } else if ( str [ i ] == ' k ' ) { if ( g > 0 ) { g -- ; gk ++ ; } } else if ( str [ i ] == ' s ' ) { if ( gk > 0 ) { gk -- ; gks ++ ; } } } return gks ; } int main ( ) { string a = " ggkssk " ; cout << maxOperations ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int * getFrequencies ( string str ) { static int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } return freq ; } int countMinParts ( string str ) { int n = str . length ( ) ; int * freq = getFrequencies ( str ) ; vector < int > oddFreq , evenFreq ; int i , sumEven = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) continue ; if ( freq [ i ] % 2 == 0 ) evenFreq . push_back ( freq [ i ] ) ; else oddFreq . push_back ( freq [ i ] ) ; } for ( i = 0 ; i < evenFreq . size ( ) ; i ++ ) { sumEven += evenFreq [ i ] ; } if ( oddFreq . size ( ) == 0 ) return 1 ; if ( sumEven == 0 ) { if ( oddFreq . size ( ) == 1 ) return 1 ; return 0 ; } i = 0 ; while ( i < oddFreq . size ( ) ) { if ( ( sumEven / 2 ) % oddFreq . size ( ) == 0 ) return oddFreq . size ( ) ; if ( oddFreq [ i ] == 1 ) { i ++ ; continue ; } sumEven += 2 ; oddFreq [ i ] = oddFreq [ i ] - 2 ; } return n ; } int main ( ) { string s = " noonpeep " ; cout << countMinParts ( s ) ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; bool prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } bool isVowel ( char c ) { c = tolower ( c ) ; if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) return true ; return false ; } bool isValidString ( string word ) { int cnt = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { if ( isVowel ( word [ i ] ) ) cnt ++ ; } if ( prime ( cnt ) ) return true ; else return false ; } int main ( ) { string s = " geeksforgeeks " ; if ( isValidString ( s ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printExpansion ( string str ) { string suff = " " ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { suff = suff + str [ i ] ; cout << suff ; } } int main ( ) { string str = " geeks " ; printExpansion ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char logicalExpressionEvaluation ( string str ) { stack < char > arr ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' [ ' ) { vector < char > s ; while ( arr . top ( ) != ' ] ' ) { s . push_back ( arr . top ( ) ) ; arr . pop ( ) ; } arr . pop ( ) ; if ( s . size ( ) == 3 ) { s [ 2 ] == '1' ? arr . push ( '0' ) : arr . push ( '1' ) ; } else if ( s . size ( ) == 5 ) { int a = s [ 0 ] - 48 , b = s [ 4 ] - 48 , c ; s [ 2 ] == ' & ' ? c = a && b : c = a || b ; arr . push ( ( char ) c + 48 ) ; } } else { arr . push ( str [ i ] ) ; } } return arr . top ( ) ; } int main ( ) { string str = " [ [0 , & ,1 ] , | , [ ! ,1 ] ] " ; cout << logicalExpressionEvaluation ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( string s , int k ) { int n = s . length ( ) ; int d = 0 , i ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) d += s [ i ] ; if ( d % k == 0 ) count += 1 ; for ( i = k ; i < n ; i ++ ) { int prev = s [ i - k ] ; d -= prev ; d += s [ i ] ; if ( d % k == 0 ) count += 1 ; } return count ; } int main ( ) { string s = " bcgabc " ; int k = 3 ; int ans = count ( s , k ) ; cout << ( ans ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string printFinalString ( string s ) { int i , n ; n = s . length ( ) ; int x = 0 , y = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' x ' ) x ++ ; else y ++ ; } string finalString = " " ; if ( x > y ) for ( i = 0 ; i < x - y ; i ++ ) finalString += " x " ; else for ( i = 0 ; i < y - x ; i ++ ) finalString += " y " ; return finalString ; } int main ( ) { string s = " xxyyxyy " ; cout << printFinalString ( s ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string K_String ( string s , int k ) { int n = s . size ( ) ; int fre [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - ' a ' ] ++ ; string str = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % k == 0 ) { int x = fre [ i ] / k ; while ( x -- ) { str += ( char ) ( i + ' a ' ) ; } } else { return " - 1" ; } } return str ; } int main ( ) { string s = " aabb " ; int k = 2 ; cout << K_String ( s , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } void sumProdOfPrimeFreq ( string s ) { bool prime [ s . length ( ) + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , s . length ( ) + 1 ) ; int i , j ; unordered_map < char , int > m ; for ( i = 0 ; i < s . length ( ) ; i ++ ) m [ s [ i ] ] ++ ; int sum = 0 , product = 1 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( prime [ it -> second ] ) { sum += it -> second ; product *= it -> second ; } } cout << " Sum ▁ = ▁ " << sum ; cout << " Product = " } int main ( ) { string s = " geeksforgeeks " ; sumProdOfPrimeFreq ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_map < int , int > countt ; bool canBePalindrome ( unordered_map < int , int > & countt ) { for ( auto key : countt ) { if ( key . second & 1 ) return false ; } return true ; } int maxPal ( string str , unordered_map < int , int > & countt , int start , int end ) { if ( end == str . length ( ) ) { if ( ( end - start ) % 2 == 0 ) if ( canBePalindrome ( countt ) ) return end - start ; return 0 ; } else { if ( ( end - start ) % 2 == 0 ) { if ( canBePalindrome ( countt ) ) { countt [ str [ end ] ] ++ ; return max ( end - start , maxPal ( str , countt , start , end + 1 ) ) ; } else { countt [ str [ end ] ] ++ ; return maxPal ( str , countt , start , end + 1 ) ; } } else { countt [ str [ end ] ] ++ ; unordered_map < int , int > c ( countt . begin ( ) , countt . end ( ) ) ; int length = maxPal ( str , c , start , end + 1 ) ; countt [ str [ end ] ] -- ; countt [ str [ start ] ] -- ; return max ( length , maxPal ( str , countt , start + 1 , end ) ) ; } } } int main ( int argc , char const * argv [ ] ) { string str = "124565463" ; int start = 0 , end = 0 ; cout << maxPal ( str , countt , start , end ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; unordered_map < char , int > m ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] and str [ i ] <= r ) ) { cnt ++ ; if ( m [ str [ i ] ] != 1 ) { cout << str [ i ] << " ▁ " ; m [ str [ i ] ] ++ ; } } } return cnt ; } int main ( ) { string str = " geeksforgeeks " ; int l = 102 , r = 111 ; cout << " Characters ▁ with ▁ ASCII ▁ values " " ▁ not ▁ in ▁ the ▁ range ▁ [ l , ▁ r ] ▁ STRNEWLINE in ▁ the ▁ given ▁ string ▁ are : ▁ " ; cout << " and their count is " << CountCharacters ( str , l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CountWords ( string str , int k ) { int sum = 0 ; int NumberOfWords = 0 ; int counter = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { if ( str [ i ] == ' ▁ ' ) { if ( sum < k ) counter ++ ; sum = 0 ; NumberOfWords ++ ; } else sum += str [ i ] ; } NumberOfWords ++ ; if ( sum < k ) counter ++ ; cout << " Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ ASCII " " ▁ values ▁ less ▁ than ▁ k ▁ = ▁ " << counter << endl ; cout << " Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ ASCII ▁ values " " ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ k ▁ = ▁ " << NumberOfWords - counter ; } int main ( ) { string str = " Learn ▁ how ▁ to ▁ code " ; int k = 400 ; CountWords ( str , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; int countPalindrome ( string str ) { int n = str . size ( ) ; int sum = 0 ; int hashTable [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hashTable [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( hashTable [ i ] ) sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) / 2 ) ; } return sum ; } int main ( ) { string str = " ananananddd " ; cout << countPalindrome ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countConsecutive ( string s ) { int count = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) i ++ ; else count ++ ; } return count ; } int main ( ) { string str = "44522255" ; cout << countConsecutive ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool multipleOrFactor ( string s1 , string s2 ) { map < char , int > m1 , m2 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) m1 [ s1 [ i ] ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) m2 [ s2 [ i ] ] ++ ; map < char , int > :: iterator it ; for ( it = m1 . begin ( ) ; it != m1 . end ( ) ; it ++ ) { if ( m2 . find ( ( * it ) . first ) == m2 . end ( ) ) continue ; if ( m2 [ ( * it ) . first ] % ( * it ) . second == 0 || ( * it ) . second % m2 [ ( * it ) . first ] == 0 ) continue ; else return false ; } } int main ( ) { string s1 = " geeksforgeeks " ; string s2 = " geeks " ; multipleOrFactor ( s1 , s2 ) ? cout << " YES " : cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int check_digits ( int n ) { while ( n ) { return 0 ; n /= 10 ; } return 1 ; } int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) ) return i ; } int main ( ) { int N = 2397 ; cout << smallest_number ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestNumber ( int n ) { int num = 0 ; string s = " " ; int duplicate = n ; while ( n ) { s = char ( n % 10 + 48 ) + s ; n /= 10 ; } int index = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int digit = s [ i ] - '0' ; if ( ( digit & 1 ) == 0 ) { index = i ; break ; } } if ( index == -1 ) return duplicate ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' + 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 1 ; return num ; } int main ( ) { int N = 2397 ; cout << smallestNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( l <= str [ i ] and str [ i ] <= r ) { cnt ++ ; cout << str [ i ] << " ▁ " ; } } return cnt ; } int main ( ) { string str = " geeksforgeeks " ; int l = 102 , r = 111 ; cout << " Characters ▁ with ▁ ASCII ▁ values " " ▁ in ▁ the ▁ range ▁ [ l , ▁ r ] ▁ are ▁ STRNEWLINE " ; cout << " and their count is " << CountCharacters ( str , l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) - 2 ; i ++ ) { if ( str [ i ] == '0' ) { if ( str [ i + 1 ] == '1' ) { if ( str [ i + 2 ] == '0' ) { count ++ ; i += 2 ; } } } } return count ; } int main ( ) { string str = "0101010" ; cout << minSteps ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } int xorOfPrime ( string s ) { bool prime [ 100005 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , 10005 ) ; int i , j ; map < char , int > m ; for ( i = 0 ; i < s . length ( ) ; i ++ ) m [ s [ i ] ] ++ ; int result = 0 ; int flag = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( prime [ it -> second ] ) { result ^= it -> second ; flag = 1 ; } } if ( ! flag ) return -1 ; return result ; } int main ( ) { string s = " gggggeeekkkks " ; cout << xorOfPrime ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountCharacters ( string str , int k ) { int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] < k ) cnt ++ ; } return cnt ; } int main ( ) { string str = " GeeksForGeeks " ; int k = 90 ; int count = CountCharacters ( str , k ) ; cout << " Characters ▁ with ▁ ASCII ▁ values " " ▁ less ▁ than ▁ K ▁ are ▁ " << count ; cout << " Characters with ASCII values " STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL " greater than or equal to K are " << str . length ( ) - count ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_set < string > seen ; vector < int > edges ; void dfs ( string node , int & k , string & A ) { for ( int i = 0 ; i < k ; ++ i ) { string str = node + A [ i ] ; if ( seen . find ( str ) == seen . end ( ) ) { seen . insert ( str ) ; dfs ( str . substr ( 1 ) , k , A ) ; edges . push_back ( i ) ; } } } string deBruijn ( int n , int k , string A ) { seen . clear ( ) ; edges . clear ( ) ; string startingNode = string ( n - 1 , A [ 0 ] ) ; dfs ( startingNode , k , A ) ; string S ; int l = pow ( k , n ) ; for ( int i = 0 ; i < l ; ++ i ) S += A [ edges [ i ] ] ; S += startingNode ; return S ; } int main ( ) { int n = 3 , k = 2 ; string A = "01" ; cout << deBruijn ( n , k , A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string isFibonacci ( string s ) { map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } vector < int > v ; int n = m . size ( ) ; int a = 1 , b = 1 ; int c ; v . push_back ( a ) ; v . push_back ( b ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { v . push_back ( a + b ) ; c = a + b ; a = b ; b = c ; } int flag = 1 ; int i = 0 ; for ( auto itr = m . begin ( ) ; itr != m . end ( ) ; itr ++ ) { if ( itr -> second != v [ i ] ) { flag = 0 ; break ; } i ++ ; } if ( flag == 1 ) return " YES " ; else return " NO " ; } int main ( ) { string s = " abeeedd " ; cout << isFibonacci ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string smallest ( string s ) { int l = s . length ( ) ; string ans = " " ; for ( int i = 0 ; i < l - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) { for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) ans += s [ j ] ; } return ans ; } } ans = s . substr ( 0. , l - 1 ) ; return ans ; } int main ( ) { string s = " abcda " ; cout << smallest ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { f = f * i ; } return f ; } int npr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; } int countPermutations ( string str ) { int even = floor ( str . length ( ) / 2 ) ; int odd = str . length ( ) - even ; int ways = 0 ; int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ++ freq [ str [ i ] - ' a ' ] ; } int nvowels = freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ; int nconsonants = str . length ( ) - nvowels ; ways = npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ; return ways ; } int main ( ) { string str = " geeks " ; cout << countPermutations ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string replacingConsonants ( string s ) { char nVowel [ ] = " aaaeeeeiiiiioooooouuuuuuuu " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) s [ i ] = nVowel [ s [ i ] - ' a ' ] ; return s ; } int main ( ) { string s = " geeksforgeeks " ; cout << replacingConsonants ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' ) return false ; return true ; } string replaceConsonants ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! isVowel ( s [ i ] ) ) { if ( s [ i ] == ' z ' ) s [ i ] = ' b ' ; else { s [ i ] = ( char ) ( s [ i ] + 1 ) ; if ( isVowel ( s [ i ] ) ) s [ i ] = ( char ) ( s [ i ] + 1 ) ; } } } return s ; } int main ( ) { string s = " geeksforgeeks " ; cout << replaceConsonants ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; string removeChars ( string str , int k ) { int hash [ MAX_CHAR ] = { 0 } ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; ++ i ) hash [ str [ i ] - ' a ' ] ++ ; string res = " " ; for ( int i = 0 ; i < n ; ++ i ) { if ( hash [ str [ i ] - ' a ' ] >= k ) { res += str [ i ] ; } } return res ; } int main ( ) { string str = " geeksforgeeks " ; int k = 2 ; cout << removeChars ( str , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOnOff ( string n ) { int Led [ ] = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 } ; int len = n . length ( ) ; int sum = Led [ n [ 0 ] - '0' ] ; for ( int i = 1 ; i < len ; i ++ ) { sum = sum + abs ( Led [ n [ i ] - '0' ] - Led [ n [ i - 1 ] - '0' ] ) ; } return sum ; } int main ( ) { string n = "082" ; cout << countOnOff ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_length_substring ( string st , int n , int k ) { int max_len = 0 ; int len = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( st [ i ] == '0' ) len ++ ; else len = 0 ; max_len = max ( max_len , len ) ; } if ( max_len == n ) return n * k ; int pref = 0 , suff = 0 ; for ( int i = 0 ; st [ i ] == '0' ; ++ i , ++ pref ) ; for ( int i = n - 1 ; st [ i ] == '0' ; -- i , ++ suff ) ; if ( k > 1 ) max_len = max ( max_len , pref + suff ) ; return max_len ; } int main ( ) { int n = 6 ; int k = 3 ; string st = "110010" ; int ans = max_length_substring ( st , n , k ) ; cout << ans ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidSubString ( string r , int K , int p ) { int c = 0 ; for ( int i = 0 ; i < r . length ( ) ; i ++ ) { if ( ( int ) r [ i ] > p ) c ++ ; } if ( c == K ) return true ; else return false ; } void countSubStrings ( string s , int K , int p ) { int l = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = K ; ( i + j ) <= l ; j ++ ) { string r = s . substr ( i , j ) ; if ( isValidSubString ( r , K , p ) ) count ++ ; } } cout << count << " STRNEWLINE " ; } int main ( ) { string s = " abepztydba " ; int K = 4 ; int p = 110 ; countSubStrings ( s , K , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( string S , int X ) { int count = 0 ; const int N = S . length ( ) ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] != '0' ) { for ( int len = 1 ; ( i + len ) <= N ; ++ len ) { if ( stoi ( S . substr ( i , len ) ) > X ) count ++ ; } } } return count ; } int main ( ) { string S = "2222" ; int X = 97 ; cout << count ( S , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isBinary ( int n ) { while ( n != 0 ) { int temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = n / 10 ; } return true ; } void formBinaryStr ( int n , int a [ ] ) { bool flag = true ; string s = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( isBinary ( a [ i ] ) ) s += to_string ( a [ i ] ) ; else { flag = false ; break ; } } if ( flag ) cout << s << " STRNEWLINE " ; else cout << " - 1 STRNEWLINE " ; } int main ( ) { int a [ ] = { 10 , 1 , 0 , 11 , 10 } ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; formBinaryStr ( N , a ) ; return 0 ; }
using namespace std ; bool checkPalindrome ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ s . length ( ) - i - 1 ] ) return false ; } return true ; } bool CheckOdd ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { string x = " " ; for ( int j = i ; j < n ; j ++ ) { x += s [ j ] ; if ( x . length ( ) % 2 == 0 && checkPalindrome ( x ) == true ) return false ; } } return true ; } int main ( ) { string s = " geeksforgeeks " ; if ( CheckOdd ( s ) ) cout << ( " YES " ) ; else cout << ( " NO " ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int fact ( int n ) { long long result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result *= i ; return result ; } int getResult ( string str , char ch ) { int has [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) has [ str [ i ] - ' A ' ] ++ ; int particular = has [ ch - ' A ' ] ; if ( particular == 0 ) return 0 ; has [ ch - ' A ' ] = 0 ; int total = str . length ( ) ; total = total - particular + 1 ; long long int result = fact ( total ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( has [ i ] > 1 ) { result = result / fact ( has [ i ] ) ; } } return result ; } int main ( ) { string str = " MISSISSIPPI " ; cout << getResult ( str , ' S ' ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isAnyNotPalindrome ( string s ) { set < char > unique ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) unique . insert ( s [ i ] ) ; if ( unique . size ( ) > 1 ) return true ; else return false ; } int main ( ) { string s = " aaaaab " ; if ( isAnyNotPalindrome ( s ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long int NEW_LINE ll factorial ( ll n ) { ll res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) res = res * i ; return res ; } ll count ( string word ) { ll freq [ 27 ] = { 0 } ; ll vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { freq [ word [ i ] - ' A ' ] ++ ; if ( word [ i ] == ' A ' word [ i ] == ' E ' word [ i ] == ' I ' word [ i ] == ' O ' word [ i ] == ' U ' ) { vowel ++ ; } else consonant ++ ; } ll vowelArrange ; vowelArrange = factorial ( vowel ) ; vowelArrange /= factorial ( freq [ 0 ] ) ; vowelArrange /= factorial ( freq [ 4 ] ) ; vowelArrange /= factorial ( freq [ 8 ] ) ; vowelArrange /= factorial ( freq [ 14 ] ) ; vowelArrange /= factorial ( freq [ 20 ] ) ; ll consonantArrange ; consonantArrange = factorial ( consonant ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 ) consonantArrange /= factorial ( freq [ i ] ) ; } ll total = vowelArrange * consonantArrange ; return total ; } int main ( ) { string word = " COMPUTER " ; ll ans = count ( word ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string s ) { string s1 = " " ; int N = s . length ( ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) s1 += s [ i ] ; if ( s == s1 ) return true ; return false ; } bool createString ( int N ) { string str = " " ; string s = to_string ( N ) ; string letters = " abcdefghij " ; int sum = 0 ; string substr = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int digit = s [ i ] - '0' ; substr += letters [ digit ] ; sum += digit ; } while ( str . length ( ) <= sum ) { str += substr ; } str = str . substr ( 0 , sum ) ; return isPalindrome ( str ) ; } int main ( ) { int N = 61 ; bool flag = createString ( N ) ; if ( flag ) cout << " YES " ; else cout << " NO " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long productAscii ( string str ) { long long prod = 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= ( int ) str [ i ] ; } return prod ; } int main ( ) { string str = " GfG " ; cout << productAscii ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s ) { int n = s . length ( ) ; int Presum [ n ] ; Presum [ 0 ] = s [ 0 ] - '0' ; for ( int i = 1 ; i < n ; i ++ ) { Presum [ i ] = Presum [ i - 1 ] + ( s [ i ] - '0' ) ; } for ( int i = 1 ; i <= n - 1 ; i ++ ) { int sum = Presum [ i - 1 ] ; int presum = 0 ; int it = i ; int flag = 0 ; while ( it < n ) { presum += s [ it ] - '0' ; if ( presum == sum ) { presum = 0 ; flag = 1 ; } else if ( presum > sum ) { break ; } it ++ ; } if ( presum == 0 && it == n && flag == 1 ) { return true ; } } return false ; } int main ( ) { string s = "73452" ; if ( check ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void balancedString ( string str ) { int count = 0 , i ; int n = str . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) { cout << str [ i ] ; count ++ ; } else if ( str [ i ] == ' ) ' && count != 0 ) { cout << str [ i ] ; count -- ; } else if ( str [ i ] != ' ) ' ) cout << str [ i ] ; } if ( count != 0 ) for ( i = 0 ; i < count ; i ++ ) cout << " ) " ; } int main ( ) { string str = " gau ) ra ) v ( ku ( mar ( rajput ) ) " ; balancedString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countStrings ( string s ) { long sum = 1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( i % 2 == 0 && s [ i ] == ' $ ' ) sum *= 21 ; else if ( s [ i ] == ' $ ' ) sum *= 5 ; } return sum ; } int main ( ) { string str = " s $ $ e $ " ; cout << countStrings ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <string> NEW_LINE using namespace std ; string removeDuplicatesFromString ( string str ) { int counter = 0 ; int i = 0 ; int size = str . size ( ) ; int x ; int length = 0 ; while ( i < size ) { x = str [ i ] - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = ' a ' + x ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return str . substr ( 0 , length ) ; } int main ( ) { string str = " geeksforgeeks " ; cout << removeDuplicatesFromString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeDuplicatesFromString ( string str ) { vector < int > table ( 256 , 0 ) ; vector < char > chars ; for ( auto i : str ) chars . push_back ( i ) ; int endIndex = 0 ; for ( int i = 0 ; i < chars . size ( ) ; i ++ ) { if ( table [ chars [ i ] ] == 0 ) { table [ chars [ i ] ] = -1 ; chars [ endIndex ++ ] = chars [ i ] ; } } string ans = " " ; for ( int i = 0 ; i < endIndex ; i ++ ) ans += chars [ i ] ; return ans ; } int main ( ) { string str = " geeksforgeeks " ; cout << ( removeDuplicatesFromString ( str ) ) << endl ; }
#include <iostream> NEW_LINE using namespace std ; int firstPos ( string str , int start , int end ) { int firstChar = -1 ; for ( int i = start ; i <= end ; i ++ ) { if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { firstChar = i ; break ; } } return firstChar ; } int lastPos ( string str , int start , int end ) { int lastChar = -1 ; for ( int i = start ; i >= end ; i -- ) { if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { lastChar = i ; break ; } } return lastChar ; } bool isPalindrome ( string str ) { int firstChar = 0 , lastChar = str . length ( ) - 1 ; bool ch = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { firstChar = firstPos ( str , firstChar , lastChar ) ; lastChar = lastPos ( str , lastChar , firstChar ) ; if ( lastChar < 0 firstChar < 0 ) break ; if ( str [ firstChar ] == str [ lastChar ] ) { firstChar ++ ; lastChar -- ; continue ; } ch = false ; break ; } return ( ch ) ; } int main ( ) { string str = " m TABSYMBOL a ▁ 343 ▁ la ▁ y ▁ a ▁ l ▁ am " ; if ( isPalindrome ( str ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool arePermutation ( string str1 , string str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 != n2 ) return false ; sort ( str1 . begin ( ) , str1 . end ( ) ) ; sort ( str2 . begin ( ) , str2 . end ( ) ) ; for ( int i = 0 ; i < n1 ; i ++ ) if ( str1 [ i ] != str2 [ i ] ) return false ; return true ; } int main ( ) { string str1 = " test " ; string str2 = " ttew " ; if ( arePermutation ( str1 , str2 ) ) printf ( " Yes " ) ; else printf ( " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; # define NO_OF_CHARS  256 NEW_LINE bool arePermutation ( string str1 , string str2 ) { int count1 [ NO_OF_CHARS ] = { 0 } ; int count2 [ NO_OF_CHARS ] = { 0 } ; int i ; for ( i = 0 ; str1 [ i ] && str2 [ i ] ; i ++ ) { count1 [ str1 [ i ] ] ++ ; count2 [ str2 [ i ] ] ++ ; } if ( str1 [ i ] str2 [ i ] ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; } int main ( ) { string str1 = " geeksforgeeks " ; string str2 = " forgeeksgeeks " ; if ( arePermutation ( str1 , str2 ) ) printf ( " Yes " ) ; else printf ( " No " ) ; return 0 ; }
bool arePermutation ( string str1 , string str2 ) { int count [ NO_OF_CHARS ] = { 0 } ; int i ; for ( i = 0 ; str1 [ i ] && str2 [ i ] ; i ++ ) { count [ str1 [ i ] ] ++ ; count [ str2 [ i ] ] -- ; } if ( str1 [ i ] str2 [ i ] ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] ) return false ; return true ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLongestSub ( string bin ) { int n = bin . length ( ) , i ; int sum = 0 ; unordered_map < int , int > prevSum ; int maxlen = 0 ; int currlen ; for ( i = 0 ; i < n ; i ++ ) { if ( bin [ i ] == '1' ) sum ++ ; else sum -- ; if ( sum > 0 ) { maxlen = i + 1 ; } else if ( sum <= 0 ) { if ( prevSum . find ( sum - 1 ) != prevSum . end ( ) ) { currlen = i - prevSum [ sum - 1 ] ; maxlen = max ( maxlen , currlen ) ; } } if ( prevSum . find ( sum ) == prevSum . end ( ) ) prevSum [ sum ] = i ; } return maxlen ; } int main ( ) { string bin = "1010" ; cout << findLongestSub ( bin ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int averageValue ( string s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum_char += ( int ) s [ i ] ; } return sum_char / s . length ( ) ; } int main ( ) { string s = " GeeksforGeeks " ; cout << averageValue ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s , int l ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < l ; i ++ ) { } for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] >= 2 ) return true ; } return false ; } int main ( ) { string s = " geeksforgeeks " ; int l = s . length ( ) ; if ( check ( s , l ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void predictWinner ( string score , int n ) { int count [ 2 ] = { 0 } , i ; for ( i = 0 ; i < score . size ( ) ; i ++ ) { count [ score [ i ] - '0' ] ++ ; if ( count [ 0 ] == n && count [ 1 ] < n - 1 ) { cout << " GEEKS ▁ lost " ; return ; } if ( count [ 1 ] == n && count [ 0 ] < n - 1 ) { cout << " GEEKS ▁ won " ; return ; } if ( count [ 0 ] == n - 1 && count [ 1 ] == n - 1 ) { count [ 0 ] = 0 ; count [ 1 ] = 0 ; break ; } } for ( i ++ ; i < score . size ( ) ; i ++ ) { count [ score [ i ] - '0' ] ++ ; if ( abs ( count [ 0 ] - count [ 1 ] ) == 2 ) { if ( count [ 0 ] > count [ 1 ] ) cout << " GEEKS ▁ lost " ; else cout << " GEEKS ▁ won " ; return ; } } } int main ( ) { string score = "1001010101111011101111" ; int n = 15 ; predictWinner ( score , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str , int l , int r ) { while ( l < r ) { if ( str [ l ] != str [ r ] ) return false ; l ++ ; r -- ; } return true ; } int CyclicShifts ( string str ) { int n = str . length ( ) ; int left = 0 ; int right = n - 1 ; str = str + str ; int cnt = 0 ; while ( right < 2 * n - 1 ) { if ( isPalindrome ( str , left , right ) ) break ; cnt ++ ; left ++ ; right ++ ; } return cnt ; } int main ( ) { string str = " bccbbaab " ; cout << CyclicShifts ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string printString ( int n , string str ) { string str2 = " " ; int extraChar = n % 26 ; if ( extraChar >= 1 ) { for ( int i = 26 - ( extraChar + 1 ) ; i <= 25 ; i ++ ) str2 += str [ i ] ; } int countOfStr = n / 26 ; for ( int i = 1 ; i <= countOfStr ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) str2 += str [ j ] ; } return str2 ; } int main ( ) { int n = 30 ; string str = " zyxwvutsrqponmlkjihgfedcba " ; cout << printString ( n , str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string commonPrefixUtil ( string str1 , string str2 ) { string result ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; for ( int i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 [ i ] != str2 [ j ] ) break ; result . push_back ( str1 [ i ] ) ; } return ( result ) ; } void commonPrefix ( string arr [ ] , int n ) { sort ( arr , arr + n ) ; cout << commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ; } int main ( ) { string arr [ ] = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; commonPrefix ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countDigits ( string st , int n ) { if ( n > 0 ) { int cnt = 1 , i ; string st2 = " " ; for ( i = 1 ; i < st . length ( ) ; i ++ ) { if ( st [ i ] == st [ i - 1 ] ) cnt ++ ; else { st2 += ( '0' + cnt ) ; st2 += st [ i - 1 ] ; cnt = 1 ; } } st2 += ( '0' + cnt ) ; st2 += st [ i - 1 ] ; countDigits ( st2 , -- n ) ; } else cout << st ; } int main ( ) { string num = "123" ; int n = 3 ; countDigits ( num , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateSubsequences ( string input , string output , int idx , vector < string > & ans ) { if ( input [ idx ] == ' \0' ) { if ( output . size ( ) ) ans . push_back ( output ) ; return ; } generateSubsequences ( input , output , idx + 1 , ans ) ; output += input [ idx ] ; generateSubsequences ( input , output , idx + 1 , ans ) ; output . pop_back ( ) ; char upper = input [ idx ] ; upper = toupper ( upper ) ; output += upper ; generateSubsequences ( input , output , idx + 1 , ans ) ; } void printSubsequences ( string S ) { string output ; vector < string > ans ; generateSubsequences ( S , output , 0 , ans ) ; sort ( ans . begin ( ) , ans . end ( ) ) ; for ( auto str : ans ) cout << str << " ▁ " ; } int main ( ) { string S = " ab " ; printSubsequences ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNum ( string s ) { int i = 0 , j = 0 , val = 0 ; map < int , int > mp ; val = ( s [ 0 ] - '0' ) * 100 + ( s [ 1 ] - '0' ) * 10 + ( s [ 2 ] - '0' ) ; mp [ val ] = 1 ; for ( i = 3 ; i < s . length ( ) ; i ++ ) { val = ( val % 100 ) * 10 + s [ i ] - '0' ; if ( mp . find ( val ) != mp . end ( ) ) { mp [ val ] = mp [ val ] + 1 ; } else { mp [ val ] = 1 ; } } for ( auto m : mp ) { int key = m . first ; int value = m . second ; if ( value > 1 ) cout << key << " ▁ - ▁ " << value << " ▁ times " << endl ; } } int main ( ) { string input = "123412345123456" ; printNum ( input ) ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; int countSubstrig ( string str1 , string str2 ) { int n1 = str1 . length ( ) ; int n2 = str2 . length ( ) ; if ( n1 == 0 n1 < n2 ) return 0 ; if ( str1 . substr ( 0 , n2 ) . compare ( str2 ) == 0 ) return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) + 1 ; return countSubstrig ( str1 . substr ( n2 - 1 ) , str2 ) ; } int main ( ) { string str1 = " geeksforgeeks " , str2 = " geeks " ; cout << countSubstrig ( str1 , str2 ) << endl ; str1 = " hikakashi " , str2 = " hi " ; cout << countSubstrig ( str1 , str2 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long NEW_LINE bool hasAllcodes ( string s , int k ) { unordered_set < string > us ; for ( int i = 0 ; i + k <= s . size ( ) ; i ++ ) { us . insert ( s . substr ( i , k ) ) ; } return us . size ( ) == 1 << k ; } signed main ( ) { string s = "00110110" ; int k = 2 ; if ( hasAllcodes ) { cout << " YES STRNEWLINE " ; } else { cout << " NO STRNEWLINE " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string addBinaryUtil ( string a , string b ) { string result = " " ; int s = 0 ; int i = a . size ( ) - 1 , j = b . size ( ) - 1 ; while ( i >= 0 j >= 0 s == 1 ) { s += ( ( i >= 0 ) ? a [ i ] - '0' : 0 ) ; s += ( ( j >= 0 ) ? b [ j ] - '0' : 0 ) ; result = char ( s % 2 + '0' ) + result ; s /= 2 ; i -- ; j -- ; } return result ; } string addBinary ( string arr [ ] , int n ) { string result = " " ; for ( int i = 0 ; i < n ; i ++ ) result = addBinaryUtil ( result , arr [ i ] ) ; return result ; } int main ( ) { string arr [ ] = { "1" , "10" , "11" } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << addBinary ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverse ( char str [ ] , int start , int end ) { char temp ; while ( start <= end ) { temp = str [ start ] ; str [ start ] = str [ end ] ; str [ end ] = temp ; start ++ ; end -- ; } } void reverseletter ( char str [ ] , int start , int end ) { int wstart , wend ; for ( wstart = wend = start ; wend < end ; wend ++ ) { if ( str [ wend ] == ' ▁ ' ) continue ; while ( str [ wend ] != ' ▁ ' && wend <= end ) wend ++ ; wend -- ; reverse ( str , wstart , wend ) ; } } int main ( ) { char str [ 1000 ] = " Ashish ▁ Yadav ▁ Abhishek ▁ Rajput ▁ Sunil ▁ Pundir " ; reverseletter ( str , 0 , strlen ( str ) - 1 ) ; cout << str ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int prefix ( string k , int n ) { int a = 0 , b = 0 , count = 0 ; int i = 0 ; int len = k . size ( ) ; for ( i = 0 ; i < len ; i ++ ) { if ( k [ i ] == ' a ' ) a ++ ; if ( k [ i ] == ' b ' ) b ++ ; if ( a > b ) { count ++ ; } } if ( count == 0 n == 1 ) { cout << count << endl ; return 0 ; } if ( count == len a - b == 0 ) { cout << count * n << endl ; return 0 ; } int n2 = n - 1 , count2 = 0 ; while ( n2 != 0 ) { for ( i = 0 ; i < len ; i ++ ) { if ( k [ i ] == ' a ' ) a ++ ; if ( k [ i ] == ' b ' ) b ++ ; if ( a > b ) { count2 ++ ; } } count += count2 ; n2 -- ; if ( count2 == 0 ) break ; if ( count2 == len ) { count += ( n2 * count2 ) ; break ; } count2 = 0 ; } return count ; } int main ( ) { string S = " aba " ; int N = 2 ; cout << prefix ( S , N ) << endl ; S = " baa " ; N = 3 ; cout << prefix ( S , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  20 NEW_LINE int countPair ( char str [ N ] [ N ] , int n ) { int cnt [ 1 << 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int mask = 0 ; for ( int j = 0 ; str [ i ] [ j ] != ' \0' ; ++ j ) mask |= ( 1 << ( str [ i ] [ j ] - '0' ) ) ; cnt [ mask ] ++ ; } int ans = 0 ; for ( int m1 = 0 ; m1 <= 1023 ; m1 ++ ) for ( int m2 = 0 ; m2 <= 1023 ; m2 ++ ) if ( ( m1 m2 ) == 1023 ) { ans += ( ( m1 == m2 ) ? ( cnt [ m1 ] * ( cnt [ m1 ] - 1 ) ) : ( cnt [ m1 ] * cnt [ m2 ] ) ) ; } return ans / 2 ; } int main ( ) { int n = 5 ; char str [ ] [ N ] = { "129300455" , "5559948277" , "012334556" , "56789" , "123456879" } ; cout << countPair ( str , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define mod  1000000007 NEW_LINE #define max  1001 NEW_LINE using namespace std ; long long int nCr [ 1003 ] [ 1003 ] ; void preComputeCoeff ( ) { for ( int i = 0 ; i < max ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = ( nCr [ i - 1 ] [ j - 1 ] + nCr [ i - 1 ] [ j ] ) % mod ; } } } long long int computeStringCount ( int N ) { int n = N / 2 ; long long int ans = 0 ; for ( int i = 2 ; i <= n ; i += 2 ) ans = ( ans + ( ( nCr [ n ] [ i ] * nCr [ n ] [ i / 2 ] ) % mod ) ) % mod ; return ans ; } int main ( ) { preComputeCoeff ( ) ; int N = 3 ; cout << computeStringCount ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE void countSubsequence ( char s [ ] , int n ) { int cntG = 0 , cntF = 0 , result = 0 , C = 0 ; for ( int i = 0 ; i < n ; i ++ ) { switch ( s [ i ] ) { case ' G ' : cntG ++ ; result += C ; break ; case ' F ' : cntF ++ ; C += cntG ; break ; default : continue ; } } cout << result << endl ; } int main ( ) { char s [ ] = " GFGFG " ; int n = strlen ( s ) ; countSubsequence ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string LexicographicalMaxString ( string str ) { string mx = " " ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) mx = max ( mx , str . substr ( i ) ) ; return mx ; } int main ( ) { string str = " ababaa " ; cout << LexicographicalMaxString ( str ) ; return 0 ; }
#include <iostream> NEW_LINE #include <algorithm> NEW_LINE #include <string> NEW_LINE using namespace std ; bool checkPalin ( string word ) { int n = word . length ( ) ; transform ( word . begin ( ) , word . end ( ) , word . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < n ; i ++ , n -- ) if ( word [ i ] != word [ n - 1 ] ) return false ; return true ; } string longestPalin ( string str ) { str = str + " ▁ " ; string longestword = " " , word = " " ; int length , length1 = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ▁ ' ) word = word + ch ; else { length = word . length ( ) ; if ( checkPalin ( word ) && length > length1 ) { length1 = length ; longestword = word ; } word = " " ; } } return longestword ; } int main ( ) { string s = " My ▁ name ▁ is ▁ ava ▁ and ▁ i ▁ love " " ▁ Geeksforgeeks " ; if ( longestPalin ( s ) == " " ) cout << " No ▁ Palindrome " << " ▁ Word " ; else cout << longestPalin ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCommonBase ( string base , string s1 , string s2 ) { for ( int j = 0 ; j < s1 . length ( ) ; ++ j ) if ( base [ j % base . length ( ) ] != s1 [ j ] ) return false ; for ( int j = 0 ; j < s2 . length ( ) ; ++ j ) if ( base [ j % base . length ( ) ] != s2 [ j ] ) return false ; return true ; } int countCommonBases ( string s1 , string s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; int count = 0 ; for ( int i = 1 ; i <= min ( n1 , n2 ) ; i ++ ) { string base = s1 . substr ( 0 , i ) ; if ( isCommonBase ( base , s1 , s2 ) ) count ++ ; } return count ; } int main ( ) { string s1 = " pqrspqrs " ; string s2 = " pqrspqrspqrspqrs " ; cout << countCommonBases ( s1 , s2 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findstring ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( s . at ( i - 1 ) == '0' && s . at ( i + 1 ) == '0' ) ) { s . erase ( i , 1 ) ; i -- ; if ( i > 0 && s . at ( i - 1 ) == '0' ) i -- ; n = s . length ( ) ; } } return s ; } int main ( ) { cout << findstring ( "100100" ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquareString ( string str ) { int sum = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] ; long double squareRoot = sqrt ( sum ) ; return ( ( squareRoot - floor ( squareRoot ) ) == 0 ) ; } int main ( ) { string str = " d " ; if ( isPerfectSquareString ( str ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_vow ( char c ) { return ( c == ' a ' ) || ( c == ' e ' ) || ( c == ' i ' ) || ( c == ' o ' ) || ( c == ' u ' ) ; } void removeVowels ( string str ) { printf ( " % c " , str [ 0 ] ) ; for ( int i = 1 ; str [ i ] ; i ++ ) if ( ( ! is_vow ( str [ i - 1 ] ) ) || ( ! is_vow ( str [ i ] ) ) ) printf ( " % c " , str [ i ] ) ; } int main ( ) { char str [ ] = " ▁ geeks ▁ for ▁ geeks " ; removeVowels ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNumbers ( int n , int d ) { string st = " " ; st += to_string ( d ) ; char ch = st [ 0 ] ; string p = " " ; p += ch ; for ( int i = 0 ; i <= n ; i ++ ) { st = " " ; st = st + to_string ( i ) ; int idx = st . find ( p ) ; if ( i == d idx != -1 ) cout << ( i ) << " ▁ " ; } } int main ( ) { int n = 100 , d = 5 ; printNumbers ( n , d ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPanDigital ( string s ) { bool digits [ 10 ] = { false } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) digits [ s [ i ] - '0' ] = true ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( digits [ i ] == false ) return false ; return true ; } int countPandigitalPairs ( vector < string > & v ) { int pairs = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) for ( int j = i + 1 ; j < v . size ( ) ; j ++ ) if ( isPanDigital ( v [ i ] + v [ j ] ) ) pairs ++ ; return pairs ; } int main ( ) { vector < string > v = { "123567" , "098234" , "14765" , "19804" } ; cout << countPandigitalPairs ( v ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int pandigitalMask = ( ( 1 << 10 ) - 1 ) ; void computeMaskFrequencies ( vector < string > v , map < int , int > & freq ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int mask = 0 ; unordered_set < int > digits ; for ( int j = 0 ; j < v [ i ] . size ( ) ; j ++ ) digits . insert ( v [ i ] [ j ] - '0' ) ; for ( auto it = digits . begin ( ) ; it != digits . end ( ) ; it ++ ) { int digit = ( * it ) ; mask += ( 1 << digit ) ; } freq [ mask ] ++ ; } } int pandigitalConcatenations ( map < int , int > freq ) { int ans = 0 ; for ( int i = 1 ; i <= 1023 ; i ++ ) { for ( int j = 1 ; j <= 1023 ; j ++ ) { if ( ( i j ) == pandigitalMask ) { if ( i == j ) ans += ( freq [ i ] * ( freq [ i ] - 1 ) ) ; else ans += ( freq [ i ] * freq [ j ] ) ; } } } return ans / 2 ; } int countPandigitalPairs ( vector < string > v ) { map < int , int > freq ; computeMaskFrequencies ( v , freq ) ; return pandigitalConcatenations ( freq ) ; } int main ( ) { vector < string > v = { "123567" , "098234" , "14765" , "19804" } ; cout << countPandigitalPairs ( v ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 256 ; void printPalindromePos ( string & str ) { vector < int > pos [ MAX ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) pos [ str [ i ] ] . push_back ( i + 1 ) ; int oddCount = 0 ; char oddChar ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( pos [ i ] . size ( ) % 2 != 0 ) { oddCount ++ ; oddChar = i ; } } if ( oddCount > 1 ) cout << " NO ▁ PALINDROME " ; for ( int i = 0 ; i < MAX ; i ++ ) { int mid = pos [ i ] . size ( ) / 2 ; for ( int j = 0 ; j < mid ; j ++ ) cout << pos [ i ] [ j ] << " ▁ " ; } if ( oddCount > 0 ) { int last = pos [ oddChar ] . size ( ) - 1 ; cout << pos [ oddChar ] [ last ] << " ▁ " ; pos [ oddChar ] . pop_back ( ) ; } for ( int i = MAX - 1 ; i >= 0 ; i -- ) { int count = pos [ i ] . size ( ) ; for ( int j = count / 2 ; j < count ; j ++ ) cout << pos [ i ] [ j ] << " ▁ " ; } } int main ( ) { string s = " geeksgk " ; printPalindromePos ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; int minChanges ( string & str ) { int n = str . length ( ) ; if ( n > MAX_CHAR ) return -1 ; int dist_count = 0 ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ str [ i ] - ' a ' ] == 0 ) dist_count ++ ; count [ ( str [ i ] - ' a ' ) ] ++ ; } return ( n - dist_count ) ; } int main ( ) { string str = " aebaecedabbee " ; cout << minChanges ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) ; } int main ( ) { int n = 2 , m = 3 ; cout << numofstring ( n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountSpecialPalindrome ( string str ) { int n = str . length ( ) ; int result = 0 ; int sameChar [ n ] = { 0 } ; int i = 0 ; while ( i < n ) { int sameCharCount = 1 ; int j = i + 1 ; while ( str [ i ] == str [ j ] && j < n ) sameCharCount ++ , j ++ ; result += ( sameCharCount * ( sameCharCount + 1 ) / 2 ) ; sameChar [ i ] = sameCharCount ; i = j ; } for ( int j = 1 ; j < n ; j ++ ) { if ( str [ j ] == str [ j - 1 ] ) sameChar [ j ] = sameChar [ j - 1 ] ; if ( j > 0 && j < ( n - 1 ) && ( str [ j - 1 ] == str [ j + 1 ] && str [ j ] != str [ j - 1 ] ) ) result += min ( sameChar [ j - 1 ] , sameChar [ j + 1 ] ) ; } return result - n ; } int main ( ) { string str = " abccba " ; cout << CountSpecialPalindrome ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printBracketNumber ( string exp , int n ) { int left_bnum = 1 ; stack < int > right_bnum ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp [ i ] == ' ( ' ) { cout << left_bnum << " ▁ " ; right_bnum . push ( left_bnum ) ; left_bnum ++ ; } else if ( exp [ i ] == ' ) ' ) { cout << right_bnum . top ( ) << " ▁ " ; right_bnum . pop ( ) ; } } } int main ( ) { string exp = " ( a + ( b * c ) ) + ( d / e ) " ; int n = exp . size ( ) ; printBracketNumber ( exp , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCornerPresent ( string str , string corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ; if ( n < cl ) return false ; return ( str . substr ( 0 , cl ) . compare ( corner ) == 0 && str . substr ( n - cl , cl ) . compare ( corner ) == 0 ) ; } int main ( ) { string str = " geeksforgeeks " ; string corner = " geeks " ; if ( isCornerPresent ( str , corner ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSegment ( string & s , int k ) { int seg_len = s . length ( ) - k ; int res = 0 ; for ( int i = 0 ; i < seg_len ; i ++ ) res = res * 10 + ( s [ i ] - '0' ) ; int seg_len_pow = pow ( 10 , seg_len - 1 ) ; int curr_val = res ; for ( int i = 1 ; i <= ( s . length ( ) - seg_len ) ; i ++ ) { curr_val = curr_val - ( s [ i - 1 ] - '0' ) * seg_len_pow ; curr_val = curr_val * 10 + ( s [ i + seg_len - 1 ] - '0' ) ; res = max ( res , curr_val ) ; } return res ; } int main ( ) { string s = "8754" ; int k = 2 ; cout << " Maximum ▁ number ▁ = ▁ " << findMaxSegment ( s , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int isConsecutive ( string str ) { int start ; int length = str . size ( ) ; for ( int i = 0 ; i < length / 2 ; i ++ ) { string new_str = str . substr ( 0 , i + 1 ) ; int num = atoi ( new_str . c_str ( ) ) ; start = num ; while ( new_str . size ( ) < length ) { num ++ ; new_str = new_str + to_string ( num ) ; } if ( new_str == str ) return start ; } return -1 ; } int main ( ) { string str = "99100" ; cout << " String : ▁ " << str << endl ; int start = isConsecutive ( str ) ; if ( start != -1 ) cout << " Yes ▁ STRNEWLINE " << start << endl ; else cout << " No " << endl ; string str1 = "121315" ; cout << " String : " start = isConsecutive ( str1 ) ; if ( start != -1 ) cout << " Yes ▁ STRNEWLINE " << start << endl ; else cout << " No " << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX_CHAR  26 NEW_LINE void findSubsequence ( string str , int k ) { int a [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) a [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l ; i ++ ) if ( a [ str [ i ] - ' a ' ] >= k ) cout << str [ i ] ; } int main ( ) { int k = 2 ; findSubsequence ( " geeksforgeeks " , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isConvertible ( string str1 , string str2 , int k ) { if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ; return false ; } int main ( ) { string str1 = " geek " , str2 = " geek " ; int k = 7 ; if ( isConvertible ( str1 , str2 , k ) ) cout << " Yes " ; else cout << " No " ; str1 = " geeks " , str2 = " geek " ; k = 5 ; cout << endl ; if ( isConvertible ( str1 , str2 , k ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_CHAR  26 NEW_LINE int maxLower ( string str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { i ++ ; break ; } } int maxCount = 0 ; int count [ MAX_CHAR ] = { 0 } ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) if ( count [ j ] > 0 ) currCount ++ ; maxCount = max ( maxCount , currCount ) ; memset ( count , 0 , sizeof ( count ) ) ; } if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) count [ str [ i ] - ' a ' ] ++ ; } return maxCount ; } int main ( ) { string str = " zACaAbbaazzC " ; cout << maxLower ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLower ( string str ) { int n = str . length ( ) ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { i ++ ; break ; } } int maxCount = 0 ; unordered_set < int > s ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { maxCount = max ( maxCount , ( int ) s . size ( ) ) ; s . clear ( ) ; } if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) s . insert ( str [ i ] ) ; } return maxCount ; } int main ( ) { string str = " zACaAbbaazzC " ; cout << maxLower ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string convert ( string str ) { string w = " " , z = " " ; transform ( str . begin ( ) , str . end ( ) , str . begin ( ) , :: toupper ) ; str += " ▁ " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ch != ' ▁ ' ) { w = w + ch ; } else { z = z + char ( tolower ( w [ 0 ] ) ) + w . substr ( 1 ) + " ▁ " ; w = " " ; } } return z ; } int main ( ) { string str = " I ▁ got ▁ intern ▁ at ▁ geeksforgeeks " ; cout << convert ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ; return 0 ; } int main ( ) { string str = " geeksforGeeKS " ; char res = first ( str ) ; if ( res == 0 ) cout << " No ▁ uppercase ▁ letter " ; else cout << res << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ( ans ) ; } int numberOfPossiblePallindrome ( string str , int n ) { unordered_map < char , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ str [ i ] ] ++ ; int fi ; for ( auto it = mp . begin ( ) ; it != mp . end ( ) ; ++ it ) { if ( it -> second % 2 == 0 ) fi = it -> second / 2 ; else { fi = ( it -> second - 1 ) / 2 ; k ++ ; } num = num + fi ; den = den * fact ( fi ) ; } if ( num != 0 ) num = fact ( num ) ; int ans = num / den ; if ( k != 0 ) { ans = ans * k ; } return ( ans ) ; } int main ( ) { char str [ ] = " ababab " ; int n = strlen ( str ) ; cout << numberOfPossiblePallindrome ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; } int main ( ) { string str = "10010" ; int n = 5 ; cout << evenDecimalValue ( str , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int recLen ( char * str ) { if ( * str == ' \0' ) return 0 ; else return 1 + recLen ( str + 1 ) ; } int main ( ) { char str [ ] = " GeeksforGeeks " ; cout << recLen ( str ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isConsonant ( char ch ) { ch = toupper ( ch ) ; return ! ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) && ch >= 65 && ch <= 90 ; } int totalConsonants ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isConsonant ( str [ i ] ) ) ++ count ; return count ; } int main ( ) { string str = " abc ▁ de " ; cout << totalConsonants ( str ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isConsonant ( char ch ) { ch = toupper ( ch ) ; return ! ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) && ch >= 65 && ch <= 90 ; } int totalConsonants ( string str , int n ) { if ( n == 1 ) return isConsonant ( str [ 0 ] ) ; return totalConsonants ( str , n - 1 ) + isConsonant ( str [ n - 1 ] ) ; } int main ( ) { string str = " abc ▁ de " ; cout << totalConsonants ( str , str . length ( ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int reverseBits ( unsigned int n ) { unsigned int rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( n & 1 == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } bool isPalindrome ( unsigned int n ) { unsigned int rev = reverseBits ( n ) ; return ( n == rev ) ; } int main ( ) { unsigned int n = 9 ; if ( isPalindrome ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE void Swap ( string s , string t , int n ) { int dp [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof dp ) ; int tot = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] != t [ i ] ) tot ++ ; for ( int i = 0 ; i < n ; i ++ ) { int a = s [ i ] - ' a ' ; int b = t [ i ] - ' a ' ; if ( a == b ) continue ; if ( dp [ a ] [ b ] != -1 ) { cout << i + 1 << " ▁ " << dp [ a ] [ b ] + 1 << endl ; return ; } dp [ b ] [ a ] = i ; } int A [ MAX ] , B [ MAX ] ; memset ( A , -1 , sizeof A ) ; memset ( B , -1 , sizeof B ) ; for ( int i = 0 ; i < n ; i ++ ) { int a = s [ i ] - ' a ' ; int b = t [ i ] - ' a ' ; if ( a == b ) continue ; if ( A [ b ] != -1 ) { cout << i + 1 << " ▁ " << A [ b ] + 1 << endl ; return ; } if ( B [ a ] != -1 ) { cout << i + 1 << " ▁ " << B [ a ] + 1 << endl ; return ; } A [ a ] = i ; B [ b ] = i ; } cout << -1 << endl ; } int main ( ) { string S = " permanent " ; string T = " pergament " ; int n = S . length ( ) ; if ( S == " " T == " " ) cout << " Required ▁ string ▁ is ▁ empty . " ; else Swap ( S , T , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  256 NEW_LINE int countPairs ( string s ) { int cnt [ MAX ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) cnt [ s [ i ] ] ++ ; int ans = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) ans += cnt [ i ] * cnt [ i ] ; return ans ; } int main ( ) { string s = " geeksforgeeks " ; cout << countPairs ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string lexNext ( string s , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return s ; } s [ i ] = ' a ' ; } } int main ( ) { string S = " abcdeg " , T = " abcfgh " ; int n = S . length ( ) ; string res = lexNext ( S , n ) ; if ( res != T ) cout << res << endl ; else cout << " - 1" << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int n , int t , string s ) { for ( int i = 0 ; i < t ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) if ( s [ j ] == ' B ' && s [ j + 1 ] == ' G ' ) { char temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j ++ ; } cout << s ; } int main ( ) { int n = 6 , t = 2 ; string s = " BBGBBG " ; solve ( n , t , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calSumUtil ( int a [ ] , int b [ ] , int n , int m ) { int sum [ n ] ; int i = n - 1 , j = m - 1 , k = n - 1 ; int carry = 0 , s = 0 ; while ( j >= 0 ) { s = a [ i ] + b [ j ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; k -- ; i -- ; j -- ; } while ( i >= 0 ) { s = a [ i ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; i -- ; k -- ; } int ans = 0 ; if ( carry ) ans = 10 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { ans += sum [ i ] ; ans *= 10 ; } return ans / 10 ; } int calSum ( int a [ ] , int b [ ] , int n , int m ) { if ( n >= m ) return calSumUtil ( a , b , n , m ) ; else return calSumUtil ( b , a , m , n ) ; } int main ( ) { int a [ ] = { 9 , 3 , 9 } ; int b [ ] = { 6 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << calSum ( a , b , n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26 NEW_LINE int longCommomAnagramSubseq ( char str1 [ ] , char str2 [ ] , int n1 , int n2 ) { int freq1 [ SIZE ] , freq2 [ SIZE ] ; memset ( freq1 , 0 , sizeof ( freq1 ) ) ; memset ( freq2 , 0 , sizeof ( freq2 ) ) ; int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; } int main ( ) { char str1 [ ] = " abdacp " ; char str2 [ ] = " ckamb " ; int n1 = strlen ( str1 ) ; int n2 = strlen ( str2 ) ; cout << " Length ▁ = ▁ " << longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPanalphabeticWindow ( char s [ ] , int n ) { char ch = ' a ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch ++ ; if ( ch == ' z ' + 1 ) return true ; } return false ; } int main ( ) { char s [ ] = " abujm ▁ zvcd ▁ acefc ▁ deghf ▁ gijkle " " ▁ m ▁ n ▁ o ▁ p ▁ pafqrstuvwxyzfap " ; int n = strlen ( s ) ; ( isPanalphabeticWindow ( s , n ) ) ? ( cout << " YES " ) : ( cout << " NO " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } void prime_index ( string input ) { int n = input . length ( ) ; for ( int i = 2 ; i <= n ; i ++ ) if ( isPrime ( i ) ) cout << input [ i - 1 ] ; } int main ( ) { string input = " GeeksforGeeks " ; prime_index ( input ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isHeterogram ( char s [ ] , int n ) { int hash [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != ' ▁ ' ) { if ( hash [ s [ i ] - ' a ' ] == 0 ) hash [ s [ i ] - ' a ' ] = 1 ; else return false ; } } return true ; } int main ( ) { char s [ ] = " the ▁ big ▁ dwarf ▁ only ▁ jumps " ; int n = strlen ( s ) ; ( isHeterogram ( s , n ) ) ? ( cout << " YES " ) : ( cout << " NO " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestAnagramSet ( string arr [ ] , int n ) { int maxSize = 0 ; unordered_map < string , int > count ; for ( int i = 0 ; i < n ; ++ i ) { sort ( arr [ i ] . begin ( ) , arr [ i ] . end ( ) ) ; count [ arr [ i ] ] += 1 ; maxSize = max ( maxSize , count [ arr [ i ] ] ) ; } return maxSize ; } int main ( ) { string arr [ ] = { " ant " , " magenta " , " magnate " , " tan " , " gnamate " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largestAnagramSet ( arr , n ) << " STRNEWLINE " ; string arr1 [ ] = { " cars " , " bikes " , " arcs " , " steer " } ; n = sizeof ( arr1 ) / sizeof ( arr [ 0 ] ) ; cout << largestAnagramSet ( arr1 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countCharacterType ( string str ) { int vowels = 0 , consonant = 0 , specialChar = 0 , digit = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str [ i ] ; if ( ( ch >= ' a ' && ch <= ' z ' ) || ( ch >= ' A ' && ch <= ' Z ' ) ) { ch = tolower ( ch ) ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) vowels ++ ; else consonant ++ ; } else if ( ch >= '0' && ch <= '9' ) digit ++ ; else specialChar ++ ; } cout << " Vowels : ▁ " << vowels << endl ; cout << " Consonant : ▁ " << consonant << endl ; cout << " Digit : ▁ " << digit << endl ; cout << " Special ▁ Character : ▁ " << specialChar << endl ; } int main ( ) { string str = " geeks ▁ for ▁ geeks121" ; countCharacterType ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } string encryptString ( string s , int n , int k ) { int cv [ n ] , cc [ n ] ; if ( isVowel ( s [ 0 ] ) ) cv [ 0 ] = 1 ; else cc [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { cv [ i ] = cv [ i - 1 ] + isVowel ( s [ i ] ) ; cc [ i ] = cc [ i - 1 ] + ! isVowel ( s [ i ] ) ; } string ans = " " ; int prod = 0 ; prod = cc [ k - 1 ] * cv [ k - 1 ] ; ans += to_string ( prod ) ; for ( int i = k ; i < s . length ( ) ; i ++ ) { prod = ( cc [ i ] - cc [ i - k ] ) * ( cv [ i ] - cv [ i - k ] ) ; ans += to_string ( prod ) ; } return ans ; } int main ( ) { string s = " hello " ; int n = s . length ( ) ; int k = 2 ; cout << encryptString ( s , n , k ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; int Octal ( int decimal ) { int octal = 0 ; string temp = " " ; while ( decimal > 0 ) { int remainder = decimal % 8 ; temp = to_string ( remainder ) + temp ; decimal /= 8 ; } for ( int i = 0 ; i < temp . length ( ) ; i ++ ) octal = ( octal * 10 ) + ( temp [ i ] - '0' ) ; return octal ; } string Hexadecimal ( int decimal ) { string hex = " " ; while ( decimal > 0 ) { int remainder = decimal % 16 ; if ( remainder >= 0 && remainder <= 9 ) hex = to_string ( remainder ) + hex ; else hex = ( char ) ( ' A ' + remainder % 10 ) + hex ; decimal /= 16 ; } return hex ; } string HTML ( int decimal ) { string html = to_string ( decimal ) ; html = " & # " + html + " ; " ; return html ; } void ASCIIlookuptable ( char ch ) { int decimal = ch ; cout << " Octal ▁ value : ▁ " << Octal ( decimal ) << endl ; cout << " Decimal ▁ value : ▁ " << decimal << endl ; cout << " Hexadecimal ▁ value : ▁ " << Hexadecimal ( decimal ) << endl ; cout << " HTML ▁ value : ▁ " << HTML ( decimal ) ; } int main ( ) { char ch = ' @ ' ; ASCIIlookuptable ( ch ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string replace ( string s , char c1 , char c2 ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == c1 ) s [ i ] = c2 ; else if ( s [ i ] == c2 ) s [ i ] = c1 ; } return s ; } int main ( ) { string s = " grrksfoegrrks " ; char c1 = ' e ' , c2 = ' r ' ; cout << replace ( s , c1 , c2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string fibWord ( int n ) { string Sn_1 = "0" ; string Sn = "01" ; string tmp ; for ( int i = 2 ; i <= n ; i ++ ) { tmp = Sn ; Sn += Sn_1 ; Sn_1 = tmp ; } return Sn ; } int main ( ) { int n = 6 ; cout << fibWord ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string decToBin ( int n ) { if ( n == 0 ) return "0" ; string bin = " " ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; } string convertBinToOct ( string bin ) { int l = bin . size ( ) ; for ( int i = 1 ; i <= ( 3 - l % 3 ) % 3 ; i ++ ) bin = '0' + bin ; unordered_map < string , char > bin_oct_map ; bin_oct_map [ "000" ] = '0' ; bin_oct_map [ "001" ] = '1' ; bin_oct_map [ "010" ] = '2' ; bin_oct_map [ "011" ] = '3' ; bin_oct_map [ "100" ] = '4' ; bin_oct_map [ "101" ] = '5' ; bin_oct_map [ "110" ] = '6' ; bin_oct_map [ "111" ] = '7' ; int i = 0 ; string octal = " " ; while ( 1 ) { octal += bin_oct_map [ bin . substr ( i , 3 ) ] ; i += 3 ; if ( i == bin . size ( ) ) break ; } return octal ; } string decToOctal ( int n ) { string bin = decToBin ( n ) ; return convertBinToOct ( bin ) ; } int main ( ) { int n = 151 ; cout << decToOctal ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string constructPalin ( string str , int len ) { int i = 0 , j = len - 1 ; for ( ; i < j ; i ++ , j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != ' * ' ) continue ; else if ( str [ i ] == str [ j ] && str [ i ] == ' * ' ) { str [ i ] = ' a ' ; str [ j ] = ' a ' ; continue ; } else if ( str [ i ] == ' * ' ) { str [ i ] = str [ j ] ; continue ; } else if ( str [ j ] == ' * ' ) { str [ j ] = str [ i ] ; continue ; } cout << " Not ▁ Possible " ; return " " ; } return str ; } int main ( ) { string str = " bca * xc * * b " ; int len = str . size ( ) ; cout << constructPalin ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void conversion ( char charSet [ ] , string & str ) { int n = str . length ( ) ; char hashChar [ 26 ] ; for ( int i = 0 ; i < 27 ; i ++ ) hashChar [ charSet [ i ] - ' a ' ] = ' a ' + i ; for ( int i = 0 ; i < n ; i ++ ) str [ i ] = hashChar [ str [ i ] - ' a ' ] ; } int main ( ) { char charSet [ 27 ] = " qwertyuiopasdfghjklzxcvbnm " ; string str = " egrt " ; conversion ( charSet , str ) ; cout << str ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfDifferentSubstrings ( string s , string a , string b ) { int ans = 0 ; int ls = s . size ( ) , la = a . size ( ) , lb = b . size ( ) ; int x [ ls ] = { 0 } , y [ ls ] = { 0 } ; for ( int i = 0 ; i < ls ; i ++ ) { if ( s . substr ( i , la ) == a ) x [ i ] = 1 ; if ( s . substr ( i , lb ) == b ) y [ i ] = 1 ; } unordered_set < string > hash ; string curr_substr = " " ; for ( int i = 0 ; i < ls ; i ++ ) { if ( x [ i ] ) { for ( int j = i ; j < ls ; j ++ ) { if ( ! y [ j ] ) curr_substr += s [ j ] ; if ( y [ j ] ) { curr_substr += s . substr ( j , lb ) ; if ( hash . find ( curr_substr ) == hash . end ( ) ) ans ++ ; hash . insert ( curr_substr ) ; } } curr_substr = " " ; } } return ans ; } int main ( ) { string s = " codecppforfood " ; string begin = " c " ; string end = " d " ; cout << numberOfDifferentSubstrings ( s , begin , end ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define max  100 NEW_LINE using namespace std ; void carveCross ( string str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) { cout << " Not ▁ possible . ▁ Please ▁ enter ▁ " << " odd ▁ length ▁ string . STRNEWLINE " ; } else { char arr [ max ] [ max ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = ' X ' ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] [ m ] = str [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ m ] [ i ] = str [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << arr [ i ] [ j ] << " ▁ " ; } cout << " STRNEWLINE " ; } } } int main ( ) { string str = " PICTURE " ; carveCross ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generatestring ( int n ) { for ( int i = 0 ; i < n ; i ++ ) putchar ( i & 2 ? ' b ' : ' a ' ) ; puts ( " " ) ; } int main ( ) { int n = 5 ; generatestring ( n ) ; n = 8 ; generatestring ( n ) ; n = 10 ; generatestring ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string subsequence ( string s , int binary , int len ) { string sub = " " ; for ( int j = 0 ; j < len ; j ++ ) if ( binary & ( 1 << j ) ) sub += s [ j ] ; return sub ; } void possibleSubsequences ( string s ) { map < int , set < string > > sorted_subsequence ; int len = s . size ( ) ; int limit = pow ( 2 , len ) ; for ( int i = 1 ; i <= limit - 1 ; i ++ ) { string sub = subsequence ( s , i , len ) ; sorted_subsequence [ sub . length ( ) ] . insert ( sub ) ; } for ( auto it : sorted_subsequence ) { cout << " Subsequences ▁ of ▁ length ▁ = ▁ " << it . first << " ▁ are : " << endl ; for ( auto ii : it . second ) cout << ii << " ▁ " ; cout << endl ; } } int main ( ) { string s = " aabc " ; possibleSubsequences ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int remainder ( string str ) { int len = str . length ( ) ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; } int main ( ) { string str = "3435346456547566345436457867978" ; cout << remainder ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeSpecialCharacter ( string s ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] < ' A ' s [ i ] > ' Z ' && s [ i ] < ' a ' s [ i ] > ' z ' ) { s . erase ( i , 1 ) ; i -- ; } } cout << s ; } int main ( ) { string s = " $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? " ; removeSpecialCharacter ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeSpecialCharacter ( string s ) { int j = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) || ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) ) { s [ j ] = s [ i ] ; j ++ ; } } cout << s . substr ( 0 , j ) ; } int main ( ) { string s = " $ Gee * k ; s . . fo , ▁ r ' Ge ^ eks ? " ; removeSpecialCharacter ( s ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void findPermutations ( char str [ ] , int index , int n ) { if ( index >= n || ( index + 1 ) >= n ) { cout << str << endl ; return ; } findPermutations ( str , index + 1 , n ) ; swap ( str [ index ] , str [ index + 1 ] ) ; findPermutations ( str , index + 2 , n ) ; swap ( str [ index ] , str [ index + 1 ] ) ; } int main ( ) { char str [ ] = { "12345" } ; int n = strlen ( str ) ; findPermutations ( str , 0 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string decodeMedianString ( string s ) { int l = s . length ( ) ; string s1 = " " ; bool isEven = ( l % 2 == 0 ) ? true : false ; for ( int i = 0 ; i < l ; i += 2 ) { if ( isEven ) { s1 = s [ i ] + s1 ; s1 += s [ i + 1 ] ; } else { if ( l - i > 1 ) { s1 += s [ i ] ; s1 = s [ i + 1 ] + s1 ; } else { s1 += s [ i ] ; } } } return s1 ; } int main ( ) { string s = " eekgs " ; cout << decodeMedianString ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumChars ( string & str ) { int n = str . length ( ) ; int res = -1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) res = max ( res , abs ( j - i - 1 ) ) ; return res ; } int main ( ) { string str = " abba " ; cout << maximumChars ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isUnique ( int a [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; } int main ( ) { int a [ ] = { 3 , 3 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 12 ; if ( isUnique ( a , n , k ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; void commonCharacters ( string str [ ] , int n ) { bool prim [ MAX_CHAR ] ; memset ( prim , true , sizeof ( prim ) ) ; for ( int i = 0 ; i < n ; i ++ ) { bool sec [ MAX_CHAR ] = { false } ; for ( int j = 0 ; str [ i ] [ j ] ; j ++ ) { if ( prim [ str [ i ] [ j ] - ' a ' ] ) sec [ str [ i ] [ j ] - ' a ' ] = true ; } memcpy ( prim , sec , MAX_CHAR ) ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( prim [ i ] ) printf ( " % c ▁ " , i + ' a ' ) ; } int main ( ) { string str [ ] = { " geeksforgeeks " , " gemkstones " , " acknowledges " , " aguelikes " } ; int n = sizeof ( str ) / sizeof ( str [ 0 ] ) ; commonCharacters ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string & s , int i , int j ) { int p = j ; for ( int k = i ; k <= p ; k ++ ) { if ( s [ k ] != s [ p ] ) return false ; p -- ; } return true ; } int countWays ( string & s ) { int n = s . length ( ) ; int count = 0 ; if ( isPalindrome ( s , 0 , n - 1 ) ) { for ( int i = n / 2 ; i < n ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) count ++ ; else break ; } { count ++ ; } else } else { for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( s [ i ] != s [ n - 1 - i ] ) { int j = n - 1 - i ; if ( isPalindrome ( s , i , n - 2 - i ) ) { for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( s [ k ] != s [ j ] ) break ; count ++ ; } count ++ ; } if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) { for ( int k = n - i ; k < n ; k ++ ) { if ( s [ k ] != s [ i ] ) break ; count ++ ; } count ++ ; } break ; } } } return count ; } int main ( ) { string s = " abca " ; cout << countWays ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfSubstringWithKOnes ( string s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int freq [ N + 1 ] = { 0 } ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s [ i ] - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; } int main ( ) { string s = "10010" ; int K = 1 ; cout << countOfSubstringWithKOnes ( s , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverse ( char num [ ] , int i , int j ) { while ( i < j ) { swap ( num [ i ] , num [ j ] ) ; i ++ ; j -- ; } } void nextPalin ( char num [ ] , int n ) { if ( n <= 3 ) { cout << " Not ▁ Possible " ; return ; } int mid = n / 2 - 1 ; int i , j ; for ( i = mid - 1 ; i >= 0 ; i -- ) if ( num [ i ] < num [ i + 1 ] ) break ; if ( i < 0 ) { cout << " Not ▁ Possible " ; return ; } int smallest = i + 1 ; for ( j = i + 2 ; j <= mid ; j ++ ) if ( num [ j ] > num [ i ] && num [ j ] <= num [ smallest ] ) smallest = j ; swap ( num [ i ] , num [ smallest ] ) ; swap ( num [ n - i - 1 ] , num [ n - smallest - 1 ] ) ; reverse ( num , i + 1 , mid ) ; if ( n % 2 == 0 ) reverse ( num , mid + 1 , n - i - 2 ) ; else reverse ( num , mid + 2 , n - i - 2 ) ; cout << " Next ▁ Palindrome : ▁ " << num ; } int main ( ) { char num [ ] = "4697557964" ; int n = strlen ( num ) ; nextPalin ( num , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRec ( string number , int extraOnes , int remainingPlaces ) { if ( 0 == remainingPlaces ) { cout << number << " ▁ " ; return ; } printRec ( number + "1" , extraOnes + 1 , remainingPlaces - 1 ) ; if ( 0 < extraOnes ) printRec ( number + "0" , extraOnes - 1 , remainingPlaces - 1 ) ; } void printNums ( int n ) { string str = " " ; printRec ( str , 0 , n ) ; } int main ( ) { int n = 4 ; printNums ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findstem ( vector < string > arr ) { int n = arr . size ( ) ; string s = arr [ 0 ] ; int len = s . length ( ) ; string res = " " ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j <= len ; j ++ ) { string stem = s . substr ( i , j ) ; int k = 1 ; for ( k = 1 ; k < n ; k ++ ) { if ( arr [ k ] . find ( stem ) == std :: string :: npos ) break ; } if ( k == n && res . length ( ) < stem . length ( ) ) res = stem ; } } return res ; } int main ( ) { vector < string > arr { " grace " , " graceful " , " disgraceful " , " gracefully " } ; string stems = findstem ( arr ) ; cout << stems << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 256 ; bool isPossible ( string & s1 , string & s2 ) { int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) count [ s2 [ i ] ] ++ ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( count [ s1 [ i ] ] == 0 ) return false ; count [ s1 [ i ] ] -- ; } return true ; } int main ( ) { string s1 = " GeeksforGeeks " , s2 = " rteksfoGrdsskGeggehes " ; if ( isPossible ( s1 , s2 ) ) cout << " Possible " ; else cout << " Not ▁ Possible STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string nxtHighUsingAtMostOneSwap ( string num ) { int l = num . size ( ) ; int posRMax = l - 1 ; int index = -1 ; for ( int i = l - 2 ; i >= 0 ; i -- ) { if ( num [ i ] >= num [ posRMax ] ) posRMax = i ; else { index = i ; break ; } } if ( index == -1 ) return " Not ▁ Possible " ; int greatSmallDgt = -1 ; for ( int i = l - 1 ; i > index ; i -- ) { if ( num [ i ] > num [ index ] ) { if ( greatSmallDgt == -1 ) greatSmallDgt = i ; else if ( num [ i ] <= num [ greatSmallDgt ] ) greatSmallDgt = i ; } } char temp = num [ index ] ; num [ index ] = num [ greatSmallDgt ] ; num [ greatSmallDgt ] = temp ; return num ; } int main ( ) { string num = "218765" ; cout << " Original ▁ number : ▁ " << num << endl ; cout << " Next ▁ higher ▁ number : ▁ " << nxtHighUsingAtMostOneSwap ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } int longestVowel ( string s ) { int count = 0 , res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( isVowel ( s [ i ] ) ) count ++ ; else { res = max ( res , count ) ; count = 0 ; } } return max ( res , count ) ; } int main ( ) { string s = " theeare " ; cout << longestVowel ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; bool check ( int freq [ ] , int k ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] && freq [ i ] != k ) return false ; return true ; } int substrings ( string s , int k ) { for ( int i = 0 ; s [ i ] ; i ++ ) { int freq [ MAX_CHAR ] = { 0 } ; for ( int j = i ; s [ j ] ; j ++ ) { int index = s [ j ] - ' a ' ; freq [ index ] ++ ; if ( freq [ index ] > k ) break ; else if ( freq [ index ] == k && check ( freq , k ) == true ) res ++ ; } } return res ; } int main ( ) { string s = " aabbcc " ; int k = 2 ; cout << substrings ( s , k ) << endl ; s = " aabbc " ; k = 2 ; cout << substrings ( s , k ) << endl ; }
#include <iostream> NEW_LINE #include <map> NEW_LINE #include <set> NEW_LINE #include <string> NEW_LINE int min ( int a , int b ) { return a < b ? a : b ; } using namespace std ; bool have_same_frequency ( map < char , int > & freq , int k ) { for ( auto & pair : freq ) { if ( pair . second != k && pair . second != 0 ) { return false ; } } return true ; } int count_substrings ( string s , int k ) { int count = 0 ; int distinct = ( set < char > ( s . begin ( ) , s . end ( ) ) ) . size ( ) ; for ( int length = 1 ; length <= distinct ; length ++ ) { int window_length = length * k ; map < char , int > freq ; int window_start = 0 ; int window_end = window_start + window_length - 1 ; for ( int i = window_start ; i <= min ( window_end , s . length ( ) - 1 ) ; i ++ ) { freq [ s [ i ] ] ++ ; } while ( window_end < s . length ( ) ) { if ( have_same_frequency ( freq , k ) ) { count ++ ; } freq [ s [ window_start ] ] -- ; window_start ++ ; window_end ++ ; if ( window_length < s . length ( ) ) { freq [ s [ window_end ] ] ++ ; } } } return count ; } int main ( ) { string s = " aabbcc " ; int k = 2 ; cout << count_substrings ( s , k ) << endl ; s = " aabbc " ; k = 2 ; cout << count_substrings ( s , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHARS = 26 ; void longestSubseqWithK ( string str , int k ) { int n = str . size ( ) ; int freq [ MAX_CHARS ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) if ( freq [ str [ i ] - ' a ' ] >= k ) cout << str [ i ] ; } int main ( ) { string str = " geeksforgeeks " ; int k = 2 ; longestSubseqWithK ( str , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generate ( set < string > & st , string s ) { if ( s . size ( ) == 0 ) return ; if ( st . find ( s ) == st . end ( ) ) { st . insert ( s ) ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { string t = s ; t . erase ( i , 1 ) ; generate ( st , t ) ; } } return ; } int main ( ) { string s = " xyz " ; set < string > st ; set < string > :: iterator it ; generate ( st , s ) ; for ( auto it = st . begin ( ) ; it != st . end ( ) ; it ++ ) cout << * it << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_set < string > st ; void subsequence ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { for ( int j = str . length ( ) ; j > i ; j -- ) { string sub_str = str . substr ( i , j ) ; st . insert ( sub_str ) ; for ( int k = 1 ; k < sub_str . length ( ) ; k ++ ) { string sb = sub_str ; sb . erase ( sb . begin ( ) + k ) ; subsequence ( sb ) ; } } } } int main ( ) { string s = " aabc " ; subsequence ( s ) ; for ( auto i : st ) cout << i << " ▁ " ; cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubSeqRec ( string str , int n , int index = -1 , string curr = " " ) { if ( index == n ) return ; if ( ! curr . empty ( ) ) { cout << curr << " STRNEWLINE " ; } for ( int i = index + 1 ; i < n ; i ++ ) { curr += str [ i ] ; printSubSeqRec ( str , n , i , curr ) ; curr = curr . erase ( curr . size ( ) - 1 ) ; } return ; } void printSubSeq ( string str ) { printSubSeqRec ( str , str . size ( ) ) ; } int main ( ) { string str = " cab " ; printSubSeq ( str ) ; return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; int countSubstrs ( string str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; } int main ( ) { string str = " abcab " ; int n = str . length ( ) ; cout << countSubstrs ( str , 0 , n - 1 , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countManipulations ( string s1 , string s2 ) { int count = 0 ; int char_count [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char_count [ i ] = 0 ; } for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char_count [ s1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { char_count [ s2 [ i ] - ' a ' ] -- ; } for ( int i = 0 ; i < 26 ; ++ i ) { if ( char_count [ i ] != 0 ) { count += abs ( char_count [ i ] ) ; } } return count / 2 ; } int main ( ) { string s1 = " ddcf " ; string s2 = " cedk " ; cout << countManipulations ( s1 , s2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void prCharWithFreq ( string s ) { unordered_map < char , int > d ; for ( char i : s ) { d [ i ] ++ ; } for ( char i : s ) { if ( d [ i ] != 0 ) { cout << i << d [ i ] << " ▁ " ; d [ i ] = 0 ; } } } int main ( ) { string s = " geeksforgeeks " ; prCharWithFreq ( s ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findFirstRepeated ( string s ) { istringstream iss ( s ) ; string token ; unordered_map < string , int > setOfWords ; while ( getline ( iss , token , ' ▁ ' ) ) { if ( setOfWords . find ( token ) != setOfWords . end ( ) ) else setOfWords . insert ( make_pair ( token , 1 ) ) ; } istringstream iss2 ( s ) ; while ( getline ( iss2 , token , ' ▁ ' ) ) { int count = setOfWords [ token ] ; if ( count > 1 ) { return token ; } } return " NoRepetition " ; } int main ( ) { string s ( " Ravi ▁ had ▁ been ▁ saying ▁ that ▁ he ▁ had ▁ been ▁ there " ) ; string firstWord = findFirstRepeated ( s ) ; if ( firstWord != " NoRepetition " ) cout << " First ▁ repeated ▁ word ▁ : : ▁ " << firstWord << endl ; else cout << " No ▁ Repetitionn " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findFirstRepeated ( string s ) { istringstream iss ( s ) ; string token ; set < string > setOfWords ; while ( getline ( iss , token , ' ▁ ' ) ) { if ( setOfWords . find ( token ) != setOfWords . end ( ) ) { return token ; } setOfWords . insert ( token ) ; } return " NoRepetition " ; } int main ( ) { string s ( " Ravi ▁ had ▁ been ▁ saying ▁ that ▁ he ▁ had ▁ been ▁ there " ) ; string firstWord = findFirstRepeated ( s ) ; if ( firstWord != " NoRepetition " ) cout << " First ▁ repeated ▁ word ▁ : : ▁ " << firstWord << endl ; else cout << " No ▁ Repetitionn " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void permute ( string input ) { int n = input . length ( ) ; int max = 1 << n ; transform ( input . begin ( ) , input . end ( ) , input . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < max ; i ++ ) { string combination = input ; for ( int j = 0 ; j < n ; j ++ ) if ( ( ( i >> j ) & 1 ) == 1 ) combination [ j ] = toupper ( input . at ( j ) ) ; cout << combination << " ▁ " ; } } int main ( ) { permute ( " ABC " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 256 ; int countBalance ( char * str ) { int leftVisited [ MAX_CHAR ] = { 0 } ; int rightVisited [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) rightVisited [ str [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { leftVisited [ str [ i ] ] ++ ; rightVisited [ str [ i ] ] -- ; int j ; for ( j = 0 ; j < MAX_CHAR ; j ++ ) { if ( ( leftVisited [ j ] == 0 && rightVisited [ j ] != 0 ) || ( leftVisited [ j ] != 0 && rightVisited [ j ] == 0 ) ) break ; } if ( j == MAX_CHAR ) res ++ ; } return res ; } int main ( ) { char str [ ] = " abaababa " ; cout << countBalance ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFlips ( char str [ ] , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) res ++ ; last = str [ i ] ; } return res / 2 ; } int main ( ) { char str [ ] = "00011110001110" ; int n = strlen ( str ) ; cout << findFlips ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void allCharactersSame ( string s ) { set < char > s1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) s1 . insert ( s [ i ] ) ; if ( s1 . size ( ) == 1 ) cout << " YES " ; else cout << " NO " ; } int main ( ) { string str = " nnnn " ; allCharactersSame ( str ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printString ( string str , char ch , int count ) { int occ = 0 , i ; if ( count == 0 ) { cout << str ; return ; } for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ch ) occ ++ ; if ( occ == count ) break ; } if ( i < str . length ( ) - 1 ) cout << str . substr ( i + 1 , str . length ( ) - ( i + 1 ) ) ; else cout << " Empty ▁ string " ; } int main ( ) { string str = " geeks ▁ for ▁ geeks " ; printString ( str , ' e ' , 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMinIndexChar ( string str , string patt ) { int minIndex = INT_MAX ; int m = str . size ( ) ; int n = patt . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( patt [ i ] == str [ j ] && j < minIndex ) { minIndex = j ; break ; } } } if ( minIndex != INT_MAX ) cout << " Minimum ▁ Index ▁ Character ▁ = ▁ " << str [ minIndex ] ; else cout << " No ▁ character ▁ present " ; } int main ( ) { string str = " geeksforgeeks " ; string patt = " set " ; printMinIndexChar ( str , patt ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMinIndexChar ( string str , string patt ) { unordered_map < char , int > um ; int minIndex = INT_MAX ; int m = str . size ( ) ; int n = patt . size ( ) ; - for ( int i = 0 ; i < m ; i ++ ) if ( um . find ( str [ i ] ) == um . end ( ) ) um [ str [ i ] ] = i ; for ( int i = 0 ; i < n ; i ++ ) if ( um . find ( patt [ i ] ) != um . end ( ) && um [ patt [ i ] ] < minIndex ) minIndex = um [ patt [ i ] ] ; if ( minIndex != INT_MAX ) cout << " Minimum ▁ Index ▁ Character ▁ = ▁ " << str [ minIndex ] ; else cout << " No ▁ character ▁ present " ; } int main ( ) { string str = " geeksforgeeks " ; string patt = " set " ; printMinIndexChar ( str , patt ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cstring> NEW_LINE using namespace std ; int count9s ( char number [ ] ) { int n = strlen ( number ) ; int d [ 9 ] ; memset ( d , 0 , sizeof ( d ) ) ; d [ 0 ] = 1 ; int result = 0 ; int mod_sum = 0 , continuous_zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! int ( number [ i ] - '0' ) ) continuous_zero ++ ; else continuous_zero = 0 ; mod_sum += int ( number [ i ] - '0' ) ; mod_sum %= 9 ; result += d [ mod_sum ] ; d [ mod_sum ] ++ ; result -= continuous_zero ; } return result ; } int main ( ) { cout << count9s ( "01809" ) << endl ; cout << count9s ( "1809" ) << endl ; cout << count9s ( "4189" ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int possibleStrings ( int n , int r , int b , int g ) { int fact [ n + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; int left = n - ( r + g + b ) ; int sum = 0 ; for ( int i = 0 ; i <= left ; i ++ ) { for ( int j = 0 ; j <= left - i ; j ++ ) { int k = left - ( i + j ) ; sum = sum + fact [ n ] / ( fact [ i + r ] * fact [ j + b ] * fact [ k + g ] ) ; } } return sum ; } int main ( ) { int n = 4 , r = 2 ; int b = 0 , g = 1 ; cout << possibleStrings ( n , r , b , g ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string maximumNum ( string curr_num , string res ) { int len1 = curr_num . length ( ) ; int len2 = res . length ( ) ; if ( len1 == len2 ) { int i = 0 ; while ( curr_num [ i ] == res [ i ] ) i ++ ; if ( curr_num [ i ] < res [ i ] ) return res ; else return curr_num ; } return len1 < len2 ? res : curr_num ; } string extractMaximum ( string str ) { int n = str . length ( ) ; string curr_num = " " ; string res ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n && str [ i ] == '0' ) i ++ ; while ( i < n && str [ i ] >= '0' && str [ i ] <= '9' ) { curr_num = curr_num + str [ i ] ; i ++ ; } if ( i == n ) break ; if ( curr_num . size ( ) > 0 ) i -- ; res = maximumNum ( curr_num , res ) ; curr_num = " " ; } if ( curr_num . size ( ) == 0 && res . size ( ) == 0 ) res = res + '0' ; return maximumNum ( curr_num , res ) ; } int main ( ) { string str = "100klh564abc365bg " ; cout << extractMaximum ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisible999 ( string num ) { int n = num . length ( ) ; if ( n == 0 && num [ 0 ] == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num [ i ++ ] - '0' ) * 100 ; group += ( num [ i ++ ] - '0' ) * 10 ; group += num [ i ] - '0' ; gSum += group ; } if ( gSum > 1000 ) { num = to_string ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ; } return ( gSum == 999 ) ; } int main ( ) { string num = "1998" ; int n = num . length ( ) ; if ( isDivisible999 ( num ) ) cout << " Divisible " ; else cout << " Not ▁ divisible " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; string arrangeString ( string str ) { int char_count [ MAX_CHAR ] = { 0 } ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) char_count [ str [ i ] - ' A ' ] ++ ; else sum = sum + ( str [ i ] - '0' ) ; } string res = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( ' A ' + i ) ; while ( char_count [ i ] -- ) res = res + ch ; } if ( sum > 0 ) res = res + to_string ( sum ) ; return res ; } int main ( ) { string str = " ACCBA10D2EW30" ; cout << arrangeString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' A ' c == ' e ' c == ' E ' c == ' i ' c == ' I ' c == ' o ' c == ' O ' c == ' u ' c == ' U ' ) ; } string reverseVowel ( string str ) { int i = 0 ; int j = str . length ( ) - 1 ; while ( i < j ) { if ( ! isVowel ( str [ i ] ) ) { i ++ ; continue ; } if ( ! isVowel ( str [ j ] ) ) { j -- ; continue ; } swap ( str [ i ] , str [ j ] ) ; i ++ ; j -- ; } return str ; } int main ( ) { string str = " hello ▁ world " ; cout << reverseVowel ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void subString ( char str [ ] , int n ) { for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; for ( int k = i ; k <= j ; k ++ ) cout << str [ k ] ; cout << endl ; } } } int main ( ) { char str [ ] = " abc " ; subString ( str , strlen ( str ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; string reverses ( string str ) { int n = str . size ( ) ; string result ( n , ' \0' ) ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == ' ▁ ' ) result [ i ] = ' ▁ ' ; int j = n - 1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != ' ▁ ' ) { if ( result [ j ] == ' ▁ ' ) j -- ; result [ j ] = str [ i ] ; j -- ; } } return result ; } int main ( ) { string str = " internship ▁ at ▁ geeks ▁ for ▁ geeks " ; cout << reverses ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; void findAndPrintUncommonChars ( string str1 , string str2 ) { int present [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) present [ i ] = 0 ; int l1 = str1 . size ( ) ; int l2 = str2 . size ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) present [ str1 [ i ] - ' a ' ] = 1 ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( present [ str2 [ i ] - ' a ' ] == 1 present [ str2 [ i ] - ' a ' ] == -1 ) present [ str2 [ i ] - ' a ' ] = -1 ; else present [ str2 [ i ] - ' a ' ] = 2 ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( present [ i ] == 1 present [ i ] == 2 ) cout << ( char ( i + ' a ' ) ) << " ▁ " ; } int main ( ) { string str1 = " characters " ; string str2 = " alphabets " ; findAndPrintUncommonChars ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <boost/algorithm/string.hpp> NEW_LINE using namespace std ; int lengthOfLastWord ( string a ) { int len = 0 ; string str ( a ) ; boost :: trim_right ( str ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . at ( i ) == ' ▁ ' ) len = 0 ; else len ++ ; } return len ; } int main ( ) { string input = " Geeks ▁ For ▁ Geeks ▁ " ; cout << " The ▁ length ▁ of ▁ last ▁ word ▁ is ▁ " << lengthOfLastWord ( input ) ; }
#include <iostream> NEW_LINE using namespace std ; bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } int countVowels ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ count ; return count ; } int main ( ) { string str = " abc ▁ de " ; cout << countVowels ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char * toggleCase ( char * a ) { for ( int i = 0 ; a [ i ] != ' \0' ; i ++ ) { a [ i ] ^= 32 ; } return a ; } int main ( ) { char str [ ] = " CheRrY " ; cout << " Toggle ▁ case : ▁ " << toggleCase ( str ) << endl ; cout << " Original ▁ string : ▁ " << toggleCase ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool uniqueCharacters ( string str ) { set < char > char_set ; for ( char c : str ) { char_set . insert ( c ) ; } if ( char_set . size ( ) == str . size ( ) ) { return true ; } else { return false ; } } int main ( ) { string str = " GeeksforGeeks " ; if ( uniqueCharacters ( str ) ) { cout << " The ▁ String ▁ " << str << " ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE " ; } else { cout << " The ▁ String ▁ " << str << " ▁ has ▁ duplicate ▁ characters STRNEWLINE " ; } return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void concatenate ( char a [ ] , char b [ ] , char c [ ] , int n1 , int n2 ) { int i ; for ( i = 0 ; i < n1 ; i ++ ) c [ i ] = a [ i ] ; for ( int j = 0 ; j < n2 ; j ++ ) c [ i ++ ] = b [ j ] ; c [ i ] = ' \0' ; } int main ( ) { char a [ ] = " Hi ▁ This ▁ is ▁ geeksforgeeks . ▁ " ; int n1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; char b [ ] = " You ▁ are ▁ welcome ▁ here . " ; int n2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; char c [ n1 + n2 - 1 ] ; concatenate ( a , b , c , n1 , n2 ) ; for ( int i = 0 ; i < n1 + n2 - 1 ; i ++ ) cout << c [ i ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void toggleChars ( string & S ) { for ( auto & it : S ) { if ( isalpha ( it ) ) { it ^= ( 1 << 5 ) ; } } } int main ( ) { string S = " GeKf @ rGeek $ " ; toggleChars ( S ) ; cout << " String ▁ after ▁ toggle ▁ " << endl ; cout << S << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string nextGreaterWithSameDigits ( string bnum ) { int l = bnum . size ( ) ; int i ; for ( int i = l - 2 ; i >= 1 ; i -- ) { if ( bnum . at ( i ) == '0' && bnum . at ( i + 1 ) == '1' ) { char ch = bnum . at ( i ) ; bnum . at ( i ) = bnum . at ( i + 1 ) ; bnum . at ( i + 1 ) = ch ; break ; } } if ( i == 0 ) " no ▁ greater ▁ number " ; int j = i + 2 , k = l - 1 ; while ( j < k ) { if ( bnum . at ( j ) == '1' && bnum . at ( k ) == '0' ) { char ch = bnum . at ( j ) ; bnum . at ( j ) = bnum . at ( k ) ; bnum . at ( k ) = ch ; j ++ ; k -- ; } else if ( bnum . at ( i ) == '0' ) break ; else j ++ ; } return bnum ; } int main ( ) { string bnum = "10010" ; cout << " Binary ▁ representation ▁ of ▁ next ▁ greater ▁ number ▁ = ▁ " << nextGreaterWithSameDigits ( bnum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRotatedString ( char str [ ] ) { int len = strlen ( str ) ; char temp [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { int j = i ; int k = 0 ; while ( str [ j ] != ' \0' ) { temp [ k ] = str [ j ] ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { temp [ k ] = str [ j ] ; j ++ ; k ++ ; } printf ( " % s STRNEWLINE " , temp ) ; } } int main ( ) { char str [ ] = " geeks " ; printRotatedString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int n = str . size ( ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) if ( str . at ( i ) != str . at ( n - i - 1 ) ) return false ; return true ; } int maxLengthNonPalinSubstring ( string str ) { int n = str . size ( ) ; char ch = str . at ( 0 ) ; int i = 1 ; for ( i = 1 ; i < n ; i ++ ) if ( str . at ( i ) != ch ) break ; if ( i == n ) return 0 ; if ( isPalindrome ( str ) ) return n - 1 ; return n ; } int main ( ) { string str = " abba " ; cout << " Maximum ▁ length ▁ = ▁ " << maxLengthNonPalinSubstring ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void moveSpaceInFront ( char str [ ] ) { int i = strlen ( str ) - 1 ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) swap ( str [ i -- ] , str [ j ] ) ; } int main ( ) { char str [ ] = " Hey ▁ there , ▁ it ' s ▁ GeeksforGeeks " ; moveSpaceInFront ( str ) ; cout << str ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void moveSpaceInFront ( char str [ ] ) { int i = strlen ( str ) ; for ( int j = i ; j >= 0 ; j -- ) if ( str [ j ] != ' ▁ ' ) str [ i -- ] = str [ j ] ; while ( i >= 0 ) str [ i -- ] = ' ▁ ' ; } int main ( ) { char str [ ] = " Hey ▁ there , ▁ it ' s ▁ GeeksforGeeks " ; moveSpaceInFront ( str ) ; cout << str ; return 0 ; }
#include <stdio.h> NEW_LINE #include <string.h> NEW_LINE #include <stdbool.h> NEW_LINE bool isPalindrome ( char * str ) { int len = strlen ( str ) ; if ( len == 1 ) return true ; char * ptr1 = str ; char * ptr2 = str + len - 1 ; while ( ptr2 > ptr1 ) { if ( * ptr1 != * ptr2 ) return false ; ptr1 ++ ; ptr2 -- ; } return true ; } int noOfAppends ( char s [ ] ) { if ( isPalindrome ( s ) ) return 0 ; s ++ ; return 1 + noOfAppends ( s ) ; } int main ( ) { char s [ ] = " abede " ; printf ( " % d STRNEWLINE " , noOfAppends ( s ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int titleToNumber ( string s ) { int result = 0 ; for ( const auto & c : s ) { result *= 26 ; result += c - ' A ' + 1 ; } return result ; } int main ( ) { cout << titleToNumber ( " CDA " ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void isKthBitSet ( int n , int k ) { if ( ( n >> ( k - 1 ) ) & 1 ) cout << " SET " ; else cout << " NOT ▁ SET " ; } int main ( ) { int n = 5 , k = 1 ; isKthBitSet ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string reversingString ( string str , int start , int end ) { while ( start < end ) { str [ start ] ^= str [ end ] ; str [ end ] ^= str [ start ] ; str [ start ] ^= str [ end ] ; ++ start ; -- end ; } return str ; } int main ( ) { string s = " GeeksforGeeks " ; cout << reversingString ( s , 0 , 12 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; string isAnBn ( string str ) { int n = str . length ( ) ; if ( n & 1 ) return " No " ; int i ; for ( i = 0 ; i < n / 2 ; i ++ ) if ( str [ i ] != ' a ' str [ n - i - 1 ] != ' b ' ) return " No " ; return " Yes " ; } int main ( ) { string str = " ab " ; cout << isAnBn ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100002 NEW_LINE using namespace std ; int f ( int i , int m , char s [ ] , int memoize [ ] [ 3 ] ) { if ( i == strlen ( s ) ) return 0 ; if ( memoize [ i ] [ m ] != -1 ) return memoize [ i ] [ m ] ; int x = s [ i ] - '0' ; int ans = ( ( x + m ) % 3 == 0 && x % 2 == 0 ) + f ( i + 1 , ( m + x ) % 3 , s , memoize ) ; return memoize [ i ] [ m ] = ans ; } int countDivBy6 ( char s [ ] ) { int n = strlen ( s ) ; int memoize [ n + 1 ] [ 3 ] ; memset ( memoize , -1 , sizeof memoize ) ; int ans = 0 ; for ( int i = 0 ; i < strlen ( s ) ; i ++ ) { if ( s [ i ] == '0' ) ans ++ ; else ans += f ( i , 0 , s , memoize ) ; } return ans ; } int main ( ) { char s [ ] = "4806" ; cout << countDivBy6 ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const char MAX_CHAR = 26 ; void countFreq ( string str , int freq [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) freq [ str . at ( i ) - ' a ' ] ++ ; } bool canMakePalindrome ( int freq [ ] , int len ) { int count_odd = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] % 2 != 0 ) count_odd ++ ; if ( len % 2 == 0 ) { if ( count_odd > 0 ) return false ; else return true ; } if ( count_odd != 1 ) return false ; return true ; } string findOddAndRemoveItsFreq ( int freq [ ] ) { string odd_str = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { freq [ i ] -- ; odd_str = odd_str + ( char ) ( i + ' a ' ) ; return odd_str ; } } return odd_str ; } string findPalindromicString ( string str ) { int len = str . length ( ) ; int freq [ MAX_CHAR ] = { 0 } ; countFreq ( str , freq , len ) ; if ( ! canMakePalindrome ( freq , len ) ) return " No ▁ Palindromic ▁ String " ; string odd_str = findOddAndRemoveItsFreq ( freq ) ; string front_str = " " , rear_str = " ▁ " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { string temp = " " ; if ( freq [ i ] != 0 ) { char ch = ( char ) ( i + ' a ' ) ; for ( int j = 1 ; j <= freq [ i ] / 2 ; j ++ ) temp = temp + ch ; front_str = front_str + temp ; rear_str = temp + rear_str ; } } return ( front_str + odd_str + rear_str ) ; } int main ( ) { string str = " malayalam " ; cout << findPalindromicString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkEquality ( string s ) { return ( s [ 0 ] == s [ s . size ( ) - 1 ] ) ; } int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) if ( checkEquality ( s . substr ( i , len ) ) ) result ++ ; return result ; } int main ( ) { string s ( " abcab " ) ; cout << countSubstringWithEqualEnds ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s [ i ] == s [ j ] ) result ++ ; return result ; } int main ( ) { string s ( " abcab " ) ; cout << countSubstringWithEqualEnds ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_DIGITS = 6 ; int getValue ( const string & str , int i , int m ) { if ( i + m > str . length ( ) ) return -1 ; int value = 0 ; for ( int j = 0 ; j < m ; j ++ ) { int c = str [ i + j ] - '0' ; if ( c < 0 c > 9 ) return -1 ; value = value * 10 + c ; } return value ; } int findMissingNumber ( const string & str ) { for ( int m = 1 ; m <= MAX_DIGITS ; ++ m ) { int n = getValue ( str , 0 , m ) ; if ( n == -1 ) break ; int missingNo = -1 ; bool fail = false ; for ( int i = m ; i != str . length ( ) ; i += 1 + log10l ( n ) ) { if ( ( missingNo == -1 ) && ( getValue ( str , i , 1 + log10l ( n + 2 ) ) == n + 2 ) ) { missingNo = n + 1 ; n += 2 ; } else if ( getValue ( str , i , 1 + log10l ( n + 1 ) ) == n + 1 ) n ++ ; else { fail = true ; break ; } } if ( ! fail ) return missingNo ; } } int main ( ) { cout << findMissingNumber ( "99101102" ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char maxRepeating ( string str ) { int len = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] != str [ j ] ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } } return res ; } int main ( ) { string str = " aaaabbaaccde " ; cout << maxRepeating ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findSum ( string str1 , string str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 , str2 ) ; string str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; reverse ( str1 . begin ( ) , str1 . end ( ) ) ; reverse ( str2 . begin ( ) , str2 . end ( ) ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry ) str . push_back ( carry + '0' ) ; reverse ( str . begin ( ) , str . end ( ) ) ; return str ; } int main ( ) { string str1 = "12" ; string str2 = "198111" ; cout << findSum ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findSum ( string str1 , string str2 ) { if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 , str2 ) ; string str = " " ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i + diff ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry ) str . push_back ( carry + '0' ) ; reverse ( str . begin ( ) , str . end ( ) ) ; return str ; } int main ( ) { string str1 = "12" ; string str2 = "198111" ; cout << findSum ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int len = str . length ( ) ; for ( int i = 0 ; i < len / 2 ; i ++ ) if ( str [ i ] != str [ len - i - 1 ] ) return false ; return true ; } bool checkPalindromePair ( vector < string > vect ) { for ( int i = 0 ; i < vect . size ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < vect . size ( ) ; j ++ ) { string check_str ; check_str = vect [ i ] + vect [ j ] ; if ( isPalindrome ( check_str ) ) return true ; check_str = vect [ j ] + vect [ i ] ; if ( isPalindrome ( check_str ) ) return true ; } } return false ; } int main ( ) { vector < string > vect = { " geekf " , " geeks " , " or " , " keeg " , " abc " , " bc " } ; checkPalindromePair ( vect ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void print ( string str ) { cout << str [ 0 ] ; for ( int i = 1 ; str [ i ] != ' \0' ; i ++ ) { if ( ( str [ i ] == str [ i - 1 ] + 1 ) || ( str [ i ] == str [ i - 1 ] - 1 ) ) cout << str [ i ] ; else cout << " STRNEWLINE " << str [ i ] ; ; } } int main ( ) { string str = " ABCXYZACCD " ; print ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areChractersUnique ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; } int main ( ) { string s = " aaabbccdaa " ; if ( areChractersUnique ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWords ( char str [ ] , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; } int main ( ) { char str [ ] = " abc " ; int len = strlen ( str ) ; cout << countWords ( str , len ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void qType1 ( int l , int x , char str [ ] ) { str [ l - 1 ] = x ; } void qType2 ( int l , int r , char str [ ] ) { int freq [ 27 ] = { 0 } ; for ( int i = l - 1 ; i <= r - 1 ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) if ( freq [ j ] % 2 ) count ++ ; ( count <= 1 ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; } int main ( ) { char str [ ] = " geeksforgeeks " ; int n = strlen ( str ) ; qType1 ( 4 , ' g ' , str ) ; qType2 ( 1 , 4 , str ) ; qType2 ( 2 , 3 , str ) ; qType1 ( 10 , ' t ' , str ) ; qType2 ( 10 , 11 , str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define max  1000 NEW_LINE using namespace std ; int getFrequency ( int tree [ max ] [ 27 ] , int idx , int i ) { int sum = 0 ; while ( idx > 0 ) { sum += tree [ idx ] [ i ] ; idx -= ( idx & - idx ) ; } return sum ; } void update ( int tree [ max ] [ 27 ] , int idx , int val , int i ) { while ( idx <= max ) { tree [ idx ] [ i ] += val ; idx += ( idx & - idx ) ; } } void qType1 ( int tree [ max ] [ 27 ] , int l , int x , char str [ ] ) { update ( tree , l , -1 , str [ l - 1 ] - 97 + 1 ) ; str [ l - 1 ] = x ; update ( tree , l , 1 , str [ l - 1 ] - 97 + 1 ) ; } void qType2 ( int tree [ max ] [ 27 ] , int l , int r , char str [ ] ) { int count = 0 ; for ( int i = 1 ; i <= 26 ; i ++ ) { if ( l == 1 ) { if ( getFrequency ( tree , r , i ) % 2 == 1 ) count ++ ; } else { if ( ( getFrequency ( tree , r , i ) - getFrequency ( tree , l - 1 , i ) ) % 2 == 1 ) count ++ ; } } ( count <= 1 ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; } void buildBIT ( int tree [ max ] [ 27 ] , char str [ ] , int n ) { memset ( tree , 0 , sizeof ( tree ) ) ; for ( int i = 0 ; i < n ; i ++ ) update ( tree , i + 1 , 1 , str [ i ] - 97 + 1 ) ; } int main ( ) { char str [ ] = " geeksforgeeks " ; int n = strlen ( str ) ; int tree [ max ] [ 27 ] ; buildBIT ( tree , str , n ) ; qType1 ( tree , 4 , ' g ' , str ) ; qType2 ( tree , 1 , 4 , str ) ; qType2 ( tree , 2 , 3 , str ) ; qType1 ( tree , 10 , ' t ' , str ) ; qType2 ( tree , 10 , 11 , str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findDivision ( string & str , int a , int b ) { int len = str . length ( ) ; vector < int > lr ( len + 1 , 0 ) ; lr [ 0 ] = ( str [ 0 ] - '0' ) % a ; for ( int i = 1 ; i < len ; i ++ ) lr [ i ] = ( ( lr [ i - 1 ] * 10 ) % a + ( str [ i ] - '0' ) ) % a ; vector < int > rl ( len + 1 , 0 ) ; rl [ len - 1 ] = ( str [ len - 1 ] - '0' ) % b ; int power10 = 10 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { rl [ i ] = ( rl [ i + 1 ] + ( str [ i ] - '0' ) * power10 ) % b ; power10 = ( power10 * 10 ) % b ; } for ( int i = 0 ; i < len - 1 ; i ++ ) { if ( lr [ i ] != 0 ) continue ; if ( rl [ i + 1 ] == 0 ) { cout << " YES STRNEWLINE " ; for ( int k = 0 ; k <= i ; k ++ ) cout << str [ k ] ; cout << " , ▁ " ; for ( int k = i + 1 ; k < len ; k ++ ) cout << str [ k ] ; return ; } } cout << " NO STRNEWLINE " ; } int main ( ) { string str = "123" ; int a = 12 , b = 3 ; findDivision ( str , a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isequal ( string str ) { int n = str . length ( ) ; int num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( '0' <= str [ i ] && str [ i ] <= '9' ) { num = ( str [ i ] - '0' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; } int main ( ) { string str = " geeksforgeeks13" ; isequal ( str ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool kAnagrams ( string str1 , string str2 , int k ) { int flag = 0 ; if ( str1 . length ( ) != str2 . length ( ) ) return false ; int n = str1 . length ( ) ; char arr1 [ n ] ; char arr2 [ n ] ; strcpy ( arr1 , str1 . c_str ( ) ) ; strcpy ( arr2 , str2 . c_str ( ) ) ; sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + n ) ; vector < char > list ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( arr1 [ i ] != arr2 [ i ] ) { list . push_back ( arr2 [ i ] ) ; } } if ( list . size ( ) <= k ) flag = 1 ; if ( flag == 1 ) return true ; else return false ; } int main ( ) { string str1 = " anagram " , str2 = " grammar " ; int k = 3 ; kAnagrams ( str1 , str2 , k ) ; if ( kAnagrams ( str1 , str2 , k ) == true ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countToMake0lternate ( const string & s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; } int main ( ) { cout << countToMake0lternate ( "000111" ) << endl ; cout << countToMake0lternate ( "11111" ) << endl ; cout << countToMake0lternate ( "01010101" ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkString ( string str , long k ) { int n = str . length ( ) ; if ( n % k != 0 ) return false ; unordered_map < string , int > mp ; for ( int i = 0 ; i < n ; i += k ) mp [ str . substr ( i , k ) ] ++ ; if ( mp . size ( ) == 1 ) return true ; if ( mp . size ( ) != 2 ) return false ; if ( ( mp . begin ( ) -> second == ( n / k - 1 ) ) || mp . begin ( ) -> second == 1 ) return true ; return false ; } int main ( ) { checkString ( " abababcd " , 2 ) ? cout << " Yes " : cout << " No " ; return 0 ; }
# include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; void printGrouped ( string str ) { int n = str . length ( ) ; int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { while ( count [ str [ i ] - ' a ' ] -- ) cout << str [ i ] ; count [ str [ i ] - ' a ' ] = 0 ; } } int main ( ) { string str = " geeksforgeeks " ; printGrouped ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; void sortByPattern ( string & str , string pat ) { int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; int index = 0 ; for ( int i = 0 ; i < pat . length ( ) ; i ++ ) for ( int j = 0 ; j < count [ pat [ i ] - ' a ' ] ; j ++ ) str [ index ++ ] = pat [ i ] ; } int main ( ) { string pat = " bca " ; string str = " abc " ; sortByPattern ( str , pat ) ; cout << str ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossiblePalindrome ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( str [ i ] != ' . ' && str [ n - i - 1 ] != ' . ' && str [ i ] != str [ n - i - 1 ] ) return false ; } return true ; } string smallestPalindrome ( string str ) { if ( ! isPossiblePalindrome ( str ) ) return " Not ▁ Possible " ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' . ' ) { if ( str [ n - i - 1 ] != ' . ' ) str [ i ] = str [ n - i - 1 ] ; else str [ i ] = str [ n - i - 1 ] = ' a ' ; } } return str ; } int main ( ) { string str = " ab . . e . c . a " ; cout << smallestPalindrome ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char flip ( char ch ) { return ( ch == '0' ) ? '1' : '0' ; } int getFlipWithStartingCharcter ( string str , char expected ) { int flipCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != expected ) flipCount ++ ; expected = flip ( expected ) ; } return flipCount ; } int minFlipToMakeStringAlternate ( string str ) { return min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) ) ; } int main ( ) { string str = "0001010111" ; cout << minFlipToMakeStringAlternate ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int CHARS = 26 ; int remAnagram ( string str1 , string str2 ) { int count1 [ CHARS ] = { 0 } , count2 [ CHARS ] = { 0 } ; for ( int i = 0 ; str1 [ i ] != ' \0' ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; str2 [ i ] != ' \0' ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int result = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) result += abs ( count1 [ i ] - count2 [ i ] ) ; return result ; } int main ( ) { string str1 = " bcadeh " , str2 = " hea " ; cout << remAnagram ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canBecomeEmpty ( string str , string sub_str ) { while ( str . size ( ) > 0 ) { int idx = str . find ( sub_str ) ; if ( idx == -1 ) break ; str . erase ( idx , sub_str . size ( ) ) ; } return ( str . size ( ) == 0 ) ; } int main ( ) { string str = " GEEGEEKSKS " , sub_str = " GEEKS " ; if ( canBecomeEmpty ( str , sub_str ) ) cout << " Yes " else cout << " No " return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkForVariation ( string str ) { if ( str . empty ( ) || str . length ( ) != 0 ) { return true ; } map < char , int > mapp ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { mapp [ str [ i ] ] ++ ; } bool first = true , second = true ; int val1 = 0 , val2 = 0 ; int countOfVal1 = 0 , countOfVal2 = 0 ; map < char , int > :: iterator itr ; for ( itr = mapp . begin ( ) ; itr != mapp . end ( ) ; ++ itr ) { int i = itr -> first ; if ( first ) { val1 = i ; first = false ; countOfVal1 ++ ; continue ; } if ( i == val1 ) { countOfVal1 ++ ; continue ; } if ( second ) { val2 = i ; countOfVal2 ++ ; second = false ; continue ; } if ( i == val2 ) { countOfVal2 ++ ; continue ; } return false ; } if ( countOfVal1 > 1 && countOfVal2 > 1 ) { return false ; } else { return true ; } } int main ( ) { if ( checkForVariation ( " abcbcvf " ) ) cout << " true " << endl ; else cout << " false " << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { string concat = set1 [ i ] + set2 [ j ] ; int frequency [ 26 ] = { 0 } ; for ( int k = 0 ; k < concat . length ( ) ; k ++ ) frequency [ concat [ k ] - ' a ' ] ++ ; int i ; for ( i = 0 ; i < 26 ; i ++ ) if ( frequency [ i ] < 1 ) break ; if ( i == 26 ) result ++ ; } } return result ; } int main ( ) { string set1 [ ] = { " abcdefgh " , " geeksforgeeks " , " lmnopqrst " , " abc " } ; string set2 [ ] = { " ijklmnopqrstuvwxyz " , " abcdefghijklmnopqrstuvwxyz " , " defghijklmnopqrstuvwxyz " } ; int n = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int m = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << countCompletePairs ( set1 , set2 , n , m ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countCompletePairs ( string set1 [ ] , string set2 [ ] , int n , int m ) { int result = 0 ; int con_s1 [ n ] , con_s2 [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { con_s1 [ i ] = 0 ; for ( int j = 0 ; j < set1 [ i ] . length ( ) ; j ++ ) { con_s1 [ i ] = con_s1 [ i ] | ( 1 << ( set1 [ i ] [ j ] - ' a ' ) ) ; } } for ( int i = 0 ; i < m ; i ++ ) { con_s2 [ i ] = 0 ; for ( int j = 0 ; j < set2 [ i ] . length ( ) ; j ++ ) { con_s2 [ i ] = con_s2 [ i ] | ( 1 << ( set2 [ i ] [ j ] - ' a ' ) ) ; } } long long complete = ( 1 << 26 ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( con_s1 [ i ] con_s2 [ j ] ) == complete ) result ++ ; } } return result ; } int main ( ) { string set1 [ ] = { " abcdefgh " , " geeksforgeeks " , " lmnopqrst " , " abc " } ; string set2 [ ] = { " ijklmnopqrstuvwxyz " , " abcdefghijklmnopqrstuvwxyz " , " defghijklmnopqrstuvwxyz " } ; int n = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int m = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << countCompletePairs ( set1 , set2 , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int CHAR_SIZE = 256 ; bool checkPattern ( string str , string pat ) { vector < int > label ( CHAR_SIZE , -1 ) ; int order = 1 ; for ( int i = 0 ; i < pat . length ( ) ; i ++ ) { label [ pat [ i ] ] = order ; order ++ ; } int last_order = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( label [ str [ i ] ] != -1 ) { if ( label [ str [ i ] ] < last_order ) return false ; last_order = label [ str [ i ] ] ; } } return true ; } int main ( ) { string str = " engineers ▁ rock " ; string pattern = " gsr " ; cout << boolalpha << checkPattern ( str , pattern ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char encodedChar ( string str , int k ) { string expand = " " ; for ( int i = 0 ; str [ i ] != ' \0' ; ) { while ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { temp . push_back ( str [ i ] ) ; i ++ ; } while ( str [ i ] >= '1' && str [ i ] <= '9' ) { freq = freq * 10 + str [ i ] - '0' ; i ++ ; } for ( int j = 1 ; j <= freq ; j ++ ) expand . append ( temp ) ; } if ( freq == 0 ) expand . append ( temp ) ; return expand [ k - 1 ] ; } int main ( ) { string str = " ab4c12ed3" ; int k = 21 ; cout << encodedChar ( str , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int romanToDecimal ( string & str ) { map < char , int > m ; m . insert ( { ' I ' , 1 } ) ; m . insert ( { ' V ' , 5 } ) ; m . insert ( { ' X ' , 10 } ) ; m . insert ( { ' L ' , 50 } ) ; m . insert ( { ' C ' , 100 } ) ; m . insert ( { ' D ' , 500 } ) ; m . insert ( { ' M ' , 1000 } ) ; int sum = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( m [ str [ i ] ] < m [ str [ i + 1 ] ] ) { sum += m [ str [ i + 1 ] ] - m [ str [ i ] ] ; i ++ ; continue ; } sum += m [ str [ i ] ] ; } return sum ; } int main ( ) { string str = " MCMIV " ; cout << " Integer ▁ form ▁ of ▁ Roman ▁ Numeral ▁ is ▁ " << romanToDecimal ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinLength ( string arr [ ] , int n ) { int min = INT_MAX ; for ( int i = 0 ; i <= n - 1 ; i ++ ) if ( arr [ i ] . length ( ) < min ) min = arr [ i ] . length ( ) ; return ( min ) ; } bool allContainsPrefix ( string arr [ ] , int n , string str , int start , int end ) { for ( int i = 0 ; i <= n - 1 ; i ++ ) for ( int j = start ; j <= end ; j ++ ) if ( arr [ i ] [ j ] != str [ j ] ) return ( false ) ; return ( true ) ; } string commonPrefix ( string arr [ ] , int n ) { int index = findMinLength ( arr , n ) ; int low = 0 , high = index ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( allContainsPrefix ( arr , n , arr [ 0 ] , low , mid ) ) { prefix = prefix + arr [ 0 ] . substr ( low , mid - low + 1 ) ; low = mid + 1 ; } high = mid - 1 ; } return ( prefix ) ; } int main ( ) { string arr [ ] = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; string ans = commonPrefix ( arr , n ) ; if ( ans . length ( ) ) cout << " The ▁ longest ▁ common ▁ prefix ▁ is ▁ " << ans ; else cout << " There ▁ is ▁ no ▁ common ▁ prefix " ; return ( 0 ) ; }
#include <iostream> NEW_LINE using namespace std ; string to_upper ( string & in ) { for ( int i = 0 ; i < in . length ( ) ; i ++ ) if ( ' a ' <= in [ i ] <= ' z ' ) in [ i ] &= ~ ( 1 << 5 ) ; return in ; } int main ( ) { string str = " geeksforgeeks " ; cout << to_upper ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string commonPrefixUtil ( string str1 , string str2 ) { string result ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; for ( int i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 [ i ] != str2 [ j ] ) break ; result . push_back ( str1 [ i ] ) ; } return ( result ) ; } string commonPrefix ( string arr [ ] , int low , int high ) { if ( low == high ) return ( arr [ low ] ) ; if ( high > low ) { int mid = low + ( high - low ) / 2 ; string str1 = commonPrefix ( arr , low , mid ) ; string str2 = commonPrefix ( arr , mid + 1 , high ) ; return ( commonPrefixUtil ( str1 , str2 ) ) ; } } int main ( ) { string arr [ ] = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; string ans = commonPrefix ( arr , 0 , n - 1 ) ; if ( ans . length ( ) ) cout << " The ▁ longest ▁ common ▁ prefix ▁ is ▁ " << ans ; else cout << " There ▁ is ▁ no ▁ common ▁ prefix " ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string commonPrefixUtil ( string str1 , string str2 ) { string result ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; for ( int i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 [ i ] != str2 [ j ] ) break ; result . push_back ( str1 [ i ] ) ; } return ( result ) ; } string commonPrefix ( string arr [ ] , int n ) { string prefix = arr [ 0 ] ; for ( int i = 1 ; i <= n - 1 ; i ++ ) prefix = commonPrefixUtil ( prefix , arr [ i ] ) ; return ( prefix ) ; } int main ( ) { string arr [ ] = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; string ans = commonPrefix ( arr , n ) ; if ( ans . length ( ) ) printf ( " The ▁ longest ▁ common ▁ prefix ▁ is ▁ - ▁ % s " , ans . c_str ( ) ) ; else printf ( " There ▁ is ▁ no ▁ common ▁ prefix " ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( const char * str ) { int l = 0 ; int h = strlen ( str ) - 1 ; while ( h > l ) if ( str [ l ++ ] != str [ h -- ] ) return false ; return true ; } int minRemovals ( const char * str ) { if ( str [ 0 ] == ' ' ) return 0 ; if ( isPalindrome ( str ) ) return 1 ; return 2 ; } int main ( ) { cout << minRemovals ( "010010" ) << endl ; cout << minRemovals ( "0100101" ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; } void printOneAndTwosComplement ( string bin ) { int n = bin . length ( ) ; int i ; string ones , twos ; ones = twos = " " ; for ( i = 0 ; i < n ; i ++ ) ones += flip ( bin [ i ] ) ; twos = ones ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( ones [ i ] == '1' ) twos [ i ] = '0' ; else { twos [ i ] = '1' ; break ; } } if ( i == -1 ) twos = '1' + twos ; cout << "1 ' s ▁ complement : ▁ " << ones << endl ; cout << "2 ' s ▁ complement : ▁ " << twos << endl ; } int main ( ) { string bin = "1100" ; printOneAndTwosComplement ( bin ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void pattern ( string str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { int j = len - 1 - i ; for ( int k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) cout << str [ k ] ; else cout << " ▁ " ; } cout << endl ; } } int main ( ) { string str = " geeksforgeeks " ; int len = str . size ( ) ; pattern ( str , len ) ; return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; void printUtil ( string arr [ R ] [ C ] , int m , int n , string output [ R ] ) { output [ m ] = arr [ m ] [ n ] ; if ( m == R - 1 ) { for ( int i = 0 ; i < R ; i ++ ) cout << output [ i ] << " ▁ " ; cout << endl ; return ; } for ( int i = 0 ; i < C ; i ++ ) if ( arr [ m + 1 ] [ i ] != " " ) printUtil ( arr , m + 1 , i , output ) ; } void print ( string arr [ R ] [ C ] ) { string output [ R ] ; for ( int i = 0 ; i < C ; i ++ ) if ( arr [ 0 ] [ i ] != " " ) printUtil ( arr , 0 , i , output ) ; } int main ( ) { string arr [ R ] [ C ] = { { " you " , " we " } , { " have " , " are " } , { " sleep " , " eat " , " drink " } } ; print ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define NO_OF_CHARS  256 NEW_LINE bool canFormPalindrome ( string str ) { int count [ NO_OF_CHARS ] = { 0 } ; for ( int i = 0 ; str [ i ] ; i ++ ) count [ str [ i ] ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] & 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; } int main ( ) { canFormPalindrome ( " geeksforgeeks " ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; canFormPalindrome ( " geeksogeeks " ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeDuplicates ( string s , char ch ) { if ( s . length ( ) <= 1 ) { return s ; } int i = 0 ; while ( i < s . length ( ) ) { if ( i + 1 < s . length ( ) && s [ i ] == s [ i + 1 ] ) { int j = i ; while ( j + 1 < s . length ( ) && s [ j ] == s [ j + 1 ] ) { j ++ ; } char lastChar = i > 0 ? s [ i - 1 ] : ch ; string remStr = removeDuplicates ( s . substr ( j + 1 , s . length ( ) ) , lastChar ) ; s = s . substr ( 0 , i ) ; int k = s . length ( ) , l = 0 ; while ( remStr . length ( ) > 0 && s . length ( ) > 0 && remStr [ 0 ] == s [ s . length ( ) - 1 ] ) { while ( remStr . length ( ) > 0 && remStr [ 0 ] != ch && remStr [ 0 ] == s [ s . length ( ) - 1 ] ) { remStr = remStr . substr ( 1 , remStr . length ( ) ) ; } s = s . substr ( 0 , s . length ( ) - 1 ) ; } s = s + remStr ; i = j ; } else { i ++ ; } } return s ; } int main ( ) { string str1 = " mississipie " ; cout << removeDuplicates ( str1 , ' ▁ ' ) << endl ; string str2 = " ocvvcolop " ; cout << removeDuplicates ( str2 , ' ▁ ' ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < string > generateGray ( int n ) { if ( n <= 0 ) return { "0" } ; if ( n == 1 ) { return { "0" , "1" } ; } vector < string > recAns = generateGray ( n - 1 ) ; vector < string > mainAns ; for ( int i = 0 ; i < recAns . size ( ) ; i ++ ) { string s = recAns [ i ] ; mainAns . push_back ( "0" + s ) ; } for ( int i = recAns . size ( ) - 1 ; i >= 0 ; i -- ) { string s = recAns [ i ] ; mainAns . push_back ( "1" + s ) ; } return mainAns ; } void generateGrayarr ( int n ) { vector < string > arr ; arr = generateGray ( n ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << endl ; } int main ( ) { generateGrayarr ( 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define NO_OF_CHARS  256 NEW_LINE bool areAnagram ( char * str1 , char * str2 ) { int count1 [ NO_OF_CHARS ] = { 0 } ; int count2 [ NO_OF_CHARS ] = { 0 } ; int i ; for ( i = 0 ; str1 [ i ] && str2 [ i ] ; i ++ ) { count1 [ str1 [ i ] ] ++ ; count2 [ str2 [ i ] ] ++ ; } if ( str1 [ i ] str2 [ i ] ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; } int main ( ) { char str1 [ ] = " geeksforgeeks " ; char str2 [ ] = " forgeeksgeeks " ; if ( areAnagram ( str1 , str2 ) ) cout << " The ▁ two ▁ strings ▁ are ▁ anagram ▁ of ▁ each ▁ other " ; else cout << " The ▁ two ▁ strings ▁ are ▁ not ▁ anagram ▁ of ▁ each ▁ " " other " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int no_of_chars = 256 ; string findSubString ( string str , string pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ; if ( len1 < len2 ) { cout << " No ▁ such ▁ window ▁ exists " ; return " " ; } int hash_pat [ no_of_chars ] = { 0 } ; int hash_str [ no_of_chars ] = { 0 } ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat [ i ] ] ++ ; int start = 0 , start_index = -1 , min_len = INT_MAX ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str [ j ] ] ++ ; if ( hash_str [ str [ j ] ] <= hash_pat [ str [ j ] ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] hash_pat [ str [ start ] ] == 0 ) { if ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] ) hash_str [ str [ start ] ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == -1 ) { cout << " No ▁ such ▁ window ▁ exists " ; return " " ; } return str . substr ( start_index , min_len ) ; } int main ( ) { string str = " this ▁ is ▁ a ▁ test ▁ string " ; string pat = " tist " ; cout << " Smallest ▁ window ▁ is ▁ : ▁ STRNEWLINE " << findSubString ( str , pat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string RevString ( string s [ ] , int l ) { if ( l % 2 == 0 ) { int j = l / 2 ; while ( j <= l - 1 ) { string temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } else { int j = ( l / 2 ) + 1 ; while ( j <= l - 1 ) { string temp ; temp = s [ l - j - 1 ] ; s [ l - j - 1 ] = s [ j ] ; s [ j ] = temp ; j += 1 ; } } string S = s [ 0 ] ; for ( int i = 1 ; i < 9 ; i ++ ) { S = S + " ▁ " + s [ i ] ; } return S ; } int main ( ) { string s = " getting ▁ good ▁ at ▁ coding ▁ " " needs ▁ a ▁ lot ▁ of ▁ practice " ; string words [ ] = { " getting " , " good " , " at " , " coding " , " needs " , " a " , " lot " , " of " , " practice " } ; cout << RevString ( words , 9 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char * removeDuplicate ( char str [ ] , int n ) { int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < i ; j ++ ) if ( str [ i ] == str [ j ] ) break ; if ( j == i ) str [ index ++ ] = str [ i ] ; } return str ; } int main ( ) { char str [ ] = " geeksforgeeks " ; int n = sizeof ( str ) / sizeof ( str [ 0 ] ) ; cout << removeDuplicate ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char * removeDuplicates ( char * s , int n ) { unordered_map < char , int > exists ; int index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( exists [ s [ i ] ] == 0 ) { s [ index ++ ] = s [ i ] ; exists [ s [ i ] ] ++ ; } } return s ; } int main ( ) { char s [ ] = " geeksforgeeks " ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; cout << removeDuplicates ( s , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSub ( vector < vector < int > > & res , int sum , int K , int N , vector < int > & temp ) { if ( K == 0 && sum == 0 ) { res . push_back ( temp ) ; return ; } if ( sum <= 0 K <= 0 ) { return ; } for ( int i = 1 ; i <= N ; i ++ ) { temp . push_back ( i ) ; findSub ( res , sum - i , K - 1 , N , temp ) ; temp . pop_back ( ) ; } } void UtilPrintSubsequncesOfKSumN ( int N , int K ) { vector < vector < int > > res ; vector < int > temp ; findSub ( res , N , K , N , temp ) ; int sz = res . size ( ) ; cout << " { ▁ " ; for ( int i = 0 ; i < sz ; i ++ ) { cout << " { ▁ " ; for ( int j = 0 ; j < K ; j ++ ) { if ( j == K - 1 ) cout << res [ i ] [ j ] << " ▁ " ; else cout << res [ i ] [ j ] << " , ▁ " ; } if ( i == sz - 1 ) cout << " } " ; else cout << " } , ▁ " ; } cout << " ▁ } " ; } int main ( ) { int N = 4 ; int K = 2 ; UtilPrintSubsequncesOfKSumN ( N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum = INT_MAX ; void getMinPathSum ( unordered_map < int , vector < pair < int , int > > > & graph , vector < bool > & visited , vector < int > necessary , int src , int dest , int currSum ) { if ( src == dest ) { bool flag = true ; for ( int i : necessary ) { if ( ! visited [ i ] ) { flag = false ; break ; } } if ( flag ) minSum = min ( minSum , currSum ) ; return ; } else { visited [ src ] = true ; for ( auto node : graph [ src ] ) { if ( ! visited [ node . first ] ) { visited [ node . first ] = true ; getMinPathSum ( graph , visited , necessary , node . first , dest , currSum + node . second ) ; visited [ node . first ] = false ; } } visited [ src ] = false ; } } int main ( ) { unordered_map < int , vector < pair < int , int > > > graph ; graph [ 0 ] = { { 1 , 2 } , { 2 , 3 } , { 3 , 2 } } ; graph [ 1 ] = { { 4 , 4 } , { 0 , 1 } } ; graph [ 2 ] = { { 4 , 5 } , { 5 , 6 } } ; graph [ 3 ] = { { 5 , 7 } , { 0 , 1 } } ; graph [ 4 ] = { { 6 , 4 } } ; graph [ 5 ] = { { 6 , 2 } } ; graph [ 6 ] = { { 7 , 11 } } ; int n = 7 ; int source = 0 ; int dest = 6 ; vector < bool > visited ( n , false ) ; vector < int > necessary { 2 , 4 } ; getMinPathSum ( graph , visited , necessary , source , dest , 0 ) ; if ( minSum == INT_MAX ) cout << " - 1 STRNEWLINE " ; else cout << minSum << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void comb ( int * arr , int len , int r , int ipos , int * op , int opos , int sum ) { if ( opos == r ) { int sum2 = 0 ; for ( int i = 0 ; i < opos ; i ++ ) { sum2 = sum2 + op [ i ] ; } if ( sum == sum2 ) { for ( int i = 0 ; i < opos ; i ++ ) cout << op [ i ] << " , ▁ " ; cout << endl ; } return ; } if ( ipos < len ) { comb ( arr , len , r , ipos + 1 , op , opos , sum ) ; op [ opos ] = arr [ ipos ] ; comb ( arr , len , r , ipos + 1 , op , opos + 1 , sum ) ; } } int main ( ) { int arr [ ] = { 4 , 6 , 8 , 2 , 12 } ; int K = 3 ; int S = 20 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int op [ N ] = { 0 } ; comb ( arr , N , K , 0 , op , 0 , S ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool traverseMatrixDiagonally ( int m [ ] [ 5 ] , int i , int j , int row , int col ) { static int k1 = 0 , k2 = 0 ; static bool flag = true ; if ( i >= row j >= col ) { if ( flag ) { int a = k1 ; k1 = k2 ; k2 = a ; flag = ! flag ; k1 ++ ; } else { int a = k1 ; k1 = k2 ; k2 = a ; flag = ! flag ; } cout << endl ; return false ; } cout << m [ i ] [ j ] << " ▁ " ; if ( traverseMatrixDiagonally ( m , i + 1 , j + 1 , row , col ) ) { return true ; } if ( traverseMatrixDiagonally ( m , k1 , k2 , row , col ) ) { return true ; } return true ; } int main ( ) { int mtrx [ 5 ] [ 5 ] = { { 10 , 11 , 12 , 13 , 14 } , { 15 , 16 , 17 , 18 , 19 } , { 20 , 21 , 22 , 23 , 24 } , { 25 , 26 , 27 , 28 , 29 } , { 30 , 31 , 32 , 33 , 34 } } ; traverseMatrixDiagonally ( mtrx , 0 , 0 , 5 , 5 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 5 , m = 7 ; vector < pair < int , int > > g [ m ] ; int col [ n ] ; bool cyc ; int res [ m ] ; void dfs ( int v ) { col [ v ] = 1 ; for ( auto p : g [ v ] ) { int to = p . first , id = p . second ; if ( col [ to ] == 0 ) { dfs ( to ) ; res [ id ] = 1 ; } else if ( col [ to ] == 2 ) { res [ id ] = 1 ; } else { res [ id ] = 2 ; cyc = true ; } } col [ v ] = 2 ; } int main ( ) { g [ 0 ] . push_back ( make_pair ( 1 , 0 ) ) ; g [ 0 ] . push_back ( make_pair ( 2 , 1 ) ) ; g [ 1 ] . push_back ( make_pair ( 2 , 2 ) ) ; g [ 1 ] . push_back ( make_pair ( 3 , 3 ) ) ; g [ 2 ] . push_back ( make_pair ( 3 , 4 ) ) ; g [ 3 ] . push_back ( make_pair ( 4 , 5 ) ) ; g [ 4 ] . push_back ( make_pair ( 2 , 6 ) ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( col [ i ] == 0 ) { dfs ( i ) ; } } cout << ( cyc ? 2 : 1 ) << endl ; for ( int i = 0 ; i < m ; ++ i ) { cout << res [ i ] << ' ▁ ' ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumSubsets ( vector < int > set , int n , int target ) { int x [ set . size ( ) ] ; int j = set . size ( ) - 1 ; while ( n > 0 ) { x [ j ] = n % 2 ; n = n / 2 ; j -- ; } int sum = 0 ; for ( int i = 0 ; i < set . size ( ) ; i ++ ) if ( x [ i ] == 1 ) sum = sum + set [ i ] ; if ( sum == target ) { cout << ( " { " ) ; for ( int i = 0 ; i < set . size ( ) ; i ++ ) if ( x [ i ] == 1 ) cout << set [ i ] << " , ▁ " ; cout << ( " } , ▁ " ) ; } } void findSubsets ( vector < int > arr , int K ) { int x = pow ( 2 , arr . size ( ) ) ; for ( int i = 1 ; i < x ; i ++ ) sumSubsets ( arr , i , K ) ; } int main ( ) { vector < int > arr = { 5 , 10 , 12 , 13 , 15 , 18 } ; int K = 30 ; findSubsets ( arr , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  10 NEW_LINE int fact [ maxN ] ; int ncr ( int n , int r ) { return ( fact [ n ] / fact [ r ] ) / fact [ n - r ] ; } int findSum ( int * arr , int n ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int mul = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) mul += ( int ) pow ( 2 , i ) * ncr ( n - 1 , i ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += mul * arr [ i ] ; return ans ; } int main ( ) { int arr [ ] = { 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  4 NEW_LINE #define C  4 NEW_LINE int countPaths ( int maze [ ] [ C ] ) { if ( maze [ 0 ] [ 0 ] == -1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == -1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; } int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; } int solve ( int maze [ ] [ C ] ) { int ans = numberOfPaths ( R , C ) - countPaths ( maze ) ; return ans ; } int main ( ) { int maze [ R ] [ C ] = { { 0 , 0 , 0 , 0 } , { 0 , -1 , 0 , 0 } , { -1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; cout << solve ( maze ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void printPath ( vector < int > res , int nThNode , int kThNode ) { if ( kThNode > nThNode ) return ; res . push_back ( kThNode ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; cout << " STRNEWLINE " ; printPath ( res , nThNode , kThNode * 2 ) ; printPath ( res , nThNode , kThNode * 2 + 1 ) ; } void printPathToCoverAllNodeUtil ( int nThNode ) { vector < int > res ; printPath ( res , nThNode , 1 ) ; } int main ( ) { int nThNode = 7 ; printPathToCoverAllNodeUtil ( nThNode ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE #include <cmath> NEW_LINE using namespace std ; vector < int > set ; vector < int > prime ; bool isPrime ( int x ) { int sqroot = sqrt ( x ) ; bool flag = true ; if ( x == 1 ) return false ; for ( int i = 2 ; i <= sqroot ; i ++ ) if ( x % i == 0 ) return false ; return true ; } void display ( ) { int length = set . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) cout << set [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } void primeSum ( int total , int N , int S , int index ) { if ( total == S && set . size ( ) == N ) { display ( ) ; return ; } if ( total > S || index == prime . size ( ) ) return ; set . push_back ( prime [ index ] ) ; primeSum ( total + prime [ index ] , N , S , index + 1 ) ; set . pop_back ( ) ; primeSum ( total , N , S , index + 1 ) ; } void allPrime ( int N , int S , int P ) { for ( int i = P + 1 ; i <= S ; i ++ ) { if ( isPrime ( i ) ) prime . push_back ( i ) ; } if ( prime . size ( ) < N ) return ; primeSum ( 0 , N , S , 0 ) ; } int main ( ) { int S = 54 , N = 2 , P = 3 ; allPrime ( N , S , P ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void grayCodeUtil ( vector < int > & res , int n , int & num ) { if ( n == 0 ) { res . push_back ( num ) ; return ; } grayCodeUtil ( res , n - 1 , num ) ; num = num ^ ( 1 << ( n - 1 ) ) ; grayCodeUtil ( res , n - 1 , num ) ; } vector < int > grayCodes ( int n ) { vector < int > res ; int num = 0 ; grayCodeUtil ( res , n , num ) ; return res ; } int main ( ) { int n = 3 ; vector < int > code = grayCodes ( n ) ; for ( int i = 0 ; i < code . size ( ) ; i ++ ) cout << code [ i ] << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isKPartitionPossibleRec ( int arr [ ] , int subsetSum [ ] , bool taken [ ] , int subset , int K , int N , int curIdx , int limitIdx ) { if ( subsetSum [ curIdx ] == subset ) { if ( curIdx == K - 2 ) return true ; return isKPartitionPossibleRec ( arr , subsetSum , taken , subset , K , N , curIdx + 1 , N - 1 ) ; } for ( int i = limitIdx ; i >= 0 ; i -- ) { if ( taken [ i ] ) continue ; int tmp = subsetSum [ curIdx ] + arr [ i ] ; if ( tmp <= subset ) { taken [ i ] = true ; subsetSum [ curIdx ] += arr [ i ] ; bool nxt = isKPartitionPossibleRec ( arr , subsetSum , taken , subset , K , N , curIdx , i - 1 ) ; taken [ i ] = false ; subsetSum [ curIdx ] -= arr [ i ] ; if ( nxt ) return true ; } } return false ; } bool isKPartitionPossible ( int arr [ ] , int N , int K ) { if ( K == 1 ) return true ; if ( N < K ) return false ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % K != 0 ) return false ; int subset = sum / K ; int subsetSum [ K ] ; bool taken [ N ] ; for ( int i = 0 ; i < K ; i ++ ) subsetSum [ i ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) taken [ i ] = false ; subsetSum [ 0 ] = arr [ N - 1 ] ; taken [ N - 1 ] = true ; return isKPartitionPossibleRec ( arr , subsetSum , taken , subset , K , N , 0 , N - 1 ) ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 5 , 3 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; if ( isKPartitionPossible ( arr , N , K ) ) cout << " Partitions ▁ into ▁ equal ▁ sum ▁ is ▁ possible . STRNEWLINE " ; else cout << " Partitions ▁ into ▁ equal ▁ sum ▁ is ▁ not ▁ possible . STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isParenthesis ( char c ) { return ( ( c == ' ( ' ) || ( c == ' ) ' ) ) ; } bool isValidString ( string str ) { int cnt = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' ( ' ) cnt ++ ; else if ( str [ i ] == ' ) ' ) cnt -- ; if ( cnt < 0 ) return false ; } return ( cnt == 0 ) ; } void removeInvalidParenthesis ( string str ) { if ( str . empty ( ) ) return ; set < string > visit ; queue < string > q ; string temp ; bool level ; q . push ( str ) ; visit . insert ( str ) ; while ( ! q . empty ( ) ) { str = q . front ( ) ; q . pop ( ) ; if ( isValidString ( str ) ) { cout << str << endl ; level = true ; } if ( level ) continue ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( ! isParenthesis ( str [ i ] ) ) continue ; temp = str . substr ( 0 , i ) + str . substr ( i + 1 ) ; if ( visit . find ( temp ) == visit . end ( ) ) { q . push ( temp ) ; visit . insert ( temp ) ; } } } } int main ( ) { string expression = " ( ) ( ) ) ( ) " ; removeInvalidParenthesis ( expression ) ; expression = " ( ) v ) " ; removeInvalidParenthesis ( expression ) ; return 0 ; }
#define N  4 NEW_LINE #include <stdbool.h> NEW_LINE #include <stdio.h> NEW_LINE int ld [ 30 ] = { 0 } ; int rd [ 30 ] = { 0 } ; int cl [ 30 ] = { 0 } ; void printSolution ( int board [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( " ▁ % d ▁ " , board [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } } bool solveNQUtil ( int board [ N ] [ N ] , int col ) { if ( col >= N ) return true ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( ld [ i - col + N - 1 ] != 1 && rd [ i + col ] != 1 ) && cl [ i ] != 1 ) { board [ i ] [ col ] = 1 ; ld [ i - col + N - 1 ] = rd [ i + col ] = cl [ i ] = 1 ; if ( solveNQUtil ( board , col + 1 ) ) return true ; ld [ i - col + N - 1 ] = rd [ i + col ] = cl [ i ] = 0 ; } } return false ; } bool solveNQ ( ) { int board [ N ] [ N ] = { { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; if ( solveNQUtil ( board , 0 ) == false ) { printf ( " Solution ▁ does ▁ not ▁ exist " ) ; return false ; } printSolution ( board ) ; return true ; } int main ( ) { solveNQ ( ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printPairs ( int a [ ] , int n , int x ) { int i ; int rem [ x ] ; for ( i = 0 ; i < x ; i ++ ) { rem [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] < x ) { rem [ a [ i ] % x ] ++ ; } } for ( i = 1 ; i < x / 2 ; i ++ ) { if ( rem [ i ] > 0 && rem [ x - i ] > 0 ) { cout << " Yes " << " STRNEWLINE " ; break ; } } if ( i >= x / 2 ) { if ( x % 2 == 0 ) { if ( rem [ x / 2 ] > 1 ) { cout << " Yes " << " STRNEWLINE " ; } else { cout << " No " << " STRNEWLINE " ; } } else { if ( rem [ x / 2 ] > 0 && rem [ x - x / 2 ] > 0 ) { cout << " Yes " << " STRNEWLINE " ; } else { cout << " No " << " STRNEWLINE " ; } } } } int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int n = 16 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; printPairs ( A , arr_size , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int fact ( long long int n ) { long long int ans = 1 ; for ( long long int i = 2 ; i <= n ; i ++ ) ans *= i ; return ans ; } long long int remainder ( long long int n , long long int a , long long int p ) { long long int len = fact ( n ) ; long long int ans = 1 ; for ( long long int i = 1 ; i <= len ; i ++ ) ans = ( ans * a ) % p ; return ans ; } int main ( ) { long long int A = 2 , N = 1 , P = 2 ; cout << remainder ( N , A , P ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int n , int w ) { vector < int > a ( 105 ) ; int p = 0 ; while ( n > 0 ) { a [ p ++ ] = n % w ; n /= w ; } bool flag = true ; for ( int i = 0 ; i <= 100 ; i ++ ) { if ( a [ i ] == 0 a [ i ] == 1 ) continue ; else if ( a [ i ] == w a [ i ] == w - 1 ) a [ i + 1 ] ++ ; else flag = false ; } return flag ; } int main ( ) { int B = 3 , N = 7 ; if ( check ( N , B ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long mod = 1000000007 ; int exponentMod ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 ) ; y = ( y * y ) % mod ; } else { y = A % mod ; y = ( y * exponentMod ( A , B - 1 ) % mod ) % mod ; } return ( int ) ( ( y + mod ) % mod ) ; } void countWays ( int N ) { long long select = exponentMod ( 2 , N - 1 ) ; long long ways = ( ( N % mod ) * ( select % mod ) ) ; ways %= mod ; cout << ways ; } int main ( ) { int N = 5 ; countWays ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } bool isArmstrong ( int x ) { int n = to_string ( x ) . size ( ) ; int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += pow ( digit , n ) ; temp /= 10 ; } if ( sum1 == x ) return true ; return false ; } int MaxUtil ( int * st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return -1 ; int mid = getMid ( ss , se ) ; return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; } void updateValue ( int arr [ ] , int * st , int ss , int se , int index , int value , int node ) { if ( index < ss index > se ) { cout << " Invalid ▁ Input " << endl ; return ; } if ( ss == se ) { arr [ index ] = value ; if ( isArmstrong ( value ) ) st [ node ] = value ; else st [ node ] = -1 ; } else { int mid = getMid ( ss , se ) ; if ( index >= ss && index <= mid ) updateValue ( arr , st , ss , mid , index , value , 2 * node + 1 ) ; else updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 2 ) ; st [ node ] = max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) ; } return ; } int getMax ( int * st , int n , int l , int r ) { if ( l < 0 r > n - 1 l > r ) { printf ( " Invalid ▁ Input " ) ; return -1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { if ( isArmstrong ( arr [ ss ] ) ) st [ si ] = arr [ ss ] ; else st [ si ] = -1 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } int main ( ) { int arr [ ] = { 192 , 113 , 535 , 7 , 19 , 111 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * st = constructST ( arr , n ) ; cout << " Maximum ▁ armstrong ▁ " << " number ▁ in ▁ given ▁ range ▁ = ▁ " << getMax ( st , n , 1 , 3 ) << endl ; updateValue ( arr , st , 0 , n - 1 , 1 , 153 , 0 ) ; cout << " Updated ▁ Maximum ▁ armstrong ▁ " << " number ▁ in ▁ given ▁ range ▁ = ▁ " << getMax ( st , n , 1 , 3 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE bool isPerfectSquare ( long long int x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ? true : false ; } int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } int queryUtil ( int * st , int ss , int se , int qs , int qe , int index ) { if ( qs <= ss && qe >= se ) return st [ index ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return queryUtil ( st , ss , mid , qs , qe , 2 * index + 1 ) + queryUtil ( st , mid + 1 , se , qs , qe , 2 * index + 2 ) ; } void updateValueUtil ( int * st , int ss , int se , int i , int diff , int si ) { if ( i < ss i > se ) return ; st [ si ] = st [ si ] + diff ; if ( se != ss ) { int mid = getMid ( ss , se ) ; updateValueUtil ( st , ss , mid , i , diff , 2 * si + 1 ) ; updateValueUtil ( st , mid + 1 , se , i , diff , 2 * si + 2 ) ; } } void updateValue ( int arr [ ] , int * st , int n , int i , int new_val ) { if ( i < 0 i > n - 1 ) { printf ( " Invalid ▁ Input " ) ; return ; } int diff , oldValue ; oldValue = arr [ i ] ; arr [ i ] = new_val ; if ( isPerfectSquare ( oldValue ) && isPerfectSquare ( new_val ) ) return ; if ( ! isPerfectSquare ( oldValue ) && ! isPerfectSquare ( new_val ) ) return ; if ( isPerfectSquare ( oldValue ) && ! isPerfectSquare ( new_val ) ) { diff = -1 ; } if ( ! isPerfectSquare ( oldValue ) && ! isPerfectSquare ( new_val ) ) { diff = 1 ; } updateValueUtil ( st , 0 , n - 1 , i , diff , 0 ) ; } void query ( int * st , int n , int qs , int qe ) { int perfectSquareInRange = queryUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; cout << perfectSquareInRange << " STRNEWLINE " ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { if ( isPerfectSquare ( arr [ ss ] ) ) st [ si ] = 1 ; else st [ si ] = 0 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } int main ( ) { int arr [ ] = { 16 , 15 , 8 , 9 , 14 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * st = constructST ( arr , n ) ; int start = 0 ; int end = 4 ; query ( st , n , start , end ) ; int i = 3 ; int x = 11 ; updateValue ( arr , st , n , i , x ) ; start = 0 ; end = 4 ; query ( st , n , start , end ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int value ; int max_set_bits ; } ; Node tree [ 4 * 10000 ] ; int setBits ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( x & 1 ) parity ++ ; x = x >> 1 ; } return parity ; } void buildSegmentTree ( int a [ ] , int index , int beg , int end ) { if ( beg == end ) { tree [ index ] . value = a [ beg ] ; tree [ index ] . max_set_bits = setBits ( a [ beg ] ) ; } else { int mid = ( beg + end ) / 2 ; buildSegmentTree ( a , 2 * index + 1 , beg , mid ) ; buildSegmentTree ( a , 2 * index + 2 , mid + 1 , end ) ; if ( tree [ 2 * index + 1 ] . max_set_bits > tree [ 2 * index + 2 ] . max_set_bits ) { tree [ index ] . max_set_bits = tree [ 2 * index + 1 ] . max_set_bits ; tree [ index ] . value = tree [ 2 * index + 1 ] . value ; } else if ( tree [ 2 * index + 2 ] . max_set_bits > tree [ 2 * index + 1 ] . max_set_bits ) { tree [ index ] . max_set_bits = tree [ 2 * index + 2 ] . max_set_bits ; tree [ index ] . value = tree [ 2 * index + 2 ] . value ; } else { tree [ index ] . max_set_bits = tree [ 2 * index + 2 ] . max_set_bits ; tree [ index ] . value = max ( tree [ 2 * index + 2 ] . value , tree [ 2 * index + 1 ] . value ) ; } } } Node query ( int index , int beg , int end , int l , int r ) { Node result ; result . value = result . max_set_bits = -1 ; if ( beg > r end < l ) return result ; if ( beg >= l && end <= r ) return tree [ index ] ; int mid = ( beg + end ) / 2 ; if ( l > mid ) return query ( 2 * index + 2 , mid + 1 , end , l , r ) ; if ( r <= mid ) return query ( 2 * index + 1 , beg , mid , l , r ) ; Node left = query ( 2 * index + 1 , beg , mid , l , r ) ; Node right = query ( 2 * index + 2 , mid + 1 , end , l , r ) ; if ( left . max_set_bits > right . max_set_bits ) { result . max_set_bits = left . max_set_bits ; result . value = left . value ; } else if ( right . max_set_bits > left . max_set_bits ) { result . max_set_bits = right . max_set_bits ; result . value = right . value ; } else { result . max_set_bits = left . max_set_bits ; result . value = max ( right . value , left . value ) ; } return result ; } int main ( ) { int a [ ] = { 18 , 9 , 8 , 15 , 14 , 5 } ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; buildSegmentTree ( a , 0 , 0 , N - 1 ) ; cout << query ( 0 , 0 , N - 1 , 1 , 4 ) . value << endl ; cout << query ( 0 , 0 , N - 1 , 0 , 2 ) . value << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; set < int > fibonacci ; int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } void createHash ( int maxElement ) { int prev = 0 , curr = 1 ; fibonacci . insert ( prev ) ; fibonacci . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; fibonacci . insert ( temp ) ; prev = curr ; curr = temp ; } } int MaxUtil ( int * st , int ss , int se , int l , int r , int node ) { if ( l <= ss && r >= se ) return st [ node ] ; if ( se < l ss > r ) return -1 ; int mid = getMid ( ss , se ) ; return max ( MaxUtil ( st , ss , mid , l , r , 2 * node + 1 ) , MaxUtil ( st , mid + 1 , se , l , r , 2 * node + 2 ) ) ; } void updateValue ( int arr [ ] , int * st , int ss , int se , int index , int value , int node ) { if ( index < ss index > se ) { cout << " Invalid ▁ Input " << endl ; return ; } if ( ss == se ) { arr [ index ] = value ; if ( fibonacci . find ( value ) != fibonacci . end ( ) ) st [ node ] = value ; else st [ node ] = -1 ; } else { int mid = getMid ( ss , se ) ; if ( index >= ss && index <= mid ) updateValue ( arr , st , ss , mid , index , value , 2 * node + 1 ) ; else updateValue ( arr , st , mid + 1 , se , index , value , 2 * node + 2 ) ; st [ node ] = max ( st [ 2 * node + 1 ] , st [ 2 * node + 2 ] ) ; } return ; } int getMax ( int * st , int n , int l , int r ) { if ( l < 0 r > n - 1 l > r ) { printf ( " Invalid ▁ Input " ) ; return -1 ; } return MaxUtil ( st , 0 , n - 1 , l , r , 0 ) ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { if ( fibonacci . find ( arr [ ss ] ) != fibonacci . end ( ) ) st [ si ] = arr [ ss ] ; else st [ si ] = -1 ; return st [ si ] ; } int mid = getMid ( ss , se ) ; st [ si ] = max ( constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) , constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxEle = * max_element ( arr , arr + n ) ; createHash ( maxEle ) ; int * st = constructST ( arr , n ) ; cout << " Maximum ▁ fibonacci ▁ number " << " ▁ in ▁ given ▁ range ▁ = ▁ " << getMax ( st , n , 1 , 3 ) << endl ; updateValue ( arr , st , 0 , n - 1 , 3 , 8 , 0 ) ; cout << " Updated ▁ Maximum ▁ Fibonacci " << " ▁ number ▁ in ▁ given ▁ range ▁ = ▁ " << getMax ( st , n , 1 , 3 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < int , int > solve ( int n ) { int low = 1 , high = 1e4 , x = n , p = 0 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * ( mid + 1 ) ) / 2 ; if ( x - sum >= 1 ) { p = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } int start = 1 , end = 1e4 , y = 1 , q = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int sum = ( mid * ( mid + 1 ) ) / 2 ; if ( y + sum <= n ) { q = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } x = x - ( p * ( p + 1 ) ) / 2 ; y = y + ( q * ( q + 1 ) ) / 2 ; int r = x ; int c = q + 1 - n + y ; pair < int , int > ans = { r , c } ; return ans ; } int main ( ) { int n = 5 ; pair < int , int > p = solve ( n ) ; cout << p . first << " ▁ " << p . second ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long query ( int start , int end , int left , int right , int node , long long seg [ ] ) { if ( end < left start > right ) { return 0 ; } else if ( start >= left && end <= right ) { return seg [ node ] ; } else { int mid = ( start + end ) / 2 ; long long leftChild = query ( start , mid , left , right , 2 * node , seg ) ; long long rightChild = query ( mid + 1 , end , left , right , 2 * node + 1 , seg ) ; return ( leftChild rightChild ) ; } } void update ( int left , int right , int index , int Value , int node , int ar [ ] , long long seg [ ] ) { if ( left == right ) { ar [ index ] = Value ; seg [ node ] = ( 1LL << Value ) ; return ; } int mid = ( left + right ) / 2 ; if ( index > mid ) { update ( mid + 1 , right , index , Value , 2 * node + 1 , ar , seg ) ; } else { update ( left , mid , index , Value , 2 * node , ar , seg ) ; } seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } void build ( int left , int right , int node , int ar [ ] , long long seg [ ] ) { if ( left == right ) { seg [ node ] = ( 1LL << ar [ left ] ) ; return ; } int mid = ( left + right ) / 2 ; build ( left , mid , 2 * node , ar , seg ) ; build ( mid + 1 , right , 2 * node + 1 , ar , seg ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } void getDistinctCount ( vector < vector < int > > & queries , int ar [ ] , long long seg [ ] , int n ) { for ( int i = 0 ; i < queries . size ( ) ; i ++ ) { int op = queries [ i ] [ 0 ] ; if ( op == 2 ) { int l = queries [ i ] [ 1 ] , r = queries [ i ] [ 2 ] ; long long tempMask = query ( 0 , n - 1 , l - 1 , r - 1 , 1 , seg ) ; int countOfBits = 0 ; for ( int i = 63 ; i >= 0 ; i -- ) { if ( tempMask & ( 1LL << i ) ) { countOfBits ++ ; } } cout << countOfBits << ' ' ; } else { int index = queries [ i ] [ 1 ] ; int val = queries [ i ] [ 2 ] ; update ( 0 , n - 1 , index - 1 , val , 1 , ar , seg ) ; } } } int main ( ) { int n = 7 ; int ar [ ] = { 1 , 2 , 1 , 3 , 1 , 2 , 1 } ; long long seg [ 4 * n ] = { 0 } ; build ( 0 , n - 1 , 1 , ar , seg ) ; int q = 5 ; vector < vector < int > > queries = { { 2 , 1 , 4 } , { 1 , 4 , 2 } , { 1 , 5 , 2 } , { 2 , 4 , 6 } , { 2 , 1 , 7 } } ; getDistinctCount ( queries , ar , seg , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findGrid ( int n ) { int arr [ n ] [ n ] ; int x = 0 ; for ( int i = 0 ; i < n / 4 ; i ++ ) { for ( int j = 0 ; j < n / 4 ; j ++ ) { for ( int k = 0 ; k < 4 ; k ++ ) { for ( int l = 0 ; l < 4 ; l ++ ) { arr [ i * 4 + k ] [ j * 4 + l ] = x ; x ++ ; } } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << arr [ i ] [ j ] << " ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 4 ; findGrid ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxLen  30 NEW_LINE struct node { int data ; node * left ; node * right ; node ( int data ) { left = NULL ; right = NULL ; this -> data = data ; } } ; int segtree [ maxLen * 4 ] ; int buildTree ( int l , int r , int i , int * arr ) { if ( l == r ) { segtree [ i ] = l ; return l ; } int l1 = buildTree ( l , ( l + r ) / 2 , 2 * i + 1 , arr ) ; int r1 = buildTree ( ( l + r ) / 2 + 1 , r , 2 * i + 2 , arr ) ; if ( arr [ l1 ] > arr [ r1 ] ) segtree [ i ] = l1 ; else segtree [ i ] = r1 ; return segtree [ i ] ; } int rangeMax ( int l , int r , int rl , int rr , int i , int * arr ) { if ( r < rl l > rr ) return -1 ; if ( l >= rl and r <= rr ) return segtree [ i ] ; int l1 = rangeMax ( l , ( l + r ) / 2 , rl , rr , 2 * i + 1 , arr ) ; int r1 = rangeMax ( ( l + r ) / 2 + 1 , r , rl , rr , 2 * i + 2 , arr ) ; if ( l1 == -1 ) return r1 ; if ( r1 == -1 ) return l1 ; if ( arr [ l1 ] > arr [ r1 ] ) return l1 ; else return r1 ; } void inorder ( node * curr ) { if ( curr == NULL ) return ; inorder ( curr -> left ) ; cout << curr -> data << " ▁ " ; inorder ( curr -> right ) ; } node * createCartesianTree ( int l , int r , int * arr , int n ) { if ( r < l ) return NULL ; int m = rangeMax ( 0 , n - 1 , l , r , 0 , arr ) ; node * curr = new node ( arr [ m ] ) ; curr -> left = createCartesianTree ( l , m - 1 , arr , n ) ; curr -> right = createCartesianTree ( m + 1 , r , arr , n ) ; return curr ; } int main ( ) { int arr [ ] = { 8 , 11 , 21 , 100 , 5 , 70 , 55 } ; int n = sizeof ( arr ) / sizeof ( int ) ; buildTree ( 0 , n - 1 , 0 , arr ) ; inorder ( createCartesianTree ( 0 , n - 1 , arr , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int kthSmallest ( int * arr , int k , int n ) { int low = * min_element ( arr , arr + n ) ; int high = * max_element ( arr , arr + n ) ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int countless = 0 , countequal = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] < mid ) ++ countless ; else if ( arr [ i ] == mid ) ++ countequal ; } if ( countless < k && ( countless + countequal ) >= k ) { return mid ; } else if ( countless >= k ) { high = mid - 1 ; } else if ( countless < k && countless + countequal < k ) { low = mid + 1 ; } } } int main ( ) { int arr [ ] = { 7 , 10 , 4 , 3 , 20 , 15 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 3 ; cout << kthSmallest ( arr , k , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int lower_bound = 2 ; int upper_bound = 10 ; for ( int i = lower_bound ; i <= upper_bound ; i ++ ) { cout << i << endl ; int response ; cin >> response ; if ( response == 0 ) { cout << " Number ▁ guessed ▁ is ▁ : " << i ; break ; } } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE int tree [ MAX ] = { 0 } ; int lazy [ MAX ] = { 0 } ; void updateRangeUtil ( int si , int ss , int se , int us , int ue , int diff ) { if ( lazy [ si ] != 0 ) { tree [ si ] += lazy [ si ] ; if ( ss != se ) { lazy [ si * 2 + 1 ] += lazy [ si ] ; lazy [ si * 2 + 2 ] += lazy [ si ] ; } lazy [ si ] = 0 ; } if ( ss > se ss > ue se < us ) return ; if ( ss >= us && se <= ue ) { tree [ si ] += diff ; if ( ss != se ) { lazy [ si * 2 + 1 ] += diff ; lazy [ si * 2 + 2 ] += diff ; } return ; } int mid = ( ss + se ) / 2 ; updateRangeUtil ( si * 2 + 1 , ss , mid , us , ue , diff ) ; updateRangeUtil ( si * 2 + 2 , mid + 1 , se , us , ue , diff ) ; tree [ si ] = max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; } void updateRange ( int n , int us , int ue , int diff ) { updateRangeUtil ( 0 , 0 , n - 1 , us , ue , diff ) ; } int getMaxUtil ( int ss , int se , int qs , int qe , int si ) { if ( lazy [ si ] != 0 ) { tree [ si ] += lazy [ si ] ; if ( ss != se ) { lazy [ si * 2 + 1 ] += lazy [ si ] ; lazy [ si * 2 + 2 ] += lazy [ si ] ; } lazy [ si ] = 0 ; } if ( ss > se ss > qe se < qs ) return 0 ; if ( ss >= qs && se <= qe ) return tree [ si ] ; int mid = ( ss + se ) / 2 ; return max ( getSumUtil ( ss , mid , qs , qe , 2 * si + 1 ) , getSumUtil ( mid + 1 , se , qs , qe , 2 * si + 2 ) ) ; } int getMax ( int n , int qs , int qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { printf ( " Invalid ▁ Input " ) ; return -1 ; } return getSumUtil ( 0 , n - 1 , qs , qe , 0 ) ; } void constructSTUtil ( int arr [ ] , int ss , int se , int si ) { if ( ss > se ) return ; if ( ss == se ) { tree [ si ] = arr [ ss ] ; return ; } int mid = ( ss + se ) / 2 ; constructSTUtil ( arr , ss , mid , si * 2 + 1 ) ; constructSTUtil ( arr , mid + 1 , se , si * 2 + 2 ) ; tree [ si ] = max ( tree [ si * 2 + 1 ] , tree [ si * 2 + 2 ] ) ; } void constructST ( int arr [ ] , int n ) { constructSTUtil ( arr , 0 , n - 1 , 0 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; constructST ( arr , n ) ; updateRange ( n , 0 , 3 , 4 ) ; cout << getSum ( n , 1 , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } int findModuloByM ( int X , int N , int M ) { if ( N < 6 ) { string temp ( N , ( char ) ( 48 + X ) ) ; int res = stoi ( temp ) % M ; return res ; } if ( N % 2 == 0 ) { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 , M ) + half ) % M ; return res ; } else { int half = findModuloByM ( X , N / 2 , M ) % M ; int res = ( half * power ( 10 , N / 2 + 1 , M ) + half * 10 + X ) % M ; return res ; } } int main ( ) { int X = 6 , N = 14 , M = 9 ; cout << findModuloByM ( X , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = max ( l , a ) ; int R = min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; } int main ( ) { int l = 98 , r = 102 ; cout << rangeSum ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > permutation ; void printPermutation ( ) { for ( auto i : permutation ) cout << i << " ▁ " ; } int give_random_number ( int l , int r ) { int x = rand ( ) % ( r - l + 1 ) + l ; return x ; } void generate_random_permutation ( int l , int r ) { if ( l > r ) return ; int n = give_random_number ( l , r ) ; permutation . push_back ( n ) ; generate_random_permutation ( l , n - 1 ) ; generate_random_permutation ( n + 1 , r ) ; } int main ( ) { int l = 5 ; int r = 15 ; generate_random_permutation ( l , r ) ; printPermutation ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INF  99999 NEW_LINE #define size  10 NEW_LINE int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; } int findMinimum ( int x ) { int low = 0 , high = 100000 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( getSetBitsFromOneToN ( mid ) >= x ) { ans = min ( ans , mid ) ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; } int main ( ) { int x = 20 ; cout << findMinimum ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int trailingZeroes ( int n ) { int cnt = 0 ; while ( n > 0 ) { n /= 5 ; cnt += n ; } return cnt ; } void binarySearch ( int n ) { int low = 0 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int count = trailingZeroes ( mid ) ; if ( count < n ) low = mid + 1 ; else high = mid ; } vector < int > result ; while ( trailingZeroes ( low ) == n ) { result . push_back ( low ) ; low ++ ; } for ( int i = 0 ; i < result . size ( ) ; i ++ ) cout << result [ i ] << " ▁ " ; } int main ( ) { int n = 2 ; binarySearch ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCumulateSum ( int n ) { return ( n * ( n + 1 ) ) / 2 ; } int minDaysToEmpty ( int C , int l ) { if ( C <= l ) return C ; int lo = 0 ; int hi = 1e4 ; int mid ; while ( lo < hi ) { mid = ( lo + hi ) / 2 ; if ( getCumulateSum ( mid ) >= ( C - l ) ) hi = mid ; else lo = mid + 1 ; } return ( l + lo ) ; } int main ( ) { int C = 5 ; int l = 2 ; cout << minDaysToEmpty ( C , l ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( std :: sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return std :: ceil ( eq_root ) + l ; } int main ( ) { cout << minDaysToEmpty ( 5 , 2 ) << endl ; cout << minDaysToEmpty ( 6514683 , 4965 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int sorted1 [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; } int main ( ) { int arr1 [ 5 ] = { 2 , 3 , 6 , 7 , 9 } ; int arr2 [ 4 ] = { 1 , 4 , 8 , 10 } ; int k = 5 ; cout << kth ( arr1 , arr2 , 5 , 4 , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k , int st1 = 0 , int st2 = 0 ) { if ( st1 == m ) return arr2 [ st2 + k - 1 ] ; if ( st2 == n ) return arr1 [ st1 + k - 1 ] ; if ( k == 0 || k > ( m - st1 ) + ( n - st2 ) ) return -1 ; if ( k == 1 ) return ( arr1 [ st1 ] < arr2 [ st2 ] ) ? arr1 [ st1 ] : arr2 [ st2 ] ; int curr = k / 2 ; if ( curr - 1 >= m - st1 ) { if ( arr1 [ m - 1 ] < arr2 [ st2 + curr - 1 ] ) return arr2 [ st2 + ( k - ( m - st1 ) - 1 ) ] ; else return kth ( arr1 , arr2 , m , n , k - curr , st1 , st2 + curr ) ; } if ( curr - 1 >= n - st2 ) { if ( arr2 [ n - 1 ] < arr1 [ st1 + curr - 1 ] ) return arr1 [ st1 + ( k - ( n - st2 ) - 1 ) ] ; else return kth ( arr1 , arr2 , m , n , k - curr , st1 + curr , st2 ) ; } else { if ( arr1 [ curr + st1 - 1 ] < arr2 [ curr + st2 - 1 ] ) return kth ( arr1 , arr2 , m , n , k - curr , st1 + curr , st2 ) ; else return kth ( arr1 , arr2 , m , n , k - curr , st1 , st2 + curr ) ; } } int main ( ) { int arr1 [ 5 ] = { 2 , 3 , 6 , 7 , 9 } ; int arr2 [ 4 ] = { 1 , 4 , 8 , 10 } ; int k = 5 ; cout << kth ( arr1 , arr2 , 5 , 4 , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int kth ( int arr1 [ ] , int m , int arr2 [ ] , int n , int k ) { if ( k > ( m + n ) k < 1 ) return -1 ; if ( m > n ) return kth ( arr2 , n , arr1 , m , k ) ; if ( m == 0 ) return arr2 [ k - 1 ] ; if ( k == 1 ) return min ( arr1 [ 0 ] , arr2 [ 0 ] ) ; int i = min ( m , k / 2 ) , j = min ( n , k / 2 ) ; if ( arr1 [ i - 1 ] > arr2 [ j - 1 ] ) return kth ( arr1 , m , arr2 + j , n - j , k - j ) ; else return kth ( arr1 + i , m - i , arr2 , n , k - i ) ; } int main ( ) { int arr1 [ 5 ] = { 2 , 3 , 6 , 7 , 9 } ; int arr2 [ 4 ] = { 1 , 4 , 8 , 10 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int k = 5 ; int ans = kth ( arr1 , m , arr2 , n , k ) ; if ( ans == -1 ) cout << " Invalid ▁ query " ; else cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int kth ( int * a , int * b , int n , int m , int k ) { priority_queue < int , vector < int > , greater < int > > pq ; for ( int i = 0 ; i < n ; i ++ ) { pq . push ( a [ i ] ) ; } for ( int i = 0 ; i < m ; i ++ ) { pq . push ( b [ i ] ) ; } while ( k -- > 1 ) { pq . pop ( ) ; } return pq . top ( ) ; } int main ( ) { int arr1 [ 5 ] = { 2 , 3 , 6 , 7 , 9 } ; int arr2 [ 4 ] = { 1 , 4 , 8 , 10 } ; int k = 5 ; cout << kth ( arr1 , arr2 , 5 , 4 , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void binarySearch ( int mat [ ] [ MAX ] , int i , int j_low , int j_high , int x ) { while ( j_low <= j_high ) { int j_mid = ( j_low + j_high ) / 2 ; if ( mat [ i ] [ j_mid ] == x ) { cout << " Found ▁ at ▁ ( " << i << " , ▁ " << j_mid << " ) " ; return ; } else if ( mat [ i ] [ j_mid ] > x ) j_high = j_mid - 1 ; else j_low = j_mid + 1 ; } cout << " Element ▁ no ▁ found " ; } void sortedMatrixSearch ( int mat [ ] [ MAX ] , int n , int m , int x ) { if ( n == 1 ) { binarySearch ( mat , 0 , 0 , m - 1 , x ) ; return ; } int i_low = 0 ; int i_high = n - 1 ; int j_mid = m / 2 ; while ( ( i_low + 1 ) < i_high ) { int i_mid = ( i_low + i_high ) / 2 ; if ( mat [ i_mid ] [ j_mid ] == x ) { cout << " Found ▁ at ▁ ( " << i_mid << " , ▁ " << j_mid << " ) " ; return ; } else if ( mat [ i_mid ] [ j_mid ] > x ) i_high = i_mid ; else i_low = i_mid ; } if ( mat [ i_low ] [ j_mid ] == x ) cout << " Found ▁ at ▁ ( " << i_low << " , " << j_mid << " ) " ; else if ( mat [ i_low + 1 ] [ j_mid ] == x ) cout << " Found ▁ at ▁ ( " << ( i_low + 1 ) << " , ▁ " << j_mid << " ) " ; else if ( x <= mat [ i_low ] [ j_mid - 1 ] ) binarySearch ( mat , i_low , 0 , j_mid - 1 , x ) ; else if ( x >= mat [ i_low ] [ j_mid + 1 ] && x <= mat [ i_low ] [ m - 1 ] ) binarySearch ( mat , i_low , j_mid + 1 , m - 1 , x ) ; else if ( x <= mat [ i_low + 1 ] [ j_mid - 1 ] ) binarySearch ( mat , i_low + 1 , 0 , j_mid - 1 , x ) ; else binarySearch ( mat , i_low + 1 , j_mid + 1 , m - 1 , x ) ; } int main ( ) { int n = 4 , m = 5 , x = 8 ; int mat [ ] [ MAX ] = { { 0 , 6 , 8 , 9 , 11 } , { 20 , 22 , 28 , 29 , 31 } , { 36 , 38 , 50 , 61 , 63 } , { 64 , 66 , 100 , 122 , 128 } } ; sortedMatrixSearch ( mat , n , m , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  2 NEW_LINE #define C  2 NEW_LINE int bsearch ( int low , int high , int n , int arr [ ] ) { int mid = ( low + high ) / 2 ; if ( low <= high ) { if ( arr [ mid ] < n ) return bsearch ( mid + 1 , high , n , arr ) ; return bsearch ( low , mid - 1 , n , arr ) ; } return low ; } int mindiff ( int arr [ R ] [ C ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) sort ( arr [ i ] , arr [ i ] + m ) ; int ans = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int p = bsearch ( 0 , m - 1 , arr [ i ] [ j ] , arr [ i + 1 ] ) ; ans = min ( ans , abs ( arr [ i + 1 ] [ p ] - arr [ i ] [ j ] ) ) ; if ( p - 1 >= 0 ) ans = min ( ans , abs ( arr [ i + 1 ] [ p - 1 ] - arr [ i ] [ j ] ) ) ; } } return ans ; } int main ( ) { int m [ R ] [ C ] = { 8 , 5 , 6 , 8 , } ; cout << mindiff ( m , R , C ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findRepeatingElement ( int arr [ ] , int low , int high ) { if ( low > high ) return -1 ; int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int index = findRepeatingElement ( arr , 0 , n - 1 ) ; if ( index != -1 ) cout << arr [ index ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double diff ( double n , double mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; } double cubicRoot ( double n ) { double start = 0 , end = n ; double e = 0.0000001 ; while ( true ) { double mid = ( start + end ) / 2 ; double error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } } int main ( ) { double n = 3 ; printf ( " Cubic ▁ root ▁ of ▁ % lf ▁ is ▁ % lf STRNEWLINE " , n , cubicRoot ( n ) ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void findFrequencyUtil ( int arr [ ] , int low , int high , vector < int > & freq ) { if ( arr [ low ] == arr [ high ] ) { freq [ arr [ low ] ] += high - low + 1 ; } else { int mid = ( low + high ) / 2 ; findFrequencyUtil ( arr , low , mid , freq ) ; findFrequencyUtil ( arr , mid + 1 , high , freq ) ; } } void findFrequency ( int arr [ ] , int n ) { vector < int > freq ( arr [ n - 1 ] + 1 , 0 ) ; findFrequencyUtil ( arr , 0 , n - 1 , freq ) ; for ( int i = 0 ; i <= arr [ n - 1 ] ; i ++ ) if ( freq [ i ] != 0 ) cout << " Element ▁ " << i << " ▁ occurs ▁ " << freq [ i ] << " ▁ times " << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 2 , 3 , 3 , 5 , 5 , 8 , 8 , 8 , 9 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findFrequency ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; } int main ( ) { int x = 11 ; cout << floorSqrt ( x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canReach ( int X , int Y , int steps ) { if ( X == 0 && Y == 0 ) { return true ; } if ( X < 0 Y < 0 ) { return false ; } return ( canReach ( X - ( int ) pow ( 3 , steps ) , Y , steps + 1 ) | canReach ( X , Y - ( int ) pow ( 3 , steps ) , steps + 1 ) ) ; } int main ( ) { int X = 10 , Y = 30 ; if ( canReach ( X , Y , 0 ) ) { cout << " YES " << endl ; } else cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canReach ( int X , int Y ) { int steps = 0 ; while ( X Y ) { int pos1 = X % 3 ; int pos2 = Y % 3 ; if ( pos1 == 2 pos2 == 2 ) { return false ; } if ( pos1 == 1 && pos2 == 1 ) { return false ; } if ( pos1 == 0 && pos2 == 0 ) { return false ; } X /= 3 ; Y /= 3 ; steps ++ ; } return true ; } int main ( ) { int X = 10 , Y = 30 ; if ( canReach ( X , Y ) ) { cout << " YES " ; } else { cout << " NO " ; } }
#include <iostream> NEW_LINE using namespace std ; double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; } int main ( ) { double A = 3.0 , B = 2.0 ; cout << lengthOfLatusRectum ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double radius ( int a , int b , int c ) { int g = a / 2 ; int f = b / 2 ; if ( g * g + f * f - c < 0 ) return ( -1 ) ; return ( sqrt ( g * g + f * f - c ) ) ; } double centerDistanceFromLine ( int a , int b , int i , int j , int k ) { int g = a / 2 ; int f = b / 2 ; double distance = fabs ( i * g + j * f + k ) / ( sqrt ( i * i + j * j ) ) ; if ( distance < 0 ) return ( -1 ) ; return distance ; } void interceptLength ( int a , int b , int c , int i , int j , int k ) { double rad = radius ( a , b , c ) ; double dist = centerDistanceFromLine ( a , b , i , j , k ) ; if ( rad < 0 dist < 0 ) { cout << " circle ▁ not ▁ possible " ; return ; } if ( dist > rad ) { cout << " Line ▁ not ▁ cutting ▁ circle " ; } else cout << 2 * sqrt ( rad * rad - dist * dist ) ; } int main ( ) { int a = 0 , b = 0 , c = -4 ; int i = 2 , j = -1 , k = 1 ; interceptLength ( a , b , c , i , j , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void check_position ( int a , int b , int c , int d , int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int value_1 = a * x1 + b * y1 + c * z1 + d ; int value_2 = a * x2 + b * y2 + c * z2 + d ; if ( ( value_1 > 0 && value_2 > 0 ) || ( value_1 < 0 && value_2 < 0 ) ) cout << " On ▁ same ▁ side " ; if ( ( value_1 > 0 && value_2 < 0 ) || ( value_1 < 0 && value_2 > 0 ) ) cout << " On ▁ different ▁ sides " ; if ( value_1 == 0 && value_2 == 0 ) cout << " Both ▁ on ▁ the ▁ plane " ; if ( value_1 == 0 && value_2 != 0 ) cout << " Point ▁ 1 ▁ on ▁ the ▁ plane " ; if ( value_1 != 0 && value_2 == 0 ) cout << " Point ▁ 2 ▁ on ▁ the ▁ plane " ; } int main ( ) { int a = 1 , b = 2 , c = 3 , d = 4 ; int x1 = -2 , y1 = -2 , z1 = 1 ; int x2 = -4 , y2 = 11 , z2 = -1 ; check_position ( a , b , c , d , x1 , y1 , z1 , x2 , y2 , z2 ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; bool checkIntersection ( int arr [ ] , int N ) { vector < pair < int , int > > vec ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int x = arr [ i ] , y = arr [ i + 1 ] ; int minn = min ( x , y ) ; int maxx = max ( x , y ) ; vec . push_back ( { minn , maxx } ) ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { pair < int , int > x = vec [ i ] ; for ( int j = 0 ; j < vec . size ( ) ; j ++ ) { pair < int , int > y = vec [ j ] ; bool cond1 = ( x . first < y . first and x . second < y . second and y . first < x . second ) ; bool cond2 = ( y . first < x . first and y . second < x . second and x . first < y . second ) ; if ( cond1 or cond2 ) { return true ; } } } return false ; } int main ( ) { int arr [ ] = { 0 , 15 , 5 , 10 } ; int N = sizeof ( arr ) / sizeof ( int ) ; if ( checkIntersection ( arr , N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void AreaFactor ( int n ) { double pi = 3.14159265 ; double areaf = 1 / ( cos ( pi / n ) * cos ( pi / n ) ) ; cout << fixed << setprecision ( 6 ) << areaf << endl ; } int main ( ) { int n = 4 ; AreaFactor ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class circle { public : double x ; double y ; double r ; } ; bool check ( circle C [ ] ) { double C1C2 = sqrt ( ( C [ 1 ] . x - C [ 0 ] . x ) * ( C [ 1 ] . x - C [ 0 ] . x ) + ( C [ 1 ] . y - C [ 0 ] . y ) * ( C [ 1 ] . y - C [ 0 ] . y ) ) ; bool flag = 0 ; if ( C1C2 < ( C [ 0 ] . r + C [ 1 ] . r ) ) { if ( ( C [ 0 ] . x + C [ 1 ] . x ) == 2 * C [ 2 ] . x && ( C [ 0 ] . y + C [ 1 ] . y ) == 2 * C [ 2 ] . y ) { flag = 1 ; } } return flag ; } bool IsFairTriplet ( circle c [ ] ) { bool f = false ; f |= check ( c ) ; for ( int i = 0 ; i < 2 ; i ++ ) { swap ( c [ 0 ] , c [ 2 ] ) ; f |= check ( c ) ; } return f ; } int main ( ) { circle C [ 3 ] ; C [ 0 ] = { 0 , 0 , 8 } ; C [ 1 ] = { 0 , 10 , 6 } ; C [ 2 ] = { 0 , 5 , 5 } ; if ( IsFairTriplet ( C ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define PI  3.14159265 NEW_LINE double findInteriorAngle ( int n ) { return ( n - 2 ) * PI / n ; } double calculateSideLength ( double L , int N , int K ) { double angle = findInteriorAngle ( N ) ; double length = L * pow ( sin ( angle / 2 ) , ( K - 1 ) ) ; return length ; } int main ( ) { double N = 5 , L = 21 , K = 7 ; cout << calculateSideLength ( L , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define PI  3.14159265 NEW_LINE void findAngle ( double M1 , double M2 ) { double angle = abs ( ( M2 - M1 ) / ( 1 + M1 * M2 ) ) ; double ret = atan ( angle ) ; double val = ( ret * 180 ) / PI ; cout << val ; } int main ( ) { double M1 = 1.75 , M2 = 0.27 ; findAngle ( M1 , M2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float angle ( float R1 , float R2 , float D ) { float ans = ( R1 * R1 + R2 * R2 - D * D ) / ( 2 * R1 * R2 ) ; return ans ; } int main ( ) { float R1 = 3 , R2 = 4 ; float D = 5 ; cout << angle ( R1 , R2 , D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void triangleArea ( int a , int b ) { double ratio = ( double ) b / a ; cout << ratio ; } int main ( ) { int a = 1 , b = 2 ; triangleArea ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string find ( int a [ ] , int b [ ] , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) { continue ; } long long int dis = abs ( a [ i ] - a [ j ] ) + abs ( b [ i ] - b [ j ] ) ; if ( dis <= K ) { count ++ ; } if ( count == N - 1 ) { return " Yes " ; } } } return " No " ; } int main ( ) { int N = 5 ; int A [ ] = { 1 , 0 , 2 , 1 , 1 } ; int B [ ] = { 1 , 1 , 1 , 0 , 2 } ; int K = 1 ; cout << find ( A , B , N , K ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumTriangleArea ( int a , int b ) { int area = a * b ; cout << area ; } int main ( ) { int a = 1 , b = 2 ; minimumTriangleArea ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findAngles ( double a , double b , double c , double d ) { double numerator = a * a + d * d - b * b - c * c ; double denominator = 2 * ( a * b + c * d ) ; double x = numerator / denominator ; cout << fixed << setprecision ( 2 ) << " A : ▁ " << ( acos ( x ) * 180 ) / 3.141592 << " ▁ degrees " ; numerator = a * a + b * b - c * c - d * d ; x = numerator / denominator ; cout << fixed << setprecision ( 2 ) << " STRNEWLINE B : ▁ " << ( acos ( x ) * 180 ) / 3.141592 << " ▁ degrees " ; numerator = c * c + b * b - a * a - d * d ; x = numerator / denominator ; cout << fixed << setprecision ( 2 ) << " STRNEWLINE C : ▁ " << ( acos ( x ) * 180 ) / 3.141592 << " ▁ degrees " ; numerator = d * d + c * c - a * a - b * b ; x = numerator / denominator ; cout << fixed << setprecision ( 2 ) << " STRNEWLINE D : ▁ " << ( acos ( x ) * 180 ) / 3.141592 << " ▁ degrees " ; } int main ( ) { double A = 10 , B = 15 , C = 20 , D = 25 ; findAngles ( A , B , C , D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countInscribed ( int R1 , int R2 ) { if ( R2 > R1 ) return 0 ; double angle ; double ratio ; int number_of_circles = 0 ; ratio = R2 / ( double ) ( R1 - R2 ) ; if ( R1 < 2 * R2 ) { number_of_circles = 1 ; } else { angle = abs ( asin ( ratio ) * 180 ) / 3.14159265 ; number_of_circles = 360 / ( 2 * floor ( angle ) ) ; } return number_of_circles ; } int main ( ) { int R1 = 3 ; int R2 = 1 ; cout << countInscribed ( R1 , R2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float distance ( int m , int n , int p , int q ) { return sqrt ( pow ( n - m , 2 ) + pow ( q - p , 2 ) * 1.0 ) ; } void Excenters ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { float a = distance ( x2 , x3 , y2 , y3 ) ; float b = distance ( x3 , x1 , y3 , y1 ) ; float c = distance ( x1 , x2 , y1 , y2 ) ; vector < pair < float , float > > excenter ( 4 ) ; excenter [ 1 ] . first = ( - ( a * x1 ) + ( b * x2 ) + ( c * x3 ) ) / ( - a + b + c ) ; excenter [ 1 ] . second = ( - ( a * y1 ) + ( b * y2 ) + ( c * y3 ) ) / ( - a + b + c ) ; excenter [ 2 ] . first = ( ( a * x1 ) - ( b * x2 ) + ( c * x3 ) ) / ( a - b + c ) ; excenter [ 2 ] . second = ( ( a * y1 ) - ( b * y2 ) + ( c * y3 ) ) / ( a - b + c ) ; excenter [ 3 ] . first = ( ( a * x1 ) + ( b * x2 ) - ( c * x3 ) ) / ( a + b - c ) ; excenter [ 3 ] . second = ( ( a * y1 ) + ( b * y2 ) - ( c * y3 ) ) / ( a + b - c ) ; for ( int i = 1 ; i <= 3 ; i ++ ) { cout << excenter [ i ] . first << " ▁ " << excenter [ i ] . second << endl ; } } int main ( ) { float x1 , x2 , x3 , y1 , y2 , y3 ; x1 = 0 ; x2 = 3 ; x3 = 0 ; y1 = 0 ; y2 = 0 ; y3 = 4 ; Excenters ( x1 , y1 , x2 , y2 , x3 , y3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( vector < int > x , vector < int > y , int K ) { int n = x . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { if ( K * abs ( x [ i ] - x [ j ] ) >= abs ( y [ i ] - y [ j ] ) ) { ++ ans ; } } } cout << ans ; } int main ( ) { vector < int > X = { 2 , 1 , 0 } , Y = { 1 , 2 , 0 } ; int K = 1 ; findPairs ( X , Y , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double findDiagonal ( double s ) { return sqrt ( 2 ) * s ; } int main ( ) { double S = 10 ; cout << findDiagonal ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void triangleArea ( float a , float b ) { if ( a < 0 b < 0 ) { cout << -1 ; return ; } float area = ( 3 * sqrt ( 3 ) * a * b ) / ( 4 ) ; cout << area ; } int main ( ) { float a = 1 , b = 2 ; triangleArea ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int const MAX = 1e6 + 5 ; int query ( vector < vector < float > > arr , vector < int > Q ) { int pre [ MAX ] = { 0 } ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( arr [ i ] [ 0 ] < 0 arr [ i ] [ 1 ] < 0 ) continue ; int sum = ceil ( ( arr [ i ] [ 0 ] + arr [ i ] [ 1 ] ) ) ; pre [ sum ] ++ ; } for ( int i = 1 ; i < MAX ; i ++ ) pre [ i ] += pre [ i - 1 ] ; for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { cout << pre [ Q [ i ] ] << " ▁ " ; } cout << endl ; } int main ( ) { vector < vector < float > > arr = { { 2.1 , 3.0 } , { 3.7 , 1.2 } , { 1.5 , 6.5 } , { 1.2 , 0.0 } } ; vector < int > Q = { 2 , 8 , 5 } ; int N = arr . size ( ) ; int M = Q . size ( ) ; query ( arr , Q ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findHeight ( float p1 , float p2 , float b , float c ) { float a = max ( p1 , p2 ) - min ( p1 , p2 ) ; float s = ( a + b + c ) / 2 ; float area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; float height = ( area * 2 ) / a ; cout << " Height ▁ is : ▁ " << height ; } int main ( ) { float p1 = 25 , p2 = 10 ; float a = 14 , b = 13 ; findHeight ( p1 , p2 , a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool doIntersect ( vector < int > X , vector < int > Y ) { if ( X [ 0 ] > X [ 3 ] X [ 2 ] > X [ 1 ] ) return false ; if ( Y [ 0 ] > Y [ 3 ] Y [ 2 ] > Y [ 1 ] ) return false ; return true ; } int getUnionPerimeter ( vector < int > X , vector < int > Y ) { int perimeter = 0 ; if ( ! doIntersect ( X , Y ) ) { perimeter += 2 * ( abs ( X [ 1 ] - X [ 0 ] ) + abs ( Y [ 1 ] - Y [ 0 ] ) ) ; perimeter += 2 * ( abs ( X [ 3 ] - X [ 2 ] ) + abs ( Y [ 3 ] - Y [ 2 ] ) ) ; } else { int w = * max_element ( X . begin ( ) , X . end ( ) ) - * min_element ( X . begin ( ) , X . end ( ) ) ; int l = * max_element ( Y . begin ( ) , Y . end ( ) ) - * min_element ( Y . begin ( ) , Y . end ( ) ) ; perimeter = 2 * ( l + w ) ; } return perimeter ; } int main ( ) { vector < int > X { -1 , 2 , 4 , 6 } ; vector < int > Y { 2 , 5 , 3 , 7 } ; cout << getUnionPerimeter ( X , Y ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void parallel ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { if ( ( - ( a1 / b1 ) ) == ( - ( a2 / b2 ) ) ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { float a1 = -2 , b1 = 4 , c1 = 5 ; float a2 = -6 , b2 = 12 , c2 = 6 ; parallel ( a1 , b1 , c1 , a2 , b2 , c2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double Convert ( double degree ) { double pi = 3.14159265359 ; return ( degree * ( pi / 180 ) ) ; } void areaAndHeightOfTraingle ( double radius , double a ) { if ( a >= 180 a == 0 ) { cout << " Not ▁ possible " ; return ; } double base_angle = ( 180 - a ) / 2 ; double radians = Convert ( base_angle ) ; double height = sin ( radians ) * radius ; cout << " Height ▁ of ▁ triangle ▁ " << height << endl ; double base = cos ( radians ) * radius ; double area = base * height ; cout << " Area ▁ of ▁ triangle ▁ " << area << endl ; } int main ( ) { double R = 5 , angle = 120 ; areaAndHeightOfTraingle ( R , angle ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Tri { int MinX , MaxX , MinY , MaxY ; } ; int StringtoInt ( string s ) { stringstream geek ( s ) ; int x ; geek >> x ; return x ; } int TriangleCuts ( vector < vector < int > > Triangle , string Cuts [ ] , int N , int M , int COL ) { Tri Minimized [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int x1 = Triangle [ i ] [ 0 ] ; int y1 = Triangle [ i ] [ 1 ] ; int x2 = Triangle [ i ] [ 2 ] ; int y2 = Triangle [ i ] [ 3 ] ; int x3 = Triangle [ i ] [ 4 ] ; int y3 = Triangle [ i ] [ 5 ] ; Minimized [ i ] . MinX = min ( { x1 , x2 , x3 } ) ; Minimized [ i ] . MaxX = max ( { x1 , x2 , x3 } ) ; Minimized [ i ] . MinY = min ( { y1 , y2 , y3 } ) ; Minimized [ i ] . MaxY = max ( { y1 , y2 , y3 } ) ; } for ( int i = 0 ; i < M ; i ++ ) { string Cut = Cuts [ i ] ; int CutCount = 0 ; int CutVal = StringtoInt ( Cut . substr ( 2 , Cut . size ( ) ) ) ; if ( Cut [ 0 ] == ' X ' ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( Minimized [ j ] . MinX ) < ( CutVal ) & & ( Minimized [ j ] . MaxX ) > ( CutVal ) ) { CutCount ++ ; } } } else if ( Cut [ 0 ] == ' Y ' ) { for ( int j = 0 ; j < N ; j ++ ) { if ( ( Minimized [ j ] . MinY ) < ( CutVal ) & & ( Minimized [ j ] . MaxY ) > ( CutVal ) ) { CutCount ++ ; } } } cout << CutCount << " ▁ " ; } } int main ( ) { vector < vector < int > > Triangle = { { 0 , 2 , 2 , 9 , 8 , 5 } , { 5 , 0 , 6 , 3 , 7 , 0 } } ; int N = Triangle . size ( ) ; int COL = 6 ; string Cuts [ ] = { " X = 2" , " Y = 2" , " Y = 9" } ; int M = sizeof ( Cuts ) / sizeof ( Cuts [ 0 ] ) ; TriangleCuts ( Triangle , Cuts , N , M , COL ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntRect ( int points [ ] [ 2 ] , int N , int rectangle [ ] [ 2 ] ) { unordered_set < int > cntHor ; unordered_set < int > cntVer ; cntHor . insert ( 0 ) ; cntVer . insert ( 0 ) ; cntHor . insert ( rectangle [ 3 ] [ 0 ] ) ; cntVer . insert ( rectangle [ 3 ] [ 1 ] ) ; for ( int i = 0 ; i < N ; i ++ ) { cntHor . insert ( points [ i ] [ 0 ] ) ; cntVer . insert ( points [ i ] [ 1 ] ) ; } return ( cntHor . size ( ) - 1 ) * ( cntVer . size ( ) - 1 ) ; } int main ( ) { int rectangle [ ] [ 2 ] = { { 0 , 0 } , { 0 , 5 } , { 5 , 0 } , { 5 , 5 } } ; int points [ ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } } ; int N = sizeof ( points ) / sizeof ( points [ 0 ] ) ; cout << cntRect ( points , N , rectangle ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfSquares ( int X [ ] , int Y [ ] , int N , int M ) { unordered_map < int , int > m1 , m2 ; int i , j , ans = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { int dist = abs ( X [ i ] - X [ j ] ) ; m1 [ dist ] ++ ; } } for ( i = 0 ; i < M ; i ++ ) { for ( j = i + 1 ; j < M ; j ++ ) { int dist = abs ( Y [ i ] - Y [ j ] ) ; m2 [ dist ] ++ ; } } for ( auto i = m1 . begin ( ) ; i != m1 . end ( ) ; i ++ ) { if ( m2 . find ( i -> first ) != m2 . end ( ) ) { ans += ( i -> second * m2 [ i -> first ] ) ; } } return ans ; } int main ( ) { int X [ ] = { 1 , 3 , 7 } ; int Y [ ] = { 2 , 4 , 6 , 1 } ; int N = sizeof ( X ) / sizeof ( X [ 0 ] ) ; int M = sizeof ( Y ) / sizeof ( Y [ 0 ] ) ; cout << numberOfSquares ( X , Y , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double toRadians ( int degree ) { double pi = 3.14159265359 ; return ( ( double ) degree * ( pi / 180 ) ) ; } double Area_Parallelogram1 ( int a , int b , int theta ) { double area = ( abs ( tan ( toRadians ( theta ) ) ) / 2 ) * abs ( a * a - b * b ) ; return area ; } double Area_Parallelogram2 ( int a , int b , int gamma ) { double area = ( abs ( sin ( toRadians ( gamma ) ) ) ) * abs ( a * b ) ; return area ; } static double Area_Parallelogram3 ( int d1 , int d2 , int theta ) { double area = ( abs ( sin ( toRadians ( theta ) ) ) / 2 ) * abs ( d1 * d2 ) ; return area ; } int main ( ) { int d1 = 3 ; int d2 = 5 ; int theta = 90 ; double area = Area_Parallelogram3 ( d1 , d2 , theta ) ; printf ( " % .2f " , area ) ; }
#include <iostream> NEW_LINE using namespace std ; int No_of_squares ( int N , int K ) { int no_of_squares = 0 ; no_of_squares = ( N - K + 1 ) * ( N - K + 1 ) ; return no_of_squares ; } int main ( ) { int N = 5 ; int K = 3 ; cout << No_of_squares ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int No_of_cubes ( int N , int K ) { int No = 0 ; No = ( N - K + 1 ) ; No = pow ( No , 3 ) ; return No ; } int main ( ) { int N = 5 ; int K = 2 ; cout << No_of_cubes ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int No_of_rectangles ( int L , int B , int l , int b ) { if ( ( l > L ) || ( b > B ) ) { return -1 ; } else { return ( L - l + 1 ) * ( B - b + 1 ) ; } } int main ( ) { int L = 5 , B = 3 ; int l = 4 , b = 1 ; cout << No_of_rectangles ( L , B , l , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkTriangle ( int x , int y , int z ) { if ( x == y && y == z ) cout << " Equilateral ▁ Triangle " ; else if ( x == y y == z z == x ) cout << " Isosceles ▁ Triangle " ; else cout << " Scalene ▁ Triangle " ; } int main ( ) { int x = 8 , y = 7 , z = 9 ; checkTriangle ( x , y , z ) ; }
#include <cstdlib> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void findVertices ( int x1 , int y1 , int x2 , int y2 ) { if ( x1 == x2 ) { cout << ( x1 + y2 - y1 ) << " , ▁ " << y1 << endl ; cout << ( x2 + y2 - y1 ) << " , ▁ " << y2 ; } else if ( y1 == y2 ) { cout << x1 << " , ▁ " << ( y1 + x2 - x1 ) << endl ; cout << x2 << " , ▁ " << ( y2 + x2 - x1 ) ; } else if ( abs ( x2 - x1 ) == abs ( y2 - y1 ) ) { cout << x1 << " , ▁ " << y2 << endl ; cout << x2 << " , ▁ " << y1 ; } else cout << " - 1" ; } int main ( ) { int x1 = 1 , y1 = 2 ; int x2 = 3 , y2 = 4 ; findVertices ( x1 , y1 , x2 , y2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateTriangles ( int sides [ ] ) { double count = pow ( sides [ 0 ] + sides [ 1 ] + sides [ 2 ] , 2 ) ; count -= pow ( sides [ 0 ] , 2 ) ; count -= pow ( sides [ 2 ] , 2 ) ; count -= pow ( sides [ 4 ] , 2 ) ; return ( int ) ( count ) ; } int main ( ) { int sides [ ] = { 1 , 1 , 1 , 1 , 1 , 1 } ; cout << ( calculateTriangles ( sides ) ) << endl ; int sides1 [ ] = { 2 , 2 , 1 , 3 , 1 , 2 } ; cout << ( calculateTriangles ( sides1 ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Length_Diagonal ( int a , int b , int d ) { float diagonal = sqrt ( 2 * ( ( a * a ) + ( b * b ) ) - ( d * d ) ) ; return diagonal ; } int main ( ) { int A = 10 ; int B = 30 ; int D = 20 ; float ans = Length_Diagonal ( A , B , D ) ; printf ( " % 0.1f " , ans ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < float > Diagonals ( int a , int b , int c , int d ) { vector < float > ans ; ans . push_back ( sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * d ) + ( b * c ) ) / ( ( a * b ) + ( c * d ) ) ) ) ; ans . push_back ( sqrt ( ( ( a * c ) + ( b * d ) ) * ( ( a * b ) + ( c * d ) ) / ( ( a * d ) + ( b * c ) ) ) ) ; return ans ; } int main ( ) { int A = 10 ; int B = 15 ; int C = 20 ; int D = 25 ; vector < float > ans = Diagonals ( A , B , C , D ) ; printf ( " % .2f ▁ % .2f " , ( ans [ 0 ] ) + .01 , ans [ 1 ] + .01 ) ; }
#include <iostream> NEW_LINE using namespace std ; int det ( int d [ ] [ 3 ] ) { int Sum = d [ 0 ] [ 0 ] * ( ( d [ 1 ] [ 1 ] * d [ 2 ] [ 2 ] ) - ( d [ 2 ] [ 1 ] * d [ 1 ] [ 2 ] ) ) ; Sum -= d [ 0 ] [ 1 ] * ( ( d [ 1 ] [ 0 ] * d [ 2 ] [ 2 ] ) - ( d [ 1 ] [ 2 ] * d [ 2 ] [ 0 ] ) ) ; Sum += d [ 0 ] [ 2 ] * ( ( d [ 0 ] [ 1 ] * d [ 1 ] [ 2 ] ) - ( d [ 0 ] [ 2 ] * d [ 1 ] [ 1 ] ) ) ; return Sum ; } int main ( ) { int x1 = -3 , y1 = 1 , z1 = 5 ; int a1 = -3 , b1 = 1 , c1 = 5 ; int x2 = -1 , y2 = 2 , z2 = 5 ; int a2 = -1 , b2 = 2 , c2 = 5 ; int det_list [ 3 ] [ 3 ] = { { x2 - x1 , y2 - y1 , z2 - z1 } , { a1 , b1 , c1 } , { a2 , b2 , c2 } } ; if ( det ( det_list ) == 0 ) { cout << " Lines ▁ are ▁ coplanar " << endl ; } else { cout << " Lines ▁ are ▁ non ▁ coplanar " << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define PI  3.141592653589 NEW_LINE double uniform ( ) { return ( double ) rand ( ) / RAND_MAX ; } vector < pair < double , double > > randPoint ( int r , int x , int y , int n ) { vector < pair < double , double > > res ; for ( int i = 0 ; i < n ; i ++ ) { double theta = 2 * PI * uniform ( ) ; double len = sqrt ( uniform ( ) ) * r ; res . push_back ( { x + len * cos ( theta ) , y + len * sin ( theta ) } ) ; } return res ; } void printVector ( vector < pair < double , double > > A ) { for ( pair < double , double > P : A ) { printf ( " ( % . 2lf , ▁ % .2lf ) STRNEWLINE " , P . first , P . second ) ; } } int main ( ) { int R = 12 ; int X = 3 ; int Y = 3 ; int N = 5 ; printVector ( randPoint ( R , X , Y , N ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void checkValidPolygon ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 180 * ( N - 2 ) ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int N = 3 ; int arr [ ] = { 60 , 60 , 60 } ; checkValidPolygon ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimalSquareSide ( int a , int b ) { if ( a == b ) { return 2 * a ; } if ( a != b ) { if ( a > b ) { int newB = b + b ; int diff = abs ( newB - a ) ; if ( newB < a ) { b = newB + diff ; if ( a == b ) return a ; return 0 ; } else { a = a + diff ; if ( a == newB ) return a ; return 0 ; } } else { int newA = a + a ; int diff = abs ( newA - b ) ; if ( newA < b ) { a = diff + newA ; if ( a == b ) return a ; return 0 ; } else { b = b + diff ; if ( b == newA ) return b ; return 0 ; } } } } int main ( ) { int H , W ; H = 3 , W = 1 ; cout << minimalSquareSide ( H , W ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1001 NEW_LINE bool arr [ MAX ] [ MAX ] ; void updateArray ( int x1 , int y1 , int x2 , int y2 ) { for ( int i = x1 ; i < x2 ; i ++ ) { for ( int j = y1 ; j < y2 ; j ++ ) { arr [ i ] [ j ] = true ; } } } int findAreaCovered ( ) { int area = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { if ( arr [ i ] [ j ] == true ) { area ++ ; } } } return area ; } int main ( ) { int N = 3 ; vector < vector < int > > A = { { 1 , 3 , 4 , 5 } , { 3 , 1 , 7 , 4 } , { 5 , 3 , 8 , 6 } } ; for ( int i = 0 ; i < N ; i ++ ) { updateArray ( A [ i ] [ 0 ] , A [ i ] [ 1 ] , A [ i ] [ 2 ] , A [ i ] [ 3 ] ) ; } int area = findAreaCovered ( ) ; cout << area ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findEquation ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int d , int e , int f ) { double a = x2 - x1 ; double b = y2 - y1 ; double c = z2 - z1 ; int A = ( b * f - c * e ) ; int B = ( a * f - c * d ) ; int C = ( a * e - b * d ) ; int D = - ( A * d - B * e + C * f ) ; cout << A << " x ▁ + ▁ " << B << " y ▁ + ▁ " << C << " z ▁ + ▁ " << D << " = ▁ 0" ; } int main ( ) { int x1 = 2 , y1 = 3 , z1 = 5 ; int x2 = 6 , y2 = 7 , z2 = 8 ; int a = 11 , b = 23 , c = 10 ; findEquation ( x1 , y1 , z1 , x2 , y2 , z2 , a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float median ( int a , int b , int c ) { float n = sqrt ( 2 * b * b + 2 * c * c - a * a ) / 2 ; return n ; } int main ( ) { int a , b , c ; a = 4 ; b = 3 ; c = 5 ; float ans = median ( a , b , c ) ; cout << fixed << setprecision ( 2 ) << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSide ( float a , float B , float C ) { float A = 180 - C - B ; float radA = M_PI * ( A / 180 ) ; float radB = M_PI * ( B / 180 ) ; float radC = M_PI * ( C / 180 ) ; float b = a / sin ( radA ) * sin ( radB ) ; float c = a / sin ( radA ) * sin ( radC ) ; cout << fixed << setprecision ( 15 ) << b << " ▁ " ; cout << fixed << setprecision ( 15 ) << c ; } int main ( ) { int a = 12 , B = 60 , C = 30 ; findSide ( a , B , C ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const double pi = acos ( -1.0 ) ; double nGon ( int N ) { double proAngleVar ; if ( N % 4 == 0 ) { proAngleVar = pi * ( 180.0 / N ) / 180 ; } else { proAngleVar = pi * ( 180.0 / ( 2 * N ) ) / 180 ; } double negX = 1.0e+99 , posX = -1.0e+99 , negY = 1.0e+99 , posY = -1.0e+99 ; for ( int j = 0 ; j < N ; ++ j ) { double px = cos ( 2 * pi * j / N + proAngleVar ) ; double py = sin ( 2 * pi * j / N + proAngleVar ) ; negX = min ( negX , px ) ; posX = max ( posX , px ) ; negY = min ( negY , py ) ; posY = max ( posY , py ) ; } double opt2 = max ( posX - negX , posY - negY ) ; return ( double ) opt2 / sin ( pi / N ) / 2 ; } int main ( ) { int N = 10 ; cout << nGon ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int heptacontagonNum ( int n ) { return ( 68 * n * n - 66 * n ) / 2 ; } int main ( ) { int N = 3 ; cout << "3rd ▁ heptacontagon ▁ Number ▁ is ▁ = ▁ " << heptacontagonNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isicositetragonal ( int N ) { float n = ( 10 + sqrt ( 44 * N + 100 ) ) / 22 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int i = 24 ; if ( isicositetragonal ( i ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isicosihenagonal ( int N ) { float n = ( 17 + sqrt ( 152 * N + 289 ) ) / 38 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int i = 21 ; if ( isicosihenagonal ( i ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isicositrigonal ( int N ) { float n = ( 19 + sqrt ( 168 * N + 361 ) ) / 42 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int i = 23 ; if ( isicositrigonal ( i ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const long long mod = 1000000007 ; const int MAXN = 1001 ; long long factorial [ MAXN ] , inverse [ MAXN ] ; long long power ( long long a , long long b ) { long long res = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) { res = ( res * a ) % mod ; } a = ( a * a ) % mod ; b >>= 1 ; } return res ; } long long nCk ( int n , int k ) { if ( k < 0 k > n ) { return 0 ; } long long ans = factorial [ n ] ; ans = ( ans * inverse [ n - k ] ) % mod ; ans = ( ans * inverse [ k ] ) % mod ; return ans ; } void numberOfWays ( vector < pair < int , int > > lines , int K , int N ) { sort ( lines . begin ( ) , lines . end ( ) ) ; long long total_case = nCk ( N , K ) ; multiset < int > m ; for ( int i = 0 ; i < N ; i ++ ) { while ( ! m . empty ( ) && ( * m . begin ( ) < lines [ i ] . first ) ) { m . erase ( m . begin ( ) ) ; } total_case -= nCk ( m . size ( ) , K - 1 ) ; total_case += mod ; total_case %= mod ; m . insert ( lines [ i ] . second ) ; } cout << total_case << endl ; } void preCompute ( ) { long long fact = 1 ; factorial [ 0 ] = 1 ; inverse [ 0 ] = 1 ; for ( int i = 1 ; i < MAXN ; i ++ ) { fact = ( fact * i ) % mod ; factorial [ i ] = fact ; inverse [ i ] = power ( factorial [ i ] , mod - 2 ) ; } } int main ( ) { int N = 3 , K = 2 ; vector < pair < int , int > > lines ; preCompute ( ) ; lines . push_back ( { 1 , 3 } ) ; lines . push_back ( { 4 , 5 } ) ; lines . push_back ( { 5 , 7 } ) ; numberOfWays ( lines , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Icositetragonal_num ( int n ) { return ( 22 * n * n - 20 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << Icositetragonal_num ( n ) << endl ; n = 10 ; cout << Icositetragonal_num ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkTriangle ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ; if ( a == 0 ) cout << " No " ; else cout << " Yes " ; } int main ( ) { int x1 = 1 , x2 = 2 , x3 = 3 , y1 = 1 , y2 = 2 , y3 = 3 ; checkTriangle ( x1 , y1 , x2 , y2 , x3 , y3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numTrip ( vector < pair < int , int > > & points ) { int res = 0 ; for ( int i = 0 ; i < points . size ( ) ; ++ i ) { unordered_map < long , int > map ( points . size ( ) ) ; for ( int j = 0 ; j < points . size ( ) ; ++ j ) { if ( j == i ) continue ; int dy = points [ i ] . second - points [ j ] . second ; int dx = points [ i ] . first - points [ j ] . first ; int key = dy * dy ; key += dx * dx ; map [ key ] ++ ; } for ( auto & p : map ) res += p . second * ( p . second - 1 ) ; } return res ; } int main ( ) { vector < pair < int , int > > mat = { { 0 , 0 } , { 1 , 0 } , { 2 , 0 } } ; cout << numTrip ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double area_of_circle ( int m , int n ) { int square_of_radius = ( m * n ) / 4 ; double area = ( 3.141 * square_of_radius ) ; return area ; } int main ( ) { int n = 10 ; int m = 30 ; cout << ( area_of_circle ( m , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int NotParallel ( int p [ ] [ 2 ] , int n ) { map < int , int > x_axis , y_axis ; for ( int i = 0 ; i < n ; i ++ ) { x_axis [ p [ i ] [ 0 ] ] ++ ; y_axis [ p [ i ] [ 1 ] ] ++ ; } int total = ( n * ( n - 1 ) ) / 2 ; for ( auto i : x_axis ) { int c = i . second ; total -= ( c * ( c - 1 ) ) / 2 ; } for ( auto i : y_axis ) { int c = i . second ; total -= ( c * ( c - 1 ) ) / 2 ; } return total ; } int main ( ) { int p [ ] [ 2 ] = { { 1 , 2 } , { 1 , 5 } , { 1 , 15 } , { 2 , 10 } } ; int n = sizeof ( p ) / sizeof ( p [ 0 ] ) ; cout << NotParallel ( p , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( int n , int m ) { if ( m % n == 0 ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; } int main ( ) { int n = 5 ; int m = 10 ; check ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findModulo ( string s ) { int l = s . length ( ) ; int i , modulus = 0 ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; } else { i = s . find ( ' - ' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - 1 ) ; int x = stoi ( real ) ; int y = stoi ( imaginary ) ; cout << sqrt ( x * x + y * y ) << " STRNEWLINE " ; } int main ( ) { string s = "3 + 4i " ; findModulo ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void disp ( int row_no , int block ) { cout << row_no * block ; } int row ( int ht , int h ) { return ht / h ; } void calculate ( int l , int w , int h , int a , int ht ) { int no_block = ( 4 * a ) / l ; int row_no ; if ( h < w ) row_no = row ( ht , w ) ; else row_no = row ( ht , h ) ; disp ( row_no , no_block ) ; } int main ( ) { int l = 50 , w = 20 , h = 35 ; int a = 700 ; int ht = 140 ; calculate ( l , w , h , a , ht ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double solve ( int s ) { double area = ( 1.732 * pow ( s , 2 ) ) / 8 ; return area ; } int main ( ) { int n = 14 ; cout << solve ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float circlearea ( float R ) { if ( R < 0 ) return -1 ; float a = 3.14 * R * R / 4 ; return a ; } int main ( ) { float R = 2 ; cout << circlearea ( R ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float find_Area ( float a ) { float R = a * ( 2.0 - sqrt ( 2 ) ) ; float area = 3.14 * R * R / 2.0 ; return area ; } int main ( ) { float a = 4 ; cout << " ▁ Area ▁ of ▁ semicircle ▁ = ▁ " << find_Area ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int times ( int steps [ ] , int n ) { int current_level = 0 ; int previous_level = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { previous_level = current_level ; current_level = current_level + steps [ i ] ; if ( ( previous_level < 0 && current_level >= 0 ) || ( previous_level > 0 && current_level <= 0 ) ) { count ++ ; } } return count ; } int main ( ) { int steps [ 12 ] = { 1 , -1 , 0 , 0 , 1 , 1 , -3 , 2 } ; int n = sizeof ( steps ) / sizeof ( int ) ; cout << times ( steps , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float * XandYandZintercept ( float A , float B , float C , float D ) { static float rslt [ 3 ] ; float x = - D / A ; float y = - D / B ; float z = - D / C ; rslt [ 0 ] = x ; rslt [ 1 ] = y ; rslt [ 2 ] = z ; return rslt ; } void equation_plane ( int p [ ] , int q [ ] , int r [ ] ) { int x1 = p [ 0 ] ; int y1 = p [ 1 ] ; int z1 = p [ 2 ] ; int x2 = q [ 0 ] ; int y2 = q [ 1 ] ; int z2 = q [ 2 ] ; int x3 = r [ 0 ] ; int y3 = r [ 1 ] ; int z3 = r [ 2 ] ; int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int A = b1 * c2 - b2 * c1 ; int B = a2 * c1 - a1 * c2 ; int C = a1 * b2 - b1 * a2 ; int D = ( - A * x1 - B * y1 - C * z1 ) ; float * rslt = XandYandZintercept ( A , B , C , D ) ; for ( int i = 0 ; i < 3 ; i ++ ) { cout << rslt [ i ] << " ▁ " ; } } int main ( ) { int x1 = -1 ; int y1 = 2 ; int z1 = 1 ; int x2 = 0 ; int y2 = -3 ; int z2 = 2 ; int x3 = 1 ; int y3 = 1 ; int z3 = -4 ; int p [ 3 ] = { x1 , y1 , z1 } ; int q [ 3 ] = { x2 , y2 , z2 } ; int r [ 3 ] = { x3 , y3 , z3 } ; equation_plane ( p , q , r ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < pair < int , int > > FindPoints ( int n ) { vector < pair < int , int > > v ; v . push_back ( { 0 , 0 } ) ; v . push_back ( { 0 , n } ) ; v . push_back ( { n , 0 } ) ; v . push_back ( { n , n } ) ; if ( n % 2 == 0 ) v . push_back ( { n / 2 , n / 2 } ) ; return v ; } int main ( ) { int N = 8 ; vector < pair < int , int > > v = FindPoints ( N ) ; for ( auto i : v ) { cout << " ( " << i . first << " , ▁ " << i . second << " ) ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; } int main ( ) { int n = 5 ; cout << sumOfInternalAngles ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntWays ( int n ) { if ( n % 2 == 1 ) { return 0 ; } else { return ( n - 2 ) / 4 ; } } int main ( ) { int n = 18 ; cout << cntWays ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int noOfTriangles ( int n ) { int y = 4 * n ; return ( ( y * ( y - 2 ) * ( y - 1 ) ) - ( 4 * n * ( n - 2 ) * ( n - 1 ) ) ) / 6 ; } int main ( ) { int n = 1 ; cout << noOfTriangles ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool orthogonality ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int dsquare = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; if ( dsquare == r1 * r1 + r2 * r2 ) return true ; else return false ; } int main ( ) { int x1 = 4 , y1 = 3 ; int x2 = 0 , y2 = 1 ; int r1 = 2 , r2 = 4 ; bool f = orthogonality ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( f ) cout << " Given ▁ circles ▁ are " << " ▁ orthogonal . " ; else cout << " Given ▁ circles ▁ are " << " ▁ not ▁ orthogonal . " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dx [ ] = { -1 , 0 , 1 , 0 } ; int dy [ ] = { 0 , 1 , 0 , -1 } ; int ifRight ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int a = ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ; int b = ( ( x1 - x3 ) * ( x1 - x3 ) ) + ( ( y1 - y3 ) * ( y1 - y3 ) ) ; int c = ( ( x2 - x3 ) * ( x2 - x3 ) ) + ( ( y2 - y3 ) * ( y2 - y3 ) ) ; if ( ( a == ( b + c ) && a != 0 && b != 0 && c != 0 ) || ( b == ( a + c ) && a != 0 && b != 0 && c != 0 ) || ( c == ( a + b ) && a != 0 && b != 0 && c != 0 ) ) { return 1 ; } return 0 ; } void isValidCombination ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { int x , y ; bool possible = 0 ; if ( ifRight ( x1 , y1 , x2 , y2 , x3 , y3 ) ) { cout << " ALREADY ▁ RIGHT ▁ ANGLED " ; return ; } else { for ( int i = 0 ; i < 4 ; i ++ ) { x = dx [ i ] + x1 ; y = dy [ i ] + y1 ; if ( ifRight ( x , y , x2 , y2 , x3 , y3 ) ) { cout << " POSSIBLE " ; return ; } x = dx [ i ] + x2 ; y = dy [ i ] + y2 ; if ( ifRight ( x1 , y1 , x , y , x3 , y3 ) ) { cout << " POSSIBLE " ; return ; } x = dx [ i ] + x3 ; y = dy [ i ] + y3 ; if ( ifRight ( x1 , y1 , x2 , y2 , x , y ) ) { cout << " POSSIBLE " ; return ; } } } if ( ! possible ) cout << " NOT ▁ POSSIBLE " << endl ; } int main ( ) { int x1 = -49 , y1 = 0 ; int x2 = 0 , y2 = 50 ; int x3 = 0 , y3 = -50 ; isValidCombination ( x1 , y1 , x2 , y2 , x3 , y3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <cmath> NEW_LINE using namespace std ; double area_of_regular_polygon ( double n , double len ) { double P = ( len * n ) ; double A = len / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; double area = ( P * A ) / 2 ; return area ; } double area_of_triangle_inscribed ( double n , double len ) { double area = area_of_regular_polygon ( n , len ) ; double triangle = area / n ; double ins_tri = ( triangle * 3 ) ; return ins_tri ; } int main ( ) { double n = 6 , len = 10 ; cout << area_of_triangle_inscribed ( n , len ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxRegions ( int n ) { int num ; num = n * ( n + 1 ) / 2 + 1 ; cout << num ; } int main ( ) { int n = 10 ; maxRegions ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float diagonal_length ( float a ) { float L ; L = a * sqrt ( 3 ) ; return L ; } int main ( ) { float a = 5 ; cout << diagonal_length ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int concentric_Hexagon ( int n ) { return 3 * pow ( n , 2 ) / 2 ; } int main ( ) { int n = 3 ; cout << concentric_Hexagon ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const double PI = 3.14 ; double find_area ( int r , int d ) { double R = d / PI ; R += pow ( r , 2 ) ; R = sqrt ( R ) ; double area = PI * pow ( R , 2 ) ; return area ; } int main ( ) { int r = 4 , d = 5 ; cout << find_area ( r , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double calculate_angle ( double n ) { double total_angle = 360 ; return total_angle / n ; } int main ( ) { double N = 5 ; cout << calculate_angle ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float areaOfKite ( int d1 , int d2 ) { float area = ( d1 * d2 ) / 2 ; return area ; } int main ( ) { int d1 = 4 , d2 = 6 ; cout << " Area ▁ of ▁ Kite ▁ = ▁ " << areaOfKite ( d1 , d2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define PI  3.14159 / 180 NEW_LINE using namespace std ; float areaOfKite ( int a , int b , double angle ) { angle = angle * PI ; double area = a * b * sin ( angle ) ; return area ; } int main ( ) { int a = 4 , b = 7 , angle = 78 ; cout << " Area ▁ of ▁ Kite ▁ = ▁ " << areaOfKite ( a , b , angle ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; float angleOncirCumference ( float z ) { return ( z / 2 ) ; } int main ( ) { float angle = 65 ; float z = angleOncirCumference ( angle ) ; cout << " The ▁ angle ▁ is ▁ " << ( z ) << " ▁ degrees " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintMaxMinValue ( double a , double b , double c ) { double secondPart = c * 1.0 - ( b * b / ( 4.0 * a ) ) ; if ( a > 0 ) { cout << " Maxvalue ▁ = ▁ " << " Infinity STRNEWLINE " ; cout << " Minvalue ▁ = ▁ " << secondPart ; } else if ( a < 0 ) { cout << " Maxvalue ▁ = ▁ " << secondPart << " STRNEWLINE " ; cout << " Minvalue ▁ = ▁ " << " - Infinity " ; } else { cout << " Not ▁ a ▁ quadratic ▁ function STRNEWLINE " ; } } int main ( ) { double a = -1 , b = 3 , c = -2 ; PrintMaxMinValue ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void newvol ( double x ) { cout << " percentage ▁ increase ▁ " << " in ▁ the ▁ volume ▁ of ▁ the ▁ cylinder ▁ is ▁ " << x << " % " << endl ; } int main ( ) { double x = 10 ; newvol ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void radius ( double n , double d ) { cout << " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " << d / ( ( n - 1 ) * sqrt ( 2 ) ) << endl ; } int main ( ) { double d = 42 , n = 4 ; radius ( n , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; double innerCirclearea ( double radius ) { if ( radius < 0 ) { return -1 ; } double r = radius / 2 ; double Area = ( 3.14 * pow ( r , 2 ) ) ; return Area ; } int main ( ) { double radius = 4 ; cout << ( " Area ▁ of ▁ circle ▁ c2 ▁ = ▁ " , innerCirclearea ( radius ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define PI  3.14159 NEW_LINE using namespace std ; double areaOfTriangle ( float d ) { float c = 1.618 * d ; float s = ( d + c + c ) / 2 ; double area = sqrt ( s * ( s - c ) * ( s - c ) * ( s - d ) ) ; return 5 * area ; } double areaOfRegPentagon ( float d ) { double cal = 4 * tan ( PI / 5 ) ; double area = ( 5 * d * d ) / cal ; return area ; } double areaOfPentagram ( float d ) { return areaOfRegPentagon ( d ) + areaOfTriangle ( d ) ; } int main ( ) { float d = 5 ; cout << areaOfPentagram ( d ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void angleequichord ( int z ) { cout << " The ▁ angle ▁ subtended ▁ at ▁ the ▁ center ▁ is ▁ " << z << " ▁ degrees " << endl ; } int main ( ) { int z = 48 ; angleequichord ( z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengequichord ( int z ) { cout << " The ▁ distance ▁ between ▁ the ▁ " << " chord ▁ and ▁ the ▁ center ▁ is ▁ " << z << endl ; } int main ( ) { int z = 48 ; lengequichord ( z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengperpbisect ( double r1 , double r2 ) { double z = 2 * sqrt ( ( r1 * r1 ) - ( ( r1 - r2 ) * ( r1 - r2 ) / 4 ) ) ; cout << " The ▁ length ▁ of ▁ the ▁ " << " perpendicular ▁ bisector ▁ is ▁ " << z << endl ; } int main ( ) { double r1 = 5 , r2 = 3 ; lengperpbisect ( r1 , r2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void anglequichord ( int z ) { cout << " The ▁ angle ▁ is ▁ " << z << " ▁ degrees " << endl ; } int main ( ) { int z = 48 ; anglequichord ( z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void distcenter ( int r1 , int r2 , int x ) { int z = sqrt ( ( r1 * r1 ) - ( x / 2 * x / 2 ) ) + sqrt ( ( r2 * r2 ) - ( x / 2 * x / 2 ) ) ; cout << " distance ▁ between ▁ the " << " ▁ centers ▁ is ▁ " << z << endl ; } int main ( ) { int r1 = 24 , r2 = 37 , x = 40 ; distcenter ( r1 , r2 , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void anglechordtang ( int z ) { cout << " The ▁ angle ▁ between ▁ tangent " << " ▁ and ▁ the ▁ chord ▁ is ▁ " << z << " ▁ degrees " << endl ; } int main ( ) { int z = 48 ; anglechordtang ( z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct TreeNode { int val ; TreeNode * left , * right ; TreeNode ( int x = 0 ) { val = x ; left = NULL ; right = NULL ; } } ; int findSum ( TreeNode * root ) { queue < TreeNode * > que ; que . push ( root ) ; int ans = 0 ; while ( que . size ( ) ) { int leaf = 0 ; int nonleaf = 0 ; int length = que . size ( ) ; while ( length ) { auto temp = que . front ( ) ; que . pop ( ) ; if ( ! temp -> left && ! temp -> right ) leaf += temp -> val ; else nonleaf += temp -> val ; if ( temp -> left ) que . push ( temp -> left ) ; if ( temp -> right ) que . push ( temp -> right ) ; length -= 1 ; } ans += leaf & nonleaf ; } return ans ; } int main ( ) { TreeNode * root = new TreeNode ( 5 ) ; root -> left = new TreeNode ( 3 ) ; root -> right = new TreeNode ( 9 ) ; root -> left -> left = new TreeNode ( 6 ) ; root -> left -> right = new TreeNode ( 4 ) ; root -> left -> left -> right = new TreeNode ( 7 ) ; cout << findSum ( root ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinTime ( int * a , int * b , int n , int m ) { int ans = INT_MAX ; int prefix_a [ 10 ] = { 0 } ; int prefix_b [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { prefix_a [ a [ i ] ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { prefix_b [ b [ i ] ] ++ ; } for ( int i = 1 ; i <= 9 ; i ++ ) { prefix_a [ i ] += prefix_a [ i - 1 ] ; } for ( int i = 1 ; i <= 9 ; i ++ ) { prefix_b [ i ] += prefix_b [ i - 1 ] ; } for ( int i = 0 ; i <= 9 ; i ++ ) { ans = min ( ans , prefix_a [ i ] + m - prefix_b [ i ] ) ; ans = min ( ans , n - prefix_a [ i ] + prefix_b [ i ] ) ; } cout << ans ; } int main ( ) { int A [ ] = { 0 , 0 , 1 , 3 , 3 } ; int B [ ] = { 2 , 0 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int M = sizeof ( B ) / sizeof ( B [ 0 ] ) ; MinTime ( A , B , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findReverse ( int N ) { int rev = 0 ; while ( N > 0 ) { rev <<= 1 ; if ( N & 1 == 1 ) rev ^= 1 ; N >>= 1 ; } return rev ; } void countElements ( int arr [ ] , int N ) { vector < int > ans ; for ( int i = 0 ; i < N ; i ++ ) { ans . push_back ( findReverse ( arr [ i ] ) ) ; } unordered_map < int , int > cnt ; for ( int i = 0 ; i < N ; i ++ ) { cnt [ arr [ i ] ] = 1 ; } int count = 0 ; for ( auto i : ans ) { if ( cnt [ i ] ) count ++ ; } cout << count << endl ; } int main ( ) { int arr [ ] = { 1 , 30 , 3 , 8 , 12 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countElements ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime [ 1000005 ] ; void SieveOfEratosthenes ( int N ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= N ; i += p ) prime [ i ] = false ; } } } void checkElementsOnDiagonal ( vector < vector < int > > M , int N ) { int flag = 1 ; SieveOfEratosthenes ( 1000000 ) ; for ( int i = 0 ; i < N ; i ++ ) { flag &= ( prime [ M [ i ] [ i ] ] && prime [ M [ i ] [ N - 1 - i ] ] ) ; } if ( flag ) cout << " Yes " << endl ; else cout << " No " ; } int main ( ) { vector < vector < int > > M = { { 1 , 2 , 3 , 13 } , { 5 , 3 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 7 } } ; int N = M . size ( ) ; checkElementsOnDiagonal ( M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > circularPermutation ( int n , int start ) { vector < int > res = { 0 } ; vector < int > ret ; int index = -1 ; for ( int k = 0 , add = 1 << k ; k < n ; k ++ , add = 1 << k ) { for ( int i = res . size ( ) - 1 ; i >= 0 ; i -- ) { if ( res [ i ] + add == start ) index = res . size ( ) ; res . push_back ( res [ i ] + add ) ; } } if ( start == 0 ) return res ; while ( ret . size ( ) < res . size ( ) ) { ret . push_back ( res [ index ] ) ; index = ( index + 1 ) % res . size ( ) ; } return ret ; } int main ( ) { int N = 2 , S = 3 ; vector < int > print = circularPermutation ( N , S ) ; cout << " [ " ; for ( int i = 0 ; i < print . size ( ) - 1 ; i ++ ) { cout << print [ i ] << " , ▁ " ; } cout << print [ print . size ( ) - 1 ] << " ] " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canMakeEqual ( int arr1 [ ] , int arr2 [ ] , int N ) { int count = 0 ; int arr1_one = 0 , arr1_zero = 0 ; int arr2_one = 0 , arr2_zero = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr1 [ i ] == 1 ) { arr1_one ++ ; } else if ( arr1 [ i ] == 0 ) { arr1_zero ++ ; } if ( arr2 [ i ] == 1 ) { arr2_one ++ ; } else if ( arr2 [ i ] == 0 ) { arr2_zero ++ ; } } if ( arr1_one != arr2_one arr1_zero != arr2_zero ) { cout << " No " ; return ; } for ( int i = 0 ; i < N ; i ++ ) { count = count + ( arr1 [ i ] - arr2 [ i ] ) ; if ( count < 0 ) { cout << " No " ; return ; } } cout << " Yes " ; } int main ( ) { int arr1 [ ] = { 0 , 1 , 1 , 0 } ; int arr2 [ ] = { 0 , 0 , 1 , 1 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; canMakeEqual ( arr1 , arr2 , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checksubarrayExist1_N ( int arr [ ] , int N ) { unordered_map < int , int > pos ; for ( int i = 0 ; i < N ; i ++ ) { pos [ arr [ i ] ] = i ; } set < int > st ; for ( int i = 1 ; i <= N ; i ++ ) { st . insert ( pos [ i ] ) ; int Min = * ( st . begin ( ) ) ; int Max = * ( st . rbegin ( ) ) ; if ( Max - Min + 1 == i ) { cout << " True ▁ " ; } else { cout << " False ▁ " ; } } } int main ( ) { int arr [ ] = { 1 , 4 , 3 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checksubarrayExist1_N ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumFib ( int N ) { long num = ( long ) round ( pow ( ( sqrt ( 5 ) + 1 ) / 2.0 , N + 2 ) / sqrt ( 5 ) ) ; cout << ( num - 1 ) ; } int main ( ) { int N = 3 ; sumFib ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumFib ( int N ) { double num = ( 1 - sqrt ( 5 ) ) / 2 ; long val = round ( abs ( 1 / ( pow ( num , N + 2 ) + pow ( num , N + 1 ) + pow ( num , N ) + pow ( num , N - 1 ) ) ) - 1 ) ; cout << val ; } int main ( ) { int N = 3 ; sumFib ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperations ( int arr [ ] , int n , int k ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] ++ ; } int ans = 0 ; while ( mp [ k ] < n ) { for ( int i = 1 ; i <= k - 1 ; i ++ ) { if ( mp [ i ] ) { mp [ i ] -- ; mp [ i + 1 ] ++ ; if ( mp [ i + 1 ] == 1 ) { i ++ ; } } } ans ++ ; } cout << ans ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 4 } ; int K = 5 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minOperations ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void poorPigs ( int buckets , int minutesToDie , int minutesToTest ) { cout << ceil ( log ( buckets ) / log ( ( minutesToTest / minutesToDie ) + 1 ) ) ; } int main ( ) { int N = 1000 , M = 15 , P = 60 ; poorPigs ( N , M , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxProduct ( int arr [ ] , int N ) { int max_product = INT_MIN ; int prefix_sum = 0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { prefix_sum += arr [ i ] ; int X = prefix_sum ; int Y = sum - prefix_sum ; max_product = max ( max_product , X * Y ) ; } cout << max_product ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 6 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxProduct ( arr , N ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int findMask ( int K ) { int mask = 1 ; while ( ( K & mask ) == 0 ) { mask = mask << 1 ; } return mask ; } void sameRightSetBitPos ( int arr [ ] , int N , int K ) { int mask = findMask ( K ) ; int pos = ( K & mask ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & mask ) == pos ) cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 3 , 4 , 6 , 7 , 9 , 12 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 7 ; sameRightSetBitPos ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE int maxSum ( int arr [ ] , int N , int K ) { if ( N < K ) { cout << " Invalid " ; return -1 ; } int CountDistinct [ MAX + 1 ] ; bool prime [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( long long int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( long long int j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } int Maxarr_sum = 0 , DistPrimeSum = 0 ; for ( int i = 0 ; i < K ; i ++ ) { Maxarr_sum += arr [ i ] ; DistPrimeSum += CountDistinct [ arr [ i ] ] ; } int curr_sum = DistPrimeSum ; int curr_arrSum = Maxarr_sum ; for ( int i = K ; i < N ; i ++ ) { curr_sum += CountDistinct [ arr [ i ] ] - CountDistinct [ arr [ i - K ] ] ; curr_arrSum += arr [ i ] - arr [ i - K ] ; if ( curr_sum > DistPrimeSum ) { DistPrimeSum = curr_sum ; Maxarr_sum = curr_arrSum ; } else if ( curr_sum == DistPrimeSum ) { Maxarr_sum = max ( curr_arrSum , Maxarr_sum ) ; } } cout << Maxarr_sum ; } int main ( ) { int arr [ ] = { 1 , 4 , 2 , 10 , 3 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxSum ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( sqrt ( x ) ) ; i ++ ) { if ( x == i * ( i + 1 ) ) { return true ; } } return false ; } void countPronic ( int A , int B ) { int count = 0 ; for ( int i = A ; i <= B ; i ++ ) { if ( checkPronic ( i ) ) { count ++ ; } } cout << count ; } int main ( ) { int A = 3 , B = 20 ; countPronic ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void oddDivisors ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int powerOfTwo = 2 ; int count = 0 ; while ( powerOfTwo <= arr [ i ] ) { count ++ ; powerOfTwo = 2 * powerOfTwo ; } cout << count << " ▁ " ; } return ; } int main ( ) { int arr [ ] = { 15 , 16 , 20 , 35 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; oddDivisors ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void productExceptSelf ( int arr [ ] , int N ) { int product = 1 ; int z = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] ) product *= arr [ i ] ; z += ( arr [ i ] == 0 ) ; } int a = abs ( product ) , b ; for ( int i = 0 ; i < N ; i ++ ) { if ( z == 1 ) { if ( arr [ i ] ) arr [ i ] = 0 ; else arr [ i ] = product ; continue ; } else if ( z > 1 ) { arr [ i ] = 0 ; continue ; } int b = abs ( arr [ i ] ) ; int curr = round ( exp ( log ( a ) - log ( b ) ) ) ; if ( arr [ i ] < 0 && product < 0 ) arr [ i ] = curr ; else if ( arr [ i ] > 0 && product > 0 ) arr [ i ] = curr ; else arr [ i ] = -1 * curr ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 10 , 3 , 5 , 6 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; productExceptSelf ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void highestPowerOfTwo ( int num ) { string s = to_string ( num ) ; for ( int i = 0 ; i < ( int ) s . size ( ) ; i ++ ) { if ( s [ i ] == '0' ) { cout << "0" ; continue ; } int lg = log2 ( int ( s [ i ] ) - 48 ) ; int p = pow ( 2 , lg ) ; cout << char ( p + 48 ) ; } } int main ( ) { int num = 4317 ; highestPowerOfTwo ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumAfterKReverse ( int arr [ ] , int K , int N ) { int sum = INT_MIN ; if ( K & 1 ) reverse ( arr , arr + N ) ; int currsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { currsum += arr [ i ] ; sum = max ( sum , currsum ) ; } cout << sum ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 11 , 2 } ; int K = 1 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxSumAfterKReverse ( arr , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int N ) { return ( ( N & ( N - 1 ) ) && N ) ; } void countElements ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isPossible ( i ) ) count ++ ; } cout << count ; } int main ( ) { int N = 15 ; countElements ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countElements ( int N ) { int Cur_Ele = 1 ; int Count = 0 ; while ( Cur_Ele <= N ) { Count ++ ; Cur_Ele = Cur_Ele * 2 ; } cout << N - Count ; } int main ( ) { int N = 15 ; countElements ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SubMasks ( int N ) { for ( int S = N ; S ; S = ( S - 1 ) & N ) { cout << S << " ▁ " ; } } int main ( ) { int N = 25 ; SubMasks ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MOD  1000000007 NEW_LINE using namespace std ; long long int power ( int x , int y ) { long long int res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % MOD ; y = y >> 1 ; x = ( x * x ) % MOD ; } return res ; } void countPairs ( int N ) { long long int high = power ( 2 , N ) ; int count = 0 ; for ( int i = 0 ; i < high ; i ++ ) { for ( int j = 0 ; j < high ; j ++ ) { int X = ( i ^ j ) ; int Y = ( i j ) ; if ( X == Y ) { count ++ ; } } } cout << count % MOD << endl ; } int main ( ) { int N = 10 ; countPairs ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MOD  1000000007 NEW_LINE using namespace std ; long long int power ( int x , int y ) { long long int res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % MOD ; y = y >> 1 ; x = ( x * x ) % MOD ; } return res ; } void countPairs ( int N ) { cout << power ( 3 , N ) ; } int main ( ) { int N = 10 ; countPairs ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxAdjacent ( int * arr , int N ) { vector < int > res ; int arr_max = INT_MIN ; for ( int i = 1 ; i < N ; i ++ ) { arr_max = max ( arr_max , abs ( arr [ i - 1 ] - arr [ i ] ) ) ; } for ( int i = 1 ; i < N - 1 ; i ++ ) { int curr_max = abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; int ans = max ( curr_max , arr_max ) ; res . push_back ( ans ) ; } for ( auto x : res ) cout << x << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxAdjacent ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumIncrement ( int arr [ ] , int N ) { if ( N % 2 != 0 ) { cout << " - 1" ; exit ( 0 ) ; } int cntEven = 0 ; int cntOdd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cntEven += 1 ; } } cntOdd = N - cntEven ; return abs ( cntEven - cntOdd ) / 2 ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumIncrement ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void divisionalArrays ( int arr [ 3 ] , int N ) { int sum = N ; unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } for ( auto x : mp ) { if ( x . second > 1 ) { sum += x . second - 1 ; } } cout << sum << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; divisionalArrays ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void totalInversions ( int arr [ ] , int K , int N ) { int inv = 0 ; int X = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] > arr [ j ] and i < j ) inv ++ ; if ( arr [ i ] > arr [ j ] ) X ++ ; } } int totalInv = X * K * ( K - 1 ) / 2 + inv * K ; cout << totalInv << endl ; } int main ( ) { int arr [ ] = { 2 , 1 , 3 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; totalInversions ( arr , K , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumSum ( vector < vector < int > > & arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int x = 0 , y = i , sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ x ++ ] [ y ++ ] ; } if ( sum > ans ) ans = sum ; } for ( int i = 1 ; i < n ; i ++ ) { int x = i , y = 0 , sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ x ++ ] [ y ++ ] ; } if ( sum > ans ) ans = sum ; } return ans ; } int main ( ) { vector < vector < int > > arr ; arr = { { 1 , 2 , 3 } , { 3 , 5 , 10 } , { 1 , 3 , 5 } } ; int n = arr . size ( ) ; cout << MaximumSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfIntegers ( int arr [ ] , int N ) { int cur_max = 0 , count = 0 ; if ( N == 1 ) { count = 1 ; } else { for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] > cur_max ) { cur_max = arr [ i ] ; if ( arr [ i ] > arr [ i + 1 ] ) { count ++ ; } } } if ( arr [ N - 1 ] > cur_max ) count ++ ; } cout << count ; } int main ( ) { int arr [ ] = { 1 , 2 , 0 , 7 , 2 , 0 , 2 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; numberOfIntegers ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfWays ( int n , int k ) { if ( n == 0 ) return 1 ; if ( k == 0 ) return 1 ; if ( n >= pow ( 2 , k ) ) { int curr_val = pow ( 2 , k ) ; return numberOfWays ( n - curr_val , k ) + numberOfWays ( n , k - 1 ) ; } else return numberOfWays ( n , k - 1 ) ; } int main ( ) { int n = 4 ; int k = log2 ( n ) ; cout << numberOfWays ( n , k ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int possibleTriplets ( int arr [ ] , int N ) { int freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { freq ++ ; } } return ( freq * 1LL * ( freq - 1 ) * ( freq - 2 ) ) / 6 ; } int main ( ) { int arr [ ] = { 2 , 5 , -9 , -3 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << possibleTriplets ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPossibleDiff ( vector < int > & arr , int N ) { arr . push_back ( -1 ) ; reverse ( arr . begin ( ) , arr . end ( ) ) ; arr . push_back ( -1 ) ; reverse ( arr . begin ( ) , arr . end ( ) ) ; int maxDiff = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { maxDiff += arr [ i ] ; } if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { maxDiff -= arr [ i ] ; } } cout << maxDiff ; } int main ( ) { vector < int > arr = { 3 , 2 , 1 , 4 , 5 , 2 , 1 , 7 , 8 , 9 } ; int N = arr . size ( ) ; maxPossibleDiff ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } void reverseCircularArray ( int arr [ ] , int N , int K ) { int start = K , end = K - 1 ; int count = N / 2 ; while ( count -- ) { int temp = arr [ start % N ] ; arr [ start % N ] = arr [ end % N ] ; arr [ end % N ] = temp ; start ++ ; end -- ; if ( end == -1 ) { end = N - 1 ; } } printArray ( arr , N ) ; } int main ( ) { int arr [ ] = { 3 , 5 , 2 , 4 , 1 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; reverseCircularArray ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findOriginalMatrix ( vector < vector < int > > B , int N , int M ) { int A [ N ] [ M ] ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < M ; ++ j ) { A [ i ] [ j ] = 1 ; } } for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < M ; ++ j ) { if ( B [ i ] [ j ] == 0 ) { for ( int k = 0 ; k < M ; ++ k ) { A [ i ] [ k ] = 0 ; } for ( int k = 0 ; k < N ; ++ k ) { A [ k ] [ j ] = 0 ; } } } } for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < M ; ++ j ) { int c = 0 ; for ( int k = 0 ; k < M ; ++ k ) { if ( c == 1 ) break ; c += A [ i ] [ k ] ; } for ( int k = 0 ; k < N ; ++ k ) { if ( c == 1 ) break ; c += A [ k ] [ j ] ; } if ( c != B [ i ] [ j ] ) { cout << " Not ▁ Possible " ; return ; } } } for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < M ; ++ j ) { cout << A [ i ] [ j ] << " ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { vector < vector < int > > B { { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int N = B . size ( ) ; int M = B [ 0 ] . size ( ) ; findOriginalMatrix ( B , N , M ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int gcd ( int x , int y ) { if ( y == 0 ) return x ; return gcd ( y , x % y ) ; } int lcm ( int x , int y ) { return ( x * y ) / gcd ( x , y ) ; } int minimumCost ( int x , int y ) { int lcm_ = lcm ( x , y ) ; int costx = ( lcm_ - x ) / x ; int costy = ( lcm_ - y ) / y ; return costx + costy ; } int main ( ) { int x = 5 , y = 17 ; cout << minimumCost ( x , y ) << endl ; }
#include <bits/stdc++.h> NEW_LINE #define mod  1000000007 NEW_LINE using namespace std ; long long int power ( long long a , long long n , long long int d ) { long long int res = 1 ; while ( n ) { if ( n % 2 ) { res = ( ( res % d ) * ( a % d ) ) % d ; } a = ( ( a % d ) * ( a % d ) ) % d ; n /= 2 ; } return res ; } long long int gcd ( long long p , long long q , long long n ) { if ( p == q ) { return ( power ( p , n , mod ) + power ( q , n , mod ) ) % mod ; } long long int candidate = 1 ; long long int num = p - q ; long long int sq = sqrt ( num ) ; for ( long long i = 1 ; i <= sq ; ++ i ) { if ( num % i == 0 ) { long long int X = power ( p , n , i ) ; long long int Y = power ( q , n , i ) ; long long int temp = ( X + Y ) % i ; if ( temp == 0 ) { candidate = max ( candidate , i ) ; } temp = ( power ( p , n , num / i ) + power ( q , n , num / i ) ) % ( num / i ) ; if ( temp == 0 ) { candidate = max ( candidate , num / i ) ; } } } return candidate % mod ; } int main ( ) { long long int p , q , n ; p = 10 ; q = 6 ; n = 5 ; cout << gcd ( p , q , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPoint ( int n , int h ) { for ( int i = 1 ; i < n ; i ++ ) printf ( " % .2f ▁ " , sqrt ( i / ( n * 1.0 ) ) * h ) ; } int main ( ) { int n = 3 ; int h = 2 ; findPoint ( n , h ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int calculateK ( int x , int y ) { int g = gcd ( x , y ) ; int n = y / g ; int res = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { res -= ( res / i ) ; while ( n % i == 0 ) n /= i ; } } if ( n != 1 ) res -= ( res / n ) ; return res ; } int main ( ) { int x = 3 , y = 15 ; cout << calculateK ( x , y ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isInteger ( double N ) { int X = N ; double temp2 = N - X ; if ( temp2 > 0 ) { return false ; } return true ; } int main ( ) { double N = 1.5 ; if ( isInteger ( N ) ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nearestPowerOfTwo ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int lg = log2 ( arr [ i ] ) ; int a = pow ( 2 , lg ) ; int b = pow ( 2 , lg + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) cout << a << " ▁ " ; else cout << b << " ▁ " ; } } int main ( ) { int arr [ ] = { 5 , 2 , 7 , 12 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nearestPowerOfTwo ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void cntWaysConsArray ( int A [ ] , int N ) { int total = 1 ; int oddArray = 1 ; for ( int i = 0 ; i < N ; i ++ ) { total = total * 3 ; if ( A [ i ] % 2 == 0 ) { oddArray *= 2 ; } } cout << total - oddArray << " STRNEWLINE " ; } int main ( ) { int A [ ] = { 2 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cntWaysConsArray ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int n ) { int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; } int invertBits ( int n ) { int x = log2 ( n ) ; int m = 1 << x ; m = m | m - 1 ; n = n ^ m ; return n ; } void invertSum ( int A , int B ) { int temp = countSetBits ( A ) + countSetBits ( B ) ; cout << invertBits ( temp ) << endl ; } int main ( ) { int A = 5 ; int B = 7 ; invertSum ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumberHavingKthBitSet ( int N , int K ) { int numbers_rightmost_setbit_K ; for ( int i = 1 ; i <= K ; i ++ ) { int numbers_rightmost_bit_i = ( N + 1 ) / 2 ; N -= numbers_rightmost_bit_i ; if ( i == K ) { numbers_rightmost_setbit_K = numbers_rightmost_bit_i ; } } cout << numbers_rightmost_setbit_K ; } int main ( ) { int N = 15 ; int K = 2 ; countNumberHavingKthBitSet ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void XOR_for_every_i ( int A [ ] , int N ) { int frequency_of_bits [ 32 ] { } ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int M = A [ i ] ; while ( M ) { if ( M & 1 ) { frequency_of_bits [ bit_position ] += 1 ; } bit_position += 1 ; M >>= 1 ; } } for ( int i = 0 ; i < N ; i ++ ) { int M = A [ i ] ; int value_at_that_bit = 1 ; int XOR_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( M & 1 ) { XOR_sum += ( N - frequency_of_bits [ bit_position ] ) * value_at_that_bit ; } else { XOR_sum += ( frequency_of_bits [ bit_position ] ) * value_at_that_bit ; } M >>= 1 ; value_at_that_bit <<= 1 ; } cout << XOR_sum << ' ▁ ' ; } return ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; XOR_for_every_i ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minMoves ( int arr [ ] , int N ) { int odd_element_cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 != 0 ) { odd_element_cnt ++ ; } } int moves = ( odd_element_cnt ) / 2 ; if ( odd_element_cnt % 2 != 0 ) moves += 2 ; cout << moves ; } int main ( ) { int arr [ ] = { 5 , 6 , 3 , 7 , 20 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minMoves ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumMaxDiff ( vector < int > & nums ) { set < int > s ; for ( int i = 0 ; i < nums . size ( ) ; i ++ ) { if ( nums [ i ] % 2 == 0 ) s . insert ( nums [ i ] ) ; else s . insert ( nums [ i ] * 2 ) ; } int res = * s . rbegin ( ) - * s . begin ( ) ; while ( * s . rbegin ( ) % 2 == 0 ) { int x = * s . rbegin ( ) ; s . erase ( x ) ; s . insert ( x / 2 ) ; res = min ( res , * s . rbegin ( ) - * s . begin ( ) ) ; } return res ; } int main ( ) { vector < int > arr = { 1 , 2 , 5 , 9 } ; cout << minimumMaxDiff ( arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int bitwiseXorRange ( int n ) { if ( n % 4 == 0 ) return n ; if ( n % 4 == 1 ) return 1 ; if ( n % 4 == 2 ) return n + 1 ; return 0 ; } int evenXorRange ( int l , int r ) { int xor_l ; int xor_r ; xor_r = 2 * bitwiseXorRange ( r / 2 ) ; xor_l = 2 * bitwiseXorRange ( ( l - 1 ) / 2 ) ; return xor_l ^ xor_r ; } int main ( ) { int l = 10 ; int r = 20 ; cout << evenXorRange ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 3 ; const int N = 3 ; void countDigit ( int arr [ M ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i ] [ j ] ; int d = floor ( log10 ( X ) * 1.0 ) + 1 ; cout << d << " ▁ " ; } cout << endl ; } } int main ( ) { int arr [ ] [ 3 ] = { { 27 , 173 , 5 } , { 21 , 6 , 624 } , { 5 , 321 , 49 } } ; countDigit ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPermutation ( int arr [ ] , int n , int k ) { bool flag = false ; sort ( arr , arr + n ) ; do { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum += arr [ i ] & arr [ i + 1 ] ; } if ( sum >= k ) { flag = true ; for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } } while ( next_permutation ( arr , arr + n ) ) ; if ( flag == false ) { cout << " - 1" ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int K = 8 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPermutation ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMissingNumbers ( int arr [ ] , int len ) { const int M = 15 ; bitset < M > bset ; for ( int i = 0 ; i < M ; i ++ ) { bset . set ( i ) ; } for ( int i = 0 ; i < len ; i ++ ) { bset . set ( arr [ i ] - 1 , 0 ) ; } for ( int i = bset . _Find_first ( ) ; i < bset . size ( ) ; i = bset . _Find_next ( i ) ) { if ( i + 1 > len ) break ; cout << i + 1 << endl ; } } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 6 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMissingNumbers ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSum ( int a , int b , int n ) { int sum = 0 ; int x = a ^ b ; if ( n % 3 == 0 ) { sum = ( n / 3 ) * ( a + b + x ) ; } else if ( n % 3 == 1 ) { sum = ( n / 3 ) * ( a + b + x ) + a ; } else { sum = ( n / 3 ) * ( a + b + x ) + a + b ; } cout << sum ; } int main ( ) { int a = 2 , b = 5 , N = 8 ; findSum ( a , b , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LongestLenXORK ( int arr [ ] , int N , int K ) { int prefixXOR = 0 ; int maxLen = 0 ; map < int , int > mp ; mp [ 0 ] = -1 ; for ( int i = 0 ; i < N ; i ++ ) { prefixXOR ^= arr [ i ] ; if ( mp . count ( prefixXOR ^ K ) ) { maxLen = max ( maxLen , ( i - mp [ prefixXOR ^ K ] ) ) ; } if ( ! mp . count ( prefixXOR ) ) { mp [ prefixXOR ] = i ; } } return maxLen ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 7 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 1 ; cout << LongestLenXORK ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  3 NEW_LINE void intializeDiff ( int D [ N ] [ M + 1 ] , int A [ N ] [ M ] ) { for ( int i = 0 ; i < N ; i ++ ) { D [ i ] [ 0 ] = A [ i ] [ 0 ] ; D [ i ] [ M ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) D [ i ] [ j ] = A [ i ] [ j ] - A [ i ] [ j - 1 ] ; } } void update ( int D [ N ] [ M + 1 ] , int k , int r1 , int c1 , int r2 , int c2 ) { for ( int i = r1 ; i <= r2 ; i ++ ) { D [ i ] [ c1 ] += k ; D [ i ] [ c2 + 1 ] -= k ; } } void printArray ( int A [ N ] [ M ] , int D [ N ] [ M + 1 ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( j == 0 ) A [ i ] [ j ] = D [ i ] [ j ] ; else A [ i ] [ j ] = D [ i ] [ j ] + A [ i ] [ j - 1 ] ; cout << A [ i ] [ j ] << " ▁ " ; } cout << endl ; } } void performQueries ( int A [ N ] [ M ] , vector < vector < int > > Queries ) { int D [ N ] [ M + 1 ] ; intializeDiff ( D , A ) ; int Q = Queries . size ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { update ( D , Queries [ i ] [ 0 ] , Queries [ i ] [ 1 ] , Queries [ i ] [ 2 ] , Queries [ i ] [ 3 ] , Queries [ i ] [ 4 ] ) ; } printArray ( A , D ) ; } int main ( ) { int A [ N ] [ M ] = { { 1 , 2 , 3 } , { 1 , 1 , 0 } , { 4 , -2 , 2 } } ; vector < vector < int > > Queries = { { 2 , 0 , 0 , 1 , 1 } , { -1 , 1 , 0 , 2 , 2 } } ; performQueries ( A , Queries ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > calculateFactorial ( int N ) { vector < int > fact ( N + 1 ) ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fact [ i ] = fact [ i - 1 ] * i ; } return fact ; } int cntWaysSelection ( int arr [ ] , int N , int K , int L , int R ) { int cntWays = 0 ; int cntNum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= L && arr [ i ] <= R ) { cntNum ++ ; } } vector < int > fact = calculateFactorial ( cntNum ) ; for ( int i = K ; i <= cntNum ; i ++ ) { cntWays += fact [ cntNum ] / ( fact [ i ] * fact [ cntNum - i ] ) ; } return cntWays ; } int main ( ) { int arr [ ] = { 12 , 4 , 6 , 13 , 5 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; int L = 4 ; int R = 10 ; cout << cntWaysSelection ( arr , N , K , L , R ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int TotalAndPair ( int arr [ ] , int N ) { int totalAND = ( 1 << 30 ) - 1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalAND &= arr [ i ] & arr [ j ] ; } } return totalAND ; } int main ( ) { int arr [ ] = { 4 , 5 , 12 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << TotalAndPair ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumSubsetDifference ( int N ) { int blockOfSize8 = N / 8 ; string str = " ABBABAAB " ; int subsetDifference = 0 ; string partition = " " ; while ( blockOfSize8 -- ) { partition += str ; } vector < int > A , B ; for ( int i = 0 ; i < N ; i ++ ) { if ( partition [ i ] == ' A ' ) { A . push_back ( ( i + 1 ) * ( i + 1 ) ) ; } else { B . push_back ( ( i + 1 ) * ( i + 1 ) ) ; } } cout << subsetDifference << " STRNEWLINE " ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) cout << A [ i ] << " ▁ " ; cout << " STRNEWLINE " ; for ( int i = 0 ; i < B . size ( ) ; i ++ ) cout << B [ i ] << " ▁ " ; } int main ( ) { int N = 8 ; minimumSubsetDifference ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestDivisorGr1 ( int N ) { for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { return i ; } } return N ; } int findValOfNWithOperat ( int N , int K ) { for ( int i = 1 ; i <= K ; i ++ ) { N += smallestDivisorGr1 ( N ) ; } return N ; } int main ( ) { int N = 6 , K = 4 ; cout << findValOfNWithOperat ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000007 NEW_LINE long long findTripleSum ( long long A , long long B , long long C ) { long long sum = 0 ; for ( long long i = 1 ; i <= A ; i ++ ) { for ( long long j = 1 ; j <= B ; j ++ ) { for ( long long k = 1 ; k <= C ; k ++ ) { long long prod = ( ( ( i % M ) * ( j % M ) ) % M * ( k % M ) ) % M ; sum = ( sum + prod ) % M ; } } } return sum ; } int main ( ) { long long A = 10 ; long long B = 100 ; long long C = 1000 ; cout << findTripleSum ( A , B , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000007 NEW_LINE long long power ( long long x , long long N ) { long long res = 1 ; while ( N > 0 ) { if ( N & 1 ) { res = ( res * x ) % M ; } x = ( x * x ) % M ; N = N >> 1 ; } return res ; } long long modinv ( long long X ) { return power ( X , M - 2 ) ; } int findTripleSum ( long long A , long long B , long long C ) { long long MMI = modinv ( 8 ) ; long long res = 0 ; res = ( ( ( ( A % M * ( A + 1 ) % M ) % M * ( B % M * ( B + 1 ) % M ) % M ) % M * ( C % M * ( C + 1 ) % M ) % M ) % M * MMI ) % M ; return res ; } int main ( ) { long long A = 10 ; long long B = 100 ; long long C = 1000 ; cout << findTripleSum ( A , B , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMaximum ( int N , int M , vector < vector < int > > mat ) { int global_max = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int row_min = INT_MAX ; for ( int k = 0 ; k < M ; k ++ ) { int m = max ( mat [ i ] [ k ] , mat [ j ] [ k ] ) ; row_min = min ( row_min , m ) ; } global_max = max ( global_max , row_min ) ; } } return global_max ; } int main ( ) { vector < vector < int > > mat = { { 5 , 0 , 3 , 1 , 2 } , { 1 , 8 , 9 , 1 , 3 } , { 1 , 2 , 3 , 4 , 5 } , { 9 , 1 , 0 , 3 , 7 } , { 2 , 3 , 0 , 6 , 3 } , { 6 , 4 , 1 , 7 , 0 } } ; int N = 6 , M = 5 ; cout << getMaximum ( N , M , mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void makeTree ( vector < int > tree [ ] , pair < int , int > edges [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { int u = edges [ i ] . first ; int v = edges [ i ] . second ; tree [ u ] . push_back ( v ) ; } } pair < int , int > dfs ( int node , vector < int > tree [ ] ) { int mex = 0 ; int size = 1 ; for ( int u : tree [ node ] ) { pair < int , int > temp = dfs ( u , tree ) ; mex = max ( mex , temp . first ) ; size += temp . second ; } return { mex + size , size } ; } int main ( ) { int N = 7 ; pair < int , int > edges [ ] = { { 1 , 4 } , { 1 , 5 } , { 5 , 2 } , { 5 , 3 } , { 4 , 7 } , { 7 , 6 } } ; vector < int > tree [ N + 1 ] ; makeTree ( tree , edges , N ) ; cout << dfs ( 1 , tree ) . first ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divisorCount ( int n ) { int x = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == n / i ) x ++ ; else x += 2 ; } } return x ; } int minvalue_y ( int x ) { int a = divisorCount ( x ) ; int y = x + 1 ; while ( ( a & 1 ) == ( divisorCount ( y ) & 1 ) ) y ++ ; return y ; } int main ( ) { int x = 5 ; cout << minvalue_y ( x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minvalue_y ( int x ) { int n = sqrt ( x ) ; if ( n * n == x ) return x + 1 ; return pow ( n + 1 , 2 ) ; } int main ( ) { int x = 5 ; cout << minvalue_y ( x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; if ( N % 2 == 0 ) { alternateSum = ( - N ) / 2 ; } else { alternateSum = ( N + 1 ) / 2 ; } return alternateSum ; } int main ( ) { int N = 6 ; cout << alternatingSumOfFirst_N ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minStartValue ( vector < int > & nums ) { int minValue = 0 ; int sum = 0 ; for ( auto n : nums ) { sum += n ; minValue = min ( minValue , sum ) ; } int startValue = 1 - minValue ; return startValue ; } int main ( ) { vector < int > nums = { -3 , 2 , -3 , 4 , 2 } ; cout << minStartValue ( nums ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubArrayRemove ( int arr [ ] , int N ) { unordered_map < int , int > prefix_element_count , suffix_element_count ; int total_sum_of_elements = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total_sum_of_elements += arr [ i ] ; suffix_element_count [ arr [ i ] ] ++ ; } int prefix_sum = 0 ; int suffix_sum = 0 ; int count_subarray_equal_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { prefix_sum += arr [ i ] ; prefix_element_count [ arr [ i ] ] ++ ; suffix_sum = total_sum_of_elements - prefix_sum ; suffix_element_count [ arr [ i ] ] -- ; int difference = prefix_sum - suffix_sum ; int number_of_subarray_at_i_split = prefix_element_count [ difference ] + suffix_element_count [ - difference ] ; count_subarray_equal_sum += number_of_subarray_at_i_split ; } return count_subarray_equal_sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 1 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubArrayRemove ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkPerfectSquare ( int N ) { if ( N <= 0 ) { return 0 ; } double sq = sqrt ( N ) ; if ( floor ( sq ) == ceil ( sq ) ) { return 1 ; } return 0 ; } bool checktwoSidesareRighTriangle ( int A , int B ) { bool checkTriangle = false ; if ( checkPerfectSquare ( A * A + B * B ) ) { checkTriangle = true ; } if ( checkPerfectSquare ( A * A - B * B ) ) { checkTriangle = true ; } if ( checkPerfectSquare ( B * B - A * A ) ) { checkTriangle = true ; } return checkTriangle ; } int main ( ) { int A = 3 , B = 4 ; if ( checktwoSidesareRighTriangle ( A , B ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int array_sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } int countOperations ( int arr [ ] , int N ) { int count_zeros = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) count_zeros ++ ; } int sum = array_sum ( arr , N ) ; if ( count_zeros ) return count_zeros ; if ( sum == 0 ) return 1 ; return 0 ; } int main ( ) { int arr [ ] = { -1 , -1 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countOperations ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int TotalBitwiseORPair ( int arr [ ] , int N ) { int totalOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalOR |= arr [ i ] ; } return totalOR ; } int main ( ) { int arr [ ] = { 4 , 5 , 12 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << TotalBitwiseORPair ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkSolveable ( int n , int m ) { if ( n == 1 or m == 1 ) cout << " YES " ; else if ( m == 2 and n == 2 ) cout << " YES " ; else cout << " NO " ; } int main ( ) { int n = 1 , m = 3 ; checkSolveable ( n , m ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkRearrangements ( vector < vector < int > > mat , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ 0 ] != mat [ i ] [ j ] ) { return " Yes " ; } } } return " No " ; } string nonZeroXor ( vector < vector < int > > mat , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { res = res ^ mat [ i ] [ 0 ] ; } if ( res != 0 ) return " Yes " ; else return checkRearrangements ( mat , N , M ) ; } int main ( ) { vector < vector < int > > mat = { { 1 , 1 , 2 } , { 2 , 2 , 2 } , { 3 , 3 , 3 } } ; int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; cout << nonZeroXor ( mat , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findDifference ( vector < int > & p , vector < int > & q , int N ) { vector < int > A ( N ) ; for ( int i = 0 ; i < N ; i ++ ) A [ i ] = i + 1 ; bool IsCorrect ; int a = 1 , b = 1 ; do { IsCorrect = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != p [ i ] ) { IsCorrect = false ; break ; } } if ( IsCorrect ) break ; a ++ ; } while ( next_permutation ( A . begin ( ) , A . end ( ) ) ) ; for ( int i = 0 ; i < N ; i ++ ) A [ i ] = i + 1 ; do { IsCorrect = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != q [ i ] ) { IsCorrect = false ; break ; } } if ( IsCorrect ) break ; b ++ ; } while ( next_permutation ( A . begin ( ) , A . end ( ) ) ) ; cout << abs ( a - b ) << endl ; } int main ( ) { vector < int > p = { 1 , 3 , 2 } ; vector < int > q = { 3 , 1 , 2 } ; int n = p . size ( ) ; findDifference ( p , q , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE int printFinalArray ( int * a , int n , int * operations , int p , int capacity ) { int i , curr = 0 ; bool picked = false ; for ( i = 0 ; i < p ; i ++ ) { int s = operations [ i ] ; bool flag = false ; switch ( s ) { case 1 : if ( curr != 0 ) curr -- ; break ; case 2 : if ( curr != n - 1 ) curr ++ ; break ; case 3 : if ( picked == false && a [ curr ] != 0 ) { picked = true ; a [ curr ] -- ; } break ; case 4 : if ( picked == true && a [ curr ] != capacity ) { picked = false ; a [ curr ] ++ ; } break ; default : flag = true ; } if ( flag == true ) break ; } for ( i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " ▁ " ; } } int main ( ) { int capacity = 5 ; int a [ ] = { 2 , 5 , 2 } ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int operations [ ] = { 3 , 2 , 4 , 1 , 4 , 5 } ; int M = sizeof ( operations ) / sizeof ( operations [ 0 ] ) ; printFinalArray ( a , N , operations , M , capacity ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } void CheckSumPrime ( int A [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { string s = to_string ( A [ i ] ) ; sum += s . length ( ) ; } if ( isPrime ( sum ) ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } } int main ( ) { int A [ ] = { 1 , 11 , 12 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; CheckSumPrime ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int power ( long long int x , long long int N ) { long long int res = 1 ; while ( N > 0 ) { if ( N & 1 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; } void probablityPrimeprod ( long long int N ) { long long int N_E = 3 * N ; long long int N_S = power ( 6 , N ) ; cout << N_E << " ▁ / ▁ " << N_S ; } int main ( ) { long long int N = 2 ; probablityPrimeprod ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPalindrome ( int N ) { int rev = 0 ; int temp = N ; while ( N != 0 ) { rev = rev * 10 + N % 10 ; N = N / 10 ; } N = temp ; if ( N == rev ) { return true ; } return false ; } int closestSmallerPalindrome ( int N ) { do { N -- ; } while ( N >= 0 && ! checkPalindrome ( N ) ) ; return N ; } int main ( ) { int N = 4000 ; cout << closestSmallerPalindrome ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000007 NEW_LINE long long power ( long long x , long long N ) { long long res = 1 ; while ( N > 0 ) { if ( N & 1 ) { res = ( res * x ) % M ; } x = ( x * x ) % M ; N = N >> 1 ; } return res ; } long long moduloInverse ( long long X ) { return power ( X , M - 2 ) ; } long long F_1 ( long long N , long long F_N ) { long long P_2 = power ( 2 , N - 1 ) ; long long modInv = moduloInverse ( P_2 ) ; long long res ; res = ( ( modInv % M ) * ( F_N % M ) ) % M ; return res ; } int main ( ) { long long N = 3 ; long long F_N = 6 ; cout << F_1 ( N , F_N ) ; }
#include <iostream> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) return a ; else return GCD ( b , a % b ) ; } void check ( int x , int y ) { if ( GCD ( x , y ) == 1 ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int X = 2 , Y = 7 ; check ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long NEW_LINE void add ( vector < int > & arr , int x ) { arr . push_back ( x ) ; } void update ( int & effect , int x ) { effect = effect ^ x ; } void computeResults ( vector < int > & arr , int effect ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { arr [ i ] = arr [ i ] ^ effect ; cout << arr [ i ] << " ▁ " ; } } signed main ( ) { vector < int > arr = { 0 } ; int effect = 0 ; add ( arr , 5 ) ; update ( effect , 2 ) ; computeResults ( arr , effect ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubArray ( vector < int > arr , int k ) { pair < int , int > ans ; int i , sum = 0 ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } int found = 0 ; if ( sum % 3 == 0 ) { ans = make_pair ( 0 , i - 1 ) ; found = 1 ; } for ( int j = i ; j < arr . size ( ) ; j ++ ) { if ( found == 1 ) break ; sum = sum + arr [ j ] - arr [ j - k ] ; if ( sum % 3 == 0 ) { ans = make_pair ( j - k + 1 , j ) ; found = 1 ; } } if ( found == 0 ) ans = make_pair ( -1 , 0 ) ; if ( ans . first == -1 ) { cout << -1 ; } else { for ( i = ans . first ; i <= ans . second ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } } int main ( ) { vector < int > arr = { 84 , 23 , 45 , 12 , 56 , 82 } ; int K = 3 ; findSubArray ( arr , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void calculateFact ( int fact [ ] , int N ) { fact [ 0 ] = 1 ; for ( long long int i = 1 ; i < N ; i ++ ) { fact [ i ] = fact [ i - 1 ] * i ; } } int nCr ( int fact [ ] , int N , int R ) { if ( R > N ) return 0 ; int res = fact [ N ] / fact [ R ] ; res /= fact [ N - R ] ; return res ; } int countWays ( vector < int > & arr , int fact [ ] ) { int N = arr . size ( ) ; if ( N <= 2 ) { return 1 ; } vector < int > leftSubTree ; vector < int > rightSubTree ; int root = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < root ) { leftSubTree . push_back ( arr [ i ] ) ; } else { rightSubTree . push_back ( arr [ i ] ) ; } } int N1 = leftSubTree . size ( ) ; int N2 = rightSubTree . size ( ) ; int countLeft = countWays ( leftSubTree , fact ) ; int countRight = countWays ( rightSubTree , fact ) ; return nCr ( fact , N - 1 , N1 ) * countLeft * countRight ; } int main ( ) { vector < int > arr ; arr = { 3 , 4 , 5 , 1 , 2 } ; int N = arr . size ( ) ; int fact [ N ] ; calculateFact ( fact , N ) ; cout << countWays ( arr , fact ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfProd ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } return sum * sum ; } int main ( ) { int arr [ ] = { 2 , 3 , 1 , 5 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumOfProd ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int rev ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } bool check ( int n ) { return 2 * rev ( n ) == n + 1 ; } int main ( ) { int n = 73 ; if ( check ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPower ( int x , int y ) { int res1 = log ( y ) / log ( x ) ; double res2 = log ( y ) / log ( x ) ; return ( res1 == res2 ) ; } bool check ( int n ) { int x = ( n + 7 ) / 8 ; if ( ( n + 7 ) % 8 == 0 && isPower ( 10 , x ) ) return true ; else return false ; } int main ( ) { int n = 73 ; if ( check ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1e9 + 7 ; void NthTerm ( int F [ ] , int C [ ] , int K , int n ) { int ans [ n + 1 ] = { 0 } ; for ( int i = 0 ; i < K ; i ++ ) ans [ i ] = F [ i ] ; for ( int i = K ; i <= n ; i ++ ) { for ( int j = i - K ; j < i ; j ++ ) { ans [ i ] += ans [ j ] ; ans [ i ] %= mod ; } } cout << ans [ n ] << endl ; } int main ( ) { int F [ ] = { 0 , 1 } ; int C [ ] = { 1 , 1 } ; int K = 2 ; int N = 10 ; NthTerm ( F , C , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countFreq ( int arr [ ] , int n ) { unordered_map < int , int > mp1 ; for ( int i = 0 ; i < n ; ++ i ) { mp1 [ arr [ i ] ] ++ ; } unordered_map < int , int > mp2 ; for ( auto it : mp1 ) { mp2 [ it . second ] ++ ; } int M = INT_MIN ; for ( auto it : mp2 ) { M = max ( M , it . second ) ; } for ( auto it : mp2 ) { if ( M == it . second ) { return it . first ; } } return 0 ; } int main ( ) { int arr [ ] = { 6 , 10 , 3 , 10 , 8 , 3 , 6 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countFreq ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkPalindromeB ( int N , int B ) { int rev = 0 ; int N1 = N ; while ( N1 ) { rev = rev * B + N1 % B ; N1 = N1 / B ; } return N == rev ; } int main ( ) { int N = 5 , B = 2 ; if ( checkPalindromeB ( N , B ) ) { cout << " Yes " ; } else { cout << " No " ; } }
#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int findProduct ( unsigned int N ) { unsigned int result = 1 ; for ( int i = 2 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { result *= i ; } } return result ; } int main ( ) { int N = 5 ; cout << findProduct ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countEqual ( int n ) { return ( n + 1 ) / 2 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countEqual ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( int par [ ] , int x ) ; void unionn ( int par [ ] , int a , int b ) ; int countPairs ( int A [ ] , int B [ ] , int N , int M , int List [ ] [ 2 ] ) { int count = 0 ; int par [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) par [ i ] = i ; for ( int i = 0 ; i < M ; i ++ ) { int index1 = find ( par , List [ i ] [ 0 ] - 1 ) ; int index2 = find ( par , List [ i ] [ 1 ] - 1 ) ; if ( index1 != index2 ) { unionn ( par , index1 , index2 ) ; } } map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ A [ i ] ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { if ( mp . find ( B [ i ] ) == mp . end ( ) ) { count ++ ; continue ; } int j = mp [ B [ i ] ] ; if ( find ( par , i ) != find ( par , j ) ) count ++ ; } } return count ; } int find ( int par [ ] , int x ) { if ( par [ x ] == x ) return x ; else return par [ x ] = find ( par , par [ x ] ) ; } void unionn ( int par [ ] , int a , int b ) { a = find ( par , a ) ; b = find ( par , b ) ; if ( a == b ) return ; par [ a ] = b ; } int main ( ) { int N = 5 ; int M = 4 ; int A [ ] = { 1 , 5 , 9 , 2 , 3 } ; int B [ ] = { 2 , 4 , 5 , 1 , 3 } ; int List [ ] [ 2 ] = { { 1 , 4 } , { 2 , 3 } , { 3 , 5 } , { 2 , 5 } } ; cout << countPairs ( A , B , N , M , List ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void max_valid_triplet ( int A [ ] , int n ) { int ans = -1 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( A [ i ] < A [ j ] && A [ j ] < A [ k ] ) { int value = A [ i ] + A [ j ] * A [ k ] ; if ( value > ans ) { ans = value ; } } } } } cout << ( ans ) ; } int main ( ) { int arr [ ] = { 7 , 9 , 3 , 8 , 11 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; max_valid_triplet ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE #define mod  1000000007 NEW_LINE using namespace std ; vector < ll > ans ( 100002 , 1 ) ; void preCompute ( ) { for ( int i = 2 ; i <= 100000 / 2 ; i ++ ) { for ( int j = 2 * i ; j <= 100000 ; j += i ) { ans [ j ] = ( ans [ j ] * i ) % mod ; } } } int productOfProperDivi ( int num ) { return ans [ num ] ; } int main ( ) { preCompute ( ) ; int queries = 5 ; int a [ queries ] = { 4 , 6 , 8 , 16 , 36 } ; for ( int i = 0 ; i < queries ; i ++ ) { cout << productOfProperDivi ( a [ i ] ) << " , ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findlcm ( int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ( ( ( i * ans ) ) / ( __gcd ( i , ans ) ) ) ; return ans ; } int highestPower ( int n ) { int lcm = findlcm ( n ) ; int ans = 0 ; for ( int i = 1 ; ; i ++ ) { int x = pow ( 2 , i ) ; if ( lcm % x == 0 ) { ans = i ; } if ( x > n ) break ; } return ans ; } int main ( ) { int n = 15 ; cout << highestPower ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lli  long long int NEW_LINE void checkFactors ( lli N ) { lli ev_count = 0 , od_count = 0 ; for ( lli i = 1 ; i <= sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count % 2 == 0 && od_count % 2 == 1 ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { lli N = 36 ; checkFactors ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countofPermutations ( int N ) { return int ( 3 * pow ( 2 , N - 1 ) ) ; } int main ( ) { int N = 5 ; cout << countofPermutations ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void answer ( int L , int R ) { if ( 2 * L <= R ) cout << L << " , ▁ " << 2 * L << " STRNEWLINE " ; else cout << -1 ; } int main ( ) { int L = 3 , R = 8 ; answer ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int x , int y ) { if ( x % y == 0 ) return y ; else return gcd ( y , x % y ) ; } int countPairwiseCoprime ( int N , int M ) { int answer = 1 ; int g = gcd ( N , M ) ; int temp = g ; for ( int i = 2 ; i * i <= g ; i ++ ) { if ( temp % i == 0 ) { answer ++ ; while ( temp % i == 0 ) temp /= i ; } } if ( temp != 1 ) answer ++ ; return answer ; } void countCoprimePair ( int arr [ ] [ 2 ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << countPairwiseCoprime ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) << ' ▁ ' ; } } int main ( ) { int arr [ ] [ 2 ] = { { 12 , 18 } , { 420 , 660 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countCoprimePair ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getProduct ( int a [ ] , int n ) { int p = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { p *= abs ( a [ i ] - a [ j ] ) ; } } return p ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getProduct ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalCountDifference ( int n ) { if ( n == 1 ) return 1 ; return n + totalCountDifference ( n / 2 ) ; } int main ( ) { int N = 5 ; cout << totalCountDifference ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int arr [ ] , int n , int left , int right ) { int k = right - left + 1 ; int d = arr [ 1 ] / arr [ 0 ] ; int ans = arr [ left - 1 ] ; if ( d == 1 ) ans = ans * d * k ; else ans = ans * ( ( int ) pow ( d , k ) - 1 / ( d - 1 ) ) ; return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 } ; int queries = 3 ; int q [ ] [ 2 ] = { { 2 , 4 } , { 2 , 6 } , { 5 , 8 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i < queries ; i ++ ) cout << ( findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n , int r ) { int res = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int solve ( int n , int m , int k ) { int sum = 0 ; for ( int i = 0 ; i <= k ; i ++ ) sum += nCr ( n , i ) * nCr ( m , k - i ) ; return sum ; } int main ( ) { int n = 3 , m = 2 , k = 2 ; cout << solve ( n , m , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define size  1000001 NEW_LINE void seiveOfEratosthenes ( int * prime ) { prime [ 0 ] = 1 , prime [ 1 ] = 0 ; for ( int i = 2 ; i * i < 1000001 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * i ; j < 1000001 ; j += i ) { prime [ j ] = 1 ; } } } } float probabiltyEuler ( int * prime , int L , int R , int M ) { int * arr = new int [ size ] { 0 } ; int * eulerTotient = new int [ size ] { 0 } ; int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { eulerTotient [ i - L ] = i ; arr [ i - L ] = i ; } for ( int i = 2 ; i < 1000001 ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = ( L / i ) * i ; j <= R ; j += i ) { if ( j - L >= 0 ) { eulerTotient [ j - L ] = eulerTotient [ j - L ] / i * ( i - 1 ) ; while ( arr [ j - L ] % i == 0 ) { arr [ j - L ] /= i ; } } } } } for ( int i = L ; i <= R ; i ++ ) { if ( arr [ i - L ] > 1 ) { eulerTotient [ i - L ] = ( eulerTotient [ i - L ] / arr [ i - L ] ) * ( arr [ i - L ] - 1 ) ; } } for ( int i = L ; i <= R ; i ++ ) { if ( ( eulerTotient [ i - L ] % M ) == 0 ) { count ++ ; } } return ( 1.0 * count / ( R + 1 - L ) ) ; } int main ( ) { int * prime = new int [ size ] { 0 } ; seiveOfEratosthenes ( prime ) ; int L = 1 , R = 7 , M = 3 ; cout << probabiltyEuler ( prime , L , R , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll modPower ( ll a , ll b , ll M ) { ll res = 1 ; while ( b ) { if ( b & 1 ) res = res * a % M ; a = a * a % M ; b >>= 1 ; } return res ; } void findFirstAndLastM ( ll N , ll K , ll M ) { ll lastM = modPower ( N , K , ( 1LL ) * pow ( 10 , M ) ) ; ll firstM ; double y = ( double ) K * log10 ( N * 1.0 ) ; y = y - ( ll ) y ; double temp = pow ( 10.0 , y ) ; firstM = temp * ( 1LL ) * pow ( 10 , M - 1 ) ; cout << firstM << " ▁ " << lastM << endl ; } int main ( ) { ll N = 12 , K = 12 , M = 4 ; findFirstAndLastM ( N , K , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int findlcm ( int arr [ ] , int n ) { int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; return ans ; } void minimumSteps ( int arr [ ] , int n ) { int i , dat [ n + 1 ] ; for ( i = 1 ; i <= n ; i ++ ) dat [ arr [ i - 1 ] ] = i ; int b [ n + 1 ] , j = 0 , c ; for ( i = 1 ; i <= n ; i ++ ) { c = 1 ; j = dat [ i ] ; while ( j != i ) { c ++ ; j = dat [ j ] ; } b [ i ] = c ; } cout << findlcm ( b , n ) ; } int main ( ) { int arr [ ] = { 5 , 1 , 4 , 3 , 2 , 7 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumSteps ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double maximum ( double a , double b ) { if ( a > b ) return a ; return b ; } double maxSubarrayRatio ( double arr [ ] , int n ) { double maxRatio = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { double ratio = arr [ i ] ; for ( int k = i + 1 ; k <= j ; k ++ ) { ratio = ratio / arr [ k ] ; } maxRatio = maximum ( maxRatio , ratio ) ; } } return maxRatio ; } int main ( ) { double arr [ ] = { 2 , 2 , 4 , -0.2 , -1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSubarrayRatio ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( long n ) ; void check ( long num ) { long root = ( long ) sqrt ( num ) ; long poww = ( long ) ( log ( root ) / log ( 2 ) ) ; if ( num == ( long ) ( pow ( 2 , poww ) * ( pow ( 2 , poww + 1 ) - 1 ) ) ) { if ( isPrime ( poww + 1 ) ) { if ( isPrime ( ( long ) pow ( 2 , poww + 1 ) - 1 ) ) cout << " Yes " << endl ; else cout << " No " << endl ; } else cout << " No " << endl ; } else cout << " No " << endl ; } bool isPrime ( long n ) { if ( n <= 1 ) return false ; else if ( n == 2 n == 3 ) return true ; else { if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( long i = 5 ; i <= sqrt ( n ) ; i += 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; } return true ; } } int main ( ) { long num = 6 ; check ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isTriplet ( int ar [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( abs ( ar [ i ] - ar [ j ] ) == 1 || abs ( ar [ j ] - ar [ k ] ) == 1 || abs ( ar [ i ] - ar [ k ] ) == 1 ) { int x = ar [ i ] * ar [ i ] , y = ar [ j ] * ar [ j ] , z = ar [ k ] * ar [ k ] ; if ( x == y + z y == x + z z == x + y ) return true ; } } } } return false ; } int main ( ) { int arr [ ] = { 3 , 1 , 4 , 6 , 5 } ; int ar_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isTriplet ( arr , ar_size ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void closestDivisors ( int n ) { for ( int i = sqrt ( n + 2 ) ; i > 0 ; i -- ) { if ( ( n + 1 ) % i == 0 ) { cout << i << " , ▁ " << ( n + 1 ) / i ; break ; } if ( ( n + 2 ) % i == 0 ) { cout << i << " , ▁ " << ( n + 2 ) / i ; break ; } } } int main ( ) { int N = 123 ; closestDivisors ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { int phi [ n + 1 ] = { 0 } ; int divs [ n + 1 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] += i ; for ( int j = i * 2 ; j <= n ; j += i ) phi [ j ] -= phi [ i ] ; for ( int j = i ; j <= n ; j += i ) divs [ j ] ++ ; } return ( n - phi [ n ] - divs [ n ] + 1 ) ; } int main ( ) { int N = 42 ; cout << count ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum_of_differences ( int arr [ ] , int N ) { int sum = 0 ; int i , j , flag ; for ( i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) { flag = 0 ; for ( j = i + 1 ; j < N - 1 ; j ++ ) { if ( arr [ j ] >= arr [ j + 1 ] ) { sum += ( arr [ j ] - arr [ i ] ) ; i = j ; flag = 1 ; break ; } } if ( flag == 0 && arr [ i ] < arr [ N - 1 ] ) { sum += ( arr [ N - 1 ] - arr [ i ] ) ; break ; } } } return sum ; } int main ( ) { int arr [ ] = { 6 , 1 , 2 , 5 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sum_of_differences ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumString ( int x ) { int b = 1 ; double left_lim = sqrt ( x ) + 1.0 ; double right_lim = sqrt ( x ) + 2.0 ; int r ; for ( int i = left_lim ; i <= right_lim ; i ++ ) { if ( i > left_lim and i < right_lim ) { r = i ; break ; } } return b + r ; } int main ( ) { int X = 2 ; cout << MinimumString ( X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int N ) { int floorSqrt = sqrt ( N ) ; return ( N == floorSqrt * floorSqrt ) ; } bool legendreFunction ( int N ) { while ( N % 4 == 0 ) N /= 4 ; if ( N % 8 != 7 ) return true ; else return false ; } int minSquares ( int N ) { if ( isPerfectSquare ( N ) ) return 1 ; for ( int i = 1 ; i * i < N ; i ++ ) { if ( isPerfectSquare ( N - i * i ) ) return 2 ; } if ( legendreFunction ( N ) ) return 3 ; return 4 ; } int main ( ) { int N = 123 ; cout << minSquares ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_distinct ( long long n , long long k ) { unordered_set < long long > s ; for ( int i = 1 ; i <= k ; i ++ ) { long long tmp = n % i ; if ( s . find ( tmp ) != s . end ( ) ) { return false ; } s . insert ( tmp ) ; } return true ; } int main ( ) { long long N = 5 , K = 3 ; if ( is_distinct ( N , K ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; static int getDivisors ( int min , int n ) { int total = 0 ; for ( int i = min ; i < n ; ++ i ) { if ( n % i == 0 && n / i >= i ) { ++ total ; if ( n / i > i ) total += getDivisors ( i , n / i ) ; } } return total ; } int main ( ) { int n = 30 ; cout << 1 + getDivisors ( 2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int val ; struct Node * next ; Node ( int _val ) { val = _val ; next = NULL ; } } ; void getLastTwoPerson ( int n ) { int total = n ; struct Node * head = new Node ( 1 ) ; struct Node * temp = head ; for ( int i = 2 ; i <= n ; i ++ ) { temp -> next = new Node ( i ) ; temp = temp -> next ; } temp -> next = head ; temp = head ; struct Node * del ; while ( total != 2 ) { del = temp -> next -> next ; temp -> next -> next = temp -> next -> next -> next ; temp = temp -> next ; free ( del ) ; total -= 1 ; } cout << temp -> val << " ▁ " << temp -> next -> val ; } int main ( ) { int n = 2 ; getLastTwoPerson ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDenomin ( int n ) { return log2 ( n ) + 1 ; } int main ( ) { int n = 10 ; cout << findMinDenomin ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximumGcd ( int n ) { int max_gcd = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i > max_gcd ) max_gcd = i ; if ( ( n / i != i ) && ( n / i != n ) && ( ( n / i ) > max_gcd ) ) max_gcd = n / i ; } } return max_gcd ; } int main ( ) { int N = 10 ; cout << findMaximumGcd ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define newl  " NEW_LINE " #define ll  long long NEW_LINE #define pb  push_back NEW_LINE int findContent ( int arr [ ] , int n ) { int content = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { content = __gcd ( content , arr [ i ] ) ; } return content ; } int main ( ) { int n = 3 ; int arr [ ] = { 9 , 6 , 12 } ; cout << findContent ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void linearCongruentialMethod ( int Xo , int m , int a , int c , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( ( randomNums [ i - 1 ] * a ) + c ) % m ; } } int main ( ) { int Xo = 5 ; int m = 7 ; int a = 3 ; int c = 3 ; int noOfRandomNums = 10 ; vector < int > randomNums ( noOfRandomNums ) ; linearCongruentialMethod ( Xo , m , a , c , randomNums , noOfRandomNums ) ; for ( int i = 0 ; i < noOfRandomNums ; i ++ ) { cout << randomNums [ i ] << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void multiplicativeCongruentialMethod ( int Xo , int m , int a , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] * a ) % m ; } } int main ( ) { int Xo = 3 ; int m = 15 ; int a = 7 ; int noOfRandomNums = 10 ; vector < int > randomNums ( noOfRandomNums ) ; multiplicativeCongruentialMethod ( Xo , m , a , randomNums , noOfRandomNums ) ; for ( int i = 0 ; i < noOfRandomNums ; i ++ ) { cout << randomNums [ i ] << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MOD = 1000000007 ; int power ( int a , int b , int m ) { a %= m ; int res = 1 ; while ( b > 0 ) { if ( b & 1 ) res = ( ( res % m ) * ( a % m ) ) % m ; a = ( ( a % m ) * ( a % m ) ) % m ; b >>= 1 ; } return res % m ; } int productOfDivisors ( int p [ ] , int n ) { map < int , int > prime ; for ( int i = 0 ; i < n ; i ++ ) { prime [ p [ i ] ] ++ ; } int product = 1 , d = 1 ; for ( auto itr : prime ) { int val = power ( itr . first , ( itr . second ) * ( itr . second + 1 ) / 2 , MOD ) ; product = ( power ( product , itr . second + 1 , MOD ) * power ( val , d , MOD ) ) % MOD ; d = ( d * ( itr . second + 1 ) ) % ( MOD - 1 ) ; } return product ; } int main ( ) { int arr [ ] = { 11 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << productOfDivisors ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFractions ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { if ( __gcd ( i , j ) == 1 ) { string a = to_string ( i ) ; string b = to_string ( j ) ; cout << a + " / " + b << " , ▁ " ; } } } } int main ( ) { int n = 3 ; printFractions ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfObjects ( int N , int M ) { int initial = min ( N , M ) ; int final = ( N + M ) / 3 ; return min ( initial , final ) ; } int main ( ) { int N = 8 ; int M = 7 ; cout << numberOfObjects ( N , M ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLocalMaximaMinima ( int n , int arr [ ] ) { vector < int > mx , mn ; if ( arr [ 0 ] > arr [ 1 ] ) mx . push_back ( 0 ) ; else if ( arr [ 0 ] < arr [ 1 ] ) mn . push_back ( 0 ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( arr [ i - 1 ] > arr [ i ] ) and ( arr [ i ] < arr [ i + 1 ] ) ) mn . push_back ( i ) ; else if ( ( arr [ i - 1 ] < arr [ i ] ) and ( arr [ i ] > arr [ i + 1 ] ) ) mx . push_back ( i ) ; } if ( arr [ n - 1 ] > arr [ n - 2 ] ) mx . push_back ( n - 1 ) ; else if ( arr [ n - 1 ] < arr [ n - 2 ] ) mn . push_back ( n - 1 ) ; if ( mx . size ( ) > 0 ) { cout << " Points ▁ of ▁ Local ▁ maxima ▁ are ▁ : ▁ " ; for ( int a : mx ) cout << a << " ▁ " ; cout << endl ; } else cout << " There ▁ are ▁ no ▁ points ▁ of ▁ " << " Local ▁ Maxima ▁ STRNEWLINE " ; if ( mn . size ( ) > 0 ) { cout << " Points ▁ of ▁ Local ▁ minima ▁ are ▁ : ▁ " ; for ( int a : mn ) cout << a << " ▁ " ; cout << endl ; } else cout << " There ▁ are ▁ no ▁ points ▁ of ▁ " << " Local ▁ Minima ▁ STRNEWLINE " ; } int main ( ) { int N = 9 ; int arr [ ] = { 10 , 20 , 15 , 14 , 13 , 25 , 5 , 4 , 3 } ; findLocalMaximaMinima ( N , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int a , int b ) { if ( b == 0 ) return 1 ; if ( b == 1 ) return a ; int tmp = power ( a , b / 2 ) ; int result = tmp * tmp ; if ( b % 2 == 1 ) result *= a ; return result ; } bool check ( int n ) { int temp = n ; while ( temp > 0 ) { int last_digit = temp % 10 ; if ( last_digit == 0 last_digit == 1 ) return false ; if ( n % last_digit == 0 ) return false ; temp = temp / 10 ; } return true ; } void solve ( int n ) { int L = power ( 10 , n - 1 ) ; int R = power ( 10 , n ) - 1 ; int flag = 0 ; for ( int i = L ; i <= R ; i ++ ) { bool answer = check ( i ) ; if ( answer == true ) { cout << i << endl ; flag ++ ; break ; } } if ( flag == 0 ) cout << -1 << endl ; } int main ( ) { int N = 4 ; solve ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void costOfSubsequence ( int N , int arr [ ] , int costArray [ ] ) { int i , temp ; int cost = 0 ; set < int > removedElements ; int ans = 0 ; for ( i = 1 ; i < ( N - 1 ) ; i ++ ) { temp = arr [ i ] ; if ( ( ( arr [ i - 1 ] < temp ) && ( temp < arr [ i + 1 ] ) ) || ( ( arr [ i - 1 ] > temp ) && ( temp > arr [ i + 1 ] ) ) ) { removedElements . insert ( temp ) ; } } for ( i = 0 ; i < ( N ) ; i ++ ) { temp = arr [ i ] ; if ( ! ( removedElements . count ( temp ) > 0 ) ) { ans += arr [ i ] ; } else { cost += costArray [ i ] ; } } cout << ans << " , ▁ " ; cout << cost << endl ; } int main ( ) { int N ; N = 4 ; int arr [ N ] = { 1 , 3 , 4 , 2 } ; int costArray [ N ] = { 0 , 1 , 0 , 0 } ; costOfSubsequence ( N , arr , costArray ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  (long long)1000000000000 NEW_LINE vector < int > prime ; void sieve ( long long n ) { bool check [ 1000007 ] = { 0 } ; long long i , j ; check [ 0 ] = 1 , check [ 1 ] = 1 , check [ 2 ] = 0 ; for ( i = 4 ; i <= n ; i += 2 ) check [ i ] = true ; for ( i = 3 ; i * i <= n ; i += 2 ) if ( ! check [ i ] ) { for ( j = i * i ; j <= n ; j += 2 * i ) check [ j ] = true ; } prime . push_back ( 2 ) ; for ( int i = 3 ; i <= n ; i += 2 ) if ( ! check [ i ] ) prime . push_back ( i ) ; return ; } long long count ( long long a [ ] , int n , long long m ) { long long parity [ 3 ] = { 0 } ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { long long mult = 1 ; for ( int j = 0 ; j < n ; j ++ ) if ( i & ( 1 << j ) ) mult *= a [ j ] ; parity [ __builtin_popcount ( i ) & 1 ] += ( m / mult ) ; } return parity [ 1 ] - parity [ 0 ] ; } long long countRelPrime ( long long n , long long m ) { long long a [ 20 ] ; int i = 0 , j = 0 ; long long pz = prime . size ( ) ; while ( n != 1 && i < pz ) { if ( ( long long ) prime [ i ] * ( long long ) prime [ i ] > n ) break ; if ( n % prime [ i ] == 0 ) a [ j ] = ( long long ) prime [ i ] , j ++ ; while ( n % prime [ i ] == 0 ) n /= prime [ i ] ; i ++ ; } if ( n != 1 ) a [ j ] = n , j ++ ; return m - count ( a , j , m ) ; } void countRelPrimeInRange ( long long n , long long l , long long r ) { sieve ( sqrt ( maxN ) ) ; long long result = countRelPrime ( n , r ) - countRelPrime ( n , l - 1 ) ; cout << result << " STRNEWLINE " ; } int main ( ) { long long N = 7 , L = 3 , R = 9 ; countRelPrimeInRange ( N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_Xor ( int arr [ ] , pair < int , int > query [ ] , int N , int Q ) { for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] ^ arr [ i - 1 ] ; } int ans = 0 ; for ( int i = 0 ; i < Q ; i ++ ) { if ( query [ i ] . first == 0 ) ans = arr [ query [ i ] . second ] ; else ans = arr [ query [ i ] . first - 1 ] ^ arr [ query [ i ] . second ] ; cout << ans << endl ; } } int main ( ) { int arr [ ] = { 3 , 2 , 4 , 5 , 1 , 1 , 5 , 3 } ; int N = 8 ; int Q = 2 ; pair < int , int > query [ Q ] = { { 1 , 4 } , { 3 , 7 } } ; find_Xor ( arr , query , N , Q ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int * DiStirngMatch ( string Str ) { int N = Str . length ( ) ; int * arr = new int [ N ] ; int START = 0 , END = N ; for ( int i = 0 ; i < N ; i ++ ) { if ( Str [ i ] == ' I ' ) arr [ i ] = START ++ ; if ( Str [ i ] == ' D ' ) arr [ i ] = END -- ; } arr [ N ] = START ; return arr ; } int main ( ) { string Str = " IDID " ; int N = Str . length ( ) ; int * ptr = DiStirngMatch ( Str ) ; for ( int i = 0 ; i <= N ; i ++ ) cout << ptr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool IsPrime ( int i ) { if ( i % 2 == 0 && i != 2 ) return false ; else { for ( int j = 3 ; j <= sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) return false ; } return true ; } } int main ( ) { int c = 0 ; int N = 72 ; for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) { if ( IsPrime ( i ) ) { if ( N % i == 0 ) { c ++ ; if ( IsPrime ( N / i ) && i != ( N / i ) ) { c ++ ; } } } } cout << pow ( 2 , c ) - 1 << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_seq ( int arr [ ] , int m , int n ) { int b [ n ] ; int x = 0 ; b [ 0 ] = x ; for ( int i = 0 ; i < n - 1 ; i ++ ) { b [ i + 1 ] = x + arr [ i ] + b [ i ] ; } int mn = n ; for ( int i = 0 ; i < n ; i ++ ) { mn = min ( mn , b [ i ] ) ; } x = 1 - mn ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] += x ; } for ( int i = 0 ; i < n ; i ++ ) { cout << b [ i ] << " ▁ " ; } cout << endl ; } int main ( ) { int N = 3 ; int arr [ ] = { -2 , 1 } ; int M = sizeof ( arr ) / sizeof ( int ) ; find_seq ( arr , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lli  long long int NEW_LINE void isEqualFactors ( lli N ) { if ( ( N % 2 == 0 ) and ( N % 4 != 0 ) ) cout << " YES " << endl ; else cout << " NO " << endl ; } int main ( ) { lli N = 10 ; isEqualFactors ( N ) ; N = 125 ; isEqualFactors ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int n , int b ) { int largest = pow ( b , n ) - 1 ; cout << largest << endl ; } int main ( ) { int N = 2 , B = 5 ; findNumbers ( N , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximizedArray ( int arr [ ] , int N ) { int num , i = 0 ; while ( N -- ) { num = arr [ i ] ; int one = 0 ; int zero = 0 ; while ( num ) { if ( num % 2 == 0 ) { zero ++ ; } else { one ++ ; } num = num >> 1 ; } for ( int j = zero ; j < ( one + zero ) ; j ++ ) { num += ( 1 << j ) ; } cout << num ; i ++ ; if ( N > 0 ) cout << " , ▁ " ; } } int main ( ) { int arr [ ] = { 8 , 15 , 9 , 10 , 14 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximizedArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define x  2000021 NEW_LINE using namespace std ; long long int v [ x ] ; void sieve ( ) { v [ 1 ] = 1 ; for ( long long int i = 2 ; i < x ; i ++ ) v [ i ] = i ; for ( long long int i = 4 ; i < x ; i += 2 ) v [ i ] = 2 ; for ( long long int i = 3 ; i * i < x ; i ++ ) { if ( v [ i ] == i ) { for ( long long int j = i * i ; j < x ; j += i ) { if ( v [ j ] == j ) { v [ j ] = i ; } } } } } long long int prime_factors ( long long n ) { set < long long int > s ; while ( n != 1 ) { s . insert ( v [ n ] ) ; n = n / v [ n ] ; } return s . size ( ) ; } void distinctPrimes ( long long int m , long long int k ) { vector < long long int > result ; for ( long long int i = 14 ; i < m + k ; i ++ ) { long long count = prime_factors ( i ) ; if ( count == k ) { result . push_back ( i ) ; } } long long int p = result . size ( ) ; for ( long long int index = 0 ; index < p - 1 ; index ++ ) { long long element = result [ index ] ; long long count = 1 , z = index ; while ( z < p - 1 && count <= k && result [ z ] + 1 == result [ z + 1 ] ) { count ++ ; z ++ ; } if ( count >= k ) cout << element << ' ▁ ' ; } } int main ( ) { sieve ( ) ; long long int N = 1000 , K = 3 ; distinctPrimes ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findGCD ( int arr [ ] , int n ) { int gcd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { gcd = __gcd ( arr [ i ] , gcd ) ; if ( gcd == 1 ) { return 1 ; } } return gcd ; } int findLCM ( int arr [ ] , int n ) { int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { lcm = ( ( ( arr [ i ] * lcm ) ) / ( __gcd ( arr [ i ] , lcm ) ) ) ; } return lcm ; } void findRatio ( int arr [ ] , int n ) { int gcd = findGCD ( arr , n ) ; int lcm = findLCM ( arr , n ) ; cout << lcm / gcd << " : " << 1 << endl ; } int main ( ) { int arr [ ] = { 6 , 12 , 36 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findRatio ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void pen_hex ( long long n ) { long long pn = 1 ; for ( long long int i = 1 ; ; i ++ ) { pn = i * ( 3 * i - 1 ) / 2 ; if ( pn > n ) break ; long double seqNum = ( 1 + sqrt ( 8 * pn + 1 ) ) / 4 ; if ( seqNum == long ( seqNum ) ) cout << pn << " , ▁ " ; } } int main ( ) { long long int N = 1000000 ; pen_hex ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumOfTheArrayForQuery ( int * A , int N , int * X , int * Y , int Q ) { int sum = 0 ; unordered_map < int , int > count ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; count [ A [ i ] ] ++ ; } for ( int i = 0 ; i < Q ; i ++ ) { int x = X [ i ] , y = Y [ i ] ; sum -= count [ X [ i ] ] * X [ i ] ; sum += count [ X [ i ] ] * Y [ i ] ; count [ Y [ i ] ] += count [ X [ i ] ] ; count [ X [ i ] ] = 0 ; cout << sum << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 3 , 2 } ; int X [ ] = { 2 , 3 , 5 } ; int Y [ ] = { 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = sizeof ( X ) / sizeof ( X [ 0 ] ) ; sumOfTheArrayForQuery ( arr , N , X , Y , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void IncrementFactors ( int count [ ] , int val ) { for ( int i = 1 ; i * i <= val ; i ++ ) { if ( val % i == 0 ) { if ( i == val / i ) { count [ i ] ++ ; } else { count [ i ] ++ ; count [ val / i ] ++ ; } } } } void generateArr ( int A [ ] , int n ) { int B [ n ] ; int maxi = * max_element ( A , A + n ) ; int count [ maxi + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { B [ i ] = count [ A [ i ] ] ; IncrementFactors ( count , A [ i ] ) ; } printArr ( B , n ) ; } int main ( ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; generateArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > SieveOfEratosthenes ( int n ) { bool prime [ 2 * n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= 2 * n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 2 * n ; i += p ) prime [ i ] = false ; } } vector < int > primes ; for ( int p = 2 ; p <= 2 * n ; p ++ ) if ( prime [ p ] ) primes . push_back ( p ) ; return primes ; } int minChanges ( vector < int > arr ) { int n = arr . size ( ) ; int ans = 0 ; int maxi = * max_element ( arr . begin ( ) , arr . end ( ) ) ; vector < int > primes = SieveOfEratosthenes ( maxi ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = lower_bound ( primes . begin ( ) , primes . end ( ) , arr [ i ] ) - primes . begin ( ) ; int minm = abs ( primes [ x ] - arr [ i ] ) ; if ( x > 1 ) { minm = min ( minm , abs ( primes [ x - 1 ] - arr [ i ] ) ) ; } ans += minm ; } return ans ; } int main ( ) { vector < int > arr = { 4 , 25 , 13 , 6 , 20 } ; cout << minChanges ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calcSum ( int k , int n ) { int value = ( k * n * ( n + 1 ) ) / 2 ; return value ; } int findSum ( int * a , int n , int L , int R ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L % a [ i ] == 0 && L != 0 ) { sum += calcSum ( a [ i ] , R / a [ i ] ) - calcSum ( a [ i ] , ( L - 1 ) / a [ i ] ) ; } else { sum += calcSum ( a [ i ] , R / a [ i ] ) - calcSum ( a [ i ] , L / a [ i ] ) ; } } return sum ; } int main ( ) { int arr [ ] = { 2 , 7 , 3 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 7 ; int R = 20 ; cout << findSum ( arr , N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxN = 1000000 ; int arr [ 1000001 ] ; int prefix [ 1000001 ] ; void findPrimes ( ) { for ( int i = 1 ; i <= maxN ; i ++ ) arr [ i ] = 1 ; arr [ 0 ] = 0 , arr [ 1 ] = 0 ; for ( int i = 2 ; i * i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { for ( int j = i * i ; j <= maxN ; j += i ) { arr [ j ] = 0 ; } } } int sum = 0 ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= maxN ; i ++ ) { if ( arr [ i ] == 1 ) { int temp = i ; sum = 0 ; while ( temp > 0 ) { int x = temp % 10 ; sum += x ; temp = temp / 10 ; if ( arr [ sum ] == 1 ) { prefix [ i ] = 1 ; } else { prefix [ i ] = 0 ; } } } } for ( int i = 1 ; i <= maxN ; i ++ ) { prefix [ i ] += prefix [ i - 1 ] ; } } void countNumbersInRange ( int l , int r ) { findPrimes ( ) ; int result = prefix [ r ] - prefix [ l - 1 ] ; cout << result << endl ; } int main ( ) { int l , r ; l = 5 , r = 20 ; countNumbersInRange ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_product ( int a , int b , int c , int d ) { int prod1 = a * c ; int prod2 = b * d ; int prod3 = ( a + b ) * ( c + d ) ; int real = prod1 - prod2 ; int imag = prod3 - ( prod1 + prod2 ) ; cout << real << " ▁ + ▁ " << imag << " i " ; } int main ( ) { int a , b , c , d ; a = 2 ; b = 3 ; c = 4 ; d = 5 ; print_product ( a , b , c , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double get_concentration ( double mass , double volume ) { if ( volume == 0 ) return -1 ; else return ( mass / volume ) * 1000 ; } int main ( ) { double mass , volume ; mass = 100.00 ; volume = 500.00 ; cout << get_concentration ( mass , volume ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSubsetSum ( vector < int > & set , int n , int sum ) { bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; } void storeDivisors ( int n , vector < int > & div ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) div . push_back ( i ) ; else { div . push_back ( i ) ; div . push_back ( n / i ) ; } } } } bool isPractical ( int N ) { vector < int > div ; storeDivisors ( N , div ) ; for ( int i = 1 ; i < N ; i ++ ) { if ( ! isSubsetSum ( div , div . size ( ) , i ) ) return false ; } return true ; } int main ( ) { int N = 18 ; isPractical ( N ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivBySubsetSums ( vector < int > arr , int num ) { int n = arr . size ( ) ; long long total = 1 << n ; for ( long long i = 0 ; i < total ; i ++ ) { long long sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( i & ( 1 << j ) ) sum += arr [ j ] ; if ( sum != 0 && num % sum != 0 ) return false ; } return true ; } bool isSuperNivenNum ( int n ) { int temp = n ; vector < int > digits ; while ( n != 0 ) { int digit = n % 10 ; digits . push_back ( digit ) ; n = n / 10 ; } return isDivBySubsetSums ( digits , temp ) ; } int main ( ) { int n = 500 ; if ( isSuperNivenNum ( n ) ) cout << " yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divCount ( int n ) { bool hash [ n + 1 ] ; memset ( hash , true , sizeof ( hash ) ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; } bool isHighlyCompositeNumber ( int N ) { int NdivCount = divCount ( N ) ; for ( int i = 1 ; i < N ; i ++ ) { int idivCount = divCount ( i ) ; if ( idivCount >= NdivCount ) return false ; } return true ; } int main ( ) { int N = 12 ; if ( isHighlyCompositeNumber ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int PentacontahenagonNum ( int N ) { return ( 49 * N * N - 47 * N ) / 2 ; } int main ( ) { int N = 3 ; cout << "3rd ▁ Pentacontahenagon ▁ Number ▁ is ▁ " << PentacontahenagonNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isInsolite ( int n ) { int N = n ; int sum = 0 ; int product = 1 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; product = product * r * r ; n = n / 10 ; } return ( N % sum == 0 ) && ( N % product == 0 ) ; } int main ( ) { int N = 111 ; if ( isInsolite ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSaintExuperyNum ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n / i / j ; if ( i * i + j * j == k * k ) { if ( i * j * k == n ) return true ; ; } } } return false ; } int main ( ) { int N = 60 ; if ( isSaintExuperyNum ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sigma ( int n ) { if ( n == 1 ) return 1 ; int result = 0 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; } bool isSuperabundant ( int N ) { for ( float i = 1 ; i < N ; i ++ ) { float x = sigma ( i ) / i ; float y = sigma ( N ) / ( N * 1.0 ) ; if ( x > y ) return false ; } return true ; } int main ( ) { int N = 4 ; isSuperabundant ( N ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isRepdigit ( int num , int b ) { int prev = -1 ; while ( num ) { int digit = num % b ; num /= b ; if ( prev != -1 && digit != prev ) return false ; prev = digit ; } return true ; } int main ( ) { int num = 2000 , base = 7 ; isRepdigit ( num , base ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isDNum ( int n ) { if ( n < 4 ) return false ; int numerator , hcf ; for ( int k = 2 ; k <= n ; k ++ ) { numerator = pow ( k , n - 2 ) - k ; hcf = __gcd ( n , k ) ; } if ( hcf == 1 && ( numerator % n ) != 0 ) return false ; return true ; } int main ( ) { int n = 15 ; int a = isDNum ( n ) ; if ( a ) cout << " Yes " ; else cout << " No " ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; bool isComposite ( int n ) { if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } int concatenatePrimeFactors ( int n ) { char concatenate ; if ( n % 2 == 0 ) { concatenate += char ( 2 ) ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { concatenate += i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) concatenate += n ; return concatenate ; } bool isEnlightened ( int N ) { if ( ! isComposite ( N ) ) return false ; char num = char ( N ) ; char prefixConc = concatenatePrimeFactors ( N ) ; return int ( prefixConc ) ; } int main ( ) { int n = 250 ; if ( isEnlightened ( n ) ) cout << " Yes " ; else cout << " No " ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void findNthTerm ( int n ) { cout << n * ( 3 * n + 1 ) / 2 << endl ; } int main ( ) { int N = 4 ; findNthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isIdoneal ( int n ) { for ( int a = 1 ; a <= n ; a ++ ) { for ( int b = a + 1 ; b <= n ; b ++ ) { for ( int c = b + 1 ; c <= n ; c ++ ) { if ( a * b + b * c + c * a == n ) return false ; } } } return true ; } int main ( ) { int N = 10 ; if ( isIdoneal ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkDivisibility ( int n , int digit ) { return ( digit != 0 && n % digit == 0 ) ; } bool isAllDigitsDivide ( int n ) { int temp = n ; while ( temp > 0 ) { int digit = temp % 10 ; if ( ! ( checkDivisibility ( n , digit ) ) ) return false ; temp /= 10 ; } return true ; } bool isAllDigitsDistinct ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; } bool isLynchBell ( int n ) { return isAllDigitsDivide ( n ) && isAllDigitsDistinct ( n ) ; } int main ( ) { int N = 12 ; if ( isLynchBell ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; bool isRepunitNum ( int n , int b ) { int length = 0 ; int countOne = 0 ; while ( n != 0 ) { int r = n % b ; length ++ ; if ( r == 1 ) countOne ++ ; n = n / b ; } return countOne >= 3 && countOne == length ; } int main ( ) { int n = 31 ; int base = 2 ; if ( isRepunitNum ( n , base ) ) cout << " Yes " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstDigit ( int n ) { int digits = ( int ) log10 ( n ) ; n = ( int ) ( n / pow ( 10 , digits ) ) ; return n ; } int lastDigit ( int n ) { return ( n % 10 ) ; } bool isGapful ( int n ) { int first_dig = firstDigit ( n ) ; int last_dig = lastDigit ( n ) ; int concatenation = first_dig * 10 + last_dig ; return ( n % concatenation == 0 ) ; } int main ( ) { int n = 108 ; if ( isGapful ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; vector < int > primes ; void sieveSundaram ( ) { bool marked [ MAX / 2 + 1 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; } bool isEconomical ( int n ) { if ( n == 1 ) return false ; int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; } int pDigit = 0 , count_exp = 0 , p ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { p = primes [ i ] ; n = n / p ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = p / 10 ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } } return ( pDigit < sumDigits ) ; } int main ( ) { sieveSundaram ( ) ; for ( int i = 1 ; i < 200 ; i ++ ) if ( isEconomical ( i ) ) cout << i << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int A , int B , int N , int K , int L ) { int needa , needb ; if ( A % K == 0 ) needa = A / K ; else needa = A / K + 1 ; if ( B % L == 0 ) needb = B / L ; else needb = B / L + 1 ; int total = needa + needb ; if ( total > N ) return false ; else return true ; } int main ( ) { int A = 3 , B = 3 , N = 3 ; int K = 4 , M = 2 ; if ( isPossible ( A , B , N , K , M ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000050 NEW_LINE #define lli  long int NEW_LINE lli spf [ MAX + 1 ] ; void calculate_SPF ( ) { for ( lli i = 0 ; i <= MAX ; i ++ ) spf [ i ] = i ; for ( lli i = 4 ; i <= MAX ; i += 2 ) spf [ i ] = 2 ; for ( lli i = 3 ; i * i <= MAX ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j <= MAX ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } lli tfactor [ MAX + 1 ] ; lli pre [ MAX + 1 ] ; void CountTotalfactors ( ) { tfactor [ 1 ] = pre [ 1 ] = 1 ; for ( lli i = 2 ; i <= MAX ; i ++ ) { lli mspf = spf [ i ] ; lli prim = mspf ; lli temp = i ; lli cnt = 0 ; while ( temp % mspf == 0 ) { temp /= mspf ; cnt += 1 ; prim = prim * mspf ; } tfactor [ i ] = ( cnt + 1 ) * tfactor [ temp ] ; pre [ i ] = pre [ i - 1 ] + tfactor [ i ] ; } } lli BinarySearch ( lli X ) { lli start = 1 ; lli end = MAX - 1 ; while ( start < end ) { lli mid = ( start + end ) / 2 ; if ( pre [ mid ] == X ) return mid ; else if ( pre [ mid ] < X ) start = mid + 1 ; else end = mid ; } return start ; } void findSumOfCount ( int X ) { calculate_SPF ( ) ; CountTotalfactors ( ) ; cout << BinarySearch ( X ) << endl ; } int main ( ) { int X = 10 ; findSumOfCount ( X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < bool > prime ; void buildSieve ( int sum ) { prime = vector < bool > ( sum + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < ( sum + 1 ) ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < ( sum + 1 ) ; i += p ) prime [ i ] = false ; } } } int getSum ( int a [ 4 ] [ 5 ] ) { int s = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) for ( int j = 0 ; j < 5 ; j ++ ) s += a [ i ] [ j ] ; return s ; } bool checkIndex ( int n , int m , int a [ 4 ] [ 5 ] ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) { if ( prime [ i + j ] && ! prime [ a [ i ] [ j ] ] ) { return false ; } } return true ; } int main ( ) { int n = 4 , m = 5 ; int a [ 4 ] [ 5 ] = { { 1 , 2 , 3 , 2 , 2 } , { 2 , 2 , 7 , 7 , 7 } , { 7 , 7 , 21 , 7 , 10 } , { 2 , 2 , 3 , 6 , 7 } } ; int sum = getSum ( a ) ; buildSieve ( sum ) ; if ( prime [ sum ] && checkIndex ( n , m , a ) ) { cout << " YES " << endl ; } else cout << " NO " << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void gaussEaster ( int Y ) { float A , B , C , P , Q , M , N , D , E ; A = Y % 19 ; B = Y % 4 ; C = Y % 7 ; P = ( float ) floor ( Y / 100 ) ; Q = ( float ) floor ( ( 13 + 8 * P ) / 25 ) ; M = ( int ) ( 15 - Q + P - P / 4 ) % 30 ; N = ( int ) ( 4 + P - P / 4 ) % 7 ; D = ( int ) ( 19 * A + M ) % 30 ; E = ( int ) ( 2 * B + 4 * C + 6 * D + N ) % 7 ; int days = ( int ) ( 22 + D + E ) ; if ( ( D == 29 ) && ( E == 6 ) ) { cout << Y << " - 04-19" ; return ; } else if ( ( D == 28 ) && ( E == 6 ) ) { cout << Y << " - 04-18" ; return ; } else { if ( days > 31 ) { cout << Y << " - 04 - " << ( days - 31 ) ; return ; } else { cout << Y << " - 03 - " << days ; return ; } } } int main ( ) { int Y = 2020 ; gaussEaster ( Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define mod  1000000007 NEW_LINE #define pb  push_back NEW_LINE #define mod  1000000007 NEW_LINE #define vi  vector<int> NEW_LINE vi lis [ 100001 ] ; vi primes ; int vis [ 100001 ] ; int dis [ 100001 ] ; bool isPrime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } bool valid ( int a , int b ) { int c = 0 ; while ( a ) { if ( ( a % 10 ) != ( b % 10 ) ) { c ++ ; } a = a / 10 ; b = b / 10 ; } if ( c == 1 ) { return true ; } else { return false ; } } void makePrimes ( int N ) { int i , j ; int L = pow ( 10 , N - 1 ) ; int R = pow ( 10 , N ) - 1 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime ( i ) ) { primes . pb ( i ) ; } } for ( i = 0 ; i < primes . size ( ) ; i ++ ) { for ( j = i + 1 ; j < primes . size ( ) ; j ++ ) { int a = primes [ i ] ; int b = primes [ j ] ; if ( valid ( a , b ) ) { lis [ a ] . pb ( b ) ; lis [ b ] . pb ( a ) ; } } } } void bfs ( int src ) { queue < int > q ; q . push ( src ) ; vis [ src ] = 1 ; dis [ src ] = 0 ; while ( ! q . empty ( ) ) { int curr = q . front ( ) ; q . pop ( ) ; for ( int x : lis [ curr ] ) { if ( vis [ x ] == 0 ) { vis [ x ] = 1 ; q . push ( x ) ; dis [ x ] = dis [ curr ] + 1 ; } } } } int main ( ) { int N = 4 ; makePrimes ( N ) ; int A = 1033 , B = 8179 ; bfs ( A ) ; if ( dis [ B ] == -1 ) cout << " - 1" << endl ; else cout << dis [ B ] << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int placeValue ( int N , int num ) { int total = 1 , value = 0 , rem = 0 ; while ( true ) { rem = N % 10 ; N = N / 10 ; if ( rem == num ) { value = total * rem ; break ; } total = total * 10 ; } return value ; } int main ( ) { int D = 5 ; int N = 85932 ; cout << ( placeValue ( N , D ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void BeattySequence ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { double ans = floor ( i * sqrt ( 2 ) ) ; cout << ans << " , ▁ " ; } } int main ( ) { int n = 5 ; BeattySequence ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int N ) { return N * ( N - 1 ) / 2 + N * ( N - 1 ) * ( 2 * N - 1 ) / 6 ; } int main ( ) { int N = 3 ; cout << calculateSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Sum ( int N ) { int SumOfPrimeDivisors [ N + 1 ] = { 0 } ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! SumOfPrimeDivisors [ i ] ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } bool RuthAaronNumber ( int n ) { if ( Sum ( n ) == Sum ( n + 1 ) ) return true ; else return false ; } int main ( ) { int N = 714 ; if ( RuthAaronNumber ( N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } int main ( ) { int n = 3 ; int k = n ; n = 2 * n ; cout << binomialCoeff ( n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; } bool MultiplyPerfectNumber ( int n ) { if ( getSum ( n ) % n == 0 ) return true ; else return false ; } int main ( ) { int n = 28 ; if ( MultiplyPerfectNumber ( n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int phi ( int n ) { int result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result -= result / p ; } } if ( n > 1 ) result -= result / n ; return result ; } int isPerfectTotientNum ( int n ) { int temp = n ; int sum = 0 ; while ( n > 1 ) { sum = sum + phi ( n ) ; n = phi ( n ) ; } if ( sum == temp ) return true ; return false ; } int main ( ) { int n = 9 ; if ( isPerfectTotientNum ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = log ( a ) / log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; } bool isCunningham ( int n ) { return isPower ( n - 1 ) || isPower ( n + 1 ) ; } int main ( ) { int n = 126 ; if ( isCunningham ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long int SubArrayProdct ( int arr [ ] , int n ) { long int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) result *= pow ( arr [ i ] , ( i + 1 ) * ( n - i ) ) ; return result ; } int main ( ) { int arr [ ] = { 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << SubArrayProdct ( arr , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) ; int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int countWays ( int m , int n , int x , int y ) { return nCr ( m + n , m ) - nCr ( x + y , x ) * nCr ( m + n - x - y , m - x ) ; } int main ( ) { int m = 5 ; int n = 4 ; int x = 3 ; int y = 2 ; cout << countWays ( m , n , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountGreater ( int n , int k ) { int a = 0 ; while ( n ) { if ( ( n % 10 ) > k ) { a ++ ; } n = n / 10 ; } return a ; } int PrintList ( list < int > ans ) { for ( auto it = ans . begin ( ) ; it != ans . end ( ) ; it ++ ) cout << * it ; } void getNumber ( int n , int k ) { int count = CountGreater ( n , k ) ; if ( count == 0 ) { cout << n ; return ; } list < int > ans ; bool changed = false ; while ( n > 0 ) { int digit = n % 10 ; if ( changed == true ) { ans . push_front ( digit ) ; } else { if ( count == 0 && digit < k ) { ans . push_front ( digit + 1 ) ; changed = true ; } else { ans . push_front ( 1 ) ; if ( digit > k ) { count -- ; } } } n = n / 10 ; } if ( changed == false ) { ans . push_front ( 1 ) ; } PrintList ( ans ) ; return ; } int main ( ) { int N = 51234 ; int K = 4 ; getNumber ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double averageRuns ( int runs , int matches , int notout ) { int out = matches - notout ; if ( out == 0 ) return -1 ; double avg = double ( runs ) / out ; return avg ; } int main ( ) { int runs = 10000 ; int matches = 250 ; int notout = 50 ; double avg = averageRuns ( runs , matches , notout ) ; if ( avg == -1 ) cout << " NA " ; else cout << avg ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int ll ; void solve ( ll N ) { ll ans = 0 ; while ( N != 0 ) { ans += N ; N /= 2 ; } cout << ans << endl ; } int main ( ) { ll N = 5 ; solve ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumAND ( int L , int R ) { return R ; } int main ( ) { int l = 3 ; int r = 7 ; cout << maximumAND ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool oddSum ( vector < int > & A , int N , int K ) { set < int > Odd ; set < int > Even ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { Even . insert ( A [ i ] ) ; } else { Odd . insert ( A [ i ] ) ; } } if ( Odd . size ( ) >= K ) return true ; bool flag = false ; for ( int i = 1 ; i < K ; i += 2 ) { int needed = K - i ; if ( needed <= Even . size ( ) ) { return true ; } } return flag ; } int main ( ) { int K = 5 ; vector < int > A = { 12 , 1 , 7 , 7 , 26 , 18 } ; int N = 3 ; if ( oddSum ( A , N , K ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void smallestNumber ( int N ) { int L = pow ( 10 , N ) - 1 ; int S = pow ( 10 , N - 1 ) ; for ( int i = S ; i <= L ; i ++ ) { if ( i % N == 0 ) { cout << i ; return ; } } } int main ( ) { int N = 2 ; smallestNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrimefactorNum ( int N ) { int arr [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) arr [ i ] = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( arr [ i ] == 1 ) { for ( int j = i ; j <= N ; j += i ) { arr [ j ] *= i ; } } } int maxValue = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { if ( arr [ i ] > maxValue ) { maxValue = i ; } } return maxValue ; } int main ( ) { int N = 20 ; cout << maxPrimefactorNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mod = 1000000007 ; int linearSum ( int n ) { return ( n * ( n + 1 ) / 2 ) % mod ; } int rangeSum ( int b , int a ) { return ( linearSum ( b ) - linearSum ( a ) ) % mod ; } int totalSum ( int n ) { int result = 0 ; int i = 1 ; while ( true ) { result += rangeSum ( n / i , n / ( i + 1 ) ) * ( i % mod ) % mod ; result %= mod ; if ( i == n ) break ; i = n / ( n / ( i + 1 ) ) ; } return result ; } int main ( ) { int N = 4 ; cout << totalSum ( N ) << endl ; N = 12 ; cout << totalSum ( N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <unordered_map> NEW_LINE #include <vector> NEW_LINE using namespace std ; void spf_array ( int spf [ ] ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < 1000 ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < 1000 ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < 1000 ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < 1000 ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } int minimum_operation ( int b [ ] , int d , int spf [ ] ) { unordered_map < int , int > m ; int i = 0 ; int c = 0 ; for ( i = 0 ; i < d ; i ++ ) { int x = b [ i ] ; while ( x != 1 ) { x = x / spf [ x ] ; if ( m [ spf [ x ] ] == 0 ) { m [ spf [ x ] ] = 1 ; } } } m . erase ( 1 ) ; for ( auto x : m ) { int e = 0 , o = 0 ; int j = x . first ; for ( i = 0 ; i < d ; i ++ ) { if ( b [ i ] % j == 0 ) { int h = 0 ; int g = b [ i ] ; while ( g != 0 ) { if ( g % j != 0 ) { break ; } g = g / j ; h = h + 1 ; } if ( h % 2 == 0 ) { e = e + 1 ; } else { o = o + 1 ; } } else { e = e + 1 ; } } c = c + min ( o , e ) ; } return c ; } int main ( ) { int spf [ 1001 ] ; int b [ ] = { 1 , 4 , 6 } ; int d = sizeof ( b ) / sizeof ( b [ 0 ] ) ; spf_array ( spf ) ; cout << minimum_operation ( b , d , spf ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } bool isRare ( int N ) { int reverseN = reversDigits ( N ) ; if ( reverseN == N ) return false ; return isPerfectSquare ( N + reverseN ) && isPerfectSquare ( N - reverseN ) ; } int main ( ) { int n = 65 ; if ( isRare ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; } bool isZuckerman ( int n ) { return n % getProduct ( n ) == 0 ; } int main ( ) { int n = 115 ; if ( isZuckerman ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDouble ( int num ) { string s = to_string ( num ) ; int l = s . length ( ) ; if ( s [ 0 ] == s [ 1 ] ) return false ; if ( l % 2 == 1 ) { s = s + s [ 1 ] ; l ++ ; } string s1 = s . substr ( 0 , l / 2 ) ; string s2 = s . substr ( l / 2 ) ; return s1 == s2 ; } bool isNontrivialUndulant ( int N ) { return N > 100 && isDouble ( N ) ; } int main ( ) { int n = 121 ; if ( isNontrivialUndulant ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } bool isAdditivePrime ( int n ) { if ( ! isPrime ( n ) ) return false ; return isPrime ( getSum ( n ) ) ; } int main ( ) { int N = 23 ; if ( isAdditivePrime ( N ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isStraighLineNum ( int N ) { if ( N <= 99 ) return false ; string str = to_string ( N ) ; int d = str [ 1 ] - str [ 0 ] ; for ( int i = 2 ; i < str . length ( ) ; i ++ ) if ( str [ i ] - str [ i - 1 ] != d ) return false ; return true ; } int main ( ) { int N = 135 ; if ( isStraighLineNum ( n ) ) cout << " Yes " ; else cout << " No " ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void findNthTerm ( int n ) { cout << pow ( 2 , n ) - 2 * n << endl ; } int main ( ) { int N = 4 ; findNthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isEvenOddForm ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 && s [ i ] % 2 != 0 ) return false ; if ( i % 2 == 1 && s [ i ] % 2 != 1 ) return false ; } return true ; } bool isOddEvenForm ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 && s [ i ] % 2 != 1 ) return false ; if ( i % 2 == 1 && s [ i ] % 2 != 0 ) return false ; } return true ; } bool isAlternating ( int n ) { string str = to_string ( n ) ; return ( isEvenOddForm ( str ) || isOddEvenForm ( str ) ) ; } int main ( ) { int N = 129 ; if ( isAlternating ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } const int TEN = 10 ; void updateFreq ( int n , int freq [ ] ) { while ( n ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } } bool areAnagrams ( int a , int b ) { int freqA [ TEN ] = { 0 } ; int freqB [ TEN ] = { 0 } ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; } bool OrmistonPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && areAnagrams ( n1 , n2 ) ) ; } int main ( ) { int n1 = 1913 , n2 = 1931 ; if ( OrmistonPrime ( n1 , n2 ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int DecakismyriagonNum ( int N ) { return ( 99998 * N * N - 99996 * N ) / 2 ; } int main ( ) { int N = 3 ; cout << DecakismyriagonNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isLoeschian ( int n ) { for ( int x = 1 ; x <= sqrt ( n ) ; x ++ ) { for ( int y = 1 ; y <= sqrt ( n ) ; y ++ ) { if ( x * x + x * y + y * y == n ) return true ; } } return false ; } int main ( ) { int N = 19 ; if ( isLoeschian ( n ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; } bool check ( int num ) { int sigmaN = divSum ( num ) ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) { if ( sigmaN - 2 * i == 2 * num ) return true ; } else { if ( sigmaN - 2 * i == 2 * num ) return true ; if ( sigmaN - 2 * ( num / i ) == 2 * num ) return true ; } } } if ( sigmaN - 2 * 1 == 2 * num ) return true ; return false ; } bool isAdmirableNum ( int N ) { return check ( N ) ; } int main ( ) { int n = 12 ; if ( isAdmirableNum ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = ( 13 * i * ( i - 1 ) ) / 2 + 2 ; cout << ith_term << " , ▁ " ; } } int main ( ) { int N = 7 ; printSeries ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < pair < int , int > > Pairs ( int C ) { vector < pair < int , int > > ans ; for ( int i = 1 ; i < C ; i ++ ) { for ( int j = i + 1 ; j < C ; j ++ ) { if ( ( i * i ) + ( j * j ) == ( C * C ) ) { ans . push_back ( make_pair ( i , j ) ) ; } } } return ans ; } int main ( ) { int C = 13 ; vector < pair < int , int > > ans = Pairs ( C ) ; if ( ans . size ( ) == 0 ) { cout << " No ▁ valid ▁ pair ▁ exist " << endl ; return 0 ; } for ( auto i = ans . begin ( ) ; i != ans . end ( ) ; i ++ ) { cout << " ( " << i -> first << " , ▁ " << i -> second << " ) " << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float strikerate ( int bowls , int runs ) { float z ; z = ( float ( runs ) / bowls ) * 100 ; return z ; } int main ( ) { int A , B ; A = 264 ; B = 173 ; cout << strikerate ( B , A ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorize ( int N ) { int count = 0 ; int cnt = 0 ; while ( ( N % 2 ) == 0 ) { N = N / 2 ; count ++ ; } cnt = cnt + count ; for ( int i = 3 ; i <= sqrt ( N ) ; i += 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } cnt = cnt + count ; } if ( N > 2 ) cnt = cnt + 1 ; return cnt ; } void ifNumberExists ( int X , int Y ) { int C , dsum ; C = X - Y - 1 ; dsum = factorize ( X ) ; if ( dsum >= C ) cout << " YES ▁ STRNEWLINE " ; else cout << " NO ▁ STRNEWLINE " ; } int main ( ) { int X , Y ; X = 6 ; Y = 4 ; ifNumberExists ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define max  10000000 NEW_LINE bool prime [ max ] = { false } ; void SieveOfEratosthenes ( int maxm ) { prime [ 0 ] = prime [ 1 ] = true ; for ( int i = 2 ; i * i <= maxm ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = i * i ; j <= maxm ; j += i ) { prime [ j ] = true ; } } } } void print_nearest_prime ( int arr [ ] , int N ) { int maxm = * max_element ( arr , arr + N ) ; SieveOfEratosthenes ( maxm ) ; vector < int > primes ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! prime [ arr [ i ] ] ) primes . push_back ( i ) ; } if ( primes . size ( ) == 0 ) { for ( int i = 0 ; i < N ; i ++ ) { cout << -1 << " ▁ " ; } return ; } int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( curr == primes . size ( ) - 1 || i <= primes [ curr ] ) { cout << arr [ primes [ curr ] ] << " ▁ " ; continue ; } if ( abs ( primes [ curr ] - i ) < abs ( primes [ curr + 1 ] - i ) ) { cout << arr [ primes [ curr ] ] << " ▁ " ; } else { curr ++ ; cout << arr [ primes [ curr ] ] << " ▁ " ; } } } int main ( ) { int N = 6 ; int arr [ ] = { 8 , 7 , 12 , 15 , 3 , 11 } ; print_nearest_prime ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPosition ( int n ) { int i = 0 ; int pos = 0 ; while ( n > 0 ) { if ( n % 10 == 7 ) { pos = pos + pow ( 2 , i + 1 ) ; } else { pos = pos + pow ( 2 , i ) ; } i ++ ; n = n / 10 ; } cout << pos ; } int main ( ) { int N = 777 ; findPosition ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double findAverageOfCube ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += i * i * i ; } return sum / n ; } int main ( ) { int n = 3 ; cout << findAverageOfCube ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findNumberL ( int n ) { if ( n == 1 ) return "1" ; string result = " " ; int length = ( int ) floor ( log10 ( n ) + 1 ) ; for ( int i = 1 ; i <= n - ( 2 * length ) ; i ++ ) { result += '9' ; } result = to_string ( n ) + result + to_string ( n ) ; return result ; } string findNumberS ( int n ) { if ( n == 1 ) return "1" ; string result = " " ; int length = ( int ) floor ( log10 ( n ) + 1 ) ; for ( int i = 1 ; i <= n - ( 2 * length ) ; i ++ ) { result += '0' ; } result = to_string ( n ) + result + to_string ( n ) ; return result ; } int main ( ) { int N = 3 ; cout << " Smallest ▁ Number ▁ = ▁ " << findNumberS ( N ) << endl ; cout << " Largest ▁ Number ▁ = ▁ " << findNumberL ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum_star_num ( int n ) { int summ = 2 * n * ( n + 1 ) * ( n - 1 ) + n ; return summ ; } int main ( ) { int n = 3 ; cout << sum_star_num ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long int NEW_LINE void solve ( int n , const vector < pair < int , int > > & vec ) { vector < int > a , b ; for ( auto pr : vec ) { a . push_back ( pr . first ) ; b . push_back ( pr . second ) ; } sort ( a . begin ( ) , a . end ( ) ) ; sort ( b . begin ( ) , b . end ( ) ) ; int left , right , ans ; if ( ( n & 1 ) ) { left = a [ n / 2 ] ; right = b [ n / 2 ] ; ans = right - left + 1 ; } else { left = ( a [ n / 2 ] + a [ n / 2 - 1 ] ) ; right = ( b [ n / 2 ] + b [ n / 2 - 1 ] ) ; ans = right - left + 1 ; } cout << ans << endl ; } signed main ( ) { int N = 3 ; vector < pair < int , int > > vec = { { 100 , 100 } , { 10 , 10000 } , { 1 , 1000000000 } } ; solve ( N , vec ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > mp ; int find_pairs ( int ar [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mp [ ar [ i ] ] ++ ; } for ( auto i : mp ) { int count = i . second ; if ( count > 1 ) { ans += ( ( count * ( count - 1 ) ) / 2 ) ; } } return ans ; } int main ( ) { int ar [ ] = { 1 , 2 , 3 , 3 , 4 , 5 , 5 , 7 , 8 } ; int arr_size = ( sizeof ( ar ) / sizeof ( ar [ 0 ] ) ) ; cout << find_pairs ( ar , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gonNum360 ( int n ) { return ( 358 * n * n - 356 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << gonNum360 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gonNum257 ( int n ) { return ( 255 * n * n - 253 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << gonNum257 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int TetracontadigonalNum ( int n ) { return ( 40 * n * n - 38 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << TetracontadigonalNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLCMPrime ( int a , int b ) { if ( a == b ) { return a ; } return a * b ; } int main ( ) { int a = 3 , b = 5 ; cout << findLCMPrime ( a , b ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void smallestNumber ( int N ) { cout << N * ceil ( pow ( 2 , ( N - 1 ) ) / N ) ; } int main ( ) { int N = 3 ; smallestNumber ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void checkSolution ( int a , int b , int c ) { if ( 2 * b * b == 9 * a * c ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int a = 1 , b = 3 , c = 2 ; checkSolution ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getParity ( int n , const vector < int > & A ) { for ( auto x : A ) { if ( x & 1 ) { cout << " Even " << endl ; return ; } } cout << " Odd " << endl ; } int main ( ) { int N = 3 ; vector < int > A = { 2 , 3 , 1 } ; getParity ( N , A ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void numberOfDigits ( int N ) { int nod = floor ( log10 ( N ) + 1 ) ; int toDecrease = ( pow ( 10 , nod ) - 1 ) / 9 ; cout << ( N + 1 ) * nod - toDecrease << endl ; } int main ( ) { int N = 13 ; numberOfDigits ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int arr [ ] , int N , int K ) { int oddCount = 0 , evenCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) evenCount ++ ; else oddCount ++ ; } if ( evenCount == N || ( oddCount == N && K % 2 == 0 ) || ( K == N && oddCount % 2 == 0 ) ) return false ; else return true ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 8 } ; int K = 5 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isPossible ( arr , N , K ) ) cout << " Possible " ; else cout << " Not ▁ Possible " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lastTwoDigits ( long long N ) { if ( N >= 10 ) { cout << "00" ; return ; } long long fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fac = ( fac * i ) % 100 ; cout << fac ; } int main ( ) { int N = 7 ; lastTwoDigits ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float productOfGP ( float a , float r , int n ) { return pow ( a , n ) * pow ( r , n * ( n - 1 ) / 2 ) ; } int main ( ) { float a = 1 , r = 2 ; int N = 4 ; cout << productOfGP ( a , r , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float productOfGP ( float a , float r , int n ) { int an = a * pow ( r , n - 1 ) ; return sqrt ( pow ( a * an , n ) ) ; } int main ( ) { float a = 1 , r = 2 ; int N = 4 ; cout << productOfGP ( a , r , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long int NEW_LINE void prob ( int x , int y ) { int num = abs ( x - y + 1 ) * abs ( x - y + 1 ) ; int den = ( x + 1 ) * ( x + 1 ) ; int gcd = __gcd ( num , den ) ; cout << num / gcd << " / " << den / gcd << endl ; } signed main ( ) { int X = 2 , Y = 1 ; prob ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_Chiliagon ( int N ) { float n = ( 996 + sqrt ( 7984 * N + 992016 ) ) / 1996 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 1000 ; if ( is_Chiliagon ( N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int commonSubarrays ( int * A , int * B , int N ) { int Map [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) Map [ * ( A + i ) ] = i ; for ( int i = 0 ; i < N ; i ++ ) { * ( B + i ) = Map [ * ( B + i ) ] ; } int count = 0 ; int i = 0 , K ; while ( i < N ) { K = 1 ; i += 1 ; while ( i < N && B [ i ] == B [ i - 1 ] + 1 ) { i += 1 ; K += 1 ; } count = count + ( ( K ) * ( K + 1 ) ) / 2 ; } return count ; } int main ( ) { int N = 3 ; int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 2 , 3 , 1 } ; cout << ( commonSubarrays ( A , B , N ) ) << endl ; N = 5 ; int C [ ] = { 1 , 2 , 3 , 4 , 5 } ; int D [ ] = { 2 , 3 , 1 , 4 , 5 } ; cout << ( commonSubarrays ( C , D , N ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getArrayOfSizeK ( int n , int k ) { vector < int > ans ; int odd = n - ( ( k - 1 ) * 1 ) ; if ( odd > 0 && odd % 2 != 0 ) { for ( int i = 0 ; i < k - 1 ; i ++ ) { ans . push_back ( 1 ) ; } ans . push_back ( odd ) ; } int even = n - ( ( k - 1 ) * 2 ) ; if ( even > 0 && even % 2 == 0 && ans . size ( ) == 0 ) { for ( int i = 0 ; i < k - 1 ; i ++ ) { ans . push_back ( 2 ) ; } ans . push_back ( even ) ; } if ( ans . size ( ) > 0 ) { for ( int i = 0 ; i < k ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } else { cout << " NO " << endl ; } } int main ( ) { int n = 10 , k = 3 ; getArrayOfSizeK ( n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool checkDivisbility ( int num ) { int digit ; int N = num ; while ( num != 0 ) { digit = num % 10 ; num = num / 10 ; if ( digit == 0 N % digit != 0 ) return false ; } return true ; } int main ( ) { int N = 128 ; bool result = checkDivisbility ( N ) ; if ( result ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_same_digit ( int L , int R ) { int tmp = 0 , ans = 0 ; int n = log10 ( R ) + 1 ; for ( int i = 0 ; i < n ; i ++ ) { tmp = tmp * 10 + 1 ; for ( int j = 1 ; j <= 9 ; j ++ ) { if ( L <= ( tmp * j ) && ( tmp * j ) <= R ) { ans ++ ; } } } return ans ; } int main ( ) { int L = 12 , R = 68 ; cout << count_same_digit ( L , R ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minLCM ( int arr [ ] , int n ) { int mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mx = max ( mx , arr [ i ] ) ; } vector < vector < int > > mul ( mx + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mul [ arr [ i ] ] . size ( ) > 1 ) { continue ; } mul [ arr [ i ] ] . push_back ( arr [ i ] ) ; } for ( int i = 1 ; i <= mx ; i ++ ) { for ( int j = i + i ; j <= mx ; j += i ) { if ( mul [ i ] . size ( ) > 1 ) { break ; } for ( int k : mul [ j ] ) { if ( mul [ i ] . size ( ) > 1 ) break ; mul [ i ] . push_back ( k ) ; } } } int ans = INT_MAX ; for ( int i = 1 ; i <= mx ; i ++ ) { if ( mul [ i ] . size ( ) <= 1 ) continue ; int a = mul [ i ] [ 0 ] , b = mul [ i ] [ 1 ] ; int lcm = ( a * b ) / i ; ans = min ( ans , lcm ) ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 3 , 6 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minLCM ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findArrangement ( int N ) { if ( N < 3 ) return 0 ; return ( ( N ) * ( N - 1 ) * ( N - 2 ) ) / 3 ; } int main ( ) { int N = 10 ; cout << findArrangement ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void calc_ans ( ll l , ll r ) { vector < ll > power2 , power3 ; ll mul2 = 1 ; while ( mul2 <= r ) { power2 . push_back ( mul2 ) ; mul2 *= 2 ; } ll mul3 = 1 ; while ( mul3 <= r ) { power3 . push_back ( mul3 ) ; mul3 *= 3 ; } vector < ll > power23 ; for ( int x = 0 ; x < power2 . size ( ) ; x ++ ) { for ( int y = 0 ; y < power3 . size ( ) ; y ++ ) { ll mul = power2 [ x ] * power3 [ y ] ; if ( mul == 1 ) continue ; if ( mul <= r ) power23 . push_back ( mul ) ; } } ll ans = 0 ; for ( ll x : power23 ) { if ( x >= l && x <= r ) ans ++ ; } cout << ans << endl ; } int main ( ) { ll l = 1 , r = 10 ; calc_ans ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE #define int  unsigned long long NEW_LINE int inv ( int a ) { int o = 1 ; for ( int p = MOD - 2 ; p > 0 ; p >>= 1 ) { if ( ( p & 1 ) == 1 ) o = ( o * a ) % MOD ; a = ( a * a ) % MOD ; } return o ; } int inv6 = inv ( 6 ) ; int sumOfSquares ( int n ) { n %= MOD ; return ( ( ( n * ( n + 1 ) ) % MOD * ( 2 * n + 1 ) ) % MOD * inv6 ) % MOD ; } int sums ( int n ) { if ( n < 4 ) return 0 ; int curStart = 2 , ans = 0 ; int sqrtN = sqrt ( n ) ; while ( curStart <= n / curStart ) { int V = n / ( curStart * curStart ) ; int end = sqrt ( n / V ) ; ans += ( n / ( curStart * curStart ) % MOD * ( sumOfSquares ( end ) + MOD - sumOfSquares ( curStart - 1 ) ) ) % MOD ; if ( ans >= MOD ) ans -= MOD ; curStart = end + 1 ; } return ans ; } int32_t main ( ) { int input [ ] = { 5 } ; for ( auto x : input ) { cout << " sum ▁ of ▁ all ▁ perfect " << " ▁ square ▁ divisors ▁ from " << " ▁ 1 ▁ to ▁ " << x << " ▁ is : ▁ " ; cout << x + sums ( x ) << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; } bool CheckBinaryEquivalent ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; int c = pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } string bin = to_string ( B_Number ) ; return isSuffix ( "001" , bin ) ; } int main ( ) { int N = 9 ; if ( CheckBinaryEquivalent ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool CheckBinaryEquivalent ( int N ) { return ( N - 1 ) % 8 == 0 ; } int main ( ) { int N = 9 ; if ( CheckBinaryEquivalent ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > get_divisors ( int A ) { vector < int > ans ; ans . push_back ( 1 ) ; for ( int i = 2 ; i <= sqrt ( A ) ; i ++ ) { if ( A % i == 0 ) { ans . push_back ( i ) ; if ( ( i * i ) != A ) ans . push_back ( A / i ) ; } } return ans ; } bool Sum_Possible ( vector < int > set , int sum ) { int n = set . size ( ) ; bool subset [ n + 1 ] [ sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) subset [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) subset [ 0 ] [ i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { if ( j < set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] ; if ( j >= set [ i - 1 ] ) subset [ i ] [ j ] = subset [ i - 1 ] [ j ] || subset [ i - 1 ] [ j - set [ i - 1 ] ] ; } } return subset [ n ] [ sum ] ; } bool Is_Practical ( int A ) { vector < int > divisors ; divisors = get_divisors ( A ) ; for ( int i = 2 ; i < A ; i ++ ) { if ( Sum_Possible ( divisors , i ) == false ) return false ; } return true ; } void print_practica_No ( int A , int B ) { for ( int i = A ; i <= B ; i ++ ) { if ( Is_Practical ( i ) == true ) { cout << i << " ▁ " ; } } } int main ( ) { int A = 1 , B = 100 ; print_practica_No ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float maxDivision ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; float mxdiv = arr [ 1 ] ; for ( int i = 2 ; i < n ; ++ i ) mxdiv = mxdiv / arr [ i ] ; return arr [ 0 ] / mxdiv ; } int main ( ) { int arr [ ] = { 100 , 1000 , 10 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxDivision ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void coPrimeSet ( int n ) { int firstadj , secadj ; if ( n < 4 ) { cout << " ( ▁ " ; for ( int i = 1 ; i <= n ; i ++ ) cout << i << " , ▁ " ; cout << " ) STRNEWLINE " ; } else { if ( n % 2 == 0 ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { firstadj = 2 * i + 1 ; secadj = 2 * i + 2 ; cout << " ( " << firstadj << " , ▁ " << secadj << " ) STRNEWLINE " ; } } else { for ( int i = 0 ; i < n / 2 - 1 ; i ++ ) { firstadj = 2 * i + 1 ; secadj = 2 * i + 2 ; cout << " ( " << firstadj << " , ▁ " << secadj << " ) STRNEWLINE " ; } cout << " ( " << n - 2 << " , ▁ " << n - 1 << " , ▁ " << n << " ) STRNEWLINE " ; } } } int main ( ) { int n = 5 ; coPrimeSet ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int N = 21 ; int A = sqrt ( 2 * N + 0.25 ) - 0.5 ; int B = A ; if ( B != A ) cout << " - 1" ; else cout << B ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE #define ll  long long int NEW_LINE int power ( int x , unsigned int y ) { int p = 1000000007 ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } ll productPairs ( ll arr [ ] , ll n ) { ll product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = ( product % mod * ( int ) power ( arr [ i ] , ( 2 * n ) ) % mod ) % mod ; } return product % mod ; } int main ( ) { ll arr [ ] = { 1 , 2 , 3 } ; ll n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << productPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll operation ( int arr [ ] , int N ) { ll right = 0 , ans = 0 , num = 0 ; for ( ll left = 0 ; left < N ; left ++ ) { while ( right < N && num + arr [ right ] == ( num ^ arr [ right ] ) ) { num += arr [ right ] ; right ++ ; } ans += right - left ; if ( left == right ) right ++ ; else num -= arr [ left ] ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << operation ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool * sieveOfEratosthenes ( int N ) { bool * isPrime = new bool [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) { isPrime [ i ] = true ; } isPrime [ 0 ] = false ; isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( isPrime [ i ] == true ) { int j = 2 ; while ( i * j <= N ) { isPrime [ i * j ] = false ; j ++ ; } } } return isPrime ; } int numPairsWithPrimeSum ( int * arr , int n ) { int N = 2 * 1000000 ; bool * isPrime = sieveOfEratosthenes ( N ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( isPrime [ sum ] ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << numPairsWithPrimeSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digit [ 10 ] = { 0 } ; void digitsPresent ( int n ) { int lastDigit ; while ( n != 0 ) { lastDigit = n % 10 ; digit [ lastDigit ] = true ; n /= 10 ; } } int checkLastDigit ( int num ) { int count = 0 ; int lastDigit ; lastDigit = num % 10 ; if ( digit [ lastDigit ] == true ) count ++ ; return count ; } void findCount ( int N , int K , int arr [ ] ) { int count = 0 ; for ( int i = 0 ; i < K ; i ++ ) { count = checkLastDigit ( arr [ i ] ) == 1 ? count + 1 : count ; } cout << count << endl ; } int main ( ) { int N = 1731 ; digitsPresent ( N ) ; int K = 5 ; int arr [ ] = { 57 , 6786 , 1111 , 3 , 9812 } ; findCount ( N , K , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool divisorsSame ( int n ) { return ( n - 2 ) % 4 == 0 ; } int main ( ) { int N = 6 ; if ( divisorsSame ( N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( int K , int N ) { N -- ; while ( N -- ) { int curr_term = K ; int min_d = 9 ; int max_d = 0 ; while ( curr_term > 0 ) { int r = curr_term % 10 ; min_d = min ( min_d , r ) ; max_d = max ( max_d , r ) ; curr_term = curr_term / 10 ; } if ( min_d == 0 ) { break ; } K = K + min_d * max_d ; } return K ; } int main ( ) { int K = 487 ; int N = 2 ; cout << find ( K , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lli  long long int NEW_LINE lli countSubarrays ( int arr [ ] , int n ) { unordered_map < int , int > mp ; int prefixSum [ n ] ; int prefixMin = 0 ; prefixSum [ 0 ] = arr [ 0 ] ; prefixMin = min ( prefixMin , prefixSum [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; prefixMin = min ( prefixMin , prefixSum [ i ] ) ; } lli countSubs = 0 ; mp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; prefixSum [ i ] - j * j >= prefixMin ; j ++ ) { if ( mp . find ( prefixSum [ i ] - j * j ) != mp . end ( ) ) countSubs += mp [ prefixSum [ i ] - j * j ] ; } mp [ prefixSum [ i ] ] ++ ; } return countSubs ; } int main ( ) { int arr [ ] = { 2 , 3 , -5 , 6 , -7 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; lli ans = countSubarrays ( arr , n ) ; cout << ans ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool checkSolution ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { return ( a1 / a2 ) == ( b1 / b2 ) && ( b1 / b2 ) == ( c1 / c2 ) ; } int main ( ) { float a1 = 1 , b1 = -5 , c1 = 6 ; float a2 = 2 , b2 = -10 , c2 = 12 ; if ( checkSolution ( a1 , b1 , c1 , a2 , b2 , c2 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void checkSolution ( int a , int b , int c ) { if ( b == 0 ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int a = 2 , b = 0 , c = 2 ; checkSolution ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void positiveProduct ( int arr [ ] , int n ) { int even_count = 0 ; int odd_count = 0 ; int total_count = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( total_count % 2 == 0 ) even_count ++ ; else odd_count ++ ; if ( arr [ i ] < 0 ) total_count ++ ; if ( total_count % 2 == 0 ) ans += even_count ; else ans += odd_count ; } cout << ans << " STRNEWLINE " ; } int main ( ) { int A [ ] = { 5 , -3 , 3 , -1 , 1 } ; int size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; positiveProduct ( A , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int d , int n ) { int no = n / d ; int result = no ; for ( int p = 2 ; p * p <= no ; ++ p ) { if ( no % p == 0 ) { while ( no % p == 0 ) no /= p ; result -= result / p ; } } if ( no > 1 ) result -= result / no ; return result ; } int sumOfGCDofPairs ( int n ) { int res = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int d1 = i ; int d2 = n / i ; res += d1 * getCount ( d1 , n ) ; if ( d1 != d2 ) res += d2 * getCount ( d2 , n ) ; } } return res ; } int main ( ) { int n = 12 ; cout << sumOfGCDofPairs ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsFibonacci ( int arr [ ] , int n ) { if ( n == 1 n == 2 ) return true ; sort ( arr , arr + n ) ; for ( int i = 2 ; i < n ; i ++ ) if ( ( arr [ i - 1 ] + arr [ i - 2 ] ) != arr [ i ] ) return false ; return true ; } int main ( ) { int arr [ ] = { 8 , 3 , 5 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkIsFibonacci ( arr , n ) ) cout << " Yes " << endl ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lastDigit2PowerN ( int n ) { if ( n == 0 ) return 1 ; else if ( n % 4 == 1 ) return 2 ; else if ( n % 4 == 2 ) return 4 ; else if ( n % 4 == 3 ) return 8 ; else } int main ( ) { for ( int n = 0 ; n < 20 ; n ++ ) cout << lastDigit2PowerN ( n ) << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int countSubsequences ( int arr [ ] , int n ) { int totalSubsequence = pow ( 2 , n ) - 1 ; int countPrime = 0 , countOnes = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) countOnes ++ ; else if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } int compositeSubsequence ; int onesSequence = pow ( 2 , countOnes ) - 1 ; compositeSubsequence = totalSubsequence - countPrime - onesSequence - onesSequence * countPrime ; return compositeSubsequence ; } int main ( ) { int arr [ ] = { 2 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubsequences ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) ; int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int sumSubsequences ( int arr [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int kLengthSubSequence ; kLengthSubSequence = nCr ( n , k ) ; int ans = sum * ( ( k * kLengthSubSequence ) / n ) ; return ans ; } int main ( ) { int arr [ ] = { 7 , 8 , 9 , 2 } ; int K = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumSubsequences ( arr , n , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int n , int k ) { int val = ( k / ( n - 1 ) ) * n ; int rem = k % ( n - 1 ) ; if ( rem == 0 ) { val = val - 1 ; } else { val = val + rem ; } int sum = ( val * ( val + 1 ) ) / 2 ; int x = k / ( n - 1 ) ; int sum_of_multiples = ( x * ( x + 1 ) * n ) / 2 ; sum -= sum_of_multiples ; return sum ; } int main ( ) { int n = 7 , k = 13 ; cout << findSum ( n , k ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > getFactorization ( int x ) { int count = 0 ; vector < int > v ; while ( x % 2 == 0 ) { count ++ ; x = x / 2 ; } if ( count != 0 ) v . push_back ( count ) ; for ( int i = 3 ; i <= sqrt ( x ) ; i += 2 ) { count = 0 ; while ( x % i == 0 ) { count ++ ; x /= i ; } if ( count != 0 ) v . push_back ( count ) ; } if ( x > 1 ) { v . push_back ( 1 ) ; } return v ; } int nonPrimeDivisors ( int N ) { vector < int > v = getFactorization ( N ) ; int ret = 1 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ret = ret * ( v [ i ] + 1 ) ; ret = ret - v . size ( ) ; return ret ; } int main ( ) { int N = 8 ; cout << nonPrimeDivisors ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisible ( string s ) { int flag = 0 ; while ( s . size ( ) > 4 ) { int l = s . size ( ) - 1 ; int x = ( s [ l ] - '0' ) * 37 ; reverse ( s . begin ( ) , s . end ( ) ) ; s . erase ( 0 , 1 ) ; int i = 0 , carry = 0 ; while ( x ) { int d = ( s [ i ] - '0' ) - ( x % 10 ) - carry ; if ( d < 0 ) { d += 10 ; carry = 1 ; } else carry = 0 ; s [ i ] = ( char ) ( d + '0' ) ; x /= 10 ; i ++ ; } while ( carry && i < l ) { int d = ( s [ i ] - '0' ) - carry ; if ( d < 0 ) { d += 10 ; carry = 1 ; } else carry = 0 ; s [ i ] = ( char ) ( d + '0' ) ; i ++ ; } reverse ( s . begin ( ) , s . end ( ) ) ; } int num = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { num = num * 10 + ( s [ i ] - '0' ) ; } if ( num % 53 == 0 ) return true ; else return false ; } int main ( ) { string N = "18432462191076" ; if ( isDivisible ( N ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checksilverRatio ( float a , float b ) { if ( a < b ) swap ( a , b ) ; float ratio1 = ( ( a / b ) * 1000.0 ) / 1000.0 ; float ratio2 = ( int ) ( ( ( 2 * a + b ) / a ) * 1000 ) ; ratio2 = ratio2 / 1000 ; if ( ratio1 == ratio2 && ( int ) ( ratio1 - 2.414 ) == 0 ) { cout << " Yes STRNEWLINE " ; return true ; } else { cout << " No STRNEWLINE " ; return false ; } } int main ( ) { float a = 2.414 ; float b = 1 ; checksilverRatio ( a , b ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MIN ( int n ) { int ans = 11 ; while ( n ) { ans = min ( ans , n % 10 ) ; n /= 10 ; } return ans ; } int MAX ( int n ) { int ans = -1 ; while ( n ) { ans = max ( ans , n % 10 ) ; n /= 10 ; } return ans ; } void Find_value ( int n , int k ) { k -- ; int x = 0 ; int y = 0 ; while ( k -- ) { x = MIN ( n ) ; y = MAX ( n ) ; if ( y - x == 0 ) break ; n *= ( y - x ) ; } cout << n ; } int main ( ) { int N = 487 , D = 5 ; Find_value ( N , D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isdecagonal ( int N ) { float n = ( 3 + sqrt ( 16 * N + 9 ) ) / 8 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 10 ; if ( isdecagonal ( N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isOctadecagon ( int N ) { float n = ( 14 + sqrt ( 128 * N + 196 ) ) / 32 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 18 ; if ( isOctadecagon ( N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int countSubsequences ( int arr [ ] , int n , int k ) { int countPrime = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( arr [ i ] ) ) countPrime ++ ; } if ( countPrime < k ) return 0 ; return nCr ( countPrime , k ) * pow ( 2 , ( n - countPrime ) ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubsequences ( arr , n , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digSum ( int a ) { int sum = 0 ; while ( a ) { sum += a % 10 ; a = a / 10 ; } return sum ; } bool isPrime ( int r ) { bool s = true ; for ( int i = 2 ; i * i <= r ; i ++ ) { if ( r % i == 0 ) { s = false ; break ; } } return s ; } void moranNo ( int n ) { int dup = n ; int sum = digSum ( dup ) ; if ( n % sum == 0 ) { int c = n / sum ; if ( isPrime ( c ) ) { cout << " Yes " ; return ; } } cout << " No " << endl ; } int main ( ) { int n = 21 ; moranNo ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool ishendecagonal ( int N ) { float n = ( 7 + sqrt ( 72 * N + 49 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 11 ; if ( ishendecagonal ( N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool ishexadecagonal ( int N ) { float n = ( 12 + sqrt ( 112 * N + 144 ) ) / 28 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 16 ; if ( ishexadecagonal ( N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isnonagonal ( int N ) { float n = ( 5 + sqrt ( 56 * N + 25 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 9 ; if ( isnonagonal ( N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) ; int nCr ( int n , int r ) { if ( r > n ) return 0 ; return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int countSubsequences ( int arr [ ] , int n , int k ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) countOdd ++ ; } int ans = nCr ( n , k ) - nCr ( countOdd , k ) ; return ans ; } int main ( ) { int arr [ ] = { 2 , 4 } ; int K = 1 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubsequences ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divParts ( int N ) { if ( N % 2 == 0 ) cout << ( N / 2 ) - 1 << endl ; else cout << N / 2 << endl ; } int main ( ) { int N = 8 ; divParts ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArray ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << i << " ▁ " ; } } int main ( ) { int N = 5 ; constructArray ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCentereddecagonal ( int N ) { float n = ( 5 + sqrt ( 20 * N + 5 ) ) / 10 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int N = 11 ; if ( isCentereddecagonal ( N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i += 6 ) { if ( n % i == 0 || n % ( i + 6 ) == 0 ) { return false ; } } return true ; } bool SexyPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && abs ( n1 - n2 ) == 6 ) ; } int countSexyPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( SexyPrime ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 6 , 7 , 5 , 11 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSexyPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFirstNumIndex ( int & k , int n ) { if ( n == 1 ) return 0 ; n -- ; int first_num_index ; int n_partial_fact = n ; while ( k >= n_partial_fact && n > 1 ) { n_partial_fact = n_partial_fact * ( n - 1 ) ; n -- ; } first_num_index = k / n_partial_fact ; k = k % n_partial_fact ; return first_num_index ; } string findKthPermutation ( int n , int k ) { string ans = " " ; set < int > s ; for ( int i = 1 ; i <= n ; i ++ ) s . insert ( i ) ; set < int > :: iterator itr ; itr = s . begin ( ) ; k = k - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int index = findFirstNumIndex ( k , n - i ) ; advance ( itr , index ) ; ans += ( to_string ( * itr ) ) ; s . erase ( itr ) ; itr = s . begin ( ) ; } return ans ; } int main ( ) { int n = 3 , k = 4 ; string kth_perm_seq = findKthPermutation ( n , k ) ; cout << kth_perm_seq << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nDigitPerfectSquares ( int n , int b ) { int largest = pow ( ceil ( sqrt ( pow ( b , n ) ) ) - 1 , 2 ) ; cout << largest ; } int main ( ) { int N = 1 , B = 8 ; nDigitPerfectSquares ( N , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE double cubeRoot ( double n ) { double ans = pow ( 3 , ( 1.0 / 3 ) * ( log ( n ) / log ( 3 ) ) ) ; return ans ; } int main ( ) { double N = 8 ; printf ( " % .2lf ▁ " , cubeRoot ( N ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int floorMax ( int A , int B , int N ) { int x = min ( B - 1 , N ) ; return ( A * x ) / B ; } int main ( ) { int A = 11 , B = 10 , N = 9 ; cout << floorMax ( A , B , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int calculateMoves ( int n ) { int count = 0 ; int layers = n / 2 ; for ( int k = 1 ; k < layers + 1 ; k ++ ) { count += 8 * k * k ; } return count ; } int main ( ) { int N = 5 ; cout << calculateMoves ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSumSquare ( int N ) { float n = ( 2 + sqrt ( 8 * N - 4 ) ) / 2 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int i = 13 ; if ( isSumSquare ( i ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCenteredheptagonal ( int N ) { float n = ( 7 + sqrt ( 56 * N - 7 ) ) / 14 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int n = 8 ; if ( isCenteredheptagonal ( n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCenteredOctadecagonal ( int N ) { float n = ( 9 + sqrt ( 36 * N + 45 ) ) / 18 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int n = 19 ; if ( isCenteredOctadecagonal ( n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double kthRoot ( double n , int k ) { return pow ( k , ( 1.0 / k ) * ( log ( n ) / log ( k ) ) ) ; } int main ( ) { double N = 8.0 ; int K = 3 ; cout << kthRoot ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPower ( int N , int K ) { int res1 = log ( N ) / log ( K ) ; double res2 = log ( N ) / log ( K ) ; return ( res1 == res2 ) ; } int main ( ) { int N = 8 ; int K = 2 ; if ( isPower ( N , K ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxSize ( int a [ ] , int n ) { vector < int > frq ( n + 1 ) ; for ( int i = 0 ; i < n ; ++ i ) frq [ a [ i ] ] ++ ; int maxfrq = * max_element ( frq . begin ( ) , frq . end ( ) ) ; int dist = n + 1 - count ( frq . begin ( ) , frq . end ( ) , 0 ) ; int ans1 = min ( maxfrq - 1 , dist ) ; int ans2 = min ( maxfrq , dist - 1 ) ; int ans = max ( ans1 , ans2 ) ; return ans ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 1 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxSize ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countElement ( int arr [ ] , int n ) { map < int , int > freq ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { int tmpsum = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { tmpsum += arr [ j ] ; if ( freq . find ( tmpsum ) != freq . end ( ) ) { ans += freq [ tmpsum ] ; } } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countElement ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void first_digit ( int x , int y ) { int length = log ( x ) / log ( y ) + 1 ; int first_digit = x / pow ( y , length - 1 ) ; cout << first_digit ; } int main ( ) { int X = 55 , Y = 3 ; first_digit ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE double kthRoot ( double n , int k ) { return pow ( k , ( 1.0 / k ) * ( log ( n ) / log ( k ) ) ) ; } int main ( void ) { double n = 81 ; int k = 4 ; printf ( " % lf ▁ " , kthRoot ( n , k ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checksum ( int n , int k ) { float first_term = ( ( 2 * n ) / k + ( 1 - k ) ) / 2.0 ; if ( first_term - int ( first_term ) == 0 ) { for ( int i = first_term ; i <= first_term + k - 1 ; i ++ ) { cout << i << " ▁ " ; } } else cout << " - 1" ; } int main ( ) { int n = 33 , k = 6 ; checksum ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void distributeN ( int A , int B , int C , int n ) { int max1 = max ( A , B ) ; int max2 = max ( B , C ) ; int maximum = max ( max1 , max2 ) ; int sum = A + B + C ; int p = ( 3 * maximum ) - sum ; int diff = n - p ; if ( diff < 0 diff % 3 ) cout << " No " ; else cout << " Yes " ; } int main ( ) { int A = 10 , B = 20 ; int C = 15 , n = 14 ; distributeN ( A , B , C , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumOddNumbers ( int N , int K ) { int check = N - ( K - 1 ) ; if ( check > 0 && check % 2 == 1 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { cout << "1 ▁ " ; } cout << check ; } else cout << " - 1" ; } int main ( ) { int N = 5 ; int K = 3 ; sumOddNumbers ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LongestMountain ( vector < int > & a ) { int i = 0 , j = -1 , k = -1 , p = 0 , d = 0 , n = 0 ; if ( a . size ( ) < 3 ) { return 0 ; } for ( i = 0 ; i < a . size ( ) - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] ) { if ( k != -1 ) { k = -1 ; j = -1 ; } if ( j == -1 ) { j = i ; } } else { if ( a [ i + 1 ] < a [ i ] ) { if ( j != -1 ) { k = i + 1 ; } if ( k != -1 && j != -1 ) { if ( d < k - j + 1 ) { d = k - j + 1 ; } } } else { k = -1 ; j = -1 ; } } } if ( k != -1 && j != -1 ) { if ( d < k - j + 1 ) { d = k - j + 1 ; } } return d ; } int main ( ) { vector < int > d = { 1 , 3 , 1 , 4 , 5 , 6 , 7 , 8 , 9 , 8 , 7 , 6 , 5 } ; cout << LongestMountain ( d ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string solve ( vector < int > & A ) { int i , ctr = 0 ; for ( i = 0 ; i < A . size ( ) ; i ++ ) { if ( A [ i ] % 2 ) { ctr ++ ; } } if ( ctr % 2 ) { return " No " ; } else { return " Yes " ; } } int main ( ) { vector < int > arr = { 9 , 17 } ; cout << solve ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSquares ( int n ) { int r = ceil ( sqrt ( pow ( 10 , n ) ) ) ; int l = ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) ; return r - l ; } int main ( ) { int n = 3 ; cout << countSquares ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int summation ( int N ) { int co = ( N + 1 ) / 2 ; int ce = ( N ) / 2 ; int se = 2 * ( ( ce * ( ce + 1 ) ) * ( ce * ( ce + 1 ) ) ) ; int so = ( co * co ) * ( 2 * ( ( co * co ) ) - 1 ) ; return so - se ; } int main ( ) { int n = 3 ; cout << summation ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isStar ( int N ) { float n = ( 6 + sqrt ( 24 * N + 12 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int i = 13 ; if ( isStar ( i ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumEvenNumbers ( int N , int K ) { int check = N - 2 * ( K - 1 ) ; if ( check > 0 && check % 2 == 0 ) { for ( int i = 0 ; i < K - 1 ; i ++ ) { cout << "2 ▁ " ; } cout << check ; } else { cout << " - 1" ; } } int main ( ) { int N = 8 ; int K = 2 ; sumEvenNumbers ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int arr [ ] , int n ) { int count = 0 ; for ( int j = 1 ; j < n - 1 ; j ++ ) { int p = 0 , q = 0 ; for ( int i = 0 ; i < j ; i ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) p ++ ; } for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ k ] % arr [ j ] == 0 ) q ++ ; } count += p * q ; } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getCount ( arr , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float computeMaxValue ( float arr [ ] , int n ) { float ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { float val = max ( arr [ i ] / arr [ j ] , arr [ j ] / arr [ i ] ) ; ans = max ( ans , val ) ; } } return ans ; } int main ( ) { float arr [ ] = { 15 , 10 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << computeMaxValue ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkIfCurzonNumber ( int N ) { long int powerTerm , productTerm ; powerTerm = pow ( 2 , N ) + 1 ; productTerm = 2 * N + 1 ; if ( powerTerm % productTerm == 0 ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; } int main ( ) { long int N = 5 ; checkIfCurzonNumber ( N ) ; N = 10 ; checkIfCurzonNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int kthNonDivisible ( int N , int K ) { return K + floor ( ( K - 1 ) / ( N - 1 ) ) ; } int main ( ) { int N = 3 ; int K = 6 ; cout << kthNonDivisible ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int TEN = 10 ; int minCount ( int n ) { int hasharr [ TEN ] = { 10 , 3 , 6 , 9 , 2 , 5 , 8 , 1 , 4 , 7 } ; if ( n > 69 ) return hasharr [ n % TEN ] ; else { if ( n >= hasharr [ n % TEN ] * 7 ) return ( hasharr [ n % TEN ] ) ; else return -1 ; } } int main ( ) { int n = 38 ; cout << minCount ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void NumbertoCharacter ( int n ) { int rev = 0 , r = 0 ; while ( n > 0 ) { r = n % 10 ; rev = rev * 10 + r ; n = n / 10 ; } while ( rev > 0 ) { r = rev % 10 ; switch ( r ) { case 1 : cout << " one ▁ " ; break ; case 2 : cout << " two ▁ " ; break ; case 3 : cout << " three ▁ " ; break ; case 4 : cout << " four ▁ " ; break ; case 5 : cout << " five ▁ " ; break ; case 6 : cout << " six ▁ " ; break ; case 7 : cout << " seven ▁ " ; break ; case 8 : cout << " eight ▁ " ; break ; case 9 : cout << " nine ▁ " ; break ; case 0 : cout << " zero ▁ " ; break ; default : cout << " UnValid ▁ " ; break ; } rev = rev / 10 ; } } #include <iostream> NEW_LINE int main ( ) { int n = 12345 ; NumbertoCharacter ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int lli ; const int m = 4 ; long long int power ( lli x , lli y , lli p ) { lli res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } void nCr ( lli n , lli p , lli f [ ] [ m + 1 ] ) { for ( lli i = 0 ; i <= n ; i ++ ) { for ( lli j = 0 ; j <= m ; j ++ ) { if ( j > i ) f [ i ] [ j ] = 0 ; else if ( j == 0 j == i ) f [ i ] [ j ] = 1 ; else f [ i ] [ j ] = ( f [ i - 1 ] [ j ] + f [ i - 1 ] [ j - 1 ] ) % p ; } } } void operations ( lli arr [ ] , lli n , lli f [ ] [ m + 1 ] ) { lli p = 1000000007 ; nCr ( n , p - 1 , f ) ; sort ( arr , arr + n ) ; lli ans = 1 ; for ( lli i = 0 ; i < n ; i ++ ) { long long int x = 0 ; for ( lli j = 1 ; j <= m ; j ++ ) { if ( m % j == 0 ) x = ( x + ( f [ n - i - 1 ] [ m - j ] * f [ i ] [ j - 1 ] ) % ( p - 1 ) ) % ( p - 1 ) ; } ans = ( ( ans * power ( arr [ i ] , x , p ) ) % p ) ; } cout << ans << endl ; } int main ( ) { lli arr [ ] = { 4 , 5 , 7 , 9 , 3 } ; lli n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; lli f [ n + 1 ] [ m + 1 ] ; operations ( arr , n , f ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prodSquare ( int n ) { unordered_map < float , float > s ; for ( int i = 2 ; i * i <= n ; ++ i ) { s [ i * i ] = 1 ; if ( s . find ( n / ( i * i ) ) != s . end ( ) ) return true ; } return false ; } int main ( ) { int n = 25 ; if ( prodSquare ( n ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GetSum ( int n ) { vector < int > divisors ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { divisors . push_back ( i ) ; if ( i != n / i ) { divisors . push_back ( n / i ) ; } } } int ans = 1 ; for ( auto i : divisors ) { ans *= ( i + 1 ) ; } ans = ans - 1 ; return ans ; } int main ( ) { int N = 4 ; cout << GetSum ( N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > calculateWays ( int N ) { int x = 0 ; vector < int > v ; for ( int i = 0 ; i < N ; i ++ ) v . push_back ( 0 ) ; for ( int i = 0 ; i <= N / 2 ; i ++ ) { if ( N % 2 == 0 && i == N / 2 ) break ; x = N * ( i + 1 ) - ( i + 1 ) * i ; v [ i ] = x ; v [ N - i - 1 ] = x ; } return v ; } void printArray ( vector < int > v ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << " ▁ " ; } int main ( ) { vector < int > v ; v = calculateWays ( 4 ) ; printArray ( v ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } int longestPowerfulSubsequence ( int arr [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerful ( arr [ i ] ) ) answer ++ ; } return answer ; } int main ( ) { int arr [ ] = { 6 , 4 , 10 , 13 , 9 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestPowerfulSubsequence ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxOR ( int arr [ ] , int n ) { int max_value = * max_element ( arr , arr + n ) ; int number_of_bits = floor ( log2 ( max_value ) ) + 1 ; int complement = ( ( 1 << number_of_bits ) - 1 ) ^ max_value ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != max_value ) { c = max ( c , ( complement & arr [ i ] ) ) ; } } return ( max_value + c ) ; } int main ( ) { int arr [ ] = { 3 , 6 , 8 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxOR ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void update ( int res [ ] , int L , int R , int K ) { L -= 1 ; R -= 1 ; res [ L ] ^= K ; res [ R + 1 ] ^= K ; } void display ( int arr [ ] , int res [ ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { res [ i ] = res [ i ] ^ res [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ( arr [ i ] ^ res [ i ] ) << " ▁ " ; } cout << endl ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int res [ N ] ; memset ( res , 0 , sizeof ( res ) ) ; int L = 1 , R = 3 , K = 2 ; update ( res , L , R , K ) ; L = 2 ; R = 4 ; K = 3 ; update ( res , L , R , K ) ; display ( arr , res , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int a [ ] , int n , int k ) { map < int , int > m ; int extra = 0 ; for ( int i = k ; i < n ; i ++ ) m [ a [ i ] ] ++ ; for ( auto x : m ) extra += x . second - 1 ; if ( extra == 0 ) return true ; for ( int i = 1 ; i + k - 1 < n ; i ++ ) { if ( m [ a [ i + k - 1 ] ] > 1 ) extra -- ; m [ a [ i + k - 1 ] ] -- ; m [ a [ i - 1 ] ] ++ ; if ( m [ a [ i - 1 ] ] > 1 ) extra ++ ; if ( extra == 0 ) return true ; } return false ; } int minlength ( int a [ ] , int n ) { int lo = 0 , hi = n + 1 ; int ans = 0 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( check ( a , n , mid ) ) { ans = mid ; hi = mid ; } else lo = mid + 1 ; } return ans ; } int main ( ) { int a [ 5 ] = { 1 , 2 , 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << minlength ( a , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  10000000 NEW_LINE int sumOfDigits ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n /= 10 ; } return sum ; } int smallestNum ( int X , int Y ) { int res = -1 ; for ( int i = X ; i < MAXN ; i ++ ) { int sum_of_digit = sumOfDigits ( i ) ; if ( sum_of_digit % Y == 0 ) { res = i ; break ; } } return res ; } int main ( ) { int X = 5923 , Y = 13 ; cout << smallestNum ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateBill ( int units ) { if ( units <= 100 ) { return units * 10 ; } else if ( units <= 200 ) { return ( 100 * 10 ) + ( units - 100 ) * 15 ; } else if ( units <= 300 ) { return ( 100 * 10 ) + ( 100 * 15 ) + ( units - 200 ) * 20 ; } else if ( units > 300 ) { return ( 100 * 10 ) + ( 100 * 15 ) + ( 100 * 20 ) + ( units - 300 ) * 25 ; } return 0 ; } int main ( ) { int units = 250 ; cout << calculateBill ( units ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void factors ( int n ) { int i , j ; cout << "1 ▁ - - > 1 STRNEWLINE " ; for ( i = 2 ; i <= n ; i ++ ) { cout << i << " ▁ - - > " ; for ( j = 1 ; j <= i / 2 ; j ++ ) { if ( i % j == 0 ) cout << j << " , ▁ " ; } cout << i << " STRNEWLINE " ; } } int main ( ) { int n = 5 ; factors ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void factors ( int n ) { int i , j ; cout << "1 ▁ - - > 1 STRNEWLINE " ; for ( i = 2 ; i <= n ; i ++ ) { cout << i << " ▁ - - > " ; for ( j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { cout << j << " , ▁ " ; if ( i / j != j ) cout << i / j << " , ▁ " ; } } cout << " STRNEWLINE " ; } } int main ( ) { int n = 5 ; factors ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1e5 ; vector < int > divisor [ MAX + 1 ] ; void sieve ( ) { for ( int i = 1 ; i <= MAX ; ++ i ) { for ( int j = i ; j <= MAX ; j += i ) divisor [ j ] . push_back ( i ) ; } } void findNFactors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { cout << i << " - - > " ; for ( auto & divi : divisor [ i ] ) { cout << divi << " , ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 5 ; sieve ( ) ; findNFactors ( n ) ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int countPrimeFactors ( int n ) { if ( n == 1 ) return 0 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { cnt ++ ; n = n / i ; } } if ( n > 2 ) cnt ++ ; return cnt ; } int main ( ) { int x = 8 ; int prime_factor_cnt = countPrimeFactors ( x ) ; cout << prime_factor_cnt << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPalindromic ( int n ) { int count ; if ( n % 2 == 1 ) { count = pow ( 9 , ( n - 1 ) / 2 ) ; } else { count = pow ( 9 , ( n - 2 ) / 2 ) ; } return count ; } int main ( ) { int n = 3 ; cout << countPalindromic ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubArrayWithOddProduct ( int * A , int N ) { int count = 0 ; int last = -1 ; int K = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) { K = ( i - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; last = i ; } } K = ( N - last - 1 ) ; count += ( K * ( K + 1 ) / 2 ) ; return count ; } int main ( ) { int arr [ ] = { 12 , 15 , 7 , 3 , 25 , 6 , 2 , 1 , 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubArrayWithOddProduct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinXORSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } cout << min_xor << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 3 , 7 , 90 , 20 , 10 , 50 , 40 } ; int n = sizeof arr / sizeof arr [ 0 ] ; findMinXORSubarray ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string getNumber ( int a , int b ) { string X = to_string ( a ) ; string Y = to_string ( b ) ; string XY = X + Y ; string YX = Y + X ; return XY > YX ? XY : YX ; } void printMaxPair ( int arr [ ] , int n ) { int largest = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int number = stoi ( getNumber ( arr [ i ] , arr [ j ] ) ) ; largest = max ( largest , number ) ; } cout << largest ; } int main ( ) { int a [ ] = { 23 , 14 , 16 , 25 , 3 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printMaxPair ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void findMaxPrimeDivisor ( int n ) { int max_possible_prime = 0 ; while ( n % 2 == 0 ) { max_possible_prime ++ ; n = n / 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { max_possible_prime ++ ; n = n / i ; } } if ( n > 2 ) { max_possible_prime ++ ; } cout << max_possible_prime << " STRNEWLINE " ; } int main ( ) { int n = 4 ; findMaxPrimeDivisor ( n ) ; return 0 ; }
#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int previousPerfectSquare ( int N ) { int prevN = floor ( sqrt ( N ) ) ; if ( prevN * prevN == N ) prevN -= 1 ; return prevN * prevN ; } int previousPerfectCube ( int N ) { int prevN = floor ( cbrt ( N ) ) ; if ( prevN * prevN * prevN == N ) prevN -= 1 ; return prevN * prevN * prevN ; } int main ( ) { int n = 30 ; cout << previousPerfectSquare ( n ) << " STRNEWLINE " ; cout << previousPerfectCube ( n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCount ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] % 2 == 0 ) && ( arr [ j ] % 2 == 1 ) ) { res ++ ; } return res ; } int main ( ) { int a [ ] = { 5 , 4 , 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findCount ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCount ( int arr [ ] , int n ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count ++ ; else ans = ans + count ; } return ans ; } int main ( ) { int a [ ] = { 5 , 4 , 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findCount ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long product ( int arr [ ] , int n ) { double occurrence = pow ( 2 , n - 1 ) ; double product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product *= pow ( arr [ i ] , occurrence ) ; } return ( long ) product ; } int main ( ) { int arr [ ] = { 10 , 3 , 7 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << product ( arr , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int MOD = 1000000007 ; long long int power ( long long int a , long long int b ) { if ( b == 0 ) return 1 ; long long int temp = power ( a , b / 2 ) ; temp = ( temp * temp ) % MOD ; if ( b % 2 != 0 ) { temp = ( temp * a ) % MOD ; } return temp ; } void palindromicSum ( int N ) { long long int sum = 0 , res , ways ; if ( N == 1 ) { cout << "9" << endl ; return ; } if ( N == 2 ) { cout << "99" << endl ; return ; } ways = N / 2 ; if ( N % 2 == 0 ) ways -- ; res = power ( 9 , ways - 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { sum = sum * 10 + 45 * res ; sum %= MOD ; } cout << sum << endl ; } int main ( ) { int N = 3 ; palindromicSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int joinNumbers ( int numA , int numB ) { int revB = 0 ; while ( numB > 0 ) { revB = revB * 10 + ( numB % 10 ) ; numB = numB / 10 ; } while ( revB > 0 ) { numA = numA * 10 + ( revB % 10 ) ; revB = revB / 10 ; } return numA ; } int findMaxSum ( int A [ ] , int B [ ] , int n ) { int maxArr [ n ] ; for ( int i = 0 ; i < n ; ++ i ) { int X = joinNumbers ( A [ i ] , B [ i ] ) ; int Y = joinNumbers ( B [ i ] , A [ i ] ) ; int mx = max ( X , Y ) ; maxArr [ i ] = mx ; } int maxAns = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxAns += maxArr [ i ] ; } return maxAns ; } int main ( ) { int N = 5 ; int A [ 5 ] = { 11 , 23 , 38 , 43 , 59 } ; int B [ 5 ] = { 36 , 24 , 17 , 40 , 56 } ; cout << findMaxSum ( A , B , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE void createSets ( ll n ) { if ( n <= 2 ) { cout << " - 1" ; return ; } else { ll x = ( n % 2 == 0 ) ? ( n / 2 ) : ( ( n + 1 ) / 2 ) ; cout << x << endl ; for ( ll i = 1 ; i <= n ; i ++ ) { if ( i == x ) continue ; cout << i << " ▁ " ; } } return ; } int main ( ) { ll N = 7 ; createSets ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int calcCount ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( k % arr [ i ] == 0 ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 6 ; cout << calcCount ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void modifiedBinaryPattern ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( j == 1 j == i ) cout << 1 ; else cout << 0 ; } cout << endl ; } } int main ( ) { int n = 7 ; modifiedBinaryPattern ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfect ( long long int n ) { long long int sum = 1 ; for ( long long int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; } int contiguousPerfectNumber ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPerfect ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; } int main ( ) { int arr [ ] = { 1 , 7 , 36 , 4 , 6 , 28 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << contiguousPerfectNumber ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } int contiguousPowerfulNumber ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerful ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; } int main ( ) { int arr [ ] = { 1 , 7 , 36 , 4 , 6 , 28 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << contiguousPowerfulNumber ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int K , int start , int end , int max_sum ) { if ( K == 0 ) return max_sum ; int max_sum_start = max_sum + arr [ start ] ; int max_sum_end = max_sum + arr [ end ] ; int ans = max ( maxSum ( arr , K - 1 , start + 1 , end , max_sum_start ) , maxSum ( arr , K - 1 , start , end - 1 , max_sum_end ) ) ; return ans ; } void maximizeSum ( int arr [ ] , int K , int n ) { int max_sum = 0 ; int start = 0 ; int end = n - 1 ; cout << maxSum ( arr , K , start , end , max_sum ) ; } int main ( ) { int arr [ ] = { 8 , 4 , 4 , 8 , 12 , 3 , 2 , 9 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximizeSum ( arr , K , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPointCount ( int arr [ ] , int K , int size ) { int curr_points = 0 ; int max_points = 0 ; for ( int i = 0 ; i < K ; i ++ ) curr_points += arr [ i ] ; max_points = curr_points ; int j = size - 1 ; for ( int i = K - 1 ; i >= 0 ; i -- ) { curr_points = curr_points + arr [ j ] - arr [ i ] ; max_points = max ( curr_points , max_points ) ; j -- ; } return max_points ; } int main ( ) { int arr [ ] = { 8 , 4 , 4 , 8 , 12 , 3 , 2 , 9 } ; int K = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxPointCount ( arr , K , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPalindrome ( int n ) { int count ; if ( n % 2 == 1 ) { count = pow ( 9 , ( n - 1 ) / 2 ) ; } else { count = pow ( 9 , ( n - 2 ) / 2 ) ; } return count ; } int sumPalindrome ( int n ) { int count = countPalindrome ( n ) ; int res = 0 ; if ( n == 1 ) return 9 ; if ( n == 2 ) return 99 ; for ( int i = 0 ; i < n ; i ++ ) { res = res * 10 + count * 5 ; } return res ; } int main ( ) { int n = 3 ; cout << sumPalindrome ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int N , int B ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += ( B - 1 ) * pow ( B , i - 1 ) ; } return sum ; } int main ( ) { int N = 2 , B = 10 ; cout << count ( N , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long SmallestPerfectSquare ( long N ) { long X = ( long ) 1e9 ; long ans ; for ( int i = 1 ; i < sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) { long a = i ; long b = N / i ; if ( ( b - a != 0 ) && ( ( b - a ) % 2 == 0 ) ) { X = min ( X , ( b - a ) / 2 ) ; } } } if ( X != 1e9 ) ans = X * X ; else ans = -1 ; return ans ; } int main ( ) { long N = 3 ; cout << SmallestPerfectSquare ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int arr [ ] , int n , int circumference ) { sort ( arr , arr + n ) ; int arr2 [ 2 * n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr2 [ i ] = arr [ i ] ; arr2 [ i + n ] = arr [ i ] + circumference ; } int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) res = min ( res , arr2 [ i + ( n - 1 ) ] - arr2 [ i ] ) ; return res ; } int main ( ) { int arr [ ] = { 19 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int circumference = 20 ; cout << minCost ( arr , n , circumference ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountWays ( int n ) { int ans = ( n - 1 ) / 2 ; return ans ; } int main ( ) { int N = 8 ; cout << CountWays ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumGCD ( int arr [ ] , int n ) { int g = 0 ; for ( int i = 0 ; i < n ; i ++ ) { g = __gcd ( g , arr [ i ] ) ; } return g ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinimumGCD ( arr , N ) << endl ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int stepRequired ( int N ) { int cnt = 0 ; while ( N ) { N = N & ( N - 1 ) ; cnt ++ ; } return cnt ; } int main ( ) { int N = 23 ; cout << stepRequired ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; } bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; } void fibonacciSubarrays ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int sum = 0 ; for ( int j = i ; j < n ; ++ j ) { sum += arr [ j ] ; if ( isFibonacci ( sum ) ) { ++ count ; } } } cout << count ; } int main ( ) { int arr [ ] = { 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; fibonacciSubarrays ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define mod  1000000007 NEW_LINE #define int  long long NEW_LINE using namespace std ; int factorial [ 100005 ] ; void StoreFactorials ( int n ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { factorial [ i ] = ( i * factorial [ i - 1 ] ) % mod ; } } int Power ( int x , int y ) { int ans = 1 ; while ( y > 0 ) { if ( y % 2 == 1 ) { ans = ( ans * x ) % mod ; } x = ( x * x ) % mod ; y /= 2 ; } return ans ; } int invmod ( int x ) { return Power ( x , mod - 2 ) ; } int nCr ( int n , int r ) { return ( factorial [ n ] * invmod ( ( factorial [ r ] * factorial [ n - r ] ) % mod ) ) % mod ; } int CountWays ( int n , int k ) { StoreFactorials ( n ) ; int ans = 0 ; for ( int i = k ; i >= 0 ; i -- ) { if ( i % 2 == k % 2 ) { ans = ( ans + ( Power ( i , n ) * nCr ( k , i ) ) % mod ) % mod ; } else { ans = ( ans + mod - ( Power ( i , n ) * nCr ( k , i ) ) % mod ) % mod ; } } ans = ( ans * nCr ( n , k ) ) % mod ; return ans ; } signed main ( ) { int N = 5 ; int K = 5 ; cout << CountWays ( N , K ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintReverseOrder ( int N ) { if ( N <= 0 ) { return ; } else { cout << N << " ▁ " ; PrintReverseOrder ( N - 1 ) ; } } int main ( ) { int N = 5 ; PrintReverseOrder ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void XOROfElements ( int arr [ ] , int n ) { int FirstHalfXOR = 0 ; int SecondHalfXOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) FirstHalfXOR ^= arr [ i ] ; else SecondHalfXOR ^= arr [ i ] ; } cout << FirstHalfXOR << " , " << SecondHalfXOR << endl ; } int main ( ) { int arr [ ] = { 20 , 30 , 50 , 10 , 55 , 15 , 42 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; XOROfElements ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int modInverse ( int n , int p ) { return power ( n , p - 2 , p ) ; } int nCrModPFermat ( int n , int r , int p ) { if ( r == 0 ) return 1 ; if ( n < r ) return 0 ; int fac [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; } int SumOfXor ( int a [ ] , int n ) { int mod = 10037 ; int answer = 0 ; for ( int k = 0 ; k < 32 ; k ++ ) { int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & ( 1 << k ) ) x ++ ; else y ++ ; } answer += ( ( 1 << k ) % mod * ( nCrModPFermat ( x , 3 , mod ) + x * nCrModPFermat ( y , 2 , mod ) ) % mod ) % mod ; } return answer ; } int main ( ) { int n = 5 ; int A [ n ] = { 3 , 5 , 2 , 18 , 7 } ; cout << SumOfXor ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE int phi [ N ] ; int pref [ N ] ; void precompute ( ) { phi [ 1 ] = 0 ; for ( int i = 2 ; i < N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } } void prefix ( ) { for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + phi [ i ] ; } void find_pairs ( int n ) { int total = ( n * ( n - 1 ) ) / 2 ; int ans = total - pref [ n ] ; cout << " Number ▁ of ▁ pairs ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ are ▁ " << ans << endl ; } int main ( ) { precompute ( ) ; prefix ( ) ; int q [ ] = { 5 , 7 } ; int n = sizeof ( q ) / sizeof ( q [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) { find_pairs ( q [ i ] ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void balance ( int x , int y , int p , int q ) { int b1 , b2 , b3 ; if ( p % x == 0 && q % y == 0 ) { b1 = p / x ; b2 = q / y ; b3 = 1 ; } else { p = p * y ; q = q * x ; b3 = x * y ; int temp = gcd ( p , gcd ( q , b3 ) ) ; b1 = p / temp ; b2 = q / temp ; b3 = b3 / temp ; } cout << b1 << " ▁ " << b2 << " ▁ " << b3 << endl ; } int main ( ) { int x = 2 , y = 3 , p = 4 , q = 5 ; balance ( x , y , p , q ) ; }
#include <iostream> NEW_LINE using namespace std ; int maxAlternatingSum ( int arr [ ] , int n ) { int max_sum = 0 ; int i = 0 ; while ( i < n ) { int current_max = arr [ i ] ; int k = i ; while ( k < n && ( ( arr [ i ] > 0 && arr [ k ] > 0 ) || ( arr [ i ] < 0 && arr [ k ] < 0 ) ) ) { current_max = max ( current_max , arr [ k ] ) ; k += 1 ; } max_sum += current_max ; i = k ; } return max_sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , -1 , -2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxAlternatingSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int subarrayLength ( int A [ ] , int R [ ] [ 2 ] , int N , int M ) { for ( int i = 0 ; i < M ; ++ i ) { int l = R [ i ] [ 0 ] , r = R [ i ] [ 1 ] + 1 ; l -- ; r -- ; A [ l ] ++ ; if ( r < N ) A [ r ] -- ; } for ( int i = 1 ; i < N ; ++ i ) { A [ i ] += A [ i - 1 ] ; } int count = 0 ; unordered_set < int > s ; for ( int i = 0 ; i < N ; ++ i ) { if ( s . find ( A [ i ] ) == s . end ( ) ) count ++ ; s . insert ( A [ i ] ) ; } vector < int > repeat ( count + 1 , 0 ) ; int ans = N ; int counter = 0 , left = 0 , right = 0 ; while ( right < N ) { int cur_element = A [ right ] ; repeat [ cur_element ] += 1 ; if ( repeat [ cur_element ] == 1 ) ++ counter ; while ( counter == count ) { ans = min ( ans , right - left + 1 ) ; cur_element = A [ left ] ; repeat [ cur_element ] -= 1 ; ++ left ; if ( repeat [ cur_element ] == 0 ) -- counter ; } ++ right ; } return ans ; } int main ( ) { int N = 8 , queries = 6 ; int Q [ ] [ 2 ] = { { 1 , 4 } , { 3 , 4 } , { 4 , 5 } , { 5 , 5 } , { 7 , 8 } , { 8 , 8 } } ; int A [ N ] = { 0 } ; cout << subarrayLength ( A , Q , N , queries ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ModifiedSieveOfEratosthenes ( int N , bool Expo_Prime [ ] ) { bool primes [ N ] ; memset ( primes , true , sizeof ( primes ) ) ; for ( int i = 2 ; i < N ; i ++ ) { if ( primes [ i ] ) { int no = i ; while ( no <= N ) { Expo_Prime [ no ] = true ; no *= i ; } for ( int j = i * i ; j < N ; j += i ) primes [ j ] = false ; } } } void Display ( int arr [ ] , bool Expo_Prime [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( Expo_Prime [ arr [ i ] ] ) cout << arr [ i ] << " ▁ " ; } void FindExpoPrime ( int arr [ ] , int n ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } bool Expo_Prime [ max + 1 ] ; memset ( Expo_Prime , false , sizeof ( Expo_Prime ) ) ; ModifiedSieveOfEratosthenes ( max + 1 , Expo_Prime ) ; Display ( arr , Expo_Prime , n ) ; } int main ( ) { int arr [ ] = { 4 , 6 , 9 , 16 , 1 , 3 , 12 , 36 , 625 , 1000 } ; int n = sizeof ( arr ) / sizeof ( int ) ; FindExpoPrime ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubarray ( int n ) { return ( ( n ) * ( n + 1 ) ) / 2 ; } int countSubsequence ( int n ) { return pow ( 2 , n ) ; } int main ( ) { int n = 5 ; cout << ( countSubarray ( n ) ) << endl ; cout << ( countSubsequence ( n ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float y ( float x ) { return ( 1 / ( 1 + x ) ) ; } float BooleRule ( float a , float b ) { int n = 4 ; int h ; h = ( ( b - a ) / n ) ; float sum = 0 ; float bl = ( ( 7 * y ( a ) + 32 * y ( a + h ) + 12 * y ( a + 2 * h ) + 32 * y ( a + 3 * h ) + 7 * y ( a + 4 * h ) ) * 2 * h / 45 ) ; sum = sum + bl ; return sum ; } int main ( ) { float lowlimit = 0 ; float upplimit = 4 ; cout << fixed << setprecision ( 4 ) << " f ( x ) ▁ = ▁ " << BooleRule ( 0 , 4 ) ; return 0 ; }
#include <cstdio> NEW_LINE #include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void convertToDecimal ( int N ) { cout << " Decimal ▁ number ▁ of ▁ " << N << " ▁ is : ▁ " ; if ( N != 0 ) { int decimalNumber = 0 , i = 0 , remainder ; while ( N != 0 ) { remainder = N % 10 ; N /= 10 ; decimalNumber += remainder * pow ( 3 , i ) ; ++ i ; } cout << decimalNumber << endl ; } else cout << "0" << endl ; } int main ( ) { int Ternary = 10202202 ; convertToDecimal ( Ternary ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int N ) { double sr = sqrt ( N ) ; return ( sr - floor ( sr ) ) == 0 ; } void BetrothedNumbers ( int n , int m ) { int Sum1 = 1 ; int Sum2 = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { Sum1 += i + ( isPerfectSquare ( n ) ? 0 : n / i ) ; } } for ( int i = 2 ; i <= sqrt ( m ) ; i ++ ) { if ( m % i == 0 ) { Sum2 += i + ( isPerfectSquare ( m ) ? 0 : m / i ) ; } } if ( ( n + 1 == Sum2 ) && ( m + 1 == Sum1 ) ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } int main ( ) { int N = 9504 ; int M = 20734 ; BetrothedNumbers ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float getPercentile ( int rank , int students ) { float result = float ( students - rank ) / students * 100 ; return result ; } int main ( ) { int your_rank = 805 ; int total_students = 97481 ; cout << getPercentile ( your_rank , total_students ) ; }
#include <iostream> NEW_LINE using namespace std ; void sumOfPrevK ( int N , int K ) { int arr [ N ] , prevsum = 0 ; arr [ 0 ] = 1 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( i < K ) { arr [ i + 1 ] = arr [ i ] + prevsum ; prevsum = arr [ i + 1 ] ; } else { arr [ i + 1 ] = arr [ i ] + prevsum - arr [ i + 1 - K ] ; prevsum = arr [ i + 1 ] ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } int main ( ) { int N = 8 , K = 3 ; sumOfPrevK ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } void findMaxGCD ( int arr [ ] , int n ) { int maxGCD = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int val = gcd ( arr [ i ] , arr [ i + 1 ] ) ; if ( val > maxGCD ) { maxGCD = val ; } } cout << maxGCD << endl ; } int main ( ) { int arr [ ] = { 3 , 18 , 9 , 9 , 5 , 15 , 8 , 7 , 6 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMaxGCD ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float round ( float var , int digit ) { float value = ( int ) ( var * pow ( 10 , digit ) + .5 ) ; return ( float ) value / pow ( 10 , digit ) ; } int probability ( int N ) { int a = 2 ; int b = 3 ; if ( N == 1 ) { return a ; } else if ( N == 2 ) { return b ; } else { for ( int i = 3 ; i <= N ; i ++ ) { int c = a + b ; a = b ; b = c ; } return b ; } } float operations ( int N ) { int x = probability ( N ) ; int y = pow ( 2 , N ) ; return round ( ( float ) x / ( float ) y , 2 ) ; } int main ( ) { int N = 10 ; cout << ( operations ( N ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float y ( float x ) { float num = 1 ; float denom = 1.0 + x * x ; return num / denom ; } float WeedleRule ( float a , float b ) { double h = ( b - a ) / 6 ; float sum = 0 ; sum = sum + ( ( ( 3 * h ) / 10 ) * ( y ( a ) + y ( a + 2 * h ) + 5 * y ( a + h ) + 6 * y ( a + 3 * h ) + y ( a + 4 * h ) + 5 * y ( a + 5 * h ) + y ( a + 6 * h ) ) ) ; return sum ; } int main ( ) { float a = 0 , b = 6 ; cout << " f ( x ) ▁ = ▁ " << fixed << WeedleRule ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int findSmallest ( int N ) { if ( N == 0 ) return 2 ; if ( N == 1 ) return 1 ; int prime = N , counter = 0 ; bool found = false ; while ( ! found ) { if ( isPrime ( prime ) ) found = true ; else { prime ++ ; counter ++ ; } } return counter ; } int main ( ) { int N = 10 ; cout << findSmallest ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPermutation ( int arr [ ] , int n ) { long long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; long long prefix [ n + 1 ] = { 0 } ; prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long long lsum = prefix [ i ] ; long long rsum = sum - prefix [ i ] ; long long l_len = i + 1 , r_len = n - i - 1 ; if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) && ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) return true ; } return false ; } void printPermutations ( int arr [ ] , int n , int l1 , int l2 ) { for ( int i = 0 ; i < l1 ; i ++ ) { cout << arr [ i ] << " ▁ " ; } cout << endl ; for ( int i = l1 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } void findPermutations ( int arr [ ] , int n ) { if ( ! checkPermutation ( arr , n ) ) { cout << " Not ▁ Possible " ; return ; } int l1 = 0 , l2 = 0 ; l1 = * max_element ( arr , arr + n ) ; l2 = n - l1 ; set < int > s1 , s2 ; for ( int i = 0 ; i < l1 ; i ++ ) s1 . insert ( arr [ i ] ) ; for ( int i = l1 ; i < n ; i ++ ) s2 . insert ( arr [ i ] ) ; if ( s1 . size ( ) == l1 && s2 . size ( ) == l2 ) printPermutations ( arr , n , l1 , l2 ) ; else { swap ( l1 , l2 ) ; printPermutations ( arr , n , l1 , l2 ) ; } } int main ( ) { int arr [ ] = { 2 , 1 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 1 , 10 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; findPermutations ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = max ( l , a ) ; int R = min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += pow ( i , i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; } int main ( ) { int l = 98 , r = 102 ; cout << rangeSum ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int TrialDivision ( int N ) { int i = 2 ; int k = ceil ( sqrt ( N ) ) ; while ( i <= k ) { if ( N % i == 0 ) return 0 ; i += 1 ; } return 1 ; } int main ( ) { int N = 49 ; int p = TrialDivision ( N ) ; if ( p ) cout << ( " Prime " ) ; else cout << ( " Composite " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pairs ( int n ) { vector < vector < int > > c ( 10 , vector < int > ( 10 , 0 ) ) ; int tmp = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= tmp * 10 ) tmp *= 10 ; c [ i / tmp ] [ i % 10 ] ++ ; } long long ans = 0 ; for ( int i = 1 ; i < 10 ; i ++ ) for ( int j = 1 ; j < 10 ; j ++ ) ans += ( long long ) c [ i ] [ j ] * c [ j ] [ i ] ; return ans ; } int main ( ) { int n = 25 ; cout << pairs ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int A , int B , int C ) { int minAddA = max ( 0 , ( C + B - A + 2 ) / 2 ) ; int count_ways = max ( C - minAddA + 1 , 0 ) ; return count_ways ; } int main ( ) { int A = 3 , B = 5 , C = 5 ; cout << countWays ( A , B , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } int gcdFibonacciFreq ( int arr [ ] , int n ) { set < int > hash ; createHash ( hash , * max_element ( arr , arr + n ) ) ; int i , j ; unordered_map < int , int > m ; for ( i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int gcd = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( hash . find ( it -> second ) != hash . end ( ) ) { gcd = __gcd ( gcd , it -> first ) ; } } return gcd ; } int main ( ) { int arr [ ] = { 5 , 3 , 6 , 5 , 6 , 6 , 5 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << gcdFibonacciFreq ( arr , n ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; void printSeries ( int N ) { int ith_term = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { ith_term = i % 2 == 0 ? 2 * i * i + 1 : 2 * i * i - 1 ; cout << ith_term << " , ▁ " ; } } int main ( ) { int N = 7 ; printSeries ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNthTerm ( int N ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { ans = ans + 6 ; } else { ans = ans + 2 ; } } cout << ans << endl ; } int main ( ) { int N = 3 ; findNthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSeriesSum ( int N ) { long long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += pow ( i , i - 1 ) ; } cout << sum << endl ; } int main ( ) { int N = 5 ; printSeriesSum ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printSumSeries ( int N ) { float sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 1.0 / ( 2 * i - 1 ) ; } cout << sum << endl ; } int main ( ) { int N = 6 ; printSumSeries ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printSeriesSum ( int N ) { double sum = 0 ; int a = 1 ; int cnt = 0 ; bool flag = true ; sum += a ; while ( cnt < N ) { int nextElement ; if ( flag ) { nextElement = a * 2 ; sum += nextElement ; flag = ! flag ; } else { nextElement = a * 3 / 2 ; sum += nextElement ; flag = ! flag ; } a = nextElement ; cnt ++ ; } cout << sum << endl ; } int main ( ) { int N = 8 ; printSeriesSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinimumSwapOperations ( string s ) { bool zero_exist = false ; bool multiple_of_2 = false ; int sum = 0 ; int index_of_zero ; bool more_zero = false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int val = s [ i ] - '0' ; if ( zero_exist == true ) more_zero = true ; if ( val == 0 ) { zero_exist = true ; index_of_zero = i ; } sum += val ; } if ( zero_exist == false sum % 3 != 0 ) { cout << " - 1" << " STRNEWLINE " ; return ; } for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int val = s [ i ] - '0' ; if ( val % 2 == 0 && i != index_of_zero ) multiple_of_2 = true ; } if ( multiple_of_2 == false ) { cout << " - 1" << " STRNEWLINE " ; return ; } int last_val = s [ s . length ( ) - 1 ] - '0' ; int second_last_val = s [ s . length ( ) - 2 ] - '0' ; if ( last_val == 0 && second_last_val % 2 == 0 ) cout << 0 << " STRNEWLINE " ; else if ( ( last_val == 0 && second_last_val % 2 != 0 ) || ( last_val % 2 == 0 && second_last_val == 0 ) ) cout << 1 << " STRNEWLINE " ; else if ( more_zero == true && ( last_val == 0 && second_last_val % 2 != 0 ) ) cout << 1 << " STRNEWLINE " ; else cout << 2 << " STRNEWLINE " ; } int main ( ) { string N = "20" ; MinimumSwapOperations ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100000 ; int max_prime [ MAX ] ; int min_prime [ MAX ] ; void sieve ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { if ( min_prime [ i ] > 0 ) { continue ; } min_prime [ i ] = i ; max_prime [ i ] = i ; int j = i + i ; while ( j <= n ) { if ( min_prime [ j ] == 0 ) { min_prime [ j ] = i ; } max_prime [ j ] = i ; j += i ; } } } int findCost ( int A , int B , int C , int X ) { sieve ( MAX ) ; int N , M ; if ( X == 1 ) { return -1 ; } int min_cost = C + X ; int cost_for_prime = A ; N = max_prime [ X ] ; if ( N != X ) { M = X / N ; cost_for_prime += M ; min_cost = min ( min_cost , cost_for_prime ) ; } M = min_prime [ X ] ; N = X / M ; if ( N != min_prime [ N ] ) { int cost_for_comp = B + M ; min_cost = min ( min_cost , cost_for_comp ) ; } return min_cost ; } int main ( ) { int A = 7 , B = 11 , C = 2 , X = 20 ; cout << findCost ( A , B , C , X ) << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPower ( int n , int k ) { int i = 0 ; int a = pow ( n , i ) ; while ( a <= k ) { i += 1 ; a = pow ( n , i ) ; } return i - 1 ; } int b [ 50 ] = { 0 } ; int PowerArray ( int n , int k ) { while ( k ) { int t = highestPower ( n , k ) ; if ( b [ t ] ) { cout << -1 ; return 0 ; } else b [ t ] = 1 ; k -= pow ( n , t ) ; } for ( int i = 0 ; i < 50 ; i ++ ) { if ( b [ i ] ) { cout << i << " , ▁ " ; } } } int main ( ) { int N = 3 ; int K = 40 ; PowerArray ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countdigits ( int n , int k ) { if ( n == 0 ) return 0 ; int digit = n % 10 ; if ( digit == k ) return 1 + countdigits ( n / 10 , k ) ; return countdigits ( n / 10 , k ) ; } int main ( ) { int n = 1000 ; int k = 0 ; cout << countdigits ( n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void product_subarrays ( long long int arr [ ] , int n ) { long long int res = 1 ; for ( int i = 0 ; i < n ; i ++ ) { long long int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product = product * arr [ j ] ; res *= product ; } } cout << res << " STRNEWLINE " ; } int main ( ) { long long int arr [ ] = { 10 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; product_subarrays ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printModulus ( int X , int Y ) { int d = abs ( X - Y ) ; int i = 1 ; while ( i * i <= d ) { if ( d % i == 0 ) { cout << i << " ▁ " ; if ( d / i != i ) cout << d / i << " ▁ " ; } i ++ ; } } int main ( ) { int X = 10 ; int Y = 26 ; printModulus ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool difSquare ( int n ) { if ( n % 4 != 2 ) { return true ; } return false ; } int main ( ) { int n = 45 ; if ( difSquare ( n ) ) { cout << " Yes STRNEWLINE " ; } else { cout << " No STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int data ) { struct Node * newNode = new Node ; newNode -> data = data ; newNode -> left = newNode -> right = NULL ; return ( newNode ) ; } int rec ( Node * root , int & res , int & k ) { if ( root == NULL ) { return 0 ; } int xr = root -> data ; xr ^= rec ( root -> left , res , k ) ; xr ^= rec ( root -> right , res , k ) ; if ( xr == k ) { res ++ ; } return xr ; } int findCount ( Node * root , int K ) { int res = 0 ; rec ( root , res , K ) ; return res ; } int main ( void ) { struct Node * root = newNode ( 2 ) ; root -> left = newNode ( 1 ) ; root -> right = newNode ( 9 ) ; root -> left -> left = newNode ( 10 ) ; root -> left -> right = newNode ( 5 ) ; int K = 5 ; cout << findCount ( root , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void makearrayequal ( int arr [ ] , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x += arr [ i ] & 1 ; } cout << min ( x , n - x ) << endl ; } int main ( ) { int arr [ ] = { 4 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; makearrayequal ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE void SieveOfEratosthenes ( vector < bool > & composite ) { for ( int i = 0 ; i < N ; i ++ ) composite [ i ] = false ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( ! composite [ p ] ) { for ( int i = p * 2 ; i < N ; i += p ) composite [ i ] = true ; } } } int sumOfElements ( int arr [ ] , int n ) { vector < bool > composite ( N ) ; SieveOfEratosthenes ( composite ) ; unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int sum = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( composite [ it -> second ] ) { sum += ( it -> first ) ; } } return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 1 , 1 , 3 , 3 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumOfElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d == 2 d == 3 d == 5 d == 7 ) count ++ ; } return count ; } int main ( ) { int n = 1234567890 ; cout << countDigit ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string permutation ( int arr [ ] , int N ) { int hash [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] != 1 ) return " No " ; } return " Yes " ; } int main ( ) { int arr [ ] = { 1 , 1 , 5 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << permutation ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void remove ( int arr [ ] , int n ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( m [ arr [ i ] ] & 1 ) ) continue ; cout << arr [ i ] << " , ▁ " ; } } int main ( ) { int arr [ ] = { 3 , 3 , 3 , 2 , 2 , 4 , 7 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; remove ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } int longestPrimeSubsequence ( int arr [ ] , int n ) { bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , N ) ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { answer ++ ; } } return answer ; } int main ( ) { int arr [ ] = { 3 , 4 , 11 , 2 , 9 , 21 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestPrimeSubsequence ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string even_or_odd ( string N ) { int len = N . size ( ) ; if ( N [ len - 1 ] == '0' N [ len - 1 ] == '2' N [ len - 1 ] == '4' N [ len - 1 ] == '6' ) return ( " Even " ) ; else return ( " Odd " ) ; } int main ( ) { string N = "735" ; cout << even_or_odd ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float dydx ( float x , float y ) { return ( x + y - 2 ) ; } float rungeKutta ( float x0 , float y0 , float x , float h ) { int n = ( int ) ( ( x - x0 ) / h ) ; float k1 , k2 ; float y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; y = y + ( 1.0 / 6.0 ) * ( k1 + 2 * k2 ) ; x0 = x0 + h ; } return y ; } int main ( ) { float x0 = 0 , y = 1 , x = 2 , h = 0.2 ; cout << fixed << setprecision ( 6 ) << " y ( x ) ▁ = ▁ " << rungeKutta ( x0 , y , x , h ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define size  10001 NEW_LINE using namespace std ; long long fib [ 100010 ] ; int freq [ 100010 ] ; bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; } int isFibonacci ( int n ) { if ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) return 1 ; return 0 ; } void compute ( int a , int b ) { for ( int i = 1 ; i < 100010 ; i ++ ) { fib [ i ] = isFibonacci ( i ) ; } for ( int x = 1 ; x < 100010 ; x ++ ) { for ( int y = 1 ; y < size ; y ++ ) { if ( fib [ x ] == 1 && fib [ y ] == 1 && a * x + b * y < 100010 ) { freq [ a * x + b * y ] ++ ; } } } } int main ( ) { int Q = 2 , A = 5 , B = 10 ; compute ( A , B ) ; int arr [ Q ] = { 50 , 150 } ; for ( int i = 0 ; i < Q ; i ++ ) { cout << freq [ arr [ i ] ] << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE void findMaxSum ( int n1 , int n2 ) { int arr1 [ MAX ] = { 0 } , arr2 [ MAX ] = { 0 } ; int l1 = 0 , l2 = 0 ; int max1 = max ( n1 , n2 ) ; int min1 = min ( n1 , n2 ) ; for ( int i = max1 ; i > 0 ; i /= 10 ) arr1 [ l1 ++ ] = ( i % 10 ) ; for ( int i = min1 ; i > 0 ; i /= 10 ) arr2 [ l2 ++ ] = ( i % 10 ) ; int f = 0 ; if ( l1 != l2 ) { int index = ( max_element ( arr2 , arr2 + l2 ) - arr2 ) ; for ( int i = l1 - 1 ; i > ( l2 - 1 ) ; i -- ) { if ( arr1 [ i ] < arr2 [ index ] ) { swap ( arr1 [ i ] , arr2 [ index ] ) ; f = 1 ; break ; } } } if ( f != 1 ) { int index1 = 0 , index2 = 0 ; int diff1 = 0 , diff2 = 0 ; for ( int i = l2 - 1 ; i >= 0 ; i -- ) { index1 = ( max_element ( arr1 , arr1 + i ) - arr1 ) ; index2 = ( max_element ( arr2 , arr2 + i ) - arr2 ) ; diff1 = ( arr2 [ index2 ] - arr1 [ i ] ) ; diff2 = ( arr1 [ index1 ] - arr2 [ i ] ) ; if ( diff1 > 0 diff2 > 0 ) { if ( diff1 > diff2 ) { swap ( arr1 [ i ] , arr2 [ index2 ] ) ; break ; } else if ( diff2 > diff1 ) { swap ( arr2 [ i ] , arr1 [ index1 ] ) ; break ; } else if ( diff1 == diff2 ) { if ( index1 <= index2 ) { swap ( arr2 [ i ] , arr1 [ index1 ] ) ; break ; } else if ( index2 <= index1 ) { swap ( arr1 [ i ] , arr2 [ index2 ] ) ; break ; } } } } } int f_n1 = 0 , f_n2 = 0 ; for ( int i = l1 - 1 ; i >= 0 ; i -- ) { f_n1 = ( f_n1 * 10 ) + arr1 [ i ] ; f_n2 = ( f_n2 * 10 ) + arr2 [ i ] ; } cout << ( f_n1 + f_n2 ) << " STRNEWLINE " ; } int main ( ) { int N1 = 9987 ; int N2 = 123 ; findMaxSum ( N1 , N2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string even_or_odd ( string N ) { int len = N . size ( ) ; if ( N [ len - 1 ] == '0' N [ len - 1 ] == '2' N [ len - 1 ] == '4' N [ len - 1 ] == '6' N [ len - 1 ] == '8' N [ len - 1 ] == ' A ' N [ len - 1 ] == ' C ' N [ len - 1 ] == ' E ' ) return ( " Even " ) ; else return ( " Odd " ) ; } int main ( ) { string N = " AB3454D " ; cout << even_or_odd ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <stdlib.h> NEW_LINE using namespace std ; bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n - ( d * 3 ) ) ; } return ( n % 31 == 0 ) ; } int main ( ) { int N = 1922 ; if ( isDivisible ( N ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <stdlib.h> NEW_LINE using namespace std ; bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n + ( d * 13 ) ) ; } return ( n % 43 == 0 ) ; } int main ( ) { int N = 2795 ; if ( isDivisible ( N ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; void print ( ll n , ll k ) { cout << k << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { ll x = pow ( k , i ) - pow ( k , i - 1 ) ; cout << x << " ▁ " ; } } int main ( ) { ll N = 3 , K = 4 ; print ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <stdlib.h> NEW_LINE using namespace std ; bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n - ( d * 7 ) ) ; } return ( n % 71 == 0 ) ; } int main ( ) { int N = 5041 ; if ( isDivisible ( N ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digit [ 100000 ] ; int findDigits ( int n ) { int count = 0 ; while ( n != 0 ) { digit [ count ] = n % 10 ; n = n / 10 ; ++ count ; } return count ; } int OR_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans | digit [ i ] ; } return ans ; } int AND_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans & digit [ i ] ; } return ans ; } int XOR_of_Digits ( int n , int count ) { int ans = 0 ; for ( int i = 0 ; i < count ; i ++ ) { ans = ans ^ digit [ i ] ; } return ans ; } void bitwise_operation ( int N ) { int countOfDigit = findDigits ( N ) ; cout << " XOR ▁ = ▁ " << XOR_of_Digits ( N , countOfDigit ) << endl ; cout << " OR ▁ = ▁ " << OR_of_Digits ( N , countOfDigit ) << endl ; cout << " AND ▁ = ▁ " << AND_of_Digits ( N , countOfDigit ) << endl ; } int main ( ) { int N = 123456 ; bitwise_operation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largest_sum ( int arr [ ] , int n ) { int maximum = -1 ; map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( auto j : m ) { if ( j . second > 1 ) { m [ 2 * j . first ] = m [ 2 * j . first ] + j . second / 2 ; if ( 2 * j . first > maximum ) maximum = 2 * j . first ; } } return maximum ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 4 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largest_sum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( int arr [ ] , int N ) { int product = 1 , len = 0 ; for ( int i = 0 ; i < N ; i ++ ) { product *= arr [ i ] ; } if ( product >= 0 ) { return N ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 0 ) { len = max ( len , max ( N - i - 1 , i ) ) ; } } return len ; } int main ( ) { int arr [ ] = { -1 , 1 , 1 , -2 , 3 , 2 , -1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxLength ( arr , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinimumOperation ( int n , int d , int arrays [ 3 ] [ 2 ] ) { int cnt = 0 ; int first = INT_MIN , end = INT_MAX ; while ( n -- ) { int arr [ 2 ] = { arrays [ cnt ] [ 0 ] , arrays [ cnt ] [ 1 ] } ; sort ( arr , arr + 2 ) ; first = max ( first , arr [ 0 ] ) ; end = min ( end , arr [ 1 ] ) ; cnt ++ ; } if ( first > end ) cout << " - 1" ; else { if ( d >= first && d <= end ) { cout << "0" ; } else cout << min ( abs ( first - d ) , abs ( d - end ) ) ; } } int main ( ) { int n = 3 , d = 3 ; int arrays [ 3 ] [ 2 ] = { { 0 , 7 } , { 2 , 14 } , { 4 , 6 } } ; findMinimumOperation ( n , d , arrays ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll mod = 1000000007 ; ll mult ( ll a , ll b ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; } ll calculate_factors ( ll n ) { ll ans , cnt ; cnt = 0 ; ans = 1 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } if ( cnt ) { ans = mult ( ans , ( cnt + 1 ) ) ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } if ( cnt ) { ans = mult ( ans , ( cnt + 1 ) ) ; } } if ( n > 2 ) { ans = mult ( ans , ( 2 ) ) ; } return ans % mod ; } int main ( ) { ll n = 193748576239475639 ; mod = 17 ; cout << calculate_factors ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxValue ( int a ) { string c = bitset < 3 > ( a ) . to_string ( ) ; string b = " " ; for ( int i = 0 ; i < c . length ( ) ; i ++ ) { if ( ( c [ i ] - '0' ) == 1 ) b += '0' ; else b += '1' ; } cout << bitset < 3 > ( b ) . to_ulong ( ) ; } int main ( ) { int a = 4 ; maxValue ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getmax ( int arr [ ] , int n , int x ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s = s + arr [ i ] ; } cout << min ( s , x ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int x = 5 ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getmax ( arr , arr_size , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canBeReduced ( int x , int y ) { int maxi = max ( x , y ) ; int mini = min ( x , y ) ; if ( ( ( x + y ) % 3 ) == 0 && maxi <= 2 * mini ) cout << " YES " << endl ; else cout << " NO " << endl ; } int main ( ) { int x = 6 , y = 9 ; canBeReduced ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double nthRoot ( int A , int N ) { double xPre = rand ( ) % 10 ; double eps = 1e-3 ; double delX = INT_MAX ; double xK ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N ; delX = abs ( xK - xPre ) ; xPre = xK ; } return xK ; } int countPowers ( int a , int b , int k ) { return ( floor ( nthRoot ( b , k ) ) - ceil ( nthRoot ( a , k ) ) + 1 ) ; } int main ( ) { int a = 7 , b = 28 , k = 2 ; cout << " Count ▁ of ▁ Powers ▁ is ▁ " << countPowers ( a , b , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INFINITY_  9999999 NEW_LINE int sqrtByLongDivision ( int n ) { int cur_divisor = 0 ; int quotient_units_digit = 0 ; int cur_quotient = 0 ; int cur_dividend = 0 ; int cur_remainder = 0 ; int a [ 10 ] = { 0 } ; while ( n > 0 ) { a [ i ] = n % 100 ; n = n / 100 ; i ++ ; } i -- ; for ( j = i ; j >= 0 ; j -- ) { cur_remainder = INFINITY_ ; cur_dividend = cur_dividend * 100 + a [ j ] ; for ( udigit = 0 ; udigit <= 9 ; udigit ++ ) { if ( cur_remainder >= cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) && cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) >= 0 ) { cur_remainder = cur_dividend - ( ( cur_divisor * 10 + udigit ) * udigit ) ; quotient_units_digit = udigit ; } } cur_quotient = cur_quotient * 10 + quotient_units_digit ; cur_divisor = cur_quotient * 2 ; cur_dividend = cur_remainder ; } return cur_quotient ; } int main ( ) { int x = 1225 ; cout << sqrtByLongDivision ( x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int previousFibonacci ( int n ) { double a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) ; return round ( a ) ; } int nextFibonacci ( int n ) { double a = n * ( 1 + sqrt ( 5 ) ) / 2.0 ; return round ( a ) ; } bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; } bool isFibonacci ( int n ) { return ( isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ) ; } int countFibonacciPairs ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isFibonacci ( arr [ i ] ) && isFibonacci ( arr [ j ] ) ) { int prevFib = previousFibonacci ( arr [ i ] ) ; int nextFib = nextFibonacci ( arr [ i ] ) ; if ( prevFib == arr [ j ] nextFib == arr [ j ] ) { res ++ ; } } return res ; } int main ( ) { int a [ ] = { 3 , 5 , 8 , 11 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countFibonacciPairs ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countPairsWithProdK ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == k ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << countPairsWithProdK ( arr , N , K ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; #define MAX  100000 NEW_LINE int countPairsWithProductK ( int arr [ ] , int n , int k ) { int count = 0 ; bool hashmap [ MAX ] = { false } ; for ( int i = 0 ; i < n ; i ++ ) hashmap [ arr [ i ] ] = true ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; double index = 1.0 * k / arr [ i ] ; if ( index >= 0 && ( ( index - ( int ) ( index ) ) == 0 ) && hashmap [ k / x ] ) count ++ ; hashmap [ x ] = false ; } return count ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << countPairsWithProductK ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void oddIntegers ( int n , int k ) { if ( n % 2 != k % 2 ) { cout << " - 1" << " STRNEWLINE " ; return ; } int sum = 0 ; int i = 1 ; int j = 1 ; while ( j < k ) { sum = sum + i ; cout << i << " ▁ " ; i = i + 2 ; j ++ ; } int finalOdd = n - sum ; cout << finalOdd << " STRNEWLINE " ; } int main ( ) { int n = 10 ; int k = 2 ; oddIntegers ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE #define mod  1000000007 NEW_LINE using namespace std ; vector < ll > ans ( 100002 , 1 ) ; long long pref [ 100002 ] ; void preCompute ( ) { for ( int i = 2 ; i <= 100000 / 2 ; i ++ ) { for ( int j = 2 * i ; j <= 100000 ; j += i ) { ans [ j ] = ( ans [ j ] * i ) % mod ; } } for ( int i = 1 ; i < 100002 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + ans [ i ] ; pref [ i ] %= mod ; } } void printSum ( int L , int R ) { cout << pref [ R ] - pref [ L - 1 ] << " ▁ " ; } void printSumProper ( int arr [ ] [ 2 ] , int Q ) { preCompute ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } } int main ( ) { int Q = 2 ; int arr [ ] [ 2 ] = { { 10 , 20 } , { 12 , 16 } } ; printSumProper ( arr , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int a [ ] , int k , int x ) { int j ; for ( j = k - 1 ; j > -1 ; j -- ) { if ( a [ j ] == x ) return j ; } return -1 ; } void genArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( search ( arr , i , arr [ i ] ) == -1 ) arr [ i + 1 ] = 0 ; else arr [ i + 1 ] = ( i - search ( arr , i , arr [ i ] ) ) ; } } int main ( ) { int N = 5 ; int size = N + 1 ; int a [ ] = { 0 , 0 , 0 , 0 , 0 } ; genArray ( a , N ) ; for ( int i = 0 ; i < N ; i ++ ) cout << a [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <vector> NEW_LINE using namespace std ; vector < int > getPerfectcubes ( int n ) { vector < int > perfectcubes ; int current = 1 ; int i = 1 ; while ( current <= n ) { perfectcubes . push_back ( current ) ; i += 1 ; current = int ( pow ( i , 3 ) ) ; } return perfectcubes ; } int maxPairSum ( int arr [ ] , int n ) { int max = 0 ; int secondMax = 0 ; if ( arr [ 0 ] > arr [ 1 ] ) { max = arr [ 0 ] ; secondMax = arr [ 1 ] ; } else { max = arr [ 1 ] ; secondMax = arr [ 0 ] ; } for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) secondMax = arr [ i ] ; } return ( max + secondMax ) ; } int countPairsWith ( int n , vector < int > perfectcubes , vector < int > nums ) { int count = 0 ; int len = perfectcubes . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) { int temp = perfectcubes [ i ] - n ; if ( temp > n ) { for ( auto j = nums . begin ( ) ; j != nums . end ( ) ; j ++ ) { if ( ( * j ) == temp ) count += 1 ; } } } return count ; } int countPairs ( int arr [ ] , int n ) { int max = maxPairSum ( arr , n ) ; vector < int > perfectcubes = getPerfectcubes ( max ) ; vector < int > nums ; for ( int i = 0 ; i < n ; i ++ ) nums . push_back ( arr [ i ] ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { count += countPairsWith ( arr [ i ] , perfectcubes , nums ) ; } return count ; } int main ( ) { int arr [ ] = { 2 , 6 , 18 , 9 , 999 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( countPairs ( arr , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) for ( int j = 1 ; j * j * j <= i ; j ++ ) if ( j * j * j == i ) cnt ++ ; return cnt ; } int main ( ) { int a = 7 , b = 30 ; cout << " Count ▁ of ▁ Cubes ▁ is ▁ " << countCubes ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countCubes ( int a , int b ) { return ( floor ( cbrt ( b ) ) - ceil ( cbrt ( a ) ) + 1 ) ; } int main ( ) { int a = 7 , b = 28 ; cout << " Count ▁ of ▁ cubes ▁ is ▁ " << countCubes ( a , b ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; void isPrime ( int N ) { bool isPrime = true ; int arr [ 8 ] = { 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 } ; if ( N < 2 ) { isPrime = false ; } if ( N % 2 == 0 N % 3 == 0 N % 5 == 0 ) { isPrime = false ; } for ( int i = 0 ; i < sqrt ( N ) ; i += 30 ) { for ( int c : arr ) { if ( c > sqrt ( N ) ) { break ; } else { if ( N % ( c + i ) == 0 ) { isPrime = false ; break ; } } if ( ! isPrime ) break ; } } if ( isPrime ) cout << " Prime ▁ Number " ; else cout << " Not ▁ a ▁ Prime ▁ Number " ; } int main ( ) { int N = 121 ; isPrime ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isArmstrong ( int x , int n ) { int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += ( int ) pow ( digit , n ) ; temp /= 10 ; } return sum1 == x ; } void CalculateXORandOR ( int n ) { int CalculateXOR = 0 ; int CalculateOR = 0 ; int start = ( int ) pow ( 10 , n - 1 ) ; int end = ( int ) pow ( 10 , n ) - 1 ; for ( int i = start ; i < end + 1 ; i ++ ) { if ( isArmstrong ( i , n ) ) { CalculateXOR = CalculateXOR ^ i ; CalculateOR = CalculateOR | i ; } } cout << " XOR ▁ = ▁ " << CalculateXOR << endl ; cout << " OR ▁ = ▁ " << CalculateOR << endl ; } int main ( ) { int n = 4 ; CalculateXORandOR ( n ) ; }
. #include <bits/stdc++.h> NEW_LINE using namespace std ; void perfectCube ( int N ) { int cube ; for ( int i ; i <= N ; i ++ ) { cube = i * i * i ; if ( cube == N ) { cout << " Yes " ; return ; } else if ( cube > N ) { cout << " NO " ; return ; } } } int main ( ) { int N = 216 ; perfectCube ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void perfectCube ( int N ) { int cube_root ; cube_root = round ( cbrt ( N ) ) ; if ( cube_root * cube_root * cube_root == N ) { cout << " Yes " ; return ; } else { cout << " NO " ; return ; } } int main ( ) { int N = 125 ; perfectCube ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int arr [ ] , int N ) { int even = 0 ; int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) { odd ++ ; } else { even ++ ; } } if ( even == N odd == N ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int arr [ ] = { 1 , 1 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; check ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int n , int b ) { int even = 0 , odd = 0 ; if ( b % 2 == 0 ) { even = pow ( b , n ) - 2 ; odd = pow ( b , n ) - 1 ; } else { even = pow ( b , n ) - 1 ; odd = pow ( b , n ) - 2 ; } cout << " Even ▁ Number ▁ = ▁ " << even << ' ' ; cout << " Odd ▁ Number ▁ = ▁ " << odd ; } int main ( ) { int N = 2 , B = 5 ; findNumbers ( N , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 3 != 0 ) ans *= pow ( 2 , ( count % 3 ) ) ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 3 != 0 ) ans *= pow ( i , ( count % 3 ) ) ; } if ( n > 2 ) ans *= n ; return ans ; } int main ( ) { int n = 128 ; cout << findMinNumber ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isPerfectSquare ( long long int x ) { long double sr = round ( sqrt ( x ) ) ; if ( sr * sr == x ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int n = 7 , k = 2 ; isPerfectSquare ( n + k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPairs ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << " , ▁ " ; } } } int main ( ) { int arr [ ] = { 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int product ( int N ) { int ans = 1 ; int val = pow ( 2 , N - 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { ans *= pow ( i , val ) ; } return ans ; } int main ( ) { int N = 2 ; cout << product ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nearest ( int n ) { int prevCube = cbrt ( n ) ; int nextCube = prevCube + 1 ; prevCube = prevCube * prevCube * prevCube ; nextCube = nextCube * nextCube * nextCube ; int ans = ( n - prevCube ) < ( nextCube - n ) ? ( prevCube - n ) : ( nextCube - n ) ; return ans ; } int main ( ) { int n = 25 ; cout << nearest ( n ) << endl ; n = 27 ; cout << nearest ( n ) << endl ; n = 40 ; cout << nearest ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = sqrt ( ( ( x1 - x2 ) * ( x1 - x2 ) ) + ( ( y1 - y2 ) * ( y1 - y2 ) ) ) ; if ( distSq + r2 == r1 ) cout << " The ▁ smaller ▁ circle ▁ lies ▁ completely " << " ▁ inside ▁ the ▁ bigger ▁ circle ▁ with ▁ " << " touching ▁ each ▁ other ▁ " << " at ▁ a ▁ point ▁ of ▁ circumference . ▁ " << endl ; else if ( distSq + r2 < r1 ) cout << " The ▁ smaller ▁ circle ▁ lies ▁ completely " << " ▁ inside ▁ the ▁ bigger ▁ circle ▁ without " << " ▁ touching ▁ each ▁ other ▁ " << " at ▁ a ▁ point ▁ of ▁ circumference . ▁ " << endl ; else cout << " The ▁ smaller ▁ does ▁ not ▁ lies ▁ inside " << " ▁ the ▁ bigger ▁ circle ▁ completely . " << endl ; } int main ( ) { int x1 = 10 , y1 = 8 ; int x2 = 1 , y2 = 2 ; int r1 = 30 , r2 = 10 ; circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; } int main ( ) { int x1 = -10 , y1 = 8 ; int x2 = 14 , y2 = -24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) cout << " There ▁ are ▁ 3 ▁ common ▁ tangents " << " ▁ between ▁ the ▁ circles . " ; else if ( t < 0 ) cout << " There ▁ are ▁ 4 ▁ common ▁ tangents " << " ▁ between ▁ the ▁ circles . " ; else cout << " There ▁ are ▁ 2 ▁ common ▁ tangents " << " ▁ between ▁ the ▁ circles . " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; } void ratiotang ( int r1 , int r2 ) { cout << " The ▁ ratio ▁ is ▁ " << r1 / GCD ( r1 , r2 ) << " : " << r2 / GCD ( r1 , r2 ) << endl ; } int main ( ) { int r1 = 4 , r2 = 8 ; ratiotang ( r1 , r2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; } int main ( ) { int V = 5 , E = 7 ; cout << Regions ( V , E ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; } void ratiotang ( int r1 , int r2 ) { cout << " The ▁ ratio ▁ is ▁ " << r1 / GCD ( r1 , r2 ) << " ▁ : ▁ " << r2 / GCD ( r1 , r2 ) << endl ; } int main ( ) { int r1 = 4 , r2 = 6 ; ratiotang ( r1 , r2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengthOfTangent ( double r1 , double r2 , double d ) { cout << " The ▁ length ▁ of ▁ the ▁ transverse " << " ▁ common ▁ tangent ▁ is ▁ " << sqrt ( pow ( d , 2 ) - pow ( ( r1 + r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 12 ; lengthOfTangent ( r1 , r2 , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengtang ( double r1 , double r2 , double d ) { cout << " The ▁ length ▁ of ▁ the ▁ direct " << " ▁ common ▁ tangent ▁ is ▁ " << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 3 ; lengtang ( r1 , r2 , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void shortdis ( double r , double d ) { cout << " The ▁ shortest ▁ distance ▁ " << " from ▁ the ▁ chord ▁ to ▁ centre ▁ " << sqrt ( ( r * r ) - ( ( d * d ) / 4 ) ) << endl ; } int main ( ) { double r = 4 , d = 3 ; shortdis ( r , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengtang ( double r1 , double r2 ) { cout << " The ▁ length ▁ of ▁ the ▁ " << " direct ▁ common ▁ tangent ▁ is ▁ " << 2 * sqrt ( r1 * r2 ) << endl ; } int main ( ) { double r1 = 5 , r2 = 9 ; lengtang ( r1 , r2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { cout << " The ▁ shortest ▁ distance ▁ " << " between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " << sqrt ( ( pow ( ( x2 - x1 ) , 2 ) ) + ( pow ( ( y2 - y1 ) , 2 ) ) ) - r << endl ; } int main ( ) { double x1 = 4 , y1 = 6 , x2 = 35 , y2 = 42 , r = 5 ; dist ( x1 , y1 , x2 , y2 , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengtang ( double r1 , double r2 , double d ) { cout << " The ▁ length ▁ of ▁ the ▁ direct " << " ▁ common ▁ tangent ▁ is ▁ " << sqrt ( pow ( d , 2 ) - pow ( ( r1 - r2 ) , 2 ) ) << endl ; } int main ( ) { double r1 = 4 , r2 = 6 , d = 12 ; lengtang ( r1 , r2 , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double dist ( double m , double b1 , double b2 ) { double d = fabs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; return d ; } int main ( ) { double m = 2 , b1 = 4 , b2 = 3 ; cout << dist ( m , b1 , b2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float normal ( float m , float n ) { float N = ( fabsf ( m ) * fabsf ( n ) ) / sqrt ( ( fabsf ( m ) * fabsf ( m ) ) + ( fabsf ( n ) * fabsf ( n ) ) ) ; return N ; } int main ( ) { float m = -5 , n = 3 ; cout << normal ( m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float findAreaShaded ( float a ) { float sqArea = a * a ; float semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ; float ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; } int main ( ) { float a = 10 ; cout << findAreaShaded ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } } int main ( ) { int x = 4 , y = 3 ; cout << countSteps ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSlopeGood ( double slope , int arr [ ] , int n ) { set < double > setOfLines ; for ( int i = 0 ; i < n ; i ++ ) setOfLines . insert ( arr [ i ] - slope * ( i ) ) ; return setOfLines . size ( ) == 2 ; } bool checkForParallel ( int arr [ ] , int n ) { bool slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) ; bool slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) ; bool slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) / 2 , arr , n ) ; return ( slope1 slope2 slope3 ) ; } int main ( ) { int arr [ ] = { 1 , 6 , 3 , 8 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( int ) checkForParallel ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; } int main ( ) { int m = 3 , c = 2 ; int x = 1 , y = 5 ; if ( pointIsOnLine ( m , c , x , y ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Area ( float a , float b ) { if ( a < 0 && b < 0 ) return -1 ; float h = sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) ; float A = 0.70477 * pow ( h , 2 ) ; return A ; } int main ( ) { float a = 5 , b = 4 ; cout << Area ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxRectangles ( int L , int B , int l , int b ) { int horizontal = 0 , vertical = 0 ; if ( l <= L && b <= B ) { int columns = B / b ; int rows = L / l ; horizontal = rows * columns ; } if ( l <= B && b <= L ) { int columns = L / b ; int rows = B / l ; vertical = rows * columns ; } return max ( horizontal , vertical ) ; } int main ( ) { int L = 10 , B = 7 , l = 4 , b = 3 ; cout << ( maxRectangles ( L , B , l , b ) ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Area ( float a ) { if ( a < 0 ) return -1 ; float h = 1.268 * a ; float A = 0.70477 * pow ( h , 2 ) ; return A ; } int main ( ) { float a = 5 ; cout << Area ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Area ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; float A = 0.70477 * pow ( x , 2 ) ; return A ; } int main ( ) { float a = 5 ; cout << Area ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / pow ( 2 , fold ) ; } int main ( ) { double side = 4 , fold = 2 ; cout << areaSquare ( side , fold ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float square ( float a ) { if ( a < 0 ) return -1 ; float x = 0.464 * a ; return x ; } int main ( ) { float a = 5 ; cout << square ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float ReuleauxArea ( float r ) { if ( r < 0 ) return -1 ; float A = 0.70477 * 2 * pow ( r , 2 ) ; return A ; } int main ( ) { float r = 6 ; cout << ReuleauxArea ( r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float cyl ( float a ) { if ( a < 0 ) return -1 ; float r = ( 2 * a * sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; } int main ( ) { float a = 5 ; cout << cyl ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Area ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return -1 ; float x = ( l * b ) / ( l + b ) ; float A = 0.70477 * pow ( x , 2 ) ; return A ; } int main ( ) { float l = 5 , b = 12 , h = 13 ; cout << Area ( l , b , h ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float squareSide ( float a ) { if ( a < 0 ) return -1 ; float x = 0.423 * a ; return x ; } int main ( ) { float a = 8 ; cout << squareSide ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( ceil ( a ) == 1 && floor ( a ) == 1 ) return true ; return false ; } int main ( ) { float l = 0.70710678 , m = 0.5 , n = 0.5 ; if ( isPossible ( l , m , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyapothem ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; } int main ( ) { float a = 9 , n = 6 ; cout << polyapothem ( n , a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float polyarea ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; float A = ( a * a * n ) / ( 4 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; return A ; } int main ( ) { float a = 9 , n = 6 ; cout << polyarea ( n , a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float decdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.902 * a ; return d ; } int main ( ) { float a = 9 ; cout << decdiagonal ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float heptdiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.802 * a ; return d ; } int main ( ) { float a = 6 ; cout << heptdiagonal ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float hexDiagonal ( float a ) { if ( a < 0 ) return -1 ; float d = 1.73 * a ; return d ; } int main ( ) { float a = 9 ; cout << hexDiagonal ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float ReuleauxArea ( float a ) { if ( a < 0 ) return -1 ; float A = 0.70477 * pow ( a , 2 ) ; return A ; } int main ( ) { float a = 6 ; cout << ReuleauxArea ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float calculateSide ( float n , float r ) { float theta , theta_in_radians ; theta = 360 / n ; theta_in_radians = theta * 3.14 / 180 ; return 2 * r * sin ( theta_in_radians / 2 ) ; } int main ( ) { float n = 3 ; float r = 5 ; cout << calculateSide ( n , r ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float CubeVolume ( float d ) { float Volume ; Volume = ( sqrt ( 3 ) * pow ( d , 3 ) ) / 9 ; return Volume ; } int main ( ) { float d = 5 ; cout << " Volume ▁ of ▁ Cube : ▁ " << CubeVolume ( d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float cyl ( float r , float R , float h ) { if ( h < 0 && r < 0 && R < 0 ) return -1 ; float r1 = r ; float h1 = h ; float V = 3.14 * pow ( r1 , 2 ) * h1 ; return V ; } int main ( ) { float r = 7 , R = 11 , h = 6 ; cout << cyl ( r , R , h ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float cyl ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = ( 2 * r ) / 3 ; float H = ( 2 * h ) / 3 ; float V = 3.14 * pow ( R , 2 ) * H ; return V ; } int main ( ) { float r = 4 , h = 8 ; cout << cyl ( r , h ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float a = pow ( h , 3 ) ; return a ; } int main ( ) { float h = 5 , r = 4 ; cout << cube ( h , r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float cyl ( float R ) { if ( R < 0 ) return -1 ; float V = ( 2 * 3.14 * pow ( R , 3 ) ) / ( 3 * sqrt ( 3 ) ) ; return V ; } int main ( ) { float R = 4 ; cout << cyl ( R ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float l = sqrt ( pow ( h , 2 ) + 4 * pow ( r , 2 ) ) ; return l ; } int main ( ) { float h = 4 , r = 1.5 ; cout << rod ( h , r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float cubeSide ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float a = ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) ; return a ; } int main ( ) { float h = 5 , r = 6 ; cout << cubeSide ( h , r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float coner ( float R ) { if ( R < 0 ) return -1 ; float r = ( 2 * sqrt ( 2 ) * R ) / 3 ; return r ; } float coneh ( float R ) { if ( R < 0 ) return -1 ; float h = ( 4 * R ) / 3 ; return h ; } int main ( ) { float R = 10 ; cout << " r ▁ = ▁ " << coner ( R ) << " , ▁ " << " h ▁ = ▁ " << coneh ( R ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float coneRadius ( float a ) { if ( a < 0 ) return -1 ; float r = a / sqrt ( 2 ) ; return r ; } float coneHeight ( float a ) { if ( a < 0 ) return -1 ; float h = a ; return h ; } int main ( ) { float a = 6 ; cout << " r ▁ = ▁ " << coneRadius ( a ) << " , ▁ " << " h ▁ = ▁ " << coneHeight ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float largestCube ( float r ) { if ( r < 0 ) return -1 ; float a = ( 2 * r ) / sqrt ( 3 ) ; return a ; } int main ( ) { float r = 5 ; cout << largestCube ( r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float sphere ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; return r ; } int main ( ) { float a = 5 ; cout << sphere ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float maxVol ( float P , float A ) { float l = ( P - sqrt ( P * P - 24 * A ) ) / 12 ; float V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ; return V ; } int main ( ) { float P = 20 , A = 16 ; cout << maxVol ( P , A ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int rhombusAreaPeri ( int d1 , int d2 ) { long long int area , perimeter ; area = ( d1 * d2 ) / 2 ; perimeter = 2 * sqrt ( pow ( d1 , 2 ) + pow ( d2 , 2 ) ) ; cout << " The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " << d1 << " ▁ and ▁ " << d2 << " ▁ is ▁ " << area << " . " << endl ; cout << " The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " << d1 << " ▁ and ▁ " << d2 << " ▁ is ▁ " << perimeter << " . " << endl ; } int main ( ) { int d1 = 2 , d2 = 4 ; rhombusAreaPeri ( d1 , d2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iomanip> NEW_LINE #include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void foot ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << " ▁ x2 ▁ = ▁ " << x2 ; cout << " ▁ y2 ▁ = ▁ " << y2 ; cout << " ▁ z2 ▁ = ▁ " << z2 ; } int main ( ) { float a = 1 ; float b = -2 ; float c = 0 ; float d = 0 ; float x1 = -1 ; float y1 = 3 ; float z1 = 4 ; foot ( a , b , c , d , x1 , y1 , z1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRectangles ( int l , int w ) { int squareSide = __gcd ( l , w ) ; return ( l * w ) / ( squareSide * squareSide ) ; } int main ( ) { int l = 4 , w = 6 ; cout << countRectangles ( l , w ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void circle_equation ( double x1 , double y1 , double r ) { double a = -2 * x1 ; double b = -2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; cout << " x ^ 2 ▁ + ▁ ( " << a << " ▁ x ) ▁ + ▁ " ; cout << " y ^ 2 ▁ + ▁ ( " << b << " ▁ y ) ▁ = ▁ " ; cout << c << " . " << endl ; } int main ( ) { double x1 = 2 , y1 = -3 , r = 8 ; circle_equation ( x1 , y1 , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkEquilibrium ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int resx = x1 + x2 + x3 ; int resy = y1 + y2 + y3 ; int resz = z1 + z2 + z3 ; if ( resx == 0 and resy == 0 and resz == 0 ) return true ; else return false ; } int main ( ) { int x1 = -2 , y1 = -7 , z1 = -9 , x2 = 5 , y2 = -14 , z2 = 14 , x3 = -3 , y3 = 21 , z3 = -5 ; if ( checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ) cout << " The ▁ vectors ▁ are ▁ at ▁ equilibrium . " ; else cout << " The ▁ vectors ▁ are ▁ not ▁ at ▁ equilibrium . " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) cout << " y ▁ = ▁ " << dif << " x " << ( x * dif ) + ( y ) ; else if ( dif > 0 ) cout << " y ▁ = ▁ " << dif << " x + " << - x * dif + y ; else cout << " Not ▁ possible " ; } } int main ( ) { int A = 2 , x = 2 , y = 0 ; findTangent ( A , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float octaside ( float a ) { if ( a < 0 ) return -1 ; float s = a / ( sqrt ( 2 ) + 1 ) ; return s ; } int main ( ) { float a = 4 ; cout << octaside ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; struct t { ll x , y , r ; } ; typedef struct t node ; long double dis ( ll x1 , ll y1 , ll x2 , ll y2 ) { return sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; } bool check ( node c1 , node c2 , int k ) { long double min = 0 ; long double max = 0 ; long double de = dis ( c1 . x , c1 . y , c2 . x , c2 . y ) ; if ( de == 0 ) { if ( c1 . r == c2 . r ) { min = 0 ; max = 0 ; } else { if ( c1 . r - c2 . r > 0 ) { min = c1 . r - c2 . r ; max = min + 2 * c2 . r ; } else { min = c2 . r - c1 . r ; max = min + 2 * c1 . r ; } } } else if ( de >= c1 . r + c2 . r ) { min = de - c1 . r - c2 . r ; max = de + c1 . r + c2 . r ; } else if ( de + c2 . r < c1 . r ) { max = c2 . r + c1 . r + de ; min = c1 . r - de - c2 . r ; } else if ( de + c1 . r < c2 . r ) { max = c2 . r + c1 . r + de ; min = c2 . r - de - c1 . r ; } else if ( ( de + c2 . r >= c1 . r ) || ( de + c1 . r >= c2 . r ) ) { max = c2 . r + c1 . r + de ; min = 0 ; } ll temin = ( ll ) ( ceil ( min ) ) ; ll re = ( ll ) max ; if ( k >= temin && k <= re ) return true ; return false ; } int main ( ) { node circle1 , circle2 ; int k = 3 ; circle1 . x = 0 ; circle1 . y = 0 ; circle1 . r = 5 ; circle2 . x = 8 ; circle2 . y = 3 ; circle2 . r = 2 ; if ( check ( circle1 , circle2 , k ) ) cout << " YES " << endl ; else cout << " NO " << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float rhombusarea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; return ( l * b ) / 2 ; } int main ( ) { float l = 16 , b = 6 ; cout << rhombusarea ( l , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; } int main ( ) { int a = 3 , x = 2 , b = 7 ; if ( Move ( a , x , b ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float A = a * b ; return A ; } int main ( ) { float a = 5 , b = 2 ; cout << area ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float circlearea ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0 ) return -1 ; float p = ( a + b + c ) / 2 ; float At = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float A = 3.14 * pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) ; return A ; } int main ( ) { float a = 4 , b = 5 , c = 3 ; cout << circlearea ( a , b , c ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float altitude ( float a , float b ) { return sqrt ( pow ( a , 2 ) - ( pow ( b , 2 ) / 4 ) ) ; } float area ( float b , float h ) { return ( 1 * b * h ) / 2 ; } int main ( ) { float a = 2 , b = 3 ; float h = altitude ( a , b ) ; cout << setprecision ( 3 ) ; cout << " Altitude = ▁ " << h << " , ▁ " ; cout << " Area = ▁ " << area ( b , h ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int surfaceArea ( int b , int s ) { return 2 * b * s + pow ( b , 2 ) ; } int main ( ) { int b = 3 , s = 4 ; cout << surfaceArea ( b , s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll check ( ll a , ll b , ll p , ll q ) { ll d = p * p + q * q ; if ( d == 0 ) return a == 0 && b == 0 ; else return ( a * p + b * q ) % d == 0 && ( b * p - a * q ) % d == 0 ; } bool check ( int a , int b , int x , int y , int p , int q ) { if ( check ( a - x , b - y , p , q ) || check ( a + x , b + y , p , q ) || check ( a - y , b + x , p , q ) || check ( a + y , b - x , p , q ) ) return true ; else return false ; } int main ( ) { int a = -4 , b = -2 ; int x = 0 , y = 0 ; int p = -2 , q = -1 ; if ( check ( a , b , x , y , p , q ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float trianglearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / ( 4 * b ) ; return area ; } int main ( ) { float a = 4 , b = 2 ; cout << trianglearea ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float area = 4 * ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ; return area ; } int main ( ) { float a = 4 , b = 2 ; cout << squarearea ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float trianglearea ( float r ) { if ( r < 0 ) return -1 ; return r * r ; } int main ( ) { float r = 5 ; cout << trianglearea ( r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float squarearea ( float r ) { if ( r < 0 ) return -1 ; float a = 4 * ( pow ( r , 2 ) / 5 ) ; return a ; } int main ( ) { float r = 5 ; cout << squarearea ( r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; return 2 * a * b ; } int main ( ) { float a = 10 , b = 8 ; cout << rectanglearea ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  50 NEW_LINE void solveQuery ( int n , int q , int qi [ ] , int qj [ ] ) { int arr [ MAX ] ; for ( int i = 0 ; i <= n ; i ++ ) arr [ i ] = 0 ; for ( int k = 0 ; k < q ; k ++ ) { int flag = 0 ; if ( qj [ k ] < qi [ k ] ) { int temp = qi [ k ] ; qi [ k ] = qj [ k ] ; qj [ k ] = temp ; } if ( arr [ qi [ k ] ] != 0 arr [ qj [ k ] ] != 0 ) flag = 1 ; else if ( qi [ k ] == qj [ k ] ) flag = 1 ; else { for ( int i = 1 ; i < qi [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] < qj [ k ] && qi [ k ] < arr [ i ] ) { flag = 1 ; break ; } } if ( flag == 0 ) { for ( int i = qi [ k ] + 1 ; i < qj [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] > qj [ k ] ) { flag = 1 ; break ; } } } } if ( flag == 0 ) { cout << " YES STRNEWLINE " ; arr [ qi [ k ] ] = qj [ k ] ; arr [ qj [ k ] ] = qi [ k ] ; } else cout << " NO STRNEWLINE " ; } } int main ( ) { int n = 10 ; int q = 7 ; int qi [ ] = { 1 , 2 , 2 , 2 , 9 , 10 , 8 } ; int qj [ ] = { 5 , 7 , 3 , 4 , 9 , 9 , 6 } ; solveQuery ( n , q , qi , qj ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE void shortestLength ( int n , int x [ ] , int y [ ] ) { int answer = 0 ; int i = 0 ; while ( n -- ) { if ( x [ i ] + y [ i ] > answer ) answer = x [ i ] + y [ i ] ; i ++ ; } cout << " Length ▁ - > ▁ " << answer << endl ; cout << " Path ▁ - > ▁ " << " ( ▁ 1 , ▁ " << answer << " ▁ ) " << " and ▁ ( ▁ " << answer << " , ▁ 1 ▁ ) " ; } int main ( ) { int n = 4 ; int x [ n ] = { 1 , 4 , 2 , 1 } ; int y [ n ] = { 4 , 1 , 1 , 2 } ; shortestLength ( n , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int squares ( int l , int b , int a ) { return ceil ( l / ( double ) a ) * ceil ( b / ( double ) a ) ; } int main ( ) { int l = 11 , b = 23 , a = 14 ; cout << squares ( l , b , a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } int squarearea ( int l , int b ) { if ( l < 0 b < 0 ) return -1 ; int n = ( l * b ) / gcd ( l , b ) ; return n * n ; } int main ( ) { int l = 6 , b = 4 ; cout << squarearea ( l , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <cmath> NEW_LINE using namespace std ; float angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; float den = sqrt ( pow ( ( x2 - x1 ) , 2 ) + pow ( ( y2 - y1 ) , 2 ) + pow ( ( z2 - z1 ) , 2 ) ) * sqrt ( pow ( ( x3 - x1 ) , 2 ) + pow ( ( y3 - y1 ) , 2 ) + pow ( ( z3 - z1 ) , 2 ) ) ; float angle = acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; } int main ( ) { int x1 = -1 ; int y1 = 3 ; int z1 = 2 ; int x2 = 2 ; int y2 = 3 ; int z2 = 5 ; int x3 = 3 ; int y3 = 5 ; int z3 = -2 ; float angle_A = angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) ; float angle_B = angle_triangle ( x2 , x3 , x1 , y2 , y3 , y1 , z2 , z3 , z1 ) ; float angle_C = angle_triangle ( x3 , x2 , x1 , y3 , y2 , y1 , z3 , z2 , z1 ) ; cout << " Angles ▁ are ▁ : " << endl ; cout << setprecision ( 3 ) ; cout << " angle ▁ A ▁ = ▁ " << angle_A << " ▁ degree " << endl ; cout << " angle ▁ B ▁ = ▁ " << angle_B << " ▁ degree " << endl ; cout << " angle ▁ C ▁ = ▁ " << angle_C << " ▁ degree " << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int M , int N , int s ) { if ( N % s == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( M % s == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; } int main ( ) { int N = 12 , M = 13 , s = 4 ; cout << solve ( M , N , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( double M , double N , double s ) { int ans = ( ( int ) ( ceil ( M / s ) ) * ( int ) ( ceil ( N / s ) ) ) ; return ans ; } int main ( ) { double N = 12 , M = 13 , s = 4 ; cout << solve ( M , N , s ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; { int x ; int y ; } ; int orientation ( Point p , Point q , Point r ) { int val = ( q . y - p . y ) * ( r . x - q . x ) - ( q . x - p . x ) * ( r . y - q . y ) ; if ( val == 0 ) return 0 ; return ( val > 0 ) ? 1 : 2 ; } bool doIntersect ( Point p1 , Point q1 , Point p2 , Point q2 ) { int o1 = orientation ( p1 , q1 , p2 ) ; int o2 = orientation ( p1 , q1 , q2 ) ; int o3 = orientation ( p2 , q2 , p1 ) ; int o4 = orientation ( p2 , q2 , q1 ) ; if ( o1 != o2 && o3 != o4 ) return true ; return false ; } bool similar ( Point p1 , Point p2 ) { if ( p1 . x == p2 . x && p1 . y == p2 . y ) return false ; return true ; } bool collinear ( Point p1 , Point p2 , Point p3 ) { int x1 = p1 . x , y1 = p1 . y ; int x2 = p2 . x , y2 = p2 . y ; int x3 = p3 . x , y3 = p3 . y ; if ( ( y3 - y2 ) * ( x2 - x1 ) == ( y2 - y1 ) * ( x3 - x2 ) ) return false ; else return true ; } int no_of_quads ( Point p1 , Point p2 , Point p3 , Point p4 ) { bool same = true ; same = same & similar ( p1 , p2 ) ; same = same & similar ( p1 , p3 ) ; same = same & similar ( p1 , p4 ) ; same = same & similar ( p2 , p3 ) ; same = same & similar ( p2 , p4 ) ; same = same & similar ( p3 , p4 ) ; if ( same == false ) return 0 ; bool coll = true ; coll = coll & collinear ( p1 , p2 , p3 ) ; coll = coll & collinear ( p1 , p2 , p4 ) ; coll = coll & collinear ( p1 , p3 , p4 ) ; coll = coll & collinear ( p2 , p3 , p4 ) ; if ( coll == false ) return 0 ; int check = 0 ; if ( doIntersect ( p1 , p2 , p3 , p4 ) ) check = 1 ; if ( doIntersect ( p1 , p3 , p2 , p4 ) ) check = 1 ; if ( doIntersect ( p1 , p2 , p4 , p3 ) ) check = 1 ; if ( check == 0 ) return 3 ; return 1 ; } int main ( ) { struct Point p1 , p2 , p3 , p4 ; p1 . x = 0 , p1 . y = 9 ; p2 . x = -1 , p2 . y = 0 ; p3 . x = 5 , p3 . y = -1 ; p4 . x = 5 , p4 . y = 9 ; cout << no_of_quads ( p1 , p2 , p3 , p4 ) << endl ; p1 . x = 0 , p1 . y = 9 ; p2 . x = -1 , p2 . y = 0 ; p3 . x = 5 , p3 . y = -1 ; p4 . x = 0 , p4 . y = 3 ; cout << no_of_quads ( p1 , p2 , p3 , p4 ) << endl ; p1 . x = 0 , p1 . y = 9 ; p2 . x = 0 , p2 . y = 10 ; p3 . x = 0 , p3 . y = 11 ; p4 . x = 0 , p4 . y = 12 ; cout << no_of_quads ( p1 , p2 , p3 , p4 ) << endl ; p1 . x = 0 , p1 . y = 9 ; p2 . x = 0 , p2 . y = 9 ; p3 . x = 5 , p3 . y = -1 ; p4 . x = 0 , p4 . y = 3 ; cout << no_of_quads ( p1 , p2 , p3 , p4 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float findVolume ( float l , float b , float h ) { float volume = ( l * b * h ) / 2 ; return volume ; } int main ( ) { float l = 18 , b = 12 , h = 9 ; cout << " Volume ▁ of ▁ triangular ▁ prism : ▁ " << findVolume ( l , b , h ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; } int main ( ) { int n = 4 ; cout << countNumberOfTriangles ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int centeredDodecagonal ( long int n ) { return 6 * n * ( n - 1 ) + 1 ; } int main ( ) { long int n = 2 ; cout << centeredDodecagonal ( n ) ; cout << endl ; n = 9 ; cout << centeredDodecagonal ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int centeredTridecagonalNum ( long int n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; } int main ( ) { long int n = 3 ; cout << centeredTridecagonalNum ( n ) ; cout << endl ; n = 10 ; cout << centeredTridecagonalNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; } int main ( ) { int a1 = 2 , b1 = -3 , c1 = 5 ; int a2 = 3 , b2 = 4 , c2 = -7 ; int a3 = 9 , b3 = -5 , c3 = 8 ; ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ? ( cout << " Yes " ) : ( cout << " No " ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int center_octadecagon_num ( long int n ) { return 9 * n * n - 9 * n + 1 ; } int main ( ) { long int n = 3 ; cout << n << " th ▁ centered ▁ octadecagonal ▁ number ▁ : ▁ " << center_octadecagon_num ( n ) ; cout << endl ; n = 13 ; cout << n << " th ▁ centered ▁ octadecagonal ▁ number ▁ : ▁ " << center_octadecagon_num ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; } int main ( ) { int n = 5 ; cout << n << " th ▁ centered ▁ decagonal " << " number : ▁ " ; cout << centereddecagonalnum ( n ) ; cout << endl ; n = 9 ; cout << n << " th ▁ centered ▁ decagonal " << " number : ▁ " ; cout << centereddecagonalnum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int a , int b ) { int res = 1 ; for ( int i = 1 ; i <= ( a + b ) ; i ++ ) res = res * i ; for ( int i = 1 ; i <= a ; i ++ ) res = res / i ; for ( int i = 1 ; i <= b ; i ++ ) res = res / i ; return res ; } void Ksmallest ( int x , int y , int k ) { if ( x == 0 && y == 0 ) return ; else if ( x == 0 ) { y -- ; cout << " V " ; Ksmallest ( x , y , k ) ; } else if ( y == 0 ) { x -- ; cout << " H " ; Ksmallest ( x , y , k ) ; } else { if ( factorial ( x - 1 , y ) > k ) { cout << " H " ; Ksmallest ( x - 1 , y , k ) ; } else { cout << " V " ; Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) ; } } } int main ( ) { int x = 2 , y = 2 , k = 2 ; Ksmallest ( x , y , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; } int main ( ) { int n = 7 ; cout << n << " th ▁ Centered ▁ pentagonal ▁ number : ▁ " ; cout << centered_pentagonal_Num ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pivotDis ( int x0 , int y0 , int x1 , int y1 ) { return sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) ; } int minDis ( int D , int r1 , int r2 ) { return max ( ( D - r1 - r2 ) , 0 ) ; } int maxDis ( int D , int r1 , int r2 ) { return D + r1 + r2 ; } int main ( ) { int x0 = 0 , y0 = 0 , x1 = 8 , y1 = 0 , r1 = 4 , r2 = 5 ; int D = pivotDis ( x0 , y0 , x1 , y1 ) ; cout << " Distance ▁ while ▁ repulsion ▁ = ▁ " << maxDis ( D , r1 , r2 ) ; cout << " Distance while attraction = " return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRect ( int X [ ] , int Y [ ] , int n ) { int Xmax = * max_element ( X , X + n ) ; int Xmin = * min_element ( X , X + n ) ; int Ymax = * max_element ( Y , Y + n ) ; int Ymin = * min_element ( Y , Y + n ) ; cout << " { " << Xmin << " , ▁ " << Ymin << " } " << endl ; cout << " { " << Xmin << " , ▁ " << Ymax << " } " << endl ; cout << " { " << Xmax << " , ▁ " << Ymax << " } " << endl ; cout << " { " << Xmax << " , ▁ " << Ymin << " } " << endl ; } int main ( ) { int X [ ] = { 4 , 3 , 6 , 1 , -1 , 12 } ; int Y [ ] = { 4 , 1 , 10 , 3 , 7 , -1 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; printRect ( X , Y , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; } int main ( ) { if ( checkOrigin ( 1 , 28 , 2 , 56 ) == true ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isBetween ( int a , int b , int c ) { return min ( a , b ) <= c && c <= max ( a , b ) ; } bool canJoin ( int x [ ] , int y [ ] , int i , int j , int k ) { return ( x [ k ] == x [ i ] x [ k ] == x [ j ] ) && isBetween ( y [ i ] , y [ j ] , y [ k ] ) || ( y [ k ] == y [ i ] y [ k ] == y [ j ] ) && isBetween ( x [ i ] , x [ j ] , x [ k ] ) ; } int countLineSegments ( int x [ ] , int y [ ] ) { if ( ( x [ 0 ] == x [ 1 ] && x [ 1 ] == x [ 2 ] ) || ( y [ 0 ] == y [ 1 ] && y [ 1 ] == y [ 2 ] ) ) return 1 ; else if ( canJoin ( x , y , 0 , 1 , 2 ) || canJoin ( x , y , 0 , 2 , 1 ) || canJoin ( x , y , 1 , 2 , 0 ) ) return 2 ; else return 3 ; } int main ( ) { int x [ 3 ] , y [ 3 ] ; x [ 0 ] = -1 ; y [ 0 ] = -1 ; x [ 1 ] = -1 ; y [ 1 ] = 3 ; x [ 2 ] = 4 ; y [ 2 ] = 3 ; cout << countLineSegments ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; } int main ( ) { int a = 1 , b = 2 , c = 2 , d = 3 ; if ( pythagorean_quadruple ( a , b , c , d ) ) cout << " Yes " << endl ; else cout << " No " << endl ; }
#include <iostream> NEW_LINE using namespace std ; void midpoint ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " ▁ , ▁ " << ( float ) ( y1 + y2 ) / 2 ; } int main ( ) { int x1 = -1 , y1 = 2 ; int x2 = 3 , y2 = -6 ; midpoint ( x1 , x2 , y1 , y2 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; float pi = 3.14159 ; float volume ( float r , float R , float h ) { return ( float ( 1 ) / float ( 3 ) ) * pi * h * ( r * r + R * R + r * R ) ; } float curved_surface_area ( float r , float R , float l ) { return pi * l * ( R + r ) ; } float total_surface_area ( float r , float R , float l , float h ) { return pi * l * ( R + r ) + pi * ( r * r + R * R ) ; } int main ( ) { float small_radius = 3 ; float big_radius = 8 ; float slant_height = 13 ; float height = 12 ; cout << " Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " << volume ( small_radius , big_radius , height ) << endl ; cout << " Curved ▁ Surface ▁ Area ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " << curved_surface_area ( small_radius , big_radius , slant_height ) << endl ; cout << " Total ▁ Surface ▁ Area ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " << total_surface_area ( small_radius , big_radius , slant_height , height ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Circumference ( int a ) { return 4 * a ; } int main ( ) { int a = 5 ; cout << " Circumference ▁ of " << " ▁ a ▁ square ▁ is ▁ " << Circumference ( a ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { cout << " Angle ▁ cannot " , " ▁ be ▁ formed " ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } } int main ( ) { double diameter = 25.0 ; double angle = 45.0 ; double arc_len = arcLength ( diameter , angle ) ; cout << ( arc_len ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct point { int x , y ; } ; const int RIGHT = 1 , LEFT = -1 , ZERO = 0 ; int directionOfPoint ( point A , point B , point P ) { B . x -= A . x ; B . y -= A . y ; P . x -= A . x ; P . y -= A . y ; int cross_product = B . x * P . y - B . y * P . x ; if ( cross_product > 0 ) return RIGHT ; if ( cross_product < 0 ) return LEFT ; return ZERO ; } int main ( ) { point A , B , P ; A . x = -30 ; B . x = 29 ; P . x = 15 ; int direction = directionOfPoint ( A , B , P ) ; if ( direction == 1 ) cout << " Right ▁ Direction " << endl ; else if ( direction == -1 ) cout << " Left ▁ Direction " << endl ; else cout << " Point ▁ is ▁ on ▁ the ▁ Line " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( dis , dis + n ) ; return dis [ k - 1 ] ; } int main ( ) { int k = 3 ; int x [ ] = { 1 , -1 , 1 } ; int y [ ] = { 1 , -1 , -1 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; cout << minRadius ( k , x , y , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int areaRectangle ( int a , int b ) { int area = a * b ; return area ; } int perimeterRectangle ( int a , int b ) { int perimeter = 2 * ( a + b ) ; return perimeter ; } int main ( ) { int a = 5 ; int b = 6 ; cout << " Area ▁ = ▁ " << areaRectangle ( a , b ) << endl ; cout << " Perimeter ▁ = ▁ " << perimeterRectangle ( a , b ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int areaSquare ( int side ) { int area = side * side ; return area ; } int main ( ) { int side = 4 ; cout << areaSquare ( side ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minPerimeter ( int n ) { int l = sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long long int row = n / l ; long long int perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } } int main ( ) { int n = 10 ; cout << minPerimeter ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void possibleOrNot ( long long a1 , long long a2 , long long b1 , long long b2 , long long c1 , long long c2 ) { long long dis1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ; long long dis2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) cout << " No " ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) cout << " No " ; else cout << " Yes " ; } int main ( ) { ios_base :: sync_with_stdio ( false ) ; cin . tie ( NULL ) ; long long a1 = 1 , a2 = 0 , b1 = 2 , b2 = 0 , c1 = 3 , c2 = 0 ; possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return min ( c1 , c2 ) ; } int main ( ) { int k = 6 , a = 1 , b = 3 ; cout << countObtuseAngles ( a , b , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Point { float x , y ; Point ( ) { x = y = 0 ; } Point ( float a , float b ) { x = a , y = b ; } } ; void printPoints ( Point source , float l , int m ) { Point a , b ; if ( m == 0 ) { a . x = source . x + l ; a . y = source . y ; b . x = source . x - l ; b . y = source . y ; } else if ( m == std :: numeric_limits < float > :: max ( ) ) { a . x = source . x ; a . y = source . y + l ; b . x = source . x ; b . y = source . y - l ; } else { float dx = ( l / sqrt ( 1 + ( m * m ) ) ) ; float dy = m * dx ; a . x = source . x + dx ; a . y = source . y + dy ; b . x = source . x - dx ; b . y = source . y - dy ; } cout << a . x << " , ▁ " << a . y << endl ; cout << b . x << " , ▁ " << b . y << endl ; } int main ( ) { Point p ( 2 , 1 ) , q ( 1 , 0 ) ; printPoints ( p , sqrt ( 2 ) , 1 ) ; cout << endl ; printPoints ( q , 5 , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Point { float x , y ; Point ( ) { x = y = 0 ; } Point ( float a , float b ) { x = a , y = b ; } } ; void printCorners ( Point p , Point q , float l ) { Point a , b , c , d ; if ( p . x == q . x ) { a . x = p . x - ( l / 2.0 ) ; a . y = p . y ; d . x = p . x + ( l / 2.0 ) ; d . y = p . y ; b . x = q . x - ( l / 2.0 ) ; b . y = q . y ; c . x = q . x + ( l / 2.0 ) ; c . y = q . y ; } else if ( p . y == q . y ) { a . y = p . y - ( l / 2.0 ) ; a . x = p . x ; d . y = p . y + ( l / 2.0 ) ; d . x = p . x ; b . y = q . y - ( l / 2.0 ) ; b . x = q . x ; c . y = q . y + ( l / 2.0 ) ; c . x = q . x ; } else { float m = ( p . x - q . x ) / float ( q . y - p . y ) ; float dx = ( l / sqrt ( 1 + ( m * m ) ) ) * 0.5 ; float dy = m * dx ; a . x = p . x - dx ; a . y = p . y - dy ; d . x = p . x + dx ; d . y = p . y + dy ; b . x = q . x - dx ; b . y = q . y - dy ; c . x = q . x + dx ; c . y = q . y + dy ; } cout << a . x << " , ▁ " << a . y << " ▁ n " << b . x << " , ▁ " << b . y << " n " ; << c . x << " , ▁ " << c . y << " ▁ n " << d . x << " , ▁ " << d . y << " nn " ; } int main ( ) { Point p1 ( 1 , 0 ) , q1 ( 1 , 2 ) ; printCorners ( p1 , q1 , 2 ) ; Point p ( 1 , 1 ) , q ( -1 , -1 ) ; printCorners ( p , q , 2 * sqrt ( 2 ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct point { int x , y ; point ( int x , int y ) : x ( x ) , y ( y ) { } } ; struct line { int a , b , c ; line ( int a , int b , int c ) : a ( a ) , b ( b ) , c ( c ) { } line ( ) { } } ; int evalPointOnLine ( point p , line curLine ) { int eval = curLine . a * p . x + curLine . b * p . y + curLine . c ; if ( eval > 0 ) return 1 ; return -1 ; } int minJumpToReachDestination ( point start , point dest , line lines [ ] , int N ) { int jumps = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int signStart = evalPointOnLine ( start , lines [ i ] ) ; int signDest = evalPointOnLine ( dest , lines [ i ] ) ; if ( signStart * signDest < 0 ) jumps ++ ; } return jumps ; } int main ( ) { point start ( 1 , 1 ) ; point dest ( -2 , -1 ) ; line lines [ 3 ] ; lines [ 0 ] = line ( 1 , 0 , 0 ) ; lines [ 1 ] = line ( 0 , 1 , 0 ) ; lines [ 2 ] = line ( 1 , 1 , -2 ) ; cout << minJumpToReachDestination ( start , dest , lines , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Interval { int start , end ; Interval ( int start , int end ) : start ( start ) , end ( end ) { } } ; int minDistanceToCoverIntervals ( Interval intervals [ ] , int N , int x ) { int rightMostStart = INT_MIN ; int leftMostEnd = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { if ( rightMostStart < intervals [ i ] . start ) rightMostStart = intervals [ i ] . start ; if ( leftMostEnd > intervals [ i ] . end ) leftMostEnd = intervals [ i ] . end ; } int res ; if ( rightMostStart > leftMostEnd ) res = -1 ; else if ( rightMostStart <= x && x <= leftMostEnd ) res = 0 ; else res = ( x < rightMostStart ) ? ( rightMostStart - x ) : ( x - leftMostEnd ) ; return res ; } int main ( ) { int x = 3 ; Interval intervals [ ] = { { 0 , 7 } , { 2 , 14 } , { 4 , 6 } } ; int N = sizeof ( intervals ) / sizeof ( intervals [ 0 ] ) ; int res = minDistanceToCoverIntervals ( intervals , N , x ) ; if ( res == -1 ) cout << " Not ▁ Possible ▁ to ▁ cover ▁ all ▁ intervals STRNEWLINE " ; else cout << res << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkPoint ( int radius , int x , int y , float percent , float startAngle ) { float endAngle = 360 / percent + startAngle ; float polarradius = sqrt ( x * x + y * y ) ; float Angle = atan ( y / x ) ; if ( Angle >= startAngle && Angle <= endAngle && polarradius < radius ) printf ( " Point ▁ ( % d , ▁ % d ) ▁ exist ▁ in ▁ the ▁ circle ▁ sector STRNEWLINE " , x , y ) ; else printf ( " Point ▁ ( % d , ▁ % d ) ▁ does ▁ not ▁ exist ▁ in ▁ the ▁ circle ▁ sector STRNEWLINE " , x , y ) ; } int main ( ) { int radius = 8 , x = 3 , y = 4 ; float percent = 12 , startAngle = 0 ; checkPoint ( radius , x , y , percent , startAngle ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct point { int x , y ; point ( ) { } point ( int x , int y ) : x ( x ) , y ( y ) { } } ; int square ( int x ) { return x * x ; } void order ( int & a , int & b , int & c ) { int copy [ 3 ] ; copy [ 0 ] = a ; copy [ 1 ] = b ; copy [ 2 ] = c ; sort ( copy , copy + 3 ) ; a = copy [ 0 ] ; b = copy [ 1 ] ; c = copy [ 2 ] ; } int euclidDistSquare ( point p1 , point p2 ) { return square ( p1 . x - p2 . x ) + square ( p1 . y - p2 . y ) ; } string getSideClassification ( int a , int b , int c ) { if ( a == b && b == c ) return " Equilateral " ; else if ( a == b b == c ) return " Isosceles " ; else return " Scalene " ; } string getAngleClassification ( int a , int b , int c ) { if ( a + b > c ) return " acute " ; else if ( a + b == c ) return " right " ; else return " obtuse " ; } void classifyTriangle ( point p1 , point p2 , point p3 ) { int a = euclidDistSquare ( p1 , p2 ) ; int b = euclidDistSquare ( p1 , p3 ) ; int c = euclidDistSquare ( p2 , p3 ) ; order ( a , b , c ) ; cout << " Triangle ▁ is ▁ " + getAngleClassification ( a , b , c ) + " ▁ and ▁ " + getSideClassification ( a , b , c ) << endl ; } int main ( ) { point p1 , p2 , p3 ; p1 = point ( 3 , 0 ) ; p2 = point ( 0 , 4 ) ; p3 = point ( 4 , 7 ) ; classifyTriangle ( p1 , p2 , p3 ) ; p1 = point ( 0 , 0 ) ; p2 = point ( 1 , 1 ) ; p3 = point ( 1 , 2 ) ; classifyTriangle ( p1 , p2 , p3 ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; void findDifferenceArray ( int arr [ ] , int N ) { set < int > S1 ; set < int > S2 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { S1 . insert ( arr [ j ] ) ; } for ( int j = i + 1 ; j < N ; j ++ ) { S2 . insert ( arr [ j ] ) ; } cout << abs ( ( int ) S1 . size ( ) - ( int ) S2 . size ( ) ) << ' ▁ ' ; S1 . clear ( ) ; S2 . clear ( ) ; } } int main ( ) { int arr [ ] = { 7 , 7 , 3 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findDifferenceArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSubarraySum ( vector < int > & arr ) { int N = arr . size ( ) ; unordered_map < int , int > memo ; int res = INT_MIN ; int currsum = 0 , currval = 0 ; for ( int i = 0 ; i < N ; ++ i ) { currval = arr [ i ] ; currsum = currsum + currval ; if ( memo . count ( currval ) != 0 ) { if ( currval > 0 ) res = max ( res , currsum - memo [ currval ] + currval ) ; else res = max ( res , currsum - memo [ currval ] + 2 * currval ) ; } else memo [ currval ] = currsum ; if ( currval < 0 ) currsum = currsum - currval ; } return res ; } int main ( ) { vector < int > arr = { -1 , -3 , 4 , 0 , -1 , -2 } ; cout << maximumSubarraySum ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double f ( double x , int p , double num ) { return pow ( x , p ) - num ; } double f_prime ( double x , int p ) { return p * pow ( x , p - 1 ) ; } double root ( double num , int p ) { double left = - num ; double right = num ; double x ; while ( true ) { x = ( left + right ) / 2.0 ; double value = f ( x , p , num ) ; double prime = f_prime ( x , p ) ; if ( value * prime <= 0 ) left = x ; else right = x ; if ( value < 0.000001 && value >= 0 ) { return x ; } } } int main ( ) { double P = 1234321 ; int N = 2 ; double ans = root ( P , N ) ; cout << ans ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumAdditionOperation ( unsigned long long int N ) { int count = 0 ; while ( N ) { if ( N & 1 == 1 ) { count ++ ; } N = N >> 1 ; } return count ; } int main ( ) { int N = 6 ; cout << minimumAdditionOperation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumOperations ( int arr [ ] , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; while ( arr [ i ] % 2 == 0 ) { arr [ i ] = arr [ i ] / 2 ; count ++ ; } if ( mini > count ) { mini = count ; } } return mini ; } int main ( ) { int arr [ ] = { 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumOperations ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSizeArr ( int A , int B ) { int currXor = 0 ; int reminder = ( A - 1 ) % 4 ; if ( reminder == 0 ) currXor = A - 1 ; else if ( reminder == 1 ) currXor = 1 ; else if ( reminder == 2 ) currXor = A ; int minSize = A ; if ( currXor == B ) return minSize ; else if ( currXor ^ B == A ) return minSize + 2 ; else return minSize + 1 ; } int main ( ) { int A = 1 ; int B = 999 ; cout << minimumSizeArr ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int N ) { int cnt = 0 ; for ( int A = 1 ; A <= N ; ++ A ) { for ( int B = 1 ; B <= N / A ; ++ B ) { cnt += N / ( A * B ) ; } } return cnt ; } int main ( ) { int N = 2 ; cout << countTriplets ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberOfPasses ( vector < int > arr , int N ) { for ( int i = 0 ; i < N ; ++ i ) { -- arr [ i ] ; } for ( int i = 0 ; i < N ; ++ i ) { int cnt = 0 ; int k = i ; do { ++ cnt ; k = arr [ k ] ; } while ( k != i ) ; cout << cnt << " ▁ " ; } } int main ( ) { vector < int > arr { 4 , 6 , 2 , 1 , 5 , 3 } ; int N = arr . size ( ) ; numberOfPasses ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int A [ ] , int B [ ] , int N ) { int cnt = 0 ; int i = 0 ; while ( i < N ) { int j = 0 ; while ( j < N && i < N ) { if ( B [ i ] == A [ j ] ) { i ++ ; } j ++ ; } cnt ++ ; } return cnt ; } int main ( ) { int A [ ] = { 2 , 4 , 6 , 1 , 5 , 3 } ; int B [ ] = { 6 , 5 , 4 , 2 , 3 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minOperations ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDistinctSums ( int N , int L , int R ) { int minSum = L * N ; int maxSum = R * N ; return maxSum - minSum + 1 ; } int main ( ) { int N = 2 , L = 1 , R = 3 ; cout << countDistinctSums ( N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void setSumtoZero ( double arr [ ] , int N ) { int A [ N ] ; int sum = 0 ; int m = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { sum += ceil ( arr [ i ] ) ; A [ i ] = ceil ( arr [ i ] ) ; } if ( sum > 0 ) { m = min ( sum , N ) ; for ( int i = 0 ; i < N && m > 0 ; i ++ ) { A [ i ] = floor ( arr [ i ] ) ; if ( A [ i ] != floor ( arr [ i ] ) ) m -- ; } } for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << " ▁ " ; } } int main ( ) { double arr [ ] = { -2 , -2 , 4.5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; setSumtoZero ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Get ( vector < int > & graph , int a ) { return graph [ a ] = ( graph [ a ] == a ? a : Get ( graph , graph [ a ] ) ) ; } void Union ( vector < int > & graph , int a , int b ) { a = Get ( graph , a ) ; b = Get ( graph , b ) ; graph [ a ] = b ; } void Queries ( vector < pair < int , int > > & queries , int N , int M ) { vector < int > graph ( N + 2 ) ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { graph [ i ] = i ; } for ( auto query : queries ) { if ( query . first == 1 ) { Union ( graph , query . second , query . second + 1 ) ; } else { int a = Get ( graph , query . second ) ; if ( a == N + 1 ) cout << -1 << " ▁ " ; else cout << graph [ a ] << " ▁ " ; } } } int main ( ) { int N = 5 ; vector < pair < int , int > > queries { { 2 , 1 } , { 1 , 1 } , { 2 , 1 } , { 2 , 3 } } ; int Q = queries . size ( ) ; Queries ( queries , N , Q ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; long long convertToBase9 ( long long n ) { long long ans = 0 ; long long a = 1 ; while ( n > 0 ) { ans += ( a * ( n % 9 ) ) ; a *= 10 ; n /= 9 ; } return ans ; } long long getNthnumber ( long long base9 , long long K ) { long long ans = 0 ; long long a = 1 ; while ( base9 > 0 ) { int cur = base9 % 10 ; if ( cur >= K ) { ans += a * ( cur + 1 ) ; } else { ans += a * cur ; } base9 /= 10 ; a *= 10 ; } return ans ; } int main ( ) { long long N = 10 , K = 1 ; long long base9 = convertToBase9 ( N ) ; cout << getNthnumber ( base9 , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool binarySearch ( float arr [ ] , int size , float key ) { int low = 0 , high = size - 1 , mid ; while ( low <= high ) { mid = low + ( high - low ) / 2 ; if ( key > arr [ mid ] ) low = mid + 1 ; else if ( key < arr [ mid ] ) high = mid - 1 ; else return 1 ; } return 0 ; } bool twoPointers ( float arr [ ] , int N , float mean ) { int i = 0 , j = N - 1 ; while ( i < j ) { float temp = ( arr [ i ] + arr [ j ] ) / 2 ; if ( temp > mean ) j -- ; else if ( temp < mean ) i ++ ; else return 1 ; } return 0 ; } bool checkArray ( float arr [ ] , int N ) { float sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; float mean = sum / N ; if ( N & 1 ) return binarySearch ( arr , N , mean ) ; else return twoPointers ( arr , N , mean ) ; } int main ( ) { float arr [ ] = { 1.0 , 3.0 , 6.0 , 9.0 , 12.0 , 32.0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkArray ( arr , N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int UniqueGeometricTerms ( int N , int a1 , int r1 , int a2 , int r2 ) { set < int > S ; long long p1 = a1 ; for ( int i = 0 ; i < N ; i ++ ) { S . insert ( p1 ) ; p1 = ( long long ) ( p1 * r1 ) ; } long long p2 = a2 ; for ( int i = 0 ; i < N ; i ++ ) { S . insert ( p2 ) ; p2 = ( long long ) ( p2 * r2 ) ; } return S . size ( ) ; } int main ( ) { int N = 5 ; int a1 = 3 , r1 = 2 , a2 = 2 , r2 = 3 ; cout << UniqueGeometricTerms ( N , a1 , r1 , a2 , r2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int arr [ ] , int N , int K ) { vector < pair < int , int > > vp ; for ( int i = 0 ; i < N ; i ++ ) { vp . push_back ( { arr [ i ] , i } ) ; } sort ( vp . begin ( ) , vp . end ( ) ) ; int minCnt = 0 ; while ( ! vp . empty ( ) ) { int val , ind ; val = vp . back ( ) . first ; ind = vp . back ( ) . second ; minCnt ++ ; while ( ! vp . empty ( ) && vp . back ( ) . first == val && ind - vp . back ( ) . second + 1 <= K ) vp . pop_back ( ) ; } return minCnt ; } int main ( ) { int arr [ ] = { 18 , 11 , 18 , 11 , 18 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nearestLeft ( int arr [ ] , int N , vector < int > & steps ) { int L = - N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { L = - ( N - i ) ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { L = i ; } steps [ i ] = i - L ; } } void nearestRight ( int arr [ ] , int N , vector < int > & steps ) { int R = 2 * N ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] > 0 ) { R = N + i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] > 0 ) { R = i ; } steps [ i ] = min ( steps [ i ] , R - i ) ; } } int findSum ( int arr [ ] , int N , int M , int K ) { vector < int > steps ( N ) ; int sum = accumulate ( arr , arr + N , 0 ) ; if ( sum == 0 ) { return 0 ; } nearestLeft ( arr , N , steps ) ; nearestRight ( arr , N , steps ) ; for ( int i = 0 ; i < N ; i ++ ) sum += 2 * K * max ( 0 , M - steps [ i ] ) ; return sum ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = 2 ; int K = 1 ; cout << findSum ( arr , N , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int chk ( int n ) { vector < int > v ; while ( n != 0 ) { v . push_back ( n % 2 ) ; n = n / 2 ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] == 1 ) { return pow ( 2 , i ) ; } } return 0 ; } void sumOfLSB ( int arr [ ] , int N ) { vector < int > lsb_arr ; for ( int i = 0 ; i < N ; i ++ ) { lsb_arr . push_back ( chk ( arr [ i ] ) ) ; } sort ( lsb_arr . begin ( ) , lsb_arr . end ( ) , greater < int > ( ) ) ; int ans = 0 ; for ( int i = 0 ; i < N - 1 ; i += 2 ) { ans += ( lsb_arr [ i + 1 ] ) ; } cout << ( ans ) ; } int main ( ) { int N = 5 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; sumOfLSB ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void elementsCoprimeWithArr ( int A [ ] , int N , int L , int R ) { unordered_set < int > S ; for ( int i = 0 ; i < N ; i ++ ) { int curr_ele = A [ i ] ; for ( int j = 1 ; j <= sqrt ( curr_ele ) + 1 ; j ++ ) { if ( curr_ele % j == 0 ) { S . insert ( j ) ; S . insert ( curr_ele / j ) ; } } } unordered_set < int > store ; for ( int i = L ; i <= R ; i ++ ) store . insert ( i ) ; S . erase ( 1 ) ; for ( auto it : S ) { int ele = it ; int index = 1 ; while ( index * ele <= R ) { store . erase ( index * ele ) ; index ++ ; } } for ( auto i : store ) { cout << i << " ▁ " ; } } int main ( ) { int arr [ ] = { 3 , 5 } ; int L = 1 , R = 10 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; elementsCoprimeWithArr ( arr , N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < int > > adj ( 100000 ) ; vector < int > setNum ( 100000 ) ; void addEdge ( int a1 , int a2 ) { adj [ a1 ] . push_back ( a2 ) ; adj [ a2 ] . push_back ( a1 ) ; } void toBipartite ( int N ) { setNum . assign ( N , -1 ) ; queue < int > q ; q . push ( 0 ) ; setNum [ 0 ] = 0 ; while ( ! q . empty ( ) ) { int v = q . front ( ) ; q . pop ( ) ; for ( int u : adj [ v ] ) { if ( setNum [ u ] == -1 ) { setNum [ u ] = setNum [ v ] ^ 1 ; q . push ( u ) ; } } } } void pathLengthQuery ( int A , int B ) { if ( setNum [ A ] == setNum [ B ] ) { cout << " Odd " << endl ; } else { cout << " Even " << endl ; } } int main ( ) { int N = 7 ; addEdge ( 0 , 1 ) ; addEdge ( 0 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 3 , 4 ) ; addEdge ( 3 , 5 ) ; addEdge ( 2 , 6 ) ; toBipartite ( N ) ; pathLengthQuery ( 4 , 2 ) ; pathLengthQuery ( 0 , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPowerof2 ( int n ) { int p = int ( log2 ( n ) ) ; if ( p % 2 == 0 ) p -= 1 ; return int ( pow ( 2 , p ) ) ; } int minStep ( int N , int X ) { if ( N % 2 and X == 0 ) return -1 ; int size = 0 ; while ( X < N ) { N -= highestPowerof2 ( N ) ; size += 1 ; } if ( N ) size += 1 ; return size ; } int main ( ) { int N = 11 ; int X = 2 ; cout << ( minStep ( N , X ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkSameDigits ( int N ) { int digit = N % 10 ; while ( N != 0 ) { int current_digit = N % 10 ; N = N / 10 ; if ( current_digit != digit ) { return " No " ; } } return " Yes " ; } int main ( ) { int N = 222 ; cout << ( checkSameDigits ( N ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int positionAfterKJumps ( int X , int Y , int K ) { int addY = Y * ( K / 2 ) ; int reduceX = -1 * X * ( K / 2 + K % 2 ) ; return addY + reduceX ; } int main ( ) { int X = 2 , Y = 5 , K = 3 ; cout << positionAfterKJumps ( X , Y , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxK ( int N ) { int K = N ; for ( int i = N - 1 ; i >= 0 ; i -- ) { K &= i ; if ( K == 0 ) { return i ; } } return 0 ; } int main ( ) { int N = 5 ; cout << findMaxK ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ j ] % arr [ i ] == 0 ) && ( j + 1 ) % ( i + 1 ) == 0 && ( arr [ j ] / arr [ i ] == ( j + 1 ) / ( i + 1 ) ) ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 5 , -2 , 4 , 20 , 25 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinMax ( vector < int > & a ) { int min_val = 1000000000 ; for ( int i = 1 ; i < a . size ( ) ; ++ i ) { min_val = min ( min_val , a [ i ] * a [ i - 1 ] ) ; } return min_val ; } int main ( ) { vector < int > arr = { 6 , 4 , 5 , 6 , 2 , 4 , 1 } ; cout << findMinMax ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long factorial ( int n ) { long long ans = 1 ; while ( n >= 1 ) { ans *= n ; n -- ; } return ans ; } void Binary_Num ( int n , int k ) { long long num_even , num_odd ; if ( n - k - 1 >= 0 && k - 1 >= 0 ) { num_even = factorial ( n - 2 ) / ( factorial ( k - 1 ) * factorial ( n - k - 1 ) ) ; } else { num_even = 0 ; } if ( k - 2 >= 0 ) { num_odd = factorial ( n - 2 ) / ( factorial ( k - 2 ) * factorial ( n - k ) ) ; } else { num_odd = 0 ; } cout << num_even << " ▁ " << num_odd << endl ; } int main ( ) { int N = 9 , K = 6 ; Binary_Num ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int intCount ( int X , int K ) { int ans = 0 ; for ( int z = 0 ; z < pow ( 10 , K ) ; z += ( pow ( 10 , K ) - 1 ) / 9 ) { if ( z > X ) break ; ans += ( ( X - z ) / pow ( 10 , K ) + 1 ) ; } return ans ; } int intCountInRange ( int L , int R , int K ) { return ( intCount ( R , K ) - intCount ( L - 1 , K ) ) ; } int main ( ) { int L = 49 ; int R = 101 ; int K = 2 ; cout << intCountInRange ( L , R , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct TreeNode { int data ; TreeNode * left ; TreeNode * right ; TreeNode ( int data ) { this -> data = data ; this -> left = NULL ; this -> right = NULL ; } } ; void kDistanceDownSum ( TreeNode * root , int k , int & sum ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { sum += root -> data ; return ; } kDistanceDownSum ( root -> left , k - 1 , sum ) ; kDistanceDownSum ( root -> right , k - 1 , sum ) ; } int kDistanceSum ( TreeNode * root , int target , int k , int & sum ) { if ( root == NULL ) return -1 ; if ( root -> data == target ) { kDistanceDownSum ( root -> left , k - 1 , sum ) ; return 0 ; } int dl = -1 ; if ( target < root -> data ) { dl = kDistanceSum ( root -> left , target , k , sum ) ; } if ( dl != -1 ) { if ( dl + 1 == k ) sum += root -> data ; return -1 ; } int dr = -1 ; if ( target > root -> data ) { dr = kDistanceSum ( root -> right , target , k , sum ) ; } if ( dr != -1 ) { if ( dr + 1 == k ) sum += root -> data ; else kDistanceDownSum ( root -> left , k - dr - 2 , sum ) ; return 1 + dr ; } return -1 ; } TreeNode * insertNode ( int data , TreeNode * root ) { if ( root == NULL ) { TreeNode * node = new TreeNode ( data ) ; return node ; } else if ( data > root -> data ) { root -> right = insertNode ( data , root -> right ) ; } else if ( data <= root -> data ) { root -> left = insertNode ( data , root -> left ) ; } return root ; } void findSum ( TreeNode * root , int target , int K ) { int sum = 0 ; kDistanceSum ( root , target , K , sum ) ; cout << sum ; } int main ( ) { TreeNode * root = NULL ; int N = 11 ; int tree [ ] = { 3 , 1 , 7 , 0 , 2 , 5 , 10 , 4 , 6 , 9 , 8 } ; for ( int i = 0 ; i < N ; i ++ ) { root = insertNode ( tree [ i ] , root ) ; } int target = 7 ; int K = 2 ; findSum ( root , target , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool can ( int Mid , int X , int Y , int A , int B ) { int p1 = X - Mid * B ; int p2 = Y - Mid * B ; if ( p1 < 0 p2 < 0 ) { return false ; } int k = A - B ; if ( k == 0 ) { return true ; } int val = p1 / k + p2 / k ; if ( val >= Mid ) { return true ; } return false ; } int maxPossibleMoves ( int X , int Y , int A , int B ) { int ans = 0 ; int L = 1 , R = MAXN ; while ( L <= R ) { int Mid = ( L + R ) / 2 ; if ( can ( Mid , X , Y , A , B ) ) { L = Mid + 1 ; ans = max ( ans , Mid ) ; } else { R = Mid - 1 ; } } return ans ; } int main ( ) { int X = 10 , Y = 12 , A = 2 , B = 5 ; if ( A < B ) { swap ( A , B ) ; } cout << maxPossibleMoves ( X , Y , A , B ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFactors ( int n ) { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { int d1 = i , d2 = n ; while ( d2 % d1 == 0 ) { d2 = d2 / d1 ; } if ( d1 > 1 && d2 > 1 ) { cout << d1 << " , ▁ " << d2 ; return ; } } } cout << -1 ; } int main ( ) { int N = 10 ; printFactors ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  100000 NEW_LINE vector < int > bit1 ( MAXN , 0 ) ; vector < int > bit2 ( MAXN , 0 ) ; void update ( int idx , int val , vector < int > & bit ) { while ( idx < bit . size ( ) ) { bit [ idx ] += val ; idx += idx & ( - idx ) ; } } int query ( int idx , vector < int > & bit ) { int res = 0 ; while ( idx > 0 ) { res += bit [ idx ] ; idx -= idx & ( - idx ) ; } return res ; } void buildFenwickTree ( int a [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { update ( i , a [ i - 1 ] , bit1 ) ; update ( i , a [ i - 1 ] * a [ i - 1 ] , bit2 ) ; } } void pairwiseProductSum ( int a [ ] , int l , int r ) { int sum , e , q ; e = query ( r , bit1 ) - query ( l - 1 , bit1 ) ; e = e * e ; q = query ( r , bit2 ) - query ( l - 1 , bit2 ) ; sum = ( e - q ) / 2 ; cout << sum << endl ; } void updateArray ( int * a , int p , int x ) { update ( p , - a [ p - 1 ] , bit1 ) ; update ( p , x , bit1 ) ; update ( p , - a [ p - 1 ] * a [ p - 1 ] , bit2 ) ; update ( p , x * x , bit2 ) ; a [ p - 1 ] = x ; } void solveQueries ( int * a , int n , int Q , int query [ ] [ 3 ] ) { buildFenwickTree ( a , n ) ; for ( int i = 0 ; i < Q ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) pairwiseProductSum ( a , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else updateArray ( a , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; } } int main ( ) { int A [ ] = { 5 , 7 , 2 , 3 , 1 } ; int N = sizeof ( A ) / sizeof ( int ) ; int Q = 3 ; int query [ Q ] [ 3 ] = { { 1 , 1 , 3 } , { 2 , 2 , 5 } , { 1 , 2 , 5 } } ; solveQueries ( A , N , Q , query ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countTriplets ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; else even ++ ; } int c1 = odd * ( even * ( even - 1 ) ) / 2 ; int c2 = ( odd * ( odd - 1 ) * ( odd - 2 ) ) / 6 ; return c1 + c2 ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 4 , 5 , 10 , 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int ans = countTriplets ( arr , n ) ; cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTotalPairs ( int N , int K ) { if ( K == 0 ) { return N * N ; } int ans = 0 ; for ( int b = K + 1 ; b <= N ; b ++ ) { ans += ( N / b ) * ( b - K ) ; ans += max ( N % b - K + 1 , 0 ) ; } return ans ; } int main ( ) { int N = 5 , K = 2 ; cout << countTotalPairs ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSumDifference ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ar [ i ] ; int rem = sum % n ; return rem * ( n - rem ) ; } int main ( ) { int arr [ ] = { 3 , 6 , 8 , 5 , 2 , 1 , 11 , 7 , 10 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << minSumDifference ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairsCount ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = arr [ i ] - ( i % arr [ i ] ) ; j < n ; j += arr [ i ] ) { if ( i < j && abs ( arr [ i ] - arr [ j ] ) >= min ( arr [ i ] , arr [ j ] ) ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getPairsCount ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( int N ) { int count = 1 , res = 0 ; for ( int i = 1 ; i <= N ; i += count ) { res = max ( res , count ) ; count ++ ; } return res ; } int main ( ) { int N = 6 ; cout << minSteps ( N ) << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( int N ) { int res = ( sqrt ( 1 + 8 * N ) - 1 ) / 2 ; return res ; } int main ( ) { int N = 6 ; cout << minSteps ( N ) << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int oppositeFaceOfDice ( int N ) { int ans = 7 - N ; cout << ans ; } int main ( ) { int N = 2 ; oppositeFaceOfDice ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countReachablePoints ( int X , int Y , int L , int R ) { int diff_arr [ 100000 ] = { 0 } ; int count = 0 ; diff_arr [ X ] = 1 ; diff_arr [ X + 1 ] = -1 ; for ( int i = X ; i <= Y ; i ++ ) { diff_arr [ i ] += diff_arr [ i - 1 ] ; if ( diff_arr [ i ] >= 1 ) { diff_arr [ i + L ] += 1 ; diff_arr [ i + R + 1 ] -= 1 ; count ++ ; } } return count ; } int main ( ) { int X = 3 , Y = 12 , L = 2 , R = 3 ; cout << countReachablePoints ( X , Y , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; Node * newNode ( int data ) { Node * new_node = new Node ; new_node -> data = data ; new_node -> next = NULL ; return new_node ; } Node * reverse ( Node * head ) { Node * prev = NULL ; Node * current = head ; Node * next ; while ( current != NULL ) { next = current -> next ; current -> next = prev ; prev = current ; current = next ; } return prev ; } Node * multiplyHelp ( Node * head , int M ) { Node * res = head ; Node * prev = NULL ; int carry = 0 , product = 1 ; while ( head != NULL ) { product = head -> data * M ; product += carry ; carry = product / 10 ; head -> data = product % 10 ; prev = head ; head = head -> next ; } if ( carry > 0 ) prev -> next = newNode ( carry ) ; return res ; } Node * multiply ( Node * head , int M ) { head = reverse ( head ) ; head = multiplyHelp ( head , M ) ; return reverse ( head ) ; } void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data ; node = node -> next ; } } int main ( ) { Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 7 ) ; head -> next -> next -> next = newNode ( 3 ) ; int M = 3 ; head = multiply ( head , M ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > s ( 11 , 0 ) ; void sieveOfEratosthenes ( int N ) { bool prime [ N + 1 ] ; memset ( prime , false , sizeof ( false ) ) ; for ( int i = 2 ; i < N + 1 ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i < N + 1 ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j < N / i + 1 ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } int generatePrimeFactors ( int N ) { int curr = s [ N ] ; map < int , int > cnt ; cnt [ s [ N ] ] = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( N and s [ N ] ) if ( cnt . find ( s [ N ] ) == cnt . end ( ) ) cnt [ s [ N ] ] = 1 ; else cnt [ s [ N ] ] += 1 ; } if ( cnt . find ( 0 ) != cnt . end ( ) ) cnt . erase ( 0 ) ; int totfactor = 1 ; for ( auto i : cnt ) totfactor *= i . second + 1 ; return totfactor ; } int countTriplets ( int N ) { int CountTriplet = 0 ; for ( int z = 1 ; z < N + 1 ; z ++ ) { int p = generatePrimeFactors ( N - z ) ; if ( p > 1 ) CountTriplet += p ; } return CountTriplet + 1 ; } int main ( ) { int N = 10 ; sieveOfEratosthenes ( N ) ; cout << countTriplets ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkSum ( int arr [ ] , int n , int k ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; vector < int > freq [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int f = m [ arr [ i ] ] ; if ( f != -1 ) { freq [ f ] . push_back ( arr [ i ] ) ; m [ arr [ i ] ] = -1 ; } } int count = 0 ; int kleastfreqsum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int x : freq [ i ] ) { kleastfreqsum += x ; count ++ ; if ( count == k ) break ; } if ( count == k ) break ; } count = 0 ; int kmostfreqsum = 0 ; for ( int i = n ; i >= 0 ; i -- ) { for ( int x : freq [ i ] ) { kmostfreqsum += x ; count ++ ; if ( count == k ) break ; } if ( count == k ) break ; } if ( kleastfreqsum == kmostfreqsum ) return " Yes " ; return " No " ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 , 2 , 3 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << checkSum ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > solve ( int start , int end ) { string num = " " ; vector < int > ans ; for ( int i = 1 ; i <= 9 ; i ++ ) { num = to_string ( i ) ; int value = stoi ( num ) ; if ( value >= start and value <= end ) { ans . push_back ( value ) ; } for ( int j = i + 1 ; j <= 9 ; j ++ ) { num += to_string ( j ) ; value = stoi ( num ) ; if ( value >= start and value <= end ) { ans . push_back ( value ) ; } } } sort ( ans . begin ( ) , ans . end ( ) ) ; return ans ; } int main ( ) { int L = 12 , R = 87 ; vector < int > ans = solve ( 12 , 87 ) ; for ( auto & it : ans ) cout << it << ' ▁ ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDistance ( int start [ ] , int end [ ] , int n , int d ) { int left = INT_MIN ; int right = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { left = max ( left , start [ i ] ) ; right = min ( right , end [ i ] ) ; } if ( left > right ) return -1 ; if ( d >= left && d <= right ) return 0 ; if ( d < left ) return ( left - d ) ; if ( d > right ) return ( d - right ) ; } int main ( ) { int start [ ] = { 0 , 2 , 4 } ; int end [ ] = { 7 , 14 , 6 } ; int n = sizeof ( start ) / sizeof ( int ) ; int d = 3 ; cout << minDistance ( start , end , n , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } int order ( int num ) { int count = 0 ; while ( num ) { count ++ ; num = num / 10 ; } return count ; } int isArmstrong ( int N ) { int r = order ( N ) ; int temp = N , sum = 0 ; while ( temp ) { int d = temp % 10 ; sum += power ( d , r ) ; temp = temp / 10 ; } return ( sum == N ) ; } int maxSum ( int arr [ ] , int N , int K ) { if ( N < K ) { return -1 ; } int res = 0 ; for ( int i = 0 ; i < K ; i ++ ) { res += arr [ i ] ; } int curr_sum = res ; for ( int i = K ; i < N ; i ++ ) { curr_sum += arr [ i ] - arr [ i - K ] ; res = max ( res , curr_sum ) ; } return res ; } int maxArmstrong ( int arr [ ] , int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = isArmstrong ( arr [ i ] ) ; } return maxSum ( arr , N , K ) ; } int main ( ) { int arr [ ] = { 28 , 2 , 3 , 6 , 153 , 99 , 828 , 24 } ; int K = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxArmstrong ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( long long x , unsigned int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int countArrays ( int n , int k ) { int mod = 1000000007 ; int ans = power ( n , k , mod ) ; return ans ; } int main ( ) { int n = 3 , k = 5 ; int ans = countArrays ( n , k ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int arr [ ] , int N ) { int answer = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] + arr [ j ] == i + j ) { answer ++ ; } } } cout << answer ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkDistribution ( int R , int B , int D ) { if ( max ( R , B ) <= min ( R , B ) * ( D + 1 ) ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int R = 1 , B = 1 , D = 0 ; checkDistribution ( R , B , D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int itemType ( int n ) { int count = 0 ; for ( int day = 1 ; ; day ++ ) { for ( int type = day ; type > 0 ; type -- ) { count += type ; if ( count >= n ) return type ; } } } int main ( ) { int N = 10 ; cout << itemType ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < pair < int , int > > primeFactor ( int N ) { vector < pair < int , int > > v ; int count = 0 ; while ( ! ( N % 2 ) ) { N >>= 1 ; count ++ ; } if ( count ) v . push_back ( { 2 , count } ) ; for ( int i = 3 ; i <= sqrt ( N ) ; i += 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } if ( count ) { v . push_back ( { i , count } ) ; } } if ( N > 2 ) v . push_back ( { N , 1 } ) ; return v ; } void printAnswer ( int n ) { vector < pair < int , int > > v = primeFactor ( n ) ; int maxi_size = 0 , prime_factor = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( maxi_size < v [ i ] . second ) { maxi_size = v [ i ] . second ; prime_factor = v [ i ] . first ; } } if ( maxi_size < 2 ) { cout << 1 << ' ▁ ' << n ; } else { int product = 1 ; cout << maxi_size << endl ; for ( int i = 0 ; i < maxi_size - 1 ; i ++ ) { cout << prime_factor << " ▁ " ; product *= prime_factor ; } cout << ( n / product ) ; } } int main ( ) { int N = 360 ; printAnswer ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void IsEvenPath ( int Source [ ] , int Destination [ ] ) { int x_dif = abs ( Source [ 0 ] - Destination [ 0 ] ) ; int y_dif = abs ( Source [ 1 ] - Destination [ 1 ] ) ; int minsteps = x_dif + y_dif ; if ( minsteps % 2 == 0 ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int Source [ ] = { 2 , 1 } ; int Destination [ ] = { 1 , 4 } ; IsEvenPath ( Source , Destination ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string BaseConversion ( int N ) { string s = " " ; while ( N != 0 ) { if ( N % 2 == 0 ) { s = "0" + s ; } else { s = "1" + s ; N -- ; } N /= -2 ; } if ( s == " " ) { s = "0" ; } return s ; } int main ( ) { int N = -9 ; cout << BaseConversion ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void finalInstances ( int instances , int arr [ ] , int N ) { int i = 0 ; while ( i < N ) { if ( arr [ i ] < 25 && instances > 1 ) { double temp = ( instances / 2.0 ) ; instances = ( int ) ( ceil ( temp ) ) ; i = i + 10 ; } else if ( arr [ i ] > 60 && instances <= ( 2 * pow ( 10 , 8 ) ) ) { instances = instances * 2 ; i = i + 10 ; } i = i + 1 ; } cout << instances ; } int main ( ) { int instances = 2 ; int arr [ ] = { 25 , 23 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 76 , 80 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; finalInstances ( instances , arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( int N ) { int twos = 0 , fives = 0 ; while ( N % 2 == 0 ) { N /= 2 ; twos ++ ; } while ( N % 5 == 0 ) { N /= 5 ; fives ++ ; } if ( N == 1 && twos <= fives ) { cout << 2 * fives - twos ; } else { cout << -1 ; } } int main ( ) { int N = 50 ; check ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string isMakeZero ( int arr [ ] , int N , int K ) { map < int , int > MP ; vector < int > V ; int X = 1 ; int i ; while ( X > 0 && X < INT_MAX ) { V . push_back ( X ) ; X *= K ; } for ( i = 0 ; i < N ; i ++ ) { for ( int j = V . size ( ) - 1 ; j >= 0 ; j -- ) { if ( MP [ V [ j ] ] == 0 && V [ j ] <= arr [ i ] ) { arr [ i ] -= V [ j ] ; MP [ V [ j ] ] = 1 ; } } if ( arr [ i ] != 0 ) break ; } if ( i < N ) return " No " ; else return " Yes " ; } int main ( ) { int arr [ ] = { 8 , 0 , 3 , 4 , 80 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << isMakeZero ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string perfectSquare ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int p = sqrt ( arr [ i ] ) ; if ( p * p != arr [ i ] ) { return " No " ; } } return " Yes " ; } int main ( ) { int arr [ ] = { 1 , 4 , 100 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << perfectSquare ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countKAverageSubarrays ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int L = 0 ; L < n ; L ++ ) { int sum = 0 ; for ( int R = L ; R < n ; R ++ ) { sum += arr [ R ] ; int len = ( R - L + 1 ) ; if ( sum % len == 0 ) { int avg = sum / len ; if ( avg == k ) res ++ ; } } } return res ; } int main ( ) { int K = 6 ; int arr [ ] = { 12 , 5 , 3 , 10 , 4 , 8 , 10 , 12 , -6 , -1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countKAverageSubarrays ( arr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumElement ( int arr [ ] , int N , int K ) { int minElement = arr [ 0 ] ; for ( int i = 0 ; i < N ; ++ i ) { minElement = min ( minElement , arr [ i ] ) ; } int reqOperations = 0 ; for ( int i = 0 ; i < N ; ++ i ) { reqOperations += arr [ i ] - minElement ; } if ( reqOperations < K ) { K -= reqOperations ; minElement -= ( K + N - 1 ) / N ; } return minElement ; } int main ( ) { int arr [ ] = { 10 , 10 , 10 , 10 } ; int K = 7 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumElement ( arr , N , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void swap ( int & a , int & b ) { int temp = a ; a = b ; b = temp ; } void findPermutation ( int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = i + 1 ; } for ( int i = 1 ; i < N ; i += 2 ) { swap ( arr [ i ] , arr [ i - 1 ] ) ; } if ( N % 2 == 1 && N > 1 ) { swap ( arr [ N - 1 ] , arr [ N - 2 ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } int main ( ) { int N = 7 ; findPermutation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rangeSum ( int arr [ ] , int N , int L , int R ) { int sum = 0 ; for ( int i = L - 1 ; i < R ; i ++ ) { sum += arr [ i % N ] ; } cout << sum ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rangeSum ( arr , N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rangeSum ( int arr [ ] , int N , int L , int R ) { int prefix [ N + 1 ] ; prefix [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i - 1 ] ; } int leftsum = ( ( L - 1 ) / N ) * prefix [ N ] + prefix [ ( L - 1 ) % N ] ; int rightsum = ( R / N ) * prefix [ N ] + prefix [ R % N ] ; cout << rightsum - leftsum ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 9 } ; int L = 10 , R = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rangeSum ( arr , N , L , R ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void addAP ( int A [ ] , int Q , int operations [ 2 ] [ 4 ] ) { for ( int j = 0 ; j < 2 ; ++ j ) { int L = operations [ j ] [ 0 ] , R = operations [ j ] [ 1 ] , a = operations [ j ] [ 2 ] , d = operations [ j ] [ 3 ] ; int curr = a ; for ( int i = L - 1 ; i < R ; i ++ ) { A [ i ] += curr ; curr += d ; } } for ( int i = 0 ; i < 4 ; ++ i ) cout << A [ i ] << " ▁ " ; } int main ( ) { int A [ ] = { 5 , 4 , 2 , 8 } ; int Q = 2 ; int Query [ 2 ] [ 4 ] = { { 1 , 2 , 1 , 3 } , { 1 , 4 , 4 , 1 } } ; addAP ( A , Q , Query ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximizeNumber ( int N , int K ) { string s = to_string ( N ) ; int L = s . length ( ) ; string result ; int i = 0 ; while ( ( i < L ) && ( K <= ( s [ i ] - '0' ) ) ) { result . push_back ( s [ i ] ) ; ++ i ; } result . push_back ( char ( K + '0' ) ) ; while ( i < L ) { result . push_back ( s [ i ] ) ; ++ i ; } cout << result ; } int main ( ) { int N = 6673 , K = 6 ; maximizeNumber ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y ) { int res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = res * x ; y = y >> 1 ; x = x * x ; } return res ; } void countArrays ( int N , int K ) { cout << int ( power ( N , K ) ) ; } int main ( ) { int N = 5 , K = 6 ; countArrays ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfPairs ( int arr [ ] , int N , int X ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( ( arr [ i ] ^ arr [ j ] ) & X ) == 0 ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 3 , 2 , 5 , 4 , 6 , 7 } ; int X = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countOfPairs ( arr , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE int cntMatrices ( vector < vector < int > > arr , int N , int M , int K ) { int cnt = 0 ; vector < vector < int > > pre ( N + 1 , vector < int > ( M + 1 , 0 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { pre [ i ] [ j ] = arr [ i - 1 ] [ j - 1 ] + pre [ i - 1 ] [ j ] + pre [ i ] [ j - 1 ] - pre [ i - 1 ] [ j - 1 ] ; } } for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { for ( int l = i , r = j ; l > 0 && r > 0 ; l -- , r -- ) { int sum1 = ( K * ( i - l + 1 ) * ( i - r + 1 ) ) ; int sum2 = pre [ i ] [ j ] - pre [ l - 1 ] [ r ] - pre [ l ] [ r - 1 ] + pre [ l - 1 ] [ r - 1 ] ; if ( sum1 <= sum2 ) cnt ++ ; } } } return cnt ; } int main ( ) { vector < vector < int > > arr = { { 2 , 2 , 3 } , { 3 , 4 , 5 } , { 4 , 5 , 5 } } ; int K = 4 ; int N = arr . size ( ) ; int M = arr [ 0 ] . size ( ) ; cout << cntMatrices ( arr , N , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ConcatenateArr ( int arr [ ] , int N ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { int l = floor ( log10 ( arr [ i ] ) + 1 ) ; ans = ans * pow ( 10 , l ) ; ans += arr [ i ] ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 23 , 456 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ConcatenateArr ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countXor ( int N ) { int cnt = N / 2 + 1 ; return cnt ; } int main ( ) { int N = 4 ; cout << countXor ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int DistRecursion ( string S , int i , int dist ) { if ( i == S . length ( ) ) return abs ( dist ) ; if ( S [ i ] == ' L ' ) return DistRecursion ( S , i + 1 , dist - 1 ) ; if ( S [ i ] == ' R ' ) return DistRecursion ( S , i + 1 , dist + 1 ) ; return max ( DistRecursion ( S , i + 1 , dist - 1 ) , DistRecursion ( S , i + 1 , dist + 1 ) ) ; } int maxDistance ( string S ) { return DistRecursion ( S , 0 , 0 ) ; } int main ( ) { string S = " ? RRR ? " ; cout << maxDistance ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ExpoFactorial ( int N ) { int res = 1 ; int mod = 1000000007 ; for ( int i = 2 ; i < N + 1 ; i ++ ) res = ( int ) pow ( i , res ) % mod ; return res ; } int main ( ) { int N = 4 ; cout << ( ExpoFactorial ( N ) ) ;
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySumRepeated ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int curr = arr [ 0 ] ; int ans = arr [ 0 ] ; if ( K == 1 ) { for ( int i = 1 ; i < N ; i ++ ) { curr = max ( arr [ i ] , curr + arr [ i ] ) ; ans = max ( ans , curr ) ; } return ans ; } vector < int > V ; for ( int i = 0 ; i < 2 * N ; i ++ ) { V . push_back ( arr [ i % N ] ) ; } int maxSuf = V [ 0 ] ; int maxPref = V [ 2 * N - 1 ] ; curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr += V [ i ] ; maxPref = max ( maxPref , curr ) ; } curr = V [ 2 * N - 1 ] ; for ( int i = 2 * N - 2 ; i >= 0 ; i -- ) { curr += V [ i ] ; maxSuf = max ( maxSuf , curr ) ; } curr = V [ 0 ] ; for ( int i = 1 ; i < 2 * N ; i ++ ) { curr = max ( V [ i ] , curr + V [ i ] ) ; ans = max ( ans , curr ) ; } if ( sum > 0 ) { int temp = 1LL * sum * ( K - 2 ) ; ans = max ( ans , max ( temp + maxPref , temp + maxSuf ) ) ; } return ans ; } int main ( ) { int arr [ ] = { 10 , 20 , -30 , -1 , 40 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 10 ; cout << maxSubArraySumRepeated ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRectPattern ( int c1 , int c2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << ( max ( abs ( c1 - i ) , abs ( c2 - j ) ) ) << " ▁ " ; } cout << endl ; } } int main ( ) { int c1 = 2 ; int c2 = 2 ; int n = 5 ; printRectPattern ( c1 , c2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( ( i & 1 ) == 0 ) { count ++ ; } } return count ; } int main ( ) { int l = 10 , r = 20 ; cout << countNumbers ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int l , int r ) { return ( ( r / 2 ) - ( l - 1 ) / 2 ) ; } int main ( ) { int l = 10 , r = 20 ; cout << countNumbers ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; } bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; } int contiguousFibonacciNumber ( int arr [ ] , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isFibonacci ( arr [ i ] ) ) { current_length ++ ; } else { current_length = 0 ; } max_length = max ( max_length , current_length ) ; } return max_length ; } int main ( ) { int arr [ ] = { 11 , 8 , 21 , 5 , 3 , 28 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << contiguousFibonacciNumber ( arr , n ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int direction [ ] [ 2 ] = { { -1 , 0 } , { 0 , 1 } , { 0 , -1 } , { 1 , 0 } } ; bool dfs ( vector < vector < int > > & matrix , int i , int j , int N , int M ) { if ( i == N - 1 and j == M - 1 ) { return true ; } matrix [ i ] [ j ] = 1 ; for ( int k = 0 ; k < 4 ; k ++ ) { int newX = i + direction [ k ] [ 0 ] ; int newY = j + direction [ k ] [ 1 ] ; if ( newX >= 0 and newX < N and newY > = 0 and newY < M and matrix [ newX ] [ newY ] == 0 ) { if ( dfs ( matrix , newX , newY , N , M ) ) { return true ; } } } return false ; } int solve ( vector < vector < int > > & matrix ) { int N = matrix . size ( ) ; int M = matrix [ 0 ] . size ( ) ; if ( ! dfs ( matrix , 0 , 0 , N , M ) ) { return 0 ; } if ( ! dfs ( matrix , 0 , 0 , N , M ) ) { return 1 ; } return 2 ; } int main ( ) { vector < vector < int > > mat = { { 0 , 1 , 0 , 0 } , { 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; cout << solve ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrayPartition ( int a [ ] , int n ) { int ans [ n ] ; int cnt = 0 ; int ind , flag = 0 ; map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ a [ i ] ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( mp [ a [ i ] ] == 1 ) cnt ++ ; if ( mp [ a [ i ] ] > 2 && flag == 0 ) { flag = 1 ; ind = i ; } } int p = ( cnt + 1 ) / 2 ; int ans1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans [ i ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp [ a [ i ] ] == 1 && ans1 < p ) { ans [ i ] = 1 ; ans1 ++ ; } else if ( mp [ a [ i ] ] == 1 ) { ans [ i ] = 2 ; } } if ( cnt % 2 == 1 && flag == 0 ) { cout << -1 << endl ; return ; } if ( cnt % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } else { for ( int i = 0 ; i < n ; i ++ ) { if ( ind == i ) cout << 2 << " ▁ " ; else cout << ans [ i ] << " ▁ " ; } } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 , 4 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; arrayPartition ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void evenOdd ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int even_digits = 0 ; int odd_digits = 0 ; int temp = arr [ i ] ; while ( temp ) { if ( ( temp % 10 ) & 1 ) odd_digits ++ ; else even_digits ++ ; temp /= 10 ; } if ( even_digits > odd_digits ) { int res = 0 ; while ( arr [ i ] ) { res += arr [ i ] % 10 ; arr [ i ] /= 10 ; } cout << res << " ▁ " ; } else if ( odd_digits > even_digits ) { int res = 1 ; while ( arr [ i ] ) { res *= arr [ i ] % 10 ; arr [ i ] /= 10 ; } cout << res << " ▁ " ; } else cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 113 , 141 , 214 , 3186 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; evenOdd ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfFirstM ( int A [ ] , int N , int M ) { int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { sum = sum + A [ i % N ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int M = 5 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumOfFirstM ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canReach0toM ( int a [ ] [ 2 ] , int n , int m ) { int rightMost [ m + 1 ] ; int dp [ m + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { rightMost [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int a1 = a [ i ] [ 0 ] ; int b1 = a [ i ] [ 1 ] ; rightMost [ a1 ] = max ( rightMost [ a1 ] , b1 ) ; } for ( int i = m ; i >= 0 ; i -- ) { dp [ i ] = i ; for ( int j = min ( m , rightMost [ i ] ) ; j > i ; j -- ) { dp [ i ] = max ( dp [ i ] , dp [ j ] ) ; } } if ( dp [ 0 ] >= m ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int arr [ ] [ 2 ] = { { 0 , 2 } , { 2 , 2 } , { 2 , 5 } , { 4 , 5 } } ; int M = 5 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; canReach0toM ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void countPairs ( int * arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int x = 1 ; x <= arr [ i ] ; x ++ ) { for ( int y = x ; y <= arr [ i ] ; y ++ ) { if ( gcd ( x , y ) > 1 ) count ++ ; } } cout << count << " ▁ " ; } } int main ( ) { int arr [ ] = { 5 , 10 , 20 } ; int N = 3 ; countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1005 ; void preCalculate ( vector < int > & phi , vector < int > & ans ) { phi [ 0 ] = 0 ; phi [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) phi [ i ] = i ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( phi [ i ] == i ) { for ( int j = i ; j <= MAX ; j += i ) phi [ j ] -= ( phi [ j ] / i ) ; } } for ( int i = 1 ; i <= MAX ; i ++ ) ans [ i ] = ans [ i - 1 ] + ( i - phi [ i ] ) ; } void countPairs ( int * arr , int N ) { vector < int > phi ( 1e5 , 0 ) ; vector < int > ans ( 1e5 , 0 ) ; preCalculate ( phi , ans ) ; for ( int i = 0 ; i < N ; ++ i ) { cout << ans [ arr [ i ] ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 5 , 10 , 20 } ; int N = 3 ; countPairs ( arr , N ) ; }
#include <iostream> NEW_LINE using namespace std ; void countSubarray ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int mxSubarray = 0 ; int mxOther = 0 ; for ( int k = i ; k <= j ; k ++ ) { mxSubarray = max ( mxSubarray , arr [ k ] ) ; } for ( int k = 0 ; k < i ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } for ( int k = j + 1 ; k < n ; k ++ ) { mxOther = max ( mxOther , arr [ k ] ) ; } if ( mxSubarray > ( 2 * mxOther ) ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubarray ( int arr [ ] , int n ) { int count = 0 , L = 0 , R = 0 ; int mx = * max_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] * 2 > mx ) { L = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( arr [ i ] * 2 > mx ) { R = i ; break ; } } cout << ( L + 1 ) * ( n - R ) ; } int main ( ) { int arr [ ] = { 1 , 6 , 10 , 9 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int n ) { int count = 0 ; while ( n ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } int minOperations ( int A , int B ) { int cnt1 = 0 , cnt2 = 0 ; cnt1 += countSetBits ( A ) ; cnt2 += countSetBits ( B ) ; if ( ( cnt1 + cnt2 ) % 2 != 0 ) return -1 ; int oneZero = 0 , zeroOne = 0 ; int ans = 0 ; for ( int i = 0 ; i < max ( cnt1 , cnt2 ) ; i ++ ) { int bitpos = 1 << i ; if ( ( ! ( bitpos & A ) ) && ( bitpos & B ) ) zeroOne ++ ; if ( ( bitpos & A ) && ( ! ( bitpos & B ) ) ) oneZero ++ ; } ans = ( zeroOne / 2 ) + ( oneZero / 2 ) ; if ( zeroOne % 2 != 0 ) ans += 2 ; return ans ; } int main ( ) { int A = 27 , B = 5 ; cout << minOperations ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSum ( vector < int > A , int N , int K ) { int curr_sum = 0 ; int max_sum = INT_MIN ; for ( int i = 0 ; i < N - K + 1 ; i ++ ) { vector < int > dupl_arr ( A . begin ( ) + i , A . begin ( ) + i + K ) ; sort ( dupl_arr . begin ( ) , dupl_arr . end ( ) ) ; bool flag = true ; for ( int j = 1 ; j < K ; j ++ ) { if ( dupl_arr [ j ] - dupl_arr [ j - 1 ] != 1 ) { flag = false ; break ; } } if ( flag ) { int temp = 0 ; curr_sum = accumulate ( dupl_arr . begin ( ) , dupl_arr . end ( ) , temp ) ; max_sum = max ( max_sum , curr_sum ) ; curr_sum = 0 ; } } return max_sum ; } int main ( ) { vector < int > arr = { 10 , 12 , 9 , 8 , 10 , 15 , 1 , 3 , 2 } ; int K = 3 ; int N = arr . size ( ) ; cout << maximumSum ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; vector < int > primes ; void sieveSundaram ( ) { bool marked [ MAX / 2 + 100 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; } bool isSmith ( int n ) { int original_no = n ; int pDigitSum = 0 ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { int p = primes [ i ] ; n = n / p ; while ( p > 0 ) { pDigitSum += ( p % 10 ) ; p = p / 10 ; } } } if ( n != 1 && n != original_no ) { while ( n > 0 ) { pDigitSum = pDigitSum + n % 10 ; n = n / 10 ; } } int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits = sumDigits + original_no % 10 ; original_no = original_no / 10 ; } return ( pDigitSum == sumDigits ) ; } bool isSmithBrotherPair ( int X , int Y ) { return isSmith ( X ) && isSmith ( Y ) && abs ( X - Y ) == 1 ; } int countSmithBrotherPairs ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { if ( isSmithBrotherPair ( A [ i ] , A [ j ] ) ) count ++ ; } return count ; } int main ( ) { sieveSundaram ( ) ; int A [ ] = { 728 , 729 , 28 , 2964 , 2965 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << countSmithBrotherPairs ( A , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; vector < int > primes ; void sieveSundaram ( ) { bool marked [ MAX / 2 + 100 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; } bool isSmith ( int n ) { int original_no = n ; int pDigitSum = 0 ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { int p = primes [ i ] ; n = n / p ; while ( p > 0 ) { pDigitSum += ( p % 10 ) ; p = p / 10 ; } } } if ( n != 1 && n != original_no ) { while ( n > 0 ) { pDigitSum = pDigitSum + n % 10 ; n = n / 10 ; } } int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits = sumDigits + original_no % 10 ; original_no = original_no / 10 ; } return ( pDigitSum == sumDigits ) ; } bool isSmithBrotherPair ( int X , int Y ) { return isSmith ( X ) && isSmith ( Y ) ; } int countSmithBrotherPairs ( int A [ ] , int N ) { int count = 0 ; sort ( A , A + N ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( isSmithBrotherPair ( A [ i ] , A [ i + 1 ] ) ) count ++ ; return count ; } int main ( ) { sieveSundaram ( ) ; int A [ ] = { 728 , 729 , 28 , 2964 , 2965 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << countSmithBrotherPairs ( A , N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void countPairs ( int arr [ ] , int N ) { int count = 0 , totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( totalSum % ( arr [ i ] + arr [ j ] ) == 0 ) { count += 1 ; } } } cout << count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } int largestK ( int A [ ] , int N ) { int l = 0 , r = N - 1 , flag = 0 ; while ( l < r ) { if ( A [ l ] != A [ r ] ) { flag = 1 ; break ; } l ++ ; r -- ; } if ( flag == 0 ) return -1 ; int K = abs ( A [ 0 ] - A [ N - 1 ] ) ; for ( int i = 1 ; i < N / 2 ; i ++ ) K = gcd ( K , abs ( A [ i ] - A [ N - i - 1 ] ) ) ; return K ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 2 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << largestK ( A , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool PermuteAndFind ( vector < long > power , int idx , long SumSoFar , int target ) { if ( idx == power . size ( ) ) { if ( SumSoFar == target ) return true ; return false ; } bool select = PermuteAndFind ( power , idx + 1 , SumSoFar , target ) ; bool notselect = PermuteAndFind ( power , idx + 1 , SumSoFar + power [ idx ] , target ) ; return ( select notselect ) ; } void DistinctPowersOf3 ( int N ) { vector < long > power ( 16 ) ; power [ 0 ] = 1 ; for ( int i = 1 ; i < 16 ; i ++ ) power [ i ] = 3 * power [ i - 1 ] ; bool found = PermuteAndFind ( power , 0 , 0L , N ) ; if ( found == true ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int N = 91 ; DistinctPowersOf3 ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void DistinctPowersOf3 ( int N ) { while ( N > 0 ) { if ( N % 3 == 2 ) { cout << " No " ; return ; } N /= 3 ; } cout << " Yes " ; } int main ( ) { int N = 91 ; DistinctPowersOf3 ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int A , int B ) { if ( B == 0 ) return A ; else return gcd ( B , A % B ) ; } int getDistinctValues ( int A , int B , int C ) { int g = gcd ( A , B ) ; int num_values = C / g ; return num_values ; } int main ( ) { int A = 2 ; int B = 3 ; int C = 10 ; cout << ( getDistinctValues ( A , B , C ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int * game_with_number ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { arr [ i ] = arr [ i ] ^ arr [ i + 1 ] ; } return arr ; } void print ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 10 , 11 , 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * new_arr = game_with_number ( arr , n ) ; print ( new_arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int currSubArrayScore ( int * a , int * b , int l , int r ) { int straightScore = 0 ; int reverseScore = 0 ; for ( int i = l ; i <= r ; i ++ ) { straightScore += a [ i ] * b [ i ] ; reverseScore += a [ r - ( i - l ) ] * b [ i ] ; } return max ( straightScore , reverseScore ) ; } void maxScoreSubArray ( int * a , int * b , int n ) { int res = 0 , start = 0 , end = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int currScore = currSubArrayScore ( a , b , i , j ) ; if ( currScore > res ) { res = currScore ; start = i ; end = j ; } } } cout << res ; } int main ( ) { int A [ ] = { 13 , 4 , 5 } ; int B [ ] = { 10 , 22 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maxScoreSubArray ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSizeSubarray ( int arr [ ] , int N ) { int i = 0 , j = N - 1 ; while ( i < N and arr [ i ] == 0 ) { i ++ ; } if ( i == N ) return 1 ; while ( j >= 0 and arr [ j ] == 0 ) { j -- ; } return ( j - i + 1 ) ; } int main ( ) { int arr [ ] = { 0 , 2 , 0 , 0 , 12 , 0 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumSizeSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countXorPartition ( int N ) { double a = pow ( 2 , floor ( N - log ( N + 1 ) / log ( 2 ) ) ) ; cout << a ; } int main ( ) { int N = 5 ; countXorPartition ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPowerof2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; } bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int reduceToOne ( int N ) { if ( N == 1 ) { return 0 ; } if ( isPowerOfTwo ( N ) == true ) { return 1 + reduceToOne ( N / 2 ) ; } else { return 1 + reduceToOne ( N - highestPowerof2 ( N ) ) ; } } int main ( ) { int N = 7 ; cout << reduceToOne ( N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSum ( int arr [ ] , int N ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) { sum += arr [ i ] ; } } ans = max ( ans , sum ) ; } return ans ; } int main ( ) { int arr [ ] = { 5 , 4 , 1 , 7 , 11 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxCount ( int arr [ ] , int N , int K ) { set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { st . insert ( arr [ i ] ) ; } if ( N - st . size ( ) <= K ) { cout << " Yes " ; } else cout << " No " ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , 3 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxCount ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_sum ( int a [ ] , vector < pair < pair < int , int > , int > > v , int q , int n ) { int x = 0 ; int m = INT_MIN ; for ( int i = 0 ; i < q ; i ++ ) { int p , q , k ; p = v [ i ] . first . first ; q = v [ i ] . first . second ; k = v [ i ] . second ; a [ p ] += k ; if ( q + 1 <= n ) a [ q + 1 ] -= k ; } for ( int i = 1 ; i <= n ; i ++ ) { x += a [ i ] ; m = max ( m , x ) ; } return m ; } int main ( ) { int n = 10 , q = 3 ; int a [ n + 5 ] = { 0 } ; vector < pair < pair < int , int > , int > > v ( q ) ; v [ 0 ] . first . first = 1 ; v [ 0 ] . first . second = 5 ; v [ 0 ] . second = 3 ; v [ 1 ] . first . first = 4 ; v [ 1 ] . first . second = 8 ; v [ 1 ] . second = 7 ; v [ 2 ] . first . first = 6 ; v [ 2 ] . first . second = 9 ; v [ 2 ] . second = 1 ; cout << max_sum ( a , v , q , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( int X , int Y ) { int playerA = ( X ^ Y ) ; bool flag = false ; for ( int i = 1 ; i <= X ; i ++ ) { for ( int j = 1 ; j <= Y ; j ++ ) { int val = ( i ^ j ) ; if ( val > playerA ) { flag = true ; break ; } } if ( flag ) { break ; } } if ( flag ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int A = 2 , B = 4 ; findWinner ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( int X , int Y ) { int first = ( X ^ Y ) ; int second = ( X + Y ) ; if ( first == second ) { cout << " No " ; } else { cout << " Yes " ; } } int main ( ) { int A = 2 , B = 4 ; findWinner ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int KthSmallest ( int A [ ] , int B [ ] , int N , int K ) { int M = 0 ; for ( int i = 0 ; i < N ; i ++ ) { M = max ( A [ i ] , M ) ; } int freq [ M + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { freq [ A [ i ] ] += B [ i ] ; } int sum = 0 ; for ( int i = 0 ; i <= M ; i ++ ) { sum += freq [ i ] ; if ( sum >= K ) { return i ; } } return -1 ; } int main ( ) { int A [ ] = { 3 , 4 , 5 } ; int B [ ] = { 2 , 1 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int K = 4 ; cout << KthSmallest ( A , B , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void prefixFactorialArray ( int A [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { A [ i ] += A [ i - 1 ] ; } int fact [ A [ N - 1 ] + 1 ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= A [ N - 1 ] ; i ++ ) { fact [ i ] = i * fact [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = fact [ A [ i ] ] ; } for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; prefixFactorialArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left ; Node * right ; } ; Node * newNode ( int d ) { Node * n = new Node ; n -> data = d ; n -> left = NULL ; n -> right = NULL ; return n ; } void findwt ( Node * root , int wt [ ] , map < int , int > & um , int width = 0 ) { if ( root == NULL ) { return ; } um [ width ] += wt [ root -> data ] ; findwt ( root -> left , wt , um , width - 1 ) ; findwt ( root -> right , wt , um , width + 1 ) ; } void solveQueries ( int wt [ ] , Node * root , vector < vector < int > > queries ) { map < int , int > um ; findwt ( root , wt , um ) ; int x = 0 ; for ( auto it = um . begin ( ) ; it != um . end ( ) ; it ++ ) { x += it -> second ; um [ it -> first ] = x ; } for ( int i = 0 ; i < queries . size ( ) ; i ++ ) { int l = queries [ i ] [ 0 ] ; int r = queries [ i ] [ 1 ] ; cout << um [ r ] - um [ l - 1 ] << " STRNEWLINE " ; } } int main ( ) { int N = 8 ; Node * root = newNode ( 1 ) ; root -> left = newNode ( 3 ) ; root -> left -> left = newNode ( 5 ) ; root -> left -> right = newNode ( 6 ) ; root -> right = newNode ( 2 ) ; root -> right -> right = newNode ( 4 ) ; root -> right -> right -> left = newNode ( 7 ) ; root -> right -> right -> right = newNode ( 0 ) ; int wt [ ] = { 8 , 6 , 4 , 5 , 1 , 2 , 9 , 1 } ; vector < vector < int > > queries { { -1 , 1 } , { -2 , -1 } , { 0 , 3 } } ; solveQueries ( wt , root , queries ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string recreationalSpot ( int arr [ ] , int N ) { if ( N < 3 ) { return " No " ; } int preMin [ N ] ; preMin [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { preMin [ i ] = min ( preMin [ i - 1 ] , arr [ i ] ) ; } stack < int > stack ; for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( arr [ j ] > preMin [ j ] ) { while ( ! stack . empty ( ) && stack . top ( ) <= preMin [ j ] ) { stack . pop ( ) ; } if ( ! stack . empty ( ) && stack . top ( ) < arr [ j ] ) { return " Yes " ; } stack . push ( arr [ j ] ) ; } } return " No " ; } int main ( ) { int arr [ ] = { 4 , 7 , 11 , 5 , 13 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << recreationalSpot ( arr , size ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool ToCheckPowerofX ( int n , int x ) { while ( n > 0 ) { int rem = n % x ; if ( rem >= 2 ) { return false ; } n = n / x ; } return true ; } int main ( ) { int N = 10 , X = 3 ; if ( ToCheckPowerofX ( N , X ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverseBin ( int N ) { string S = " " ; int i ; for ( i = 0 ; i < 32 ; i ++ ) { if ( N & ( 1LL << i ) ) S += '1' ; else S += '0' ; } reverse ( S . begin ( ) , S . end ( ) ) ; int M = 0 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( S [ i ] == '1' ) M += ( 1LL << i ) ; } return M ; } int maximumOfTwo ( int N ) { int M = reverseBin ( N ) ; return max ( N , M ) ; } int main ( ) { int N = 6 ; cout << maximumOfTwo ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sub_array = a [ i ] ; res = res | curr_sub_array ; for ( int j = i ; j < n ; j ++ ) { curr_sub_array = curr_sub_array & a [ j ] ; res = res | curr_sub_array ; } } cout << res ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findbitwiseOR ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findbitwiseOR ( int * a , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res | a [ i ] ; cout << res ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findbitwiseOR ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void complexRoot ( int A , int B ) { vector < pair < double , double > > ans ; double X1 = abs ( sqrt ( ( A + sqrt ( A * A + B * B ) ) / 2 ) ) ; double Y1 = B / ( 2 * X1 ) ; ans . push_back ( { X1 , Y1 } ) ; double X2 = -1 * X1 ; double Y2 = B / ( 2 * X2 ) ; if ( X2 != 0 ) { ans . push_back ( { X2 , Y2 } ) ; } double X3 = ( A - sqrt ( A * A + B * B ) ) / 2 ; if ( X3 > 0 ) { X3 = abs ( sqrt ( X3 ) ) ; double Y3 = B / ( 2 * X3 ) ; ans . push_back ( { X3 , Y3 } ) ; double X4 = -1 * X3 ; double Y4 = B / ( 2 * X4 ) ; if ( X4 != 0 ) { ans . push_back ( { X4 , Y4 } ) ; } } cout << " The ▁ Square ▁ roots ▁ are : ▁ " << endl ; for ( auto p : ans ) { cout << p . first ; if ( p . second > 0 ) cout << " + " ; if ( p . second ) cout << p . second << " * i " << endl ; else cout << endl ; } } int main ( ) { int A = 0 , B = 1 ; complexRoot ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int findlcm ( int arr [ ] , int n ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; } void minimumRod ( int A [ ] , int N ) { cout << N * findlcm ( A , N ) ; } int main ( ) { int arr [ ] = { 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumRod ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void check ( int n ) { int sumOfDigit = 0 ; int prodOfDigit = 1 ; while ( n > 0 ) { int rem ; rem = n % 10 ; sumOfDigit += rem ; prodOfDigit *= rem ; n /= 10 ; } if ( sumOfDigit > prodOfDigit ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int N = 1234 ; check ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool findDigit ( int N , int D ) { while ( N > 0 ) { int a = N % 10 ; if ( a == D ) { return true ; } N /= 10 ; } return false ; } bool check ( int N , int D ) { while ( N > 0 ) { if ( findDigit ( N , D ) == true ) { return true ; } N -= D ; } return false ; } int main ( ) { int N = 24 ; int D = 7 ; if ( check ( N , D ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindSum ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int power = log2 ( arr [ i ] ) ; int LesserValue = pow ( 2 , power ) ; int LargerValue = pow ( 2 , power + 1 ) ; if ( ( arr [ i ] - LesserValue ) == ( LargerValue - arr [ i ] ) ) { res += arr [ i ] ; } } return res ; } int main ( ) { int arr [ ] = { 10 , 24 , 17 , 3 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << FindSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } void countRelations ( int N ) { cout << ( power ( 2 , N ) - 2 ) * power ( 2 , N * N - N ) ; } int main ( ) { int N = 2 ; countRelations ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void evenOddBitwiseXOR ( int N ) { cout << " Even : ▁ " << 0 << " ▁ " ; for ( int i = 4 ; i <= N ; i = i + 4 ) { cout << i << " ▁ " ; } cout << " STRNEWLINE " ; cout << " Odd : ▁ " << 1 << " ▁ " ; for ( int i = 4 ; i <= N ; i = i + 4 ) { cout << i - 1 << " ▁ " ; } if ( N % 4 == 2 ) cout << N + 1 ; else if ( N % 4 == 3 ) cout << N ; } int main ( ) { int N = 6 ; evenOddBitwiseXOR ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperation ( int N ) { if ( N % 2 == 0 ) { return ( N / 2 ) * ( N / 2 ) ; } int k = ( N - 1 ) / 2 ; return k * ( k + 1 ) ; } int main ( ) { int N = 6 ; cout << minOperation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findXORS ( int arr1 [ ] , int arr2 [ ] , int N , int M ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int temp = arr1 [ i ] & arr2 [ j ] ; res ^= temp ; } } return res ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 6 , 5 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << findXORS ( arr1 , arr2 , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPermutation ( vector < int > & arr ) { int N = arr . size ( ) ; int i = N - 2 ; while ( i >= 0 && arr [ i ] <= arr [ i + 1 ] ) i -- ; if ( i == -1 ) { cout << " - 1" ; return ; } int j = N - 1 ; while ( j > i && arr [ j ] >= arr [ i ] ) j -- ; while ( j > i && arr [ j ] == arr [ j - 1 ] ) { j -- ; } swap ( arr [ i ] , arr [ j ] ) ; for ( auto & it : arr ) { cout << it << ' ▁ ' ; } } int main ( ) { vector < int > arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; findPermutation ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerof2 ( unsigned int n ) { return ( ( n & ( n - 1 ) ) && n ) ; } void countNum ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { bool flag = isPowerof2 ( i ) ; if ( ! flag ) { count ++ ; } } cout << count << " STRNEWLINE " ; } int main ( ) { int N = 100 ; countNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countNum ( int N ) { int ans = log2 ( N ) + 1 ; cout << ans << " STRNEWLINE " ; } int main ( ) { int N = 100 ; countNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct ListNode { int val ; struct ListNode * next ; } ; void push ( ListNode * * head_ref , int node_val ) { ListNode * new_node = new ListNode ( ) ; new_node -> val = node_val ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void splitListInParts ( ListNode * head , int K ) { vector < ListNode * > ans ; if ( ! head ) { while ( K -- ) ans . push_back ( NULL ) ; } int N = 0 ; ListNode * p = head ; while ( p ) { p = p -> next ; N ++ ; } int len = N / K ; int rem = N % K ; p = head ; while ( K > 0 && p ) { int x = len ; ListNode * curr_head = p ; ListNode * last = p ; if ( rem > 0 ) { p = p -> next ; rem -- ; } while ( x -- ) { if ( last == p ) p = p -> next ; else { last -> next = p ; last = p ; p = p -> next ; } } last -> next = NULL ; ans . push_back ( curr_head ) ; K -- ; } while ( K > 0 ) { ans . push_back ( NULL ) ; K -- ; } cout << " { " ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << " { " ; while ( ans [ i ] ) { cout << ans [ i ] -> val << " ▁ " ; ans [ i ] = ans [ i ] -> next ; } cout << " } " ; if ( i != ans . size ( ) - 1 ) cout << " , ▁ " ; } cout << " } " ; } int main ( ) { ListNode * root = NULL ; push ( & root , 8 ) ; push ( & root , 7 ) ; push ( & root , 6 ) ; push ( & root , 5 ) ; push ( & root , 4 ) ; push ( & root , 3 ) ; push ( & root , 2 ) ; push ( & root , 1 ) ; int K = 3 ; splitListInParts ( root , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findLast ( int mat [ ] [ 3 ] ) { int m = 3 ; int n = 3 ; set < int > rows ; set < int > cols ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] ) { rows . insert ( i ) ; cols . insert ( j ) ; } } } int avRows = m - rows . size ( ) ; int avCols = n - cols . size ( ) ; int choices = min ( avRows , avCols ) ; if ( choices & 1 ) cout << " P1" ; else cout << " P2" ; } int main ( ) { int mat [ ] [ 3 ] = { { 1 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 1 } } ; findLast ( mat ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nearestPow ( int x , int base ) { int k = int ( log ( x ) / log ( base ) ) ; if ( abs ( pow ( base , k ) - x ) < abs ( pow ( base , ( k + 1 ) ) - x ) ) return pow ( base , k ) ; else return pow ( base , ( k + 1 ) ) ; } void replaceWithNearestPowerOfK ( int arr [ ] , int K , int n ) { for ( int i = 0 ; i < n ; i ++ ) { string strEle = to_string ( arr [ i ] ) ; for ( int c = 0 ; c < strEle . length ( ) ; c ++ ) { if ( ( strEle - '0' ) == K ) { arr [ i ] = nearestPow ( arr [ i ] , K ) ; break ; } } } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 432 , 953 , 232 , 333 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; replaceWithNearestPowerOfK ( arr , K , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeTailing ( int A , int B ) { int N = A + B ; stack < int > s ; string strsum = to_string ( N ) ; for ( int i = 0 ; i < strsum . length ( ) ; i ++ ) { s . push ( strsum [ i ] ) ; } while ( s . top ( ) == '0' ) s . pop ( ) ; string res = " " ; while ( ! s . empty ( ) ) { res = res + char ( s . top ( ) ) ; s . pop ( ) ; } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; } int main ( ) { int A = 130246 , B = 450164 ; cout << removeTailing ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSumOfGP ( double a , double r ) { if ( abs ( r ) >= 1 ) { cout << " Infinite " ; return ; } double sum = a / ( 1 - r ) ; cout << sum ; } int main ( ) { double A = 1 , R = 0.5 ; findSumOfGP ( A , R ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int mod = 1000000007 ; int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } int numberOfRelations ( int N ) { return power ( 3 , ( N * N - N ) / 2 ) ; } int main ( ) { int N = 2 ; cout << numberOfRelations ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( __gcd ( i , N ) != 1 ) count ++ ; } cout << count ; } int main ( ) { int N = 5 ; countNumbers ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int phi ( int N ) { int result = N ; for ( int p = 2 ; p * p <= N ; ++ p ) { if ( N % p == 0 ) { while ( N % p == 0 ) N /= p ; result -= result / p ; } } if ( N > 1 ) result -= result / N ; return result ; } int countNumbers ( int N ) { int count = N - phi ( N ) ; cout << count ; } int main ( ) { int N = 5 ; countNumbers ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthFibo ( int n ) { double a = ( pow ( 5 , 0.5 ) + 1 ) / 2 ; double b = ( -1 * ( pow ( 5 , 0.5 ) ) + 1 ) / 2 ; double r = pow ( 5 , 0.5 ) ; double ans = ( pow ( a , n ) - pow ( b , n ) ) / r ; return int ( ans ) ; } int nearFibo ( int X ) { double a = ( pow ( 5 , 0.5 ) + 1 ) / 2 ; int n = int ( log ( ( pow ( 5 , 0.5 ) ) * X ) / log ( a ) ) ; int nth = nthFibo ( n ) ; int nplus = nthFibo ( n + 1 ) ; if ( abs ( X - nth ) < abs ( X - nplus ) ) return nth ; else return nplus ; } int getCost ( int arr [ ] , int n ) { int cost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int fibo = nearFibo ( arr [ i ] ) ; cost += abs ( arr [ i ] - fibo ) ; } return cost ; } int main ( ) { int arr [ ] = { 56 , 34 , 23 , 98 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( getCost ( arr , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sieveOfEratosthenes ( int N , int s [ ] ) { vector < bool > prime ( N + 1 , false ) ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( ! prime [ i * j ] ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } void findDifference ( int N ) { int s [ N + 1 ] ; sieveOfEratosthenes ( N , s ) ; int total = 1 , odd = 1 , even = 0 ; int curr = s [ N ] ; int cnt = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( curr == s [ N ] ) { cnt ++ ; continue ; } if ( curr == 2 ) { total = total * ( cnt + 1 ) ; } else { total = total * ( cnt + 1 ) ; odd = odd * ( cnt + 1 ) ; } curr = s [ N ] ; cnt = 1 ; } even = total - odd ; cout << abs ( even - odd ) ; } int main ( ) { int N = 12 ; findDifference ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumOfInfiniteAGP ( double a , double d , double r ) { double ans = a / ( 1 - r ) + ( d * r ) / ( 1 - r * r ) ; cout << ans ; } int main ( ) { double a = 0 , d = 1 , r = 0.5 ; sumOfInfiniteAGP ( a , d , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] % arr [ j ] == 0 arr [ j ] % arr [ i ] == 0 ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 2 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countbits ( int n ) { int count = 0 ; while ( n != 0 ) { if ( n & 1 ) count ++ ; n = n / 2 ; } return count ; } int BitProduct ( int arr [ ] , int N ) { int product = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int bits = countbits ( arr [ i ] ) ; product *= bits ; } return product ; } int main ( ) { int arr [ ] = { 3 , 2 , 4 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << BitProduct ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } int getSumUtil ( int * st , int ss , int se , int qs , int qe , int si ) { if ( qs <= ss && qe >= se ) return st [ si ] ; if ( se < qs ss > qe ) return 0 ; int mid = getMid ( ss , se ) ; return getSumUtil ( st , ss , mid , qs , qe , 2 * si + 1 ) + getSumUtil ( st , mid + 1 , se , qs , qe , 2 * si + 2 ) ; } int getSum ( int * st , int n , int qs , int qe ) { if ( qs < 0 qe > n - 1 qs > qe ) { cout << " Invalid ▁ Input " ; return -1 ; } return getSumUtil ( st , 0 , n - 1 , qs , qe , 0 ) ; } int constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return arr [ ss ] ; } int mid = getMid ( ss , se ) ; st [ si ] = constructSTUtil ( arr , ss , mid , st , si * 2 + 1 ) + constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 ) ; return st [ si ] ; } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; constructSTUtil ( arr , 0 , n - 1 , st , 0 ) ; return st ; } void OddDivisorsSum ( int n , int q , int arr [ ] , vector < pair < int , int > > Query ) { for ( int i = 0 ; i < n ; i ++ ) { int sq = sqrt ( arr [ i ] ) ; if ( sq * sq != arr [ i ] ) arr [ i ] = 0 ; } int * st = constructST ( arr , n ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = Query [ i ] . first ; int r = Query [ i ] . second ; cout << getSum ( st , n , l , r ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 6 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 3 ; vector < pair < int , int > > Query = { { 0 , 2 } , { 1 , 3 } , { 1 , 4 } } ; OddDivisorsSum ( N , Q , arr , Query ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void OddDivisorsSum ( int n , int q , int a [ ] , vector < pair < int , int > > Query ) { int DP [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int x = sqrt ( a [ i ] ) ; if ( x * x == a [ i ] ) DP [ i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i ] ; } for ( int i = 0 ; i < q ; i ++ ) { int l = Query [ i ] . first ; int r = Query [ i ] . second ; if ( l == 0 ) { cout << DP [ r ] << " ▁ " ; } else { cout << DP [ r ] - DP [ l - 1 ] << " ▁ " ; } } } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 6 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q = 3 ; vector < pair < int , int > > Query = { { 0 , 2 } , { 1 , 3 } , { 1 , 4 } } ; OddDivisorsSum ( N , Q , arr , Query ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; static void findSubset ( vector < int > arr ) { int N = arr . size ( ) ; map < int , int > mp ; int totSum = 0 ; int s = 0 ; int flag = 0 ; vector < int > ans ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { totSum += arr [ i ] ; mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } sort ( arr . begin ( ) , arr . end ( ) ) ; int i = N - 1 ; while ( i >= 0 ) { int frq = mp [ arr [ i ] ] ; if ( ( frq + ans . size ( ) ) < ( N - ( frq + ans . size ( ) ) ) ) { for ( int k = 0 ; k < frq ; k ++ ) { ans . push_back ( arr [ i ] ) ; totSum -= arr [ i ] ; s += arr [ i ] ; i -- ; } } else { i -= frq ; } if ( s > totSum ) { flag = 1 ; break ; } } if ( flag == 1 ) { for ( i = ans . size ( ) - 1 ; i >= 0 ; i -- ) { cout << ans [ i ] << " ▁ " ; } } else { cout << -1 ; } } int main ( ) { vector < int > arr = { 5 , 3 , 2 , 4 , 1 , 2 } ; findSubset ( arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Rotate ( int n , int f ) { int temp = n ; int maxi = n ; int mini = n ; for ( int idx = 0 ; idx < 7 ; idx ++ ) { if ( temp & 1 ) { temp >>= 1 ; temp += pow ( 2 , 7 ) ; } else temp >>= 1 ; mini = min ( mini , temp ) ; maxi = max ( maxi , temp ) ; } if ( f ) return ( maxi ) ; else return ( mini ) ; } int calcMinDiff ( int arr [ ] , int n ) { int caseOne = 0 ; int sumOfodd = 0 ; int sumOfeven = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) sumOfodd += Rotate ( arr [ i ] , 0 ) ; else sumOfeven += Rotate ( arr [ i ] , 1 ) ; } caseOne = abs ( sumOfodd - sumOfeven ) ; int caseTwo = 0 ; sumOfodd = 0 ; sumOfeven = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) sumOfodd += Rotate ( arr [ i ] , 1 ) ; else sumOfeven += Rotate ( arr [ i ] , 0 ) ; } caseTwo = abs ( sumOfodd - sumOfeven ) ; return max ( caseOne , caseTwo ) ; } int main ( ) { int arr [ ] = { 123 , 86 , 234 , 189 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( calcMinDiff ( arr , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumDiff ( int arr [ ] , int N ) { int res = arr [ 0 ] , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; int min_diff = sum ; for ( int i = 0 ; i < N ; i ++ ) { if ( abs ( sum - ( arr [ i ] * N ) ) < min_diff ) { min_diff = abs ( sum - ( arr [ i ] * N ) ) ; res = arr [ i ] ; } } cout << res ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumDiff ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int arr [ ] , int N , int K ) { int sum = 0 ; vector < int > v ; for ( int i = 0 ; i < N ; i ++ ) { v . push_back ( arr [ i ] ) ; } bool flag = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( ! flag && v [ i ] % K == 0 ) v . push_back ( v [ i ] / K ) ; else { flag = 1 ; } sum = sum + v [ i % N ] ; } return sum ; } int main ( ) { int arr [ ] = { 4 , 6 , 8 , 2 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sum ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int primeDivisors ( int arr [ ] , int N ) { int K = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { K = max ( K , arr [ i ] ) ; } int prime [ K + 1 ] = { 0 } ; prime [ 0 ] = 1 ; prime [ 1 ] = 1 ; for ( int i = 2 ; i < K + 1 ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = 2 * i ; j < K + 1 ; j += i ) { prime [ j ] = 1 ; } } } int factor [ K + 1 ] = { 0 } ; factor [ 0 ] = 0 ; factor [ 1 ] = 1 ; for ( int i = 2 ; i < K + 1 ; i ++ ) { factor [ i ] += 1 ; for ( int j = i ; j < K + 1 ; j += i ) { factor [ j ] += 1 ; } } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( prime [ factor [ arr [ i ] ] ] == 0 ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 10 , 13 , 17 , 25 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << primeDivisors ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMedian ( int Mean , int Mode ) { double Median = ( 2 * Mean + Mode ) / 3.0 ; cout << Median ; } int main ( ) { int mode = 6 , mean = 3 ; findMedian ( mean , mode ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 1e9 + 7 ; void sumOfBinaryNumbers ( int n ) { int ans = 0 ; int one = 1 ; while ( 1 ) { if ( n <= 1 ) { ans = ( ans + n ) % MOD ; break ; } int x = log2 ( n ) ; int cur = 0 ; int add = ( one << ( x - 1 ) ) ; for ( int i = 1 ; i <= x ; i ++ ) { cur = ( cur + add ) % MOD ; add = ( add * 10 % MOD ) ; } ans = ( ans + cur ) % MOD ; int rem = n - ( one << x ) + 1 ; int p = pow ( 10 , x ) ; p = ( p * ( rem % MOD ) ) % MOD ; ans = ( ans + p ) % MOD ; n = rem - 1 ; } cout << ans ; } int main ( ) { int N = 3 ; sumOfBinaryNumbers ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findGCD ( int a , int b ) { if ( b == 0 ) return a ; return findGCD ( b , a % b ) ; } int findLCM ( int a , int b ) { return ( a * b ) / findGCD ( a , b ) ; } int uniqueElementsLCM ( int arr [ ] , int N ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int lcm = 1 ; for ( auto i : freq ) { if ( i . second == 1 ) { lcm = findLCM ( lcm , i . first ) ; } } if ( lcm == 1 ) lcm = -1 ; cout << lcm ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 3 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; uniqueElementsLCM ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int mod = 1000000007 ; int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } int asymmetricRelation ( int N ) { return power ( 3 , ( N * N - N ) / 2 ) ; } int main ( ) { int N = 2 ; cout << asymmetricRelation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void crossProduct ( int vect_A [ ] , int vect_B [ ] , int cross_P [ ] ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; } void checkCollinearity ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { int A [ 3 ] = { x1 , y1 , z1 } ; int B [ 3 ] = { x2 , y2 , z2 } ; int cross_P [ 3 ] ; crossProduct ( A , B , cross_P ) ; if ( cross_P [ 0 ] == 0 && cross_P [ 1 ] == 0 && cross_P [ 2 ] == 0 ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int x1 = 4 , y1 = 8 , z1 = 12 ; int x2 = 8 , y2 = 16 , z2 = 24 ; checkCollinearity ( x1 , y1 , z1 , x2 , y2 , z2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float vectorMagnitude ( int x , int y , int z ) { int sum = x * x + y * y + z * z ; return sqrt ( sum ) ; } int main ( ) { int x = 1 ; int y = 2 ; int z = 3 ; cout << vectorMagnitude ( x , y , z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float kineticEnergy ( float M , float V ) { float KineticEnergy ; KineticEnergy = 0.5 * M * V * V ; return KineticEnergy ; } float potentialEnergy ( float M , float H ) { float PotentialEnergy ; PotentialEnergy = M * 9.8 * H ; return PotentialEnergy ; } int main ( ) { float M = 5.5 , H = 23.5 , V = 10.5 ; cout << " Kinetic ▁ Energy ▁ = ▁ " << kineticEnergy ( M , V ) << endl ; cout << " Potential ▁ Energy ▁ = ▁ " << potentialEnergy ( M , H ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nearestFibonacci ( int num ) { if ( num == 0 ) { cout << 0 ; return ; } int first = 0 , second = 1 ; int third = first + second ; while ( third <= num ) { first = second ; second = third ; third = first + second ; } int ans = ( abs ( third - num ) >= abs ( second - num ) ) ? second : third ; cout << ans ; } int main ( ) { int N = 17 ; nearestFibonacci ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void distribute ( int N , int K , int M , int arr [ ] ) { int distribution [ N ] = { 0 } ; int ptr = K - 1 ; int rem = M ; while ( rem > 0 ) { if ( rem >= arr [ ptr ] ) { distribution [ ptr ] += arr [ ptr ] ; rem -= arr [ ptr ] ; } else { distribution [ ptr ] += rem ; rem = 0 ; } ptr = ( ptr + 1 ) % N ; } for ( int i = 0 ; i < N ; i ++ ) { cout << distribution [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 2 , 3 , 2 , 1 , 4 } ; int M = 11 , S = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; distribute ( N , S , M , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void waysToRemove ( int n , int m ) { int ans = 0 ; if ( m == 1 ) { cout << n ; return ; } for ( int d = 0 ; d >= 0 ; d ++ ) { int len = m + ( m - 1 ) * d ; if ( len > n ) break ; ans += ( n - len ) + 1 ; } cout << ans ; } int main ( ) { int N = 5 , M = 3 ; waysToRemove ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countStairs ( int n , int x , int a , int b ) { int vis [ n + 1 ] = { 0 } ; int moves [ ] = { + a , - a , + b , - b } ; queue < int > q ; q . push ( x ) ; vis [ x ] = 1 ; while ( ! q . empty ( ) ) { int currentStair = q . front ( ) ; q . pop ( ) ; for ( int j = 0 ; j < 4 ; j ++ ) { int newStair = currentStair + moves [ j ] ; if ( newStair > 0 && newStair <= n && ! vis [ newStair ] ) { q . push ( newStair ) ; vis [ newStair ] = 1 ; } } } int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( vis [ i ] == 1 ) cnt ++ ; cout << cnt ; } int main ( ) { int N = 10 , S = 2 , A = 5 , B = 7 ; countStairs ( N , S , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallerNumbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { count ++ ; } } cout << count << " ▁ " ; } } int main ( ) { int arr [ ] = { 3 , 4 , 1 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; smallerNumbers ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } void minimumOperations ( int X , int Y ) { int GCD = gcd ( X , Y ) ; X = X / GCD ; Y = Y / GCD ; int count = 0 ; while ( X != Y ) { if ( Y > X ) { swap ( X , Y ) ; } if ( X % 2 == 0 ) { X = X / 2 ; } else if ( X % 3 == 0 ) { X = X / 3 ; } else if ( X % 5 == 0 ) { X = X / 5 ; } else { cout << " - 1" ; return ; } count ++ ; } cout << count ; } int main ( ) { int X = 15 , Y = 20 ; minimumOperations ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int a [ ] , int n ) { int ans = accumulate ( a , a + n , 0 ) - n ; for ( int x = 1 ; ; x ++ ) { int curPow = 1 , curCost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curCost += abs ( a [ i ] - curPow ) ; curPow *= x ; } if ( curPow / x > ans + a [ n - 1 ] ) break ; ans = min ( ans , curCost ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int floorMod ( int a , int n ) { int q = ( int ) floor ( ( double ) a / n ) ; return a - n * q ; } int main ( ) { int a , b ; a = 9 ; b = 4 ; cout << a << " ▁ % ▁ " << b << " ▁ = ▁ " << floorMod ( a , b ) << " STRNEWLINE " ; a = -9 ; b = 4 ; cout << a << " ▁ % ▁ " << b << " ▁ = ▁ " << floorMod ( a , b ) << " STRNEWLINE " ; a = 9 ; b = -4 ; cout << a << " ▁ % ▁ " << b << " ▁ = ▁ " << floorMod ( a , b ) << " STRNEWLINE " ; a = -9 ; b = -4 ; cout << a << " ▁ % ▁ " << b << " ▁ = ▁ " << floorMod ( a , b ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } void nearestPowerDiff ( int arr [ ] , int N , int a , int b ) { for ( int i = 0 ; i < N ; i ++ ) { int log_a = log ( arr [ i ] ) / log ( a ) ; int A = pow ( a , log_a ) ; int B = pow ( a , log_a + 1 ) ; if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) log_a = A ; else log_a = B ; int log_b = log ( arr [ i ] ) / log ( b ) ; A = pow ( b , log_b ) ; B = pow ( b , log_b + 1 ) ; if ( ( arr [ i ] - A ) < ( B - arr [ i ] ) ) log_b = A ; else log_b = B ; arr [ i ] = abs ( log_a - log_b ) ; } printArray ( arr , N ) ; } int main ( ) { int arr [ ] = { 5 , 12 , 25 } ; int A = 2 , B = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nearestPowerDiff ( arr , N , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int bitOr ( int arr [ ] , int N ) { int count = 0 ; int length = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { length ++ ; } else { if ( length != 0 ) { count += ( ( length ) * ( length + 1 ) ) / 2 ; } length = 0 ; } } count += ( ( length ) * ( length + 1 ) ) / 2 ; return count ; } int main ( ) { int arr [ ] = { 1 , 5 , 4 , 2 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << bitOr ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumAND ( int arr [ ] , int n , int m ) { int tot = 1 << n ; int mx = 0 ; for ( int bm = 0 ; bm < tot ; bm ++ ) { int andans = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( ( bm >> i ) & 1 ) { if ( count == 0 ) { andans = arr [ i ] ; } else { andans = andans & arr [ i ] ; } count ++ ; } } if ( count == ( m + 1 ) ) { mx = max ( mx , andans ) ; } } return mx ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = 2 ; cout << maximumAND ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTotalSum ( vector < string > & ops ) { if ( ops . empty ( ) ) { cout << 0 ; return ; } stack < int > pts ; int ans = 0 ; for ( int i = 0 ; i < ops . size ( ) ; i ++ ) { if ( ops [ i ] == " C " ) { ans -= pts . top ( ) ; pts . pop ( ) ; } else if ( ops [ i ] == " D " ) { pts . push ( pts . top ( ) * 2 ) ; ans += pts . top ( ) ; } else if ( ops [ i ] == " + " ) { int a = pts . top ( ) ; pts . pop ( ) ; int b = pts . top ( ) ; pts . push ( a ) ; ans += ( a + b ) ; pts . push ( a + b ) ; } else { int n = stoi ( ops [ i ] ) ; ans += n ; pts . push ( n ) ; } } cout << ans ; } int main ( ) { vector < string > arr = { "5" , " - 2" , " C " , " D " , " + " } ; findTotalSum ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findXOR ( vector < vector < vector < int > > > & mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) { if ( ( i == j && j == k ) ) { XOR ^= mat [ i ] [ j ] [ k ] ; XOR ^= mat [ i ] [ j ] [ N - k - 1 ] ; } } } } cout << XOR << " STRNEWLINE " ; } int main ( ) { vector < vector < vector < int > > > mat = { { { 1 , 2 } , { 3 , 4 } } , { { 5 , 6 } , { 7 , 8 } } } ; int N = mat . size ( ) ; findXOR ( mat , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  300004 NEW_LINE using namespace std ; vector < int > graph [ MAX ] ; int mod = 1e9 + 7 ; int ans = 0 ; int countSubtreesUtil ( int cur , int par ) { int res = 1 ; for ( int i = 0 ; i < graph [ cur ] . size ( ) ; i ++ ) { int v = graph [ cur ] [ i ] ; if ( v == par ) continue ; res = ( res * ( countSubtreesUtil ( v , cur ) + 1 ) ) % mod ; } ans = ( ans + res ) % mod ; return res ; } void countSubtrees ( int N , vector < pair < int , int > > & adj ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { int a = adj [ i ] . first ; int b = adj [ i ] . second ; graph [ a ] . push_back ( b ) ; graph [ b ] . push_back ( a ) ; } countSubtreesUtil ( 1 , 1 ) ; cout << ans + 1 ; } int main ( ) { int N = 3 ; vector < pair < int , int > > adj = { { 0 , 1 } , { 1 , 2 } } ; countSubtrees ( N , adj ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArray ( int N ) { vector < int > ans ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { ans . push_back ( i ) ; if ( N != ( i * i ) ) { ans . push_back ( N / i ) ; } } } for ( auto it : ans ) { cout << it << " ▁ " ; } } int main ( ) { int N = 12 ; constructArray ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int maximumRowValue ( int n , int m ) { return gcd ( n , m ) ; } int main ( ) { int N = 4 ; int M = 2 ; cout << maximumRowValue ( N , M ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; constexpr int MOD = 998244353 ; void findConvolution ( const vector < int > & a , const vector < int > & b ) { int n = a . size ( ) , m = b . size ( ) ; vector < long long > c ( n + m - 1 ) ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { c [ i + j ] += 1LL * ( a [ i ] * b [ j ] ) % MOD ; } } for ( int k = 0 ; k < c . size ( ) ; ++ k ) { c [ k ] %= MOD ; cout << c [ k ] << " ▁ " ; } } int main ( ) { vector < int > A = { 1 , 2 , 3 , 4 } ; vector < int > B = { 5 , 6 , 7 , 8 , 9 } ; findConvolution ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define P  51 NEW_LINE int count1s ( int start_i , int start_j , int end_i , int end_j , int mat [ ] [ P ] ) { int count = 0 ; for ( int x = start_i ; x < end_i ; x ++ ) { for ( int y = start_j ; y < end_j ; y ++ ) { if ( mat [ x ] [ y ] == 1 ) count ++ ; } } return count ; } int findMinimumCount ( int N , int M , int A , int B , int mat [ ] [ P ] ) { int minimum = 1e9 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i + A <= N && j + B <= M ) { int count = count1s ( i , j , i + A , j + B , mat ) ; minimum = min ( count , minimum ) ; } if ( i + B <= N && j + A <= M ) { int count = count1s ( i , j , i + B , j + A , mat ) ; minimum = min ( count , minimum ) ; } } } return minimum ; } int main ( ) { int A = 2 , B = 2 ; int N = 3 , M = 4 ; int mat [ P ] [ P ] = { { 1 , 0 , 1 , 0 } , { 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } } ; cout << findMinimumCount ( N , M , A , B , mat ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkEvenPower ( int n ) { int x = 0 ; while ( x < n ) { int value = pow ( 2 , x ) ; if ( value == n ) { if ( x % 2 == 0 ) return true ; else return false ; } x ++ ; } return false ; } int main ( ) { int N = 4 ; cout << ( checkEvenPower ( N ) ? " Yes " : " No " ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string checkEvenPower ( int n ) { int low = 0 , high = n ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; int value = pow ( 2 , mid ) ; if ( value == n ) { if ( mid % 2 == 1 ) return " No " ; else return " Yes " ; } else if ( value < n ) low = mid + 1 ; else high = mid - 1 ; } return " No " ; } int main ( ) { int N = 4 ; cout << checkEvenPower ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long multiplyByMersenne ( long N , long M ) { long x = log2 ( M + 1 ) ; return ( ( N << x ) - N ) ; } int main ( ) { long N = 4 ; long M = 15 ; cout << multiplyByMersenne ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int N , int K ) { int ans = 0 ; int i = 1 ; while ( i <= N ) { ans += N / i ; i = i * K ; } cout << ans ; } int main ( ) { int N = 10 , K = 2 ; findSum ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumInsertions ( int arr [ ] , int N , int K ) { bool possible = 1 ; int res = 0 ; int last = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] >= K ) { possible = 0 ; break ; } if ( last + arr [ i ] > K ) res ++ ; last = arr [ i ] ; } if ( possible ) { cout << res ; } else { cout << " - 1" ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int K = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumInsertions ( arr , N , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int mod = 1000000007 ; int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } int irreflexiveRelation ( int N ) { return power ( 2 , N * N - N ) ; } int main ( ) { int N = 2 ; cout << irreflexiveRelation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countAPs ( long long int N ) { long long int count = 0 ; for ( long long int i = 1 ; i * i <= 2 * N ; i ++ ) { long long int res = 2 * N ; if ( res % i == 0 ) { long long int op = res / i - i + 1 ; if ( op % 2 == 0 ) { count ++ ; } if ( i * i != res and ( i - res / i + 1 ) % 2 == 0 ) { count ++ ; } } } cout << count - 1 << " STRNEWLINE " ; } int main ( ) { long long int N = 963761198400 ; countAPs ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int perfectSquare ( int num ) { int sr = sqrt ( num ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( num - a ) < ( b - num ) ) { return a ; } else { return b ; } } int powerOfTwo ( int num ) { int lg = log2 ( num ) ; int p = pow ( 2 , lg ) ; return p ; } void uniqueElement ( int arr [ ] , int N ) { bool ans = true ; unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } for ( auto el : freq ) { if ( el . second == 1 ) { ans = false ; int ps = perfectSquare ( el . first ) ; cout << powerOfTwo ( ps ) << ' ▁ ' ; } } if ( ans ) cout << " - 1" ; } int main ( ) { int arr [ ] = { 4 , 11 , 4 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; uniqueElement ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sieve [ 105 ] ; void buildSieve ( ) { for ( int i = 2 ; i < 100 ; i ++ ) sieve [ i ] = 1 ; for ( int i = 2 ; i < 100 ; i ++ ) { if ( sieve [ i ] == 1 ) { for ( int j = i * i ; j < 100 ; j += i ) sieve [ j ] = 0 ; } } } bool isAnyPrime ( int first , int last ) { int num1 = first * 10 + last ; int num2 = last * 10 + first ; if ( sieve [ num1 ] == 1 sieve [ num2 ] == 1 ) return true ; else return false ; } void performQueries ( vector < int > q ) { for ( int i = 0 ; i < q . size ( ) ; i ++ ) { int A = q [ i ] ; int last = A % 10 ; int first ; while ( A >= 10 ) A = A / 10 ; first = A ; if ( isAnyPrime ( first , last ) ) cout << " True STRNEWLINE " ; else cout << " False STRNEWLINE " ; } } int main ( ) { vector < int > q = { 30 , 66 } ; buildSieve ( ) ; performQueries ( q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string oddDivisor ( int N ) { int X = N ; while ( N % 2 == 0 ) { N /= 2 ; } for ( int i = 3 ; i * i <= X ; i += 2 ) { if ( N % i == 0 ) { return " Yes " ; } } if ( N != X ) return " Yes " ; return " No " ; } int main ( ) { int N = 10 ; cout << oddDivisor ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int arr [ 10005 ] ; int isPalindrome ( int n ) { int temp = n ; int res = 0 ; while ( temp != 0 ) { int rem = temp % 10 ; res = res * 10 + rem ; temp /= 10 ; } if ( res == n ) { return 1 ; } else return 0 ; } void precompute ( ) { for ( int i = 1 ; i <= 10000 ; i ++ ) { if ( isPalindrome ( i * i * i ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } for ( int i = 1 ; i <= 10000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } } int main ( ) { vector < pair < int , int > > Q = { { 2 , 7 } , { 10 , 25 } } ; precompute ( ) ; for ( auto it : Q ) { cout << arr [ it . second ] - arr [ it . first - 1 ] << " STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int arr [ 100005 ] ; bool isDivisible ( int x ) { int sum = 0 ; int temp = x ; while ( x != 0 ) { sum += x % 10 ; x /= 10 ; } if ( temp % sum ) return false ; else return true ; } void precompute ( ) { for ( int i = 1 ; i <= 100000 ; i ++ ) { if ( isDivisible ( i ) ) arr [ i ] = 1 ; else arr [ i ] = 0 ; } for ( int i = 1 ; i <= 100000 ; i ++ ) { arr [ i ] = arr [ i ] + arr [ i - 1 ] ; } } int main ( ) { vector < pair < int , int > > Q = { { 5 , 9 } , { 5 , 20 } } ; precompute ( ) ; for ( auto it : Q ) { cout << arr [ it . second ] - arr [ it . first - 1 ] << " STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int primes [ 1000006 ] ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } void preprocess ( ) { for ( int i = 1 ; i <= 1000000 ; i ++ ) primes [ i ] = i ; for ( int i = 2 ; i * i <= 1000000 ; i ++ ) { if ( primes [ i ] == i ) { for ( int j = 2 * i ; j <= 1000000 ; j += i ) { if ( primes [ j ] == j ) primes [ j ] = i ; } } } } int Steps ( int x , int m ) { int steps = 0 ; bool flag = false ; while ( x > 1 ) { if ( primes [ x ] > m ) { flag = true ; break ; } x /= primes [ x ] ; steps ++ ; } if ( flag ) return -1 ; return steps ; } int minimumSteps ( int x , int y , int m ) { preprocess ( ) ; int g = gcd ( x , y ) ; x = x / g ; y = y / g ; int x_steps = Steps ( x , m ) ; int y_steps = Steps ( y , m ) ; if ( x_steps == -1 y_steps == -1 ) return -1 ; return x_steps + y_steps ; } int main ( ) { int X = 160 ; int Y = 180 ; int M = 10 ; cout << ( minimumSteps ( X , Y , M ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isNonDeficient ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum >= 2 * n ; } int LongestNonDeficientSubsequence ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isNonDeficient ( arr [ i ] ) ) { res += 1 ; } } return res ; } int main ( ) { int arr [ ] = { 13 , 55 , 240 , 32 , 24 , 27 , 56 , 80 , 100 , 330 , 89 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << LongestNonDeficientSubsequence ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } int findSum ( int n ) { int sum = 0 ; for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == 2 ) { sum += num ; i ++ ; } } return sum ; } void check ( int n , int k ) { int s = findSum ( k - 1 ) ; if ( s >= n ) cout << " No " ; else cout << " Yes " ; } int main ( ) { int n = 100 , k = 6 ; check ( n , k ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; bool isPronic ( int n ) { int range = sqrt ( n ) ; for ( int i = 0 ; i < range + 1 ; i ++ ) { if ( i * ( i + 1 ) == n ) return true ; } return false ; } int countSub ( int * arr , int n ) { int ans = 0 ; int ispro = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPronic ( arr [ i ] ) ) ispro += 1 ; else ispro = 0 ; ans += ispro ; } return ans ; } int main ( ) { int arr [ 5 ] = { 5 , 6 , 12 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSub ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; int LOG ( int a , int b ) { return log ( a ) / log ( b ) ; } void repbyNP ( int * arr , int n ) { int x = arr [ n - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { int k = LOG ( arr [ i ] , x ) ; int temp = arr [ i ] ; if ( abs ( pow ( x , k ) - arr [ i ] ) < abs ( pow ( x , k + 1 ) - arr [ i ] ) ) arr [ i ] = pow ( x , k ) ; else arr [ i ] = pow ( x , k + 1 ) ; x = temp ; } } int main ( ) { int arr [ 5 ] = { 2 , 4 , 6 , 3 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; repbyNP ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEqualElementPairs ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] += 1 ; } int total = 0 ; for ( auto i : mp ) { total += ( i . second * ( i . second - 1 ) ) / 2 ; } for ( int i = 0 ; i < N ; i ++ ) { cout << total - ( mp [ arr [ i ] ] - 1 ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countEqualElementPairs ( arr , N ) ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int lastElement ( const int arr [ ] , int n ) { int sum = 0 ; int multiplier = n % 2 == 0 ? -1 : 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * multiplier ; multiplier = multiplier * ( n - 1 - i ) / ( i + 1 ) * ( -1 ) ; } return sum ; } int main ( ) { int arr [ ] = { 3 , 4 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << lastElement ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] & 1 ) odd ++ ; } int ans = ( N - odd + odd / 2 - 1 ) + odd / 2 ; return ans ; } int main ( ) { int arr [ ] = { 4 , 6 , 1 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int N ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { freq [ log2 ( arr [ i ] ) ] ++ ; } int pairs = 0 ; for ( auto i : freq ) { pairs += i . second - 1 ; } return pairs ; } int main ( ) { int arr [ ] = { 12 , 9 , 15 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countBit ( int n ) { return int ( log2 ( n ) ) + 1 ; } int countSetBit ( int n ) { int ans = 0 ; while ( n > 0 ) { ans += ( n & 1 ) ; n >>= 1 ; } return ans ; } int maximize ( int n ) { int bits = countBit ( n ) ; int setBits = countSetBit ( n ) ; int ans = 0 ; for ( int i = 0 ; i < bits ; i ++ ) { if ( i < setBits ) ans |= 1 ; if ( i != setBits - 1 ) ans <<= 1 ; } return ans ; } int minimize ( int n ) { int setBits = countSetBit ( n ) ; int ans = 0 ; for ( int i = 0 ; i < setBits ; i ++ ) { ans |= 1 ; if ( i != setBits - 1 ) ans <<= 1 ; } return ans ; } int maxDiff ( vector < int > arr ) { int caseOne = 0 ; int SumOfOdd = 0 ; int SumOfeven = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( i % 2 ) SumOfOdd += minimize ( arr [ i ] ) ; else SumOfeven += maximize ( arr [ i ] ) ; } caseOne = abs ( SumOfOdd - SumOfeven ) ; int caseTwo = 0 ; SumOfOdd = 0 ; SumOfeven = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( i % 2 ) SumOfOdd += maximize ( arr [ i ] ) ; else SumOfeven += minimize ( arr [ i ] ) ; } caseTwo = abs ( SumOfOdd - SumOfeven ) ; return max ( caseOne , caseTwo ) ; } int main ( ) { vector < int > arr { 54 , 32 , 11 , 23 } ; cout << maxDiff ( arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumDifference ( int N ) { int sum1 = ( 1 << N ) , sum2 = 0 ; for ( int i = 1 ; i < N / 2 ; i ++ ) sum1 += ( 1 << i ) ; for ( int i = N / 2 ; i < N ; i ++ ) sum2 += ( 1 << i ) ; cout << sum1 - sum2 ; } int main ( ) { int N = 4 ; minimumDifference ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectCube ( int x ) { int cr = round ( cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; } void canBePerfectCube ( int N , int K ) { if ( isPerfectCube ( N + K ) || isPerfectCube ( N - K ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; } int main ( ) { int N = 7 , K = 1 ; canBePerfectCube ( N , K ) ; N = 5 , K = 4 ; canBePerfectCube ( N , K ) ; N = 7 , K = 2 ; canBePerfectCube ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sqrtSearch ( int low , int high , int N ) { if ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * mid <= N ) && ( ( mid + 1 ) * ( mid + 1 ) > N ) ) { return mid ; } else if ( mid * mid < N ) { return sqrtSearch ( mid + 1 , high , N ) ; } else { return sqrtSearch ( low , mid - 1 , N ) ; } } return low ; } int main ( ) { int N = 25 ; cout << sqrtSearch ( 0 , N , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } void printAllDivisors ( int arr [ ] , int N ) { int g = arr [ 0 ] ; set < int > divisors ; for ( int i = 1 ; i < N ; i ++ ) { g = gcd ( arr [ i ] , g ) ; } for ( int i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { divisors . insert ( i ) ; if ( g / i != i ) divisors . insert ( g / i ) ; } } for ( auto & it : divisors ) cout << it << " ▁ " ; } int main ( ) { int arr [ ] = { 6 , 90 , 12 , 18 , 30 , 24 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAllDivisors ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void mul_table ( int N , int i ) { if ( i > 10 ) return ; cout << N << " ▁ * ▁ " << i << " ▁ = ▁ " << N * i << endl ; return mul_table ( N , i + 1 ) ; } int main ( ) { int N = 8 ; mul_table ( N , 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int getSmallestPrimefactor ( int n ) { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return i ; } } int main ( ) { int N = 100 ; int a ; a = getSmallestPrimefactor ( N ) ; if ( isPrime ( N / a ) ) { cout << " - 1" ; } else { cout << N / a ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkEqualNo ( int m , int n , int a , int b ) { if ( m <= n ) { if ( ( n - m ) % ( a + b ) == 0 ) { return true ; } else { return false ; } } else { return false ; } } int main ( ) { int M = 2 , N = 8 ; int A = 3 , B = 3 ; if ( checkEqualNo ( M , N , A , B ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long pref [ 100001 ] ; int checkPalindrome ( int num ) { string str = to_string ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { return 0 ; } l ++ ; r -- ; } return num ; } void preCompute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + checkPalindrome ( i ) ; } } void printSum ( int L , int R ) { cout << pref [ R ] - pref [ L - 1 ] << endl ; } void printSumPalindromic ( int arr [ ] [ 2 ] , int Q ) { preCompute ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } } int main ( ) { int Q = 2 ; int arr [ ] [ 2 ] = { { 10 , 13 } , { 12 , 21 } } ; printSumPalindromic ( arr , Q ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 1 ) sum += ( i * i ) ; else sum -= ( i * i ) ; } return sum ; } int main ( ) { int N = 2 ; cout << summation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y + x ) % ( y ^ x ) == 0 ) count ++ ; } } return count ; } int main ( ) { int n = 6 ; cout << countPairs ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xor_all_elements ( int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } } vector < int > findArray ( int xorr [ ] , int n ) { vector < int > arr ; int xor_all = xor_all_elements ( n ) ; int xor_adjacent = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { xor_adjacent = xor_adjacent ^ xorr [ i ] ; } int last_element = xor_all ^ xor_adjacent ; arr . push_back ( last_element ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { last_element = xorr [ i ] ^ last_element ; arr . push_back ( last_element ) ; } return arr ; } int main ( ) { vector < int > arr ; int xorr [ ] = { 7 , 5 , 3 , 7 } ; int n = 5 ; arr = findArray ( xorr , n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { cout << arr [ i ] << " ▁ " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfParts ( int * arr , int N ) { int sum_part1 = 0 , sum_part2 = 0 , sum_part3 = 0 , sum_part4 = 0 ; int totalsum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i + j < N - 1 ) { if ( i < j and i != j and i + j ) sum_part1 += ( arr + i * N ) [ j ] ; else if ( i != j ) sum_part2 += ( arr + i * N ) [ j ] ; } else { if ( i > j and i + j != N - 1 ) sum_part3 += ( arr + i * N ) [ j ] ; else { if ( i + j != N - 1 and i != j ) sum_part4 += ( arr + i * N ) [ j ] ; } } } } totalsum = sum_part1 + sum_part2 + sum_part3 + sum_part4 ; return totalsum ; } int main ( ) { int N = 4 ; int arr [ N ] [ N ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; cout << sumOfParts ( ( int * ) arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ifPossible ( int X , int Y ) { if ( X > Y ) swap ( X , Y ) ; if ( ( X + Y ) % 5 == 0 and 3 * X >= 2 * Y ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int X = 33 , Y = 27 ; ifPossible ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int n ) { string ans = string ( n - 1 , ' F ' ) ; string even = ans + ' E ' ; string odd = ans + ' F ' ; cout << " Even : ▁ " << even << endl ; cout << " Odd : ▁ " << odd << endl ; } int main ( ) { int n = 2 ; findNumbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int log_a_to_base_b ( int a , int b ) { return log ( a ) / log ( b ) ; } int main ( ) { int a = 3 ; int b = 2 ; cout << log_a_to_base_b ( a , b ) << endl ; a = 256 ; b = 4 ; cout << log_a_to_base_b ( a , b ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int log_a_to_base_b ( int a , int b ) { return ( a > b - 1 ) ? 1 + log_a_to_base_b ( a / b , b ) : 0 ; } int main ( ) { int a = 3 ; int b = 2 ; cout << log_a_to_base_b ( a , b ) << endl ; a = 256 ; b = 4 ; cout << log_a_to_base_b ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findLargest ( int N ) { string largest = string ( N , ' F ' ) ; return largest ; } string findSmallest ( int N ) { string smallest = "1" + string ( ( N - 1 ) , '0' ) ; return smallest ; } void print ( int largest ) { cout << " Largest : ▁ " << findLargest ( largest ) << endl ; cout << " Smallest : ▁ " << findSmallest ( largest ) << endl ; } int main ( ) { int N = 4 ; print ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int prevPowerofK ( int n , int k ) { int p = ( int ) ( log ( n ) / log ( k ) ) ; return ( int ) pow ( k , p ) ; } int nextPowerOfK ( int n , int k ) { return prevPowerofK ( n , k ) * k ; } void printResult ( int n , int k ) { cout << prevPowerofK ( n , k ) << " ▁ " << nextPowerOfK ( n , k ) << endl ; } int main ( ) { int n = 25 , k = 3 ; printResult ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canMake ( int n , int ar [ ] ) { int sum = 0 , maxx = -1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; maxx = max ( maxx , ar [ i ] ) ; } if ( n == 1 sum % 2 == 1 sum - maxx < maxx ) { cout << " No STRNEWLINE " ; } else { cout << " Yes STRNEWLINE " ; } } int main ( ) { int n = 6 ; int arr [ ] = { 1 , 1 , 2 , 3 , 6 , 11 } ; canMake ( n , arr ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; bool isPalindrome ( int n ) { string str = to_string ( n ) ; int s = 0 , e = str . length ( ) - 1 ; while ( s < e ) { if ( str [ s ] != str [ e ] ) { return false ; } s ++ ; e -- ; } return true ; } void palindromicDivisors ( int n ) { vector < int > PalindromDivisors ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( isPalindrome ( i ) ) { PalindromDivisors . push_back ( i ) ; } } else { if ( isPalindrome ( i ) ) { PalindromDivisors . push_back ( i ) ; } if ( isPalindrome ( n / i ) ) { PalindromDivisors . push_back ( n / i ) ; } } } } sort ( PalindromDivisors . begin ( ) , PalindromDivisors . end ( ) ) ; for ( int i = 0 ; i < PalindromDivisors . size ( ) ; i ++ ) { cout << PalindromDivisors [ i ] << " ▁ " ; } } int main ( ) { int n = 66 ; palindromicDivisors ( n ) ; }
#include <iostream> NEW_LINE using namespace std ; string smallestPoss ( string s , int n ) { string ans = " " ; int arr [ 10 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { arr [ s [ i ] - 48 ] ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) ans = ans + to_string ( i ) ; } return ans ; } int main ( ) { int N = 15 ; string K = "325343273113434" ; cout << smallestPoss ( K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  int NEW_LINE using namespace std ; long long pref [ 100010 ] ; int isPerfectSquare ( long long int x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ? x : 0 ; } void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectSquare ( i ) ; } } void printSum ( int L , int R ) { int sum = pref [ R ] - pref [ L - 1 ] ; cout << sum << " ▁ " ; } int main ( ) { compute ( ) ; int Q = 4 ; int arr [ ] [ 2 ] = { { 1 , 10 } , { 1 , 100 } , { 2 , 25 } , { 4 , 50 } } ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void factors ( int n , int i ) { if ( i <= n ) { if ( n % i == 0 ) { cout << i << " ▁ " ; } factors ( n , i + 1 ) ; } } int main ( ) { int N = 16 ; factors ( N , 1 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int n ) { int ans = ( n * n / 4 ) ; return ans ; } int main ( ) { int n = 10 ; cout << solve ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printMultiples ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { cout << ( i * j ) << " ▁ " ; } cout << endl ; } } int main ( ) { int N = 5 ; printMultiples ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nature_of_roots ( int a , int b , int c ) { if ( a == 0 ) { cout << " Not ▁ a ▁ Quadratic ▁ Equation " << endl ; return ; } int D = b * b - 4 * a * c ; if ( D > 0 ) { cout << " Real ▁ Roots " << endl ; } else if ( D == 0 ) { cout << " Equal ▁ Roots " << endl ; } else { cout << " Imaginary ▁ Roots " << endl ; } } void checkForAllTestCase ( ) { cout << " Testcase " << " TABSYMBOL a TABSYMBOL b TABSYMBOL c TABSYMBOL Actual ▁ Output " << endl ; cout << endl ; int a , b , c ; int testcase = 1 ; while ( testcase <= 13 ) { if ( testcase == 1 ) { a = 0 ; b = 50 ; c = 50 ; } else if ( testcase == 2 ) { a = 1 ; b = 50 ; c = 50 ; } else if ( testcase == 3 ) { a = 50 ; b = 50 ; c = 50 ; } else if ( testcase == 4 ) { a = 99 ; b = 50 ; c = 50 ; } else if ( testcase == 5 ) { a = 100 ; b = 50 ; c = 50 ; } else if ( testcase == 6 ) { a = 50 ; b = 0 ; c = 50 ; } else if ( testcase == 7 ) { a = 50 ; b = 1 ; c = 50 ; } else if ( testcase == 8 ) { a = 50 ; b = 99 ; c = 50 ; } else if ( testcase == 9 ) { a = 50 ; b = 100 ; c = 50 ; } else if ( testcase == 10 ) { a = 50 ; b = 50 ; c = 0 ; } else if ( testcase == 11 ) { a = 50 ; b = 50 ; c = 1 ; } else if ( testcase == 12 ) { a = 50 ; b = 50 ; c = 99 ; } else if ( testcase == 13 ) { a = 50 ; b = 50 ; c = 100 ; } cout << " TABSYMBOL " << testcase << " TABSYMBOL " << a << " TABSYMBOL " << b << " TABSYMBOL " << c << " TABSYMBOL " ; nature_of_roots ( a , b , c ) ; cout << endl ; testcase ++ ; } } int main ( ) { checkForAllTestCase ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isPossible ( int N , int S , int C , int H , int L , int T ) { int total_time_required = S * C * H ; int available_time_after_vacation = ( N - L ) * T ; if ( available_time_after_vacation >= total_time_required ) return 1 ; return 0 ; } int main ( ) { int N = 12 , S = 5 , C = 8 , H = 3 , L = 2 , T = 20 ; if ( isPossible ( N , S , C , H , L , T ) ) cout << " Yes " << endl ; else cout << " No " << endl ; N = 1 , S = 2 , C = 3 , H = 4 , L = 5 , T = 6 ; if ( isPossible ( N , S , C , H , L , T ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum ( int x , int y ) { return ( ( x + y + abs ( x - y ) ) / 2 ) ; } int minimum ( int x , int y ) { return ( ( x + y - abs ( x - y ) ) / 2 ) ; } int main ( ) { int x = 99 , y = 18 ; cout << " Maximum : ▁ " << maximum ( x , y ) << endl ; cout << " Minimum : ▁ " << minimum ( x , y ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SubarraysWithSumS ( int n , int k , int s ) { for ( int i = 0 ; i < k ; i ++ ) cout << s << " ▁ " ; for ( int i = k ; i < n ; i ++ ) cout << s + 1 << " ▁ " ; } int main ( ) { int n = 4 , k = 2 , s = 3 ; SubarraysWithSumS ( n , k , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pay ( int n ) { int cuts = int ( log ( n ) / log ( 2 ) ) ; return cuts ; } int main ( ) { int n = 5 ; int cuts = pay ( n ) ; cout << cuts << endl ; n = 15 ; cuts = pay ( n ) ; cout << ( cuts ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100000 ; int max_prime [ MAX ] ; int min_prime [ MAX ] ; void sieve ( int n ) { for ( int i = 2 ; i <= n ; ++ i ) { if ( min_prime [ i ] > 0 ) { continue ; } min_prime [ i ] = i ; max_prime [ i ] = i ; int j = i + i ; while ( j <= n ) { if ( min_prime [ j ] == 0 ) { min_prime [ j ] = i ; } max_prime [ j ] = i ; j += i ; } } } void findSum ( int arr [ ] , int n ) { sieve ( MAX ) ; for ( int i = 0 ; i < n ; i ++ ) { int sum = min_prime [ arr [ i ] ] + max_prime [ arr [ i ] ] ; cout << sum << " ▁ " ; } } int main ( ) { int arr [ ] = { 5 , 10 , 15 , 20 , 25 , 30 } ; int n = sizeof ( arr ) / sizeof ( int ) ; findSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define int  long long NEW_LINE const int maxin = 100001 ; int divisors [ maxin ] ; void Calc_Max_Div ( int arr [ ] , int n ) { bool vis [ maxin ] ; memset ( vis , 1 , maxin ) ; vis [ 0 ] = vis [ 1 ] = 0 ; for ( int i = 1 ; i <= maxin ; i ++ ) divisors [ i ] = i ; for ( int i = 4 ; i <= maxin ; i += 2 ) { vis [ i ] = 0 ; divisors [ i ] = i / 2 ; } for ( int i = 3 ; i <= maxin ; i += 2 ) { if ( divisors [ i ] != i ) { divisors [ i ] = i / divisors [ i ] ; } if ( vis [ i ] == 1 ) { for ( int j = i * i ; j < maxin ; j += i ) { vis [ j ] = 0 ; if ( divisors [ j ] == j ) divisors [ j ] = i ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( divisors [ arr [ i ] ] == arr [ i ] ) cout << " - 1 ▁ " ; else cout << divisors [ arr [ i ] ] << " ▁ " ; } } int32_t main ( ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( int ) ; Calc_Max_Div ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; } int main ( ) { int n = 50 ; int b = 2 ; cout << sumOfDigit ( n , b ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; } int main ( ) { int a = 100 ; int n = 3 ; int b = 4 ; cout << nthDigit ( a , n , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100001 ; vector < int > primes ; void initialize ( ) { bool numbers [ MAX ] = { } ; int n = MAX ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( ! numbers [ i ] ) for ( int j = i * i ; j <= n ; j += i ) numbers [ j ] = true ; for ( int i = 2 ; i <= n ; i ++ ) if ( numbers [ i ] == false ) primes . push_back ( i ) ; } void findNums ( int num ) { bool ans = false ; int first = -1 , second = -1 , third = -1 ; for ( int i = 0 ; i < num ; i ++ ) { first = primes [ i ] ; for ( int j = 0 ; j < num ; j ++ ) { second = primes [ j ] ; third = num - first - second ; if ( binary_search ( primes . begin ( ) , primes . end ( ) , third ) ) { ans = true ; break ; } } if ( ans ) break ; } if ( ans ) cout << first << " ▁ " << second << " ▁ " << third << endl ; else cout << -1 << endl ; } int main ( ) { int n = 101 ; initialize ( ) ; findNums ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printmaxSubseq ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i + 1 ] ) cout << arr [ i ] << " ▁ " ; else cout << arr [ i ] << " STRNEWLINE " ; } } int main ( ) { int arr [ ] = { 9 , 8 , 11 , 13 , 10 , 15 , 14 , 16 , 20 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printmaxSubseq ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSum ( int N , int L , int R ) { if ( L > R ) { return 0 ; } if ( N == 1 ) { return R - L + 1 ; } if ( N > 1 ) { return ( N - 2 ) * ( R - L ) + 1 ; } } int main ( ) { int N = 4 , L = 4 , R = 6 ; cout << countSum ( N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lli  long long int NEW_LINE lli solve ( lli arr [ ] , lli n , lli k ) { lli i , minx = INT_MAX ; for ( i = 0 ; i < n ; i ++ ) { minx = min ( minx , arr [ i ] ) ; } lli decrements = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - minx ) % k != 0 ) { return -1 ; } else { decrements += ( ( arr [ i ] - minx ) / k ) ; } } return decrements ; } int main ( ) { lli n , k ; n = 3 ; k = 3 ; lli arr [ n ] = { 12 , 9 , 15 } ; cout << solve ( arr , n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void distribution ( int n , int k , int l , int r , int S , int Sk ) { int a [ n ] ; int len = k , temp , rem , s ; int diff = S - Sk ; for ( int i = 0 ; i < len ; i ++ ) { temp = Sk / k ; rem = Sk % k ; if ( temp + rem >= l && temp + rem <= r ) { a [ i ] = temp ; } else if ( temp + rem > r ) { a [ i ] = r ; } else if ( temp + rem < r ) { cout << " - 1" ; return ; } Sk = Sk - a [ i ] ; k = k - 1 ; } if ( Sk > 0 ) { cout << " - 1" ; return ; } if ( len ) { k = n - len ; for ( int i = len ; i < n ; i ++ ) { temp = diff / k ; rem = diff % k ; if ( temp + rem >= l && temp + rem <= r ) { a [ i ] = temp ; } else if ( temp + rem > r ) { a [ i ] = r ; } else if ( temp + rem < r ) { cout << " - 1" ; return ; } diff = diff - a [ i ] ; k = k - 1 ; } if ( diff ) { cout << " - 1" ; return ; } } for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " ▁ " ; } } int main ( ) { int n = 5 , k = 3 , l = 1 , r = 5 , S = 13 , Sk = 9 ; distribution ( n , k , l , r , S , Sk ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_index ( int p [ ] , int n ) { int ans = 0 ; int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] <= mini ) mini = p [ i ] ; if ( mini == p [ i ] ) ans ++ ; } return ans ; } int main ( ) { int P [ ] = { 4 , 2 , 5 , 1 , 3 } ; int n = sizeof ( P ) / sizeof ( int ) ; cout << min_index ( P , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count_subarray ( int arr [ ] , int n ) { int subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { subarray_sum = 0 ; remaining_sum = 0 ; for ( int k = i ; k <= j ; k ++ ) { subarray_sum += arr [ k ] ; } for ( int l = 0 ; l < i ; l ++ ) { remaining_sum += arr [ l ] ; } for ( int l = j + 1 ; l < n ; l ++ ) { remaining_sum += arr [ l ] ; } if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } int main ( ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count_subarray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } int main ( ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << Count_subarray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10 NEW_LINE int countPalindromes ( int n , int m , int matrix [ MAX ] [ MAX ] ) { int count = n * m ; int length_of_sequence_row ; int length_of_sequence_column ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { length_of_sequence_row = min ( j , m - 1 - j ) ; length_of_sequence_column = min ( i , n - i - 1 ) ; for ( int k = 1 ; k <= length_of_sequence_row ; k ++ ) { if ( matrix [ i ] [ j - k ] == matrix [ i ] [ j + k ] ) { count ++ ; } else { break ; } } for ( int k = 1 ; k <= length_of_sequence_column ; k ++ ) { if ( matrix [ i - k ] [ j ] == matrix [ i + k ] [ j ] ) { count ++ ; } else { break ; } } } } return count ; } int main ( void ) { int m = 3 , n = 3 ; int matrix [ MAX ] [ MAX ] = { { 2 , 1 , 2 } , { 1 , 1 , 1 } , { 2 , 1 , 2 } } ; cout << countPalindromes ( n , m , matrix ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumNo ( int n ) { int ans = 0 ; stack < int > stack1 ; stack < int > stack2 ; while ( n != 0 ) { int r = n % 10 ; if ( r % 2 == 0 ) { stack1 . push ( r ) ; } else { stack2 . push ( r ) ; } n = n / 10 ; } while ( ! stack1 . empty ( ) && ! stack2 . empty ( ) ) { if ( stack1 . top ( ) < stack2 . top ( ) ) { ans = ans * 10 + stack1 . top ( ) ; stack1 . pop ( ) ; } else { ans = ans * 10 + stack2 . top ( ) ; stack2 . pop ( ) ; } } while ( ! stack1 . empty ( ) ) { ans = ans * 10 + stack1 . top ( ) ; stack1 . pop ( ) ; } while ( ! stack2 . empty ( ) ) { ans = ans * 10 + stack2 . top ( ) ; stack2 . pop ( ) ; } return ans ; } int main ( ) { int n1 = 64432 ; cout << minimumNo ( n1 ) << endl ; int n2 = 3137 ; cout << minimumNo ( n2 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b % 2 == 1 ) { result = result * a ; } a = a * a ; b = b / 2 ; } return result ; } int factorial ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact = fact * i ; } return fact ; } void findNoOfArrays ( int * a , int n ) { int sum = 0 , s1 , c = 0 ; map < int , int > mp ; for ( int i = 0 ; i < 2 * n ; i ++ ) { mp [ a [ i ] ] ++ ; sum = sum + a [ i ] ; } bool isArrayPossible = true ; int ans = factorial ( n - 1 ) ; s1 = sum / ( n + 1 ) ; if ( mp [ s1 ] >= 2 ) { mp [ s1 ] = mp [ s1 ] - 2 ; } else { isArrayPossible = false ; } if ( isArrayPossible ) { for ( auto i : mp ) { if ( i . first == s1 - i . first ) { if ( mp [ i . first ] % 2 != 0 ) { isArrayPossible = false ; break ; } } if ( i . first != s1 - i . first ) { if ( mp [ i . first ] != mp [ s1 - i . first ] ) { isArrayPossible = false ; break ; } } if ( i . second > 0 ) { if ( i . first != s1 - i . first ) { c = c + i . second ; ans = ans * power ( 2 , i . second ) ; ans = ans / factorial ( i . second ) ; mp [ i . first ] = 0 ; mp [ s1 - i . first ] = 0 ; } if ( i . first == s1 - i . first ) { c = c + i . second / 2 ; ans = ans / factorial ( i . second / 2 ) ; mp [ i . first ] = 0 ; } } } } if ( c < n - 1 isArrayPossible == false ) { cout << "0" << endl ; } else { cout << ans << endl ; } } int main ( ) { int arr1 [ ] = { 5 , 2 , 3 , 5 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; findNoOfArrays ( arr1 , n1 / 2 ) ; int arr2 [ ] = { -1 , -1 , -1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; findNoOfArrays ( arr2 , n2 / 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  1000000 NEW_LINE int maxCommonElement ( int A [ ] , int D [ ] , int N ) { int cnt [ MAXN ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] ; j < MAXN ; j += D [ i ] ) cnt [ j ] ++ ; } int com = max_element ( cnt , cnt + MAXN ) - cnt ; return com ; } int main ( ) { int A [ ] = { 13 , 1 , 2 , 5 } , D [ ] = { 5 , 10 , 1 , 12 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << maxCommonElement ( A , D , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findTrailingZeros ( int n ) { if ( n & 1 ) return 0 ; else { int ans = 0 ; n /= 2 ; while ( n ) { ans += n / 5 ; n /= 5 ; } return ans ; } } int main ( ) { int n = 12 ; cout << findTrailingZeros ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double r1 , r2 , r3 ; double area ( double a , double b , double c ) { double p = ( a + b + c ) / 2 ; return sqrt ( p ) * sqrt ( p - a ) * sqrt ( p - b ) * sqrt ( p - c ) ; } double binary_search ( ) { double s = area ( r1 + r2 , r2 + r3 , r3 + r1 ) ; double l = 0 , h = s / ( r1 + r2 + r3 ) ; while ( h - l >= 1.e-7 ) { double mid = ( l + h ) / 2 ; double s1 = area ( mid + r1 , mid + r2 , r1 + r2 ) ; double s2 = area ( mid + r1 , mid + r3 , r1 + r3 ) ; double s3 = area ( mid + r2 , mid + r3 , r2 + r3 ) ; if ( s1 + s2 + s3 < s ) { l = mid ; } else { h = mid ; } } return ( l + h ) / 2 ; } int main ( ) { r1 = 1.0 ; r2 = 2.0 ; r3 = 3.0 ; cout << fixed << setprecision ( 6 ) << binary_search ( ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { double r1 , r2 , r3 ; r1 = 1 ; r2 = 2 ; r3 = 3 ; double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; cout << fixed << setprecision ( 6 ) << r4 << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkZeroArray ( int * arr , int n ) { int sum = 0 , maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + arr [ i ] ; maximum = max ( maximum , arr [ i ] ) ; } if ( sum % 2 == 0 && maximum <= sum / 2 ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; if ( checkZeroArray ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int ll ; bool subArray ( ll * arr , ll n , ll m ) { ll i ; unordered_map < ll , ll > mp ; for ( i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] = i + 1 ; } ll sumcur = 0 ; ll p = INT_MAX ; vector < ll > ans ; for ( i = 1 ; i <= m ; i ++ ) { sumcur += mp [ i ] ; p = min ( p , mp [ i ] ) ; ll val = p * i - i + ( i * ( i + 1 ) ) / 2 ; if ( i == m ) { if ( val == sumcur ) { return true ; } else return false ; } } } int main ( ) { ll arr [ ] = { 4 , 5 , 1 , 3 , 2 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; ll m = 3 ; if ( subArray ( arr , n , m ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string & s ) { int left = 0 , right = s . size ( ) - 1 ; while ( left <= right ) { if ( s [ left ] != s [ right ] ) { return false ; } left ++ ; right -- ; } return true ; } long long getSum ( int n ) { int start = pow ( 10 , n - 1 ) ; int end = pow ( 10 , n ) - 1 ; long long sum = 0 ; for ( int i = start ; i <= end ; i ++ ) { string s = to_string ( i ) ; if ( isPalindrome ( s ) ) { sum += i ; } } return sum ; } int main ( ) { int n = 1 ; long long ans = getSum ( n ) ; cout << ans << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLength ( int * arr , int n ) { int x = 0 ; for ( int i = 0 ; i < n ; i ++ ) x = max ( x , arr [ i ] ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != x ) continue ; int j = i ; while ( arr [ j ] == x ) j ++ ; ans = max ( ans , j - i ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findLength ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long countPairs ( int arr [ ] , int n ) { long count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] * arr [ j ] == arr [ i ] + arr [ j ] ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 2 , 0 , 3 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long countPairs ( int arr [ ] , int n ) { int countZero = 0 ; int countTwo = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) countZero ++ ; else if ( arr [ i ] == 2 ) countTwo ++ ; } long pair0 = ( countZero * ( countZero - 1 ) ) / 2 ; long pair2 = ( countTwo * ( countTwo - 1 ) ) / 2 ; return pair0 + pair2 ; } int main ( ) { int arr [ ] = { 2 , 0 , 3 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubSeq ( int arr [ ] , int n ) { int pos_count = 0 ; int neg_count = 0 ; int result ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos_count ++ ; if ( arr [ i ] < 0 ) neg_count ++ ; } result = pow ( 2 , pos_count ) ; if ( neg_count > 0 ) result *= pow ( 2 , neg_count - 1 ) ; result -= 1 ; return result ; } int main ( ) { int arr [ ] = { 2 , -3 , -1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntSubSeq ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int * arr , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = max ( m , arr [ i ] ) ; int cnt [ m + 2 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j * j <= arr [ i ] ; j ++ ) { if ( arr [ i ] % j == 0 ) { if ( j * j == arr [ i ] ) cnt [ j ] ++ ; else cnt [ j ] ++ , cnt [ arr [ i ] / j ] ++ ; } } } for ( int i = 1 ; i <= m + 1 ; i ++ ) if ( cnt [ i ] == 0 ) { return i ; } return -1 ; } int main ( ) { int arr [ ] = { 2 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMin ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float findNumber ( int N , int S ) { float i = ( ( ( float ) ( N ) * ( float ) ( N + 1 ) ) / 4 ) - ( ( float ) ( S + 1 ) / 2 ) ; return i ; } void check ( int N , int S ) { float i = findNumber ( N , S ) ; int integerI = ( int ) i ; if ( i - integerI == 0 ) cout << " Yes : ▁ " << integerI << " , ▁ " << integerI + 1 << endl ; else cout << " No " << endl ; } int main ( ) { int N = 4 , S = 3 ; check ( N , S ) ; N = 5 , S = 3 ; check ( N , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxXOR ( int * arr , int n ) { int xorArr = 0 ; for ( int i = 0 ; i < n ; i ++ ) xorArr ^= arr [ i ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans = max ( ans , ( xorArr ^ arr [ i ] ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxXOR ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 1e5 ; bool isPrime [ sz + 1 ] ; void sieve ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } } void printArray ( int arr [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } void removePrimes ( int arr [ ] , int len ) { sieve ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( isPrime [ arr [ i ] ] ) { for ( int j = i ; j < len ; j ++ ) { arr [ j ] = arr [ j + 1 ] ; } i -- ; len -- ; } } printArray ( arr , len ) ; } int main ( ) { int arr [ ] = { 4 , 6 , 5 , 3 , 8 , 7 , 10 , 11 , 14 , 15 } ; int len = sizeof ( arr ) / sizeof ( int ) ; removePrimes ( arr , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int x , int y ) { if ( ( x - y ) == 1 ) return false ; return true ; } int main ( ) { int x = 100 , y = 98 ; if ( isPossible ( x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int subgrids ( int N , int Z , int row [ ] , int col [ ] , int r , int c ) { vector < int > conrow ; vector < int > concol ; int K = sqrt ( Z ) ; conrow . push_back ( row [ 0 ] - 0 - 1 ) ; conrow . push_back ( N + 1 - row [ r - 1 ] - 1 ) ; for ( int i = 1 ; i < r ; i ++ ) { conrow . push_back ( row [ i ] - row [ i - 1 ] - 1 ) ; } concol . push_back ( col [ 0 ] - 0 - 1 ) ; concol . push_back ( N + 1 - col - 1 ) ; for ( int i = 1 ; i < c ; i ++ ) { concol . push_back ( col [ i ] - col [ i - 1 ] - 1 ) ; } int row_size = conrow . size ( ) ; int col_size = concol . size ( ) ; int answer = 0 ; for ( int i = 0 ; i < row_size ; i ++ ) { for ( int j = 0 ; j < col_size ; j ++ ) { int total = ( concol [ j ] / K ) * ( conrow [ i ] / K ) ; answer += ( total ) ; } } return answer ; } int main ( ) { int N = 8 , Z = 4 ; int row [ ] = { 4 , 6 } ; int col [ ] = { 3 , 8 } ; int r = sizeof ( row ) / sizeof ( row [ 0 ] ) ; int c = sizeof ( col ) / sizeof ( col [ 0 ] ) ; cout << subgrids ( N , Z , row , col , r , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool digitDividesK ( int num , int k ) { while ( num ) { int d = num % 10 ; if ( d != 0 and k % d == 0 ) return true ; num = num / 10 ; } return false ; } int findCount ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( digitDividesK ( i , k ) ) count ++ ; } return count ; } int main ( ) { int l = 20 , r = 35 ; int k = 45 ; cout << findCount ( l , r , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void perfectSquares ( float l , float r ) { int number = ceil ( sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { cout << n2 << " ▁ " ; n2 = n2 + number ; number += 2 ; } } int main ( ) { int l = 2 , r = 24 ; perfectSquares ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorK ( int n , int k ) { int res = n ; for ( int i = 1 ; i < k ; i ++ ) res = ( res ^ n ) ; return res ; } int main ( ) { int n = 123 , k = 3 ; cout << xorK ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int ll ; void findRemainders ( ll n ) { set < ll > vc ; for ( ll i = 1 ; i <= ceil ( sqrt ( n ) ) ; i ++ ) vc . insert ( n / i ) ; for ( ll i = n / ceil ( sqrt ( n ) ) - 1 ; i >= 0 ; i -- ) vc . insert ( i ) ; for ( auto it : vc ) cout << it << " ▁ " ; } int main ( ) { ll n = 5 ; findRemainders ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100005 ; bool prime [ MAX ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } int countPrimes ( int n ) { SieveOfEratosthenes ( ) ; int cnt = 0 ; for ( int i = 2 ; i < n ; i ++ ) { if ( prime [ i ] && prime [ i - 2 ] ) cnt ++ ; } return cnt ; } int main ( ) { int n = 11 ; cout << countPrimes ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_VALID_YR = 9999 ; const int MIN_VALID_YR = 1800 ; bool isLeap ( int year ) { return ( ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) || ( year % 400 == 0 ) ) ; } bool isValidDate ( int d , int m , int y ) { if ( y > MAX_VALID_YR y < MIN_VALID_YR ) return false ; if ( m < 1 m > 12 ) return false ; if ( d < 1 d > 31 ) return false ; if ( m == 2 ) { if ( isLeap ( y ) ) return ( d <= 29 ) ; else return ( d <= 28 ) ; } if ( m == 4 m == 6 m == 9 m == 11 ) return ( d <= 30 ) ; return true ; } void printPalindromeDates ( int y1 , int y2 ) { for ( int year = y1 ; year <= y2 ; year ++ ) { string str = to_string ( year ) ; string rev = str ; reverse ( rev . begin ( ) , rev . end ( ) ) ; int day = stoi ( rev . substr ( 0 , 2 ) ) ; int month = stoi ( rev . substr ( 2 , 2 ) ) ; if ( isValidDate ( day , month , year ) ) { cout << rev << str << endl ; } } } int main ( ) { int y1 = 2001 , y2 = 2005 ; printPalindromeDates ( y1 , y2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10 ; bool distinctDigits ( int x ) { bool present [ MAX ] = { false } ; while ( x > 0 ) { int digit = x % 10 ; if ( present [ digit ] ) return false ; present [ digit ] = true ; x /= 10 ; } return true ; } int findK ( int l , int r ) { int maxExp = INT_MIN ; int k = -1 ; for ( int i = l ; i <= r ; i ++ ) { if ( distinctDigits ( i ) ) { int exp = ( l - i ) * ( i - r ) ; if ( exp >= maxExp ) { k = i ; maxExp = exp ; } } } return k ; } int main ( ) { int l = 50 , r = 60 ; cout << findK ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPerm ( int Q [ ] , int n ) { int minval = 0 , qsum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { qsum += Q [ i ] ; if ( qsum < minval ) minval = qsum ; } vector < int > P ( n ) ; P [ 0 ] = 1 - minval ; bool permFound = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) { P [ i + 1 ] = P [ i ] + Q [ i ] ; if ( P [ i + 1 ] > n P [ i + 1 ] < 1 ) { permFound = false ; break ; } } if ( permFound ) { for ( int i = 0 ; i < n ; i ++ ) { cout << P [ i ] << " ▁ " ; } } else { cout << -1 ; } } int main ( ) { int Q [ ] = { -2 , 1 } ; int n = 1 + ( sizeof ( Q ) / sizeof ( int ) ) ; findPerm ( Q , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string Hex ( int num ) { map < int , char > m ; char digit = '0' ; char c = ' a ' ; for ( int i = 0 ; i <= 15 ; i ++ ) { if ( i < 10 ) { m [ i ] = digit ++ ; } else { m [ i ] = c ++ ; } } string res = " " ; if ( ! num ) { return "0" ; } if ( num > 0 ) { while ( num ) { res = m [ num % 16 ] + res ; num /= 16 ; } } else { u_int n = num ; while ( n ) { res = m [ n % 16 ] + res ; n /= 16 ; } } return res ; } int main ( ) { int x = 134 , y = -1 , z = -234 ; cout << " Hexa ▁ representation ▁ for " << endl ; cout << x << " ▁ is ▁ " << Hex ( x ) << endl ; cout << y << " ▁ is ▁ " << Hex ( y ) << endl ; cout << z << " ▁ is ▁ " << Hex ( z ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE #define mod  (int)(1e9 + 7) NEW_LINE int factorial [ N ] , modinverse [ N ] ; int power ( int a , int m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( 1LL * a * a ) % mod ; else if ( m1 & 1 ) return ( 1LL * a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; } void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( 1LL * factorial [ i - 1 ] * i ) % mod ; } void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( 1LL * modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; } int binomial ( int n , int r ) { if ( r > n ) return 0 ; int a = ( 1LL * factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( 1LL * a * modinverse [ r ] ) % mod ; return a ; } void arrange_balls ( int n , int k ) { factorialfun ( ) ; modinversefun ( ) ; for ( int i = 1 ; i <= k ; i ++ ) cout << ( 1LL * binomial ( n - k + 1 , i ) * binomial ( k - 1 , i - 1 ) ) % mod << " ▁ " ; } int main ( ) { int n = 5 , k = 3 ; arrange_balls ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_changes ( int a [ ] , int n ) { int ans_a = 0 , ans_b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( a [ i ] == 0 ) ans_a ++ ; else ans_b ++ ; } else { if ( a [ i ] == 0 ) ans_b ++ ; else ans_a ++ ; } } return min ( ans_a , ans_b ) ; } int main ( ) { int a [ ] = { 1 , 0 , 0 , 1 , 0 , 0 , 1 , 0 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << min_changes ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ans ( int n ) { if ( n == 1 ) cout << "1" ; else cout << "0" ; } int main ( ) { int n = 2 ; ans ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isPossible ( int w , int h , int x , int y ) { if ( x * 2 == w && y * 2 == h ) return true ; return false ; } int main ( ) { int w = 1 , h = 2 , x = 1 , y = 2 ; if ( isPossible ( w , h , x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; string minNum ( string num , int k ) { int len = num . length ( ) ; if ( len == 0 k == 0 ) return num ; if ( len == 1 ) return "0" ; if ( num [ 0 ] != '1' ) { num [ 0 ] = '1' ; k -- ; } int i = 1 ; while ( k > 0 && i < len ) { if ( num [ i ] != '0' ) { num [ i ] = '0' ; k -- ; } i ++ ; } return num ; } int main ( ) { string num = "91945" ; int k = 3 ; cout << minNum ( num , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minsteps ( int n , int m ) { if ( m > n ) { return -1 ; } else { return ( ( n + 1 ) / 2 + m - 1 ) / m * m ; } } int main ( ) { int n = 17 , m = 4 ; int ans = minsteps ( n , m ) ; cout << ans << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isFactorial ( int n ) { for ( int i = 1 ; ; i ++ ) { if ( n % i == 0 ) { n /= i ; } else { break ; } } if ( n == 1 ) { return true ; } else { return false ; } } int main ( ) { int n = 24 ; bool ans = isFactorial ( n ) ; if ( ans == 1 ) { cout << " Yes STRNEWLINE " ; } else { cout << " No STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; Node * removeLeadingZeros ( struct Node * a ) { if ( a != NULL && a -> data == 0 ) return removeLeadingZeros ( a -> next ) ; else return a ; } int getSize ( struct Node * a ) { int sz = 0 ; while ( a != NULL ) { a = a -> next ; sz ++ ; } return sz ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int compare ( struct Node * a , struct Node * b ) { a = removeLeadingZeros ( a ) ; b = removeLeadingZeros ( b ) ; int lenA = getSize ( a ) ; int lenB = getSize ( b ) ; if ( lenA > lenB ) { return 1 ; } else if ( lenB > lenA ) { return -1 ; } while ( a != NULL && b != NULL ) { if ( a -> data > b -> data ) return 1 ; else if ( a -> data < b -> data ) return -1 ; a = a -> next ; b = b -> next ; } return 0 ; } int main ( ) { struct Node * a = NULL ; push ( & a , 7 ) ; push ( & a , 6 ) ; push ( & a , 5 ) ; struct Node * b = NULL ; push ( & b , 3 ) ; push ( & b , 3 ) ; push ( & b , 2 ) ; cout << compare ( a , b ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } int sumModArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int subSum = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) { subSum += arr [ j ] ; } arr [ i ] -= subSum ; } return sumArr ( arr , n ) ; } int main ( ) { int arr [ ] = { 40 , 25 , 12 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumModArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minHealth ( int health [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { gcd = __gcd ( gcd , health [ i ] ) ; } return gcd ; } int main ( ) { int health [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n = sizeof ( health ) / sizeof ( int ) ; cout << minHealth ( health , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void constructArr ( int pair [ ] , int n ) { int size = ( 1 + ( int ) sqrt ( 1 + 8 * n ) ) / 2 ; int arr [ size ] ; arr [ 0 ] = sqrt ( ( pair [ 0 ] * pair [ 1 ] ) / pair [ size - 1 ] ) ; for ( int i = 1 ; i < size ; i ++ ) arr [ i ] = pair [ i - 1 ] / arr [ 0 ] ; printArr ( arr , size ) ; } int main ( ) { int pair [ ] = { 48 , 18 , 24 , 24 , 32 , 12 } ; int n = sizeof ( pair ) / sizeof ( int ) ; constructArr ( pair , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int arr [ ] , int n ) { int cntEven = 0 , cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; cout << " Odd ▁ pairs ▁ = ▁ " << oddPairs << endl ; cout << " Even ▁ pairs ▁ = ▁ " << evenPairs ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; findPairs ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } unsigned long int Fuss_catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 3 * n , n ) ; return c / ( 2 * n + 1 ) ; } int main ( ) { for ( int i = 0 ; i < 10 ; i ++ ) cout << Fuss_catalan ( i ) << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 1e5 ; bool isPrime [ sz + 1 ] ; void sieve ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } } int minDifference ( int L , int R ) { int fst = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { fst = i ; break ; } } int snd = 0 ; for ( int i = fst + 1 ; i <= R ; i ++ ) { if ( isPrime [ i ] ) { snd = i ; break ; } } if ( snd == 0 ) return -1 ; int diff = snd - fst ; int left = snd + 1 ; int right = R ; for ( int i = left ; i <= right ; i ++ ) { if ( isPrime [ i ] ) { if ( i - snd <= diff ) { fst = snd ; snd = i ; diff = snd - fst ; } } } return diff ; } int main ( ) { sieve ( ) ; int L = 21 , R = 50 ; cout << minDifference ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubArr ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int curr_gcd = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_gcd = __gcd ( curr_gcd , arr [ j ] ) ; ans += ( curr_gcd == 1 ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntSubArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countElements ( int p [ ] , int n ) { int ans = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( p [ i - 1 ] > p [ i ] and p [ i ] > p [ i + 1 ] ) ans ++ ; else if ( p [ i - 1 ] < p [ i ] and p [ i ] < p [ i + 1 ] ) ans ++ ; } return ans ; } int main ( ) { int p [ ] = { 2 , 5 , 1 , 3 , 4 } ; int n = sizeof ( p ) / sizeof ( p [ 0 ] ) ; cout << countElements ( p , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNums ( int a , int b , int c , int d ) { int x = b / c - ( a - 1 ) / c ; int y = b / d - ( a - 1 ) / d ; int k = ( c * d ) / __gcd ( c , d ) ; int z = b / k - ( a - 1 ) / k ; return b - a + 1 - x - y + z ; } int main ( ) { int a = 10 , b = 50 , c = 4 , d = 6 ; cout << countNums ( a , b , c , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubArrays ( int * arr , int n , int k ) { int res = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; res += max ( j - i - k + 1 , 0 ) ; i = j ; } return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 2 ; cout << cntSubArrays ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLen ( int * arr , int n ) { int min_val = * min_element ( arr , arr + n ) ; int freq = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == min_val ) freq ++ ; } return freq ; } int main ( ) { int arr [ ] = { 1 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxLen ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_primes_till_N ( int N ) { int i , j , flag ; cout << " Prime numbers between 1 and " << N < < " ▁ are : STRNEWLINE " ; for ( i = 1 ; i <= N ; i ++ ) { if ( i == 1 i == 0 ) continue ; flag = 1 ; for ( j = 2 ; j <= i / 2 ; ++ j ) { if ( i % j == 0 ) { flag = 0 ; break ; } } if ( flag == 1 ) cout << i << " ▁ " ; } } int main ( ) { int N = 100 ; print_primes_till_N ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void last_digit ( int X , int Y ) { cout << X % Y ; } int main ( ) { int X = 55 , Y = 3 ; last_digit ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSquares ( int n ) { return ( pow ( n , 2 ) - ( 2 * n ) + 2 ) ; } int main ( ) { int n = 2 ; cout << countSquares ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  32 NEW_LINE int findX ( int A , int B ) { int X = 0 ; for ( int bit = 0 ; bit < MAX ; bit ++ ) { int tempBit = 1 << bit ; int bitOfX = A & B & tempBit ; X += bitOfX ; } return X ; } int main ( ) { int A = 11 , B = 13 ; cout << findX ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntPairs ( int a [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd ++ ; else if ( ( a [ i ] / 2 ) % 2 == 1 ) even ++ ; } int ans = odd * even + ( odd * ( odd - 1 ) ) / 2 ; return ans ; } int main ( ) { int a [ ] = { 4 , 2 , 7 , 11 , 14 , 15 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << cntPairs ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int a [ ] , int n ) { int cur = a [ 0 ] ; cur -- ; for ( int i = 1 ; i < n ; i ++ ) { int nxt = a [ i ] ; if ( nxt > cur ) nxt -- ; else if ( nxt < cur ) return false ; cur = nxt ; } return true ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isPossible ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_element ( int a [ ] , int n ) { int pre [ n ] ; pre [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = max ( pre [ i - 1 ] , a [ i ] ) ; int suf [ n ] ; suf [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = max ( suf [ i + 1 ] , a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) cout << suf [ i + 1 ] << " ▁ " ; else if ( i == n - 1 ) cout << pre [ i - 1 ] << " ▁ " ; else cout << max ( pre [ i - 1 ] , suf [ i + 1 ] ) << " ▁ " ; } } int main ( ) { int a [ ] = { 2 , 5 , 6 , 1 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; max_element ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int a [ ] , int n ) { int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != i + 1 ) k ++ ; } if ( k <= 2 ) return true ; return false ; } int main ( ) { int a [ ] = { 5 , 2 , 3 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isPossible ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int odd_digits ( int n ) { if ( n < 10 ) return n ; else if ( n / 10 < 10 ) return 9 ; else if ( n / 100 < 10 ) return 9 + n - 99 ; else if ( n / 1000 < 10 ) return 9 + 900 ; else if ( n / 10000 < 10 ) return 909 + n - 9999 ; else return 90909 ; } int main ( ) { int n = 893 ; cout << odd_digits ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nDigitPalindromes ( int n ) { return ( 9 * pow ( 10 , ( n - 1 ) / 2 ) ) ; } int main ( ) { int n = 2 ; cout << nDigitPalindromes ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; } int main ( ) { int n = 3 ; cout << maxLCM ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntCells ( int n ) { int cells = pow ( n , 2 ) + pow ( n - 1 , 2 ) ; return cells ; } int main ( ) { int n = 3 ; cout << cntCells ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int n ) { return pow ( n , 3 ) ; } int main ( ) { int n = 3 ; cout << findSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int n ) { string ans = string ( n - 1 , '7' ) ; string even = ans + '6' ; string odd = ans + '7' ; cout << " Even ▁ : ▁ " << even << endl ; cout << " Odd ▁ : ▁ " << odd << endl ; } int main ( ) { int n = 4 ; findNumbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nth_term ( int a , int b , int n ) { int z = 0 ; if ( n % 6 == 1 ) z = a ; else if ( n % 6 == 2 ) z = b ; else if ( n % 6 == 3 ) z = b - a ; else if ( n % 6 == 4 ) z = - a ; else if ( n % 6 == 5 ) z = - b ; if ( n % 6 == 0 ) z = - ( b - a ) ; return z ; } int main ( ) { int a = 10 , b = 17 , n = 3 ; cout << nth_term ( a , b , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool inProportion ( int arr [ ] ) { int n = 4 ; sort ( arr , arr + n ) ; long extremes = ( long ) arr [ 0 ] * ( long ) arr [ 3 ] ; long means = ( long ) arr [ 1 ] * ( long ) arr [ 2 ] ; if ( extremes == means ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 2 } ; if ( inProportion ( arr ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } int countNum ( int n ) { if ( n > 10 ) return 0 ; return ( 9 * factorial ( 9 ) / factorial ( 10 - n ) ) ; } int main ( ) { int n = 3 ; cout << countNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { return int ( ( -1 + sqrt ( 1 + 8 * n ) ) / 2 ) ; } int main ( ) { int n = 10 ; cout << count ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findEquation ( int a , int b ) { int sum = ( a + b ) ; int product = ( a * b ) ; cout << " x ^ 2 ▁ - ▁ ( " << sum << " x ) ▁ + ▁ ( " << product << " ) ▁ = ▁ 0" ; } int main ( ) { int a = 2 , b = 3 ; findEquation ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cal ( int n ) { double res = pow ( ceil ( ( pow ( pow ( 10 , ( n - 1 ) ) , 1 / 4 ) ) ) , 4 ) ; return ( int ) res ; } int main ( ) { int n = 1 ; cout << ( cal ( n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lli  long long int NEW_LINE lli binomialCoeff ( lli n , lli k ) { if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; } lli fact ( lli n ) { if ( n >= 1 ) return n * fact ( n - 1 ) ; else return 1 ; } bool isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) { return true ; } return false ; } lli countWords ( string s , int p , int q ) { lli countc = 0 , countv = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( isVowel ( s [ i ] ) ) countv ++ ; else countc ++ ; } lli a = binomialCoeff ( countc , p ) ; lli b = binomialCoeff ( countv , q ) ; lli c = fact ( p + q ) ; lli ans = ( a * b ) * c ; return ans ; } int main ( ) { string s = " crackathon " ; int p = 4 , q = 3 ; cout << countWords ( s , p , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void generateArr ( int A [ ] , int n ) { int B [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] % A [ i ] == 0 ) cnt ++ ; } B [ i ] = cnt ; } printArr ( B , n ) ; } int main ( ) { int A [ ] = { 3 , 5 , 1 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; generateArr ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNums ( int n ) { if ( n <= 11 ) { if ( n == 8 ) cout << "4 ▁ 4" ; if ( n == 10 ) cout << "4 ▁ 6" ; else cout << " - 1" ; return ; } if ( n % 2 == 0 ) cout << "4 ▁ " << ( n - 4 ) ; else cout << "9 ▁ " << ( n - 9 ) ; } int main ( ) { int n = 13 ; findNums ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { return pow ( 2 , n - 1 ) ; } int main ( ) { int n = 4 ; cout << count ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextFibonacci ( int n ) { double a = n * ( 1 + sqrt ( 5 ) ) / 2.0 ; return round ( a ) ; } int main ( ) { int n = 5 ; cout << nextFibonacci ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int h ) { return pow ( 2 , h - 1 ) ; } int main ( ) { int L = 3 ; cout << sum ( L ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int product ( int a [ ] , int n ) { int ans = 1 ; int val = pow ( 2 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { ans *= pow ( a [ i ] , val ) ; } return ans ; } int main ( ) { int n = 2 ; int a [ ] = { 3 , 7 } ; cout << product ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int oddFib ( int n ) { n = ( 3 * n + 1 ) / 2 ; int a = -1 , b = 1 , c , i ; for ( i = 1 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; } int main ( ) { int n = 4 ; cout << oddFib ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void findPair ( int arr [ ] , int n ) { if ( n < 2 ) { cout << " - 1" ; return ; } int i , first , second ; first = second = -1 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { second = arr [ i ] ; } } cout << " n ▁ = ▁ " << first << " ▁ and ▁ r ▁ = ▁ " << second ; } int main ( ) { int arr [ ] = { 0 , 2 , 3 , 4 , 1 , 6 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPair ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void triangle ( int n ) { int k = 2 * n - 2 ; int ch = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < k ; j ++ ) cout << " ▁ " ; k = k - 1 ; for ( int j = 0 ; j <= i ; j ++ ) { cout << ch ++ << " ▁ " ; } cout << endl ; } } int maxHeight ( int n ) { return ( ( ( int ) sqrt ( 1 + 8.0 * n ) ) - 1 ) / 2 ; } int main ( ) { int N = 9 ; triangle ( maxHeight ( N ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int no_of_ways ( int a [ ] , int n ) { int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) count_0 ++ ; else count_1 ++ ; } if ( count_1 % 2 == 0 ) return count_0 ; else return count_1 ; } int main ( ) { int n = 4 ; int a1 [ 4 ] = { 1 , 1 , 0 , 0 } ; cout << no_of_ways ( a1 , n ) << endl ; n = 5 ; int a2 [ 5 ] = { 1 , 1 , 1 , 0 , 0 } ; cout << no_of_ways ( a2 , n ) << endl ; n = 5 ; int a3 [ 5 ] = { 1 , 1 , 0 , 0 , 0 } ; cout << no_of_ways ( a3 , n ) << endl ; n = 6 ; int a4 [ 6 ] = { 1 , 1 , 1 , 0 , 0 , 0 } ; cout << no_of_ways ( a4 , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string maxInt ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] < '5' ) { str [ i ] = ( '9' - str [ i ] ) + '0' ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '9' ; return str ; } int main ( ) { string str = "42" ; cout << maxInt ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void FindRatio ( int a , int b , int c ) { int up = abs ( b - c ) ; int down = abs ( c - a ) ; int g = __gcd ( up , down ) ; up /= g ; down /= g ; cout << up << " : " << down << " STRNEWLINE " ; } int main ( ) { int a = 4 , b = 10 , c = 6 ; FindRatio ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longest_gap ( int N ) { int distance = 0 , count = 0 , first_1 = -1 , last_1 = -1 ; while ( N ) { count ++ ; int r = N & 1 ; if ( r == 1 ) { first_1 = first_1 == -1 ? count : first_1 ; last_1 = count ; } N = N / 2 ; } if ( last_1 <= first_1 ) { return -1 ; } else { distance = ( last_1 - first_1 - 1 ) ; return distance ; } } int main ( ) { int N = 131 ; cout << longest_gap ( N ) << endl ; N = 8 ; cout << longest_gap ( N ) << endl ; N = 17 ; cout << longest_gap ( N ) << endl ; N = 33 ; cout << longest_gap ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int x , int y , int k ) { int minMoves = abs ( x ) + abs ( y ) ; if ( k >= minMoves && ( k - minMoves ) % 2 == 0 ) return true ; return false ; } int main ( ) { int x = 5 , y = 8 , k = 20 ; if ( isPossible ( x , y , k ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int TOTAL_BITS = 32 ; bool isPossible ( int n ) { int cnt = __builtin_popcount ( n ) ; if ( cnt == TOTAL_BITS / 2 ) return true ; return false ; } int main ( ) { int n = 524280 ; if ( isPossible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int TEN = 10 ; void updateFreq ( int n , int freq [ ] ) { while ( n ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } } bool areAnagrams ( int a , int b ) { int freqA [ TEN ] = { 0 } ; int freqB [ TEN ] = { 0 } ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; } int main ( ) { int a = 240 , b = 204 ; if ( areAnagrams ( a , b ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int days [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int dayOfYear ( string date ) { int year = stoi ( date . substr ( 0 , 4 ) ) ; int month = stoi ( date . substr ( 5 , 2 ) ) ; int day = stoi ( date . substr ( 8 ) ) ; if ( month > 2 && year % 4 == 0 && ( year % 100 != 0 year % 400 == 0 ) ) { ++ day ; } while ( month -- > 0 ) { day = day + days [ month - 1 ] ; } return day ; } int main ( ) { string date = "2019-01-09" ; cout << dayOfYear ( date ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Max_Sum ( int n ) { return ( n * ( n - 1 ) ) / 2 ; } int main ( ) { int n = 8 ; cout << Max_Sum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isDivisible ( int arr [ ] , int n ) { int lastDigit = arr [ n - 1 ] % 10 ; if ( lastDigit == 0 ) return true ; return false ; } int main ( ) { int arr [ ] = { 12 , 65 , 46 , 37 , 99 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isDivisible ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } long divTermCount ( long a , long b , long c , long num ) { return ( ( num / a ) + ( num / b ) + ( num / c ) - ( num / ( ( a * b ) / gcd ( a , b ) ) ) - ( num / ( ( c * b ) / gcd ( c , b ) ) ) - ( num / ( ( a * c ) / gcd ( a , c ) ) ) + ( num / ( ( a * b * c ) / gcd ( gcd ( a , b ) , c ) ) ) ) ; } int main ( ) { long a = 7 , b = 3 , c = 5 , n = 100 ; cout << divTermCount ( a , b , c , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < long > getArray ( int n ) { vector < long > ans ; long p2 = 1 ; while ( n > 0 ) { if ( n & 1 ) ans . push_back ( p2 ) ; n >>= 1 ; p2 *= 2 ; } return ans ; } int main ( ) { long n = 15 ; vector < long > ans = getArray ( n ) ; for ( int i : ans ) cout << i << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 3 , N = 2 ; void getIndex ( int n , int shuffle [ ] [ N ] ) { for ( int i = 0 ; i < 3 ; i ++ ) { if ( shuffle [ i ] [ 0 ] == n ) n = shuffle [ i ] [ 1 ] ; else if ( shuffle [ i ] [ 1 ] == n ) n = shuffle [ i ] [ 0 ] ; } cout << n ; } int main ( ) { int n = 3 ; int shuffle [ M ] [ N ] = { { 3 , 1 } , { 2 , 1 } , { 1 , 2 } } ; getIndex ( n , shuffle ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; long long power ( int p ) { long long res = 1 ; for ( int i = 1 ; i <= p ; ++ i ) { res *= 2 ; res %= mod ; } return res % mod ; } long long subset_square_sum ( vector < int > & A ) { int n = ( int ) A . size ( ) ; long long ans = 0 ; for ( int i : A ) { ans += ( 1LL * i * i ) % mod ; ans %= mod ; } return ( 1LL * ans * power ( n - 1 ) ) % mod ; } int main ( ) { vector < int > A = { 3 , 7 } ; cout << subset_square_sum ( A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long fact ( int n ) { long long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } long long nCr ( int n , int r ) { return fact ( n ) / ( 1LL * fact ( r ) * fact ( n - r ) ) ; } long long number_of_subsequences ( int arr [ ] , int k , int n ) { long long s = 0 ; map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { m [ arr [ i ] ] ++ ; } for ( auto j : m ) { s = s + 1LL * nCr ( j . second , k ) ; } return s ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 1 , 2 , 2 , 2 } ; int k = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << number_of_subsequences ( arr , k , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long countTriplets ( int A , int B , int C ) { long long ans = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { for ( int j = 1 ; j <= B ; j ++ ) { for ( int k = 1 ; k <= C ; k ++ ) { if ( i * k > j * j ) ans ++ ; } } } return ans ; } int main ( ) { int A , B , C ; A = 3 , B = 2 , C = 2 ; cout << countTriplets ( A , B , C ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int getSum ( int n ) { long long int sum = 0 ; int k = sqrt ( n ) ; for ( int i = 1 ; i <= k ; i ++ ) { sum += floor ( n / i ) ; } sum *= 2 ; sum -= pow ( k , 2 ) ; return sum ; } int main ( ) { int n = 5 ; cout << getSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinctRemainders ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) ; return ( 1 + ( n / 2 ) ) ; } int main ( ) { int n = 5 ; cout << distinctRemainders ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100050 NEW_LINE int lpf [ N ] , mobius [ N ] ; void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( ! lpf [ i ] ) for ( int j = i ; j < N ; j += i ) if ( ! lpf [ j ] ) lpf [ j ] = i ; } void Mobius ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = -1 * mobius [ i / lpf [ i ] ] ; } } } int gcd_pairs ( int a [ ] , int n ) { int maxi = 0 ; int fre [ N ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { fre [ a [ i ] ] ++ ; maxi = max ( a [ i ] , maxi ) ; } least_prime_factor ( ) ; Mobius ( ) ; int ans = 0 ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( ! mobius [ i ] ) continue ; int temp = 0 ; for ( int j = i ; j <= maxi ; j += i ) temp += fre [ j ] ; ans += temp * ( temp - 1 ) / 2 * mobius [ i ] ; } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << gcd_pairs ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool graphExists ( vector < int > & a , int n ) { while ( 1 ) { sort ( a . begin ( ) , a . end ( ) , greater < > ( ) ) ; if ( a [ 0 ] == 0 ) return true ; int v = a [ 0 ] ; a . erase ( a . begin ( ) + 0 ) ; if ( v > a . size ( ) ) return false ; for ( int i = 0 ; i < v ; i ++ ) { a [ i ] -- ; if ( a [ i ] < 0 ) return false ; } } } int main ( ) { vector < int > a = { 3 , 3 , 3 , 3 } ; int n = a . size ( ) ; graphExists ( a , n ) ? cout << " Yes " : cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int negProdSubArr ( int arr [ ] , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = -1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; } int main ( ) { int arr [ ] = { 5 , -4 , -3 , 2 , -5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << negProdSubArr ( arr , n ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int difference ( int n ) { int S , res ; S = ( n * ( n + 1 ) ) / 2 ; res = S * ( S - 1 ) ; return res ; } int main ( ) { int n = 5 ; cout << difference ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE int lpf [ N ] ; void least_prime_factor ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( ! lpf [ i ] ) for ( int j = i ; j < N ; j += i ) if ( ! lpf [ j ] ) lpf [ j ] = i ; } void Mobius ( int n ) { int mobius [ N ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( i == 1 ) mobius [ i ] = 1 ; else { if ( lpf [ i / lpf [ i ] ] == lpf [ i ] ) mobius [ i ] = 0 ; else mobius [ i ] = -1 * mobius [ i / lpf [ i ] ] ; } } for ( int i = 1 ; i <= n ; i ++ ) cout << mobius [ i ] << " ▁ " ; } int main ( ) { int n = 5 ; least_prime_factor ( ) ; Mobius ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int DIGITS = 4 , MIN = 1000 , MAX = 9999 ; int getBest ( int prev , int cur ) { int maximum = max ( MIN , prev ) ; for ( int i = maximum ; i <= MAX ; i ++ ) { int cnt = 0 ; int a = i ; int b = cur ; for ( int k = 0 ; k < DIGITS ; k ++ ) { if ( a % 10 != b % 10 ) cnt += 1 ; a /= 10 ; b /= 10 ; } if ( cnt <= 1 ) return i ; } return -1 ; } void getList ( int arr [ ] , int n ) { vector < int > myList ; int i , cur ; bool possible = true ; myList . push_back ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { cur = arr [ i ] ; myList . push_back ( getBest ( myList . back ( ) , cur ) ) ; if ( myList . back ( ) == -1 ) { possible = false ; break ; } } if ( possible ) { for ( i = 1 ; i < myList . size ( ) ; i ++ ) cout << myList [ i ] << " ▁ " ; } else cout << " - 1" ; } int main ( ) { int arr [ ] = { 1095 , 1094 , 1095 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getList ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countFactors ( int n , int p ) { int pwr = 0 ; while ( n > 0 && n % p == 0 ) { n /= p ; pwr ++ ; } return pwr ; } int getCount ( int l , int r , int p ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { cnt += countFactors ( i , p ) ; } return cnt ; } int main ( ) { int l = 2 , r = 8 , p = 2 ; cout << getCount ( l , r , p ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int getCount ( int l , int r , int p ) { int cnt = 0 ; int val = p ; while ( 1 ) { int a = r / val ; int b = ( l - 1 ) / val ; val *= p ; if ( a - b ) { cnt += ( a - b ) ; } else break ; } return cnt ; } int main ( ) { int l = 2 , r = 8 , p = 2 ; cout << getCount ( l , r , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool topsyTurvy ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '2' str [ i ] == '4' str [ i ] == '5' str [ i ] == '6' str [ i ] == '7' str [ i ] == '9' ) { return false ; } } return true ; } int main ( ) { string str = "1234" ; if ( topsyTurvy ( str ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubSeq ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { count ++ ; } } return ( pow ( 2 , count ) - 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << countSubSeq ( arr , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX  1000001 NEW_LINE int countNum ( int N , int K ) { int sumPF [ MAX ] = { 0 } ; for ( int i = 2 ; i < N ; i ++ ) { if ( sumPF [ i ] == 0 ) { for ( int j = i ; j < N ; j += i ) { sumPF [ j ] += i ; } } } int count = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( sumPF [ i ] == K ) count ++ ; } return count ; } int main ( ) { int N = 20 , K = 7 ; cout << countNum ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMatrix ( int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) cout << k << " ▁ " ; else cout << "0 ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 3 , k = 7 ; printMatrix ( n , k ) ; return ( 0 ) ; }
#include <iostream> NEW_LINE using namespace std ; int findNthNumber ( int A , int B , int N ) { int sum = 0 ; for ( int i = 2 ; i < N ; i ++ ) { sum = A + B ; A = B ; B = sum ; } return sum ; } int main ( ) { int A = 5 , B = 7 , N = 10 ; cout << findNthNumber ( A , B , N ) ; return 0 ; }
#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void cal_IST ( int h , float r ) { float IST = ( h * r * 1.0 ) / 360 ; int int_IST = ( int ) IST ; int float_IST = ceil ( ( IST - int_IST ) * 60 ) ; cout << int_IST << " : " << float_IST ; } int main ( ) { int h = 20 ; float r = 150 ; cal_IST ( h , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int arr [ ] , int p , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) sum += arr [ i ] ; if ( sum == ( n * m ) ) return true ; return false ; } int main ( ) { int n = 3 , m = 4 ; int arr [ ] = { 6 , 3 , 2 , 1 } ; int p = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isPossible ( arr , p , n , m ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinStep ( int a [ ] , int n ) { int positive = 0 , negative = 0 , zero = 0 ; int step = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { zero ++ ; } else if ( a [ i ] < 0 ) { negative ++ ; step = step + ( -1 - a [ i ] ) ; } else { positive ++ ; step = step + ( a [ i ] - 1 ) ; } } if ( negative % 2 == 0 ) { step = step + zero ; } else { if ( zero > 0 ) { step = step + zero ; } else { step = step + 2 ; } } return step ; } int main ( ) { int a [ ] = { 0 , -2 , -1 , -3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinStep ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int n ) { int sum = 0 ; while ( n ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } void firstN ( int n ) { int num = 19 , cnt = 1 ; while ( cnt != n ) { if ( sum ( num ) == 10 ) { cout << num << " ▁ " ; cnt ++ ; } num += 9 ; } } int main ( ) { int n = 10 ; firstN ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define long  long long NEW_LINE long sumOfLastDig ( long n , long m ) { long sum = 0 , k ; k = n / m ; long arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { arr [ i ] = m * ( i + 1 ) % 10 ; sum += arr [ i ] ; } long rem = k % 10 ; long ans = ( k / 10 ) * sum ; for ( int i = 0 ; i < rem ; i ++ ) { ans += arr [ i ] ; } return ans ; } int main ( ) { long n = 100 , m = 3 ; cout << sumOfLastDig ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void compareVal ( int x , int y ) { long double a = y * log ( x ) ; long double b = x * log ( y ) ; if ( a > b ) cout << x << " ^ " << y << " ▁ > ▁ " << y << " ^ " << x ; else if ( a < b ) cout << x << " ^ " << y << " ▁ < ▁ " << y << " ^ " << x ; else if ( a == b ) cout << x << " ^ " << y << " ▁ = ▁ " << y << " ^ " << x ; } int main ( ) { long double x = 4 , y = 5 ; compareVal ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int nextPrime ( int N ) { if ( N <= 1 ) return 2 ; int prime = N ; bool found = false ; while ( ! found ) { prime ++ ; if ( isPrime ( prime ) ) found = true ; } return prime ; } int main ( ) { int N = 3 ; cout << nextPrime ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool Survives ( int n ) { int i ; for ( int i = 2 ; ; i ++ ) { if ( i > n ) return true ; if ( n % i == 0 ) return false ; n -= n / i ; } } int main ( ) { int n = 17 ; if ( Survives ( n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthXorFib ( int n , int a , int b ) { if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return ( a ^ b ) ; return nthXorFib ( n % 3 , a , b ) ; } int main ( ) { int a = 1 , b = 2 , n = 10 ; cout << nthXorFib ( n , a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void flip ( int a , int b ) { int lcm = ( a * b ) / gcd ( a , b ) ; a = lcm / a ; b = lcm / b ; cout << a - 1 << " ▁ " << b - 1 ; } int main ( ) { int a = 10 ; int b = 5 ; flip ( a , b ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_Solution ( double x , int n ) { double sum = x , e = 2 , o = 1 , p = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { p += 2 ; sum += ( double ) ( o / e ) * ( double ) ( pow ( x , p ) / p ) ; o = o * ( o + 2 ) ; e = e * ( e + 2 ) ; } cout << setprecision ( 10 ) << sum ; } int main ( ) { double x = -0.5 ; if ( abs ( x ) >= 1 ) { cout << " Invalid ▁ Input STRNEWLINE " ; return 0 ; } int n = 8 ; find_Solution ( x , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalPay ( int totalItems , int priceOfOneItem , int N , int M ) { int freeItems = 0 , actual = 0 ; freeItems = totalItems / ( N + M ) ; actual = totalItems - freeItems ; int amount = actual * priceOfOneItem ; return amount ; } int main ( ) { int T = 12 , P = 8 ; int N = 2 , M = 1 ; cout << " Amount ▁ = ▁ " << totalPay ( T , P , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define p  1000000007 NEW_LINE long long power ( long long x , long long y ) { long long res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res % p ; } int main ( ) { long long n = 3 ; long long x = ( power ( 3 , n ) % p + 1 ) % p ; x = ( x - power ( 2 , n + 1 ) + p ) % p ; x = ( x * power ( 2 , p - 2 ) ) % p ; cout << x << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int rightmostNonZero ( int a [ ] , int n ) { int c5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] > 0 && a [ i ] % 5 == 0 ) { a [ i ] /= 5 ; c5 ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { while ( c5 && a [ i ] > 0 && ! ( a [ i ] & 1 ) ) { a [ i ] >>= 1 ; c5 -- ; } } long long ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans = ( ans * a [ i ] % 10 ) % 10 ; } if ( c5 ) ans = ( ans * 5 ) % 10 ; if ( ans ) return ans ; return -1 ; } int main ( ) { int a [ ] = { 7 , 42 , 11 , 64 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << rightmostNonZero ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRemainder ( int n ) { int l = n % 10 ; while ( n >= 10 ) n /= 10 ; int f = n ; int remainder = f % l ; cout << remainder << endl ; } int main ( ) { int n = 5223 ; findRemainder ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double increaseInVol ( double l , double b , double h ) { double percentInc = ( 1 + ( l / 100 ) ) * ( 1 + ( b / 100 ) ) * ( 1 + ( h / 100 ) ) ; percentInc -= 1 ; percentInc *= 100 ; return percentInc ; } int main ( ) { double l = 50 , b = 20 , h = 10 ; cout << increaseInVol ( l , b , h ) << " % " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; long long int countOccurrances ( long long int n , int d ) { long long int count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = n / 10 ; } return count ; } int main ( ) { int d = 2 ; long long int n = 214215421 ; cout << countOccurrances ( n , d ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findFactors ( int a , int b ) { int c ; c = a + b - 1 ; cout << c ; } int main ( ) { int a , b ; a = 13 ; b = 36 ; findFactors ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void TwentyoneMatchstick ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i += 1 ) { cout << 5 - arr [ i ] << " ▁ " ; } cout << endl ; } int main ( ) { int arr [ ] = { 3 , 4 , 2 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; TwentyoneMatchstick ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void expressDigit ( int arr [ ] , int n ) { int min = 9 , index = 0 , temp = 0 ; temp = arr [ 0 ] ; for ( int i = 1 ; i < 10 ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; index = i ; } } if ( temp < min ) { cout << 1 ; for ( int i = 1 ; i <= temp + 1 ; i ++ ) cout << 0 ; } else { for ( int i = 0 ; i < min ; i ++ ) cout << index ; cout << index ; } } int main ( ) { int arr [ ] = { 2 , 2 , 1 , 2 , 1 , 1 , 3 , 1 , 1 , 1 } ; int N = 10 ; expressDigit ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigits ( int num ) { int cnt = 0 ; while ( num > 0 ) { cnt ++ ; num /= 10 ; } return cnt ; } int sumFromStart ( int num , int n , int rem ) { num /= ( ( int ) pow ( 10 , rem ) ) ; int sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; } int sumFromEnd ( int num , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; } float getAverage ( int n , int k , int l ) { int totalDigits = countDigits ( n ) ; if ( totalDigits < ( k + l ) ) return -1 ; int sum1 = sumFromEnd ( n , l ) ; int sum2 = sumFromStart ( n , k , totalDigits - k ) ; return ( ( float ) ( sum1 + sum2 ) / ( float ) ( k + l ) ) ; } int main ( ) { int n = 123456 , k = 2 , l = 3 ; cout << getAverage ( n , k , l ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Wythoff ( map < int , map < int , int > > & mp , int n , int k ) { double tau = ( sqrt ( 5 ) + 1 ) / 2.0 , t_n_k ; if ( mp [ n ] [ k ] != 0 ) return mp [ n ] [ k ] ; if ( k == -1 ) { return n - 1 ; } else if ( k == 0 ) { t_n_k = floor ( n * tau ) ; } else { t_n_k = Wythoff ( mp , n , k - 1 ) + Wythoff ( mp , n , k - 2 ) ; } mp [ n ] [ k ] = t_n_k ; return ( int ) t_n_k ; } void Wythoff_Array ( int n ) { int i = 0 , j = 0 , count = 0 ; map < int , map < int , int > > mp ; while ( count < n ) { cout << Wythoff ( mp , i + 1 , j + 1 ) ; count ++ ; if ( count != n ) cout << " , ▁ " ; i ++ ; j -- ; if ( j < 0 ) { j = i ; i = 0 ; } } } int main ( ) { int n = 15 ; Wythoff_Array ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_Prime ( int n ) { if ( n < 2 ) return false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) if ( n % i == 0 ) return false ; return true ; } void set_primes ( map < int , map < int , int > > & mp , map < int , map < int , int > > & hash , int c ) { int count = 0 ; for ( int i = 2 ; count < c ; i ++ ) { if ( is_Prime ( i ) ) { mp [ 0 ] [ count ++ ] = i ; hash [ 0 ] [ count - 1 ] = 1 ; } } } int Gilbreath ( map < int , map < int , int > > & mp , map < int , map < int , int > > & hash , int n , int k ) { if ( hash [ n ] [ k ] != 0 ) return mp [ n ] [ k ] ; int ans = abs ( Gilbreath ( mp , hash , n - 1 , k + 1 ) - Gilbreath ( mp , hash , n - 1 , k ) ) ; mp [ n ] [ k ] = ans ; return ans ; } void solve ( int n ) { int i = 0 , j = 0 , count = 0 ; map < int , map < int , int > > mp , hash ; set_primes ( mp , hash , 100 ) ; while ( count < n ) { cout << Gilbreath ( mp , hash , i , j ) << " , ▁ " ; count ++ ; i -- ; j ++ ; if ( i < 0 ) { i = j ; j = 0 ; } } } int main ( ) { int n = 15 ; solve ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int longestAlternativeSequence ( int a [ ] , int n ) { int maxi1 = 0 ; int f1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! f1 ) { if ( a [ i ] % 2 ) { f1 = 1 ; maxi1 ++ ; } } else { if ( a [ i ] % 2 == 0 ) { maxi1 ++ ; f1 = 0 ; } } } int maxi2 = 0 ; int f2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( f2 ) { if ( a [ i ] % 2 ) { f2 = 1 ; maxi2 ++ ; } } else { if ( a [ i ] % 2 == 0 ) { maxi2 ++ ; f2 = 0 ; } } } return max ( maxi1 , maxi2 ) ; } int main ( ) { int a [ ] = { 13 , 16 , 8 , 9 , 32 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << longestAlternativeSequence ( a , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cells ( int n , int x ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( x % i == 0 && x / i <= n ) ans ++ ; return ans ; } int main ( ) { int n = 6 , x = 12 ; cout << Cells ( n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ZigZag ( int n ) { long long fact [ n + 1 ] , zig [ n + 1 ] = { 0 } ; fact [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; zig [ 0 ] = 1 ; zig [ 1 ] = 1 ; cout << " zig ▁ zag ▁ numbers : ▁ " ; cout << zig [ 0 ] << " ▁ " << zig [ 1 ] << " ▁ " ; for ( int i = 2 ; i < n ; i ++ ) { long long sum = 0 ; for ( int k = 0 ; k <= i - 1 ; k ++ ) { sum += ( fact [ i - 1 ] / ( fact [ i - 1 - k ] * fact [ k ] ) ) * zig [ k ] * zig [ i - 1 - k ] ; } zig [ i ] = sum / 2 ; cout << sum / 2 << " ▁ " ; } } int main ( ) { int n = 10 ; ZigZag ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string numbiarNumber ( string str , int i ) { if ( i > str . length ( ) ) return " " ; int firstDigit = str [ i ] - '0' ; int digitParity = firstDigit % 2 ; int sumDigits = 0 ; while ( i < str . length ( ) ) { sumDigits += ( str [ i ] - '0' ) ; int sumParity = sumDigits % 2 ; if ( digitParity != sumParity ) break ; i ++ ; } return ( to_string ( sumDigits ) + numbiarNumber ( str , i + 1 ) ) ; } int main ( ) { string str = "9880127431" ; cout << numbiarNumber ( str , 0 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Depreciation ( float v , float r , float t ) { float D = v * pow ( ( 1 - r / 100 ) , t ) ; return D ; } int main ( ) { float V1 = 200 , R = 10 , T = 2 ; cout << Depreciation ( V1 , R , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextPowerOfFour ( int n ) { int x = floor ( sqrt ( sqrt ( n ) ) ) ; if ( pow ( x , 4 ) == n ) return n ; else { x = x + 1 ; return pow ( x , 4 ) ; } } int main ( ) { int n = 122 ; cout << nextPowerOfFour ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int phi ( int n ) { for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result -= result / p ; } } if ( n > 1 ) result -= result / n ; return result ; } void Highly_Totient ( int n ) { int count = 0 , p_count = -1 , i = 1 ; map < int , int > mp ; for ( int i = 1 ; i < 100000 ; i ++ ) mp [ phi ( i ) ] ++ ; while ( count < n ) { if ( mp [ i ] > p_count ) { cout << i ; if ( count < n - 1 ) cout << " , ▁ " ; p_count = mp [ i ] ; count ++ ; } i ++ ; } } int main ( ) { int n = 20 ; Highly_Totient ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_count ( vector < int > ele ) { int count = 0 ; for ( int i = 0 ; i < ele . size ( ) ; i ++ ) { vector < int > p ; int c = 0 ; for ( int j = ele . size ( ) - 1 ; j >= ( ele . size ( ) - 1 - i ) && j >= 0 ; j -- ) p . push_back ( ele [ j ] ) ; int j = ele . size ( ) - 1 , k = 0 ; while ( j >= 0 ) { if ( ele [ j ] != p [ k ] ) break ; j -- ; k ++ ; if ( k == p . size ( ) ) { c ++ ; k = 0 ; } } count = max ( count , c ) ; } return count ; } void solve ( int n ) { int count = 1 ; vector < int > ele ; for ( int i = 0 ; i < n ; i ++ ) { cout << count << " , ▁ " ; ele . push_back ( count ) ; count = find_count ( ele ) ; } } int main ( ) { int n = 10 ; solve ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float speedOfTrain ( float X , float Y ) { float Speed = 0 ; Speed = 1188 * ( ( X - Y ) / Y ) ; return Speed ; } int main ( ) { float X = 8 , Y = 7.2 ; cout << speedOfTrain ( X , Y ) << " ▁ km / hr " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Division ( int a [ ] , int n ) { int maxi = INT_MIN , mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { maxi = max ( a [ i ] , maxi ) ; mini = min ( a [ i ] , mini ) ; } return maxi / mini ; } int main ( ) { int a [ ] = { 3 , 7 , 9 , 3 , 11 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Division ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE vector < int > addPrimes ( ) { int n = MAX ; bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } vector < int > ans ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) ans . push_back ( p ) ; return ans ; } int pi ( int x , vector < int > v ) { int l = 0 , r = v . size ( ) - 1 , m , in = -1 ; while ( l <= r ) { m = ( l + r ) / 2 ; if ( v [ m ] <= x ) { in = m ; l = m + 1 ; } else { r = m - 1 ; } } return in + 1 ; } int Ramanujan ( int n , vector < int > v ) { int upperbound = 4 * n * ( log ( 4 * n ) / log ( 2 ) ) ; for ( int i = upperbound ; ; i -- ) { if ( pi ( i , v ) - pi ( i / 2 , v ) < n ) return 1 + i ; } } void Ramanujan_Numbers ( int n ) { int c = 1 ; vector < int > v = addPrimes ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { cout << Ramanujan ( i , v ) ; if ( i != n ) cout << " , ▁ " ; } } int main ( ) { int n = 10 ; Ramanujan_Numbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 130 ; bool validQuadruple ( int arr [ ] , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; } int main ( ) { int arr [ ] = { 1 , 0 , 2 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( validQuadruple ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } int NumberOfWays ( int X , int Y , int M , int N ) { return fact ( X + Y ) * nCr ( M , X ) * nCr ( N , Y ) ; } int main ( ) { int X = 2 , Y = 2 , M = 3 , N = 3 ; cout << NumberOfWays ( X , Y , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > store ; int Wedderburn ( int n ) { if ( n <= 2 ) return store [ n ] ; else if ( n % 2 == 0 ) { int x = n / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } ans += ( store [ x ] * ( store [ x ] + 1 ) ) / 2 ; store [ n ] = ans ; return ans ; } else { int x = ( n + 1 ) / 2 , ans = 0 ; for ( int i = 1 ; i < x ; i ++ ) { ans += store [ i ] * store [ n - i ] ; } store [ n ] = ans ; return ans ; } } void Wedderburn_Etherington ( int n ) { store [ 0 ] = 0 ; store [ 1 ] = 1 ; store [ 2 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { cout << Wedderburn ( i ) ; if ( i != n - 1 ) cout << " , ▁ " ; } } int main ( ) { int n = 10 ; Wedderburn_Etherington ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int i = 1 , fac = 1 ; for ( i = 1 ; i <= n ; i ++ ) fac = fac * i ; return fac ; } double log_Expansion ( double x , int n ) { double sum = 0 ; int i = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum = sum + pow ( x , 2 * i ) / fact ( 2 * i ) ; } return sum ; } int main ( ) { double x = 1 ; int n = 10 ; cout << setprecision ( 12 ) << log_Expansion ( x , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countElements ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; float mean = ( float ) sum / n ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float newMean = ( float ) ( sum - arr [ i ] ) / ( n - 1 ) ; if ( newMean == mean ) cnt ++ ; } return cnt ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE #define MAX_ELEMENT  50 NEW_LINE int dp [ MAX_ELEMENT ] [ MAX_ELEMENT ] [ MAX ] ; int Max_Xor ( int arr [ ] , int i , int j , int mask , int n ) { if ( i >= n ) { if ( j == 0 ) return mask ; else return 0 ; } if ( dp [ i ] [ j ] [ mask ] != -1 ) return dp [ i ] [ j ] [ mask ] ; int ans = 0 ; if ( j > 0 ) ans = Max_Xor ( arr , i + 1 , j - 1 , mask ^ arr [ i ] , n ) ; ans = max ( ans , Max_Xor ( arr , i + 1 , j , mask , n ) ) ; return dp [ i ] [ j ] [ mask ] = ans ; } int main ( ) { int arr [ ] = { 2 , 5 , 4 , 1 , 3 , 7 , 6 , 8 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 3 ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << Max_Xor ( arr , 0 , k , 0 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool Prime ( int n ) { for ( int j = 2 ; j <= sqrt ( n ) ; j ++ ) if ( n % j == 0 ) return false ; return true ; } int find_prime ( int x , int xsqmodp , int y , int ysqmodp ) { int n = x * x - xsqmodp ; int n1 = y * y - ysqmodp ; for ( int j = 2 ; j <= max ( sqrt ( n ) , sqrt ( n1 ) ) ; j ++ ) { if ( n % j == 0 && ( x * x ) % j == xsqmodp && n1 % j == 0 && ( y * y ) % j == ysqmodp ) if ( Prime ( j ) ) return j ; int j1 = n / j ; if ( n % j1 == 0 && ( x * x ) % j1 == xsqmodp && n1 % j1 == 0 && ( y * y ) % j1 == ysqmodp ) if ( Prime ( j1 ) ) return j1 ; j1 = n1 / j ; if ( n % j1 == 0 && ( x * x ) % j1 == xsqmodp && n1 % j1 == 0 && ( y * y ) % j1 == ysqmodp ) if ( Prime ( j1 ) ) return j1 ; } if ( n == n1 ) return n ; } int main ( ) { int x = 3 , xsqmodp = 0 , y = 5 , ysqmodp = 1 ; cout << find_prime ( x , xsqmodp , y , ysqmodp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfMinutes ( int S , int S1 ) { int Min = 0 ; Min = ( ( S - S1 ) / floor ( S ) ) * 60 ; return Min ; } int main ( ) { int S = 30 , S1 = 10 ; cout << numberOfMinutes ( S , S1 ) << " ▁ min " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fac ( int num ) { if ( num == 0 ) return 1 ; int fact = 1 ; for ( int i = 1 ; i <= num ; i ++ ) fact = fact * i ; return fact ; } void Tanx_expansion ( int terms , int x ) { double sum = 0 ; for ( int i = 1 ; i <= terms ; i += 1 ) { double B = 0 ; int Bn = 2 * i ; for ( int k = 0 ; k <= Bn ; k ++ ) { double temp = 0 ; for ( int r = 0 ; r <= k ; r ++ ) temp = temp + pow ( -1 , r ) * fac ( k ) * pow ( r , Bn ) / ( fac ( r ) * fac ( k - r ) ) ; B = B + temp / ( ( double ) ( k + 1 ) ) ; } sum = sum + pow ( -4 , i ) * ( 1 - pow ( 4 , i ) ) * B * pow ( x , 2 * i - 1 ) / fac ( 2 * i ) ; } cout << setprecision ( 10 ) << sum ; } int main ( ) { int n = 6 , x = 1 ; Tanx_expansion ( n , x ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int minimum_elements ( int n , int arr [ ] ) { if ( n < 3 ) return 0 ; int g , ans = 0 , diff , cnt ; diff = arr [ 1 ] - arr [ 0 ] ; g = diff ; for ( int i = 2 ; i < n ; i ++ ) { diff = arr [ i ] - arr [ i - 1 ] ; g = gcd ( g , diff ) ; } for ( int i = 1 ; i < n ; i ++ ) { diff = arr [ i ] - arr [ i - 1 ] ; cnt = diff / g ; ans += ( cnt - 1 ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 10 , 12 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimum_elements ( n , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int x , int y , int p , int q ) { if ( y % x != 0 ) return -1 ; int d = y / x ; int a = 0 ; while ( d % p == 0 ) { d /= p ; a ++ ; } int b = 0 ; while ( d % q == 0 ) { d /= q ; b ++ ; } if ( d != 1 ) return -1 ; return ( a + b ) ; } int main ( ) { int x = 12 , y = 2592 , p = 2 , q = 3 ; cout << minOperations ( x , y , p , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkcomposite ( int n ) { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return 1 ; } return 0 ; } int power ( int x , int y , int mod ) { int res = 1 ; while ( y ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } bool Check ( int n , int a ) { if ( a > 1 && checkcomposite ( n ) && power ( a , n - 1 , n ) == 1 ) return 1 ; return 0 ; } int main ( ) { int N = 645 ; int a = 2 ; cout << Check ( N , a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Digits ( int n ) { int largest = 0 ; int smallest = 9 ; while ( n ) { int r = n % 10 ; largest = max ( r , largest ) ; smallest = min ( r , smallest ) ; n = n / 10 ; } cout << largest << " ▁ " << smallest ; } int main ( ) { int n = 2346 ; Digits ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; } int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } float Probability ( int M , int N , int X ) { return ( float ) ( nCr ( M - N - 1 , X - 2 ) / ( nCr ( M - 1 , X - 1 ) * 1.0 ) ) ; } int main ( ) { int M = 9 , X = 3 , N = 4 ; cout << Probability ( M , N , X ) ; return 0 ; }
#include <math.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int fact ( int n ) { if ( n <= 1 ) return 1 ; return n * fact ( n - 1 ) ; } int nPr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; } int countWords ( int N , int M ) { return pow ( N , M ) - nPr ( N , M ) ; } int main ( ) { int N = 10 , M = 5 ; cout << ( countWords ( N , M ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinimumValue ( int x , int y ) { if ( x > y ) swap ( x , y ) ; int a = 1 ; int b = x - 1 ; int c = y - b ; cout << a << " ▁ " << b << " ▁ " << c ; } int main ( ) { int x = 123 , y = 13 ; MinimumValue ( x , y ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void find_length ( int s1 , int s2 ) { if ( s1 <= 0 s2 <= 0 ) { cout << -1 ; return ; } int max_length = s1 + s2 - 1 ; int min_length = max ( s1 , s2 ) - min ( s1 , s2 ) + 1 ; if ( min_length > max_length ) { cout << -1 ; return ; } cout << " Max ▁ = ▁ " << max_length << endl ; cout << " Min ▁ = ▁ " << min_length ; } int main ( ) { int s1 = 8 , s2 = 5 ; find_length ( s1 , s2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstSetBit ( int n ) { int x = n & ( n - 1 ) ; return ( n ^ x ) ; } int main ( ) { int n = 12 ; cout << firstSetBit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ncr ( int n , int r ) { int res = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { res *= ( n - r + i ) ; res /= i ; } return res ; } int NoofSequences ( int N , int M ) { unordered_map < int , int > prime ; for ( int i = 2 ; i <= sqrt ( M ) ; i += 1 ) { while ( M % i == 0 ) { prime [ i ] += 1 ; M /= i ; } } if ( M > 1 ) { prime [ M ] += 1 ; } int ans = 1 ; for ( auto it : prime ) { ans *= ( ncr ( N + it . second - 1 , N - 1 ) ) ; } return ans ; } int main ( ) { int N = 2 , M = 6 ; cout << NoofSequences ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCr ( int n ) { if ( n < 4 ) return 0 ; int answer = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; answer /= 24 ; return answer ; } int countQuadruples ( int N , int K ) { int M = N / K ; int answer = nCr ( M ) ; for ( int i = 2 ; i < M ; i ++ ) { int j = i ; int temp2 = M / i ; int count = 0 ; int check = 0 ; int temp = j ; while ( j % 2 == 0 ) { count ++ ; j /= 2 ; if ( count >= 2 ) break ; } if ( count >= 2 ) { check = 1 ; } for ( int k = 3 ; k <= sqrt ( temp ) ; k += 2 ) { int cnt = 0 ; while ( j % k == 0 ) { cnt ++ ; j /= k ; if ( cnt >= 2 ) break ; } if ( cnt >= 2 ) { check = 1 ; break ; } else if ( cnt == 1 ) count ++ ; } if ( j > 2 ) { count ++ ; } if ( check ) continue ; else { if ( count % 2 == 1 ) { answer -= nCr ( temp2 ) ; } else { answer += nCr ( temp2 ) ; } } } return answer ; } int main ( ) { int N = 10 , K = 2 ; cout << countQuadruples ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; } int NoOfDistributions ( int N , int R ) { return ncr ( N + R - 1 , R - 1 ) ; } int main ( ) { int N = 4 , R = 3 ; cout << NoOfDistributions ( N , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPerfectcube ( int n ) { int d = cbrt ( n ) ; if ( d * d * d == n ) return true ; return false ; } int smallestPerfectCube ( int a [ ] , int n ) { int mini = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectcube ( a [ i ] ) ) { mini = min ( a [ i ] , mini ) ; } } return mini ; } int main ( ) { int a [ ] = { 16 , 8 , 25 , 2 , 3 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << smallestPerfectCube ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CheckSubarray ( int arr [ ] , int N ) { int presum [ N + 1 ] = { 0 } ; for ( int i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 1 ; i <= N ; i += 1 ) { for ( int j = i ; j <= N ; j += 1 ) { if ( ( presum [ j ] - presum [ i - 1 ] ) % N == 0 ) { cout << i - 1 << " ▁ " << j - 1 ; return ; } } } cout << -1 ; } int main ( ) { int arr [ ] = { 7 , 5 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; CheckSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CheckSubarray ( int arr [ ] , int N ) { int presum [ N + 1 ] = { 0 } ; for ( int i = 1 ; i <= N ; i += 1 ) { presum [ i ] = presum [ i - 1 ] + arr [ i - 1 ] ; } vector < int > moduloclass [ N ] ; for ( int i = 1 ; i <= N ; i += 1 ) { moduloclass [ presum [ i ] % N ] . push_back ( i - 1 ) ; } if ( moduloclass [ 0 ] . size ( ) > 0 ) { cout << 0 << " ▁ " << moduloclass [ 0 ] [ 0 ] ; return ; } for ( int i = 1 ; i < N ; i += 1 ) { if ( moduloclass [ i ] . size ( ) >= 2 ) { cout << moduloclass [ i ] [ 0 ] + 1 << " ▁ " << moduloclass [ i ] [ 1 ] ; return ; } } } int main ( ) { int arr [ ] = { 7 , 3 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; CheckSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countBits ( int n ) { int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; } int findNearestNumber ( int n ) { int cnt = countBits ( n ) ; cnt -= 1 ; if ( cnt % 2 ) { return 1 << ( cnt + 1 ) ; } else { int tempnum = 0 ; for ( int i = 0 ; i <= cnt ; i += 2 ) tempnum += 1 << i ; if ( tempnum < n ) { return ( 1 << ( cnt + 2 ) ) ; } else if ( tempnum == n ) return n ; for ( int i = 0 ; i <= cnt ; i += 2 ) { tempnum -= ( 1 << i ) ; if ( tempnum < n ) return tempnum += ( 1 << i ) ; } } } int main ( ) { int n = 19 ; cout << findNearestNumber ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getX ( int a , int b , int c , int d ) { int X = ( b * c - a * d ) / ( d - c ) ; return X ; } int main ( ) { int a = 2 , b = 3 , c = 4 , d = 5 ; cout << getX ( a , b , c , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNum ( int n ) { if ( n == 1 ) return 1 ; int count = pow ( 2 , n - 2 ) ; return count ; } int main ( ) { int n = 3 ; cout << countNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE string constructString ( ll n ) { string s = " " ; for ( ll i = 0 ; i < n ; i ++ ) { s += "10" ; } return s ; } ll binaryToDecimal ( string n ) { string num = n ; ll dec_value = 0 ; ll base = 1 ; ll len = num . length ( ) ; for ( ll i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; } ll findNumber ( ll n ) { string s = constructString ( n - 1 ) ; ll num = binaryToDecimal ( s ) ; return num ; } int main ( ) { ll n = 4 ; cout << findNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; Node * push ( Node * * head_ref , int data ) { Node * new_node = new Node ; new_node -> data = data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int bitonic_point ( Node * node ) { if ( node == NULL ) return -1 ; if ( node -> next == NULL ) return -1 ; if ( node -> data > node -> next -> data ) return -1 ; while ( node -> next != NULL ) { if ( node -> data > node -> next -> data ) break ; node = node -> next ; } int bitonicPoint = node -> data ; while ( node -> next != NULL ) { if ( node -> data < node -> next -> data ) return -1 ; node = node -> next ; } return bitonicPoint ; } int main ( ) { Node * head = NULL ; push ( & head , 100 ) ; push ( & head , 201 ) ; push ( & head , 399 ) ; push ( & head , 490 ) ; push ( & head , 377 ) ; push ( & head , 291 ) ; push ( & head , 100 ) ; cout << bitonic_point ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canConvert ( int a , int b ) { while ( b > a ) { if ( b % 10 == 1 ) { b /= 10 ; continue ; } if ( b % 2 == 0 ) { b /= 2 ; continue ; } return false ; } if ( b == a ) return true ; return false ; } int main ( ) { int A = 2 , B = 82 ; if ( canConvert ( A , B ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; } void nMosaicNumbers ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) cout << mosaic ( i ) << " ▁ " ; } int main ( ) { int n = 10 ; nMosaicNumbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countNodes ( int N , int X ) { int height = floor ( log2 ( N ) ) ; if ( X > height ) { cout << "0 STRNEWLINE 0" ; return ; } if ( N == 1 ) { cout << "1 STRNEWLINE 1" ; return ; } int max_total_nodes = ( 1 << ( height + 1 ) ) - 1 ; int nodes_last_level = ( 1 << height ) - ( max_total_nodes - N ) ; int from_root ; int from_leaf ; if ( X == height ) from_root = nodes_last_level ; else from_root = 1 << X ; int left_leaf_nodes = ( ( 1 << height ) - nodes_last_level ) / 2 ; if ( X == 0 ) { from_leaf = nodes_last_level + left_leaf_nodes ; } else { int i = X ; while ( nodes_last_level > 1 && i > 0 ) { nodes_last_level = ceil ( ( float ) nodes_last_level / ( float ) 2 ) ; i -- ; } from_leaf = nodes_last_level ; i = X ; while ( left_leaf_nodes > 1 && i > 0 ) { left_leaf_nodes = ceil ( ( float ) left_leaf_nodes / ( float ) 2 ) ; i -- ; } from_leaf += left_leaf_nodes ; } cout << from_root << endl << from_leaf ; } int main ( ) { int N = 38 , X = 3 ; countNodes ( N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum_of_4_squares ( int n ) { int i , odd = 0 , even = 0 ; for ( i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i % 2 == 0 ) even += i ; else odd += i ; if ( ( n / i ) != i ) { if ( ( n / i ) % 2 == 0 ) even += ( n / i ) ; else odd += ( n / i ) ; } } } if ( n % 2 == 1 ) return 8 * ( odd + even ) ; else return 24 * ( odd ) ; } int main ( ) { int n = 4 ; cout << sum_of_4_squares ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mosaic ( int n ) { int i , ans = 1 ; for ( i = 2 ; i <= n ; i ++ ) { if ( n % i == 0 && n > 0 ) { int count = 0 ; while ( n % i == 0 ) { n /= i ; count ++ ; } ans *= count * i ; } } return ans ; } int main ( ) { int n = 36 ; cout << mosaic ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Total_Ways ( int n ) { int fac = 1 ; for ( int i = 2 ; i <= n - 1 ; i ++ ) { fac = fac * i ; } return ( fac * 2 ) ; } int main ( ) { int n = 5 ; cout << Total_Ways ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxNumbers ( int a [ ] , int n ) { int fre [ 3 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] %= 3 ; fre [ a [ i ] ] ++ ; } int ans = fre [ 0 ] ; int k = min ( fre [ 1 ] , fre [ 2 ] ) ; ans += k ; fre [ 1 ] -= k ; fre [ 2 ] -= k ; ans += fre [ 1 ] / 3 + fre [ 2 ] / 3 ; return ans ; } int main ( ) { int a [ ] = { 1 , 4 , 10 , 7 , 11 , 2 , 8 , 5 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MaxNumbers ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; } int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = countSetBits ( arr [ i ] ) + countSetBits ( arr [ j ] ) ; if ( sum == k ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; cout << pairs ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void UpperHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i > j + 1 ) cout << '0' << " ▁ " ; else cout << rand ( ) % 10 << " ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 4 ; UpperHessenbergMatrix ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int composite_factors ( int n ) { int count = 0 ; int i , j ; int a [ n + 1 ] = { 0 } ; for ( i = 1 ; i <= n ; ++ i ) { if ( n % i == 0 ) { a [ i ] = i ; } } for ( i = 2 ; i <= n ; i ++ ) { j = 2 ; int p = 1 ; while ( j < a [ i ] ) { if ( a [ i ] % j == 0 ) { p = 0 ; break ; } j ++ ; } if ( p == 0 && a [ i ] != 0 ) { count ++ ; } } return count ; } int main ( ) { int n = 100 ; cout << composite_factors ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int sumOfFactors ( int n ) { int sum = 0 ; for ( int f = 1 ; f <= n / 2 ; f ++ ) { if ( n % f == 0 ) { sum += f ; } } return sum ; } int getSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && arr [ i ] == sumOfFactors ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; } int main ( ) { int arr [ 10 ] = { 17 , 6 , 10 , 6 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( getSum ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sameLength ( int A , int B ) { while ( A > 0 && B > 0 ) { A = A / 10 ; B = B / 10 ; } if ( A == 0 && B == 0 ) return true ; return false ; } int main ( ) { int A = 21 , B = 1 ; if ( sameLength ( A , B ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  2 NEW_LINE #define M  2 NEW_LINE void Matrix ( char a [ N ] [ M ] ) { char ch = '1' ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( a [ i ] [ j ] == ' . ' ) a [ i ] [ j ] = ch ; ch = ( ch == '1' ) ? '0' : '1' ; cout << a [ i ] [ j ] << " ▁ " ; } cout << endl ; if ( i % 2 == 0 ) ch = '0' ; else ch = '1' ; } } int main ( ) { char a [ N ] [ M ] = { { ' . ' , ' _ ' } , { ' _ ' , ' . ' } } ; Matrix ( a ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int FindXorSum ( int arr [ ] , int k , int n ) { if ( n < k ) return 0 ; int x [ n ] = { 0 } ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i > 0 ) x [ i ] = x [ i - 1 ] ^ arr [ i ] ; else x [ i ] = arr [ i ] ; if ( i >= k - 1 ) { int sum = 0 ; sum = x [ i ] ; if ( i - k > -1 ) sum ^= x [ i - k ] ; result += sum ; } } return result ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = 4 , k = 2 ; cout << FindXorSum ( arr , k , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverse ( int n ) { int rev = 0 ; while ( n > 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n = n / 10 ; } return rev ; } bool isPalin ( int n ) { return ( n == reverse ( n ) ) ; } int countDigits ( int n ) { int c = 0 ; while ( n > 0 ) { n = n / 10 ; c ++ ; } return c ; } int countPalinDigits ( int arr [ ] , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 10 || isPalin ( arr [ i ] ) ) { s += countDigits ( arr [ i ] ) ; } } return s ; } int main ( ) { int arr [ ] = { 121 , 56 , 434 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( countPalinDigits ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverse ( int n ) { int d = 0 , s = 0 ; while ( n > 0 ) { d = n % 10 ; s = s * 10 + d ; n = n / 10 ; } return s ; } bool isPalin ( int n ) { return n == reverse ( n ) ; } int sumOfArray ( int arr [ ] , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] > 10 ) && isPalin ( arr [ i ] ) ) { s += arr [ i ] ; } } return s ; } int main ( ) { int n = 6 ; int arr [ ] = { 12 , 313 , 11 , 44 , 9 , 1 } ; cout << sumOfArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; bool isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; else return false ; } ll fact ( ll n ) { if ( n < 2 ) return 1 ; return n * fact ( n - 1 ) ; } ll only_vowels ( map < char , int > & freq ) { ll denom = 1 ; ll cnt_vwl = 0 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { if ( isVowel ( itr -> first ) ) { denom *= fact ( itr -> second ) ; cnt_vwl += itr -> second ; } } return fact ( cnt_vwl ) / denom ; } ll all_vowels_together ( map < char , int > & freq ) { ll vow = only_vowels ( freq ) ; ll denom = 1 ; ll cnt_cnst = 0 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { if ( ! isVowel ( itr -> first ) ) { denom *= fact ( itr -> second ) ; cnt_cnst += itr -> second ; } } ll ans = fact ( cnt_cnst + 1 ) / denom ; return ( ans * vow ) ; } ll total_permutations ( map < char , int > & freq ) { ll cnt = 0 ; ll denom = 1 ; for ( auto itr = freq . begin ( ) ; itr != freq . end ( ) ; itr ++ ) { denom *= fact ( itr -> second ) ; cnt += itr -> second ; } return fact ( cnt ) / denom ; } ll no_vowels_together ( string & word ) { map < char , int > freq ; for ( int i = 0 ; i < word . size ( ) ; i ++ ) { char ch = tolower ( word [ i ] ) ; freq [ ch ] ++ ; } ll total = total_permutations ( freq ) ; ll vwl_tgthr = all_vowels_together ( freq ) ; ll res = total - vwl_tgthr ; return res ; } int main ( ) { string word = " allahabad " ; ll ans = no_vowels_together ( word ) ; cout << ans << endl ; word = " geeksforgeeks " ; ans = no_vowels_together ( word ) ; cout << ans << endl ; word = " abcd " ; ans = no_vowels_together ( word ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidSeq ( int a [ ] , int n ) { int nodes = n + 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 a [ i ] > nodes ) return false ; } return true ; } int main ( ) { int a [ ] = { 4 , 1 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isValidSeq ( a , n ) ) cout << " Valid " ; else cout << " Invalid " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; double e ( int x , int n ) { static double p = 1 , f = 1 ; double r ; if ( n == 0 ) return 1 ; r = e ( x , n - 1 ) ; p = p * x ; f = f * n ; return ( r + p / f ) ; } int main ( ) { int x = 4 , n = 15 ; cout << " STRNEWLINE " << e ( x , n ) ; return 0 ; }
#include <iostream> NEW_LINE #define MAX  1000000 NEW_LINE using namespace std ; int Sieve [ MAX ] = { 0 } ; void constructSieve ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { if ( Sieve [ i ] == 0 ) { for ( int j = 2 * i ; j <= MAX ; j += i ) { int temp = j ; while ( temp > 1 && temp % i == 0 ) { Sieve [ j ] ++ ; temp = temp / i ; } } } } } void checkElements ( int A [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( Sieve [ A [ i ] ] == k ) { cout << " YES STRNEWLINE " ; } else { cout << " NO STRNEWLINE " ; } } } int main ( ) { constructSieve ( ) ; int k = 3 ; int A [ ] = { 12 , 36 , 42 , 72 } ; int n = sizeof ( A ) / sizeof ( int ) ; checkElements ( A , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define mod  1000000007 NEW_LINE using namespace std ; long long modularexpo ( long long x , long long y , long long p ) { long long res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } void multiply ( long long F [ 2 ] [ 2 ] , long long M [ 2 ] [ 2 ] , long long m ) { long long x = ( ( F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] ) % m + ( F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ) % m ) % m ; long long y = ( ( F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] ) % m + ( F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ) % m ) % m ; long long z = ( ( F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] ) % m + ( F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ) % m ) % m ; long long w = ( ( F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] ) % m + ( F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ) % m ) % m ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; } void power ( long long F [ 2 ] [ 2 ] , long long n , long long m ) { if ( n == 0 n == 1 ) return ; long long M [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 , m ) ; multiply ( F , F , m ) ; if ( n % 2 != 0 ) multiply ( F , M , m ) ; } long long fib ( long long n , long long m ) { long long F [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n - 1 , m ) ; return F [ 0 ] [ 0 ] ; } int main ( ) { long long n = 4 ; long long base = fib ( n , mod ) % mod ; long long expo = fib ( n , mod - 1 ) % ( mod - 1 ) ; long long result = modularexpo ( base , expo , mod ) % mod ; cout << result << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntWays ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int tot_sum = 0 , sum = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) tot_sum += arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum += arr [ i ] ; if ( sum == tot_sum / 2 ) ans ++ ; } return ans ; } int main ( ) { int arr [ ] = { 1 , -1 , 1 , -1 , 1 , -1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntWays ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE #define MAX  32 NEW_LINE ll pow2 [ MAX ] ; bool visited [ MAX ] ; vector < int > ans ; void power_2 ( ) { ll ans = 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { pow2 [ i ] = ans ; ans *= 2 ; } } int countSetBits ( ll x ) { int setBits = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; setBits ++ ; } return setBits ; } void add ( ll num ) { int point = 0 ; ll value = 0 ; for ( ll i = 0 ; i < MAX ; i ++ ) { if ( visited [ i ] ) continue ; else { if ( num & 1 ) { value += ( 1 << i ) ; } num /= 2 ; } } ans . push_back ( value ) ; } void solve ( ll n , ll k ) { ans . push_back ( k ) ; int countk = countSetBits ( k ) ; if ( pow2 [ countk ] < n ) { cout << -1 ; return ; } int count = 0 ; for ( ll i = 0 ; i < pow2 [ countk ] - 1 ; i ++ ) { add ( i ) ; count ++ ; if ( count == n ) break ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } int main ( ) { ll n = 3 , k = 5 ; power_2 ( ) ; solve ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfMen ( int D , int m , int d ) { int Men = ( m * ( D - d ) ) / d ; return Men ; } int main ( ) { int D = 5 , m = 4 , d = 4 ; cout << numberOfMen ( D , m , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countX ( int a , int b ) { if ( b > a ) return 0 ; else if ( a == b ) return -1 ; else { int x = a - b , ans = 0 ; for ( int i = 1 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { int d1 = i , d2 = b - 1 ; if ( i * i != x ) d2 = x / i ; if ( d1 > b ) ans ++ ; if ( d2 > b ) ans ++ ; } } return ans ; } } int main ( ) { int a = 21 , b = 5 ; cout << countX ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll sumPowersK ( ll n , ll k ) { ll sum = 0 , num = 1 ; while ( num <= n ) { sum += num ; num *= k ; } return sum ; } ll getSum ( ll n , ll k ) { ll pwrK = sumPowersK ( n , k ) ; ll sumAll = ( n * ( n + 1 ) ) / 2 ; return ( sumAll - pwrK ) ; } int main ( ) { ll n = 10 , k = 3 ; cout << getSum ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPeople ( int p ) { int tmp = 0 , count = 0 ; for ( int i = 1 ; i * i <= p ; i ++ ) { tmp = tmp + ( i * i ) ; if ( tmp <= p ) count ++ ; else break ; } return count ; } int main ( ) { int p = 14 ; cout << maxPeople ( p ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE static constexpr int kN = 1000000 ; int maxPeople ( int p ) { ll sums [ kN ] ; sums [ 0 ] = 0 ; for ( int i = 1 ; i < kN ; i ++ ) sums [ i ] = ( ll ) ( i * i ) + sums [ i - 1 ] ; auto it = std :: lower_bound ( sums , sums + kN , p ) ; if ( * it > p ) { -- it ; } return ( it - sums ) ; } int main ( ) { int p = 14 ; cout << maxPeople ( p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getAverage ( int x , int y ) { int avg = ( x & y ) + ( ( x ^ y ) >> 1 ) ; return avg ; } int main ( ) { int x = 10 , y = 9 ; cout << getAverage ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  60 NEW_LINE int solveQuery ( int L , int X ) { int res ; int a [ MAXN ] , b [ L ] ; int ref = X , size_a = 0 ; while ( ref > 0 ) { a [ size_a ] = ref % 2 ; ref /= 2 ; size_a ++ ; } for ( int i = 0 ; i < min ( size_a , L ) ; i ++ ) { if ( a [ i ] == 1 ) b [ i ] = 0 ; else b [ i ] = 1 ; } for ( int i = min ( size_a , L ) ; i < L ; i ++ ) b [ i ] = 1 ; b [ L - 1 ] = 1 ; int temp = 0 , p = 1 ; for ( int i = 0 ; i < L ; i ++ ) { temp += b [ i ] * p ; p *= 2 ; } res = temp ^ X ; return res ; } int main ( ) { int queries [ ] [ 2 ] = { { 2 , 5 } , { 3 , 15 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) cout << solveQuery ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool solve ( int n , int k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; } int main ( ) { int n = 12 , k = 4 ; if ( solve ( n , k ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int closetAND ( int arr [ ] , int n , int k ) { int ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = min ( ans , abs ( k - X ) ) ; } } return ans ; } int main ( ) { int arr [ ] = { 4 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << closetAND ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / float ( N1 ) ; return rate ; } int main ( ) { int N1 = 100 , N2 = 120 ; cout << Rate ( N1 , N2 ) << " ▁ % " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPrime ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int maximum = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) maximum = max ( maximum , arr [ i ] ) ; } return maximum ; } int main ( ) { int arr [ ] = { 2 , 10 , 15 , 7 , 6 , 8 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getPrime ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long getMinNum ( int N ) { int lcm = 1 ; for ( int i = 2 ; i <= N ; i ++ ) lcm = ( ( i * lcm ) / ( __gcd ( i , lcm ) ) ) ; return ( lcm + 1 ) ; } int main ( ) { int N = 5 ; cout << getMinNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxEdges ( int N ) { int edges = 0 ; edges = floor ( ( N * N ) / 4 ) ; return edges ; } int main ( ) { int N = 5 ; cout << maxEdges ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSafe ( int N , int M , string str ) { int coll = 0 , colr = 0 , rowu = 0 , rowd = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' L ' ) { coll ++ ; if ( colr > 0 ) { colr -- ; } if ( coll == M ) { break ; } } else if ( str [ i ] == ' R ' ) { colr ++ ; if ( coll > 0 ) { coll -- ; } if ( colr == M ) { break ; } } else if ( str [ i ] == ' U ' ) { - rowu ++ ; if ( rowd > 0 ) { rowd -- ; } if ( rowu == N ) { break ; } } else if ( str [ i ] == ' D ' ) { rowd ++ ; if ( rowu > 0 ) { rowu -- ; } if ( rowd == N ) { break ; } } } if ( abs ( rowd ) < N && abs ( rowu ) < N && abs ( coll ) < M && abs ( colr ) < M ) { return true ; } return false ; } int main ( ) { int N = 1 , M = 1 ; string str = " R " ; if ( isSafe ( N , M , str ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Permutation ( int n , int k ) { int p [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) cout << p [ i ] << " ▁ " ; } int main ( ) { int n = 5 , k = 2 ; Permutation ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOnes ( int arr [ ] , int N ) { for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i ; j <= N ; j ++ ) { if ( j % i == 0 ) { if ( arr [ j - 1 ] == 0 ) else } } } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] == 1 ) return count ; } int main ( ) { int arr [ 10 ] = { 0 } ; int ans = countOnes ( arr , N ) ; cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void count_unique ( unordered_set < int > & s , int n ) { if ( s . count ( n ) ) return ; s . insert ( n ) ; n += 1 ; while ( n % 10 == 0 ) { n = n / 10 ; } count_unique ( s , n ) ; } int main ( ) { int n = 10 ; unordered_set < int > s ; count_unique ( s , n ) ; cout << s . size ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; ; int maxBitElement ( int arr [ ] , int n ) { int num = 0 , max = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = __builtin_popcount ( arr [ i ] ) ; if ( cnt > max ) { max = cnt ; num = arr [ i ] ; } } return num ; } int main ( ) { int arr [ ] = { 3 , 2 , 4 , 7 , 1 , 10 , 5 , 8 , 9 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxBitElement ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestSum ( int n ) { if ( n == 1 ) return 0 ; return ( 2 * pow ( 10 , n - 1 ) ) ; } int largestSum ( int n ) { return ( 2 * ( pow ( 10 , n ) - 1 ) ) ; } int main ( ) { int n = 4 ; cout << " Largest ▁ = ▁ " << largestSum ( n ) << endl ; cout << " Smallest ▁ = ▁ " << smallestSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_pairs ( int a [ ] , int b [ ] , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 ) odd2 ++ ; else even2 ++ ; } int pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) ; return pairs ; } int main ( ) { int a [ ] = { 9 , 14 , 6 , 2 , 11 } ; int b [ ] = { 8 , 4 , 7 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << count_pairs ( a , b , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_leftmost_unsetbit ( int n ) { int ind = -1 ; int i = 1 ; while ( n ) { if ( ! ( n & 1 ) ) ind = i ; i ++ ; n >>= 1 ; } return ind ; } void perform_steps ( int n ) { int left = find_leftmost_unsetbit ( n ) ; if ( left == -1 ) { cout << " No ▁ steps ▁ required " ; return ; } int step = 1 ; while ( find_leftmost_unsetbit ( n ) != -1 ) { if ( step % 2 == 0 ) { n += 1 ; cout << " Step " << step << " : ▁ Increase ▁ by ▁ 1 STRNEWLINE " ; } else { int m = find_leftmost_unsetbit ( n ) ; int num = pow ( 2 , m ) - 1 ; n = n ^ num ; cout << " Step " << step << " : ▁ Xor ▁ with ▁ " << num << endl ; } step += 1 ; } } int main ( ) { int n = 39 ; perform_steps ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = INT_MAX ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { int x = abs ( i - A ) ; int y = abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; } int main ( ) { int N = 3 , A = 1 , B = 2 ; cout << " Vertex ▁ = ▁ " << vertices ( N , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ans = 0 ; vector < int > gr [ 100005 ] ; void Add_Edge ( int u , int v ) { gr [ u ] . push_back ( v ) ; gr [ v ] . push_back ( u ) ; } void dfs ( int child , int par , int color [ ] ) { if ( color [ child ] != color [ par ] ) ans ++ ; for ( auto it : gr [ child ] ) { if ( it == par ) continue ; dfs ( it , child , color ) ; } } int main ( ) { int color [ ] = { 0 , 1 , 2 , 3 , 2 , 2 , 3 } ; Add_Edge ( 1 , 2 ) ; Add_Edge ( 1 , 3 ) ; Add_Edge ( 2 , 4 ) ; Add_Edge ( 2 , 5 ) ; Add_Edge ( 3 , 6 ) ; dfs ( 1 , 0 , color ) ; cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define mod  (ll)(1e9 + 7) NEW_LINE ll factorial ( ll n , ll p ) { for ( int i = 2 ; i <= n ; i ++ ) res = ( res * i ) % p ; return res ; } ll power ( ll x , ll y , ll p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } ll modInverse ( ll n , ll p ) { return power ( n , p - 2 , p ) ; } ll nCrModP ( ll n , ll r , ll p ) { if ( r == 0 ) return 1 ; ll fac [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; } ll countArrangements ( ll n , ll k , ll p ) { return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p ; } int main ( ) { ll N = 5 , K = 8 ; cout << countArrangements ( N , K , mod ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; } int main ( ) { int N = 390 ; cout << maxProd ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  2 NEW_LINE #define M  3 NEW_LINE bool check ( int mat [ N ] [ M ] ) { int xorr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xorr ^= mat [ i ] [ 0 ] ; } if ( xorr != 0 ) return true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ 0 ] ) return true ; } } return false ; } int main ( ) { int mat [ N ] [ M ] = { { 7 , 7 , 7 } , { 10 , 10 , 7 } } ; if ( check ( mat ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumodd ( int n ) { return ( n * n ) ; } int sumeven ( int n ) { return ( n * ( n + 1 ) ) ; } int findSum ( int num ) { int sumo = 0 ; int sume = 0 ; int x = 1 ; int cur = 0 ; int ans = 0 ; while ( num > 0 ) { int inc = min ( x , num ) ; num -= inc ; if ( cur == 0 ) { ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) ; sumo += inc ; } else { ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) ; sume += inc ; } x *= 2 ; cur ^= 1 ; } return ans ; } int main ( ) { int n = 4 ; cout << findSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; } int main ( ) { int N = 3 ; cout << oddTriangularNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double area ( double a , double b , double c ) { double d = fabs ( ( c * c ) / ( 2 * a * b ) ) ; return d ; } int main ( ) { double a = -2 , b = 4 , c = 3 ; cout << area ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define MAXN  (ll)(1e5 + 1) NEW_LINE #define mod  (ll)(1e9 + 7) NEW_LINE ll spf [ MAXN ] ; map < ll , ll > cnt ; void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } void factorize ( ll f ) { while ( f > 1 ) { ll x = spf [ f ] ; while ( f % x == 0 ) { cnt [ x ] ++ ; f /= x ; } } } ll factorial ( ll n , ll p ) { ll res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = ( res * i ) % p ; return res ; } ll power ( ll x , ll y , ll p ) { ll res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } ll modInverse ( ll n , ll p ) { return power ( n , p - 2 , p ) ; } ll nCrModP ( ll n , ll r , ll p ) { if ( r == 0 ) return 1 ; ll fac [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; } ll countArrays ( ll arr [ ] , ll N , ll K , ll P ) { ll res = 1 ; sieve ( ) ; for ( int i = 0 ; i < N ; i ++ ) { factorize ( arr [ i ] ) ; } for ( auto i : cnt ) { int ci = i . second ; res = ( res * nCrModP ( ci + K - 1 , K - 1 , P ) ) % P ; } return res ; } int main ( ) { ll arr [ ] = { 1 , 3 , 5 , 2 } , K = 3 ; ll N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countArrays ( arr , N , K , mod ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define MAXN  100000 NEW_LINE #define MOD  1000000007 NEW_LINE ll fact [ MAXN ] ; void factorial ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAXN ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) % MOD ; } ll power ( ll x , ll y , ll p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } ll modInverse ( ll x , ll p ) { return power ( x , p - 2 , p ) ; } ll countDifferentNumbers ( ll arr [ ] , ll P ) { factorial ( ) ; ll res = 0 , X = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) X += arr [ i ] ; res = fact [ X ] ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( arr [ i ] > 1 ) res = ( res * modInverse ( fact [ arr [ i ] ] , P ) ) % P ; } return res ; } int main ( ) { ll arr [ ] = { 1 , 0 , 2 , 0 , 0 , 7 , 4 , 0 , 0 , 3 } ; cout << countDifferentNumbers ( arr , MOD ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void line ( double x0 , double y0 ) { double c = 2 * y0 * x0 ; cout << y0 << " x " << " ▁ + ▁ " << x0 << " y ▁ = ▁ " << c ; } int main ( ) { double x0 = 4 , y0 = 3 ; line ( x0 , y0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  7 NEW_LINE void printOriginalMatrix ( int a [ ] , int b [ ] , int mat [ N ] [ M ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) cout << min ( a [ i ] , b [ j ] ) << " ▁ " ; else cout << 0 << " ▁ " ; } cout << endl ; } } int main ( ) { int a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 2 , 3 , 0 , 0 , 2 , 0 , 1 } ; int mat [ N ] [ M ] = { { 1 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { 1 , 1 , 0 , 0 , 0 , 0 , 0 } } ; printOriginalMatrix ( a , b , mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float percent ( int n , int x ) { float p = n * x ; p /= 100 ; return p ; } float getLoss ( int price [ ] , int quantity [ ] , int X [ ] , int n ) { float loss = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float originalPrice = price [ i ] ; float sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; float afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ; loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; } return loss ; } int main ( ) { int price [ ] = { 20 , 48 , 200 , 100 } ; int quantity [ ] = { 20 , 48 , 1 , 1 } ; int X [ ] = { 0 , 48 , 200 , 5 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << getLoss ( price , quantity , X , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAbsDiff ( int arr [ ] , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = min ( minEle , arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxAbsDiff ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } int maximizeSum ( int a [ ] , int n ) { int cnt = 0 ; int mini = INT_MAX ; int minSubarray = INT_MAX ; int sum = maxSubArraySum ( a , n ) ; int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; cnt ++ ; minSubarray = min ( a [ i ] , minSubarray ) ; if ( sum == max_ending_here ) { if ( cnt == 1 ) mini = min ( mini , 0 ) ; else mini = min ( mini , minSubarray ) ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; cnt = 0 ; minSubarray = INT_MAX ; } } return sum - mini ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , -2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maximizeSum ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; } int main ( ) { int n = 132 ; if ( isOsiris ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDudeney ( int n ) { int cube_rt = int ( round ( ( pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; int dig_sum = 0 ; int temp = n ; while ( temp > 0 ) { int rem = temp % 10 ; dig_sum += rem ; temp /= 10 ; } if ( cube_rt != dig_sum ) return false ; return true ; } int main ( ) { int n = 17576 ; if ( isDudeney ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriangles ( int a [ ] , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; } int main ( ) { int a [ ] = { 1 , 2 , 2 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countTriangles ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int getHCF ( int x , int y ) { int minimum = min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; } int main ( ) { int x = 16 , y = 32 ; cout << getHCF ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } bool isDivisible ( int n ) { if ( isPrime ( n + 1 ) ) return false ; return true ; } int main ( ) { int n = 6 ; if ( isDivisible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int R = 5 ; const int C = 5 ; int findMaxCock ( int ar [ R ] [ C ] ) { if ( R < 3 C < 3 ) return -1 ; int max_sum = INT_MIN ; for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) { int sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = max ( max_sum , sum ) ; } } return max_sum ; } int main ( ) { int ar [ ] [ C ] = { { 0 , 3 , 0 , 6 , 0 } , { 0 , 1 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 0 } , { 0 , 0 , 2 , 0 , 1 } , { 0 , 2 , 0 , 1 , 3 } } ; cout << findMaxCock ( ar ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int segments ( int n , int p [ ] , int m ) { map < int , int > c ; c [ 0 ] = 1 ; bool has = false ; int sum = 0 ; long long ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) has = true ; if ( has ) ans += c [ sum ] + c [ sum - 1 ] ; else c [ sum ] ++ ; } return ans ; } int main ( ) { int a [ ] = { 2 , 4 , 5 , 3 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = 4 ; cout << segments ( n , a , m ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int oddDays ( int N ) { int hund1 = N / 100 ; int hund4 = N / 400 ; int leap = N >> 2 ; int ord = N - leap ; if ( hund1 ) { ord += hund1 ; leap -= hund1 ; } if ( hund4 ) { ord -= hund4 ; leap += hund4 ; } int days = ord + leap * 2 ; int odd = days % 7 ; return odd ; } int main ( ) { int N = 100 ; cout << oddDays ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float ellipsearea ( float r ) { if ( r < 0 ) return -1 ; float a = ( 3.14 * r * r ) / 4 ; return a ; } int main ( ) { float r = 5 ; cout << ellipsearea ( r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; int maxFreq = INT_MIN ; for ( auto x : mp ) maxFreq = max ( maxFreq , x . second ) ; return ( n - maxFreq ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CntDivbyX ( int arr [ ] , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 2 ; cout << CntDivbyX ( arr , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestIndex ( int a [ ] , int n ) { int right1 = 0 , right0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) right1 = i ; else right0 = i ; } return min ( right1 , right0 ) ; } int main ( ) { int a [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << smallestIndex ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countCon ( int ar [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; } int main ( ) { int ar [ ] = { 1 , 2 , 2 , 3 , 4 , 4 , 5 , 5 , 5 , 5 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << countCon ( ar , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void reduceFraction ( int x , int y ) { int d ; d = __gcd ( x , y ) ; x = x / d ; y = y / d ; cout << " x ▁ = ▁ " << x << " , ▁ y ▁ = ▁ " << y << endl ; } int main ( ) { int x = 16 ; int y = 10 ; reduceFraction ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; } int main ( ) { int T1 = 3 , N1 = 5 , T2 = 6 ; cout << noOfYears ( T1 , N1 , T2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubsequence ( int * arr , int n , int k ) { map < int , int > M ; for ( int i = 0 ; i < n ; ++ i ) ++ M [ arr [ i ] ] ; int * numCount = new int [ k + 1 ] ; for ( int i = 0 ; i <= k ; ++ i ) numCount [ i ] = 0 ; for ( auto p : M ) { if ( p . first <= k ) { for ( int i = 1 ; ; ++ i ) { if ( p . first * i > k ) break ; numCount [ p . first * i ] += p . second ; } } else break ; } int lcm = 0 , length = 0 ; for ( int i = 1 ; i <= k ; ++ i ) { if ( numCount [ i ] > length ) { length = numCount [ i ] ; lcm = i ; } } if ( lcm == 0 ) cout << -1 << endl ; else { cout << " LCM ▁ = ▁ " << lcm << " , ▁ Length ▁ = ▁ " << length << endl ; cout << " Indexes ▁ = ▁ " ; for ( int i = 0 ; i < n ; ++ i ) if ( lcm % arr [ i ] == 0 ) cout << i << " ▁ " ; } } int main ( ) { int k = 14 ; int arr [ ] = { 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubsequence ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > addToArrayForm ( vector < int > & A , int K ) { vector < int > v , ans ; int rem = 0 ; int i = 0 ; for ( i = A . size ( ) - 1 ; i >= 0 ; i -- ) { int my = A [ i ] + K % 10 + rem ; if ( my > 9 ) { rem = 1 ; v . push_back ( my % 10 ) ; } else { v . push_back ( my ) ; rem = 0 ; } K = K / 10 ; } while ( K > 0 ) { int my = K % 10 + rem ; v . push_back ( my % 10 ) ; if ( my / 10 > 0 ) rem = 1 ; else rem = 0 ; K = K / 10 ; } if ( rem > 0 ) v . push_back ( rem ) ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) ans . push_back ( v [ i ] ) ; return ans ; } int main ( ) { vector < int > A { 2 , 7 , 4 } ; int K = 181 ; vector < int > ans = addToArrayForm ( A , K ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define mod  (ll)(1e9 + 7) NEW_LINE ll power ( ll x , ll y , ll p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } ll findCount ( ll N ) { int count = power ( 2 , N , mod ) ; return count ; } int main ( ) { ll N = 25 ; cout << findCount ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int msb ( int x ) { int ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; } int xorRange ( int l , int r ) { int max_bit = msb ( r ) ; int mul = 2 ; int ans = 0 ; for ( int i = 1 ; i <= max_bit ; i ++ ) { if ( ( l / mul ) * mul == ( r / mul ) * mul ) { if ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ans += mul ; mul *= 2 ; continue ; } bool odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ; if ( odd_c ) ans += mul ; mul *= 2 ; } int zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) / 2 ; if ( l % 2 == 1 && r % 2 == 1 ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans ++ ; return ans ; } int main ( ) { int l = 1 , r = 4 ; cout << xorRange ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; } int main ( ) { int n = 120 ; cout << countNumbers ( 1 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; bool checkfact ( int N , int countprime , int prime ) { int countfact = 0 ; if ( prime == 2 prime == 3 ) countfact ++ ; int divide = prime ; while ( N / divide != 0 ) { countfact += N / divide ; divide = divide * divide ; } if ( countfact >= countprime ) return true ; else return false ; } bool check ( int N ) { int sumsquares = ( N + 1 ) * ( 2 * N + 1 ) ; int countprime = 0 ; for ( int i = 2 ; i <= sqrt ( sumsquares ) ; i ++ ) { int flag = 0 ; while ( sumsquares % i == 0 ) { flag = 1 ; countprime ++ ; sumsquares /= i ; } if ( flag ) { if ( ! checkfact ( N - 1 , countprime , i ) ) return false ; countprime = 0 ; } } if ( sumsquares != 1 ) if ( ! checkfact ( N - 1 , 1 , sumsquares ) ) return false ; return true ; } int main ( ) { int N = 5 ; if ( check ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSquares ( int r , int c , int m ) { int squares = 0 ; for ( int i = 1 ; i <= 8 ; i ++ ) { for ( int j = 1 ; j <= 8 ; j ++ ) { if ( max ( abs ( i - r ) , abs ( j - c ) ) <= m ) squares ++ ; } } return squares ; } int main ( ) { int r = 4 , c = 4 , m = 1 ; cout << countSquares ( r , c , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNonIncreasing ( int arr [ ] , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; } int main ( ) { int arr [ ] = { 5 , 2 , 3 , 7 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countNonIncreasing ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int recamanGenerator ( int arr [ ] , int n ) { arr [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == temp ) temp < 0 ) { temp = arr [ i - 1 ] + i ; break ; } } arr [ i ] = temp ; } } int recamanArray ( int arr [ ] , int n ) { unordered_set < int > s ; int recaman [ n ] ; recamanGenerator ( recaman , n ) ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( recaman [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { auto it = s . find ( arr [ i ] ) ; if ( it != s . end ( ) ) s . erase ( it ) ; } return s . size ( ) ; } int main ( ) { int arr [ ] = { 7 , 11 , 20 , 4 , 2 , 1 , 8 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << recamanArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100005 NEW_LINE using namespace std ; int kadaneAlgorithm ( const int * ar , int n ) { int sum = 0 , maxSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ar [ i ] ; if ( sum < 0 ) sum = 0 ; maxSum = max ( maxSum , sum ) ; } return maxSum ; } int maxFunction ( const int * arr , int n ) { int b [ MAX ] , c [ MAX ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i & 1 ) { b [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; c [ i ] = - b [ i ] ; } else { c [ i ] = abs ( arr [ i + 1 ] - arr [ i ] ) ; b [ i ] = - c [ i ] ; } } int ans = kadaneAlgorithm ( b , n - 1 ) ; ans = max ( ans , kadaneAlgorithm ( c , n - 1 ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 5 , 4 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxFunction ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printPermutation ( int n ) { if ( n % 2 != 0 ) cout << -1 ; else for ( int i = 1 ; i <= n / 2 ; i ++ ) cout << 2 * i << " ▁ " << 2 * i - 1 << " ▁ " ; } int main ( ) { int n = 4 ; printPermutation ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  10000000 NEW_LINE int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; } int main ( ) { int n = 120 , m = 51840 ; int a = 2 , b = 3 ; cout << minimumSteps ( n , m , a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int n , int m ) { if ( m % n != 0 ) return -1 ; int minOperations = 0 ; int q = m / n ; while ( q % 2 == 0 ) { q = q / 2 ; minOperations ++ ; } while ( q % 3 == 0 ) { q = q / 3 ; minOperations ++ ; } if ( q == 1 ) return minOperations ; return -1 ; } int main ( ) { int n = 120 , m = 51840 ; cout << minOperations ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return -1 ; float R = ( ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) ) / 2 ; return R ; } int main ( ) { float h = 5 , r = 6 ; cout << sphereSide ( h , r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; } int main ( ) { int n = 20 ; cout << possibleways ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE int countSubarrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { ll product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 6 , 2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; cout << countSubarrays ( arr , n , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define MAX  100002 NEW_LINE ll tree [ 4 * MAX ] ; void build ( int node , int start , int end , const int * arr , int k ) { if ( start == end ) { tree [ node ] = ( 1LL * arr [ start ] ) % k ; return ; } int mid = ( start + end ) >> 1 ; build ( 2 * node , start , mid , arr , k ) ; build ( 2 * node + 1 , mid + 1 , end , arr , k ) ; tree [ node ] = ( tree [ 2 * node ] * tree [ 2 * node + 1 ] ) % k ; } ll query ( int node , int start , int end , int l , int r , int k ) { if ( start > end start > r end < l ) { return 1 ; } if ( start >= l && end <= r ) { return tree [ node ] % k ; } int mid = ( start + end ) >> 1 ; ll q1 = query ( 2 * node , start , mid , l , r , k ) ; ll q2 = query ( 2 * node + 1 , mid + 1 , end , l , r , k ) ; return ( q1 * q2 ) % k ; } ll countSubarrays ( const int * arr , int n , int k ) { ll count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { ll product_mod_k = query ( 1 , 0 , n - 1 , i , j , k ) ; if ( product_mod_k == 0 ) { count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 6 , 2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; build ( 1 , 0 , n - 1 , arr , k ) ; cout << countSubarrays ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; } int main ( ) { int n = 5 , k = 2 ; cout << Permutations ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; ll power ( ll a , ll n ) { if ( n == 0 ) return 1 ; ll p = power ( a , n / 2 ) ; p = p * p ; if ( n & 1 ) p = p * a ; return p ; } int countIntegers ( ll l , ll r ) { ll ans = 0 , i = 1 ; ll v = power ( 2 , i ) ; while ( v <= r ) { while ( v <= r ) { if ( v >= l ) ans ++ ; v = v * 3 ; } i ++ ; v = power ( 2 , i ) ; } if ( l == 1 ) ans ++ ; return ans ; } int main ( ) { ll l = 12 , r = 21 ; cout << countIntegers ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPairCount ( int N , int K ) { int count = 0 ; int rem [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; } int main ( ) { int N = 10 , K = 4 ; cout << findPairCount ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005 NEW_LINE bool prime [ N ] ; void sieve ( ) { memset ( prime , true , sizeof prime ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) if ( prime [ i ] ) for ( int j = i * 2 ; j < N ; j += i ) prime [ j ] = false ; } int sumTruncatablePrimes ( int n ) { int sum = 0 ; for ( int i = 2 ; i < n ; i ++ ) { int num = i ; bool flag = true ; while ( num ) { if ( ! prime [ num ] ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ; while ( num / power ) { if ( ! prime [ num % power ] ) { flag = false ; break ; } power *= 10 ; } if ( flag ) sum += i ; } return sum ; } int main ( ) { int n = 25 ; sieve ( ) ; cout << sumTruncatablePrimes ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nDigitPerfectSquares ( int n ) { cout << pow ( ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) << " ▁ " ; cout << pow ( ceil ( sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ; } int main ( ) { int n = 4 ; nDigitPerfectSquares ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE int MaxTraceSub ( int mat [ ] [ N ] ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = max ( trace , max_trace ) ; } } } return max_trace ; } int main ( ) { int mat [ N ] [ N ] = { { 10 , 2 , 5 } , { 6 , 10 , 4 } , { 2 , 7 , -10 } } ; cout << MaxTraceSub ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define n  3 NEW_LINE #define m  3 NEW_LINE bool check ( int a [ n ] [ m ] , int b [ n ] [ m ] ) { for ( int i = 0 ; i < n ; i ++ ) { vector < int > v1 , v2 ; int r = i ; int col = 0 ; while ( r >= 0 && col < m ) { v1 . push_back ( a [ r ] [ col ] ) ; v2 . push_back ( b [ r ] [ col ] ) ; r -- ; col ++ ; } sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) { if ( v1 [ i ] != v2 [ i ] ) return false ; } } for ( int j = 1 ; j < m ; j ++ ) { vector < int > v1 , v2 ; int r = n - 1 ; int col = j ; while ( r >= 0 && col < m ) { v1 . push_back ( a [ r ] [ col ] ) ; v2 . push_back ( b [ r ] [ col ] ) ; r -- ; col ++ ; } sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) { if ( v1 [ i ] != v2 [ i ] ) return false ; } } return true ; } int main ( ) { int a [ n ] [ m ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int b [ n ] [ m ] = { { 1 , 4 , 7 } , { 2 , 5 , 6 } , { 3 , 8 , 9 } } ; if ( check ( a , b ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lastDigit ( string a , string b ) { int lastDig = ( a [ a . length ( ) - 1 ] - '0' ) * ( b [ b . length ( ) - 1 ] - '0' ) ; cout << lastDig % 10 ; } int main ( ) { string a = "1234567891233" , b = "1234567891233156" ; lastDigit ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPalindrome ( int n ) { if ( n == 1 ) { cout << " Smallest ▁ Palindrome : ▁ 0" << endl ; cout << " Largest ▁ Palindrome : ▁ 9" ; } else { cout << " Smallest ▁ Palindrome : ▁ " << pow ( 10 , n - 1 ) + 1 ; cout << " Largest Palindrome : " } } int main ( ) { int n = 4 ; printPalindrome ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printSum ( int a , int b ) { int res = 0 ; int temp1 = 0 , temp2 = 0 ; while ( a ) { temp1 = temp1 * 10 + ( a % 10 ) ; a /= 10 ; } a = temp1 ; while ( b ) { temp2 = temp2 * 10 + ( b % 10 ) ; b /= 10 ; } b = temp2 ; while ( a ) { int sum = ( a % 10 + b % 10 ) ; if ( sum / 10 == 0 ) res = res * 10 + sum ; else { temp1 = 0 ; while ( sum ) { temp1 = temp1 * 10 + ( sum % 10 ) ; sum /= 10 ; } sum = temp1 ; while ( sum ) { res = res * 10 + ( sum % 10 ) ; sum /= 10 ; } } a /= 10 ; b /= 10 ; } return res ; } int main ( ) { int a = 7752 , b = 8834 ; cout << printSum ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigits ( int a , int b ) { int count = 0 ; int p = abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; } int main ( ) { int a = 100 ; int b = 10 ; cout << countDigits ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigits ( int a , int b ) { return floor ( log10 ( abs ( a ) ) - log10 ( abs ( b ) ) ) + 1 ; } int main ( ) { int a = 100 ; int b = 10 ; cout << countDigits ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestOdd ( int n ) { if ( n == 1 ) return 1 ; return pow ( 10 , n - 1 ) + 1 ; } int main ( ) { int n = 4 ; cout << smallestOdd ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int n ) { int odd = pow ( 10 , n ) - 1 ; int even = odd - 1 ; cout << " Even ▁ = ▁ " << even << endl ; cout << " Odd ▁ = ▁ " << odd ; } int main ( ) { int n = 4 ; findNumbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubArray ( int arr [ ] , int n ) { bool isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 0 , 1 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestSubArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return pow ( 10 , n - 1 ) ; } int main ( ) { int n = 4 ; cout << smallestEven ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProfit ( int n , int a , int b , int x , int y ) { int res = x * ( n / a ) ; res += y * ( n / b ) ; res -= min ( x , y ) * ( n / ( ( a * b ) / __gcd ( a , b ) ) ) ; return res ; } int main ( ) { int n = 6 , a = 6 , b = 2 , x = 8 , y = 2 ; cout << maxProfit ( n , a , b , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE #define MOD  1000000007 NEW_LINE int sumOfSeries ( int n ) { ll ans = ( ll ) pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; } int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int kthOdd ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i <= n ; i ++ ) { if ( ( arr [ i ] % 2 ) == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << ( kthOdd ( arr , n , k ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } printf ( " % 05d " , ans ) ; } int main ( ) { int n = 12345 ; lastFiveDigits ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; const int mod = 1000000007 ; ll power ( ll a , ll n ) { if ( n == 0 ) return 1 ; ll p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n & 1 ) { p = ( p * a ) % mod ; } return p ; } ll computeSum ( int * arr , int n ) { sort ( arr , arr + n ) ; ll sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ll maxs = ( power ( 2 , i ) - 1 + mod ) % mod ; maxs = ( maxs * arr [ i ] ) % mod ; ll mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod ; mins = ( mins * arr [ i ] ) % mod ; ll V = ( maxs - mins + mod ) % mod ; sum = ( sum + V ) % mod ; } return sum ; } int main ( ) { int arr [ ] = { 4 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << computeSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; } int main ( ) { int n = 7 ; cout << count ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int KthMinValAfterMconcatenate ( int A [ ] , int N , int M , int K ) { sort ( A , A + N ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; } int main ( ) { int A [ ] = { 3 , 1 , 2 } ; int M = 3 , K = 4 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << KthMinValAfterMconcatenate ( A , N , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumN ( int n ) { n = ( n + 1 ) / 2 ; return ( n * n ) ; } int main ( ) { int n = 3 ; cout << sumN ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; } int main ( ) { int n = 20 ; cout << countNumbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findThirdDigit ( int n ) { if ( n < 3 ) return 0 ; return n & 1 ? 1 : 6 ; } int main ( ) { int n = 7 ; cout << findThirdDigit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrimes ( int n ) { return n / 2 ; } int main ( ) { int n = 17 ; cout << maxPrimes ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; } int main ( ) { int n = 2 ; cout << sum ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE const int MAXI = 99999999 ; void add_edge ( vector < pair < int , int > > gr [ ] , int x , int y , int weight ) { gr [ x ] . push_back ( { y , weight } ) ; gr [ y ] . push_back ( { x , weight } ) ; } int minDistance ( vector < pair < int , int > > gr [ ] , int n , int dist [ ] , int vis [ ] , int a [ ] , int k ) { priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > q ; int ans = MAXI ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! a [ i ] ) continue ; for ( int j = 1 ; j <= n ; j ++ ) { dist [ j ] = MAXI ; vis [ j ] = 0 ; } dist [ i ] = 0 ; while ( ! q . empty ( ) ) q . pop ( ) ; q . push ( { 0 , i } ) ; int good = 0 ; while ( ! q . empty ( ) ) { int v = q . top ( ) . second ; q . pop ( ) ; if ( vis [ v ] ) continue ; vis [ v ] = 1 ; good += a [ v ] ; if ( dist [ v ] > ans ) break ; if ( good == 2 and a [ v ] ) { ans = min ( ans , dist [ v ] ) ; break ; } for ( int j = 0 ; j < gr [ v ] . size ( ) ; j ++ ) { int to = gr [ v ] [ j ] . first ; int weight = gr [ v ] [ j ] . second ; if ( dist [ v ] + weight < dist [ to ] ) { dist [ to ] = dist [ v ] + weight ; q . push ( { dist [ to ] , to } ) ; } } } } return ans ; } int main ( ) { int n = 5 , m = 5 ; vector < pair < int , int > > gr [ N ] ; add_edge ( gr , 1 , 2 , 3 ) ; add_edge ( gr , 1 , 2 , 3 ) ; add_edge ( gr , 2 , 3 , 4 ) ; add_edge ( gr , 3 , 4 , 1 ) ; add_edge ( gr , 4 , 5 , 8 ) ; int k = 3 ; int a [ N ] , vis [ N ] , dist [ N ] ; a [ 1 ] = a [ 3 ] = a [ 5 ] = 1 ; cout << minDistance ( gr , n , dist , vis , a , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimum ( int n , int m ) { int mini = m ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int sec = n / i ; if ( __gcd ( m , i ) > 1 ) { return i ; } else if ( __gcd ( sec , m ) > 1 ) { mini = min ( sec , mini ) ; } } } if ( mini == m ) return -1 ; else return mini ; } int main ( ) { int n = 8 , m = 10 ; cout << findMinimum ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += pow ( i , i ) ; } return nth ; } int main ( ) { int N = 3 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int kthSmallest ( int n , int k ) { return ( 2 * k ) ; } int main ( ) { int n = 8 , k = 4 ; cout << kthSmallest ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; } int main ( ) { int n = 10 ; if ( isSumOfPowersOfTwo ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinRemoval ( int arr [ ] , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = max ( maximum , temp ) ; } return ( value - maximum ) ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 2 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinRemoval ( arr , n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double getTime ( int u , int v , int x ) { double speed = u + v ; double time = x / speed ; return time ; } int main ( ) { double u = 3 , v = 3 , x = 3 ; cout << getTime ( u , v , x ) ; return 0 ; }
#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int number_of_teams ( int M ) { int N1 , N2 , sqr ; sqr = sqrt ( 1 + ( 8 * M ) ) ; N1 = ( 1 + sqr ) / 2 ; N2 = ( 1 - sqr ) / 2 ; if ( N1 > 0 ) return N1 ; return N2 ; } int main ( ) { int M = 45 ; cout << number_of_teams ( M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; int c = a + b ; a = b ; b = c ; } return sum ; } int main ( ) { int N = 20 ; cout << LucasSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; } int main ( ) { int l = 1000 , r = 6000 ; cout << countNumbers ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int countNumbers ( int L , int R , int K ) { if ( K == 9 ) K = 0 ; int totalnumbers = R - L + 1 ; int factor9 = totalnumbers / 9 ; int rem = totalnumbers % 9 ; int ans = factor9 ; for ( int i = R ; i > R - rem ; i -- ) { int rem1 = i % 9 ; if ( rem1 == K ) ans ++ ; } return ans ; } int main ( ) { int L = 10 ; int R = 22 ; int K = 3 ; cout << countNumbers ( L , R , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int EvenSum ( vector < int > & A , int index , int value ) { A [ index ] = A [ index ] + value ; int sum = 0 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; return sum ; } void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; sum = EvenSum ( A , index , value ) ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << " ▁ " ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 4 } ; vector < vector < int > > Q = { { 0 , 1 } , { 1 , -3 } , { 0 , -4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void BalanceArray ( vector < int > & A , vector < vector < int > > & Q ) { vector < int > ANS ; int i , sum = 0 ; for ( i = 0 ; i < A . size ( ) ; i ++ ) if ( A [ i ] % 2 == 0 ) sum = sum + A [ i ] ; for ( i = 0 ; i < Q . size ( ) ; i ++ ) { int index = Q [ i ] [ 0 ] ; int value = Q [ i ] [ 1 ] ; if ( A [ index ] % 2 == 0 ) sum = sum - A [ index ] ; A [ index ] = A [ index ] + value ; if ( A [ index ] % 2 == 0 ) sum = sum + A [ index ] ; ANS . push_back ( sum ) ; } for ( i = 0 ; i < ANS . size ( ) ; i ++ ) cout << ANS [ i ] << " ▁ " ; } int main ( ) { vector < int > A = { 1 , 2 , 3 , 4 } ; vector < vector < int > > Q = { { 0 , 1 } , { 1 , -3 } , { 0 , -4 } , { 3 , 2 } } ; BalanceArray ( A , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPowerOfP ( int N , int p ) { int count = 0 ; int r = p ; while ( r <= N ) { count += ( N / r ) ; r = r * p ; } return count ; } vector < pair < int , int > > primeFactorsofB ( int B ) { vector < pair < int , int > > ans ; for ( int i = 2 ; B != 1 ; i ++ ) { if ( B % i == 0 ) { int count = 0 ; while ( B % i == 0 ) { B = B / i ; count ++ ; } ans . push_back ( make_pair ( i , count ) ) ; } } return ans ; } int largestPowerOfB ( int N , int B ) { vector < pair < int , int > > vec ; vec = primeFactorsofB ( B ) ; int ans = INT_MAX ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) ans = min ( ans , findPowerOfP ( N , vec [ i ] . first ) / vec [ i ] . second ) ; return ans ; } int main ( ) { cout << largestPowerOfB ( 5 , 2 ) << endl ; cout << largestPowerOfB ( 6 , 9 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int X , int Y , int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ( i % X == 0 ) && ( i % Y != 0 ) ) count ++ ; } return count ; } int main ( ) { int X = 2 , Y = 3 , N = 10 ; cout << countNumbers ( X , Y , N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <stack> NEW_LINE #define n  3 NEW_LINE using namespace std ; void findPrefixCount ( int p_arr [ ] [ n ] , bool arr [ ] [ n ] ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] ) continue ; if ( j != n - 1 ) p_arr [ i ] [ j ] += p_arr [ i ] [ j + 1 ] ; p_arr [ i ] [ j ] += ( int ) ( ! arr [ i ] [ j ] ) ; } } int matrixOrValueOne ( bool arr [ ] [ n ] ) { int p_arr [ n ] [ n ] = { 0 } ; findPrefixCount ( p_arr , arr ) ; int count_zero_submatrices = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int i = n - 1 ; stack < pair < int , int > > q ; int to_sum = 0 ; while ( i >= 0 ) { int c = 0 ; while ( q . size ( ) != 0 and q . top ( ) . first > p_arr [ i ] [ j ] ) { to_sum -= ( q . top ( ) . second + 1 ) * ( q . top ( ) . first - p_arr [ i ] [ j ] ) ; c += q . top ( ) . second + 1 ; q . pop ( ) ; } to_sum += p_arr [ i ] [ j ] ; count_zero_submatrices += to_sum ; q . push ( { p_arr [ i ] [ j ] , c } ) ; i -- ; } } return ( n * ( n + 1 ) * n * ( n + 1 ) ) / 4 - count_zero_submatrices ; } int main ( ) { bool arr [ ] [ n ] = { { 0 , 0 , 0 } , { 0 , 1 , 0 } , { 0 , 0 , 0 } } ; cout << matrixOrValueOne ( arr ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define n  3 NEW_LINE int submatrixXor ( int arr [ ] [ n ] ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; } int main ( ) { int arr [ ] [ n ] = { { 6 , 7 , 13 } , { 8 , 3 , 4 } , { 9 , 7 , 6 } } ; cout << submatrixXor ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDigitalRoot ( int num ) { int sum = INT_MAX , tempNum = num ; while ( sum >= 10 ) { sum = 0 ; while ( tempNum > 0 ) { sum += tempNum % 10 ; tempNum /= 10 ; } tempNum = sum ; } return sum ; } void findAnswer ( int X , int N ) { int counter = 0 ; for ( int i = 1 ; counter < N ; ++ i ) { int digitalRoot = findDigitalRoot ( i ) ; if ( digitalRoot == X ) { ++ counter ; } if ( counter == N ) { cout << i ; break ; } } } int main ( ) { int X = 1 , N = 3 ; findAnswer ( X , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; } int main ( ) { int X = 7 , N = 43 ; cout << findAnswer ( X , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int count ( int N , int K , int R ) { long long int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; } int main ( ) { int N = 20 , K = 4 , R = 3 ; cout << count ( N , K , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LucasSequence ( int arr [ ] , int n ) { int max = * max_element ( arr , arr + n ) ; unordered_set < int > s ; int a = 2 , b = 1 , c ; s . insert ( a ) ; s . insert ( b ) ; while ( b < max ) { int c = a + b ; a = b ; b = c ; s . insert ( b ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { auto it = s . find ( arr [ i ] ) ; if ( it != s . end ( ) ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 7 , 11 , 22 , 4 , 2 , 1 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << LucasSequence ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; } int main ( ) { int a = 3 , b = 2 , c = 8 ; cout << getCount ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; } int main ( ) { int n = 3 ; int a [ ] = { 1 , 1 , 2 } ; if ( isSpiltPossible ( n , a ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = max ( maximum , ( i & j ) ) ; return maximum ; } int main ( ) { int L = 1 , R = 632 ; cout << maxAND ( L , R ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findCount ( int arr [ ] , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findCount ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } bool isSunnyNum ( int n ) { if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; } int main ( ) { int n = 3 ; if ( isSunnyNum ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Cycles ( int N ) { int fact = 1 , result = 0 ; result = N - 1 ; int i = result ; while ( i > 0 ) { fact = fact * i ; i -- ; } return fact / 2 ; } int main ( ) { int N = 5 ; int Number = Cycles ( N ) ; cout << " Hamiltonian ▁ cycles ▁ = ▁ " << Number ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int n , int a [ ] , int m ) { int k = n / m ; vector < vector < int > > val ( m ) ; for ( int i = 0 ; i < n ; ++ i ) { val [ a [ i ] % m ] . push_back ( i ) ; } long long ans = 0 ; vector < pair < int , int > > extra ; for ( int i = 0 ; i < 2 * m ; ++ i ) { int cur = i % m ; while ( int ( val [ cur ] . size ( ) ) > k ) { int elem = val [ cur ] . back ( ) ; val [ cur ] . pop_back ( ) ; extra . push_back ( make_pair ( elem , i ) ) ; } while ( int ( val [ cur ] . size ( ) ) < k && ! extra . empty ( ) ) { int elem = extra . back ( ) . first ; int mmod = extra . back ( ) . second ; extra . pop_back ( ) ; val [ cur ] . push_back ( elem ) ; ans += i - mmod ; } } return ans ; } int main ( ) { int m = 3 ; int a [ ] = { 3 , 2 , 0 , 6 , 10 , 12 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minOperations ( n , a , m ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; int findAndSum ( int arr [ ] , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { bool count_on = 0 ; int l = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) if ( count_on ) l ++ ; else { count_on = 1 ; l ++ ; } else if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = 0 ; l = 0 ; } } if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = 0 ; l = 0 ; } mul *= 2 ; } return sum ; } int main ( ) { int arr [ ] = { 7 , 1 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findAndSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; } int main ( ) { int Sx = 0 , Sy = 0 , Dx = 0 , Dy = 0 ; int x = 3 , y = 4 ; if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int getPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; } int main ( ) { int a [ ] = { 2 , 4 , 3 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getPairs ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } bool isDigitSumOne ( int nm ) { while ( nm > 9 ) { int sum_digit = 0 ; while ( nm > 0 ) { int digit = nm % 10 ; sum_digit = sum_digit + digit ; nm = nm / 10 ; } nm = sum_digit ; } if ( nm == 1 ) return true ; else return false ; } void printValidNums ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( isComposite ( i ) && isDigitSumOne ( i ) ) cout << i << " ▁ " ; } } int main ( void ) { int l = 10 , r = 100 ; printValidNums ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; } int main ( ) { int N = 5 , I = 2 ; cout << " Leaf ▁ nodes ▁ = ▁ " << calcNodes ( N , I ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll mod = 1000000007 ; ll arr [ 1000001 ] = { 0 } ; void cal_factorial ( ) { arr [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000000 ; i ++ ) { arr [ i ] = ( arr [ i - 1 ] * i ) % mod ; } } ll mod_exponent ( ll num , ll p ) { if ( p == 0 ) return 1 ; if ( p & 1 ) { return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ) % mod ; } else if ( ! ( p & 1 ) ) return ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ; } ll getCount ( ll x , ll y ) { ll ans = arr [ x + y - 1 ] ; ans *= mod_exponent ( arr [ x ] , mod - 2 ) ; ans %= mod ; ans *= mod_exponent ( arr [ y ] , mod - 2 ) ; ans %= mod ; ans *= ( x - y ) ; ans %= mod ; return ans ; } int main ( ) { cal_factorial ( ) ; ll x = 3 , y = 1 ; cout << getCount ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { cout << " - 1" ; return ; } cout << ( a - b ) / 2 << " ▁ " << ( a + b ) / 2 ; } int main ( ) { int a = 12 , b = 8 ; findValues ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Data { double x , y ; } ; double inv_interpolate ( Data d [ ] , int n , double y ) { double x = 0 ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { double xi = d [ i ] . x ; for ( j = 0 ; j < n ; j ++ ) { if ( j != i ) { xi = xi * ( y - d [ j ] . y ) / ( d [ i ] . y - d [ j ] . y ) ; } } x += xi ; } return x ; } int main ( ) { Data d [ ] = { { 1.27 , 2.3 } , { 2.25 , 2.95 } , { 2.5 , 3.5 } , { 3.6 , 5.1 } } ; int n = 4 ; double y = 4.5 ; cout << " Value ▁ of ▁ x ▁ at ▁ y ▁ = ▁ 4.5 ▁ : ▁ " << inv_interpolate ( d , n , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double mixtureConcentration ( int n , int p [ ] ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; } int main ( ) { int arr [ ] = { 0 , 20 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << mixtureConcentration ( n , arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1e5 + 5 ; const int MOD = 1e9 + 7 ; #define ll  long long NEW_LINE int check ( int num , int a , int b ) { while ( num ) { int rem = num % 10 ; num /= 10 ; if ( rem != a && rem != b ) return 0 ; } return 1 ; } ll power ( ll x , ll y ) { ll ans = 1 ; while ( y ) { if ( y & 1 ) ans = ( ans * x ) % MOD ; y >>= 1 ; x = ( x * x ) % MOD ; } return ans % MOD ; } int modInverse ( int x ) { return power ( x , MOD - 2 ) ; } ll countNumbers ( int n , int a , int b ) { ll fact [ MAX ] , inv [ MAX ] ; ll ans = 0 ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) { fact [ i ] = ( 1LL * fact [ i - 1 ] * i ) ; fact [ i ] %= MOD ; } inv [ MAX - 1 ] = modInverse ( fact [ MAX - 1 ] ) ; for ( int i = MAX - 2 ; i >= 0 ; i -- ) { inv [ i ] = ( inv [ i + 1 ] * ( i + 1 ) ) ; inv [ i ] %= MOD ; } if ( a < b ) swap ( a , b ) ; for ( int s = n ; s <= 9 * n ; s ++ ) { if ( ! check ( s , a , b ) ) continue ; if ( s < n * b || ( s - n * b ) % ( a - b ) != 0 ) continue ; int numDig = ( s - n * b ) / ( a - b ) ; if ( numDig > n ) continue ; ll curr = fact [ n ] ; curr = ( curr * inv [ numDig ] ) % MOD ; curr = ( curr * inv [ n - numDig ] ) % MOD ; ans = ( ans + curr ) % MOD ; } return ans ; } int main ( ) { int n = 3 , a = 1 , b = 3 ; cout << countNumbers ( n , a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOddSquares ( int n , int m ) { return ( int ) pow ( m , 0.5 ) - ( int ) pow ( n - 1 , 0.5 ) ; } int main ( ) { int n = 5 , m = 100 ; cout << " Count ▁ is ▁ " << ( m - n + 1 ) - countOddSquares ( n , m ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; } int main ( ) { int R = 4 , C = 5 , M = 2 ; cout << Square ( R , C , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; } int main ( ) { int n = 2 , m = 5 ; cout << findNumber ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkTriangularSumRepresentation ( int n ) { unordered_set < int > tri ; int i = 1 ; while ( 1 ) { int x = i * ( i + 1 ) / 2 ; if ( x >= n ) break ; tri . insert ( x ) ; i ++ ; } for ( auto tm : tri ) if ( tri . find ( n - tm ) != tri . end ( ) ) return true ; return false ; } int main ( ) { int n = 24 ; checkTriangularSumRepresentation ( n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long digitsCount ( long long n ) { int len = 0 ; while ( n > 0 ) { len ++ ; n /= 10 ; } return len ; } long long absoluteFirstLast ( long long n , int x ) { int i = 0 , mod = 1 ; while ( i < x ) { mod *= 10 ; i ++ ; } int last = n % mod ; long long len = digitsCount ( n ) ; while ( len != x ) { n /= 10 ; len -- ; } int first = n ; return abs ( first - last ) ; } int main ( ) { long long n = 21546 , x = 2 ; cout << absoluteFirstLast ( n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void make_sequence ( int N ) { int arr [ N + 1 ] , sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( int i = 1 ; i <= N ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int N = 9 ; make_sequence ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; } int main ( ) { int L = 3 , R = 7 ; int odds = countOdd ( L , R ) ; int evens = ( R - L + 1 ) - odds ; cout << " Count ▁ of ▁ odd ▁ numbers ▁ is ▁ " << odds << endl ; cout << " Count ▁ of ▁ even ▁ numbers ▁ is ▁ " << evens << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; } int main ( ) { int n = 4 , m = 5 ; cout << getMinCost ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperation ( int n , int k , int a [ ] ) { for ( int i = k ; i < n ; i ++ ) { if ( a [ i ] != a [ k - 1 ] ) cout << ( -1 ) << endl ; } for ( int i = k - 2 ; i > -1 ; i -- ) { if ( a [ i ] != a [ k - 1 ] ) cout << ( i + 1 ) << endl ; } } int main ( ) { int n = 5 ; int k = 3 ; int a [ ] = { 2 , 1 , 1 , 1 , 1 } ; minOperation ( n , k , a ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n /= 10 ; } return cnt == k ; } int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } } int main ( ) { int n = 111 , m = 2 , k = 2 ; cout << findInt ( n , m , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int N = 5 , M = 1 ; int P = ( N * ( N - 1 ) ) / 2 ; cout << binomialCoeff ( P , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) cout << i * g << " ▁ " ; } int main ( ) { int n = 6 , g = 5 ; generateSequence ( n , g ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ; int f [ MAX ] = { 0 } ; int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] ) return f [ n ] ; int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int findLCMFibonacci ( int a , int b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; } int main ( ) { int a = 3 , b = 12 ; cout << findLCMFibonacci ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; } int main ( ) { int L = 5 , R = 15 ; cout << isEvenOrOdd ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int trailing_zeros ( int N ) { int count_of_two = 0 , count_of_five = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int val = i ; while ( val % 2 == 0 && val > 0 ) { val /= 2 ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val /= 5 ; count_of_five += i ; } } int ans = min ( count_of_two , count_of_five ) ; return ans ; } int main ( ) { int N = 12 ; cout << trailing_zeros ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define limit  1000000000 NEW_LINE #define MAX_PRIME  2000000 NEW_LINE #define MAX  1000000 NEW_LINE #define I_MAX  50000 NEW_LINE map < int , int > mp ; int b [ MAX ] ; int p [ MAX ] ; int j = 0 ; bool prime [ MAX_PRIME + 1 ] ; void SieveOfEratosthenes ( int n ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { b [ j ++ ] = p ; } } } int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void printSeries ( int n ) { SieveOfEratosthenes ( MAX_PRIME ) ; int i , g , k , l , m , d ; int ar [ I_MAX + 2 ] ; for ( i = 0 ; i < j ; i ++ ) { if ( ( b [ i ] * b [ i + 1 ] ) > limit ) break ; p [ i ] = b [ i ] ; mp [ b [ i ] * b [ i + 1 ] ] = 1 ; } d = 550 ; bool flag = false ; for ( k = 2 ; ( k < d - 1 ) && ! flag ; k ++ ) { for ( m = 2 ; ( m < d ) && ! flag ; m ++ ) { for ( l = m + k ; l < d ; l += k ) { if ( ( ( b [ l ] * b [ l + k ] ) < limit ) && ( l + k ) < d && p [ i - 1 ] != b [ l + k ] && p [ i - 1 ] != b [ l ] && mp [ b [ l ] * b [ l + k ] ] != 1 ) { if ( mp [ p [ i - 1 ] * b [ l ] ] != 1 ) { p [ i ] = b [ l ] ; mp [ p [ i - 1 ] * b [ l ] ] = 1 ; i ++ ; } } if ( i >= I_MAX ) { flag = true ; break ; } } } } for ( i = 0 ; i < n ; i ++ ) ar [ i ] = p [ i ] * p [ i + 1 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) cout << ar [ i ] << " ▁ " ; g = gcd ( ar [ n - 1 ] , ar [ n - 2 ] ) ; cout << g * 2 << endl ; } int main ( ) { int n = 4 ; printSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 620000 ; int prime [ MAX ] ; void Sieve ( ) { for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = 2 * i ; j < MAX ; j += i ) { prime [ j ] = 1 ; } } } } void printSequence ( int n ) { Sieve ( ) ; vector < int > v , u ; for ( int i = 13 ; i < MAX ; i ++ ) { if ( prime [ i ] == 0 ) { v . push_back ( i ) ; } } if ( n == 3 ) { cout << 6 << " ▁ " << 10 << " ▁ " << 15 ; return ; } int k ; for ( k = 0 ; k < n - 2 ; k ++ ) { if ( k % 3 == 0 ) { u . push_back ( v [ k ] * 6 ) ; } else if ( k % 3 == 1 ) { u . push_back ( v [ k ] * 15 ) ; } else { u . push_back ( v [ k ] * 10 ) ; } } k -- ; u . push_back ( v [ k ] * 7 ) ; u . push_back ( 7 * 11 ) ; u [ 0 ] = u [ 0 ] * 11 ; for ( int i = 0 ; i < u . size ( ) ; i ++ ) { cout << u [ i ] << " ▁ " ; } } int main ( ) { int n = 4 ; printSequence ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOdd ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; } int countValidPairs ( int arr [ ] , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countValidPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string isDivisible ( long long int n ) { long long int temp = n ; int sum = 0 ; while ( n ) { int k = n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; } int main ( ) { long long int n = 123 ; cout << isDivisible ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string getResult ( long long int n ) { string st = std :: to_string ( n ) ; int sum = 0 ; for ( char i : st ) { sum = sum + ( int ) i ; } if ( n % sum == 0 ) return " Yes " ; else return " No " ; } int main ( ) { int n = 123 ; cout << getResult ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digitProduct ( int n ) { int prod = 1 ; while ( n ) { prod = prod * ( n % 10 ) ; n = n / 10 ; } return prod ; } void printMultiplicativePrimes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] && prime [ digitProduct ( i ) ] ) cout << i << " ▁ " ; } } int main ( ) { int n = 10 ; printMultiplicativePrimes ( n ) ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } bool coPrime ( ll n1 , ll n2 ) { if ( gcd ( n1 , n2 ) == 1 ) return true ; else return false ; } ll largestCoprime ( ll N ) { ll half = floor ( N / 2 ) ; while ( coPrime ( N , half ) == false ) half -- ; return half ; } int main ( ) { ll n = 50 ; cout << largestCoprime ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long largestCoprime ( long long N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; } int main ( ) { long long int n = 50 ; cout << largestCoprime ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSafePrimes ( int n ) { int prime [ n + 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = 0 ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] != 0 ) { int temp = ( 2 * i ) + 1 ; if ( temp <= n && prime [ temp ] != 0 ) prime [ temp ] = 2 ; } } for ( int i = 5 ; i <= n ; i ++ ) if ( prime [ i ] == 2 ) cout << i << " ▁ " ; } int main ( ) { int n = 20 ; printSafePrimes ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > Divisors ( int x ) { int c = 0 ; vector < int > v ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . push_back ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . push_back ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . push_back ( c ) ; v . push_back ( x ) ; return v ; } int MinOperations ( int a , int b ) { vector < int > va = Divisors ( a ) ; vector < int > vb = Divisors ( b ) ; if ( va [ 3 ] != vb [ 3 ] ) return -1 ; int minOperations = abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) ; return minOperations ; } int main ( ) { int a = 14 , b = 28 ; cout << MinOperations ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestOddDigit ( int n ) { int maxOdd = -1 ; while ( n > 0 ) { int digit = n % 10 ; if ( digit % 2 == 1 && digit > maxOdd ) maxOdd = digit ; n = n / 10 ; } return maxOdd ; } int getProduct ( int n ) { int maxOdd = largestOddDigit ( n ) ; if ( maxOdd == -1 ) return -1 ; return ( n * maxOdd ) ; } int main ( ) { int n = 12345 ; cout << getProduct ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int x ) { long long left = 1 , right = x ; while ( left <= right ) { long long mid = ( left + right ) / 2 ; if ( mid * mid == x ) { return true ; } if ( mid * mid < x ) { left = mid + 1 ; } else { right = mid - 1 ; } } return false ; } int main ( ) { int x = 2500 ; if ( isPerfectSquare ( x ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isStrongPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n > mean ) return true ; else return false ; } int main ( ) { int n = 11 ; if ( isStrongPrime ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNum ( int n , int k ) { int x = __builtin_popcount ( n ) ; if ( k < x k > n ) { cout << " - 1" ; return ; } priority_queue < int > pq ; int two = 1 ; while ( n ) { if ( n & 1 ) { pq . push ( two ) ; } two = two * 2 ; n = n >> 1 ; } while ( pq . size ( ) < k ) { int el = pq . top ( ) ; pq . pop ( ) ; pq . push ( el / 2 ) ; pq . push ( el / 2 ) ; } int ind = 0 ; while ( ind < k ) { cout << pq . top ( ) << " ▁ " ; pq . pop ( ) ; ind ++ ; } } int main ( ) { int n = 9 , k = 4 ; printNum ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define n  1000002 NEW_LINE #define ll  long long int NEW_LINE ll phi [ n + 2 ] , ans [ n + 2 ] ; void ETF ( ) { for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { phi [ i ] = i - 1 ; for ( int j = 2 * i ; j <= n ; j += i ) { phi [ j ] = ( phi [ j ] * ( i - 1 ) ) / i ; } } } } ll LcmSum ( int m ) { ETF ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j += i ) { ans [ j ] += ( i * phi [ i ] ) ; } } ll answer = ans [ m ] ; answer = ( answer + 1 ) * m ; answer = answer / 2 ; return answer ; } int main ( ) { int m = 5 ; cout << LcmSum ( m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int setBits ( int n ) { int count = 0 ; while ( n ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int setbits_x = setBits ( a [ i ] ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int setbits_y = setBits ( a [ j ] ) ; int setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) ; if ( setbits_x + setbits_y == setbits_xor_xy ) count ++ ; } } return count ; } int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int findPossibleDerivables ( int arr [ ] , int n , int D , int A , int B ) { int gcdAB = gcd ( A , B ) ; int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( abs ( arr [ i ] - D ) % gcdAB ) == 0 ) { counter ++ ; } } return counter ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 7 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int D = 5 , A = 4 , B = 2 ; cout << findPossibleDerivables ( arr , n , D , A , B ) << " STRNEWLINE " ; int a [ ] = { 1 , 2 , 3 } ; n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; D = 6 , A = 3 , B = 2 ; cout << findPossibleDerivables ( a , n , D , A , B ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; } int main ( ) { int n = 3 ; cout << calSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getElements ( int a , int arr [ ] , int n ) { int elements [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) cout << elements [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 13 , 2 , 6 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int a = 5 ; getElements ( a , arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int distinctDigitSum ( int n ) { bool used [ 10 ] ; int sum = 0 ; while ( n > 0 ) { int digit = n % 10 ; if ( ! used [ digit ] ) { used [ digit ] = true ; sum += digit ; } n = ( int ) n / 10 ; } return sum ; } string checkSum ( int m , int n ) { int sumM = distinctDigitSum ( m ) ; int sumN = distinctDigitSum ( n ) ; if ( sumM != sumN ) return " YES " ; return " NO " ; } int main ( ) { int m = 2452 , n = 9222 ; cout << ( checkSum ( m , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int countPairs ( int a [ ] , int n ) { int count = 0 ; unordered_map < int , int > m ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime ( a [ i ] ^ a [ j ] ) && m [ a [ i ] ^ a [ j ] ] == 0 ) { m [ ( a [ i ] ^ a [ j ] ) ] ++ ; count ++ ; } } } return count ; } int main ( ) { int a [ ] = { 10 , 12 , 23 , 45 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  1000001 NEW_LINE int spf [ MAXN ] ; void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } int sumFactors ( int arr [ ] , int n ) { sieve ( ) ; std :: map < int , int > map ; for ( int i = 0 ; i < n ; ++ i ) map [ arr [ i ] ] = 1 ; int sum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int num = arr [ i ] ; while ( num != 1 && map [ spf [ num ] ] == 1 ) { num /= spf [ num ] ; } if ( num == 1 ) sum += arr [ i ] ; } return sum ; } int main ( ) { int arr [ ] = { 5 , 11 , 55 , 25 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumFactors ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int doubleFactorial ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { fact = fact * i ; } return fact ; } int hermiteNumber ( int n ) { if ( n % 2 == 1 ) return 0 ; else { int number = ( pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ; if ( ( n / 2 ) % 2 == 1 ) number = number * -1 ; return number ; } } int main ( ) { int n = 6 ; cout << hermiteNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005 NEW_LINE #define MAX  1e18 NEW_LINE vector < long int > powers ; set < long int > squares ; set < long int > s ; void powersPrecomputation ( ) { for ( long int i = 2 ; i < N ; i ++ ) { squares . insert ( i * i ) ; if ( squares . find ( i ) != squares . end ( ) ) continue ; long int temp = i ; while ( i * i <= MAX / temp ) { temp *= ( i * i ) ; s . insert ( temp ) ; } } for ( auto x : s ) powers . push_back ( x ) ; } long int calculateAnswer ( long int L , long int R ) { powersPrecomputation ( ) ; long int perfectSquares = floor ( sqrtl ( R ) ) - floor ( sqrtl ( L - 1 ) ) ; long int high = upper_bound ( powers . begin ( ) , powers . end ( ) , R ) - powers . begin ( ) ; long int low = lower_bound ( powers . begin ( ) , powers . end ( ) , L ) - powers . begin ( ) ; long perfectPowers = perfectSquares + ( high - low ) ; long ans = ( R - L + 1 ) - perfectPowers ; return ans ; } int main ( ) { long int L = 13 , R = 20 ; cout << calculateAnswer ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll getSum ( int n , int d ) { ll sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 10 == d ) sum += i ; } return sum ; } int main ( ) { int n = 30 , d = 3 ; cout << getSum ( n , d ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printThreeParts ( int N ) { if ( N % 3 == 0 ) cout << " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " << N - 2 << endl ; else cout << " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " << N - 3 << endl ; } int main ( ) { int N = 10 ; printThreeParts ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigitsToBeRemoved ( int N , int K ) { string s = to_string ( N ) ; int res = 0 ; int f_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( K == 0 ) return res ; if ( s [ i ] == '0' ) { f_zero = 1 ; K -- ; } else res ++ ; } if ( ! K ) return res ; else if ( f_zero ) return s . size ( ) - 1 ; return -1 ; } int main ( ) { int N = 10904025 , K = 2 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; N = 1000 , K = 5 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; N = 23985 , K = 2 ; cout << countDigitsToBeRemoved ( N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } int largestPalindrome ( int A [ ] , int n ) { int currentMax = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > currentMax && isPalindrome ( A [ i ] ) ) currentMax = A [ i ] ; } return currentMax ; } int main ( ) { int A [ ] = { 1 , 232 , 54545 , 999991 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << largestPalindrome ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int N ) { for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; } int getDifference ( int N ) { if ( N == 0 ) return 2 ; else if ( N == 1 ) return 1 ; else if ( isPrime ( N ) ) return 0 ; int aboveN = -1 , belowN = -1 ; int n1 ; n1 = N + 1 ; while ( true ) { if ( isPrime ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPrime ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } int diff1 = aboveN - N ; int diff2 = N - belowN ; return min ( diff1 , diff2 ) ; } int main ( ) { int N = 25 ; cout << getDifference ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int arr [ ] , int x , int n ) { long long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = sqrt ( arr [ i ] ) ; if ( floor ( x ) == ceil ( x ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 13 ; if ( check ( arr , x , n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1e5 ; int findLargestDivisor ( int n ) { int m = n ; set < int , greater < int > > s ; s . insert ( 1 ) ; s . insert ( n ) ; for ( int i = 2 ; i < sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { s . insert ( n / i ) ; s . insert ( i ) ; while ( m % i == 0 ) m /= i ; } } if ( m > 1 ) s . insert ( m ) ; vector < int > vec ; for ( int i = 2 ; i <= MAX ; i ++ ) vec . push_back ( i * i ) ; for ( auto d : s ) { int divi = 0 ; for ( int j = 0 ; j < vec . size ( ) && vec [ j ] <= d ; j ++ ) { if ( d % vec [ j ] == 0 ) { divi = 1 ; break ; } } if ( ! divi ) return d ; } } int main ( ) { int n = 12 ; cout << findLargestDivisor ( n ) << endl ; n = 97 ; cout << findLargestDivisor ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int NCR ( int n , int r ) { int numerator = 1 ; int denominator = 1 ; while ( r > 0 ) { numerator *= n ; denominator *= r ; n -- ; r -- ; } return ( numerator / denominator ) ; } int findWays ( int arr [ ] , int n ) { map < int , int > count ; if ( n < 4 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { count [ arr [ i ] ] ++ ; } int remaining_choices = 4 ; int ans = 1 ; for ( auto iter = count . rbegin ( ) ; iter != count . rend ( ) ; ++ iter ) { int number = iter -> first ; int frequency = iter -> second ; int toSelect = min ( remaining_choices , frequency ) ; ans = ans * NCR ( frequency , toSelect ) ; remaining_choices -= toSelect ; if ( ! remaining_choices ) { break ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxQuadrupleWays = findWays ( arr , n ) ; cout << maxQuadrupleWays ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long getFinalElement ( long n ) { long finalNum ; for ( finalNum = 2 ; finalNum * 2 <= n ; finalNum *= 2 ) ; return finalNum ; } int main ( ) { int N = 12 ; cout << getFinalElement ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinimumMaximumPairs ( int n , int m ) { int max_pairs = ( ( n - m + 1 ) * ( n - m ) ) / 2 ; int min_pairs = m * ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 + ceil ( ( n - m ) / double ( m ) ) * ( ( n - m ) % m ) ; cout << " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " << min_pairs << " STRNEWLINE " ; cout << " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " << max_pairs << " STRNEWLINE " ; } int main ( ) { int n = 5 , m = 2 ; MinimumMaximumPairs ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findGreater ( int a , int b ) { long double x = ( long double ) a * ( long double ) ( log ( ( long double ) ( b ) ) ) ; long double y = ( long double ) b * ( long double ) ( log ( ( long double ) ( a ) ) ) ; if ( y > x ) { cout << " a ^ b ▁ is ▁ greater " << endl ; } else if ( y < x ) { cout << " b ^ a ▁ is ▁ greater " << endl ; } else { cout << " Both ▁ are ▁ equal " << endl ; } } int main ( ) { int a = 3 , b = 5 , c = 2 , d = 4 ; findGreater ( a , b ) ; findGreater ( c , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE #define m  1000000007 NEW_LINE int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } ll modexp ( ll x , ll n ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) ; } } ll getFractionModulo ( ll a , ll b ) { ll c = gcd ( a , b ) ; a = a / c ; b = b / c ; ll d = modexp ( b , m - 2 ) ; ll ans = ( ( a % m ) * ( d % m ) ) % m ; return ans ; } int main ( ) { ll a = 2 , b = 6 ; cout << getFractionModulo ( a , b ) << endl ; return 0 ; }
#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int maxPrimeFactors ( int n ) { int num = n ; int maxPrime = -1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n /= 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) maxPrime = n ; int sum = maxPrime + num ; return sum ; } int main ( ) { int n = 19 ; cout << maxPrimeFactors ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int sumOfDigits ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; } int findNumber ( int n ) { int i = n - 1 ; while ( i > 0 ) { if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) return i ; i -- ; } return -1 ; } int main ( ) { int n = 824 ; cout << findNumber ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; } int main ( ) { int N = 6 ; cout << findNth ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define N  4 NEW_LINE void predictMatrix ( int arr [ N ] [ N ] , int range1a , int range1b , int range0a , int range0b , int K , int b [ N ] [ N ] ) { int c = 0 ; while ( K -- ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { c = 0 ; if ( i > 0 && arr [ i - 1 ] [ j ] == 1 ) c ++ ; if ( j > 0 && arr [ i ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j > 0 && arr [ i - 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i < N - 1 && arr [ i + 1 ] [ j ] == 1 ) c ++ ; if ( j < N - 1 && arr [ i ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j < N - 1 && arr [ i + 1 ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j > 0 && arr [ i + 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j < N - 1 && arr [ i - 1 ] [ j + 1 ] == 1 ) c ++ ; if ( arr [ i ] [ j ] == 1 ) { if ( c >= range1a && c <= range1b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } if ( arr [ i ] [ j ] == 0 ) { if ( c >= range0a && c <= range0b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } } } for ( int k = 0 ; k < N ; k ++ ) for ( int m = 0 ; m < N ; m ++ ) arr [ k ] [ m ] = b [ k ] [ m ] ; } } int main ( ) { int arr [ N ] [ N ] = { 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 } ; int range1a = 2 , range1b = 2 ; int range0a = 2 , range0b = 3 ; int K = 3 , b [ N ] [ N ] = { 0 } ; predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) ; for ( int i = 0 ; i < N ; i ++ ) { cout << endl ; for ( int j = 0 ; j < N ; j ++ ) cout << b [ i ] [ j ] << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; } int main ( ) { int n = 3 ; cout << countMoves ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int N ) { return ( pow ( 10 , N ) - 1 ) - ( pow ( 10 , N ) - pow ( 8 , N ) ) / 2 ; } int main ( ) { int n = 2 ; cout << countNumbers ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ; int calcDeterminant ( int arr [ ] ) { int determinant = 0 ; for ( int i = 0 ; i < N ; i ++ ) { determinant += pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; } int main ( ) { int arr [ ] = { 4 , 5 , 3 } ; cout << calcDeterminant ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; } int main ( ) { int k = 3 , l = 10 , r = 10 ; cout << minimumMoves ( k , l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) ; return sum ; } int sumEven ( int l , int r ) { return sumNatural ( r / 2 ) - sumNatural ( ( l - 1 ) / 2 ) ; } int main ( ) { int l = 2 , r = 5 ; cout << " Sum ▁ of ▁ Natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " << sumEven ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisibleRec ( int x , int a , int b , int n ) { if ( x > n ) return false ; if ( n % x == 0 ) return true ; return ( isDivisibleRec ( x * 10 + a , a , b , n ) || isDivisibleRec ( x * 10 + b , a , b , n ) ) ; } bool isDivisible ( int a , int b , int n ) { return isDivisibleRec ( a , a , b , n ) || isDivisibleRec ( b , a , b , n ) ; } int main ( ) { int a = 3 , b = 5 , n = 53 ; if ( isDivisible ( a , b , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > getPerfectSquares ( int n ) { vector < int > perfectSquares ; int current = 1 , i = 1 ; while ( current <= n ) { perfectSquares . push_back ( current ) ; current = static_cast < int > ( pow ( ++ i , 2 ) ) ; } return perfectSquares ; } int maxPairSum ( vector < int > & arr ) { int n = arr . size ( ) ; int max , secondMax ; if ( arr [ 0 ] > arr [ 1 ] ) { max = arr [ 0 ] ; secondMax = arr [ 1 ] ; } else { max = arr [ 1 ] ; secondMax = arr [ 0 ] ; } for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return ( max + secondMax ) ; } int countPairsWith ( int n , vector < int > & perfectSquares , unordered_set < int > & nums ) { int count = 0 ; for ( int i = 0 ; i < perfectSquares . size ( ) ; i ++ ) { int temp = perfectSquares [ i ] - n ; if ( temp > n && find ( nums . begin ( ) , nums . end ( ) , temp ) != nums . end ( ) ) { count ++ ; } } return count ; } int countPairs ( vector < int > & arr ) { int i , n = arr . size ( ) ; int max = maxPairSum ( arr ) ; vector < int > perfectSquares = getPerfectSquares ( max ) ; unordered_set < int > nums ; for ( i = 0 ; i < n ; i ++ ) { nums . insert ( arr [ i ] ) ; } int count = 0 ; for ( i = 0 ; i < n ; i ++ ) { count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; } return count ; } int main ( ) { vector < int > arr = { 2 , 3 , 6 , 9 , 10 , 20 } ; cout << countPairs ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int findEle ( int arr [ ] , int n ) { ll sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return -1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findEle ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; } int suminRange ( int l , int r ) { return sumNatural ( r ) - sumNatural ( l - 1 ) ; } int main ( ) { int l = 2 , r = 5 ; cout << " Sum ▁ of ▁ Natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " << suminRange ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool divisibleBy3 ( string number ) { int sumOfDigit = 0 ; for ( int i = 0 ; i < number . length ( ) ; i ++ ) sumOfDigit += number [ i ] - '0' ; if ( sumOfDigit % 3 == 0 ) return true ; return false ; } bool divisibleBy25 ( string number ) { if ( number . length ( ) < 2 ) return false ; int length = number . length ( ) ; int lastTwo = ( number [ length - 2 ] - '0' ) * 10 + ( number [ length - 1 ] - '0' ) ; if ( lastTwo % 25 == 0 ) return true ; return false ; } bool divisibleBy75 ( string number ) { if ( divisibleBy3 ( number ) && divisibleBy25 ( number ) ) return true ; return false ; } int main ( ) { string number = "754586672150" ; bool divisible = divisibleBy75 ( number ) ; if ( divisible ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; } int main ( ) { int A = 8 , Lcm = 8 , Hcf = 1 ; int result = otherNumber ( A , Lcm , Hcf ) ; cout << " B ▁ = ▁ " << result ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float successiveChange ( int arr [ ] , int N ) { float var1 , var2 , result = 0 ; var1 = arr [ 0 ] ; var2 = arr [ 1 ] ; result = var1 + var2 + ( float ( var1 * var2 ) / 100 ) ; for ( int i = 2 ; i < N ; i ++ ) result = result + arr [ i ] + ( float ( result * arr [ i ] ) / 100 ) ; return result ; } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; float result = successiveChange ( arr , N ) ; cout << " Percentage ▁ change ▁ is ▁ = ▁ " << result << " ▁ % " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumNumbers ( int n , int s ) { if ( s % n ) return s / n + 1 ; else return s / n ; } int main ( ) { int n = 5 ; int s = 11 ; cout << minimumNumbers ( n , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll sumAP ( ll n , ll d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } ll sumMultiples ( ll A , ll B , ll n ) { n -- ; ll common = ( A * B ) / __gcd ( A , B ) ; return sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ; } int main ( ) { ll n = 100 , A = 5 , B = 10 ; cout << " Sum ▁ = ▁ " << sumMultiples ( A , B , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } bool isPossible ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) return true ; else return false ; } int main ( ) { int n = 13 ; if ( isPossible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int contiguousPerfectSquare ( int arr [ ] , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = sqrt ( arr [ i ] ) ; a = b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; } int main ( ) { int arr [ ] = { 9 , 75 , 4 , 64 , 121 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << contiguousPerfectSquare ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; } int main ( ) { int n = 15 ; cout << countPairs ( n ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <math.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; float getSum ( int a , int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { sum += ( i / pow ( a , i ) ) ; } return sum ; } int main ( ) { int a = 3 , n = 3 ; cout << ( getSum ( a , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getIndex ( int a [ ] , int n ) { if ( n == 1 ) return 0 ; int ptrL = 0 , ptrR = n - 1 , sumL = a [ 0 ] , sumR = a [ n - 1 ] ; while ( ptrR - ptrL > 1 ) { if ( sumL < sumR ) { ptrL ++ ; sumL += a [ ptrL ] ; } else if ( sumL > sumR ) { ptrR -- ; sumR += a [ ptrR ] ; } else { break ; } } return ptrL ; } int main ( ) { int a [ ] = { 2 , 7 , 9 , 8 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getIndex ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPosition ( int a [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m != 0 ) ) ; } int ans = -1 , max = -1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; } int main ( ) { int a [ ] = { 2 , 5 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = 2 ; cout << getPosition ( a , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) pow ( i , i ) ; int numerator = ( int ) pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; } int main ( ) { int n = 6 , r = 2 ; cout << "1 / " << calcFunction ( n , r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isExists ( int a [ ] , int n ) { unordered_map < int , int > freq ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; sum += a [ i ] ; } if ( sum % 2 == 0 ) { if ( freq [ sum / 2 ] ) return true ; } return false ; } int main ( ) { int a [ ] = { 5 , 1 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isExists ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; set < int > st ; void generateNumbers ( int n , int num , int a , int b ) { if ( num > 0 && num < n ) st . insert ( num ) ; if ( num >= n ) return ; if ( num * 10 + a > num ) generateNumbers ( n , num * 10 + a , a , b ) ; generateNumbers ( n , num * 10 + b , a , b ) ; } void printNumbers ( int n ) { for ( int i = 0 ; i <= 9 ; i ++ ) for ( int j = i + 1 ; j <= 9 ; j ++ ) generateNumbers ( n , 0 , i , j ) ; cout << " The ▁ numbers ▁ are : ▁ " ; while ( ! st . empty ( ) ) { cout << * st . begin ( ) << " ▁ " ; st . erase ( st . begin ( ) ) ; } } int main ( ) { int n = 12 ; printNumbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; } int main ( ) { int div [ ] = { 8 , 3 } ; int rem [ ] = { 2 , 2 } ; int N = sizeof ( div ) / sizeof ( div [ 0 ] ) ; cout << findNum ( div , rem , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string convert_to_words ( string num ) { int len = num . length ( ) ; if ( len == 0 len > 4 ) { return " " ; } string single_digits_temp [ ] = { " " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string single_digits [ ] = { " " , " first " , " second " , " third " , " fourth " , " fifth " , " sixth " , " seventh " , " eighth " , " ninth " } ; string two_digits [ ] = { " " , " tenth " , " eleventh " , " twelfth " , " thirteenth " , " fourteenth " , " fifteenth " , " sixteenth " , " seventeenth " , " eighteenth " , " nineteenth " } ; string tens_multiple [ ] = { " " , " tenth " , " twentieth " , " thirtieth " , " fortieth " , " fiftieth " , " sixtieth " , " seventieth " , " eightieth " , " ninetieth " } ; string tens_power [ ] = { " hundred " , " thousand " } ; string word = " " ; if ( len == 1 ) { word += single_digits [ num [ 0 ] - '0' ] ; return word ; } int i = 0 , ctr = 0 ; string s = " ▁ " ; while ( i < len ) { if ( len >= 3 ) { if ( num [ i ] != '0' ) { word += single_digits_temp [ num [ i ] - '0' ] + " ▁ " ; word += tens_power [ len - 3 ] + " ▁ " ; ctr ++ ; } len -- ; num . erase ( 0 , 1 ) ; } else { if ( ctr != 0 ) { s = " ▁ and ▁ " ; word . erase ( word . length ( ) - 1 ) ; } if ( num [ i + 1 ] == '0' ) if ( num [ i ] == '0' ) word = word + " th " ; else word += s + tens_multiple [ num [ i ] - '0' ] ; else if ( num [ i ] == '1' ) word += s + two_digits [ num [ i + 1 ] - '0' + 1 ] ; else { if ( num [ i ] != '0' ) word += s + tens_multiple [ num [ i ] - '0' ] . substr ( 0 , tens_multiple [ num [ i ] - '0' ] . length ( ) - 4 ) + " y ▁ " ; else word += s ; word += single_digits [ num [ i + 1 ] - '0' ] ; } i += 2 ; } if ( i == len ) { if ( word [ 0 ] == ' ▁ ' ) word . erase ( 0 , 1 ) ; } } return word ; } void Aronsons_sequence ( int n ) { string str = " T ▁ is ▁ the ▁ " ; int ind = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isalpha ( str [ i ] ) ) { ind += 1 ; } if ( str [ i ] == ' t ' or str [ i ] == ' T ' ) { n -= 1 ; str += convert_to_words ( to_string ( ind ) ) + " , ▁ " ; cout << ind << " , ▁ " ; } if ( n == 0 ) break ; } } int main ( void ) { int n = 6 ; Aronsons_sequence ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void niceIndices ( int A [ ] , int n ) { int sum = 0 ; map < int , int > m ; for ( int i = 0 ; i < n ; ++ i ) { m [ A [ i ] ] ++ ; sum += A [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { int k = sum - A [ i ] ; if ( k % 2 == 0 ) { k = k >> 1 ; if ( m . find ( k ) != m . end ( ) ) { if ( ( A [ i ] == k && m [ k ] > 1 ) || ( A [ i ] != k ) ) cout << ( i + 1 ) << " ▁ " ; } } } } int main ( ) { int A [ ] = { 8 , 3 , 5 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; niceIndices ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPieces ( int N ) { return 2 * N ; } int main ( ) { int N = 100 ; cout << countPieces ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long sumAP ( long long n , long long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } long long sumMultiples ( long long n ) { n -- ; return sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ; } int main ( ) { long long n = 24 ; cout << sumMultiples ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int ll ; ll gcd ( ll a , ll b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } ll powGCD ( ll a , ll n , ll b ) { for ( int i = 0 ; i < n ; i ++ ) a = a * a ; return gcd ( a , b ) ; } int main ( ) { ll a = 10 , b = 5 , n = 2 ; cout << powGCD ( a , n , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; } int main ( ) { int n = 3 , a = 5 , b = 2 ; cout << lastCoordinate ( n , a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; } int main ( ) { int N = 45 , K = 6 ; cout << " Smallest ▁ number ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ " << N << " that is divisible by " ▁ < < ▁ K ▁ < < ▁ " is " return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; } int main ( ) { int N = 45 , K = 6 ; cout << " Largest ▁ number ▁ smaller ▁ than ▁ or ▁ equal ▁ to ▁ " << N << " that is divisible by " < < ▁ K ▁ < < ▁ " is " return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisiblePalindrome ( int n ) { int hash [ 10 ] = { 0 } ; int digitSum = 0 ; while ( n ) { digitSum += n % 10 ; hash [ n % 10 ] ++ ; n /= 10 ; } if ( digitSum % 3 != 0 ) return false ; int oddCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount > 1 ) return false ; else return true ; } int main ( ) { int n = 34734 ; isDivisiblePalindrome ( n ) ? cout << " True " : cout << " False " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; } int dfs ( int src , vector < int > adj [ ] , vector < bool > & visited ) { visited [ src ] = true ; int count = 1 ; for ( int i = 0 ; i < adj [ src ] . size ( ) ; i ++ ) if ( ! visited [ adj [ src ] [ i ] ] ) count += dfs ( adj [ src ] [ i ] , adj , visited ) ; return count ; } int findMinTime ( int arr [ ] , int P [ ] , int n ) { vector < int > adj [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { adj [ arr [ i ] ] . push_back ( P [ i ] ) ; } vector < bool > visited ( n + 1 ) ; int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! visited [ i ] ) { ans = lcm ( ans , dfs ( i , adj , visited ) ) ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int P [ ] = { 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinTime ( arr , P , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool productDivisible ( int n , int k ) { int product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) product *= n % 10 ; n = n / 10 ; position ++ ; } if ( product % k == 0 ) return true ; return false ; } int main ( ) { int n = 321922 ; int k = 3 ; if ( productDivisible ( n , k ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } int npr ( int n , int r ) { int pnr = factorial ( n ) / factorial ( n - r ) ; return pnr ; } int countPermutations ( int n , int r , int k ) { return factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ; } int main ( ) { int n = 8 ; int r = 5 ; int k = 2 ; cout << countPermutations ( n , r , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GIF ( float n ) { return floor ( n ) ; } int main ( ) { int n = 2.3 ; cout << GIF ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } int main ( ) { int m = 3 , n = 4 , k = 5 ; int totalTriangles = ncr ( m + n + k , 3 ) - ncr ( m , 3 ) - ncr ( n , 3 ) - ncr ( k , 3 ) ; cout << totalTriangles << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string isTriangleExists ( int a , int b , int c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " YES " ; else return " NO " ; else return " NO " ; } int main ( ) { int a = 50 , b = 60 , c = 70 ; cout << isTriangleExists ( a , b , c ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll fact ( int n ) { ll f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f = f * i ; return f ; } ll waysOfConsonants ( int size1 , int freq [ ] ) { ll ans = fact ( size1 ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) continue ; else ans = ans / fact ( freq [ i ] ) ; } return ans ; } ll waysOfVowels ( int size2 , int freq [ ] ) { return fact ( size2 ) / ( fact ( freq [ 0 ] ) * fact ( freq [ 4 ] ) * fact ( freq [ 8 ] ) * fact ( freq [ 14 ] ) * fact ( freq [ 20 ] ) ) ; } ll countWays ( string str ) { int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != ' a ' && str [ i ] != ' e ' && str [ i ] != ' i ' && str [ i ] != ' o ' && str [ i ] != ' u ' ) consonant ++ ; else vowel ++ ; } return waysOfConsonants ( consonant + 1 , freq ) * waysOfVowels ( vowel , freq ) ; } int main ( ) { string str = " geeksforgeeks " ; cout << countWays ( str ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; class GfG { public : int findX ( int n , int k ) { int r = n , v , u ; int m = sqrt ( k ) + 1 ; for ( int i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; } for ( u = v = 0 ; k % i == 0 ; v ++ ) { k /= i ; } if ( v > 0 ) { int t = n ; while ( t > 0 ) { t /= i ; u += t ; } r = min ( r , u / v ) ; } } return r ; } } ; int main ( ) { GfG g ; int n = 5 ; int k = 2 ; cout << g . findX ( n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact *= i ; return fact ; } int ncr ( int n , int r ) { int ncr = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; return ncr ; } int ways ( int m , int w , int n , int k ) { int ans = 0 ; while ( m >= k ) { ans += ncr ( m , k ) * ncr ( w , n - k ) ; k += 1 ; } return ans ; } int main ( ) { int m , w , n , k ; m = 7 ; w = 6 ; n = 5 ; k = 3 ; cout << ways ( m , w , n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int square ( int n ) { return n * n ; } int sum ( int n ) { if ( n == 0 ) return 0 ; return square ( ( n + 1 ) / 2 ) + sum ( n / 2 ) ; } return square ( n / 2 ) + sum ( n / 2 ) ; } } int oddDivSum ( int a , int b ) { return sum ( b ) - sum ( a - 1 ) ; } int main ( ) { int a = 3 , b = 9 ; cout << oddDivSum ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countBits ( int n ) { int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; } int main ( ) { int n = 32 ; cout << " Minimum ▁ value ▁ of ▁ K ▁ is ▁ = ▁ " << countBits ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = log ( a ) / log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; } bool isAchillesNumber ( int n ) { if ( isPowerful ( n ) && ! isPower ( n ) ) return true ; else return false ; } int main ( ) { int n = 72 ; if ( isAchillesNumber ( n ) ) cout << " YES " << endl ; else cout << " NO " << endl ; n = 36 ; if ( isAchillesNumber ( n ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } } if ( divCount % 2 ) { ++ res ; } } return res ; } int main ( ) { int a = 1 , b = 10 ; cout << OddDivCount ( a , b ) << endl ; return 0 ; }
#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int largestSquareFactor ( int num ) { int answer = 1 ; for ( int i = 2 ; i < sqrt ( num ) ; ++ i ) { int cnt = 0 ; int j = i ; while ( num % j == 0 ) { cnt ++ ; j *= i ; } if ( cnt & 1 ) { cnt -- ; answer *= pow ( i , cnt ) ; } else { answer *= pow ( i , cnt ) ; } } return answer ; } int main ( ) { int N = 420 ; cout << largestSquareFactor ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestPrimeFactor ( int n ) { int max = -1 ; while ( n % 2 == 0 ) { max = 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { max = i ; n = n / i ; } } if ( n > 2 ) max = n ; return max ; } bool checkUnusual ( int n ) { int factor = largestPrimeFactor ( n ) ; if ( factor > sqrt ( n ) ) { return true ; } else { return false ; } } int main ( ) { int n = 14 ; if ( checkUnusual ( n ) ) { cout << " YES " << " STRNEWLINE " ; } else { cout << " NO " << " STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Nth_Term ( int n ) { return ( 3 * pow ( n , 2 ) - n + 2 ) / ( 2 ) ; } int main ( ) { int N = 5 ; cout << Nth_Term ( N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPermutations ( int N , int B ) { int x = pow ( B , N ) ; int y = pow ( B , N - 1 ) ; cout << x - y << " STRNEWLINE " ; } int main ( ) { int N = 6 ; int B = 4 ; countPermutations ( N , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateDifference ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; vector < bool > prime ( max_val + 1 , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int P1 = 1 , P2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { P1 *= arr [ i ] ; } else if ( arr [ i ] != 1 ) { P2 *= arr [ i ] ; } } return abs ( P2 - P1 ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 10 , 15 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << calculateDifference ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_odd_pair ( int n , int a [ ] ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } int ans = odd * even * 2 ; return ans ; } int count_even_pair ( int odd_sum_pairs , int n ) { int total_pairs = ( n * ( n - 1 ) ) ; int ans = total_pairs - odd_sum_pairs ; return ans ; } int main ( ) { int n = 6 ; int a [ ] = { 2 , 4 , 5 , 9 , 1 , 8 } ; int odd_sum_pairs = count_odd_pair ( n , a ) ; int even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) ; cout << " Even ▁ Sum ▁ Pairs ▁ = ▁ " << even_sum_pairs << endl ; cout << " Odd ▁ Sum ▁ Pairs = ▁ " << odd_sum_pairs << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSteps ( int n , int m , int a [ ] ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; } int main ( ) { int n = 3 , m = 3 ; int a [ ] = { 2 , 1 , 2 } ; cout << findSteps ( n , m , a ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void HexToBin ( string hexdec ) { long int i = 0 ; while ( hexdec [ i ] ) { switch ( hexdec [ i ] ) { case '0' : cout << "0000" ; break ; case '1' : cout << "0001" ; break ; case '2' : cout << "0010" ; break ; case '3' : cout << "0011" ; break ; case '4' : cout << "0100" ; break ; case '5' : cout << "0101" ; break ; case '6' : cout << "0110" ; break ; case '7' : cout << "0111" ; break ; case '8' : cout << "1000" ; break ; case '9' : cout << "1001" ; break ; case ' A ' : case ' a ' : cout << "1010" ; break ; case ' B ' : case ' b ' : cout << "1011" ; break ; case ' C ' : case ' c ' : cout << "1100" ; break ; case ' D ' : case ' d ' : cout << "1101" ; break ; case ' E ' : case ' e ' : cout << "1110" ; break ; case ' F ' : case ' f ' : cout << "1111" ; break ; default : cout << " Invalid hexadecimal digit " << hexdec [ i ] ; } i ++ ; } } int main ( ) { char hexdec [ 100 ] = "1AC5" ; cout << " Equivalent Binary value is : " HexToBin ( hexdec ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } void Count_pairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) ) count ++ ; } int ans = ( count * ( count - 1 ) ) / 2 ; cout << ans << " STRNEWLINE " ; } int main ( ) { int a [ ] = { 2 , 5 , 8 , 16 , 128 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Count_pairs ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = result * i ; return result ; } int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } int calculate_result ( int n ) { int result = 2 * nCr ( ( n - 2 ) , ( n / 2 - 1 ) ) ; return result ; } int main ( void ) { int a = 2 , b = 4 ; cout << calculate_result ( 2 * a ) << endl ; cout << calculate_result ( 2 * b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isHalfReducible ( int arr [ ] , int n , int m ) { int frequencyHash [ m + 1 ] ; int i ; memset ( frequencyHash , 0 , sizeof ( frequencyHash ) ) ; for ( i = 0 ; i < n ; i ++ ) { frequencyHash [ arr [ i ] % ( m + 1 ) ] ++ ; } for ( i = 0 ; i <= m ; i ++ ) { if ( frequencyHash [ i ] >= n / 2 ) break ; } if ( i <= m ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { int arr [ ] = { 8 , 16 , 32 , 3 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 7 ; isHalfReducible ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > arr ; void generateDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) arr . push_back ( i ) ; { arr . push_back ( i ) ; arr . push_back ( n / i ) ; } } } } double harmonicMean ( int n ) { generateDivisors ( n ) ; double sum = 0.0 ; int len = arr . size ( ) ; for ( int i = 0 ; i < len ; i ++ ) sum = sum + double ( n / arr [ i ] ) ; sum = double ( sum / n ) ; return double ( arr . size ( ) / sum ) ; } bool isOreNumber ( int n ) { double mean = harmonicMean ( n ) ; if ( mean - int ( mean ) == 0 ) return true ; else return false ; } int main ( ) { int n = 28 ; if ( isOreNumber ( n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digitProduct ( int digits [ ] , int start , int end ) { int pro = 1 ; for ( int i = start ; i <= end ; i ++ ) { pro *= digits [ i ] ; } return pro ; } bool isDistinct ( int N ) { string s = to_string ( N ) ; int len = s . length ( ) ; int digits [ len ] ; unordered_set < int > products ; for ( int i = 0 ; i < len ; i ++ ) { digits [ i ] = s [ i ] - '0' ; } for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i ; j < len ; j ++ ) { int val = digitProduct ( digits , i , j ) ; if ( products . find ( val ) != products . end ( ) ) return false ; else products . insert ( val ) ; } } return true ; } int main ( ) { int N = 324 ; if ( isDistinct ( N ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateAlternateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = pow ( fibo [ 0 ] , 2 ) + pow ( fibo [ 1 ] , 2 ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum -= fibo [ i ] ; else sum += fibo [ i ] ; } return sum ; } int main ( ) { int n = 8 ; cout << " Alternating ▁ Fibonacci ▁ Sum ▁ upto ▁ " << n << " ▁ terms : ▁ " << calculateAlternateSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getValue ( int n ) { int i = 0 , k = 1 ; while ( i < n ) { i = i + k ; k = k * 2 ; } return k / 2 ; } int main ( void ) { int n = 9 ; cout << getValue ( n ) << endl ; n = 1025 ; cout << getValue ( n ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE vector < int > arr ; void ulam ( ) { unordered_set < int > s ; arr . push_back ( 1 ) ; s . insert ( 1 ) ; arr . push_back ( 2 ) ; s . insert ( 2 ) ; for ( int i = 3 ; i < MAX ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . size ( ) ; j ++ ) { if ( s . find ( i - arr [ j ] ) != s . end ( ) && arr [ j ] != ( i - arr [ j ] ) ) count ++ ; if ( count > 2 ) break ; } if ( count == 2 ) { arr . push_back ( i ) ; s . insert ( i ) ; } } } int main ( ) { ulam ( ) ; int n = 9 ; cout << arr [ n - 1 ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; } int main ( ) { int n = 8 ; cout << nthKyneaNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; } bool isProthNumber ( int n ) { int k = 1 ; while ( k < ( n / k ) ) { if ( n % k == 0 ) { if ( isPowerOfTwo ( n / k ) ) return true ; } k = k + 2 ; } return false ; } int main ( ) { int n = 25 ; if ( isProthNumber ( n - 1 ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define ll  long int NEW_LINE int get_last_two_digit ( long long int N ) { if ( N <= 10 ) { ll ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; } int main ( ) { long long int N = 1 ; for ( N = 1 ; N <= 10 ; N ++ ) cout << " For ▁ N ▁ = ▁ " << N << " ▁ : ▁ " << get_last_two_digit ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isProductEven ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; } int main ( ) { int arr [ ] = { 2 , 4 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isProductEven ( arr , n ) ) cout << " Even " ; else cout << " Odd " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; } int main ( ) { int n = 6 ; cout << " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " << calculateSquareSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumMoves ( int a [ ] , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 } ; int x = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinimumMoves ( arr , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int SumOfDigits ( string str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( str [ i ] - '0' ) ; return sum ; } bool Divisible ( string str , int n ) { if ( SumOfDigits ( str , n ) % 3 == 0 and str [ n - 1 ] == '0' ) return true ; return false ; } int main ( ) { string str = "263730746028908374890" ; int n = str . size ( ) ; if ( Divisible ( str , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int k ) { if ( k <= 1 ) return false ; for ( int i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; } int check ( int num , int k ) { int flag = 1 ; for ( int i = 2 ; i < k ; i ++ ) { if ( num % i == 0 ) flag = 0 ; } if ( flag == 1 ) { if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; } int findCount ( int a , int b , int k ) { int count = 0 ; if ( ! isPrime ( k ) ) return 0 ; else { int ans ; for ( int i = a ; i <= b ; i ++ ) { ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; } int main ( ) { int a = 2020 , b = 6300 , k = 29 ; cout << findCount ( a , b , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE int findLargest ( int n , vector < int > & v ) { int flag = 0 ; ll sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( v [ i ] == 0 ) flag = 1 ; sum += v [ i ] ; } if ( ! flag ) cout << " Not ▁ possible " << endl ; else { sort ( v . begin ( ) , v . end ( ) , greater < int > ( ) ) ; if ( v [ 0 ] == 0 ) { cout << "0" << endl ; return 0 ; } else { int flag = 0 ; int y = sum % 3 ; if ( y != 0 ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( v [ i ] % 3 == y ) { v . erase ( v . begin ( ) + i ) ; flag = 1 ; break ; } } if ( flag == 0 ) { y = 3 - y ; int cnt = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( v [ i ] % 3 == y ) { v . erase ( v . begin ( ) + i ) ; cnt ++ ; if ( cnt >= 2 ) break ; } } } } if ( * v . begin ( ) == 0 ) cout << "0" << endl ; else for ( int i : v ) { cout << i ; } } } } int main ( ) { int n = 11 ; vector < int > v { 3 , 9 , 9 , 6 , 4 , 3 , 6 , 4 , 9 , 6 , 0 } ; findLargest ( n , v ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; } int main ( ) { int n = 43 ; if ( isPrime ( n ) && ( isPowerOfTwo ( n * 3 - 1 ) ) ) { cout << " YES STRNEWLINE " ; } else { cout << " NO STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findkth ( int n , int k ) { vector < int > v1 ; vector < int > v2 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v1 . push_back ( i ) ; if ( i != sqrt ( n ) ) v2 . push_back ( n / i ) ; } } reverse ( v2 . begin ( ) , v2 . end ( ) ) ; if ( k > ( v1 . size ( ) + v2 . size ( ) ) ) cout << " Doesn ' t ▁ Exist " ; else { if ( k <= v1 . size ( ) ) cout << v1 [ k - 1 ] ; else cout << v2 [ k - v1 . size ( ) - 1 ] ; } } int main ( ) { int n = 15 , k = 2 ; findkth ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll findF_N ( ll n ) { ll ans = 0 ; for ( ll i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; } int main ( ) { ll n = 3 ; cout << findF_N ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findNumber ( int n , int d ) { string ans = " " ; if ( d != 10 ) { ans += to_string ( d ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += " Impossible " ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; } int main ( ) { int n = 12 , d = 3 ; cout << findNumber ( n , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countDigits ( double val , long arr [ ] ) { while ( ( long ) val > 0 ) { long digit = ( long ) val % 10 ; arr [ ( int ) digit ] ++ ; val = ( long ) val / 10 ; } return ; } void countFrequency ( int x , int n ) { long freq_count [ 10 ] = { 0 } ; for ( int i = 1 ; i <= n ; i ++ ) { double val = pow ( ( double ) x , ( double ) i ) ; countDigits ( val , freq_count ) ; } for ( int i = 0 ; i <= 9 ; i ++ ) { cout << freq_count [ i ] << " ▁ " ; } } int main ( ) { int x = 15 , n = 3 ; countFrequency ( x , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE int sieve_Prime [ MAX + 4 ] = { 0 } , sieve_count [ MAX + 4 ] = { 0 } ; void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } } int main ( ) { form_sieve ( ) ; int n = 2 ; cout << " Count ▁ = ▁ " << ( sieve_count [ n ] + 1 ) << endl ; n = 3 ; cout << " Count ▁ = ▁ " << ( sieve_count [ n ] + 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } cout << " The ▁ matrix ▁ is STRNEWLINE " ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { cout << matrix [ row_index ] [ column_index ] << " ▁ " ; } cout << endl ; } cout << " Elements on Secondary diagonal : " for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index + column_index ) == size - 1 ) cout << matrix [ row_index ] [ column_index ] << " , ▁ " ; } } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } cout << " The ▁ matrix ▁ is STRNEWLINE " ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { cout << matrix [ row_index ] [ column_index ] << " ▁ " ; } cout << endl ; } cout << " Elements above Secondary diagonal are : " ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index + column_index ) < size - 1 ) cout << matrix [ row_index ] [ column_index ] << " , ▁ " ; } } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } cout << " The ▁ matrix ▁ is " << endl ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { cout << " TABSYMBOL " << matrix [ row_index ] [ column_index ] ; } cout << endl ; } cout << " Corner Elements are : " ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index == 0 row_index == size - 1 ) && ( column_index == 0 column_index == size - 1 ) ) cout << matrix [ row_index ] [ column_index ] << " , " ; } } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int matrix [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } cout << " The ▁ matrix ▁ is STRNEWLINE " ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { cout << " TABSYMBOL " << matrix [ row_index ] [ column_index ] ; } cout << endl ; } cout << " Boundary Elements are : " ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index == 0 row_index == size - 1 column_index == 0 column_index == size - 1 ) ) cout << matrix [ row_index ] [ column_index ] << " , ▁ " ; } } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > PrimeFactors ( int n ) { vector < int > v ; int x = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( x % i == 0 ) { v . push_back ( i ) ; while ( x % i == 0 ) x /= i ; } } if ( x > 1 ) v . push_back ( x ) ; return v ; } int GoodNumber ( int n ) { vector < int > v = PrimeFactors ( n ) ; int ans = 1 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ans *= v [ i ] ; return ans ; } int main ( ) { int n = 12 ; cout << GoodNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkSpecialPrime ( bool * sieve , int num ) { while ( num ) { if ( ! sieve [ num ] ) { return false ; } num /= 10 ; } return true ; } void findSpecialPrime ( int N ) { bool sieve [ N + 10 ] ; memset ( sieve , true , sizeof ( sieve ) ) ; sieve [ 0 ] = sieve [ 1 ] = false ; for ( long long i = 2 ; i <= N ; i ++ ) { if ( sieve [ i ] ) { for ( long long j = i * i ; j <= N ; j += i ) { sieve [ j ] = false ; } } } while ( true ) { if ( checkSpecialPrime ( sieve , N ) ) { cout << N << ' ' ; break ; } else N -- ; } } int main ( ) { findSpecialPrime ( 379 ) ; findSpecialPrime ( 100 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE vector < int > arr ; bool sprime [ MAX ] ; void computeSemiPrime ( ) { memset ( sprime , false , sizeof ( sprime ) ) ; for ( int i = 2 ; i < MAX ; i ++ ) { int cnt = 0 ; int num = i ; for ( int j = 2 ; cnt < 2 && j * j <= num ; ++ j ) { while ( num % j == 0 ) { } } if ( num > 1 ) ++ cnt ; if ( cnt == 2 ) { sprime [ i ] = true ; arr . push_back ( i ) ; } } } bool checkSemiPrime ( int n ) { int i = 0 ; while ( arr [ i ] <= n / 2 ) { if ( sprime [ n - arr [ i ] ] ) { return true ; } i ++ ; } return false ; } int main ( ) { computeSemiPrime ( ) ; int n = 30 ; if ( checkSemiPrime ( n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } int main ( ) { int n = 13 ; if ( isPrime ( n ) && ( n % 4 == 1 ) ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( ( a * sqrt ( 3 ) ) / ( sqrt ( 2 ) ) , 2 ) ; return area ; } int main ( ) { float a = 5 ; cout << area ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float heightCalculate ( int H , int n , int m ) { float N = n * 1.0 ; float M = m * 1.0 ; float h = H * sqrt ( N / ( N + M ) ) ; return h ; } int main ( ) { int H = 10 , n = 3 , m = 4 ; cout << heightCalculate ( H , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; } bool isNSqMinusnMSqPrime ( int m , int n ) { if ( n - m == 1 and isprime ( m + n ) ) return true ; else return false ; } int main ( ) { int m = 13 , n = 16 ; if ( isNSqMinusnMSqPrime ( m , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE void findsolution ( ll n , ll x , ll y ) { if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x y < n ) { cout << " No ▁ solution " ; return ; } cout << y - n + 1 ; while ( n -- > 1 ) cout << endl << 1 ; } int main ( ) { ll n , x , y ; n = 5 , x = 15 , y = 15 ; findsolution ( n , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPosition ( int n , int f , int b ) { return n - max ( f + 1 , n - b ) + 1 ; } int main ( ) { int n = 5 , f = 2 , b = 3 ; cout << findPosition ( n , f , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthOdd ( int n ) { return ( 2 * n - 1 ) ; } int main ( ) { int n = 10 ; cout << nthOdd ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthEven ( int n ) { return ( 2 * n ) ; } int main ( ) { int n = 10 ; cout << nthEven ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSolutions ( int a ) { int count = 0 ; for ( int i = 0 ; i <= a ; i ++ ) { if ( a == ( i + ( a ^ i ) ) ) count ++ ; } return count ; } int main ( ) { int a = 3 ; cout << countSolutions ( a ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSolutions ( int a ) { int count = __builtin_popcount ( a ) ; count = pow ( 2 , count ) ; return count ; } int main ( ) { int a = 3 ; cout << countSolutions ( a ) ; }
#include <iostream> NEW_LINE using namespace std ; double nthHarmonic ( int N ) { float harmonic = 1.00 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; } int main ( ) { int N = 8 ; cout << nthHarmonic ( N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + n - 3 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 5 * pow ( n , 2 ) - 5 * n ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 3 * pow ( n , 2 ) + n - 2 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 3 * pow ( n , 2 ) + 2 * n - 5 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 3 * n - 5 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 3 * pow ( n , 2 ) - 4 * n + 2 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 3 * n + 2 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <cmath> NEW_LINE using namespace std ; #define PI  3.1415926535 NEW_LINE double findAnglesA ( double a , double b , double c ) { double A = acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) ; return A * 180 / PI ; } double findAnglesB ( double a , double b , double c ) { double B = acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) ; return B * 180 / PI ; } void printAngles ( int a , int b , int c ) { double x = ( double ) a ; double y = ( double ) b ; double z = ( double ) c ; double A = findAnglesA ( x , y , z ) ; double B = findAnglesB ( x , y , z ) ; cout << " Angles ▁ are ▁ A ▁ = ▁ " << A << " , ▁ B ▁ = ▁ " << B << " , ▁ C ▁ = ▁ " << 90 << endl ; } void printOtherSides ( int n ) { int b , c ; if ( n & 1 ) { if ( n == 1 ) cout << -1 << endl ; else { b = ( n * n - 1 ) / 2 ; c = ( n * n + 1 ) / 2 ; cout << " Side ▁ b ▁ = ▁ " << b << " , ▁ Side ▁ c ▁ = ▁ " << c << endl ; } } else { if ( n == 2 ) cout << -1 << endl ; else { b = n * n / 4 - 1 ; c = n * n / 4 + 1 ; cout << " Side ▁ b ▁ = ▁ " << b << " , ▁ Side ▁ c ▁ = ▁ " << c << endl ; } } printAngles ( n , b , c ) ; } int main ( ) { int a = 12 ; printOtherSides ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ; } int main ( ) { int n = 3 ; cout << " Sum ▁ = ▁ " << calculateSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; } int main ( ) { int n = 3 ; cout << " Sum ▁ = ▁ " << calculateSum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 2 * pow ( n , 2 ) - n - 1 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 7 * n + 3 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkIfPowerIsolated ( int num ) { int input = num ; int count = 0 ; int factor [ num + 1 ] = { 0 } ; if ( num % 2 == 0 ) { while ( num % 2 == 0 ) { ++ count ; num /= 2 ; } factor [ 2 ] = count ; } for ( int i = 3 ; i * i <= num ; i += 2 ) { count = 0 ; while ( num % i == 0 ) { ++ count ; num /= i ; } if ( count > 0 ) factor [ i ] = count ; } if ( num > 1 ) factor [ num ] = 1 ; int product = 1 ; for ( int i = 0 ; i < num + 1 ; i ++ ) { if ( factor [ i ] > 0 ) product = product * factor [ i ] * i ; } if ( product == input ) cout << " Power - isolated ▁ Integer STRNEWLINE " ; else cout << " Not ▁ a ▁ Power - isolated ▁ Integer STRNEWLINE " ; } int main ( ) { checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; long long int getNthTerm ( long long int N ) { return ( pow ( N , 2 ) + N + 1 ) ; } int main ( ) { long long int N = 11 ; cout << getNthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll findSum ( int n ) { ll sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; } int main ( ) { int n = 5 ; cout << findSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } void factors ( int N , vector < int > & v [ ] ) { for ( int i = 2 ; i < N ; i ++ ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( i / j == j ) v [ i ] . push_back ( j ) ; else { v [ i ] . push_back ( j ) ; v [ i ] . push_back ( i / j ) ; } } } sort ( v [ i ] . begin ( ) , v [ i ] . end ( ) ) ; } } int product ( int n ) { vector < int > v [ n + 100 ] ; factors ( n + 100 , v ) ; if ( n % 4 == 0 ) { int x = n / 4 ; x *= x ; return x * x ; } else { if ( isPrime [ n ] ) return -1 ; else { int ans = -1 ; if ( v [ n ] . size ( ) > 2 ) { int fac = v [ n ] [ v [ n ] . size ( ) - 3 ] ; for ( int i = v [ n ] . size ( ) - 1 ; i >= 0 ; i -- ) { for ( int j = v [ n ] . size ( ) - 1 ; j >= 0 ; j -- ) { if ( ( fac * 2 ) + ( v [ n ] [ j ] + v [ n ] [ i ] ) == n ) ans = max ( ans , fac * fac * v [ n ] [ j ] * v [ n ] [ i ] ) ; } } return ans ; } } } } int main ( ) { int n = 24 ; cout << product ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool arePermutations ( int a [ ] , int b [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 , mul1 = 1 , mul2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 += a [ i ] ; mul1 *= a [ i ] ; } for ( int i = 0 ; i < m ; i ++ ) { sum2 += b [ i ] ; mul2 *= b [ i ] ; } return ( ( sum1 == sum2 ) && ( mul1 == mul2 ) ) ; } int main ( ) { int a [ ] = { 1 , 3 , 2 } ; int b [ ] = { 3 , 1 , 2 } ; int n = sizeof ( a ) / sizeof ( int ) ; int m = sizeof ( b ) / sizeof ( int ) ; if ( arePermutations ( a , b , n , m ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float CalculateRatio ( float m , float n ) { return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; } int main ( ) { float m = 6 , n = 2 ; cout << CalculateRatio ( m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { return pow ( n * ( n + 1 ) / 2 , 2 ) ; } int main ( ) { int n = 4 ; cout << calculateSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } int powerDigitSum ( int a , int n ) { int res = 1 ; while ( n ) { if ( n % 2 == 1 ) { res = res * digSum ( a ) ; res = digSum ( res ) ; } a = digSum ( digSum ( a ) * digSum ( a ) ) ; n /= 2 ; } return res ; } int main ( ) { int a = 9 , n = 4 ; cout << powerDigitSum ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totEdge ( int n ) { int result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; } int main ( ) { int n = 6 ; cout << totEdge ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000005 NEW_LINE vector < bool > prime ( MAX , true ) ; void sieve ( int N ) { prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i <= N ; i ++ ) { if ( prime [ i ] ) { for ( int j = 2 ; i * j <= N ; j ++ ) prime [ i * j ] = false ; } } } int countLogNeeded ( int N ) { int count = 0 ; sieve ( N ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) count ++ ; } return count ; } int main ( ) { int N = 6 ; cout << countLogNeeded ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2.0 ) ; twentyfive = ( ( Z * 1 ) / 4.0 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return result ; } int main ( ) { int totalRupees = 1800 ; int X = 1 , Y = 2 , Z = 4 ; int Rupees = coin ( totalRupees , X , Y , Z ) ; cout << "1 ▁ rupess ▁ coins ▁ = ▁ " << Rupees * 1 << endl ; cout << "50 ▁ paisa ▁ coins ▁ = ▁ " << Rupees * 2 << endl ; cout << "25 ▁ paisa ▁ coins ▁ = ▁ " << Rupees * 4 << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float sumOfSeries ( int x , int k ) { return ( float ( x ) / 81 ) * ( 9 * k - 1 + pow ( 10 , ( -1 ) * k ) ) ; } int main ( ) { int x = 9 ; int k = 20 ; cout << sumOfSeries ( x , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findfactors ( int n ) { unordered_map < int , int > mpp ; vector < int > v , v1 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { v . push_back ( i ) ; if ( i != ( n / i ) && i != 1 ) v . push_back ( n / i ) ; } } int s = v . size ( ) ; int maxi = -1 ; pair < int , int > mp1 [ n + 5 ] ; for ( int i = 0 ; i < s ; i ++ ) { for ( int j = i ; j < s ; j ++ ) { if ( v [ i ] + v [ j ] < n ) { v1 . push_back ( v [ i ] + v [ j ] ) ; mp1 [ v [ i ] + v [ j ] ] = { v [ i ] , v [ j ] } ; mpp [ v [ i ] + v [ j ] ] = 1 ; } } } s = v1 . size ( ) ; for ( int i = 0 ; i < s ; i ++ ) { int el = n - ( v1 [ i ] ) ; if ( mpp [ el ] == 1 ) { int a = mp1 [ v1 [ i ] ] . first ; int b = mp1 [ v1 [ i ] ] . second ; int c = mp1 [ n - v1 [ i ] ] . first ; int d = mp1 [ n - v1 [ i ] ] . second ; maxi = max ( a * b * c * d , maxi ) ; } } if ( maxi == -1 ) cout << " Not ▁ Possible STRNEWLINE " ; else { cout << " The ▁ maximum ▁ product ▁ is ▁ " << maxi << endl ; } } int main ( ) { int n = 50 ; findfactors ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > factors ; void findFactors ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i ) == i ) factors . push_back ( i ) ; else { factors . push_back ( n / i ) ; factors . push_back ( i ) ; } } } } int findProduct ( int n ) { int product = -1 ; int si = factors . size ( ) ; for ( int i = 0 ; i < si ; i ++ ) for ( int j = 0 ; j < si ; j ++ ) for ( int k = 0 ; k < si ; k ++ ) for ( int l = 0 ; l < si ; l ++ ) { int s = factors [ i ] + factors [ j ] + factors [ k ] + factors [ l ] ; if ( s == n ) { int p = factors [ i ] * factors [ j ] * factors [ k ] * factors [ l ] ; if ( p > product ) product = p ; } } return product ; } int main ( ) { int n = 10 ; findFactors ( n ) ; cout << findProduct ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisible ( long long int n ) { while ( n / 100 ) { int d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; } int main ( ) { long long int n = 19877658 ; if ( isDivisible ( n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int removeElement ( unsigned int n ) { if ( n == 1 n == 2 ) return 0 ; unsigned int a = nextPowerOf2 ( n ) ; if ( n == a n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; } int main ( ) { unsigned int n = 5 ; cout << removeElement ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; } int main ( ) { int trainLength = 120 ; int Speed = 30 ; int Time = 18 ; cout << " Length ▁ of ▁ bridge ▁ = ▁ " << bridge_length ( trainLength , Speed , Time ) << " ▁ meters " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Time ( float arr [ ] , int n , int Emptypipe ) { float fill = 0 ; for ( int i = 0 ; i < n ; i ++ ) fill += 1 / arr [ i ] ; fill = fill - ( 1 / ( float ) Emptypipe ) ; return 1 / fill ; } int main ( ) { float arr [ ] = { 12 , 14 } ; float Emptypipe = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << floor ( Time ( arr , n , Emptypipe ) ) << " ▁ Hours " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const long long MOD = 1000000007 ; long long modInv ( long long x ) { long long n = MOD - 2 ; long long result = 1 ; while ( n ) { if ( n & 1 ) result = result * x % MOD ; x = x * x % MOD ; n = n / 2 ; } return result ; } long long getSum ( long long n , long long k ) { long long ans = 1 ; for ( long long i = n + 1 ; i > n - k ; i -- ) ans = ans * i % MOD ; ans = ans * modInv ( k + 1 ) % MOD ; return ans ; } int main ( ) { long long n = 3 , k = 2 ; cout << getSum ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printCombination ( int n ) { cout << 1 << " ▁ " ; if ( ( n - 2 ) % 3 == 0 ) cout << 2 << " ▁ " << n - 3 ; else cout << 1 << " ▁ " << n - 2 ; } int main ( ) { int n = 233 ; printCombination ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; } int main ( ) { int l = 1 , r = 8 ; if ( checkPairs ( l , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; } int main ( ) { isPalindrome ( 123321 ) ? cout << " Palindrome " : cout << " Not ▁ Palindrome " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int main ( ) { int target = 93 ; int arr [ ] = { 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 } ; int length = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int totalCount = 0 ; for ( int i = 0 ; i < length - 2 ; i ++ ) { if ( target % arr [ i ] == 0 ) { for ( int j = i + 1 ; j < length - 1 ; j ++ ) { if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) { int toFind = target / ( arr [ i ] * arr [ j ] ) ; for ( int k = j + 1 ; k < length ; k ++ ) { if ( arr [ k ] == toFind ) { totalCount ++ ; } } } } } } cout << " Total ▁ number ▁ of ▁ triplets ▁ found ▁ : ▁ " << totalCount ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isFascinating ( int num ) { int freq [ 10 ] = { 0 } ; string val = " " + to_string ( num ) + to_string ( num * 2 ) + to_string ( num * 3 ) ; for ( int i = 0 ; i < val . length ( ) ; i ++ ) { int digit = val [ i ] - '0' ; if ( freq [ digit ] and digit != 0 > 0 ) return false ; else freq [ digit ] ++ ; } for ( int i = 1 ; i < 10 ; i ++ ) { if ( freq [ i ] == 0 ) return false ; } return true ; } int main ( ) { int num = 192 ; if ( num < 100 ) cout << " No " << endl ; else { bool ans = isFascinating ( num ) ; if ( ans ) cout << " Yes " ; else cout << " No " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomial_coefficient ( int n , int m ) { int res = 1 ; if ( m > n - m ) m = n - m ; for ( int i = 0 ; i < m ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int calculate_ways ( int m , int n ) { if ( m < n ) return 0 ; int ways = binomial_coefficient ( n + m - 1 , n - 1 ) ; return ways ; } int main ( ) { int m = 7 , n = 5 ; int result = calculate_ways ( m , n ) ; printf ( " % d STRNEWLINE " , result ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE int phi [ N ] ; int S [ N ] ; void computeTotient ( ) { for ( int i = 1 ; i < N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } } void CoPrimes ( ) { computeTotient ( ) ; for ( int i = 1 ; i < N ; i ++ ) S [ i ] = S [ i - 1 ] + phi [ i ] ; } int main ( ) { CoPrimes ( ) ; int q [ ] = { 3 , 4 } ; int n = sizeof ( q ) / sizeof ( q [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) cout << " Number ▁ of ▁ unordered ▁ coprime STRNEWLINE " << " pairs ▁ of ▁ integers ▁ from ▁ 1 ▁ to ▁ " << q [ i ] << " ▁ are ▁ " << S [ q [ i ] ] << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binaryToDecimal ( string n ) { string num = n ; int dec_value = 0 ; int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; } int numberSequence ( int n ) { if ( n == 1 ) return 1 ; string s = " " ; for ( int i = 1 ; i < n ; i ++ ) s += '1' ; s += '0' ; for ( int i = 1 ; i <= n ; i ++ ) s += '1' ; int num = binaryToDecimal ( s ) ; return num ; } int main ( ) { int n = 4 ; cout << numberSequence ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberSequence ( int n ) { int num = pow ( 4 , n ) - pow ( 2 , n ) - 1 ; return num ; } int main ( ) { int n = 4 ; cout << numberSequence ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int prime ( int num ) { int i , flag = 0 ; for ( i = 2 ; i <= num / 2 ; i ++ ) { if ( num % i == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) return 1 ; else return 0 ; } void print_alternate_prime ( int n ) { int counter = 0 ; for ( int num = 2 ; num < n ; num ++ ) { if ( prime ( num ) == 1 ) { if ( counter % 2 == 0 ) cout << num << " ▁ " ; counter ++ ; } } } int main ( ) { int n = 15 ; cout << " Following ▁ are ▁ the ▁ alternate ▁ prime " << " ▁ number ▁ smaller ▁ than ▁ or ▁ equal ▁ to ▁ " << n << endl ; print_alternate_prime ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } bool flag = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { if ( flag ) { cout << p << " ▁ " ; flag = false ; } else { flag = true ; } } } } int main ( ) { int n = 15 ; cout << " Following ▁ are ▁ the ▁ alternate " << " ▁ prime ▁ numbers ▁ smaller ▁ " << " ▁ than ▁ or ▁ equal ▁ to ▁ " << n << endl ; SieveOfEratosthenes ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } } int main ( ) { int x = 4 ; int y = 9 ; findGreater ( x , y ) ? cout << "1 STRNEWLINE " : cout << "2 STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_profit ( int a [ ] , int b [ ] , int n , int fee ) { int i , j , profit ; int l , r , diff_day = 1 , sum = 0 ; b [ 0 ] = 0 ; b [ 1 ] = diff_day ; for ( i = 1 ; i < n ; i ++ ) { l = 0 ; r = diff_day ; sum = 0 ; for ( j = n - 1 ; j >= i ; j -- ) { profit = ( a [ r ] - a [ l ] ) - fee ; if ( profit > 0 ) { sum = sum + profit ; } l ++ ; r ++ ; } if ( b [ 0 ] < sum ) { b [ 0 ] = sum ; b [ 1 ] = diff_day ; } diff_day ++ ; } return 0 ; } int main ( ) { int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int b [ 2 ] ; int tranFee = 2 ; max_profit ( arr , b , n , tranFee ) ; cout << b [ 0 ] << " , ▁ " << b [ 1 ] << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getsum ( int a ) { int r = 0 , sum = 0 ; while ( a > 0 ) { r = a % 10 ; sum = sum + r ; a = a / 10 ; } return sum ; } void value ( int a , int b , int c ) { int co = 0 , p = 0 ; int no , r = 0 , x = 0 , q = 0 , w = 0 ; vector < int > v ; for ( int i = 1 ; i < 82 ; i ++ ) { no = pow ( ( double ) i , double ( a ) ) ; no = b * no + c ; if ( no > 0 && no < 1000000000 ) { x = getsum ( no ) ; if ( x == i ) { q ++ ; v . push_back ( no ) ; w ++ ; } } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { cout << v [ i ] << " ▁ " ; } } int main ( ) { int a = 2 , b = 2 , c = -1 ; value ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( 1 ) { flag = 1 ; x = ( int ) ( pow ( 2 , i ) ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; printf ( " % d ▁ " , p1 ) ; i ++ ; } } int main ( ) { int p0 = 19 ; print ( p0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll boost_hyperfactorial ( ll num ) { ll val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { val = val * pow ( i , i ) ; } return val ; } int main ( ) { int num = 5 ; cout << boost_hyperfactorial ( num ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findOddPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; } int main ( ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findOddPair ( a , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; } int main ( ) { int n = 15 ; if ( isSurd ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LastTwoDigit ( long long int num ) { int one = num % 10 ; num /= 10 ; int tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; } int main ( ) { int n = 10 ; long long int num = 1 ; num = pow ( 2 , n ) ; cout << " Last ▁ " << 2 ; cout << " ▁ digits ▁ of ▁ " << 2 ; cout << " ^ " << n << " ▁ = ▁ " ; cout << LastTwoDigit ( num ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int power ( long long int x , long long int y , long long int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int numberOfDigits ( int x ) { int i = 0 ; while ( x ) { x /= 10 ; i ++ ; } return i ; } void LastTwoDigit ( int n ) { cout << " Last ▁ " << 2 ; cout << " ▁ digits ▁ of ▁ " << 2 ; cout << " ^ " << n << " ▁ = ▁ " ; int temp = 1 ; for ( int i = 1 ; i <= 2 ; i ++ ) temp *= 10 ; temp = power ( 2 , n , temp ) ; for ( int i = 0 ; i < 2 - numberOfDigits ( temp ) ; i ++ ) cout << 0 ; if ( temp ) cout << temp ; } int main ( ) { int n = 72 ; LastTwoDigit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll modPower ( ll x , ll y , ll p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } ll gcdPow ( ll a , ll n , ll c ) { if ( a % c == 0 ) return c ; ll modexpo = modPower ( a , n , c ) ; return gcd ( modexpo , c ) ; } int main ( ) { ll a = 10248585 , n = 1000000 , c = 12564 ; cout << gcdPow ( a , n , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOddSum ( int ar [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; } int main ( ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << " The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ odd " " ▁ sum ▁ is ▁ " << countOddSum ( ar , n ) ; return ( 0 ) ; }
#include <iostream> NEW_LINE using namespace std ; void printPFsInPairs ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) cout << i << " * " << n / i << endl ; } int main ( ) { int n = 24 ; printPFsInPairs ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005 NEW_LINE bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int SumOfPrimeDivisors ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 ) { if ( isPrime ( i ) ) sum += i ; } } return sum ; } int main ( ) { int n = 60 ; cout << " Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ " << SumOfPrimeDivisors ( n ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Sum ( int N ) { int SumOfPrimeDivisors [ N + 1 ] = { 0 } ; for ( int i = 2 ; i <= N ; ++ i ) { if ( ! SumOfPrimeDivisors [ i ] ) { for ( int j = i ; j <= N ; j += i ) { SumOfPrimeDivisors [ j ] += i ; } } } return SumOfPrimeDivisors [ N ] ; } int main ( ) { int N = 60 ; cout << " Sum ▁ of ▁ prime ▁ divisors ▁ of ▁ 60 ▁ is ▁ " << Sum ( N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int rangesum ( int n , int l , int r ) { int arr [ n ] ; int c = 1 , i = 0 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } c = 2 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } int sum = 0 ; for ( i = l - 1 ; i < r ; i ++ ) { sum += arr [ i ] ; } return sum ; } int main ( ) { int n = 12 ; int l = 1 , r = 11 ; cout << ( rangesum ( n , l , r ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumeven ( int n , int l , int r ) { int sum = 0 ; int mid = n / 2 ; if ( r <= mid ) { int first = ( 2 * l - 1 ) ; int last = ( 2 * r - 1 ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else if ( l >= mid ) { int first = ( 2 * ( l - n / 2 ) ) ; int last = ( 2 * ( r - n / 2 ) ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else { int sumleft = 0 , sumright = 0 ; int first_term1 = ( 2 * l - 1 ) ; int last_term1 = ( 2 * ( n / 2 ) - 1 ) ; int no_of_terms1 = n / 2 - l + 1 ; sumleft = ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) / 2 ; int first_term2 = 2 ; int last_term2 = ( 2 * ( r - n / 2 ) ) ; int no_of_terms2 = r - mid ; sumright = ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) / 2 ; sum = ( sumleft + sumright ) ; } return sum ; } int sumodd ( int n , int l , int r ) { int mid = n / 2 + 1 ; int sum = 0 ; if ( r <= mid ) { int first = ( 2 * l - 1 ) ; int last = ( 2 * r - 1 ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else if ( l > mid ) { int first = ( 2 * ( l - mid ) ) ; int last = ( 2 * ( r - mid ) ) ; int no_of_terms = r - l + 1 ; sum = ( ( no_of_terms ) * ( ( first + last ) ) ) / 2 ; } else { int sumleft = 0 , sumright = 0 ; int first_term1 = ( 2 * l - 1 ) ; int last_term1 = ( 2 * mid - 1 ) ; int no_of_terms1 = mid - l + 1 ; sumleft = ( ( no_of_terms1 ) * ( ( first_term1 + last_term1 ) ) ) / 2 ; int first_term2 = 2 ; int last_term2 = ( 2 * ( r - mid ) ) ; int no_of_terms2 = r - mid ; sumright = ( ( no_of_terms2 ) * ( ( first_term2 + last_term2 ) ) ) / 2 ; sum = ( sumleft + sumright ) ; } return sum ; } int rangesum ( int n , int l , int r ) { int sum = 0 ; if ( n % 2 == 0 ) return sumeven ( n , l , r ) ; else return sumodd ( n , l , r ) ; } int main ( ) { int n = 12 ; int l = 1 , r = 11 ; cout << ( rangesum ( n , l , r ) ) ; }
#include <iostream> NEW_LINE using namespace std ; void findAngle ( int n ) { int interiorAngle , exteriorAngle ; interiorAngle = ( n - 2 ) * 180 / n ; exteriorAngle = 360 / n ; cout << " Interior ▁ angle : ▁ " << interiorAngle << endl ; cout << " Exterior ▁ angle : ▁ " << exteriorAngle ; } int main ( ) { int n = 10 ; findAngle ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool DivisibleBy41 ( int first , int second , int c , int n ) { int digit [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; } int main ( ) { int first = 1 , second = 2 , c = 1 , n = 3 ; if ( DivisibleBy41 ( first , second , c , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findTetrahedralNumber ( int n ) { return ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ; } void printSeries ( int n ) { int prev = 0 ; int curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTetrahedralNumber ( i ) ; curr = curr + prev ; cout << curr << " ▁ " ; prev = curr ; } } int main ( ) { int n = 10 ; printSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; cout << num << " ▁ " ; } } int main ( ) { int n = 10 ; printSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long findTriangularNumber ( int n ) { return ( n * ( n + 1 ) ) / 2 ; } void printSeries ( int n ) { int prev = 0 ; int curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTriangularNumber ( i ) ; curr = curr + prev ; cout << curr << " ▁ " ; prev = curr ; } } int main ( ) { int n = 10 ; printSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; cout << num << " ▁ " ; } } int main ( ) { int n = 10 ; printSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void count_even_odd ( int min , int max , int steps [ ] [ 2 ] ) { int a , b , even , odd ; bool beven = true , aeven = false ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { a = steps [ i ] [ 0 ] , b = steps [ i ] [ 1 ] ; if ( ! ( aeven a & 1 ) ) aeven = true ; if ( beven ) { if ( b & 1 ) beven = false ; } else if ( ! ( a & 1 ) ) { if ( ! ( b & 1 ) ) beven = true ; } else { if ( b & 1 ) beven = true ; } } if ( beven ) { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } else { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) even += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; else odd += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; cout << " even ▁ = ▁ " << even << " , ▁ odd ▁ = ▁ " << odd << endl ; } int main ( ) { int min = 1 , max = 4 ; int steps [ ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } } ; count_even_odd ( min , max , steps ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMaxOnes ( int n , int x ) { int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; int total = n * n ; int ans = total - zeroes ; return ans ; } int main ( ) { int n = 5 ; int x = 2 ; cout << getMaxOnes ( n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll power ( ll x , ll y , ll p ) { x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int main ( ) { ll a = 3 ; string b = "100000000000000000000000000" ; ll remainderB = 0 ; ll MOD = 1000000007 ; for ( int i = 0 ; i < b . length ( ) ; i ++ ) remainderB = ( remainderB * 10 + b [ i ] - '0' ) % ( MOD - 1 ) ; cout << power ( a , remainderB , MOD ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumOperations ( int a [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ a [ i ] ] += 1 ; int count = 0 ; for ( auto it = mp . begin ( ) ; it != mp . end ( ) ; it ++ ) { if ( ( * it ) . second > 1 ) count += ( * it ) . second - 1 ; } return count ; } int main ( ) { int a [ ] = { 2 , 1 , 2 , 3 , 3 , 4 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minimumOperations ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( int n , int m ) { if ( n == 2 m == 2 n % m == 0 ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } } int main ( ) { int m = 3 , n = 9 ; check ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSurfaceArea ( float a , float h ) { float Area ; Area = 6 * a * h + 3 * sqrt ( 3 ) * a * a ; cout << " Surface ▁ Area : ▁ " << Area ; cout << " STRNEWLINE " ; } void findVolume ( float a , float h ) { float Volume ; Volume = 3 * sqrt ( 3 ) * a * a * h / 2 ; cout << " Volume : ▁ " << Volume ; } int main ( ) { float a = 5 , h = 10 ; findSurfaceArea ( a , h ) ; findVolume ( a , h ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; long long int MinimumMail ( int n , int k , int x ) { ll m = ( n - 1 ) + ( ll ) ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + ( ll ) ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; } int main ( ) { int N = 4 ; int K = 9 ; int X = 2 ; cout << MinimumMail ( N , K , X ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findArea ( float a , float b ) { float Area ; Area = 3.142 * a * b ; cout << " Area : ▁ " << Area ; } int main ( ) { float a = 5 , b = 4 ; findArea ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- ) { result = pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; } int main ( ) { int x = 5 , k = 2 , m = 3 ; cout << calculate ( x , k , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; } int main ( ) { int n = 121 ; int temp = rev ( n , 0 ) ; if ( temp == n ) cout << " yes " << endl ; else cout << " no " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void fibonacci ( int n ) { long long int fib ; for ( long long int i = 0 ; i < n ; i ++ ) { fib = ( pow ( ( 1 + sqrt ( 5 ) ) , i ) - pow ( ( 1 - sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * sqrt ( 5 ) ) ; cout << fib << " ▁ " ; } } int main ( ) { long long int n = 8 ; fibonacci ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE bool findNature ( int a , int b , int n ) { int seq [ MAX ] = { 0 } ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; return ( seq [ n ] & 1 ) ; } int main ( ) { int a = 2 , b = 4 ; int n = 3 ; ( findNature ( a , b , n ) ? ( cout << " Odd " << " ▁ " ) : ( cout << " Even " << " ▁ " ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMatrix ( int n ) { float H [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { H [ i ] [ j ] = ( float ) 1.0 / ( ( i + 1 ) + ( j + 1 ) - 1.0 ) ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << H [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int n = 3 ; printMatrix ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int maxDivisorRange ( int a , int b , int l , int h ) { int g = gcd ( a , b ) ; int res = -1 ; for ( int i = l ; i * i <= g && i <= h ; i ++ ) if ( g % i == 0 ) res = max ( { res , i , g / i } ) ; return res ; } int main ( ) { int a = 3 , b = 27 , l = 1 , h = 5 ; cout << maxDivisorRange ( a , b , l , h ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define rows  3 NEW_LINE #define cols  3 NEW_LINE void meanVector ( int mat [ rows ] [ cols ] ) { cout << " [ ▁ " ; for ( int i = 0 ; i < rows ; i ++ ) { double mean = 0.00 ; int sum = 0 ; for ( int j = 0 ; j < cols ; j ++ ) sum += mat [ j ] [ i ] ; mean = sum / rows ; cout << mean << " ▁ " ; } cout << " ] " ; } int main ( ) { int mat [ rows ] [ cols ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; meanVector ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checksum ( int n ) { if ( n == 0 ) { cout << " - 2 ▁ - 1 ▁ 0 ▁ 1 ▁ 2" << endl ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = -1 ; for ( int i = 0 ; i <= n - 4 ; i += inc ) { if ( i + i + 1 + i + 2 + i + 3 + i + 4 == n ) { cout << i << " ▁ " << i + 1 << " ▁ " << i + 2 << " ▁ " << i + 3 << " ▁ " << i + 4 ; return ; } } cout << " - 1" ; } int main ( ) { int n = 15 ; checksum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checksum ( int n ) { if ( n % 5 == 0 ) cout << n / 5 - 2 << " ▁ " << n / 5 - 1 << " ▁ " << n / 5 << " ▁ " << n / 5 + 1 << " ▁ " << n / 5 + 2 ; else cout << " - 1" ; } int main ( ) { int n = 15 ; checksum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000001 NEW_LINE int visited [ N ] ; int goesTo [ N ] ; int dfs ( int i ) { if ( visited [ i ] == 1 ) return 0 ; visited [ i ] = 1 ; int x = dfs ( goesTo [ i ] ) ; return ( x + 1 ) ; } int noOfTranspositions ( int P [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) visited [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) goesTo [ P [ i ] ] = i + 1 ; int transpositions = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( visited [ i ] == 0 ) { int ans = dfs ( i ) ; transpositions += ans - 1 ; } } return transpositions ; } int main ( ) { int permutation [ ] = { 5 , 1 , 4 , 3 , 2 } ; int n = sizeof ( permutation ) / sizeof ( permutation [ 0 ] ) ; cout << noOfTranspositions ( permutation , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; } int main ( ) { int n = 4 ; cout << sumOfSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; } int main ( ) { int N = 4 ; cout << " Number ▁ of ▁ unmarked ▁ elements : ▁ " << countUnmarked ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int calculateSeries ( int n ) { return factorial ( n + 1 ) - 1 ; } int main ( ) { int n = 3 ; cout << calculateSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSum ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum - n ; } int getAliquot ( int n ) { unordered_set < int > s ; s . insert ( n ) ; int next = 0 ; while ( n > 0 ) { n = getSum ( n ) ; if ( s . find ( n ) != s . end ( ) ) return n ; s . insert ( n ) ; } return 0 ; } bool isPerfect ( int n ) { long long int sum = 1 ; for ( long long int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + n / i ; if ( sum == n && n != 1 ) return true ; return false ; } bool isAspiring ( int n ) { int alq = getAliquot ( n ) ; if ( isPerfect ( alq ) && ! isPerfect ( n ) ) return true ; else return false ; } int main ( ) { int n = 25 ; if ( isAspiring ( n ) ) cout << " Aspiring " << endl ; else cout << " Not ▁ Aspiring " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumLength ( int x , int y , int z ) { return 1 + abs ( x - y ) + abs ( y - z ) ; } int main ( ) { int x = 3 , y = 1 , z = 2 ; cout << minimumLength ( x , y , z ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { cout << " x2 ▁ = ▁ " << ( float ) ( 2 * c1 - x1 ) << " ▁ " ; cout << " y2 ▁ = ▁ " << ( float ) ( 2 * c2 - y1 ) ; } int main ( ) { int x1 = -4 , y1 = -1 ; int c1 = 3 , c2 = 5 ; endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float proterm ( int i , float value , float x [ ] ) { float pro = 1 ; for ( int j = 0 ; j < i ; j ++ ) { pro = pro * ( value - x [ j ] ) ; } return pro ; } void dividedDiffTable ( float x [ ] , float y [ ] [ 10 ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) { y [ j ] [ i ] = ( y [ j ] [ i - 1 ] - y [ j + 1 ] [ i - 1 ] ) / ( x [ j ] - x [ i + j ] ) ; } } } float applyFormula ( float value , float x [ ] , float y [ ] [ 10 ] , int n ) { float sum = y [ 0 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum = sum + ( proterm ( i , value , x ) * y [ 0 ] [ i ] ) ; } return sum ; } void printDiffTable ( float y [ ] [ 10 ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) { cout << setprecision ( 4 ) << y [ i ] [ j ] << " TABSYMBOL ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 4 ; float value , sum , y [ 10 ] [ 10 ] ; float x [ ] = { 5 , 6 , 9 , 11 } ; y [ 0 ] [ 0 ] = 12 ; y [ 1 ] [ 0 ] = 13 ; y [ 2 ] [ 0 ] = 14 ; y [ 3 ] [ 0 ] = 16 ; dividedDiffTable ( x , y , n ) ; printDiffTable ( y , n ) ; value = 7 ; cout << " Value at " ▁ < < ▁ value ▁ < < ▁ " is " << applyFormula ( value , x , y , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int centered_heptagonal_num ( long int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; } int main ( ) { long int n = 5 ; cout << n << " th ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ " ; cout << centered_heptagonal_num ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE bool checkHankelMatrix ( int n , int m [ N ] [ N ] ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; } int main ( ) { int n = 4 ; int m [ N ] [ N ] = { { 1 , 2 , 3 , 5 } , { 2 , 3 , 5 , 8 } , { 3 , 5 , 8 , 0 } , { 5 , 8 , 0 , 9 } } ; checkHankelMatrix ( n , m ) ? ( cout << " Yes " ) : ( cout << " No " ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; string find_Square_369 ( string num ) { char a , b , c , d ; if ( num [ 0 ] == '3' ) a = '1' , b = '0' , c = '8' , d = '9' ; else if ( num [ 0 ] == '6' ) a = '4' , b = '3' , c = '5' , d = '6' ; else a = '9' , b = '8' , c = '0' , d = '1' ; string result = " " ; int size = num . size ( ) ; for ( int i = 1 ; i < num . size ( ) ; i ++ ) result += a ; result += b ; for ( int i = 1 ; i < num . size ( ) ; i ++ ) result += c ; result += d ; return result ; } int main ( ) { string num_3 , num_6 , num_9 ; num_3 = "3333" ; num_6 = "6666" ; num_9 = "9999" ; string result = " " ; result = find_Square_369 ( num_3 ) ; cout << " Square ▁ of ▁ " << num_3 << " ▁ is ▁ : ▁ " << result << endl ; result = find_Square_369 ( num_6 ) ; cout << " Square ▁ of ▁ " << num_6 << " ▁ is ▁ : ▁ " << result << endl ; result = find_Square_369 ( num_9 ) ; cout << " Square ▁ of ▁ " << num_9 << " ▁ is ▁ : ▁ " << result << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPower ( unsigned int n ) { for ( int x = 2 ; x <= sqrt ( n ) ; x ++ ) { float f = log ( n ) / log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; } int main ( ) { for ( int i = 2 ; i < 100 ; i ++ ) if ( isPower ( i ) ) cout << i << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005 NEW_LINE void sumOddDigit ( int digitSum [ ] ) { for ( int i = 1 ; i < N ; i ++ ) { digitSum [ i ] = digitSum [ i / 10 ] + ( i & 1 ) * ( i % 10 ) ; } } void sumFactor ( int digitSum [ ] , int factorDigitSum [ ] ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j += i ) { factorDigitSum [ j ] += digitSum [ i ] ; } } } void wrapper ( int q , int n [ ] ) { int digitSum [ N ] ; int factorDigitSum [ N ] ; sumOddDigit ( digitSum ) ; sumFactor ( digitSum , factorDigitSum ) ; for ( int i = 0 ; i < q ; i ++ ) cout << factorDigitSum [ n [ i ] ] << " ▁ " ; } int main ( ) { int q = 2 ; int n [ ] = { 10 , 36 } ; wrapper ( q , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  10 NEW_LINE void PrintMatrix ( float a [ ] [ M ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) cout << a [ i ] [ j ] << " ▁ " ; cout << endl ; } } int PerformOperation ( float a [ ] [ M ] , int n ) { int i , j , k = 0 , c , flag = 0 , m = 0 ; float pro = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] [ i ] == 0 ) { c = 1 ; while ( ( i + c ) < n && a [ i + c ] [ i ] == 0 ) c ++ ; if ( ( i + c ) == n ) { flag = 1 ; break ; } for ( j = i , k = 0 ; k <= n ; k ++ ) swap ( a [ j ] [ k ] , a [ j + c ] [ k ] ) ; } for ( j = 0 ; j < n ; j ++ ) { if ( i != j ) { float pro = a [ j ] [ i ] / a [ i ] [ i ] ; for ( k = 0 ; k <= n ; k ++ ) a [ j ] [ k ] = a [ j ] [ k ] - ( a [ i ] [ k ] ) * pro ; } } } return flag ; } void PrintResult ( float a [ ] [ M ] , int n , int flag ) { cout << " Result ▁ is ▁ : ▁ " ; if ( flag == 2 ) cout << " Infinite ▁ Solutions ▁ Exists " << endl ; else if ( flag == 3 ) cout << " No ▁ Solution ▁ Exists " << endl ; else { for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] [ n ] / a [ i ] [ i ] << " ▁ " ; } } int CheckConsistency ( float a [ ] [ M ] , int n , int flag ) { int i , j ; float sum ; flag = 3 ; for ( i = 0 ; i < n ; i ++ ) { sum = 0 ; for ( j = 0 ; j < n ; j ++ ) sum = sum + a [ i ] [ j ] ; if ( sum == a [ i ] [ j ] ) flag = 2 ; } return flag ; } int main ( ) { float a [ M ] [ M ] = { { 0 , 2 , 1 , 4 } , { 1 , 1 , 2 , 6 } , { 2 , 1 , 1 , 7 } } ; int n = 3 , flag = 0 ; flag = PerformOperation ( a , n ) ; if ( flag == 1 ) flag = CheckConsistency ( a , n , flag ) ; cout << " Final ▁ Augumented ▁ Matrix ▁ is ▁ : ▁ " << endl ; PrintMatrix ( a , n ) ; cout << endl ; PrintResult ( a , n , flag ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int main ( ) { long int ans = 1 ; long int mod = ( long int ) 1000000007 * 120 ; for ( int i = 0 ; i < 5 ; i ++ ) ans = ( ans * ( 55555 - i ) ) % mod ; ans = ans / 120 ; cout << " Answer ▁ using ▁ shortcut : ▁ " << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int number_of_digits ( int n ) { int i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; } int main ( ) { int n = 21 ; cout << number_of_digits ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Reverseorder ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = n ; p >= 2 ; p -- ) if ( prime [ p ] ) cout << p << " ▁ " ; } int main ( ) { int N = 25 ; cout << " Prime ▁ number ▁ in ▁ reverse ▁ order " << endl ; if ( N == 1 ) cout << " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ; else return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkVantieghemsTheorem ( int limit ) { long long unsigned prod = 1 ; for ( long long unsigned n = 2 ; n < limit ; n ++ ) { if ( ( ( prod - n ) % ( ( 1LL << n ) - 1 ) ) == 0 ) cout << n << " ▁ is ▁ prime STRNEWLINE " ; prod *= ( ( 1LL << n ) - 1 ) ; } } int main ( ) { checkVantieghemsTheorem ( 10 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; const int N = 1000005 ; int fact [ N ] , invfact [ N ] ; int check ( int x , int a , int b ) { if ( x == 0 ) return 0 ; while ( x ) { if ( x % 10 != a and x % 10 != b ) return 0 ; x /= 10 ; } return 1 ; } int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m , a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } void pregenFact ( ) { fact [ 0 ] = fact [ 1 ] = 1 ; for ( int i = 1 ; i <= 1000000 ; ++ i ) fact [ i ] = ( long long ) fact [ i - 1 ] * i % mod ; } void pregenInverse ( ) { invfact [ 0 ] = invfact [ 1 ] = 1 ; invfact [ 1000000 ] = modInverse ( fact [ 1000000 ] , mod ) ; for ( int i = 999999 ; i > 1 ; -- i ) invfact [ i ] = ( ( long long ) invfact [ i + 1 ] * ( long long ) ( i + 1 ) ) % mod ; } int comb ( int big , int small ) { return ( long long ) fact [ big ] * invfact [ small ] % mod * invfact [ big - small ] % mod ; } int count ( int a , int b , int n ) { pregenFact ( ) ; pregenInverse ( ) ; if ( a == b ) return ( check ( a * n , a , b ) ) ; int ans = 0 ; for ( int i = 0 ; i <= n ; ++ i ) if ( check ( i * a + ( n - i ) * b , a , b ) ) ans = ( ans + comb ( n , i ) ) % mod ; return ans ; } int main ( ) { int a = 3 , b = 4 , n = 11028 ; cout << count ( a , b , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int magicOfSequence ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; } int main ( ) { int N = 4 ; cout << magicOfSequence ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOddFactors ( long long n ) { int odd_factors = 0 ; for ( int i = 1 ; 1ll * i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( 1ll * i * i == n ) { if ( i & 1 ) odd_factors ++ ; } else { if ( i & 1 ) odd_factors ++ ; int factor = n / i ; if ( factor & 1 ) odd_factors ++ ; } } } return odd_factors - 1 ; } int main ( ) { long long int N = 15 ; cout << countOddFactors ( N ) << endl ; N = 10 ; cout << countOddFactors ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossibleToZero ( int a [ ] , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isPossibleToZero ( arr , n ) ) cout << " YES " ; else cout << " NO " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > primeFactors ( int n ) { vector < int > res ; if ( n % 2 == 0 ) { while ( n % 2 == 0 ) n = n / 2 ; res . push_back ( 2 ) ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; res . push_back ( i ) ; } } if ( n > 2 ) res . push_back ( n ) ; return res ; } bool isHoax ( int n ) { vector < int > pf = primeFactors ( n ) ; if ( pf [ 0 ] == n ) return false ; int all_pf_sum = 0 ; for ( int i = 0 ; i < pf . size ( ) ; i ++ ) { int pf_sum ; for ( pf_sum = 0 ; pf [ i ] > 0 ; pf_sum += pf [ i ] % 10 , pf [ i ] /= 10 ) ; all_pf_sum += pf_sum ; } int sum_n ; for ( sum_n = 0 ; n > 0 ; sum_n += n % 10 , n /= 10 ) ; return sum_n == all_pf_sum ; } int main ( ) { int n = 84 ; if ( isHoax ( n ) ) cout << " A ▁ Hoax ▁ Number STRNEWLINE " ; else cout << " Not ▁ a ▁ Hoax ▁ Number STRNEWLINE " ; return 0 ; }
# include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { if ( n == 0 n == 1 ) return 1 ; int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) ans = ans * i ; return ans ; } int nCr ( int n , int r ) { int Nr = n , Dr = 1 , ans = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { ans = ( ans * Nr ) / ( Dr ) ; Nr -- ; Dr ++ ; } return ans ; } int solve ( int n ) { int N = 2 * n - 2 ; int R = n - 1 ; return nCr ( N , R ) * fact ( n - 1 ) ; } int main ( ) { int n = 6 ; cout << solve ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int n , int base ) { int result = 0 ; while ( n > 0 ) { int remainder = n % base ; result = result + remainder ; n = n / base ; } return result ; } void printSumsOfDigits ( int n ) { for ( int base = 2 ; base < n ; ++ base ) cout << solve ( n , base ) << " ▁ " ; } int main ( ) { int n = 8 ; printSumsOfDigits ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; } int main ( ) { int N = 5 ; int M = 7 ; if ( check ( N , M ) ) cout << " yes " ; else cout << " no " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int perfectSquare ( string s ) { int n = s . size ( ) ; int ans = -1 ; string num ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { string str = " " ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i >> j ) & 1 ) { str += s [ j ] ; } } if ( str [ 0 ] != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . size ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str [ j ] - '0' ) ; int k = sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . size ( ) ) { ans = ( int ) str . size ( ) ; num = str ; } } } } if ( ans == -1 ) return ans ; else { cout << num << " ▁ " ; return n - ans ; } } int main ( ) { cout << perfectSquare ( "8314" ) << endl ; cout << perfectSquare ( "753" ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFourSquares ( int a ) { for ( int i = 0 ; i * i <= a ; i ++ ) { for ( int j = i ; j * j <= a ; j ++ ) { for ( int k = j ; k * k <= a ; k ++ ) { for ( int l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { cout << a << " ▁ = ▁ " << i << " * " << i << " ▁ + ▁ " << j << " * " << j << " ▁ + ▁ " ; cout << k << " * " << k << " ▁ + ▁ " << l << " * " << l << " STRNEWLINE " ; } } } } } } int main ( ) { int a = 74 ; printFourSquares ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; } int main ( ) { int n = 51242183 ; cout << " The ▁ number ▁ of ▁ distinct ▁ prime ▁ factors ▁ is / are ▁ " << exactPrimeFactorCount ( n ) << endl ; cout << " The ▁ value ▁ of ▁ log ( log ( n ) ) ▁ is ▁ " << log ( log ( n ) ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int no_of_digit ( int a , int b ) { return ( ( int ) ( b * log10 ( a ) ) + 1 ) ; } int main ( ) { int a = 2 , b = 100 ; cout << " no . ▁ of ▁ digits ▁ = ▁ " << no_of_digit ( a , b ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; } bool isEmirpimes ( int n ) { if ( checkSemiprime ( n ) == false ) return false ; int r = 0 ; for ( int t = n ; t != 0 ; t = t / n ) r = r * 10 + t % 10 ; if ( r == n ) return false ; return ( checkSemiprime ( r ) ) ; } int main ( ) { int n = 15 ; if ( isEmirpimes ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void add ( int ac [ ] , int x [ ] , int qrn ) { int i , c = 0 ; for ( i = 0 ; i < qrn ; i ++ ) { ac [ i ] = ac [ i ] + x [ i ] + c ; if ( ac [ i ] > 1 ) { ac [ i ] = ac [ i ] % 2 ; c = 1 ; } else c = 0 ; } } void complement ( int a [ ] , int n ) { int i ; int x [ 8 ] = { 0 } ; x [ 0 ] = 1 ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] + 1 ) % 2 ; } add ( a , x , n ) ; } void rightShift ( int ac [ ] , int qr [ ] , int & qn , int qrn ) { int temp , i ; temp = ac [ 0 ] ; qn = qr [ 0 ] ; cout << " TABSYMBOL TABSYMBOL rightShift TABSYMBOL " ; for ( i = 0 ; i < qrn - 1 ; i ++ ) { ac [ i ] = ac [ i + 1 ] ; qr [ i ] = qr [ i + 1 ] ; } qr [ qrn - 1 ] = temp ; } void display ( int ac [ ] , int qr [ ] , int qrn ) { int i ; for ( i = qrn - 1 ; i >= 0 ; i -- ) cout << ac [ i ] ; cout << " TABSYMBOL " ; for ( i = qrn - 1 ; i >= 0 ; i -- ) cout << qr [ i ] ; } void boothAlgorithm ( int br [ ] , int qr [ ] , int mt [ ] , int qrn , int sc ) { int qn = 0 , ac [ 10 ] = { 0 } ; int temp = 0 ; cout << " qn TABSYMBOL q [ n + 1 ] TABSYMBOL TABSYMBOL BR TABSYMBOL TABSYMBOL AC TABSYMBOL QR TABSYMBOL TABSYMBOL sc STRNEWLINE " ; cout << " TABSYMBOL TABSYMBOL TABSYMBOL initial TABSYMBOL TABSYMBOL " ; display ( ac , qr , qrn ) ; cout << " TABSYMBOL TABSYMBOL " << sc << " STRNEWLINE " ; while ( sc != 0 ) { cout << qr [ 0 ] << " TABSYMBOL " << qn ; if ( ( qn + qr [ 0 ] ) == 1 ) { if ( temp == 0 ) { add ( ac , mt , qrn ) ; cout << " TABSYMBOL TABSYMBOL A ▁ = ▁ A ▁ - ▁ BR TABSYMBOL " ; for ( int i = qrn - 1 ; i >= 0 ; i -- ) cout << ac [ i ] ; temp = 1 ; } else if ( temp == 1 ) { add ( ac , br , qrn ) ; cout << " TABSYMBOL TABSYMBOL A ▁ = ▁ A ▁ + ▁ BR TABSYMBOL " ; for ( int i = qrn - 1 ; i >= 0 ; i -- ) cout << ac [ i ] ; temp = 0 ; } cout << " STRNEWLINE TABSYMBOL " ; rightShift ( ac , qr , qn , qrn ) ; } else if ( qn - qr [ 0 ] == 0 ) rightShift ( ac , qr , qn , qrn ) ; display ( ac , qr , qrn ) ; cout << " TABSYMBOL " ; sc -- ; cout << " TABSYMBOL " << sc << " STRNEWLINE " ; } } int main ( int argc , char * * arg ) { int mt [ 10 ] , sc ; int brn , qrn ; brn = 4 ; int br [ ] = { 0 , 1 , 1 , 0 } ; for ( int i = brn - 1 ; i >= 0 ; i -- ) mt [ i ] = br [ i ] ; reverse ( br , br + brn ) ; complement ( mt , brn ) ; qrn = 4 ; sc = qrn ; int qr [ ] = { 1 , 0 , 1 , 0 } ; reverse ( qr , qr + qrn ) ; boothAlgorithm ( br , qr , mt , qrn , sc ) ; cout << endl << " Result ▁ = ▁ " ; for ( int i = qrn - 1 ; i >= 0 ; i -- ) cout << qr [ i ] ; }
#include <iostream> NEW_LINE using namespace std ; unsigned long long int factorial ( unsigned int n ) { unsigned long long int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res *= i ; return res ; } void printNComposite ( int n ) { unsigned long long int fact = factorial ( n + 1 ) ; for ( int i = 2 ; i <= n + 1 ; ++ i ) cout << fact + i << " ▁ " ; } int main ( ) { int n = 4 ; printNComposite ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < long long int > primes ( long long int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } vector < long long int > arr ; for ( int i = 2 ; i < n ; i ++ ) if ( prime [ i ] ) arr . push_back ( i ) ; return arr ; } int countDigits ( long long int n ) { long long int temp = n ; int c = 0 ; while ( temp != 0 ) { temp = temp / 10 ; c ++ ; } return c ; } bool frugal ( long long int n ) { vector < long long int > r = primes ( n ) ; long long int t = n ; long long int s = 0 ; for ( int i = 0 ; i < r . size ( ) ; i ++ ) { if ( t % r [ i ] == 0 ) { long long int k = 0 ; while ( t % r [ i ] == 0 ) { t = t / r [ i ] ; k ++ ; } if ( k == 1 ) s = s + countDigits ( r [ i ] ) ; else if ( k != 1 ) s = s + countDigits ( r [ i ] ) + countDigits ( k ) ; } } return ( countDigits ( n ) > s && s != 0 ) ; } int main ( ) { long long int n = 343 ; if ( frugal ( n ) ) cout << " A ▁ Frugal ▁ number STRNEWLINE " ; else cout << " Not ▁ a ▁ frugal ▁ number STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthSquareCube ( int n ) { return n * n * n * n * n * n ; } int main ( ) { int n = 5 ; cout << nthSquareCube ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return -1 ; } int main ( ) { int s = 9 ; int n = findS ( s ) ; n == -1 ? cout << " - 1" : cout << n ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int findKthGoodNo ( long long int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; } int main ( ) { long long int n = 10 ; cout << findKthGoodNo ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkDigits ( int n ) { while ( n ) { return 0 ; n /= 10 ; } return 1 ; } int largestNumber ( int n ) { for ( int i = n ; ; i -- ) if ( checkDigits ( i ) ) return i ; } int main ( ) { int N = 23 ; cout << largestNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestNumber ( int n ) { string s = " " ; int duplicate = n ; while ( n ) { s = char ( n % 10 + 48 ) + s ; n /= 10 ; } int index = -1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s [ i ] - '0' ) % 2 & 1 ) { index = i ; break ; } } if ( index == -1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' - 1 ) ; for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 8 ; return num ; } int main ( ) { int N = 24578 ; cout << largestNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigits ( int n ) { return ( n * log10 ( 2 ) + 1 ) ; } int main ( ) { int n = 5 ; cout << countDigits ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int check_digits ( int n ) { while ( n ) { return 0 ; n /= 10 ; } return 1 ; } int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) ) return i ; } int main ( ) { int N = 2397 ; cout << smallest_number ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } bool checkFriendly ( int n , int m ) { int sumFactors_n = sumofFactors ( n ) ; int sumFactors_m = sumofFactors ( m ) ; int gcd_n = gcd ( n , sumFactors_n ) ; int gcd_m = gcd ( m , sumFactors_m ) ; if ( n / gcd_n == m / gcd_m && sumFactors_n / gcd_n == sumFactors_m / gcd_m ) return true ; else return false ; } int main ( ) { int n = 6 , m = 28 ; checkFriendly ( n , m ) ? ( cout << " Yes STRNEWLINE " ) : ( cout << " No STRNEWLINE " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } long long int primorial ( long long int n ) { long long int p = 2 ; n -- ; for ( int i = 3 ; n != 0 ; i ++ ) { if ( isPrime ( i ) ) { p = p * i ; n -- ; } i ++ ; } return p ; } long long int findNextPrime ( long long int n ) { long long int nextPrime = n + 2 ; while ( true ) { if ( isPrime ( nextPrime ) ) break ; nextPrime ++ ; } return nextPrime ; } long long int fortunateNumber ( int n ) { long long int p = primorial ( n ) ; return findNextPrime ( p ) - p ; } int main ( ) { long long int n = 5 ; cout << fortunateNumber ( n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << procal ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = pow ( a , n ) + pow ( b , n ) ; double c = pow ( pow_sum , 1.0 / n ) ; int c_pow = pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { cout << " Count ▁ example ▁ found " ; return ; } } cout << " No ▁ counter ▁ example ▁ within ▁ given " " ▁ range ▁ and ▁ data " ; } int main ( ) { testSomeNumbers ( 10 , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } void series ( int A , int X , int n ) { int nFact = factorial ( n ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { int niFact = factorial ( n - i ) ; int iFact = factorial ( i ) ; int aPow = pow ( A , n - i ) ; int xPow = pow ( X , i ) ; cout << ( nFact * aPow * xPow ) / ( niFact * iFact ) << " ▁ " ; } } int main ( ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } void productReduce ( int n , int num [ ] , int den [ ] ) { int new_num = 1 , new_den = 1 ; for ( int i = 0 ; i < n ; i ++ ) { new_num *= num [ i ] ; new_den *= den [ i ] ; } int GCD = gcd ( new_num , new_den ) ; new_num /= GCD ; new_den /= GCD ; cout << new_num << " / " << new_den << endl ; } int main ( ) { int n = 3 ; int num [ ] = { 1 , 2 , 5 } ; int den [ ] = { 2 , 1 , 6 } ; productReduce ( n , num , den ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; } int main ( ) { int n = 10 ; cout << fnMod ( n ) << endl ; n = 11 ; cout << fnMod ( n ) << endl ; return 0 ; }
#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int totalSumDivisibleByNum ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; } int main ( ) { int n = 3 , num = 7 ; cout << totalSumDivisibleByNum ( n , num ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string fractionToDecimal ( int numerator , int denominator ) { string res ; unordered_map < int , int > mp ; int rem = numerator % denominator ; while ( ( rem != 0 ) && ( mp . find ( rem ) == mp . end ( ) ) ) { mp [ rem ] = res . length ( ) ; rem = rem * 10 ; int res_part = rem / denominator ; res += to_string ( res_part ) ; rem = rem % denominator ; } return ( rem == 0 ) ? " - 1" : res . substr ( mp [ rem ] ) ; } bool isPrime ( int n ) { for ( int i = 2 ; i <= n / 2 ; i ++ ) if ( n % i == 0 ) return false ; return true ; } void ExtendedMidys ( string str , int n , int m ) { if ( ! isPrime ( n ) ) { cout << " Denominator ▁ is ▁ not ▁ prime , ▁ " << " thus ▁ Extended ▁ Midy ' s ▁ " << " theorem ▁ is ▁ not ▁ applicable " ; return ; } int l = str . length ( ) ; int part1 = 0 , part2 = 0 ; if ( l % 2 == 0 && l % m == 0 ) { int part [ m ] = { 0 } , sum = 0 , res = 0 ; for ( int i = 0 ; i < l ; i ++ ) { int var = i / m ; part [ var ] = part [ var ] * 10 + ( str [ i ] - '0' ) ; } for ( int i = 0 ; i < m ; i ++ ) { sum = sum + part [ i ] ; cout << part [ i ] << " ▁ " ; } cout << endl ; res = pow ( 10 , m ) - 1 ; if ( sum % res == 0 ) cout << " Extended ▁ Midy ' s ▁ theorem ▁ holds ! " ; else cout << " Extended ▁ Midy ' s ▁ theorem " << " ▁ doesn ' t ▁ hold ! " ; } else if ( l % 2 != 0 ) { cout << " The ▁ repeating ▁ decimal ▁ is " << " ▁ of ▁ odd ▁ length ▁ thus ▁ Extended ▁ " << " Midy ' s ▁ theorem ▁ is ▁ not ▁ applicable " ; } else if ( l % m != 0 ) { cout << " The ▁ repeating ▁ decimal ▁ can ▁ " << " not ▁ be ▁ divided ▁ into ▁ m ▁ digits " ; } } int main ( ) { int numr = 1 , denr = 17 , m = 4 ; string res = fractionToDecimal ( numr , denr ) ; if ( res == " - 1" ) cout << " The ▁ fraction ▁ does ▁ not " << " ▁ have ▁ repeating ▁ decimal " ; else { cout << " Repeating ▁ decimal ▁ = ▁ " << res << endl ; ExtendedMidys ( res , denr , m ) ; } return 0 ; }
#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int numberofterm ( int n , int number ) { int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; } int main ( ) { int n = 3 , num = 7 ; cout << numberofterm ( n , num ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int seiresSum ( int n , int a [ ] ) { int res = 0 ; for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( i % 2 == 0 ) res += a [ i ] * a [ i ] ; else res -= a [ i ] * a [ i ] ; } return res ; } int main ( ) { int n = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; cout << seiresSum ( n , a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void georgeCantor ( int n ) { int i = 1 ; int j = 1 ; int k = 1 ; while ( k < n ) { j ++ , k ++ ; if ( k == n ) break ; while ( j > 1 && k < n ) { i ++ , j -- , k ++ ; } if ( k == n ) break ; i ++ , k ++ ; if ( k == n ) break ; while ( i > 1 && k < n ) { i -- , j ++ , k ++ ; } } cout << " N - th ▁ term ▁ : ▁ " << i << " ▁ / ▁ " << j ; } int main ( ) { int n = 15 ; georgeCantor ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isDivisible ( long long int n ) { while ( n / 100 ) { int last_digit = n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; } int main ( ) { long long int n = 348 ; if ( isDivisible ( n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string solveEquation ( string equation ) { int n = equation . size ( ) , sign = 1 , coeff = 0 ; int total = 0 , i = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( equation [ j ] == ' + ' equation [ j ] == ' - ' ) { if ( j > i ) total += sign * stoi ( equation . substr ( i , j - i ) ) ; i = j ; } else if ( equation [ j ] == ' x ' ) { if ( ( i == j ) equation [ j - 1 ] == ' + ' ) coeff += sign ; else if ( equation [ j - 1 ] == ' - ' ) coeff -= sign ; else coeff += sign * stoi ( equation . substr ( i , j - i ) ) ; i = j + 1 ; } else if ( equation [ j ] == ' = ' ) { if ( j > i ) total += sign * stoi ( equation . substr ( i , j - i ) ) ; sign = -1 ; i = j + 1 ; } } if ( i < n ) total += sign * stoi ( equation . substr ( i ) ) ; if ( coeff == 0 && total == 0 ) return " Infinite ▁ solutions " ; if ( coeff == 0 && total ) return " No ▁ solution " ; int ans = - total / coeff ; return " x = " + to_string ( ans ) ; } int main ( ) { string equation = " x + 5-3 + x = 6 + x - 2" ; cout << solveEquation ( equation ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool pronic_check ( int n ) { int x = ( int ) ( sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; } int main ( void ) { int n = 56 ; pronic_check ( n ) == true ? cout << " YES " : cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int n , int r ) { int count = 0 ; for ( int i = r ; ( n / i ) >= 1 ; i = i * r ) count += n / i ; return count ; } int main ( ) { int n = 6 , r = 3 ; printf ( " ▁ % d ▁ " , power ( n , r ) ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void LucasLehmer ( int n ) { unsigned long long current_val = 4 ; vector < unsigned long long > series ; series . push_back ( current_val ) ; for ( int i = 0 ; i < n ; i ++ ) { current_val = current_val * current_val - 2 ; series . push_back ( current_val ) ; } for ( int i = 0 ; i <= n ; i ++ ) cout << " Term ▁ " << i << " : ▁ " << series [ i ] << endl ; } int main ( ) { int n = 5 ; LucasLehmer ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void checkperfectsquare ( int n ) { if ( ceil ( ( double ) sqrt ( n ) ) == floor ( ( double ) sqrt ( n ) ) ) { cout << " perfect ▁ square " ; } else { cout << " not ▁ a ▁ perfect ▁ square " ; } } int main ( ) { int n = 49 ; checkperfectsquare ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; bool check ( int n , int p ) { int maximum = -1 ; while ( ! ( n % 2 ) ) { maximum = max ( maximum , 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maximum = max ( maximum , i ) ; n = n / i ; } } if ( n > 2 ) maximum = max ( maximum , n ) ; return ( maximum <= p ) ; } int main ( ) { int n = 24 , p = 7 ; if ( check ( n , p ) ) cout << " yes " ; else cout << " no " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; } int main ( ) { int n = 2 ; cout << sum_series ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int day_of_the_week ( int y , int m , int d ) { int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ) ; } int main ( void ) { int day = 13 , month = 7 , year = 2017 ; cout << ( day_of_the_week ( year , month , day ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n , int i = 2 ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; } int main ( ) { int n = 15 ; if ( isPrime ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; } int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; } int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float mean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; } float SSD ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; return sqrt ( sum / ( n - 1 ) ) ; } float sampleError ( float arr [ ] , int n ) { return SSD ( arr , n ) / sqrt ( n ) ; } int main ( ) { float arr [ ] = { 78.53 , 79.62 , 80.25 , 81.05 , 83.21 , 83.46 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sampleError ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int StepstoReachTarget ( int target ) { target = abs ( target ) ; int n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) ? 2 : 1 ) ; } int main ( ) { int target = 5 ; cout << StepstoReachTarget ( target ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int avg_of_odd_num ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) ; return sum / n ; } int main ( ) { int n = 20 ; cout << avg_of_odd_num ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int avg_of_odd_num ( int n ) { return n ; } int main ( ) { int n = 8 ; cout << avg_of_odd_num ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; bool sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; } int main ( ) { int n = 5 ; cout << seriesSum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int modInverse ( int a , int prime ) { a = a % prime ; for ( int x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return -1 ; } void printModIverses ( int n , int prime ) { for ( int i = 1 ; i <= n ; i ++ ) cout << modInverse ( i , prime ) << " ▁ " ; } int main ( ) { int n = 10 , prime = 17 ; printModIverses ( n , prime ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE unsigned int countSymmetric ( unsigned int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; } int main ( ) { unsigned int n = 3 ; printf ( " % u " , countSymmetric ( n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; } int main ( ) { int n = 10 ; cout << centeredNonagonal ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void fib ( int f [ ] , int N ) { f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( int i = 3 ; i <= N ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } void fiboTriangle ( int n ) { int N = n * ( n + 1 ) / 2 ; int f [ N + 1 ] ; fib ( f , N ) ; int fiboNum = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) cout << f [ fiboNum ++ ] << " ▁ " ; cout << endl ; } } int main ( ) { int n = 5 ; fiboTriangle ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Mean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; } float meanAbsoluteDeviation ( float arr [ ] , int n ) { float absSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) absSum = absSum + abs ( arr [ i ] - Mean ( arr , n ) ) ; return absSum / n ; } int main ( ) { float arr [ ] = { 10 , 15 , 15 , 17 , 18 , 21 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << meanAbsoluteDeviation ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; } int main ( ) { int lowCost = 14 , upCost = 30 , lowQuant = 5 , upQuant = 12 , r = 9 ; if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; } int main ( ) { int n = 4 ; cout << oddNumSum ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int trailingZero ( int x ) { int i = 5 , count = 0 ; while ( x > i ) { count = count + x / i ; i = i * 5 ; } return count ; } int countProductTrailing ( int M , int N ) { return trailingZero ( N ) + trailingZero ( M ) ; } int main ( ) { int N = 67 , M = 98 ; cout << countProductTrailing ( N , M ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isTrimorphic ( int N ) { int cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N /= 10 ; cube /= 10 ; } return true ; } int main ( ) { int N = 24 ; isTrimorphic ( N ) ? cout << " trimorphic " : cout << " not ▁ trimporphic " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; # define INT_MAX  2147483647 NEW_LINE bool checkTrimorphic ( int num ) { int cube = num * num * num ; while ( num > 0 ) { if ( num % 10 != cube % 10 ) return false ; num /= 10 ; cube /= 10 ; } return true ; } int nthTrimorphic ( int n ) { int count = 0 ; for ( int i = 0 ; i < INT_MAX ; i ++ ) { if ( checkTrimorphic ( i ) ) count ++ ; if ( count == n ) return i ; } } int main ( ) { int n = 9 ; cout << nthTrimorphic ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int reachTarget ( int target ) { target = abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; } int main ( ) { int target = 5 ; cout << reachTarget ( target ) ; return 0 ; }
#include <stdio.h> NEW_LINE int averageOdd ( int n ) { if ( n % 2 == 0 ) { printf ( " Invalid ▁ Input " ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 1 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } int main ( ) { int n = 15 ; printf ( " % d " , averageOdd ( n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; } int main ( ) { int n = 5 ; cout << fifthPowerSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; } int main ( ) { cout << unitDigitXRaisedY ( 4 , 2 ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE #include <algorithm> NEW_LINE #include <cmath> NEW_LINE using namespace std ; typedef pair < float , float > Data ; typedef vector < Data > Vector ; float sigma_fx ( const Vector & v ) { float sum = 0 ; for ( auto i : v ) { sum += i . first * i . second ; } return sum ; } float sigma_f ( const Vector & v ) { float sum = 0.0 ; for ( auto i : v ) { sum += i . second ; } return sum ; } float calculate_mean ( const Vector & v ) { return sigma_fx ( v ) / sigma_f ( v ) ; } float calculate_std ( const Vector & v ) { float f = sigma_f ( v ) ; float mean = sigma_fx ( v ) / f ; float sum = 0 ; for ( auto i : v ) { sum += ( i . first - mean ) * ( i . first - mean ) * i . second ; } return sqrt ( sum / f ) ; } int main ( ) { Vector A = { { 0 , 0.1 } , { 100 , 0.1 } , { 200 , 0.2 } , { 333 , 0.3 } , { 400 , 0.3 } } ; Vector B = { { 100 , 0.1 } , { 200 , 0.5 } , { 700 , 0.4 } } ; float avg_A = calculate_mean ( A ) ; float avg_B = calculate_mean ( B ) ; float std_A = calculate_std ( A ) ; float std_B = calculate_std ( B ) ; cout << " For ▁ Investment ▁ A " << endl ; cout << " Average : ▁ " << avg_A << endl ; cout << " Standard ▁ Deviation : ▁ " << std_A << endl ; cout << " Normalised ▁ Std : ▁ " << std_A / avg_A << endl ; cout << " For ▁ Investment ▁ B " << endl ; cout << " Average : ▁ " << avg_B << endl ; cout << " Standard ▁ Deviation : ▁ " << std_B << endl ; cout << " Normalised ▁ Std : ▁ " << std_B / avg_B << endl ; ( std_B / avg_B ) < ( std_A / avg_A ) ? cout << " Investment ▁ B ▁ is ▁ less ▁ risky STRNEWLINE " : cout << " Investment ▁ A ▁ is ▁ less ▁ risky STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findDivisor ( int x , int y ) { if ( x == y ) return y ; return 2 ; } int main ( ) { int x = 3 , y = 16 ; cout << findDivisor ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 , curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } int main ( ) { int n = 18 ; cout << sumofFactors ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; float focal_length_concave ( float R ) { return R / 2 ; } float focal_length_convex ( float R ) { return - ( R / 2 ) ; } int main ( ) { float R = 30 ; cout << " Focal ▁ length ▁ of ▁ spherical " << " concave ▁ mirror ▁ is ▁ : ▁ " << focal_length_concave ( R ) << " ▁ units STRNEWLINE " ; cout << " Focal ▁ length ▁ of ▁ spherical " << " convex ▁ mirror ▁ is ▁ : ▁ " << focal_length_convex ( R ) << " ▁ units " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Rational { int nume , deno ; } ; int lcm ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; } Rational maxRational ( Rational first , Rational sec ) { int k = lcm ( first . deno , sec . deno ) ; int nume1 = first . nume ; int nume2 = sec . nume ; nume1 *= k / ( first . deno ) ; nume2 *= k / ( sec . deno ) ; return ( nume2 < nume1 ) ? first : sec ; } int main ( ) { Rational first = { 3 , 2 } ; Rational sec = { 3 , 4 } ; Rational res = maxRational ( first , sec ) ; cout << res . nume << " / " << res . deno ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  6 NEW_LINE using namespace std ; void fib ( int f [ ] , int n ) { int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( i = 2 ; i <= n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } void fibcoef ( int fc [ ] [ N + 1 ] , int f [ ] , int n ) { for ( int i = 0 ; i <= n ; i ++ ) fc [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int k = j ; while ( k -- ) fc [ i ] [ j ] *= f [ k ] ; k = 1 ; while ( ( j + 1 ) != k ) fc [ i ] [ j ] /= f [ k ++ ] ; } } } void printFibonomialTriangle ( int n ) { int f [ N + 1 ] = { 0 } ; fib ( f , n ) ; int dp [ N + 1 ] [ N + 1 ] = { 0 } ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) dp [ i ] [ j ] = f [ i - j + 1 ] * dp [ i - 1 ] [ j - 1 ] + f [ j - 1 ] * dp [ i - 1 ] [ j ] ; } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) cout << dp [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int n = 6 ; printFibonomialTriangle ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; } int main ( ) { int n = 5 ; cout << " Sum ▁ = ▁ " << sumOfTheSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; } int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int TrinomialValue ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k < - n k > n ) return 0 ; return TrinomialValue ( n - 1 , k - 1 ) + TrinomialValue ( n - 1 , k ) + TrinomialValue ( n - 1 , k + 1 ) ; } void printTrinomial ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = - i ; j <= 0 ; j ++ ) cout << TrinomialValue ( i , j ) << " ▁ " ; for ( int j = 1 ; j <= i ; j ++ ) cout << TrinomialValue ( i , j ) << " ▁ " ; cout << endl ; } } int main ( ) { int n = 4 ; printTrinomial ( n ) ; return 0 ; }
#include <math.h> NEW_LINE #include <stdio.h> NEW_LINE double Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 , p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( -1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; } int main ( ) { double x = 9 ; int n = 10 ; printf ( " % .4f " , Series ( x , n ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int two_factor ( int n ) { int twocount = 0 ; while ( n % 2 == 0 ) { twocount ++ ; n = n / 2 ; } return twocount ; } int five_factor ( int n ) { int fivecount = 0 ; while ( n % 5 == 0 ) { fivecount ++ ; n = n / 5 ; } return fivecount ; } int find_con_zero ( int arr [ ] , int n ) { int twocount = 0 ; int fivecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twocount += two_factor ( arr [ i ] ) ; fivecount += five_factor ( arr [ i ] ) ; } if ( twocount < fivecount ) return twocount ; else return fivecount ; } int main ( ) { int arr [ ] = { 100 , 10 , 5 , 25 , 35 , 14 } ; int n = 6 ; cout << find_con_zero ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " Second subset sum = " << s / 2 ; cout << " Difference = " } else { if ( n % 4 == 1 n % 4 == 2 ) { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " Second subset sum = " << s / 2 + 1 ; cout << " Difference = " } else { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " Second subset sum = " << s / 2 ; cout << " Difference = " } } } int main ( ) { int n = 6 ; subsetDifference ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; cout << time ; } int main ( void ) { double s = 25 , v = 56 ; timeToMeet ( s , v ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; } int main ( ) { int n = 5 ; cout << " Sum ▁ = ▁ " << sumOfTheSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checksum ( int n ) { if ( n == 0 ) { cout << " - 1 ▁ 0 ▁ 1" << endl ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = -1 ; for ( int i = 0 ; i <= n - 2 ; i += inc ) { if ( i + i + 1 + i + 2 == n ) { cout << i << " ▁ " << i + 1 << " ▁ " << i + 2 ; return ; } } cout << " - 1" ; } int main ( ) { int n = 6 ; checksum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; } int main ( ) { int n = 4 ; cout << " ▁ " << divisorSum ( n ) << endl ; n = 5 ; cout << " ▁ " << divisorSum ( n ) ; return 0 ; }
#include <stdio.h> NEW_LINE int printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { printf ( " % 2d " , m ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; printf ( " % 4d " , binom ) ; } printf ( " STRNEWLINE " ) ; } } int main ( ) { int max = 10 ; printbinomial ( max ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfLargePrimeFactor ( int n ) { int prime [ n + 1 ] , sum = 0 ; memset ( prime , 0 , sizeof ( prime ) ) ; int max = n / 2 ; for ( int p = 2 ; p <= max ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = p ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) sum += prime [ p ] ; else sum += p ; } return sum ; } int main ( ) { int n = 12 ; cout << " Sum ▁ = ▁ " << sumOfLargePrimeFactor ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; long long maxPrimeFactors ( long long n ) { long long maxPrime = -1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; } while ( n % 3 == 0 ) { maxPrime = 3 ; n = n / 3 ; } for ( int i = 5 ; i <= sqrt ( n ) ; i += 6 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } while ( n % ( i + 2 ) == 0 ) { maxPrime = i + 2 ; n = n / ( i + 2 ) ; } } if ( n > 4 ) maxPrime = n ; return maxPrime ; } int main ( ) { long long n = 15 ; cout << maxPrimeFactors ( n ) << endl ; n = 25698751364526 ; cout << maxPrimeFactors ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; } unsigned int countUnsetBitsInGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( r - l + 1 ) - countSetBits ( n & num ) ; } int main ( ) { unsigned int n = 80 ; unsigned int l = 1 , r = 4 ; cout << countUnsetBitsInGivenRange ( n , l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string fractionToDecimal ( int numerator , int denominator ) { string res ; map < int , int > mp ; mp . clear ( ) ; int rem = numerator % denominator ; while ( ( rem != 0 ) && ( mp . find ( rem ) == mp . end ( ) ) ) { mp [ rem ] = res . length ( ) ; rem = rem * 10 ; int res_part = rem / denominator ; res += to_string ( res_part ) ; rem = rem % denominator ; } return ( rem == 0 ) ? " - 1" : res . substr ( mp [ rem ] ) ; } bool isPrime ( int n ) { for ( int i = 2 ; i <= n / 2 ; i ++ ) if ( n % i == 0 ) return false ; return true ; } void Midys ( string str , int n ) { int l = str . length ( ) ; int part1 = 0 , part2 = 0 ; if ( ! isPrime ( n ) ) { cout << " Denominator ▁ is ▁ not ▁ prime , ▁ " << " thus ▁ Midy ' s ▁ theorem ▁ is ▁ not ▁ applicable " ; } else if ( l % 2 == 0 ) { for ( int i = 0 ; i < l / 2 ; i ++ ) { part1 = part1 * 10 + ( str [ i ] - '0' ) ; part2 = part2 * 10 + ( str [ l / 2 + i ] - '0' ) ; } cout << part1 << " ▁ + ▁ " << part2 << " ▁ = ▁ " << ( part1 + part2 ) << endl ; cout << " Midy ' s ▁ theorem ▁ holds ! " ; } else { cout << " The ▁ repeating ▁ decimal ▁ is ▁ of ▁ odd ▁ length ▁ " << " thus ▁ Midy ' s ▁ theorem ▁ is ▁ not ▁ applicable " ; } } int main ( ) { int numr = 2 , denr = 11 ; string res = fractionToDecimal ( numr , denr ) ; if ( res == " - 1" ) cout << " The ▁ fraction ▁ does ▁ not ▁ have ▁ repeating ▁ decimal " ; else { cout << " Repeating ▁ decimal ▁ = ▁ " << res << endl ; Midys ( res , denr ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int evenPowerSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; } int main ( ) { int n = 5 ; cout << evenPowerSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; } int main ( ) { int n = 4 ; cout << evenPowerSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  501 NEW_LINE using namespace std ; int balancedprime ( int n ) { bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } vector < int > v ; for ( int p = 3 ; p <= MAX ; p += 2 ) if ( prime [ p ] ) v . push_back ( p ) ; int count = 0 ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] == ( v [ i + 1 ] + v [ i - 1 ] ) / 2 ) count ++ ; if ( count == n ) return v [ i ] ; } } int main ( ) { int n = 4 ; cout << balancedprime ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000001 ; int factor [ MAX ] = { 0 } ; void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; } int smallest ( int n ) { for ( int i = 1 ; ; i ++ ) if ( calculateNoOFactors ( i ) >= n ) return i ; } int main ( ) { generatePrimeFactors ( ) ; int n = 4 ; cout << smallest ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; } int main ( ) { int n = 4 ; cout << squaresum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstDigit ( int n ) { while ( n >= 10 ) n /= 10 ; return n ; } int lastDigit ( int n ) { return ( n % 10 ) ; } int main ( ) { int n = 98562 ; cout << firstDigit ( n ) << " ▁ " << lastDigit ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstDigit ( int n ) { int digits = ( int ) log10 ( n ) ; n = ( int ) ( n / pow ( 10 , digits ) ) ; return n ; } int lastDigit ( int n ) { return ( n % 10 ) ; } int main ( ) { int n = 98562 ; cout << firstDigit ( n ) << " ▁ " << lastDigit ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int x ) { if ( x == 0 x == 1 ) return false ; for ( int i = 2 ; i * i <= x ; ++ i ) if ( x % i == 0 ) return false ; return true ; } void findPrimes ( int n ) { cout << n << endl ; cout << 2 << " ▁ " << n - 2 << endl ; { cout << 3 << " ▁ " ; n = n - 3 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i ) && isPrime ( n - i ) ) { cout << i << " ▁ " << ( n - i ) ; break ; } } } } int main ( ) { int n = 27 ; findPrimes ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long c [ 100 ] ; void coef ( int n ) { c [ 0 ] = 1 ; for ( int i = 0 ; i < n ; c [ 0 ] = - c [ 0 ] , i ++ ) { c [ 1 + i ] = 1 ; for ( int j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; } } bool isPrime ( int n ) { coef ( n ) ; c [ 0 ] ++ , c [ n ] -- ; int i = n ; while ( i -- && c [ i ] % n == 0 ) ; return i < 0 ; } int main ( ) { int n = 37 ; if ( isPrime ( n ) ) cout << " Prime " << endl ; else cout << " Not ▁ Prime " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int motzkin ( int n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; } int main ( ) { int n = 8 ; cout << motzkin ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ; } int main ( ) { int n = 2 ; cout << sumOfSeries ( n ) ; }
#include <iostream> NEW_LINE using namespace std ; int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; } int main ( ) { int n = 2 ; cout << summation ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; void leyland ( int n ) { vector < int > ans ; for ( int x = 2 ; x <= n ; x ++ ) { for ( int y = 2 ; y <= x ; y ++ ) { int temp = pow ( x , y ) + pow ( y , x ) ; ans . push_back ( temp ) ; } } sort ( ans . begin ( ) , ans . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { int n = 6 ; leyland ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; } int main ( ) { int k = 3 ; cout << kthgroupsum ( k ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; } int main ( ) { int n = 4 ; cout << nthTerm ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } int main ( ) { int n = 4 ; cout << seriesSum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; double cal_speed ( double dist , double time ) { cout << " Distance ( km ) : " cout << " Time ( hr ) : " return dist / time ; } double cal_dis ( double speed , double time ) { cout << " Time ( hr ) : " cout << " Speed ( km / hr ) : " return speed * time ; } double cal_time ( double dist , double speed ) { cout << " Distance ( km ) : " cout << " Speed ( km / hr ) : " return speed * dist ; } int main ( ) { cout << " The calculated Speed ( km / hr ) is : " << cal_speed ( 45.9 , 2.0 ) << endl ; cout << " The calculated Distance ( km ) : " << cal_dis ( 62.9 , 2.5 ) << endl ; cout << " The calculated Time ( hr ) : " << cal_time ( 48.0 , 4.5 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float avgOfFirstN ( int n ) { return ( float ) ( 1 + n ) / 2 ; } int main ( ) { int n = 20 ; cout << avgOfFirstN ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE int summation ( int n ) { int sum ; sum = ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; } int main ( ) { int n = 5 ; printf ( " % d " , summation ( n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int term ( int n ) { int x = ( ( ( 1 ) + ( double ) sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; } int main ( ) { int n = 5 ; cout << term ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int countDigits ( int n ) { int c = 0 ; do { c ++ ; n = n / 10 ; } while ( n != 0 ) ; return c ; } bool isDeserium ( int x ) { int temp = x ; int p = countDigits ( x ) ; int sum = 0 ; while ( x != 0 ) { int digit = x % 10 ; sum += pow ( digit , p ) ; p -- ; x = x / 10 ; } return ( sum == temp ) ; } int main ( ) { int x = 135 ; if ( isDeserium ( x ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float mean ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; float mean = ( float ) sum / n ; return mean ; } float sd ( int arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; float sdd = sum / n ; return sdd ; } float combinedVariance ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { float mean1 = mean ( arr1 , n ) ; float mean2 = mean ( arr2 , m ) ; cout << " Mean1 : ▁ " << mean1 << " ▁ mean2 : ▁ " << mean2 << endl ; float sd1 = sd ( arr1 , n ) ; float sd2 = sd ( arr2 , m ) ; cout << " StandardDeviation1 : ▁ " << sd1 << " ▁ StandardDeviation2 : ▁ " << sd2 << endl ; float combinedMean = ( float ) ( n * mean1 + m * mean2 ) / ( n + m ) ; cout << " Combined ▁ Mean : ▁ " << combinedMean << endl ; float d1_square = ( mean1 - combinedMean ) * ( mean1 - combinedMean ) ; float d2_square = ( mean2 - combinedMean ) * ( mean2 - combinedMean ) ; cout << " d1 ▁ square : ▁ " << d1_square << " ▁ d2 _ square : ▁ " << d2_square << endl ; float combinedVar = ( n * ( sd1 + d1_square ) + m * ( sd2 + d2_square ) ) / ( n + m ) ; return combinedVar ; } int main ( ) { int arr1 [ ] = { 23 , 45 , 34 , 78 , 12 , 76 , 34 } ; int arr2 [ ] = { 65 , 67 , 34 , 23 , 45 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << " Combined ▁ Variance : ▁ " << combinedVariance ( arr1 , arr2 , n , m ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool checkDivisibility ( string num ) { int length = num . size ( ) ; if ( length == 1 && num [ 0 ] == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num [ i -- ] - '0' ; group += ( num [ i -- ] - '0' ) * 10 ; group += ( num [ i ] - '0' ) * 100 ; sum = sum + group * p ; p *= ( -1 ) ; } sum = abs ( sum ) ; return ( sum % 13 == 0 ) ; } int main ( ) { string number = "83959092724" ; if ( checkDivisibility ( number ) ) cout << number << " ▁ is ▁ divisible ▁ by ▁ 13 . " ; else cout << number << " ▁ is ▁ not ▁ divisible ▁ by ▁ 13 . " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void modularEquation ( int a , int b ) { if ( a < b ) { cout << " No ▁ solution ▁ possible ▁ " << endl ; return ; } if ( a == b ) { cout << " Infinite ▁ Solution ▁ possible ▁ " << endl ; return ; } int count = 0 ; int n = a - b ; int y = sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; cout << count << endl ; } int main ( ) { int a = 21 , b = 5 ; modularEquation ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOp ( long long int num ) { int rem ; int count = 0 ; while ( num ) { rem = num % 10 ; if ( ! ( rem == 3 rem == 8 ) ) count ++ ; num /= 10 ; } return count ; } int main ( ) { long long int num = 234198 ; cout << " Minimum ▁ Operations ▁ = " << minOp ( num ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countWays ( int num ) { int dp [ num + 1 ] ; const int MOD = 1e9 + 7 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= num ; ++ i ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 3 ; ++ j ) { if ( i - j == 0 ) dp [ i ] += 1 ; else if ( j == 1 ) dp [ i ] += dp [ i - j ] * 2 ; else if ( i - j > 0 ) dp [ i ] += dp [ i - j ] ; if ( dp [ i ] >= MOD ) dp [ i ] %= MOD ; } } return dp [ num ] ; } int main ( ) { int n = 3 ; cout << countWays ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sumSquare ( int n ) { unordered_map < int , int > s ; for ( int i = 0 ; i * i <= n ; ++ i ) { s [ i * i ] = 1 ; if ( s . find ( n - i * i ) != s . end ( ) ) { cout << sqrt ( n - i * i ) << " ^ 2 ▁ + ▁ " << i << " ^ 2" << endl ; return true ; } } return false ; } int main ( ) { int n = 169 ; if ( sumSquare ( n ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; } int main ( ) { int n = 17 ; if ( judgeSquareSum ( n ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + min ( max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; } int main ( ) { int n = 13 ; cout << countDigitOne ( n ) << endl ; n = 113 ; cout << countDigitOne ( n ) << endl ; n = 205 ; cout << countDigitOne ( n ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( char c ) { return ( c == '2' c == '3' c == '5' c == '7' ) ; } void decrease ( string & s , int i ) { if ( s [ i ] <= '2' ) { s . erase ( i , 1 ) ; s [ i ] = '7' ; } else if ( s [ i ] == '3' ) s [ i ] = '2' ; else if ( s [ i ] <= '5' ) s [ i ] = '3' ; else if ( s [ i ] <= '7' ) s [ i ] = '5' ; else s [ i ] = '7' ; return ; } string primeDigits ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! isPrime ( s [ i ] ) ) { while ( s [ i ] <= '2' && i >= 0 ) i -- ; if ( i < 0 ) { i = 0 ; decrease ( s , i ) ; } else decrease ( s , i ) ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) s [ j ] = '7' ; break ; } } return s ; } int main ( ) { string s = "45" ; cout << primeDigits ( s ) << endl ; s = "1000" ; cout << primeDigits ( s ) << endl ; s = "7721" ; cout << primeDigits ( s ) << endl ; s = "7221" ; cout << primeDigits ( s ) << endl ; s = "74545678912345689748593275897894708927680" ; cout << primeDigits ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factors ( long long n ) { unordered_map < int , int > prime ; for ( int i = 2 ; i <= sqrt ( n ) ; ++ i ) { while ( n % i == 0 ) { ++ prime [ i ] ; n = n / i ; } } if ( n > 2 ) ++ prime [ n ] ; int ans1 = 1 , ans2 = 1 ; for ( auto it : prime ) { ans1 *= 2 * it . second + 1 ; ans2 *= it . second + 1 ; } return ans1 - ans2 ; } int main ( ) { long long n = 5 ; cout << factors ( n ) << endl ; n = 8 ; cout << factors ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void greatest ( string s ) { int n = s . length ( ) ; int a [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s [ i ] - '0' ; sum += a [ i ] ; } { if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) { cout << " - 1" << endl ; } else { cout << n << endl ; } } else { int re = sum % 3 ; int del = -1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ; break ; } else { del = i ; } } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) del = n - 1 ; } if ( del == -1 ) cout << -1 << endl ; else { cout << del + 1 << endl ; } } } int main ( ) { string s = "7510222" ; greatest ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool asPowerSum ( int w , int m ) { while ( m ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; } int main ( ) { int w = 3 , m = 7 ; if ( asPowerSum ( w , m ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divisible ( string num ) { int n = num . length ( ) ; int sum = accumulate ( begin ( num ) , end ( num ) , 0 ) - '0' * 1 ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return -1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ; if ( n == 2 ) return -1 ; return 2 ; } int main ( ) { string num = "1234" ; cout << divisible ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int dotProduct ( int vect_A [ ] , int vect_B [ ] ) { int product = 0 ; for ( int i = 0 ; i < n ; i ++ ) product = product + vect_A [ i ] * vect_B [ i ] ; return product ; } void crossProduct ( int vect_A [ ] , int vect_B [ ] , int cross_P [ ] ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; } int main ( ) { int vect_A [ ] = { 3 , -5 , 4 } ; int vect_B [ ] = { 2 , 6 , 5 } ; int cross_P [ n ] ; cout << " Dot ▁ product : " ; cout << dotProduct ( vect_A , vect_B ) << endl ; cout << " Cross ▁ product : " ; crossProduct ( vect_A , vect_B , cross_P ) ; for ( int i = 0 ; i < n ; i ++ ) cout << cross_P [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalNumber ( int n ) { return 8 * pow ( 9 , n - 1 ) ; } int main ( ) { int n = 3 ; cout << totalNumber ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MOD = 1e9 + 7 ; int power ( int x , unsigned int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( 1LL * res * x ) % p ; x = ( 1LL * x * x ) % p ; } return res ; } int countEvenWays ( int n ) { return power ( 2 , n / 2 - 1 , MOD ) ; } int main ( ) { int n = 6 ; cout << countEvenWays ( n ) << " STRNEWLINE " ; n = 8 ; cout << countEvenWays ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 1000001 ; int factor [ MAX ] = { 0 } ; void cal_factor ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } int no_of_representations ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = a [ i ] ; int flag = 0 ; while ( factor [ temp ] != 1 ) { flag = -1 ; count ++ ; temp = temp / factor [ temp ] ; } count += flag ; } return count ; } int main ( ) { cal_factor ( ) ; int a [ ] = { 4 , 4 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << no_of_representations ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; } int main ( ) { int M = 3 ; int A [ ] = { 1 , 2 , 4 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << coutSubSeq ( A , N , M ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSubSeq ( int A [ ] , int N , int M ) { int ans = 0 ; int h [ M ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; } int main ( ) { int M = 3 ; int A [ ] = { 1 , 2 , 4 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << countSubSeq ( A , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } } int main ( ) { int n = 5 ; cout << findTerm ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; } int main ( ) { int n = 3 ; cout << findNumber ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ; return corr ; } int main ( ) { int X [ ] = { 15 , 18 , 21 , 24 , 27 } ; int Y [ ] = { 25 , 25 , 27 , 31 , 32 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << correlationCoefficient ( X , Y , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void result ( long long n , long long k , long long t ) { if ( t <= k ) cout << t ; else if ( t <= n ) cout << k ; else { long long temp = t - n ; temp = k - temp ; cout << temp ; } } int main ( ) { long long n , k , t ; n = 10 ; k = 5 ; t = 12 ; result ( n , k , t ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float weightedMean ( int X [ ] , int W [ ] , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) numWeight / sum ; } int main ( ) { int X [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int W [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; int m = sizeof ( W ) / sizeof ( W [ 0 ] ) ; if ( n == m ) cout << weightedMean ( X , W , n ) ; else cout << " - 1" ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigits ( int a ) { int sum = 0 ; while ( a ) { sum += a % 10 ; a /= 10 ; } return sum ; } int findMax ( int x ) { int b = 1 , ans = x ; while ( x ) { int cur = ( x - 1 ) * b + ( b - 1 ) ; if ( sumOfDigits ( cur ) > sumOfDigits ( ans ) || ( sumOfDigits ( cur ) == sumOfDigits ( ans ) && cur > ans ) ) ans = cur ; x /= 10 ; b *= 10 ; } return ans ; } int main ( ) { int n = 521 ; cout << findMax ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float harmonicMean ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; } int main ( ) { float arr [ ] = { 13.5 , 14.5 , 14.8 , 15.2 , 16.1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << harmonicMean ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float harmonicMean ( int arr [ ] , int freq [ ] , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return frequency_sum / sum ; } int main ( ) { int num [ ] = { 13 , 14 , 15 , 16 , 17 } ; int freq [ ] = { 2 , 5 , 13 , 7 , 3 } ; int n = sizeof ( num ) / sizeof ( num [ 0 ] ) ; cout << harmonicMean ( num , freq , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int calculate_sum ( int a , int N ) { int m = N / a ; int sum = m * ( m + 1 ) / 2 ; int ans = a * sum ; return ans ; } int main ( ) { int a = 7 , N = 49 ; cout << " Sum ▁ of ▁ multiples ▁ of ▁ " << a << " ▁ up ▁ to ▁ " << N << " ▁ = ▁ " << calculate_sum ( a , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void point ( int a , int b , int c , int d , int n ) { int x , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = b + i * a ; if ( ( x - d ) % c == 0 and x - d >= 0 ) { cout << x << endl ; flag = 1 ; break ; } } if ( flag == 0 ) { cout << " No ▁ collision ▁ point " << endl ; } } int main ( ) { int a = 20 ; int b = 2 ; int c = 9 ; int d = 19 ; int n = 20 ; point ( a , b , c , d , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findArmstrong ( int low , int high ) { for ( int i = low + 1 ; i < high ; ++ i ) { int x = i ; int n = 0 ; while ( x != 0 ) { x /= 10 ; ++ n ; } int pow_sum = 0 ; x = i ; while ( x != 0 ) { int digit = x % 10 ; pow_sum += pow ( digit , n ) ; x /= 10 ; } if ( pow_sum == i ) cout << i << " ▁ " ; } } int main ( ) { int num1 = 100 ; int num2 = 400 ; findArmstrong ( num1 , num2 ) ; cout << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <boost/multiprecision/cpp_int.hpp> NEW_LINE using namespace std ; using namespace boost :: multiprecision ; bool ispowerof2 ( cpp_int num ) { if ( ( num & ( num - 1 ) ) == 0 ) return 1 ; return 0 ; } int main ( ) { cpp_int num = 549755813888 ; cout << ispowerof2 ( num ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int median ( int * a , int l , int r ) { int n = r - l + 1 ; n = ( n + 1 ) / 2 - 1 ; return n + l ; } int IQR ( int * a , int n ) { sort ( a , a + n ) ; int mid_index = median ( a , 0 , n ) ; int Q1 = a [ median ( a , 0 , mid_index ) ] ; int Q3 = a [ mid_index + median ( a , mid_index + 1 , n ) ] ; return ( Q3 - Q1 ) ; } int main ( ) { int a [ ] = { 1 , 19 , 7 , 6 , 5 , 9 , 12 , 27 , 18 , 2 , 15 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << IQR ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool printPierpont ( int n ) { bool arr [ n + 1 ] ; memset ( arr , false , sizeof arr ) ; int two = 1 , three = 1 ; while ( two + 1 < n ) { arr [ two ] = true ; while ( two * three + 1 < n ) { arr [ three ] = true ; arr [ two * three ] = true ; three *= 3 ; } three = 1 ; two *= 2 ; } vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] ) v . push_back ( i + 1 ) ; memset ( arr , false , sizeof arr ) ; for ( int p = 2 ; p * p < n ; p ++ ) { if ( arr [ p ] == false ) for ( int i = p * 2 ; i < n ; i += p ) arr [ i ] = true ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) if ( ! arr [ v [ i ] ] ) cout << v [ i ] << " ▁ " ; } int main ( ) { int n = 200 ; printPierpont ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; } int main ( ) { int x = 383 ; ( isWoodall ( x ) ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_result ( int a [ ] , int n , int k , int m ) { vector < int > v [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v [ rem ] . push_back ( a [ i ] ) ; if ( v [ rem ] . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) cout << v [ rem ] [ j ] << " ▁ " ; return ; } } cout << " - 1" ; } int main ( ) { int a [ ] = { 1 , 8 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; print_result ( a , n , 2 , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestX ( int n ) { int temp [ 10 ] = { 0 } ; if ( n == 0 ) return -1 ; int count = 0 , x = 0 ; for ( x = 1 ; count < 10 ; x ++ ) { int y = x * n ; while ( y ) { if ( temp [ y % 10 ] == false ) { count ++ ; temp [ y % 10 ] = true ; } y /= 10 ; } } return x - 1 ; } int main ( ) { int n = 5 ; cout << smallestX ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digSum ( int n ) { int sum = 0 , rem = 0 ; while ( n ) { rem = n % 10 ; sum += rem ; n /= 10 ; } return sum ; } int findX ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i + digSum ( i ) == n ) return i ; return -1 ; } int main ( ) { int n = 43 ; cout << " x ▁ = ▁ " << findX ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void complement ( string number ) { for ( int i = 0 ; i < number . length ( ) ; i ++ ) if ( number [ i ] != ' . ' ) number [ i ] = '9' - number [ i ] + '0' ; cout << "9 ' s ▁ complement ▁ is ▁ : ▁ " << number ; } int main ( ) { string number = "345.45" ; complement ( number ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; } int main ( ) { int n = 12 ; cout << countWays ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDigitPresent ( int m , bool hash [ ] ) { while ( m ) { if ( hash [ m % 10 ] ) return true ; m = m / 10 ; } return false ; } int countDivisibles ( int n ) { bool hash [ 10 ] = { 0 } ; int m = n ; while ( m ) { hash [ m % 10 ] = true ; m = m / 10 ; } int ans = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( isDigitPresent ( i , hash ) ) ans ++ ; if ( n / i != i ) { if ( isDigitPresent ( n / i , hash ) ) ans ++ ; } } } return ans ; } int main ( ) { int n = 15 ; cout << countDivisibles ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void luDecomposition ( int mat [ ] [ MAX ] , int n ) { int lower [ n ] [ n ] , upper [ n ] [ n ] ; memset ( lower , 0 , sizeof ( lower ) ) ; memset ( upper , 0 , sizeof ( upper ) ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = i ; k < n ; k ++ ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; } for ( int k = i ; k < n ; k ++ ) { if ( i == k ) else { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ; } } } cout << setw ( 6 ) << " TABSYMBOL Lower ▁ Triangular " << setw ( 32 ) << " Upper ▁ Triangular " << endl ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << setw ( 6 ) << lower [ i ] [ j ] << " TABSYMBOL " ; cout << " TABSYMBOL " ; for ( int j = 0 ; j < n ; j ++ ) cout << setw ( 6 ) << upper [ i ] [ j ] << " TABSYMBOL " ; cout << endl ; } } int main ( ) { int mat [ ] [ MAX ] = { { 2 , -1 , -2 } , { -4 , 6 , 3 } , { -4 , -2 , 8 } } ; luDecomposition ( mat , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwoDivisibleParts ( string num , int f , int s ) { int N = num . length ( ) ; int prefixReminder [ N + 1 ] ; int suffixReminder [ N + 1 ] ; suffixReminder [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( num [ i - 1 ] - '0' ) ) % f ; prefixReminder [ N ] = 0 ; int base = 1 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( num [ i ] - '0' ) * base ) % s ; base = ( base * 10 ) % s ; } for ( int i = 0 ; i < N ; i ++ ) { if ( prefixReminder [ i ] == 0 && suffixReminder [ i ] == 0 && num [ i ] != '0' ) { cout << num . substr ( 0 , i ) << " ▁ " << num . substr ( i ) << endl ; return ; } } cout << " Not ▁ Possible STRNEWLINE " ; } int main ( ) { string num = "246904096" ; int f = 12345 ; int s = 1024 ; printTwoDivisibleParts ( num , f , s ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX_DIGITS = 20 ; bool isOctal ( long n ) { while ( n ) { if ( ( n % 10 ) >= 8 ) return false ; else n = n / 10 ; } return true ; } int isPalindrome ( long n ) { int divide = ( isOctal ( n ) == false ) ? 8 : 10 ; int octal [ MAX_DIGITS ] ; int i = 0 ; while ( n != 0 ) { octal [ i ++ ] = n % divide ; n = n / divide ; } for ( int j = i - 1 , k = 0 ; k <= j ; j -- , k ++ ) if ( octal [ j ] != octal [ k ] ) return false ; return true ; } int main ( ) { long n = 97 ; if ( isPalindrome ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { cout << fact << " ▁ " ; fact = fact * x ; x ++ ; } } int main ( ) { int n = 100 ; printFactorialNums ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumDigitSquare ( int n ) { int sq = 0 ; while ( n ) { int digit = n % 10 ; sq += digit * digit ; n = n / 10 ; } return sq ; } bool isHappy ( int n ) { set < int > s ; s . insert ( n ) ; while ( 1 ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( s . find ( n ) != s . end ( ) ) return false ; s . insert ( n ) ; } return false ; } int main ( ) { int n = 23 ; if ( isHappy ( n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } bool isThreeDisctFactors ( long long n ) { int sq = ( int ) sqrt ( n ) ; if ( 1LL * sq * sq != n ) return false ; return isPrime ( sq ) ? true : false ; } int main ( ) { long long num = 9 ; if ( isThreeDisctFactors ( num ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; num = 15 ; if ( isThreeDisctFactors ( num ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; num = 12397923568441 ; if ( isThreeDisctFactors ( num ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int computeLastDigit ( long long int A , long long int B ) { int variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long long int i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) ; return variable % 10 ; } } int main ( ) { cout << computeLastDigit ( 2632 , 2634 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; } int main ( ) { int n = 20 ; float a = 2.5 , d = 1.5 ; cout << sumOfAP ( a , d , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define M  1000000007 NEW_LINE using namespace std ; long long multiplyFactors ( int n ) { long long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; } int main ( ) { int n = 12 ; cout << multiplyFactors ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define M  1000000007 NEW_LINE using namespace std ; long long power ( long long x , long long y ) { long long res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % M ; y = ( y >> 1 ) % M ; x = ( x * x ) % M ; } return res ; } int countFactors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count ++ ; else count += 2 ; } } return count ; } long long multiplyFactors ( int n ) { int numFactor = countFactors ( n ) ; long long product = power ( n , numFactor / 2 ) ; if ( numFactor & 1 ) product = ( product * ( int ) sqrt ( n ) ) % M ; return product ; } int main ( ) { int n = 12 ; cout << multiplyFactors ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisibleBy10 ( string bin ) { int n = bin . size ( ) ; if ( bin [ n - 1 ] == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; } int main ( ) { string bin = "11000111001110" ; if ( isDivisibleBy10 ( bin ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; cout << first << " ▁ " ; if ( n > 1 ) cout << second << " ▁ " ; if ( n > 2 ) cout << second << " ▁ " ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; cout << curr << " ▁ " ; } } int main ( ) { int n = 10 ; printTrib ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int counDivisors ( int X ) { int count = 0 ; for ( int i = 1 ; i <= X ; ++ i ) { if ( X % i == 0 ) { count ++ ; } } return count ; } int countDivisorsMult ( int arr [ ] , int n ) { int mul = 1 ; for ( int i = 0 ; i < n ; ++ i ) mul *= arr [ i ] ; return counDivisors ( mul ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDivisorsMult ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int largest , vector < int > & prime ) { bool isPrime [ largest + 1 ] ; memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p <= largest ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= largest ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= largest ; p ++ ) if ( isPrime [ p ] ) prime . push_back ( p ) ; } int countDivisorsMult ( int arr [ ] , int n ) { int largest = * max_element ( arr , arr + n ) ; vector < int > prime ; SieveOfEratosthenes ( largest , prime ) ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < prime . size ( ) ; j ++ ) { while ( arr [ i ] > 1 && arr [ i ] % prime [ j ] == 0 ) { arr [ i ] /= prime [ j ] ; mp [ prime [ j ] ] ++ ; } } if ( arr [ i ] != 1 ) mp [ arr [ i ] ] ++ ; } long long int res = 1 ; for ( auto it : mp ) res *= ( it . second + 1L ) ; return res ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDivisorsMult ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void additiveCongruentialMethod ( int Xo , int m , int c , vector < int > & randomNums , int noOfRandomNums ) { randomNums [ 0 ] = Xo ; for ( int i = 1 ; i < noOfRandomNums ; i ++ ) { randomNums [ i ] = ( randomNums [ i - 1 ] + c ) % m ; } } int main ( ) { int Xo = 3 ; int m = 15 ; int c = 2 ; int noOfRandomNums = 20 ; vector < int > randomNums ( noOfRandomNums ) ; additiveCongruentialMethod ( Xo , m , c , randomNums , noOfRandomNums ) ; for ( int i = 0 ; i < noOfRandomNums ; i ++ ) { cout << randomNums [ i ] << " ▁ " ; } return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void findNthTerm ( int n ) { cout << n * ( 4 * n + 3 ) << endl ; } int main ( ) { int N = 4 ; findNthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int EnneacontahexagonNum ( int n ) { return ( 94 * n * n - 92 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << EnneacontahexagonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int HexacontatetragonNum ( int n ) { return ( 62 * n * n - 60 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << HexacontatetragonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int icosikaipentagonNum ( int N ) { return ( 23 * N * N - 21 * N ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ icosikaipentagon ▁ Number ▁ is ▁ " << icosikaipentagonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int chiliagonNum ( int n ) { return ( 998 * n * n - 996 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ chiliagon ▁ Number ▁ is ▁ = ▁ " << chiliagonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pentacontagonNum ( int n ) { return ( 48 * n * n - 46 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ pentacontagon ▁ Number ▁ is ▁ = ▁ " << pentacontagonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigit ( long long n ) { return floor ( log10 ( n ) + 1 ) ; } int main ( ) { double N = 80 ; cout << countDigit ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; cout << total << " ▁ " ; for ( i = 1 ; i < n ; i ++ ) { total = total + multi ; cout << multi << " ▁ " ; multi = multi * x ; } cout << " STRNEWLINE " ; return total ; } int main ( ) { int x = 2 ; int n = 5 ; cout << fixed << setprecision ( 2 ) << sum ( x , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findRemainder ( int n ) { int x = n & 3 ; return x ; } int main ( ) { int N = 43 ; int ans = findRemainder ( N ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isAutoBio ( int num ) { string autoStr ; int index , number , i , j , cnt ; autoStr = to_string ( num ) ; for ( int i = 0 ; i < autoStr . size ( ) ; i ++ ) { index = autoStr . at ( i ) - '0' ; cnt = 0 ; for ( j = 0 ; j < autoStr . size ( ) ; j ++ ) { number = autoStr . at ( j ) - '0' ; if ( number == i ) cnt ++ ; } if ( index != cnt ) return false ; } return true ; } void findAutoBios ( int n ) { int high , low , i , flag = 0 ; low = pow ( 10 , n - 1 ) ; high = pow ( 10 , n ) - 1 ; for ( i = low ; i <= high ; i ++ ) { if ( isAutoBio ( i ) ) { flag = 1 ; cout << i << " , ▁ " ; } } if ( ! flag ) cout << " There ▁ is ▁ no ▁ " << " Autobiographical ▁ number " << " ▁ with ▁ " << n << " ▁ digits STRNEWLINE " ; } int main ( ) { int N = 0 ; findAutoBios ( N ) ; N = 4 ; findAutoBios ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkPalindrome ( int num ) { string str = to_string ( num ) ; int l = 0 , r = str . length ( ) - 1 ; while ( l < r ) { if ( str [ l ] != str [ r ] ) { cout << " No " ; return ; } l ++ ; r -- ; } cout << " Yes " ; return ; } int main ( ) { int n = 19 , k = 3 ; checkPalindrome ( n + k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > sieve ( int n ) { vector < int > prime ( n + 1 , 0 ) ; int p = 2 ; while ( p * p <= n ) { if ( prime [ p ] == 0 ) { for ( int i = 2 * p ; i < n + 1 ; i += p ) prime [ i ] = 1 ; } p += 1 ; } vector < int > allPrimes ; for ( int i = 2 ; i < n ; i ++ ) if ( prime [ i ] == 0 ) allPrimes . push_back ( i ) ; return allPrimes ; } vector < int > distPrime ( vector < int > arr , vector < int > allPrimes ) { vector < int > list1 ; for ( int i : allPrimes ) { for ( int j : arr ) { if ( j % i == 0 ) { list1 . push_back ( i ) ; break ; } } } return list1 ; } int main ( ) { vector < int > allPrimes = sieve ( 10000 ) ; vector < int > arr = { 15 , 30 , 60 } ; vector < int > ans = distPrime ( arr , allPrimes ) ; cout << " [ " ; for ( int i : ans ) cout << i << " ▁ " ; cout << " ] " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_composite_nos ( int n ) { cout << 9 * n << " ▁ " << 8 * n ; } int main ( ) { int n = 4 ; find_composite_nos ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int m , int n ) { return 8 * m * n - 6 * m - 6 * n + 4 ; } int main ( ) { int m = 3 , n = 2 ; cout << sum ( m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double volumeRec ( double a , double b , double e , double h ) { return ( ( ( b * h ) / 6 ) * ( 2 * a + e ) ) ; } int main ( ) { double a = 2 ; double b = 5 ; double e = 5 ; double h = 6 ; printf ( " Volume ▁ = ▁ % .1f " , volumeRec ( a , b , e , h ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; } int main ( ) { int N = 8 ; cout << count_square ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; static int countAnomalies ( int arr [ ] , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 1 ; cout << countAnomalies ( arr , n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE int d [ N ] , pre [ N ] ; void Positive_Divisors ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } } int main ( ) { Positive_Divisors ( ) ; int n = 15 ; cout << pre [ n ] << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return -1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = number * 10 + 1 ; if ( ( number % K == 0 ) ) return len ; } return -1 ; } int main ( ) { int K = 7 ; cout << numLen ( K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int freqPairs ( int arr [ ] , int n ) { int max = * ( std :: max_element ( arr , arr + n ) ) ; int freq [ max + 1 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 * arr [ i ] ; j <= max ; j += arr [ i ] ) { if ( freq [ j ] >= 1 ) count += freq [ j ] ; } if ( freq [ arr [ i ] ] > 1 ) { count += freq [ arr [ i ] ] - 1 ; freq [ arr [ i ] ] -- ; } } return count ; } int main ( ) { int arr [ ] = { 3 , 2 , 4 , 2 , 6 } ; int n = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; cout << freqPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) cout << y << " ▁ " << x << " ▁ " ; else cout << x << " ▁ " << y << " ▁ " ; } } int main ( ) { int n = 2 , k = 1 ; printPermutation ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll maxSum ( int N ) { ll ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; } int main ( ) { int N = 6 ; cout << maxSum ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } int largestPalindrome ( int A [ ] , int n ) { sort ( A , A + n ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( isPalindrome ( A [ i ] ) ) return A [ i ] ; } return -1 ; } int main ( ) { int A [ ] = { 1 , 232 , 54545 , 999991 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << largestPalindrome ( A , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; } int main ( ) { int n = 5 ; cout << findSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double findMean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; } int main ( ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " Mean ▁ = ▁ " << findMean ( a , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool CheckArray ( int arr [ ] , int n ) { int prod = 1 ; unordered_set < int > freq ; for ( int i = 0 ; i < n ; ++ i ) { freq . insert ( arr [ i ] ) ; prod *= arr [ i ] ; } int root = sqrt ( prod ) ; if ( root * root == prod ) if ( freq . find ( root ) != freq . end ( ) ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 12 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( CheckArray ( arr , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAreaRect ( vector < vector < int > > A ) { map < int , vector < int > > columns ; for ( auto i : A ) columns [ i [ 0 ] ] . push_back ( i [ 1 ] ) ; map < pair < int , int > , int > lastx ; int ans = INT_MAX ; for ( auto x : columns ) { vector < int > column = x . second ; sort ( column . begin ( ) , column . end ( ) ) ; for ( int j = 0 ; j < column . size ( ) ; j ++ ) { for ( int i = 0 ; i < j ; i ++ ) { int y1 = column [ i ] ; if ( lastx . find ( { y1 , column [ j ] } ) != lastx . end ( ) ) { ans = min ( ans , ( x . first - lastx [ { y1 , column [ j ] } ] ) * ( column [ j ] - column [ i ] ) ) ; } lastx [ { y1 , column [ j ] } ] = x . first ; } } } if ( ans < INT_MAX ) return ans ; else return 0 ; } int main ( ) { vector < vector < int > > A = { { 1 , 1 } , { 1 , 3 } , { 3 , 1 } , { 3 , 3 } , { 2 , 2 } } ; cout << ( minAreaRect ( A ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int toK ( int N , int K ) { int w = 1 ; int s = 0 ; while ( N != 0 ) { int r = N % K ; N = N / K ; s = r * w + s ; w *= 10 ; } return s ; } bool check ( int N ) { bool fl = false ; while ( N != 0 ) { int r = N % 10 ; N = N / 10 ; if ( fl == true and r == 0 ) return false ; if ( r > 0 ) { fl = false ; continue ; } fl = true ; } return true ; } void hasConsecutiveZeroes ( int N , int K ) { int z = toK ( N , K ) ; if ( check ( z ) ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { int N = 15 ; int K = 8 ; hasConsecutiveZeroes ( N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE bool prime [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } void SumOfKthPrimes ( int arr [ ] , int n , int k ) { int c = 0 ; long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { sum += arr [ i ] ; c = 0 ; } } } cout << sum << endl ; } int main ( ) { SieveOfEratosthenes ( ) ; int arr [ ] = { 2 , 3 , 5 , 7 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; SumOfKthPrimes ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100000 NEW_LINE using namespace std ; bool prime [ 100002 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == true ) for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } int superpower ( int n ) { SieveOfEratosthenes ( ) ; int superPower = 0 , factor = 0 ; int i = 2 ; while ( n > 1 && i <= MAX ) { if ( prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; } int main ( ) { int n = 256 ; cout << superpower ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next ; } ; void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int countPrime ( Node * * head_ref ) { int count = 0 ; Node * ptr = * head_ref ; while ( ptr != NULL ) { if ( isPrime ( ptr -> data ) ) { count ++ ; } ptr = ptr -> next ; } return count ; } int main ( ) { Node * head = NULL ; push ( & head , 17 ) ; push ( & head , 10 ) ; push ( & head , 6 ) ; push ( & head , 5 ) ; push ( & head , 15 ) ; cout << " Count ▁ of ▁ prime ▁ nodes ▁ = ▁ " << countPrime ( & head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; } int main ( ) { int n = 31 ; cout << smallestDivisor ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) -2 * ( Heads ) ; count = count / 2 ; return count ; } int main ( ) { int Heads = 100 , Legs = 300 ; int Rabbits = countRabbits ( Heads , Legs ) ; cout << " Rabbits ▁ = ▁ " << Rabbits << endl ; cout << " Pigeons ▁ = ▁ " << Heads - Rabbits << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float calculateSum ( float n ) { int a = int ( n ) ; return 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ; } int main ( ) { float n = 1.4142 ; cout << ceil ( calculateSum ( n ) ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int Nth_Term ( int n ) { return ( 2 * pow ( n , 3 ) - 3 * pow ( n , 2 ) + n + 6 ) / 6 ; } int main ( ) { int N = 8 ; cout << Nth_Term ( N ) ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; class gfg { public : int Sum_upto_nth_Term ( int n ) { return ( 1 - pow ( -2 , n ) ) ; } } ; int main ( ) { gfg g ; int N = 5 ; cout << g . Sum_upto_nth_Term ( N ) ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; class gfg { public : int xorEqualsOrCount ( int N ) { int count = 0 ; int bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = N / 2 ; } return ( int ) pow ( 2 , count ) ; } } ; int main ( ) { gfg g ; int N = 7 ; cout << g . xorEqualsOrCount ( N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int fact ( int n ) { if ( n == 1 ) return 1 ; return n * fact ( n - 1 ) ; } double sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) { total = total + ( pow ( x , i ) / fact ( i + 1 ) ) ; } return total ; } int main ( ) { int x = 5 , n = 4 ; cout << " Sum ▁ is : ▁ " << sum ( x , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - pow ( i , 2 ) ; else result = result + pow ( i , 2 ) ; } return result ; } int main ( void ) { int n = 3 ; cout << sum_of_series ( n ) << endl ; n = 10 ; cout << sum_of_series ( n ) << endl ; }
#include <iostream> NEW_LINE using namespace std ; int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; } int main ( ) { int N = 4 ; cout << findSum ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE #define MAX  16 NEW_LINE using namespace std ; ll nCr [ MAX ] [ MAX ] = { 0 } ; void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } } double findCosNTheta ( double sinTheta , ll n ) { double cosTheta = sqrt ( 1 - sinTheta * sinTheta ) ; double ans = 0 ; ll toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * pow ( cosTheta , n - i ) * pow ( sinTheta , i ) * toggle ; toggle = toggle * -1 ; } return ans ; } int main ( ) { binomial ( ) ; double sinTheta = 0.5 ; ll n = 10 ; cout << findCosNTheta ( sinTheta , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 3 ; arr [ 2 ] = 5 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 3 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 5 ; } return arr [ n ] ; } int main ( ) { int n = 6 ; cout << printNthElement ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  16 NEW_LINE using namespace std ; int nCr [ MAX ] [ MAX ] = { 0 } ; void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } } double findCosnTheta ( double cosTheta , int n ) { double sinTheta = sqrt ( 1 - cosTheta * cosTheta ) ; double ans = 0 ; int toggle = 1 ; for ( int i = 0 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * pow ( cosTheta , n - i ) * pow ( sinTheta , i ) * toggle ; toggle = toggle * -1 ; } return ans ; } int main ( ) { binomial ( ) ; double cosTheta = 0.5 ; int n = 10 ; cout << findCosnTheta ( cosTheta , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } int main ( ) { int N = 5 ; cout << " Nth ▁ term ▁ for ▁ N ▁ = ▁ " << N << " ▁ : ▁ " << nthTerm ( N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int findSum ( int n ) { return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / pow ( 9 , 3 ) - n * ( n + 1 ) / 18 ; } int main ( ) { int n = 3 ; cout << findSum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int solve_sum ( int n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; } int main ( ) { int n = 8 ; cout << solve_sum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = log ( a ) / log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; } int main ( ) { int n = 16 ; cout << ( isPower ( n ) ? " Yes " : " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float rmsValue ( int arr [ ] , int n ) { int square = 0 ; float mean = 0.0 , root = 0.0 ; for ( int i = 0 ; i < n ; i ++ ) { square += pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = sqrt ( mean ) ; return root ; } int main ( ) { int arr [ ] = { 10 , 4 , 6 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << rmsValue ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Mixture ( int X , int Y , int Z ) { float result = 0.0 , result1 = 0.0 ; result1 = ( ( X - Y ) / ( float ) X ) ; result = pow ( result1 , Z ) ; result = result * X ; return result ; } int main ( ) { int X = 10 , Y = 2 , Z = 2 ; cout << Mixture ( X , Y , Z ) << " ▁ litres " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  (int)(1e9 + 7) NEW_LINE int power ( int x , int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int check ( int n ) { n -- ; int ans = n * n ; if ( ans >= mod ) ans %= mod ; ans += n + 2 ; if ( ans >= mod ) ans %= mod ; ans = ( power ( 2 , n , mod ) % mod * ans % mod ) % mod ; ans = ( ans - 1 + mod ) % mod ; return ans ; } int main ( ) { int n = 4 ; cout << check ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLCM ( int a , int b ) { int lar = max ( a , b ) ; int small = min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } } int main ( ) { int a = 5 , b = 7 ; cout << " LCM ▁ of ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << findLCM ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void primes ( int n ) { int i = 2 ; int j = 0 ; int result [ n ] ; int z = 0 ; while ( j < n ) { bool flag = true ; for ( int item = 2 ; item <= ( int ) ( i * 1 / 2 ) ; item ++ ) if ( i % item == 0 && i != item ) { flag = false ; break ; } if ( flag ) { result [ z ++ ] = i ; j += 1 ; } i += 1 ; } for ( i = 0 ; i < 5 ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) cout << result [ j ] ; cout << " ▁ " ; } } void smar_wln ( int n ) { primes ( n ) ; } int main ( ) { int n = 5 ; cout << " First ▁ " << n << " ▁ terms ▁ of ▁ the ▁ Sequence ▁ are " << endl ; smar_wln ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Pentatope_number ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; } int main ( ) { int n = 7 ; cout << n << " th ▁ Pentatope ▁ number ▁ : " << Pentatope_number ( n ) << endl ; n = 12 ; cout << n << " th ▁ Pentatope ▁ number ▁ : " << Pentatope_number ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int centered_square_num ( int n ) { return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; } int main ( ) { int n = 7 ; cout << n << " th ▁ Centered ▁ square ▁ number : ▁ " ; cout << centered_square_num ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } int main ( ) { int n = 4 ; cout << seriesSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n , bool prime [ ] , bool primesquare [ ] , int a [ ] ) { for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= ( n * n + 1 ) ; i ++ ) primesquare [ i ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } int j = 0 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { a [ j ] = p ; primesquare [ p * p ] = true ; j ++ ; } } } int countDivisors ( int n ) { if ( n == 1 ) return 1 ; bool prime [ n + 1 ] , primesquare [ n * n + 1 ] ; SieveOfEratosthenes ( n , prime , primesquare , a ) ; int ans = 1 ; for ( int i = 0 ; ; i ++ ) { if ( a [ i ] * a [ i ] * a [ i ] > n ) break ; int cnt = 1 ; while ( n % a [ i ] == 0 ) { n = n / a [ i ] ; } ans = ans * cnt ; } if ( prime [ n ] ) ans = ans * 2 ; else if ( primesquare [ n ] ) ans = ans * 3 ; else if ( n != 1 ) ans = ans * 4 ; } int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } bool checkArithmetic ( int n ) { int count = countDivisors ( n ) ; int sum = sumofFactors ( n ) ; return ( sum % count == 0 ) ; } int main ( ) { int n = 6 ; ( checkArithmetic ( n ) ) ? ( cout << " Yes " ) : ( cout << " No " ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; } int main ( ) { int N = 6 ; cout << magicOfSequence ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nextPower ( int N , vector < int > & power ) { int carry = 0 ; for ( int i = 0 ; i < power . size ( ) ; i ++ ) { int prod = ( power [ i ] * N ) + carry ; power [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry ) { power . push_back ( carry % 10 ) ; carry = carry / 10 ; } } void printPowerNumber ( int X , int N ) { vector < int > power ; power . push_back ( 1 ) ; vector < int > res ; for ( int i = 1 ; i <= X ; i ++ ) { nextPower ( N , power ) ; res . push_back ( power . back ( ) ) ; res . push_back ( power . front ( ) ) ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] ; } int main ( ) { int N = 19 , X = 4 ; printPowerNumber ( X , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstDigit ( int n ) { long long int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; } int main ( ) { int n = 5 ; cout << firstDigit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void series ( int A , int X , int n ) { int term = pow ( A , n ) ; cout << term << " ▁ " ; for ( int i = 1 ; i <= n ; i ++ ) { term = term * X * ( n - i + 1 ) / ( i * A ) ; cout << term << " ▁ " ; } } int main ( ) { int A = 3 , X = 4 , n = 5 ; series ( A , X , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; } int main ( ) { cout << sumofseries ( 3 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printGMeans ( int A , int B , int N ) { float R = ( float ) pow ( float ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) cout << A * pow ( R , i ) << " ▁ " ; } int main ( ) { int A = 3 , B = 81 , N = 2 ; printGMeans ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int division ( int num1 , int num2 ) { if ( num1 == 0 ) return 0 ; if ( num2 == 0 ) return INT_MAX ; bool negResult = false ; if ( num1 < 0 ) { num1 = - num1 ; if ( num2 < 0 ) num2 = - num2 ; else negResult = true ; } else if ( num2 < 0 ) { num2 = - num2 ; negResult = true ; } int quotient = 0 ; while ( num1 >= num2 ) { num1 = num1 - num2 ; quotient ++ ; } if ( negResult ) quotient = - quotient ; return quotient ; } int main ( ) { int num1 = 13 , num2 = 2 ; cout << division ( num1 , num2 ) ; ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { cout << i * ( 7 * i - 5 ) / 2 ; cout << " ▁ " ; } } int main ( ) { int n = 10 ; Nonagonal ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; } int main ( ) { int n = 8 ; cout << seriesFunc ( n ) << endl ; n = 13 ; cout << seriesFunc ( 13 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; } int main ( ) { int x = 9474 ; if ( checkplusperfect ( x ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Div_by_8 ( int n ) { return ( ( ( n >> 3 ) << 3 ) == n ) ; } int main ( ) { int n = 16 ; if ( Div_by_8 ( n ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int subsetCount ( int arr [ ] , int n ) { return 1 << n ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << subsetCount ( A , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; } int main ( ) { float org_cost = 100 ; float N_price = 120 ; cout << " GST ▁ = ▁ " << Calculate_GST ( org_cost , N_price ) << " ▁ % ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; } int main ( ) { int n = 10 ; cout << n << " th ▁ centered ▁ hexagonal ▁ number : ▁ " ; cout << centeredHexagonalNumber ( n ) ; return 0 ; }
#include <stdio.h> NEW_LINE int averageEven ( int n ) { if ( n % 2 != 0 ) { printf ( " Invalid ▁ Input " ) ; return -1 ; } int sum = 0 , count = 0 ; while ( n >= 2 ) { count ++ ; sum += n ; n = n - 2 ; } return sum / count ; } int main ( ) { int n = 16 ; printf ( " % d " , averageEven ( n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_distance ( int n ) { return n * ( ( 3 * n ) + 7 ) ; } int main ( ) { int n = 5 ; cout << " Distance ▁ = ▁ " << find_distance ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } bool twinPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && abs ( n1 - n2 ) == 2 ) ; } int main ( ) { int n1 = 11 , n2 = 13 ; if ( twinPrime ( n1 , n2 ) ) cout << " Twin ▁ Prime " << endl ; else cout << endl << " Not ▁ Twin ▁ Prime " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; } int main ( ) { int n = 4 ; printf ( " % d " , evenbinomialCoeffSum ( n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } int main ( ) { int n = 5 ; cout << " Sum ▁ = ▁ " << sumOfTheSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; } int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; } int main ( ) { int x = 15 ; int y = 3 ; cout << cpFact ( x , y ) << endl ; x = 14 ; y = 28 ; cout << cpFact ( x , y ) << endl ; x = 7 ; y = 3 ; cout << cpFact ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int squaresum ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } int main ( ) { int n = 4 ; cout << squaresum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int counLastDigitK ( int low , int high , int k ) { int count = 0 ; for ( int i = low ; i <= high ; i ++ ) if ( i % 10 == k ) count ++ ; return count ; } int main ( ) { int low = 3 , high = 35 , k = 3 ; cout << counLastDigitK ( low , high , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfTriangles ( int n ) { int ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; } int main ( ) { int n = 2 ; cout << numberOfTriangles ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int motzkin ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = ( ( 2 * i + 1 ) * dp [ i - 1 ] + ( 3 * i - 3 ) * dp [ i - 2 ] ) / ( i + 2 ) ; return dp [ n ] ; } int main ( ) { int n = 8 ; cout << motzkin ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int kthgroupsum ( int k ) { return k * k * k ; } int main ( ) { int k = 3 ; cout << kthgroupsum ( k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printXYZ ( int n ) { if ( n == 1 ) cout << -1 ; else cout << " x ▁ is ▁ " << n << " STRNEWLINE y ▁ is ▁ " << n + 1 << " STRNEWLINE z ▁ is ▁ " << n * ( n + 1 ) ; } int main ( ) { int n = 7 ; printXYZ ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int term ( int n ) { return n * ( n + 1 ) / 2 ; } int main ( ) { int n = 4 ; cout << term ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int series ( int n ) { return ( 8 * n * n ) + 1 ; } int main ( ) { int n = 5 ; cout << series ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisible ( int x , int y ) { if ( y == 1 ) return true ; if ( __gcd ( x , y ) == 1 ) return false ; return isDivisible ( x , y / gcd ) ; } int main ( ) { int x = 18 , y = 12 ; if ( isDivisible ( x , y ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double sumOfSeries ( double a , double num ) { double res = 0 , prev = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( res ) ; } int main ( ) { double n = 5 , a = 2 ; cout << sumOfSeries ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Cel_To_Fah ( float n ) { return ( ( n * 9.0 / 5.0 ) + 32.0 ) ; } int main ( ) { float n = 20.0 ; cout << Cel_To_Fah ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define ull  unsigned long long NEW_LINE ull countCompositions ( ull n ) { return ( 1L ) << ( n - 1 ) ; } int main ( ) { ull n = 4 ; cout << countCompositions ( n ) << " STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int printTrib ( int n ) { int dp [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; } int main ( ) { int n = 10 ; printTrib ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void multiply ( int T [ 3 ] [ 3 ] , int M [ 3 ] [ 3 ] ) { int a , b , c , d , e , f , g , h , i ; a = T [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 0 ] ; b = T [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 1 ] ; c = T [ 0 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 2 ] ; d = T [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 0 ] ; e = T [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 1 ] ; f = T [ 1 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 2 ] ; g = T [ 2 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 0 ] ; h = T [ 2 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 1 ] ; i = T [ 2 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 2 ] ; T [ 0 ] [ 0 ] = a ; T [ 0 ] [ 1 ] = b ; T [ 0 ] [ 2 ] = c ; T [ 1 ] [ 0 ] = d ; T [ 1 ] [ 1 ] = e ; T [ 1 ] [ 2 ] = f ; T [ 2 ] [ 0 ] = g ; T [ 2 ] [ 1 ] = h ; T [ 2 ] [ 2 ] = i ; } void power ( int T [ 3 ] [ 3 ] , int n ) { if ( n == 0 n == 1 ) return ; int M [ 3 ] [ 3 ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; power ( T , n / 2 ) ; multiply ( T , T ) ; if ( n % 2 ) multiply ( T , M ) ; } int tribonacci ( int n ) { int T [ 3 ] [ 3 ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 0 n == 1 ) return 0 ; else power ( T , n - 2 ) ; return T [ 0 ] [ 0 ] ; } int main ( ) { int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) cout << tribonacci ( i ) << " ▁ " ; cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float geometricMean ( int arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + log ( arr [ i ] ) ; sum = sum / n ; return exp ( sum ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << geometricMean ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int smallestNumber ( int n ) { if ( n >= 0 && n <= 9 ) return n ; stack < int > digits ; for ( int i = 9 ; i >= 2 && n > 1 ; i -- ) { while ( n % i == 0 ) { digits . push ( i ) ; n = n / i ; } } if ( n != 1 ) return -1 ; long long int k = 0 ; while ( ! digits . empty ( ) ) { k = k * 10 + digits . top ( ) ; digits . pop ( ) ; } return k ; } int main ( ) { int n = 100 ; cout << smallestNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTaxicab2 ( int N ) { int i = 1 , count = 0 ; while ( count < N ) { int int_count = 0 ; for ( int j = 1 ; j <= pow ( i , 1.0 / 3 ) ; j ++ ) for ( int k = j + 1 ; k <= pow ( i , 1.0 / 3 ) ; k ++ ) if ( j * j * j + k * k * k == i ) int_count ++ ; if ( int_count == 2 ) { count ++ ; cout << count << " ▁ " << i << endl ; } i ++ ; } } int main ( ) { int N = 5 ; printTaxicab2 ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; } int main ( ) { int n = 1234 ; if ( isMagic ( n ) ) cout << " Magic ▁ Number " ; else cout << " Not ▁ a ▁ magic ▁ Number " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int main ( ) { int x = 1234 ; if ( x % 9 == 1 ) cout << ( " Magic ▁ Number " ) ; else cout << ( " Not ▁ a ▁ Magic ▁ Number " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000000007 NEW_LINE void printSequence ( int n ) { int a = 1 ; int ans = 2 ; for ( int i = 1 ; i <= n ; i ++ ) { cout << ans << " ▁ " ; ans = ( ( a % N ) * ( ans % N ) ) % N ; a = ans ; ans = ( ans + 1 ) % N ; } } int main ( ) { int n = 6 ; printSequence ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } int main ( ) { isComposite ( 11 ) ? cout << " ▁ true STRNEWLINE " : cout << " ▁ false STRNEWLINE " ; isComposite ( 15 ) ? cout << " ▁ true STRNEWLINE " : cout << " ▁ false STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; } int main ( ) { int n = 5 ; cout << findSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int HailstoneNumbers ( int N ) { static int c ; cout << N << " ▁ " ; if ( N == 1 && c == 0 ) { return c ; } else if ( N == 1 && c != 0 ) { c ++ ; return c ; } else if ( N % 2 == 0 ) { c ++ ; HailstoneNumbers ( N / 2 ) ; } else if ( N % 2 != 0 ) { c ++ ; HailstoneNumbers ( 3 * N + 1 ) ; } } int main ( ) { int N = 7 ; int x ; x = HailstoneNumbers ( N ) ; cout << endl ; cout << " Number ▁ of ▁ Steps : ▁ " << x ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int SUM ( int n , int m ) { if ( m == 1 ) return ( n * ( n + 1 ) / 2 ) ; int sum = SUM ( n , m - 1 ) ; return ( sum * ( sum + 1 ) / 2 ) ; } int main ( ) { int n = 5 ; int m = 3 ; cout << " SUM ( " << n << " , ▁ " << m << " ) : ▁ " << SUM ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int x , int y ) { unordered_map < int , int > m ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . find ( x ) != m . end ( ) ) return -1 ; m [ x ] = 1 ; x = x * 10 ; } return ans ; } int main ( ) { int res = count ( 1 , 2 ) ; ( res == -1 ) ? cout << " INF " : cout << res ; cout << endl ; res = count ( 5 , 3 ) ; ( res == -1 ) ? cout << " INF " : cout << res ; cout << endl ; res = count ( 3 , 5 ) ; ( res == -1 ) ? cout << " INF " : cout << res ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return -1 ; } int main ( ) { int k = 31 ; cout << xorCalc ( k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findNthNo ( int n ) { string res = " " ; while ( n >= 1 ) { if ( n & 1 ) { res = res + "4" ; n = ( n - 1 ) / 2 ; } else { res = res + "7" ; n = ( n - 2 ) / 2 ; } } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; } int main ( ) { int n = 13 ; cout << findNthNo ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divCount ( int n ) { bool hash [ n + 1 ] ; memset ( hash , true , sizeof ( hash ) ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; } int main ( ) { int n = 24 ; cout << divCount ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrimefactorNum ( int N ) { int arr [ N + 1 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( ! arr [ i ] ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } return * max_element ( arr , arr + N ) ; } int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; } int main ( ) { int arr [ ] = { 10 , 11 , 12 , 13 , 12 , 11 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << arraySum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isBalancePossible ( int T , int a ) { vector < int > baseForm ; while ( T ) { baseForm . push_back ( T % a ) ; T /= a ; } baseForm . push_back ( 0 ) ; for ( int i = 0 ; i < baseForm . size ( ) ; i ++ ) { if ( baseForm [ i ] != 0 && baseForm [ i ] != 1 && baseForm [ i ] != ( a - 1 ) && baseForm [ i ] != a ) return false ; if ( baseForm [ i ] == a || baseForm [ i ] == ( a - 1 ) ) baseForm [ i + 1 ] += 1 ; } return true ; } int main ( ) { int T = 11 ; int a = 4 ; bool balancePossible = isBalancePossible ( T , a ) ; if ( balancePossible ) cout << " Balance ▁ is ▁ possible " << endl ; else cout << " Balance ▁ is ▁ not ▁ possible " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigits ( int a , int b ) { if ( a == 0 b == 0 ) return 1 ; return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1 ; } int main ( ) { int a = 33 ; int b = -24 ; cout << countDigits ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; } int main ( ) { int n = 5 ; int m = 8 ; int k = 2 ; cout << lastPosition ( n , m , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void primesInRange ( int n ) { int fact = 1 ; for ( int k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) cout << k << endl ; } } int main ( ) { int n = 15 ; primesInRange ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int changeEvenBits ( int n ) { int to_subtract = 0 ; int m = 0 ; for ( int x = n ; x ; x >>= 2 ) { if ( x & 1 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; } int main ( ) { int n = 30 ; cout << changeEvenBits ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( abs ( n - n1 ) < abs ( n - n2 ) ) return n1 ; return n2 ; } int main ( ) { int n = 13 , m = 4 ; cout << closestNumber ( n , m ) << endl ; n = -15 ; m = 6 ; cout << closestNumber ( n , m ) << endl ; n = 0 ; m = 8 ; cout << closestNumber ( n , m ) << endl ; n = 18 ; m = -7 ; cout << closestNumber ( n , m ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; } int main ( void ) { for ( int i = 0 ; i <= 200 ; i ++ ) if ( checkPronic ( i ) ) cout << i << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; } int main ( ) { int num = 12 ; cout << findMinSum ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMin ( int sum ) { int a = 0 , b = 0 ; while ( sum > 0 ) { if ( sum % 7 == 0 ) { b ++ ; sum -= 7 ; } else if ( sum % 4 == 0 ) { a ++ ; sum -= 4 ; } else { a ++ ; sum -= 4 ; } } if ( sum < 0 ) { printf ( " - 1n " ) ; return ; } for ( int i = 0 ; i < a ; i ++ ) printf ( "4" ) ; for ( int i = 0 ; i < b ; i ++ ) printf ( "7" ) ; printf ( " n " ) ; } int main ( ) { findMin ( 15 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minNum ( int arr [ ] , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd += 1 ; return ( odd % 2 ) ? 1 : 2 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minNum ( arr , n ) << " n " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } int findPrime ( int n ) { int num = n + 1 ; while ( num ) { if ( isPrime ( num ) ) return num ; num = num + 1 ; } return 0 ; } int minNumber ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( isPrime ( sum ) ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minNumber ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printMaxNum ( int num ) { int count [ 10 ] = { 0 } ; string str = to_string ( num ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str [ i ] - '0' ] ++ ; int result = 0 , multiplier = 1 ; for ( int i = 0 ; i <= 9 ; i ++ ) { while ( count [ i ] > 0 ) { result = result + ( i * multiplier ) ; count [ i ] -- ; multiplier = multiplier * 10 ; } } return result ; } int main ( ) { int num = 38293367 ; cout << printMaxNum ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestNumber ( string num ) { int n = num . size ( ) ; int rightMax [ n ] , right ; rightMax [ n - 1 ] = -1 ; right = n - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( num [ i ] < num [ right ] ) rightMax [ i ] = right ; else { rightMax [ i ] = -1 ; right = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( rightMax [ i ] != -1 ) { swap ( num [ i ] , num [ rightMax [ i ] ] ) ; break ; } } return num ; } int main ( ) { string num = "8725634" ; cout << " Largest ▁ number : " << largestNumber ( num ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; int nCr ( int n , int r ) { if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ) ; answer /= i ; } return answer ; } float binomialProbability ( int n , int k , float p ) { return nCr ( n , k ) * pow ( p , k ) * pow ( 1 - p , n - k ) ; } int main ( ) { int n = 10 ; int k = 5 ; float p = 1.0 / 3 ; float probability = binomialProbability ( n , k , p ) ; cout << " Probability ▁ of ▁ " << k ; cout << " ▁ heads ▁ when ▁ a ▁ coin ▁ is ▁ tossed ▁ " << n ; cout << " ▁ times ▁ where ▁ probability ▁ of ▁ each ▁ head ▁ is ▁ " << p << endl ; cout << " ▁ is ▁ = ▁ " << probability << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = max ( high , arr [ i ] ) ; int divisors [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxGCD ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxGCD ( int arr [ ] , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = max ( high , arr [ i ] ) ; int count [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; counter = 0 ; while ( j <= high ) { if ( count [ j ] >= 2 ) return j ; else if ( count [ j ] == 1 ) counter ++ ; j += i ; if ( counter == 2 ) return i ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxGCD ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #include <math.h> NEW_LINE int count_one ( int n ) { int c_one = 0 ; while ( n != 0 ) { int rem = n % 10 ; if ( rem == 1 ) c_one = c_one + 1 ; n = n / 10 ; } return c_one ; } int checkEvil ( int n ) { int i = 0 , bin = 0 , n_one = 0 ; while ( n != 0 ) { int r = n % 2 ; bin = bin + r * ( int ) ( pow ( 10 , i ) ) ; n = n / 2 ; } n_one = count_one ( bin ) ; if ( n_one % 2 == 0 ) return 1 ; else return 0 ; } int main ( void ) { int i , check , num ; num = 32 ; check = checkEvil ( num ) ; if ( check == 1 ) cout << num << " ▁ is ▁ Evil ▁ Number STRNEWLINE " ; else cout << num << " ▁ is ▁ Odious ▁ Number STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; } int main ( ) { cout << CountPairs ( 1 ) << endl ; cout << CountPairs ( 2 ) << endl ; cout << CountPairs ( 3 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long powermod ( long long x , long long y , long long p ) { while ( y > 0 ) { if ( y & 1LL ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } long long modInverse ( long long a , long long m ) { long long m0 = m , t , q ; long long x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m , a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } long long evaluteExpression ( long long & n ) { long long firstsum = 0 , mod = 10 ; for ( long long i = 2 , j = 0 ; ( 1LL << j ) <= n ; i *= i , ++ j ) firstsum = ( firstsum + i ) % mod ; long long secondsum = ( powermod ( 4LL , n + 1 , mod ) - 1 ) * modInverse ( 3LL , mod ) ; return ( firstsum * secondsum ) % mod ; } int main ( ) { long long n = 3 ; cout << evaluteExpression ( n ) << endl ; n = 10 ; cout << evaluteExpression ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000001 NEW_LINE #define pii  pair<int, int> NEW_LINE #define F  first NEW_LINE #define S  second NEW_LINE vector < pii > factors [ MAX ] ; void sieveOfEratothenese ( ) { bool isPrime [ MAX ] ; memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = i ; j < MAX ; j += i ) { int k , l ; isPrime [ j ] = false ; for ( k = j , l = 0 ; k % i == 0 ; l ++ , k /= i ) ; factors [ j ] . push_back ( make_pair ( i , l ) ) ; } } } } int sumOfProperDivisors ( int num ) { int mul = 1 ; for ( int i = 0 ; i < factors [ num ] . size ( ) ; i ++ ) mul *= ( ( pow ( factors [ num ] [ i ] . F , factors [ num ] [ i ] . S + 1 ) - 1 ) / ( factors [ num ] [ i ] . F - 1 ) ) ; return mul - num ; } int main ( ) { sieveOfEratothenese ( ) ; int arr [ ] = { 8 , 13 , 24 , 36 , 59 , 75 , 91 } ; for ( int i = 0 ; i < sizeof ( arr ) / sizeof ( int ) ; i ++ ) cout << sumOfProperDivisors ( arr [ i ] ) << " ▁ " ; cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; } int main ( ) { cout << PowerOFPINnfactorial ( 4 , 2 ) << endl ; return 0 ; }
#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; #define ull  unsigned long long int NEW_LINE int decimalToBinary ( int N ) { ull B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; ull c = pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; } int main ( ) { int N = 17 ; cout << decimalToBinary ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base = 1 ; int temp = num ; while ( temp ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; } int main ( ) { int num = 10101001 ; cout << binaryToDecimal ( num ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long int stirlingFactorial ( int n ) { if ( n == 1 ) return 1 ; long int z ; z = sqrt ( 2 * 3.14 * n ) * pow ( ( n / e ) , n ) ; return z ; } int main ( ) { cout << stirlingFactorial ( 1 ) << endl ; cout << stirlingFactorial ( 2 ) << endl ; cout << stirlingFactorial ( 3 ) << endl ; cout << stirlingFactorial ( 4 ) << endl ; cout << stirlingFactorial ( 5 ) << endl ; cout << stirlingFactorial ( 6 ) << endl ; cout << stirlingFactorial ( 7 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countXorPair ( int arr [ ] , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countXorPair ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; long reverse ( long ) ; bool isPalindrome ( long ) ; static int MAX_ITERATIONS = 20 ; string isLychrel ( long number ) { for ( int i = 0 ; i < MAX_ITERATIONS ; i ++ ) { number = number + reverse ( number ) ; if ( isPalindrome ( number ) ) return " false " ; } return " true " ; } bool isPalindrome ( long number ) { return number == reverse ( number ) ; } long reverse ( long number ) { long reverse = 0 ; while ( number > 0 ) { long remainder = number % 10 ; reverse = ( reverse * 10 ) + remainder ; number = number / 10 ; } return reverse ; } int main ( ) { long number = 295 ; cout << number << " ▁ is ▁ lychrel ? ▁ " << isLychrel ( number ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findRectNum ( int n ) { return n * ( n + 1 ) ; } int main ( ) { int n = 6 ; cout << findRectNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_ITERATIONS = 10000 ; float f ( float x ) { return 1 * pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ; } void Muller ( float a , float b , float c ) { int i ; float res ; for ( i = 0 ; ; ++ i ) { float f1 = f ( a ) ; float f2 = f ( b ) ; float f3 = f ( c ) ; float d1 = f1 - f3 ; float d2 = f2 - f3 ; float h1 = a - c ; float h2 = b - c ; float a0 = f3 ; float a1 = ( ( ( d2 * pow ( h1 , 2 ) ) - ( d1 * pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; float a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; float x = ( ( -2 * a0 ) / ( a1 + abs ( sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; float y = ( ( -2 * a0 ) / ( a1 - abs ( sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; if ( x >= y ) res = x + c ; else res = y + c ; float m = res * 100 ; float n = c * 100 ; m = floor ( m ) ; n = floor ( n ) ; if ( m == n ) break ; a = b ; b = c ; c = res ; if ( i > MAX_ITERATIONS ) { cout << " Root ▁ cannot ▁ be ▁ found ▁ using " << " ▁ Muller ' s ▁ method " ; break ; } } if ( i <= MAX_ITERATIONS ) cout << " The ▁ value ▁ of ▁ the ▁ root ▁ is ▁ " << res ; } int main ( ) { float a = 0 , b = 1 , c = 2 ; Muller ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE const int MAX = 100001 ; vector < ll > p ; void sieve ( ) { ll isPrime [ MAX + 1 ] ; for ( ll i = 2 ; i <= MAX ; i ++ ) { if ( isPrime [ i ] == 0 ) { p . push_back ( i ) ; for ( ll j = 2 ; i * j <= MAX ; j ++ ) isPrime [ i * j ] = 1 ; } } } ll phi ( ll n ) { ll res = n ; for ( ll i = 0 ; p [ i ] * p [ i ] <= n ; i ++ ) { if ( n % p [ i ] == 0 ) { res -= ( res / p [ i ] ) ; while ( n % p [ i ] == 0 ) n /= p [ i ] ; } } if ( n > 1 ) res -= ( res / n ) ; return res ; } int main ( ) { sieve ( ) ; cout << phi ( 11 ) << " STRNEWLINE " ; cout << phi ( 21 ) << " STRNEWLINE " ; cout << phi ( 31 ) << " STRNEWLINE " ; cout << phi ( 41 ) << " STRNEWLINE " ; cout << phi ( 51 ) << " STRNEWLINE " ; cout << phi ( 61 ) << " STRNEWLINE " ; cout << phi ( 91 ) << " STRNEWLINE " ; cout << phi ( 101 ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nthprimedigitsnumber ( long long n ) { long long len = 1 ; long long prev_count = 0 ; while ( true ) { long long curr_count = prev_count + pow ( 4 , len ) ; if ( prev_count < n && curr_count >= n ) break ; len ++ ; prev_count = curr_count ; } for ( int i = 1 ; i <= len ; i ++ ) { for ( long long j = 1 ; j <= 4 ; j ++ ) { if ( prev_count + pow ( 4 , len - i ) < n ) prev_count += pow ( 4 , len - i ) ; else { if ( j == 1 ) cout << "2" ; else if ( j == 2 ) cout << "3" ; else if ( j == 3 ) cout << "5" ; else if ( j == 4 ) cout << "7" ; break ; } } } cout << endl ; } int main ( ) { nthprimedigitsnumber ( 10 ) ; nthprimedigitsnumber ( 21 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cassini ( int n ) { return ( n & 1 ) ? -1 : 1 ; } int main ( ) { int n = 5 ; cout << cassini ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } int printRange ( int n ) { int a = factorial ( n + 2 ) + 2 ; int b = a + n - 1 ; cout << " [ " << a << " , ▁ " << b << " ] " ; return 0 ; } int main ( ) { int n = 3 ; printRange ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfTermsInNthRow ( int n ) { int sum = n * ( 2 * pow ( n , 2 ) + 1 ) ; return sum ; } int main ( ) { int n = 4 ; cout << " Sum ▁ of ▁ all ▁ the ▁ terms ▁ in ▁ nth ▁ row ▁ = ▁ " << sumOfTermsInNthRow ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; } int main ( ) { cout << firstDigit ( 12345 ) << endl ; cout << firstDigit ( 5432 ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getOccurence ( int n , int d ) { int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; } int main ( void ) { int n = 11 , d = 1 ; cout << getOccurence ( n , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUnique ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { string s = to_string ( i ) ; set < int > uniDigits ( s . begin ( ) , s . end ( ) ) ; if ( s . size ( ) == uniDigits . size ( ) ) { cout << i << " ▁ " ; } } } int main ( ) { int l = 1 , r = 20 ; printUnique ( l , r ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; cout << cosx ; } int main ( ) { float n = 30 ; cal_cos ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void multiply ( vector < int > & v , int x ) { int carry = 0 , res ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { int res = carry + v [ i ] * x ; v [ i ] = res % 10 ; carry = res / 10 ; } while ( carry != 0 ) { v . push_back ( carry % 10 ) ; carry /= 10 ; } } int findSumOfDigits ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) multiply ( v , i ) ; int sum = 0 ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) sum += v [ i ] ; return sum ; } int main ( ) { int n = 1000 ; cout << findSumOfDigits ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; for ( int i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) return i ; } int main ( ) { int n = 36 ; cout << makeOdd ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIterations ( int arr [ ] , int n ) { bool oneFound = false ; int res = 0 ; for ( int i = 0 ; i < n ; ) { if ( arr [ i ] == 1 ) oneFound = true ; while ( i < n && arr [ i ] == 1 ) i ++ ; int count_zero = 0 ; while ( i < n && arr [ i ] == 0 ) { count_zero ++ ; i ++ ; } if ( oneFound == false && i == n ) return -1 ; int curr_count ; if ( i < n && oneFound == true ) { if ( count_zero & 1 == 0 ) curr_count = count_zero / 2 ; else curr_count = ( count_zero + 1 ) / 2 ; count_zero = 0 ; } else { curr_count = count_zero ; count_zero = 0 ; } res = max ( res , curr_count ) ; } return res ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countIterations ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE int main ( ) { long long int arr [ MAX ] ; arr [ 0 ] = 0 ; arr [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] + arr [ i - 2 ] ; cout << " Fibonacci ▁ numbers ▁ divisible ▁ by ▁ " " their ▁ indexes ▁ are ▁ : STRNEWLINE " ; for ( int i = 1 ; i < MAX ; i ++ ) if ( arr [ i ] % i == 0 ) cout << " ▁ " << i ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printConsecutive ( int last , int first ) { cout << first ++ ; for ( int x = first ; x <= last ; x ++ ) cout << " ▁ + ▁ " << x ; } void findConsecutive ( int N ) { for ( int last = 1 ; last < N ; last ++ ) { for ( int first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { cout << N << " ▁ = ▁ " ; printConsecutive ( last , first + 1 ) ; return ; } } } cout << " - 1" ; } int main ( ) { int n = 12 ; findConsecutive ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printNthElement ( int n ) { int arr [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; } int main ( ) { int n = 6 ; cout << printNthElement ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumLCM ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; } int main ( ) { int n = 2 ; cout << MaxSumLCM ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE int main ( void ) { double n = 12 ; printf ( " % lf ▁ " , sqrt ( n ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool func ( int a [ ] , int k , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; } int main ( ) { int a [ ] = { 14 , 27 , 38 , 76 , 84 } ; int k = 19 ; bool res = func ( a , k , 5 ) ; if ( res ) cout << " true " ; else cout << " false " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char * tidyNum ( char str [ ] , int len ) { for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { ( char ) str [ i ] -- ; for ( int j = i + 1 ; j < len ; j ++ ) str [ j ] = '9' ; } } return str ; } int main ( ) { char str [ ] = "11333445538" ; int len = strlen ( str ) ; char * num = tidyNum ( str , len ) ; printf ( " % s STRNEWLINE " , num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createMap ( unordered_map < string , char > * um ) { ( * um ) [ "0000" ] = '0' ; ( * um ) [ "0001" ] = '1' ; ( * um ) [ "0010" ] = '2' ; ( * um ) [ "0011" ] = '3' ; ( * um ) [ "0100" ] = '4' ; ( * um ) [ "0101" ] = '5' ; ( * um ) [ "0110" ] = '6' ; ( * um ) [ "0111" ] = '7' ; ( * um ) [ "1000" ] = '8' ; ( * um ) [ "1001" ] = '9' ; ( * um ) [ "1010" ] = ' A ' ; ( * um ) [ "1011" ] = ' B ' ; ( * um ) [ "1100" ] = ' C ' ; ( * um ) [ "1101" ] = ' D ' ; ( * um ) [ "1110" ] = ' E ' ; ( * um ) [ "1111" ] = ' F ' ; } string convertBinToHex ( string bin ) { int l = bin . size ( ) ; int t = bin . find_first_of ( ' . ' ) ; int len_left = t != -1 ? t : l ; for ( int i = 1 ; i <= ( 4 - len_left % 4 ) % 4 ; i ++ ) bin = '0' + bin ; if ( t != -1 ) { int len_right = l - len_left - 1 ; for ( int i = 1 ; i <= ( 4 - len_right % 4 ) % 4 ; i ++ ) bin = bin + '0' ; } unordered_map < string , char > bin_hex_map ; createMap ( & bin_hex_map ) ; int i = 0 ; string hex = " " ; while ( 1 ) { hex += bin_hex_map [ bin . substr ( i , 4 ) ] ; i += 4 ; if ( i == bin . size ( ) ) break ; if ( bin . at ( i ) == ' . ' ) { hex += ' . ' ; i ++ ; } } return hex ; } int main ( ) { string bin = "1111001010010100001.010110110011011" ; cout << " Hexadecimal ▁ number ▁ = ▁ " << convertBinToHex ( bin ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; } int main ( ) { int m = 2 , n = 6 ; printf ( " % d STRNEWLINE " , findCount ( m , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; bool isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } } int main ( ) { cout << findNthEvenDigitNumber ( 2 ) << endl ; cout << findNthEvenDigitNumber ( 10 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisibleBy25 ( string str ) { int n = str . length ( ) ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - '0' == 0 && str [ n - 2 ] - '0' == 0 ) || ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 25 == 0 ) ; } int main ( ) { string str = "76955" ; isDivisibleBy25 ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str ) { int n = str . length ( ) ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - '0' ) * 100 + ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; int fourth_last = str [ n - 4 ] - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; } int main ( ) { string str = "769528" ; check ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; } int main ( ) { int result = findIndex ( 21 ) ; printf ( " % d STRNEWLINE " , result ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isLeap ( int y ) { if ( y % 100 != 0 && y % 4 == 0 y % 400 == 0 ) return true ; return false ; } int offsetDays ( int d , int m , int y ) { int offset = d ; switch ( m - 1 ) { case 11 : offset += 30 ; case 10 : offset += 31 ; case 9 : offset += 30 ; case 8 : offset += 31 ; case 7 : offset += 31 ; case 6 : offset += 30 ; case 5 : offset += 31 ; case 4 : offset += 30 ; case 3 : offset += 31 ; case 2 : offset += 28 ; case 1 : offset += 31 ; } if ( isLeap ( y ) && m > 2 ) offset += 1 ; return offset ; } void revoffsetDays ( int offset , int y , int * d , int * m ) { int month [ 13 ] = { 0 , 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; if ( isLeap ( y ) ) month [ 2 ] = 29 ; int i ; for ( i = 1 ; i <= 12 ; i ++ ) { if ( offset <= month [ i ] ) break ; offset = offset - month [ i ] ; } * d = offset ; * m = i ; } void addDays ( int d1 , int m1 , int y1 , int x ) { int offset1 = offsetDays ( d1 , m1 , y1 ) ; int remDays = isLeap ( y1 ) ? ( 366 - offset1 ) : ( 365 - offset1 ) ; int y2 , offset2 ; if ( x <= remDays ) { y2 = y1 ; offset2 = offset1 + x ; } else { x -= remDays ; y2 = y1 + 1 ; int y2days = isLeap ( y2 ) ? 366 : 365 ; while ( x >= y2days ) { x -= y2days ; y2 ++ ; y2days = isLeap ( y2 ) ? 366 : 365 ; } offset2 = x ; } int m2 , d2 ; revoffsetDays ( offset2 , y2 , & d2 , & m2 ) ; cout << " d2 ▁ = ▁ " << d2 << " , ▁ m2 ▁ = ▁ " << m2 << " , ▁ y2 ▁ = ▁ " << y2 ; } int main ( ) { int d = 14 , m = 3 , y = 2015 ; int x = 366 ; addDays ( d , m , y , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divisorSum ( int N , int K ) { int sum = 0 ; for ( int i = 2 ; i <= ceil ( sqrt ( N ) ) ; i ++ ) if ( N % i == 0 ) sum += ( i + N / i ) ; return sum ; } bool isPrime ( int n ) { if ( n == 1 n == 0 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } bool isHyperPerfect ( int N , int K ) { int sum = divisorSum ( N , K ) ; if ( ( 1 + K * ( sum ) ) == N ) return true ; else return false ; } int main ( ) { int N1 = 1570153 , K1 = 12 ; int N2 = 321 , K2 = 3 ; if ( isHyperPerfect ( N1 , K1 ) ) cout << N1 << " ▁ is ▁ " << K1 << " - HyperPerfect " << " STRNEWLINE " ; else cout << N1 << " ▁ is ▁ not ▁ " << K1 << " - HyperPerfect " << " STRNEWLINE " ; if ( isHyperPerfect ( N2 , K2 ) ) cout << N2 << " ▁ is ▁ " << K2 << " - HyperPerfect " << " STRNEWLINE " ; else cout << N2 << " ▁ is ▁ not ▁ " << K2 << " - HyperPerfect " << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printWellOrdered ( int number , int x , int k ) { if ( k == 0 ) { cout << number << " ▁ " ; return ; } for ( int i = ( x + 1 ) ; i < 10 ; i ++ ) printWellOrdered ( number * 10 + i , i , k - 1 ) ; } void generateWellOrdered ( int k ) { printWellOrdered ( 0 , 0 , k ) ; } int main ( ) { int k = 3 ; generateWellOrdered ( k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int convert ( int m , int n ) { if ( m == n ) return 0 ; if ( m > n ) return m - n ; if ( m <= 0 && n > 0 ) return -1 ; if ( n % 2 == 1 ) return 1 + convert ( m , n + 1 ) ; else return 1 + convert ( m , n / 2 ) ; } int main ( ) { int m = 3 , n = 11 ; cout << " Minimum ▁ number ▁ of ▁ operations ▁ : ▁ " << convert ( m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count2sinRangeAtDigit ( int number , int d ) { int powerOf10 = ( int ) pow ( 10 , d ) ; int nextPowerOf10 = powerOf10 * 10 ; int right = number % powerOf10 ; int roundDown = number - number % nextPowerOf10 ; int roundup = roundDown + nextPowerOf10 ; int digit = ( number / powerOf10 ) % 10 ; if ( digit < 2 ) return roundDown / 10 ; if ( digit == 2 ) return roundDown / 10 + right + 1 ; return roundup / 10 ; } int numberOf2sinRange ( int number ) { stringstream convert ; convert << number ; string s = convert . str ( ) ; int len = s . length ( ) ; int count = 0 ; for ( int digit = 0 ; digit < len ; digit ++ ) count += count2sinRangeAtDigit ( number , digit ) ; return count ; } int main ( ) { cout << numberOf2sinRange ( 22 ) << endl ; cout << numberOf2sinRange ( 100 ) ; return 0 ; }
unsigned long long factorial ( int n ) { const unsigned int M = 1000000007 ; unsigned long long f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) return f % M ; }
unsigned long long factorial ( int n ) { const unsigned int M = 1000000007 ; unsigned long long f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) return f ; }
int mod ( int a , int m ) { return ( a % m + m ) % m ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; } int main ( ) { int n = 3 ; cout << findStarNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisibleBy5 ( string str ) { int n = str . length ( ) ; return ( ( ( str [ n - 1 ] - '0' ) == 0 ) || ( ( str [ n - 1 ] - '0' ) == 5 ) ) ; } int main ( ) { string str = "76955" ; isDivisibleBy5 ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isTidy ( int num ) { int prev = 10 ; while ( num ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; } int main ( ) { int num = 1556 ; isTidy ( num ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int squareFree ( int n ) { int cnt = 0 ; for ( int i = 1 ; ; i ++ ) { bool isSqFree = true ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } } if ( isSqFree == true ) { cnt ++ ; if ( cnt == n ) return i ; } } return 0 ; } int main ( ) { int n = 10 ; cout << squareFree ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_PRIME = 100000 ; const int MAX_RES = 2000000000l ; void SieveOfEratosthenes ( vector < long long > & a ) { bool prime [ MAX_PRIME + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( long long p = 2 ; p * p <= MAX_PRIME ; p ++ ) { if ( prime [ p ] == true ) { for ( long long i = p * 2 ; i <= MAX_PRIME ; i += p ) prime [ i ] = false ; } } for ( long long p = 2 ; p <= MAX_PRIME ; p ++ ) if ( prime [ p ] ) a . push_back ( p ) ; } long long countSquares ( long long i , long long cur , long long k , vector < long long > & a ) { long long square = a [ i ] * a [ i ] ; long long newCur = square * cur ; if ( newCur > k ) return 0 ; long long cnt = k / ( newCur ) ; cnt += countSquares ( i + 1 , cur , k , a ) ; cnt -= countSquares ( i + 1 , newCur , k , a ) ; return cnt ; } long long squareFree ( long long n ) { vector < long long > a ; SieveOfEratosthenes ( a ) ; long long low = 1 ; long long high = MAX_RES ; while ( low < high ) { long long mid = low + ( high - low ) / 2 ; long long c = mid - countSquares ( 0 , 1 , mid , a ) ; if ( c < n ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { int n = 10 ; cout << squareFree ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long int LCM ( int arr [ ] , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( max_num < arr [ i ] ) max_num = arr [ i ] ; unsigned long long int res = 1 ; while ( x <= max_num ) { vector < int > indexes ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % x == 0 ) indexes . push_back ( j ) ; if ( indexes . size ( ) >= 2 ) { for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) arr [ indexes [ j ] ] = arr [ indexes [ j ] ] / x ; res = res * x ; } else x ++ ; } for ( int i = 0 ; i < n ; i ++ ) res = res * arr [ i ] ; return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << LCM ( arr , n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long nondecdigits ( long long n ) { long long int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; bool flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; } int main ( ) { long long n = 200 ; cout << nondecdigits ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nondecdigits ( string s ) { long long m = s . size ( ) ; long long a [ m ] ; for ( long long i = 0 ; i < m ; i ++ ) a [ i ] = s [ i ] - '0' ; long long level = m - 1 ; for ( long long i = m - 1 ; i > 0 ; i -- ) { if ( a [ i ] < a [ i - 1 ] ) { a [ i - 1 ] -- ; level = i - 1 ; } } if ( a [ 0 ] != 0 ) { for ( long long i = 0 ; i <= level ; i ++ ) cout << a [ i ] ; for ( long long i = level + 1 ; i < m ; i ++ ) cout << "9" ; } else { for ( long long i = 1 ; i < level ; i ++ ) cout << a [ i ] ; for ( long long i = level + 1 ; i < m ; i ++ ) cout << "9" ; } } int main ( ) { string n = "200" ; nondecdigits ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; } int main ( ) { printf ( " Total ▁ distinct ▁ divisors ▁ of ▁ 100 ▁ are ▁ : ▁ % d " , countDivisors ( 100 ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool hasEvenNumberOfFactors ( int n ) { int root_n = sqrt ( n ) ; if ( ( root_n * root_n ) == n ) return false ; return true ; } void printStatusOfDoors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( hasEvenNumberOfFactors ( i ) ) cout << " closed " << " ▁ " ; else cout << " open " << " ▁ " ; } } int main ( ) { int n = 5 ; printStatusOfDoors ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool validate ( long long int n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long long int temp = n ; int count = 0 ; while ( temp ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; } int main ( ) { long long int n = 1552793 ; if ( validate ( n ) ) cout << " True " ; else cout << " False " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string divisibleBy36 ( string num ) { int l = num . length ( ) ; if ( l == 0 ) return " No " ; if ( l == 1 && num [ 0 ] != '0' ) return " No " ; int two_digit_num = ( num [ l - 2 ] - '0' ) * 10 + ( num [ l - 1 ] - '0' ) ; if ( two_digit_num % 4 != 0 ) return " No " ; int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - '0' ) ; if ( sum % 9 != 0 ) return " No " ; return " Yes " ; } int main ( ) { string num = "92567812197966231384" ; cout << divisibleBy36 ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string str ) { int n = str . length ( ) ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 8 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; } int main ( ) { string str = "76952" ; check ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n / 10 ; } return count ; } int checkPrime ( int n ) { if ( n <= 1 ) return -1 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return -1 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return -1 ; return 0 ; } void printPrimePoints ( int n ) { int count = countDigits ( n ) ; if ( count == 1 count == 2 ) { cout << " - 1" ; return ; } bool found = false ; for ( int i = 1 ; i < ( count - 1 ) ; i ++ ) { int left = n / ( ( int ) pow ( 10 , count - i ) ) ; int right = n % ( ( int ) pow ( 10 , count - i - 1 ) ) ; if ( checkPrime ( left ) == 0 && checkPrime ( right ) == 0 ) { cout << i << " ▁ " ; found = true ; } } if ( found == false ) cout << " - 1" ; } int main ( ) { int n = 2317 ; printPrimePoints ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int politness ( int n ) { int count = 0 ; for ( int i = 2 ; i <= sqrt ( 2 * n ) ; i ++ ) { int a ; if ( ( 2 * n ) % i != 0 ) continue ; a = 2 * n ; a /= i ; a -= ( i - 1 ) ; if ( a % 2 != 0 ) continue ; a /= 2 ; if ( a > 0 ) { count ++ ; } } return count ; } int main ( ) { int n = 90 ; cout << " Politness ▁ of ▁ " << n << " ▁ = ▁ " << politness ( n ) << " STRNEWLINE " ; n = 15 ; cout << " Politness ▁ of ▁ " << n << " ▁ = ▁ " << politness ( n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( string str ) { int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; } int main ( ) { string str = "1332" ; check ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; #define MAXN  100001 NEW_LINE int spf [ MAXN ] ; void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } vector < int > getFactorization ( int x ) { vector < int > ret ; while ( x != 1 ) { ret . push_back ( spf [ x ] ) ; x = x / spf [ x ] ; } return ret ; } int main ( int argc , char const * argv [ ] ) { sieve ( ) ; int x = 12246 ; cout << " prime ▁ factorization ▁ for ▁ " << x << " ▁ : ▁ " ; vector < int > p = getFactorization ( x ) ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) cout << p [ i ] << " ▁ " ; cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; int prodDig [ MAX ] ; int getDigitProduct ( int x ) { if ( x < 10 ) return x ; if ( prodDig [ x ] != 0 ) return prodDig [ x ] ; int prod = ( x % 10 ) * getDigitProduct ( x / 10 ) ; return ( prodDig [ x ] = prod ) ; } void findSeed ( int n ) { vector < int > res ; for ( int i = 1 ; i <= n / 2 ; i ++ ) if ( i * getDigitProduct ( i ) == n ) res . push_back ( i ) ; if ( res . size ( ) == 0 ) { cout << " NO ▁ seed ▁ exists STRNEWLINE " ; return ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; } int main ( ) { long long int n = 138 ; findSeed ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100001 ; const int INF = INT_MAX ; int primedivisor [ MAX ] , dist [ MAX ] , pos [ MAX ] , divInd [ MAX ] ; vector < int > divisors [ MAX ] ; void sieveOfEratosthenes ( ) { for ( int i = 2 ; i * i < MAX ; ++ i ) { if ( ! primedivisor [ i ] ) for ( int j = i * i ; j < MAX ; j += i ) primedivisor [ j ] = i ; } for ( int i = 1 ; i < MAX ; ++ i ) if ( ! primedivisor [ i ] ) primedivisor [ i ] = i ; } void findDivisors ( int arr [ ] , int n ) { for ( int i = 0 ; i < MAX ; ++ i ) pos [ i ] = divInd [ i ] = -1 , dist [ i ] = INF ; for ( int i = 0 ; i < n ; ++ i ) { int num = arr [ i ] ; while ( num > 1 ) { int div = primedivisor [ num ] ; divisors [ i ] . push_back ( div ) ; while ( num % div == 0 ) num /= div ; } } } void nearestGCD ( int arr [ ] , int n ) { findDivisors ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) { for ( auto & div : divisors [ i ] ) { if ( divInd [ div ] == -1 ) divInd [ div ] = i ; else { int ind = divInd [ div ] ; divInd [ div ] = i ; if ( dist [ i ] > abs ( ind - i ) ) { dist [ i ] = abs ( ind - i ) ; pos [ i ] = ind + 1 ; } if ( dist [ ind ] > abs ( ind - i ) ) { dist [ ind ] = abs ( ind - i ) ; pos [ ind ] = i + 1 ; } } } } } int main ( ) { sieveOfEratosthenes ( ) ; int arr [ ] = { 2 , 9 , 4 , 3 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nearestGCD ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) cout << pos [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxPrimefactorNum ( int N ) { int arr [ N + 5 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( ! arr [ i ] ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } int maxval = 0 , maxint = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( arr [ i ] > maxval ) { maxval = arr [ i ] ; maxint = i ; } } return maxint ; } int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; vector < int > primes ; void sieveSundaram ( ) { bool marked [ MAX / 2 + 100 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; } void findPrimes ( int n ) { if ( n <= 2 n % 2 != 0 ) { cout << " Invalid ▁ Input ▁ STRNEWLINE " ; return ; } for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { int diff = n - primes [ i ] ; if ( binary_search ( primes . begin ( ) , primes . end ( ) , diff ) ) { cout << primes [ i ] << " ▁ + ▁ " << diff << " ▁ = ▁ " << n << endl ; return ; } } } int main ( ) { sieveSundaram ( ) ; findPrimes ( 4 ) ; findPrimes ( 38 ) ; findPrimes ( 100 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; int maxele = * max_element ( arr , arr + n ) ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = max ( ans , count ) ; } return ans ; } int main ( ) { int arr [ ] = { 3 , 6 , 2 , 5 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largestGCDSubsequence ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct data { int val ; int steps ; data ( int val , int steps ) : val ( val ) , steps ( steps ) { } } ; int minStepToReachOne ( int N ) { queue < data > q ; q . push ( data ( N , 0 ) ) ; set < int > st ; while ( ! q . empty ( ) ) { data t = q . front ( ) ; q . pop ( ) ; if ( t . val == 1 ) return t . steps ; if ( st . find ( t . val - 1 ) == st . end ( ) ) { q . push ( data ( t . val - 1 , t . steps + 1 ) ) ; st . insert ( t . val - 1 ) ; } for ( int i = 2 ; i * i <= t . val ; i ++ ) { if ( t . val % i == 0 && st . find ( t . val / i ) == st . end ( ) ) { q . push ( data ( t . val / i , t . steps + 1 ) ) ; st . insert ( t . val / i ) ; } } } } int main ( ) { int N = 17 ; cout << minStepToReachOne ( N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  1000006 NEW_LINE using namespace std ; void sieve ( int count [ ] ) { for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( count [ i ] == 0 ) { for ( int j = 2 * i ; j < MAX ; j += i ) count [ j ] ++ ; count [ i ] = 1 ; } } } int query ( int count [ ] , int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += count [ i ] ; return sum ; } int main ( ) { int count [ MAX ] ; memset ( count , 0 , sizeof count ) ; sieve ( count ) ; cout << query ( count , 6 , 10 ) << endl << query ( count , 1 , 5 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long int SubArraySum ( int arr [ ] , int n ) { long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( arr [ i ] * ( i + 1 ) * ( n - i ) ) ; return result ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ of ▁ SubArray ▁ : ▁ " << SubArraySum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateNumbers ( int factor [ ] , int n , int k ) { int next [ k ] = { 0 } ; for ( int i = 0 ; i < n ; ) { int toincrement = 0 ; for ( int j = 0 ; j < k ; j ++ ) if ( next [ j ] < next [ toincrement ] ) toincrement = j ; if ( output != next [ toincrement ] ) { output = next [ toincrement ] ; printf ( " % d ▁ " , next [ toincrement ] ) ; i ++ ; } next [ toincrement ] += factor [ toincrement ] ; } } int main ( ) { int factor [ ] = { 3 , 5 , 7 } ; int n = 10 ; int k = sizeof ( factor ) / sizeof ( factor [ 0 ] ) ; generateNumbers ( factor , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; void checkReversible ( int n ) { int rev = 0 , rem ; int flag = n ; while ( flag ) { rem = flag % 10 ; rev *= 10 ; rev += rem ; flag /= 10 ; } int sum = rev + n ; while ( sum && ( rem % 2 != 0 ) ) { rem = sum % 10 ; sum /= 10 ; } if ( sum == 0 ) cout << " Reversible ▁ Number " ; else cout << " Non - Reversible ▁ Number " ; } int main ( ) { int n = 36 ; checkReversible ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; void countReversible ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { switch ( i % 4 ) { case 0 : case 2 : count += 20 * pow ( 30 , ( i / 2 - 1 ) ) ; break ; case 3 : count += 100 * pow ( 500 , i / 4 ) ; break ; case 1 : break ; } } cout << count ; } int main ( ) { int n = 9 ; countReversible ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } int multiplicativeOrder ( int A , int N ) { if ( GCD ( A , N ) != 1 ) return -1 ; unsigned int result = 1 ; int K = 1 ; while ( K < N ) { result = ( result * A ) % N ; if ( result == 1 ) return K ; K ++ ; } return -1 ; } int main ( ) { int A = 4 , N = 7 ; cout << multiplicativeOrder ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfRange ( int a , int b ) { int i = ( a * ( a + 1 ) ) >> 1 ; int j = ( b * ( b + 1 ) ) >> 1 ; return ( i - j ) ; } int sumofproduct ( int n ) { int sum = 0 ; int root = sqrt ( n ) ; for ( int i = 1 ; i <= root ; i ++ ) { int up = n / i ; int low = max ( n / ( i + 1 ) , root ) ; sum += ( i * sumOfRange ( up , low ) ) ; sum += ( i * ( n / i ) ) ; } return sum ; } int main ( ) { int n = 10 ; cout << sumofproduct ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } int power ( int x , unsigned int y , int p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } void findPrimefactors ( unordered_set < int > & s , int n ) { while ( n % 2 == 0 ) { s . insert ( 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { s . insert ( i ) ; n = n / i ; } } if ( n > 2 ) s . insert ( n ) ; } int findPrimitive ( int n ) { unordered_set < int > s ; if ( isPrime ( n ) == false ) return -1 ; int phi = n - 1 ; findPrimefactors ( s , phi ) ; for ( int r = 2 ; r <= phi ; r ++ ) { bool flag = false ; for ( auto it = s . begin ( ) ; it != s . end ( ) ; it ++ ) { if ( power ( r , phi / ( * it ) , n ) == 1 ) { flag = true ; break ; } } if ( flag == false ) return r ; } return -1 ; } int main ( ) { int n = 761 ; cout << " ▁ Smallest ▁ primitive ▁ root ▁ of ▁ " << n << " ▁ is ▁ " << findPrimitive ( n ) ; return 0 ; }
# include <bits/stdc++.h> NEW_LINE using namespace std ; int kPrimeFactor ( int n , int k ) { while ( n % 2 == 0 ) { k -- ; n = n / 2 ; if ( k == 0 ) return 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( k == 1 ) return i ; k -- ; n = n / i ; } } if ( n > 2 && k == 1 ) return n ; return -1 ; } int main ( ) { int n = 12 , k = 3 ; cout << kPrimeFactor ( n , k ) << endl ; n = 14 , k = 3 ; cout << kPrimeFactor ( n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10001 ; void sieveOfEratosthenes ( int s [ ] ) { vector < bool > prime ( MAX + 1 , false ) ; for ( int i = 2 ; i <= MAX ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= MAX ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= MAX ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } int kPrimeFactor ( int n , int k , int s [ ] ) { while ( n > 1 ) { if ( k == 1 ) return s [ n ] ; k -- ; n /= s [ n ] ; } return -1 ; } int main ( ) { int s [ MAX + 1 ] ; memset ( s , -1 , sizeof ( s ) ) ; sieveOfEratosthenes ( s ) ; int n = 12 , k = 3 ; cout << kPrimeFactor ( n , k , s ) << endl ; n = 14 , k = 3 ; cout << kPrimeFactor ( n , k , s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; } int main ( ) { int n = 5 , x = 3 ; cout << minPower ( n , x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; int sum = 5 ; while ( n > 2 ) { sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; } int main ( ) { int n = 9 ; cout << calSum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findKCF ( int x , int y , int k ) { int small = min ( x , y ) ; int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return -1 ; } int main ( ) { int x = 4 , y = 24 , k = 3 ; cout << findKHCF ( x , y , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isToOneRec ( int n , unordered_set < int > & s ) { if ( n == 1 ) return true ; if ( s . find ( n ) != s . end ( ) ) return false ; return ( n % 2 ) ? isToOneRec ( 3 * n + 1 , s ) : isToOneRec ( n / 2 , s ) ; } bool isToOne ( int n ) { unordered_set < int > s ; return isToOneRec ( n , s ) ; } int main ( ) { int n = 5 ; isToOne ( n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isToOne ( int n ) { return ( n > 0 ) ; } int main ( ) { int n = 5 ; isToOne ( n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } void findgcd ( int n , int x , int y ) { int g = gcd ( x , y ) ; for ( int i = 0 ; i < g ; i ++ ) cout << n ; } int main ( ) { int n = 123 , x = 5 , y = 2 ; findgcd ( n , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; } int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; } int countFactorialXNotY ( int x , int y ) { return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) ; } int main ( void ) { int x = 15 , y = 25 ; cout << countFactorialXNotY ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstFactorialDivisibleNumber ( int x ) { int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; } int main ( void ) { int x = 16 ; cout << firstFactorialDivisibleNumber ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool SieveOfEratosthenes ( int n , bool isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } } void findPrimePair ( int n ) { bool isPrime [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime [ i ] && isPrime [ n - i ] ) { cout << i << " ▁ " << ( n - i ) ; return ; } } } int main ( ) { int n = 74 ; findPrimePair ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPowerof2 ( int n ) { int res = 0 ; for ( int i = n ; i >= 1 ; i -- ) { if ( ( i & ( i - 1 ) ) == 0 ) { res = i ; break ; } } return res ; } int main ( ) { int n = 10 ; cout << highestPowerof2 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getFirstDigit ( int x ) { while ( x >= 10 ) x /= 10 ; return x ; } int getCountWithSameStartAndEndFrom1 ( int x ) { if ( x < 10 ) return x ; int tens = x / 10 ; int res = tens + 9 ; int firstDigit = getFirstDigit ( x ) ; int lastDigit = x % 10 ; if ( lastDigit < firstDigit ) res -- ; return res ; } int getCountWithSameStartAndEnd ( int start , int end ) { return getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ; } int main ( ) { int start = 5 , end = 40 ; cout << getCountWithSameStartAndEnd ( start , end ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sieveOfEratosthenes ( int n , bool isPrime [ ] ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } bool rightTruPrime ( int n ) { bool isPrime [ n + 1 ] ; sieveOfEratosthenes ( n , isPrime ) ; while ( n ) { if ( isPrime [ n ] ) n = n / 10 ; else return false ; } return true ; } int main ( ) { int n = 59399 ; if ( rightTruPrime ( n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; } int main ( ) { int N = 10 , K = 2 ; cout << findSum ( N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } int findnum ( string & str ) { int n = str . length ( ) ; int count_after_dot = 0 ; bool dot_seen = false ; int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != ' . ' ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( dot_seen == true ) count_after_dot ++ ; } else dot_seen = true ; } if ( dot_seen == false ) return 1 ; int dem = ( int ) pow ( 10 , count_after_dot ) ; return ( dem / gcd ( num , dem ) ) ; } int main ( ) { string str = "5.125" ; cout << findnum ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; } int main ( ) { int n = 10 ; cout << maxHandshake ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool divisible ( string N , int digit ) { int ans = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { ans = ( ans * 10 + ( N [ i ] - '0' ) ) ; ans %= digit ; } return ( ans == 0 ) ; } int allDigits ( string N ) { bool divide [ 10 ] = { false } ; for ( int digit = 2 ; digit <= 9 ; digit ++ ) { if ( divisible ( N , digit ) ) divide [ digit ] = true ; } int result = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { if ( divide [ N [ i ] - '0' ] == true ) result ++ ; } return result ; } int main ( ) { string N = "122324" ; cout << allDigits ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSum ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum - n ; } void printAliquot ( int n ) { printf ( " % d ▁ " , n ) ; unordered_set < int > s ; s . insert ( n ) ; int next = 0 ; while ( n > 0 ) { n = getSum ( n ) ; if ( s . find ( n ) != s . end ( ) ) { cout << " Repeats with " break ; } cout << n << " ▁ " ; s . insert ( n ) ; } } int main ( ) { printAliquot ( 12 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; void sieveSundaram ( vector < int > & primes ) { bool marked [ MAX / 2 + 1 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; } int LSCPUtil ( int limit , vector < int > & prime , long long int sum_prime [ ] ) { int max_length = -1 ; int prime_number = -1 ; for ( int i = 0 ; prime [ i ] <= limit ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( sum_prime [ i ] - sum_prime [ j ] > limit ) break ; long long int consSum = sum_prime [ i ] - sum_prime [ j ] ; if ( binary_search ( prime . begin ( ) , prime . end ( ) , consSum ) ) { if ( max_length < i - j + 1 ) { max_length = i - j + 1 ; prime_number = consSum ; } } } } return prime_number ; } void LSCP ( int arr [ ] , int n ) { vector < int > primes ; sieveSundaram ( primes ) ; long long int sum_prime [ primes . size ( ) + 1 ] ; sum_prime [ 0 ] = 0 ; for ( int i = 1 ; i <= primes . size ( ) ; i ++ ) sum_prime [ i ] = primes [ i - 1 ] + sum_prime [ i - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) cout << LSCPUtil ( arr [ i ] , primes , sum_prime ) << " ▁ " ; } int main ( ) { int arr [ ] = { 10 , 30 , 40 , 50 , 1000 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; LSCP ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNums ( int n , int x , int y ) { vector < bool > arr ( n + 1 , false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; } int main ( ) { int n = 15 , x = 5 , y = 7 ; cout << countNums ( n , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverse ( int x ) { int rev = 0 ; while ( x > 0 ) { rev = ( rev * 10 ) + x % 10 ; x = x / 10 ; } return rev ; } void printEmirp ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { int rev = reverse ( p ) ; if ( p != rev && rev <= n && prime [ rev ] ) { cout << p << " ▁ " << rev << " ▁ " ; prime [ rev ] = false ; } } } } int main ( ) { int n = 40 ; printEmirp ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; { sum = sum + i ; sum = sum + ( n / i ) ; } } } sum = sum - n ; return sum ; } bool checkAbundant ( int n ) { return ( getSum ( n ) > n ) ; } int main ( ) { checkAbundant ( 12 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; checkAbundant ( 15 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } int main ( ) { isPowerful ( 20 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; isPowerful ( 27 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divisorsSum ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; } bool isDeficient ( int n ) { return ( divisorsSum ( n ) < ( 2 * n ) ) ; } int main ( ) { isDeficient ( 12 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; isDeficient ( 15 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ; vector < int > primes ; void sieveSundaram ( ) { bool marked [ MAX / 2 + 100 ] = { 0 } ; for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . push_back ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; } bool isSmith ( int n ) { int original_no = n ; int pDigitSum = 0 ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) { int p = primes [ i ] ; n = n / p ; while ( p > 0 ) { pDigitSum += ( p % 10 ) ; p = p / 10 ; } } } if ( n != 1 && n != original_no ) { while ( n > 0 ) { pDigitSum = pDigitSum + n % 10 ; n = n / 10 ; } } int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits = sumDigits + original_no % 10 ; original_no = original_no / 10 ; } return ( pDigitSum == sumDigits ) ; } int main ( ) { sieveSundaram ( ) ; cout << " Printing ▁ first ▁ few ▁ Smith ▁ Numbers " " ▁ using ▁ isSmith ( ) n " ; for ( int i = 1 ; i < 500 ; i ++ ) if ( isSmith ( i ) ) cout << i << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool iskaprekar ( int n ) { if ( n == 1 ) return true ; int sq_n = n * n ; int count_digits = 0 ; while ( sq_n ) { count_digits ++ ; sq_n /= 10 ; } for ( int r_digits = 1 ; r_digits < count_digits ; r_digits ++ ) { int eq_parts = pow ( 10 , r_digits ) ; if ( eq_parts == n ) continue ; int sum = sq_n / eq_parts + sq_n % eq_parts ; if ( sum == n ) return true ; } return false ; } int main ( ) { cout << " Printing ▁ first ▁ few ▁ Kaprekar ▁ Numbers " " ▁ using ▁ iskaprekar ( ) STRNEWLINE " ; for ( int i = 1 ; i < 10000 ; i ++ ) if ( iskaprekar ( i ) ) cout << i << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isKeith ( int x ) { vector < int > terms ; while ( temp > 0 ) { terms . push_back ( temp % 10 ) ; temp = temp / 10 ; n ++ ; } reverse ( terms . begin ( ) , terms . end ( ) ) ; int next_term = 0 , i = n ; while ( next_term < x ) { next_term = 0 ; for ( int j = 1 ; j <= n ; j ++ ) next_term += terms [ i - j ] ; terms . push_back ( next_term ) ; i ++ ; } return ( next_term == x ) ; } int main ( ) { isKeith ( 14 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isKeith ( 12 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isKeith ( 197 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canBeSumofConsec ( unsigned int n ) { return ( ( n & ( n - 1 ) ) && n ) ; } int main ( ) { unsigned int n = 15 ; canBeSumofConsec ( n ) ? cout << " true " : cout << " false " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int canBeSumofConsec ( long long int n ) { n = 2 * n ; return ( ( n & ( n - 1 ) ) != 0 ) ; } int main ( ) { long long int n = 10 ; cout << canBeSumofConsec ( n ) << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int prime ( int n ) { if ( n & 1 ) n -= 2 ; else n -- ; int i , j ; for ( i = n ; i >= 2 ; i -= 2 ) { if ( i % 2 == 0 ) continue ; for ( j = 3 ; j <= sqrt ( i ) ; j += 2 ) { if ( i % j == 0 ) break ; } if ( j > sqrt ( i ) ) return i ; } return 2 ; } int main ( ) { int n = 17 ; cout << prime ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long long int ef1 = 0 , ef2 = 2 ; long long int sum = ef1 + ef2 ; while ( ef2 <= limit ) { long long int ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; } int main ( ) { int limit = 400 ; cout << evenFibSum ( limit ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; long int evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; } int main ( ) { int n = 7 ; cout << evenFib ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxn  1000005 NEW_LINE #define INF  99999999 NEW_LINE int smallest_prime [ maxn ] ; int divisors [ maxn ] ; int segmentTree [ 4 * maxn ] ; void findSmallestPrimeFactors ( ) { for ( int i = 0 ; i < maxn ; i ++ ) smallest_prime [ i ] = INF ; for ( long long i = 2 ; i < maxn ; i ++ ) { if ( smallest_prime [ i ] == INF ) { smallest_prime [ i ] = i ; for ( long long j = i * i ; j < maxn ; j += i ) if ( smallest_prime [ j ] > i ) smallest_prime [ j ] = i ; } } } void buildDivisorsArray ( ) { for ( int i = 1 ; i < maxn ; i ++ ) { divisors [ i ] = 1 ; int n = i , p = smallest_prime [ i ] , k = 0 ; while ( n > 1 ) { n = n / p ; k ++ ; if ( smallest_prime [ n ] != p ) { divisors [ i ] = divisors [ i ] * ( k + 1 ) ; k = 0 ; } p = smallest_prime [ n ] ; } } } void buildSegtmentTree ( int node , int a , int b ) { if ( a == b ) { segmentTree [ node ] = divisors [ a ] ; return ; } buildSegtmentTree ( 2 * node , a , ( a + b ) / 2 ) ; buildSegtmentTree ( 2 * node + 1 , ( ( a + b ) / 2 ) + 1 , b ) ; segmentTree [ node ] = max ( segmentTree [ 2 * node ] , segmentTree [ 2 * node + 1 ] ) ; } int query ( int node , int a , int b , int l , int r ) { if ( l > b a > r ) return -1 ; if ( a >= l && b <= r ) return segmentTree [ node ] ; return max ( query ( 2 * node , a , ( a + b ) / 2 , l , r ) , query ( 2 * node + 1 , ( ( a + b ) / 2 ) + 1 , b , l , r ) ) ; } int main ( ) { findSmallestPrimeFactors ( ) ; buildDivisorsArray ( ) ; buildSegtmentTree ( 1 , 1 , maxn - 1 ) ; cout << " Maximum ▁ divisors ▁ that ▁ a ▁ number ▁ has ▁ " << " ▁ in ▁ [ 1 , ▁ 100 ] ▁ are ▁ " << query ( 1 , 1 , maxn - 1 , 1 , 100 ) << endl ; cout << " Maximum ▁ divisors ▁ that ▁ a ▁ number ▁ has " << " ▁ in ▁ [ 10 , ▁ 48 ] ▁ are ▁ " << query ( 1 , 1 , maxn - 1 , 10 , 48 ) << endl ; cout << " Maximum ▁ divisors ▁ that ▁ a ▁ number ▁ has " << " ▁ in ▁ [ 1 , ▁ 10 ] ▁ are ▁ " << query ( 1 , 1 , maxn - 1 , 1 , 10 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 3000 ; int smartNumber ( int n ) { int primes [ MAX ] = { 0 } ; vector < int > result ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( primes [ i ] == 0 ) { primes [ i ] = 1 ; for ( int j = i * 2 ; j < MAX ; j = j + i ) { primes [ j ] -= 1 ; if ( ( primes [ j ] + 3 ) == 0 ) result . push_back ( j ) ; } } } sort ( result . begin ( ) , result . end ( ) ) ; return result [ n - 1 ] ; } int main ( ) { int n = 50 ; cout << smartNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; } int main ( ) { int x = 100 , y = 19 ; cout << countSteps ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > ma ; void primeFactorize ( int a ) { for ( int i = 2 ; i * i <= a ; i += 2 ) { int cnt = 0 ; while ( a % i == 0 ) { cnt ++ ; a /= i ; } ma [ i ] = cnt ; } if ( a > 1 ) { ma [ a ] = 1 ; } } int commDiv ( int a , int b ) { primeFactorize ( a ) ; int res = 1 ; for ( auto m = ma . begin ( ) ; m != ma . end ( ) ; m ++ ) { int cnt = 0 ; int key = m -> first ; int value = m -> second ; while ( b % key == 0 ) { b /= key ; cnt ++ ; } res *= ( min ( cnt , value ) + 1 ) ; } return res ; } int main ( ) { int a = 12 , b = 24 ; cout << commDiv ( a , b ) << endl ; return 0 ; }
int isHappyNumber ( int n ) { set < int > st ; while ( 1 ) { n = numSquareSum ( n ) ; if ( n == 1 ) return true ; if ( st . find ( n ) != st . end ( ) ) return false ; st . insert ( n ) ; } }
#include <iostream> NEW_LINE float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = static_cast < int > ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0 * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; } int main ( ) { float num = 9.2345 ; float sqroot_of_num = sqroot ( num ) ; std :: cout << " Square ▁ root ▁ of ▁ " << num << " ▁ = ▁ " << sqroot_of_num ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , int a ) { int res = 1 ; while ( a ) { if ( a & 1 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; } int breakInteger ( int N ) { if ( N == 2 ) return 1 ; if ( N == 3 ) return 2 ; int maxProduct ; switch ( N % 3 ) { case 0 : maxProduct = power ( 3 , N / 3 ) ; break ; case 1 : maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; break ; case 2 : maxProduct = 2 * power ( 3 , N / 3 ) ; break ; } return maxProduct ; } int main ( ) { int maxProduct = breakInteger ( 10 ) ; cout << maxProduct << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digSum ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; } int main ( ) { int n = 1234 ; cout << digSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } int main ( ) { int n = 9999 ; cout << digSum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; } int main ( ) { cout << " Count ▁ = ▁ " << countMultiples ( 25 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Modulo ( int a , char b [ ] ) { int mod = 0 ; for ( int i = 0 ; i < strlen ( b ) ; i ++ ) mod = ( mod * 10 + b [ i ] - '0' ) % a ; } int LastDigit ( char a [ ] , char b [ ] ) { int len_a = strlen ( a ) , len_b = strlen ( b ) ; if ( len_a == 1 && len_b == 1 && b [ 0 ] == '0' && a [ 0 ] == '0' ) return 1 ; if ( len_b == 1 && b [ 0 ] == '0' ) return 1 ; if ( len_a == 1 && a [ 0 ] == '0' ) return 0 ; int exp = ( Modulo ( 4 , b ) == 0 ) ? 4 : Modulo ( 4 , b ) ; int res = pow ( a [ len_a - 1 ] - '0' , exp ) ; return res % 10 ; } int main ( ) { char a [ ] = "117" , b [ ] = "3" ; cout << LastDigit ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long reversDigits ( long long num ) { long long rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } bool isPalindrome ( long long num ) { return ( reversDigits ( num ) == num ) ; } void ReverseandAdd ( long long num ) { long long rev_num = 0 ; while ( num <= 4294967295 ) { rev_num = reversDigits ( num ) ; num = num + rev_num ; if ( isPalindrome ( num ) ) { printf ( " % lld STRNEWLINE " , num ) ; break ; } else if ( num > 4294967295 ) { printf ( " No ▁ palindrome ▁ exist " ) ; } } } int main ( ) { ReverseandAdd ( 195 ) ; ReverseandAdd ( 265 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; } int main ( ) { int a = 34 , b = 17 ; printf ( " Gcd ▁ of ▁ given ▁ numbers ▁ is ▁ % d STRNEWLINE " , gcd ( a , b ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int sum [ 1000005 ] ; int toInt ( char x ) { return int ( x ) - '0' ; } void prepareSum ( string s ) { sum [ 0 ] = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) sum [ i + 1 ] = sum [ i ] + toInt ( s [ i ] ) ; } void query ( int l , int r ) { if ( ( sum [ r + 1 ] - sum [ l ] ) % 3 == 0 ) cout << " Divisible ▁ by ▁ 3 STRNEWLINE " ; else cout << " Not ▁ divisible ▁ by ▁ 3 STRNEWLINE " ; } int main ( ) { string n = "12468236544" ; prepareSum ( n ) ; query ( 0 , 1 ) ; query ( 1 , 2 ) ; query ( 3 , 6 ) ; query ( 0 , 10 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNDigitNumsUtil ( int n , int sum , char * out , int index ) { if ( index > n sum < 0 ) return ; if ( index == n ) { if ( sum == 0 ) { out [ index ] = ' \0' ; cout << out << " ▁ " ; } return ; } for ( int i = 0 ; i <= 9 ; i ++ ) { out [ index ] = i + '0' ; findNDigitNumsUtil ( n , sum - i , out , index + 1 ) ; } } void findNDigitNums ( int n , int sum ) { char out [ n + 1 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) { out [ 0 ] = i + '0' ; findNDigitNumsUtil ( n , sum - i , out , 1 ) ; } } int main ( ) { int n = 2 , sum = 3 ; findNDigitNums ( n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int oneDigit ( int num ) { return ( num >= 0 && num < 10 ) ; } bool isPalUtil ( int num , int * dupNum ) { if ( oneDigit ( num ) ) return ( num == ( * dupNum ) % 10 ) ; if ( ! isPalUtil ( num / 10 , dupNum ) ) return false ; * dupNum /= 10 ; return ( num % 10 == ( * dupNum ) % 10 ) ; } int isPal ( int num ) { if ( num < 0 ) num = - num ; return isPalUtil ( num , dupNum ) ; } void printPalPrimesLessThanN ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] && isPal ( p ) ) cout << p << " ▁ " ; } int main ( ) { int n = 100 ; printf ( " Palindromic ▁ primes ▁ smaller ▁ than ▁ or ▁ " " equal ▁ to ▁ % d ▁ are ▁ : STRNEWLINE " , n ) ; printPalPrimesLessThanN ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } void printKAlmostPrimes ( int k , int n ) { for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == k ) { printf ( " % d ▁ " , num ) ; i ++ ; } } return ; } int main ( ) { int n = 10 , k = 2 ; printf ( " First ▁ % d ▁ % d - almost ▁ prime ▁ numbers ▁ : ▁ STRNEWLINE " , n , k ) ; printKAlmostPrimes ( k , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } void lowest ( int & den3 , int & num3 ) { int common_factor = gcd ( num3 , den3 ) ; den3 = den3 / common_factor ; num3 = num3 / common_factor ; } void addFraction ( int num1 , int den1 , int num2 , int den2 , int & num3 , int & den3 ) { den3 = gcd ( den1 , den2 ) ; den3 = ( den1 * den2 ) / den3 ; num3 = ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ; lowest ( den3 , num3 ) ; } int main ( ) { int num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 , den3 , num3 ; addFraction ( num1 , den1 , num2 , den2 , num3 , den3 ) ; printf ( " % d / % d ▁ + ▁ % d / % d ▁ is ▁ equal ▁ to ▁ % d / % d STRNEWLINE " , num1 , den1 , num2 , den2 , num3 , den3 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; } int main ( ) { cout << findPieces ( 1 ) << endl ; cout << findPieces ( 2 ) << endl ; cout << findPieces ( 3 ) << endl ; cout << findPieces ( 50 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) ; return floor ( x ) + 1 ; } int main ( ) { cout << findDigits ( 1 ) << endl ; cout << findDigits ( 50000000 ) << endl ; cout << findDigits ( 1000000000 ) << endl ; cout << findDigits ( 120 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += log10 ( i ) ; return floor ( digits ) + 1 ; } int main ( ) { cout << findDigits ( 1 ) << endl ; cout << findDigits ( 5 ) << endl ; cout << findDigits ( 10 ) << endl ; cout << findDigits ( 120 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; int cube [ cubeRoot + 1 ] ; for ( int i = 1 ; i <= cubeRoot ; i ++ ) cube [ i ] = i * i * i ; int l = 1 ; int r = cubeRoot ; while ( l < r ) { if ( cube [ l ] + cube [ r ] < n ) l ++ ; else if ( cube [ l ] + cube [ r ] > n ) r -- ; else { cout << " ( " << l << " , ▁ " << r << " ) " << endl ; l ++ ; r -- ; } } } int main ( ) { int n = 20683 ; findPairs ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int n ) { int cubeRoot = pow ( n , 1.0 / 3.0 ) ; unordered_map < int , pair < int , int > > s ; for ( int x = 1 ; x < cubeRoot ; x ++ ) { for ( int y = x + 1 ; y <= cubeRoot ; y ++ ) { int sum = x * x * x + y * y * y ; if ( sum != n ) continue ; if ( s . find ( sum ) != s . end ( ) ) { cout << " ( " << s [ sum ] . first << " , ▁ " << s [ sum ] . second << " ) ▁ and ▁ ( " << x << " , ▁ " << y << " ) " << endl ; } else s [ sum ] = make_pair ( x , y ) ; } } } int main ( ) { int n = 13832 ; findPairs ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countEvenSum ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ even " " ▁ sum ▁ is ▁ " << countEvenSum ( arr , n ) ; return ( 0 ) ; }
#include <iostream> NEW_LINE using namespace std ; int countEvenSum ( int arr [ ] , int n ) { int temp [ 2 ] = { 1 , 0 } ; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 ; temp [ sum ] ++ ; } result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) / 2 ) ; result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) / 2 ) ; return ( result ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ even " " ▁ sum ▁ is ▁ " << countEvenSum ( arr , n ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { while ( b != 0 ) { int t = b ; b = a % b ; a = t ; } return a ; } int findMinDiff ( int a , int b , int x , int y ) { int g = gcd ( a , b ) ; int diff = abs ( x - y ) % g ; return min ( diff , g - diff ) ; } int main ( ) { int a = 20 , b = 52 , x = 5 , y = 7 ; cout << findMinDiff ( a , b , x , y ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; } int main ( ) { int n = 4 ; cout << " Sum ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " << calculateSum ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void findCombinationsUtil ( int arr [ ] , int index , int num , int reducedNum ) { if ( reducedNum < 0 ) return ; if ( reducedNum == 0 ) { for ( int i = 0 ; i < index ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; return ; } int prev = ( index == 0 ) ? 1 : arr [ index - 1 ] ; for ( int k = prev ; k <= num ; k ++ ) { arr [ index ] = k ; findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ; } } void findCombinations ( int n ) { int arr [ n ] ; findCombinationsUtil ( arr , 0 , n , n ) ; } int main ( ) { int n = 5 ; findCombinations ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; bool isPower ( int x , int y ) { int res1 = log ( y ) / log ( x ) ; return ( res1 == res2 ) ; } int main ( ) { cout << isPower ( 27 , 729 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; } int main ( ) { isPerfectSquare ( 35 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isPerfectSquare ( 49 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCount ( int d ) { return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 , d - 1 ) ) ; } int main ( ) { int d = 1 ; cout << findCount ( d ) << endl ; d = 2 ; cout << findCount ( d ) << endl ; d = 4 ; cout << findCount ( d ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countDyckPaths ( unsigned int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; } int main ( ) { int n = 4 ; cout << " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " << countDyckPaths ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) cout << i << " ▁ " ; } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) cout << n / i << " ▁ " ; } } int main ( ) { cout << " The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE " ; printDivisors ( 100 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; } int main ( ) { int n = 55 ; if ( isTriangular ( n ) ) cout << " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ; else cout << " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( -2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && floor ( root2 ) == root2 ) return true ; return false ; } int main ( ) { int num = 55 ; if ( isTriangular ( num ) ) cout << " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ; else cout << " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string fractionToDecimal ( int numr , int denr ) { map < int , int > mp ; mp . clear ( ) ; int rem = numr % denr ; while ( ( rem != 0 ) && ( mp . find ( rem ) == mp . end ( ) ) ) { mp [ rem ] = res . length ( ) ; rem = rem * 10 ; int res_part = rem / denr ; res += to_string ( res_part ) ; rem = rem % denr ; } return ( rem == 0 ) ? " " : res . substr ( mp [ rem ] ) ; } int main ( ) { int numr = 50 , denr = 22 ; string res = fractionToDecimal ( numr , denr ) ; if ( res == " " ) cout << " No ▁ recurring ▁ sequence " ; else cout << " Recurring ▁ sequence ▁ is ▁ " << res ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { int c ; while ( a != 0 ) { c = a ; a = b % a ; b = c ; } return b ; } void forbenius ( int X , int Y ) { if ( gcd ( X , Y ) != 1 ) { cout << " NA STRNEWLINE " ; return ; } int A = ( X * Y ) - ( X + Y ) ; int N = ( X - 1 ) * ( Y - 1 ) / 2 ; cout << " Largest ▁ Amount ▁ = ▁ " << A << endl ; cout << " Total ▁ Count ▁ = ▁ " << N << endl ; } int main ( ) { int X = 2 , Y = 5 ; forbenius ( X , Y ) ; X = 5 , Y = 10 ; cout << endl ; forbenius ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int has0 ( int x ) { while ( x ) { if ( x % 10 == 0 ) return 1 ; x /= 10 ; } return 0 ; } int getCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) count += has0 ( i ) ; return count ; } int main ( ) { int n = 107 ; cout << " Count ▁ of ▁ numbers ▁ from ▁ 1" << " ▁ to ▁ " << n << " ▁ is ▁ " << getCount ( n ) ; }
#include <iostream> NEW_LINE using namespace std ; typedef long long int ll ; ll mulmod ( ll a , ll b , ll mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } int main ( ) { ll a = 9223372036854775807 , b = 9223372036854775807 ; cout << mulmod ( a , b , 100000000000 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int SieveOfAtkin ( int limit ) { if ( limit > 2 ) cout << 2 << " ▁ " ; if ( limit > 3 ) cout << 3 << " ▁ " ; bool sieve [ limit ] ; for ( int i = 0 ; i < limit ; i ++ ) sieve [ i ] = false ; for ( int x = 1 ; x * x < limit ; x ++ ) { for ( int y = 1 ; y * y < limit ; y ++ ) { int n = ( 4 * x * x ) + ( y * y ) ; if ( n <= limit && ( n % 12 == 1 n % 12 == 5 ) ) sieve [ n ] ^= true ; n = ( 3 * x * x ) + ( y * y ) ; if ( n <= limit && n % 12 == 7 ) sieve [ n ] ^= true ; n = ( 3 * x * x ) - ( y * y ) ; if ( x > y && n <= limit && n % 12 == 11 ) sieve [ n ] ^= true ; } } for ( int r = 5 ; r * r < limit ; r ++ ) { if ( sieve [ r ] ) { for ( int i = r * r ; i < limit ; i += r * r ) sieve [ i ] = false ; } } for ( int a = 5 ; a < limit ; a ++ ) if ( sieve [ a ] ) cout << a << " ▁ " ; } int main ( void ) { int limit = 20 ; SieveOfAtkin ( limit ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; } int main ( ) { int p = 7 ; int n = 2 ; squareRootExists ( n , p ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; } int main ( ) { int n = 25 , p = 29 ; cout << modFact ( n , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m , a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } int findMinX ( int num [ ] , int rem [ ] , int k ) { int prod = 1 ; for ( int i = 0 ; i < k ; i ++ ) prod *= num [ i ] ; int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int pp = prod / num [ i ] ; result += rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; } int main ( void ) { int num [ ] = { 3 , 4 , 5 } ; int rem [ ] = { 2 , 3 , 1 } ; int k = sizeof ( num ) / sizeof ( num [ 0 ] ) ; cout << " x ▁ is ▁ " << findMinX ( num , rem , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinX ( int num [ ] , int rem [ ] , int k ) { while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } return x ; } int main ( void ) { int num [ ] = { 3 , 4 , 5 } ; int rem [ ] = { 2 , 3 , 1 } ; int k = sizeof ( num ) / sizeof ( num [ 0 ] ) ; cout << " x ▁ is ▁ " << findMinX ( num , rem , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  30 NEW_LINE int fib [ N ] ; int largestFiboLessOrEqual ( int n ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; int i ; for ( i = 2 ; fib [ i - 1 ] <= n ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; return ( i - 2 ) ; } char * fibonacciEncoding ( int n ) { int index = largestFiboLessOrEqual ( n ) ; char * codeword = ( char * ) malloc ( sizeof ( char ) * ( index + 3 ) ) ; int i = index ; while ( n ) { codeword [ i ] = '1' ; n = n - fib [ i ] ; i = i - 1 ; while ( i >= 0 && fib [ i ] > n ) { codeword [ i ] = '0' ; i = i - 1 ; } } codeword [ index + 1 ] = '1' ; codeword [ index + 2 ] = ' \0' ; return codeword ; } int main ( ) { int n = 143 ; cout << " Fibonacci ▁ code ▁ word ▁ for ▁ " << n << " ▁ is ▁ " << fibonacciEncoding ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( int n , int d ) { int digit = n % 10 ; int sum = digit ; if ( digit == d ) return false ; n /= 10 ; while ( n ) { digit = n % 10 ; if ( digit == d digit <= sum ) return false ; else { sum += digit ; n /= 10 ; } } return 1 ; } void printGoodNumbers ( int L , int R , int d ) { for ( int i = L ; i <= R ; i ++ ) { if ( isValid ( i , d ) ) cout << i << " ▁ " ; } } int main ( ) { int L = 410 , R = 520 , d = 3 ; printGoodNumbers ( L , R , d ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; } int main ( ) { int m = 4 , n = 3 ; cout << " Count ▁ of ▁ squares ▁ is ▁ " << countSquares ( m , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nearestSmallerEqFib ( int n ) { if ( n == 0 n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; } void printFibRepresntation ( int n ) { while ( n > 0 ) { int f = nearestSmallerEqFib ( n ) ; cout << f << " ▁ " ; n = n - f ; } } int main ( ) { int n = 30 ; cout << " Non - neighbouring ▁ Fibonacci ▁ Representation ▁ of ▁ " << n << " ▁ is ▁ STRNEWLINE " ; printFibRepresntation ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 5001 ] [ 5001 ] [ 5 ] ; int countWaysUtil ( int n , int parts , int nextPart ) { if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 parts <= 0 ) return 0 ; if ( dp [ n ] [ nextPart ] [ parts ] != -1 ) return dp [ n ] [ nextPart ] [ parts ] ; for ( int i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ; return ( dp [ n ] [ nextPart ] [ parts ] = ans ) ; } int countWays ( int n ) { memset ( dp , -1 , sizeof ( dp ) ) ; return countWaysUtil ( n , 4 , 1 ) ; } int main ( ) { int n = 8 ; cout << countWays ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void simpleSieve ( int limit , vector < int > & prime ) { vector < bool > mark ( limit + 1 , true ) ; for ( int p = 2 ; p * p < limit ; p ++ ) { if ( mark [ p ] == true ) { for ( int i = p * p ; i < limit ; i += p ) mark [ i ] = false ; } } for ( int p = 2 ; p < limit ; p ++ ) { if ( mark [ p ] == true ) { prime . push_back ( p ) ; cout << p << " ▁ " ; } } } void segmentedSieve ( int n ) { int limit = floor ( sqrt ( n ) ) + 1 ; vector < int > prime ; prime . reserve ( limit ) ; simpleSieve ( limit , prime ) ; int low = limit ; int high = 2 * limit ; while ( low < n ) { if ( high >= n ) high = n ; bool mark [ limit + 1 ] ; memset ( mark , true , sizeof ( mark ) ) ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { int loLim = floor ( low / prime [ i ] ) * prime [ i ] ; if ( loLim < low ) loLim += prime [ i ] ; for ( int j = loLim ; j < high ; j += prime [ i ] ) mark [ j - low ] = false ; } for ( int i = low ; i < high ; i ++ ) if ( mark [ i - low ] == true ) cout << i << " ▁ " ; low = low + limit ; high = high + limit ; } } int main ( ) { int n = 100000 ; cout << " Primes ▁ smaller ▁ than ▁ " << n << " : n " ; segmentedSieve ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwins ( int low , int high ) { bool prime [ high + 1 ] , twin = false ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p <= floor ( sqrt ( high ) ) + 1 ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= high ; i += p ) prime [ i ] = false ; } } for ( int i = low ; i <= high ; i ++ ) { if ( prime [ i ] && prime [ i + 2 ] ) { cout << " Smallest ▁ twins ▁ in ▁ given ▁ range : ▁ ( " << i << " , ▁ " << i + 2 << " ) " ; twin = true ; break ; } } if ( twin == false ) cout << " No ▁ such ▁ pair ▁ exists " << endl ; } int main ( ) { printTwins ( 10 , 100 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isInside ( int circle_x , int circle_y , int rad , int x , int y ) { if ( ( x - circle_x ) * ( x - circle_x ) + ( y - circle_y ) * ( y - circle_y ) <= rad * rad ) return true ; else return false ; } int main ( ) { int x = 1 , y = 1 ; int circle_x = 0 , circle_y = 1 , rad = 2 ; isInside ( circle_x , circle_y , rad , x , y ) ? cout << " Inside " : cout << " Outside " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isFancy ( string & num ) { map < char , char > fp ; fp [ '0' ] = '0' ; fp [ '1' ] = '1' ; fp [ '6' ] = '9' ; fp [ '8' ] = '8' ; fp [ '9' ] = '6' ; int n = num . length ( ) ; int l = 0 , r = n - 1 ; while ( l <= r ) { if ( fp . find ( num [ l ] ) == fp . end ( ) fp [ num [ l ] ] != num [ r ] ) return false ; l ++ ; r -- ; } return true ; } int main ( ) { string str = "9088806" ; isFancy ( str ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextSparse ( int x ) { vector < bool > bin ; while ( x != 0 ) { bin . push_back ( x & 1 ) ; x >>= 1 ; } bin . push_back ( 0 ) ; int last_final = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( bin [ i ] == 1 && bin [ i - 1 ] == 1 && bin [ i + 1 ] != 1 ) { bin [ i + 1 ] = 1 ; for ( int j = i ; j >= last_final ; j -- ) bin [ j ] = 0 ; last_final = i + 1 ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += bin [ i ] * ( 1 << i ) ; return ans ; } int main ( ) { int x = 38 ; cout << " Next ▁ Sparse ▁ Number ▁ is ▁ " << nextSparse ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ccountSubsets ( int arr [ ] , int n , int gcd [ ] , int m ) { unordered_map < int , int > freq ; unordered_map < int , int > subsets ; int arrMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arrMax = max ( arrMax , arr [ i ] ) ; freq [ arr [ i ] ] ++ ; } for ( int i = arrMax ; i >= 1 ; i -- ) { int sub = 0 ; int add = freq [ i ] ; for ( int j = 2 ; j * i <= arrMax ; j ++ ) { add += freq [ j * i ] ; sub += subsets [ j * i ] ; } subsets [ i ] = ( 1 << add ) - 1 - sub ; } for ( int i = 0 ; i < m ; i ++ ) cout << " Number ▁ of ▁ subsets ▁ with ▁ gcd ▁ " << gcd [ i ] << " ▁ is ▁ " << subsets [ gcd [ i ] ] << endl ; } int main ( ) { int gcd [ ] = { 2 , 3 } ; int arr [ ] = { 9 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = sizeof ( gcd ) / sizeof ( gcd [ 0 ] ) ; ccountSubsets ( arr , n , gcd , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumBitDifferences ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << sumBitDifferences ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } void generateUtil ( int x , int arr [ ] , int curr_sum , int curr_idx ) { if ( curr_sum == x ) { printArr ( arr , curr_idx ) ; return ; } int num = 1 ; while ( num <= x - curr_sum && ( curr_idx == 0 num <= arr [ curr_idx - 1 ] ) ) { arr [ curr_idx ] = num ; generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) ; num ++ ; } } void generate ( int x ) { int arr [ x ] ; generateUtil ( x , arr , 0 , 0 ) ; } int main ( ) { int x = 5 ; generate ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int eval ( int a , char op , int b ) { if ( op == ' + ' ) return a + b ; if ( op == ' - ' ) return a - b ; if ( op == ' * ' ) return a * b ; } vector < int > evaluateAll ( string expr , int low , int high ) { vector < int > res ; if ( low == high ) { res . push_back ( expr [ low ] - '0' ) ; return res ; } if ( low == ( high - 2 ) ) { int num = eval ( expr [ low ] - '0' , expr [ low + 1 ] , expr [ low + 2 ] - '0' ) ; res . push_back ( num ) ; return res ; } for ( int i = low + 1 ; i <= high ; i += 2 ) { vector < int > l = evaluateAll ( expr , low , i - 1 ) ; vector < int > r = evaluateAll ( expr , i + 1 , high ) ; for ( int s1 = 0 ; s1 < l . size ( ) ; s1 ++ ) { for ( int s2 = 0 ; s2 < r . size ( ) ; s2 ++ ) { int val = eval ( l [ s1 ] , expr [ i ] , r [ s2 ] ) ; res . push_back ( val ) ; } } } return res ; } int main ( ) { string expr = "1*2 + 3*4" ; int len = expr . length ( ) ; vector < int > ans = evaluateAll ( expr , 0 , len - 1 ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isPerfect ( long long int n ) { long long int sum = 1 ; for ( long long int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; } int main ( ) { cout << " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000 STRNEWLINE " ; for ( int n = 2 ; n < 10000 ; n ++ ) if ( isPerfect ( n ) ) cout << n << " ▁ is ▁ a ▁ perfect ▁ number STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool checkUtil ( int num , int dig , int base ) { if ( dig == 1 && num < base ) return true ; if ( dig > 1 && num >= base ) return checkUtil ( num / base , -- dig , base ) ; return false ; } bool check ( int num , int dig ) { for ( int base = 2 ; base <= 32 ; base ++ ) if ( checkUtil ( num , dig , base ) ) return true ; return false ; } int main ( ) { int num = 8 ; int dig = 3 ; ( check ( num , dig ) ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isLucky ( int n ) { bool arr [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) arr [ i ] = false ; while ( n > 0 ) { int digit = n % 10 ; if ( arr [ digit ] ) return false ; arr [ digit ] = true ; n = n / 10 ; } return true ; } int main ( ) { int arr [ ] = { 1291 , 897 , 4566 , 1232 , 80 , 700 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) isLucky ( arr [ i ] ) ? cout << arr [ i ] << " ▁ is ▁ Lucky ▁ STRNEWLINE " : cout << arr [ i ] << " ▁ is ▁ not ▁ Lucky ▁ STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int modInverse ( int a , int m ) { for ( int x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; } int main ( ) { int a = 3 , m = 11 ; cout << modInverse ( a , m ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int getRemainder ( int num , int divisor ) { while ( num >= divisor ) num -= divisor ; return num ; } int main ( ) { int num = 100 , divisor = 7 ; cout << getRemainder ( num , divisor ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res *= i ; return res ; } double sum ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / factorial ( i ) ; return sum ; } int main ( ) { int n = 5 ; cout << sum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } unsigned long int findWays ( unsigned n ) { if ( n & 1 ) return 0 ; return catalan ( n / 2 ) ; } int main ( ) { int n = 6 ; cout << " Total ▁ possible ▁ expressions ▁ of ▁ length ▁ " << n << " ▁ is ▁ " << findWays ( 6 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isOperand ( char c ) { return ( c >= '0' && c <= '9' ) ; } int value ( char c ) { return ( c - '0' ) ; } int evaluate ( char * exp ) { if ( * exp == ' \0' ) return -1 ; int res = value ( exp [ 0 ] ) ; for ( int i = 1 ; exp [ i ] ; i += 2 ) { char opr = exp [ i ] , opd = exp [ i + 1 ] ; if ( ! isOperand ( opd ) ) return -1 ; if ( opr == ' + ' ) res += value ( opd ) ; else if ( opr == ' - ' ) res -= value ( opd ) ; else if ( opr == ' * ' ) res *= value ( opd ) ; else if ( opr == ' / ' ) res /= value ( opd ) ; else return -1 ; } return res ; } int main ( ) { char expr1 [ ] = "1 + 2*5 + 3" ; int res = evaluate ( expr1 ) ; ( res == -1 ) ? cout << expr1 << " ▁ is ▁ " << " Invalid STRNEWLINE " : cout << " Value ▁ of ▁ " << expr1 << " ▁ is ▁ " << res << endl ; char expr2 [ ] = "1 + 2*3" ; res = evaluate ( expr2 ) ; ( res == -1 ) ? cout << expr2 << " ▁ is ▁ " << " Invalid STRNEWLINE " : cout << " Value ▁ of ▁ " << expr2 << " ▁ is ▁ " << res << endl ; char expr3 [ ] = "4-2 + 6*3" ; res = evaluate ( expr3 ) ; ( res == -1 ) ? cout << expr3 << " ▁ is ▁ " << " Invalid STRNEWLINE " : cout << " Value ▁ of ▁ " << expr3 << " ▁ is ▁ " << res << endl ; char expr4 [ ] = "1 + + 2" ; res = evaluate ( expr4 ) ; ( res == -1 ) ? cout << expr4 << " ▁ is ▁ " << " Invalid STRNEWLINE " : cout << " Value ▁ of ▁ " << expr4 << " ▁ is ▁ " << res << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubsequences ( vector < int > arr ) { int odd = 0 ; int even = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; else even ++ ; } return ( ( 1 << odd ) - 1 ) * ( 1 << even ) ; } int main ( ) { vector < int > arr = { 2 , 4 , 1 } ; cout << countSubsequences ( arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int XorSum ( int A [ ] , int B [ ] , int N , int M ) { int ans = -1 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( ans == -1 ) ans = ( A [ i ] & B [ j ] ) ; else ans ^= ( A [ i ] & B [ j ] ) ; } } return ans ; } int main ( ) { int A [ ] = { 3 , 5 } ; int B [ ] = { 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int M = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << XorSum ( A , B , N , M ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countbitdiff ( int xo ) { int count = 0 ; while ( xo ) { if ( xo % 2 == 1 ) { count ++ ; } xo = xo / 2 ; } return count ; } void shortestPath ( int n , int a , int b ) { int xorVal = a ^ b ; int cnt = countbitdiff ( xorVal ) ; if ( cnt % 2 == 0 ) cout << cnt / 2 << endl ; else cout << " - 1" << endl ; } int main ( ) { int n = 15 ; int a = 15 , b = 3 ; shortestPath ( n , a , b ) ; return 0 ; }
boolean getBit ( int num , int i ) { return ( ( num & ( 1 << i ) ) != 0 ) ; }
int clearBit ( int num , int i ) { int mask = ~ ( 1 << i ) ; return num & mask ; }
#include <iostream> NEW_LINE using namespace std ; int countSet ( int N ) { int ans = 0 ; while ( N ) { ans += N & 1 ; N >>= 1 ; } return ans ; } int countSub ( int * arr , int k ) { int ans = 0 ; int setK = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { if ( countSet ( arr [ i ] ) == k ) setK += 1 ; else setK = 0 ; ans += setK ; } return ans ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 5 , 6 } ; int K = 2 ; cout << ( countSub ( arr , K ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void oddXorSubarray ( int a [ ] , int n ) { int odd = 0 ; int c_odd = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] & 1 ) { odd = ! odd ; } if ( odd ) { c_odd ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] & 1 ) { c_odd = ( n - i - c_odd ) ; } } cout << result ; } int main ( ) { int arr [ ] = { 1 , 4 , 7 , 9 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; oddXorSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Bitwise_AND_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { int frequency [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_AND_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_AND_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } cout << bitwise_AND_sum << ' ▁ ' ; } return ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 1 , 2 , 3 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; Bitwise_AND_sum_i ( arr1 , arr2 , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Bitwise_OR_sum_i ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { int frequency [ 32 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int bit_position = 0 ; int num = arr1 [ i ] ; while ( num ) { if ( num & 1 ) { frequency [ bit_position ] += 1 ; } bit_position += 1 ; num >>= 1 ; } } for ( int i = 0 ; i < M ; i ++ ) { int num = arr2 [ i ] ; int value_at_that_bit = 1 ; int bitwise_OR_sum = 0 ; for ( int bit_position = 0 ; bit_position < 32 ; bit_position ++ ) { if ( num & 1 ) { bitwise_OR_sum += N * value_at_that_bit ; } else { bitwise_OR_sum += frequency [ bit_position ] * value_at_that_bit ; } num >>= 1 ; value_at_that_bit <<= 1 ; } cout << bitwise_OR_sum << ' ▁ ' ; } return ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 1 , 2 , 3 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; Bitwise_OR_sum_i ( arr1 , arr2 , M , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void countPairs ( int arr [ ] , int k , int size ) { int count = 0 , x ; for ( int i = 0 ; i < size - 1 ; i ++ ) { for ( int j = i + 1 ; j < size ; j ++ ) { x = arr [ i ] | arr [ j ] ; if ( x == k ) count ++ ; } } cout << count ; } int main ( ) { int arr [ ] = { 2 , 38 , 44 , 29 , 62 } ; int K = 46 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < pair < int , int > > adj [ 100005 ] ; int visited [ 100005 ] = { 0 } ; int ans = 0 ; void dfs ( int node , int xorr , int k ) { visited [ node ] = 1 ; if ( node != 1 && xorr == k ) ans ++ ; for ( auto x : adj [ node ] ) { if ( ! visited [ x . first ] ) { int xorr1 = xorr ^ x . second ; dfs ( x . first , xorr1 , k ) ; } } } void countNodes ( int N , int K , int R , vector < vector < int > > edges ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { int u = edges [ i ] [ 0 ] , v = edges [ i ] [ 1 ] , w = edges [ i ] [ 2 ] ; adj [ u ] . push_back ( { v , w } ) ; adj [ v ] . push_back ( { u , w } ) ; } dfs ( R , 0 , K ) ; cout << ans << " STRNEWLINE " ; } int main ( ) { int K = 0 , R = 1 ; vector < vector < int > > edges = { { 1 , 2 , 3 } , { 1 , 3 , 1 } , { 2 , 4 , 3 } , { 2 , 5 , 4 } , { 3 , 6 , 1 } , { 3 , 7 , 2 } } ; int N = edges . size ( ) ; countNodes ( N , K , R , edges ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinXORSubarray ( int arr [ ] , int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_xor = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_xor ^= arr [ i ] ; int min_xor = curr_xor ; for ( int i = k ; i < n ; i ++ ) { curr_xor ^= ( arr [ i ] ^ arr [ i - k ] ) ; if ( curr_xor < min_xor ) { min_xor = curr_xor ; res_index = ( i - k + 1 ) ; } } cout << min_xor << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 3 , 7 , 90 , 20 , 10 , 50 , 40 } ; int k = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMinXORSubarray ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int powerOfTwo ( int a [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ a [ i ] ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool f = false ; for ( int j = 0 ; j < 31 ; j ++ ) { int s = ( 1 << j ) - a [ i ] ; if ( mp . count ( s ) && ( mp [ s ] > 1 || mp [ s ] == 1 && s != a [ i ] ) ) f = true ; } if ( f == false ) count ++ ; } return count ; } int main ( ) { int a [ ] = { 6 , 2 , 11 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << powerOfTwo ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findArray ( int n , int a , int b , int c ) { int arr [ n + 1 ] = { } ; for ( int bit = 30 ; bit >= 0 ; bit -- ) { int set = a & ( 1 << bit ) ; if ( set ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] |= set ; } else { if ( b & ( 1 << bit ) ) { arr [ 0 ] |= ( 1 << bit ) ; if ( ! ( c & ( 1 << bit ) ) ) { arr [ 1 ] |= ( 1 << bit ) ; } } } } int aa = INT_MAX , bb = 0 , cc = 0 ; for ( int i = 0 ; i < n ; i ++ ) { aa &= arr [ i ] ; bb |= arr [ i ] ; cc ^= arr [ i ] ; } if ( a == aa && b == bb && c == cc ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } else cout << " - 1" ; } int main ( ) { int n = 3 , a = 4 , b = 6 , c = 6 ; findArray ( n , a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void keep_count ( int arr [ ] , int & even , int & odd , int N ) { int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; while ( arr [ i ] != 0 ) { arr [ i ] = ( arr [ i ] - 1 ) & arr [ i ] ; count ++ ; } if ( count % 2 == 0 ) even ++ ; else odd ++ ; } return ; } void solveQueries ( int arr [ ] , int n , int q [ ] , int m ) { int even_count = 0 , odd_count = 0 ; keep_count ( arr , even_count , odd_count , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int X = q [ i ] ; int count = 0 ; while ( X != 0 ) { X = ( X - 1 ) & X ; count ++ ; } if ( count % 2 == 0 ) { cout << even_count << " ▁ " << odd_count << " STRNEWLINE " ; } else { cout << odd_count << " ▁ " << even_count << " STRNEWLINE " ; } } } int main ( ) { int arr [ ] = { 2 , 7 , 4 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int q [ ] = { 3 , 4 , 12 , 6 } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; solveQueries ( arr , n , q , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pref [ 100001 ] = { 0 } ; int isEvenParity ( int num ) { int parity = 0 ; int x = num ; while ( x != 0 ) { if ( x & 1 ) parity ++ ; x = x >> 1 ; } if ( parity % 2 == 0 ) return num ; else return 0 ; } void preCompute ( ) { for ( int i = 1 ; i < 100001 ; i ++ ) { pref [ i ] = pref [ i - 1 ] + isEvenParity ( i ) ; } } void printSum ( int L , int R ) { cout << ( pref [ R ] - pref [ L - 1 ] ) << endl ; } void printSum ( int arr [ 2 ] [ 2 ] , int Q ) { preCompute ( ) ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } } int main ( ) { int N = 2 ; int Q [ 2 ] [ 2 ] = { { 1 , 10 } , { 121 , 211 } } ; printSum ( Q , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLargestNumber ( vector < int > & arr ) { int k = * max_element ( arr . begin ( ) , arr . end ( ) ) ; int m [ k ] = { } ; for ( auto n : arr ) ++ m [ n ] ; for ( auto n = arr . size ( ) ; n > 0 ; -- n ) { if ( n == m [ n ] ) return n ; } return -1 ; } int main ( ) { vector < int > arr = { 3 , 2 , 5 , 2 , 4 , 5 } ; cout << findLargestNumber ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int NoCarrySum ( int N , int M ) { return N ^ M ; } int main ( ) { int N = 37 ; int M = 12 ; cout << NoCarrySum ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool CheckBits ( int N , int K ) { int check = 0 ; int count = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( 1 << i ) & N ) { if ( check == 0 ) { check = 1 ; } else { if ( count < K ) { return false ; } } count = 0 ; } else { count ++ ; } } return true ; } int main ( ) { int N = 5 ; int K = 1 ; if ( CheckBits ( N , K ) ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; }
int countSubseq ( int arr [ ] , int n ) { int count = 0 ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ arr [ i ] ] ++ ; for ( auto i : mp ) { if ( i . first == 0 ) count += pow ( 2 , i . second ) - 1 ; else count += pow ( 2 , i . second - 1 ) ; } return count ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubseq ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( vector < int > & section , int pos ) { if ( pos < 0 ) return 0 ; vector < int > on_section , off_section ; for ( auto el : section ) { if ( ( ( el >> pos ) & 1 ) == 0 ) off_section . push_back ( el ) ; else on_section . push_back ( el ) ; } if ( off_section . size ( ) == 0 ) return calculate ( on_section , pos - 1 ) ; if ( on_section . size ( ) == 0 ) return calculate ( off_section , pos - 1 ) ; return min ( calculate ( off_section , pos - 1 ) , calculate ( on_section , pos - 1 ) ) + ( 1 << pos ) ; } int minXorValue ( int a [ ] , int n ) { vector < int > section ; for ( int i = 0 ; i < n ; i ++ ) section . push_back ( a [ i ] ) ; return calculate ( section , 30 ) ; } int main ( ) { int N = 4 ; int A [ N ] = { 3 , 2 , 5 , 6 } ; cout << minXorValue ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNthNum ( long long int N ) { long long int bit_L = 1 , last_num = 0 ; while ( bit_L * ( bit_L + 1 ) / 2 < N ) { last_num = last_num + bit_L ; bit_L ++ ; } int bit_R = N - last_num - 1 ; cout << ( 1 << bit_L ) + ( 1 << bit_R ) << endl ; } int main ( ) { long long int N = 13 ; findNthNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorOfArray ( int arr [ ] , int n ) { int xor_arr = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xor_arr = xor_arr ^ arr [ i ] ; } return xor_arr ; } int main ( ) { int arr [ ] = { 3 , 9 , 12 , 13 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << xorOfArray ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEvenBit ( int A [ ] , int B [ ] , int n , int m ) { int i , j , cntOdd = 0 , cntEven = 0 ; for ( i = 0 ; i < n ; i ++ ) { int x = __builtin_popcount ( A [ i ] ) ; if ( x & 1 ) { cntEven ++ ; } else { cntOdd ++ ; } } int CountB [ m ] ; for ( i = 0 ; i < m ; i ++ ) { int x = __builtin_popcount ( B [ i ] ) ; if ( x & 1 ) { CountB [ i ] = cntEven ; } else { CountB [ i ] = cntOdd ; } } for ( i = 0 ; i < m ; i ++ ) { cout << CountB [ i ] << ' ▁ ' ; } } int main ( ) { int A [ ] = { 4 , 2 , 15 , 9 , 8 , 8 } ; int B [ ] = { 3 , 4 , 22 } ; countEvenBit ( A , B , 6 , 3 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isEven ( int n ) { if ( n ^ 1 == n + 1 ) return true ; else return false ; } int main ( ) { int n = 100 ; isEven ( n ) ? cout << " Even " : cout << " Odd " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int bitwiseOrTillN ( int n ) { int result = 2 ; for ( int i = 4 ; i <= n ; i = i + 2 ) { result = result | i ; } return result ; } int main ( ) { int n = 10 ; cout << bitwiseOrTillN ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int bitwiseOrTillN ( int n ) { if ( n < 2 ) return 0 ; int bitCount = log2 ( n ) + 1 ; return pow ( 2 , bitCount ) - 2 ; } int main ( ) { int n = 10 ; cout << bitwiseOrTillN ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int bitwiseAndOdd ( int n ) { return 1 ; } int main ( ) { int n = 10 ; cout << bitwiseAndOdd ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void genSequence ( int n , int val ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int x = i ^ ( i >> 1 ) ^ val ; cout << x << " ▁ " ; } } int main ( ) { int n = 3 , k = 2 ; genSequence ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string winner ( string moves ) { map < char , int > data ; data [ ' R ' ] = 0 ; data [ ' P ' ] = 1 ; data [ ' S ' ] = 2 ; if ( moves [ 0 ] == moves [ 1 ] ) { return " Draw " ; } if ( ( ( data [ moves [ 0 ] ] | 1 << ( 2 ) ) - ( data [ moves [ 1 ] ] | 0 << ( 2 ) ) ) % 3 ) { return " A " ; } return " B " ; } void performQueries ( string arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << winner ( arr [ i ] ) << endl ; } int main ( ) { string arr [ ] = { " RS " , " SR " , " SP " , " PP " } ; int n = sizeof ( arr ) / sizeof ( string ) ; performQueries ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } int maxOnes ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int currMax = maxConsecutiveOnes ( arr [ i ] ) ; ans = max ( ans , currMax ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxOnes ( arr , n ) ; return 0 ; }
#include <climits> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int maxOR ( int L , int R ) { int maximum = INT_MIN ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = max ( maximum , ( i j ) ) ; return maximum ; } int main ( ) { int L = 4 , R = 5 ; cout << maxOR ( L , R ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 64 ; int maxOR ( int L , int R ) { if ( L == R ) { return L ; } int ans = 0 ; for ( int i = MAX - 1 ; i >= 0 ; i -- ) { int p , lbit , rbit ; p = 1 << i ; if ( ( rbit == 1 ) && ( lbit == 0 ) ) { ans += ( p << 1 ) - 1 ; break ; } if ( rbit == 1 ) { ans += p ; } } return ans ; } int main ( ) { int L = 4 , R = 5 ; cout << maxOR ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLen ( int * arr , int n , int m ) { vector < int > filter ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & m ) == m ) filter . push_back ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_and = filter [ 0 ] ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_and &= filter [ i ] ; if ( c_and == m ) return filter . size ( ) ; return 0 ; } int main ( ) { int arr [ ] = { 7 , 3 , 3 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 3 ; cout << findLen ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLen ( int * arr , int n , int m ) { vector < int > filter ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] m ) == m ) filter . push_back ( arr [ i ] ) ; if ( filter . size ( ) == 0 ) return 0 ; int c_or = filter [ 0 ] ; for ( int i = 1 ; i < filter . size ( ) ; i ++ ) c_or |= filter [ i ] ; if ( c_or == m ) return filter . size ( ) ; return 0 ; } int main ( ) { int arr [ ] = { 7 , 3 , 3 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 3 ; cout << findLen ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int toggleBit ( int n , int k ) { return ( n ^ ( 1 << ( k - 1 ) ) ) ; } int main ( ) { int n = 5 , k = 2 ; cout << toggleBit ( n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int clearBit ( int n , int k ) { return ( n & ( ~ ( 1 << ( k - 1 ) ) ) ) ; } int main ( ) { int n = 5 , k = 1 ; cout << clearBit ( n , k ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX  32 NEW_LINE int maximizeExpression ( int a , int b ) { int result = a ; for ( int bit = MAX - 1 ; bit >= 0 ; bit -- ) { int bitOfD = 1 << bit ; int x = b & bitOfD ; if ( x == bitOfD ) { int y = result & bitOfD ; if ( y == 0 ) { result = result ^ bitOfD ; } } } return result ; } int main ( ) { int a = 11 , b = 14 ; cout << maximizeExpression ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntElements ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] == ( arr [ i + 1 ] ^ arr [ i + 2 ] ) ) { cnt ++ ; } } return cnt ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xor_triplet ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j ; k < n ; k ++ ) { int xor1 = 0 , xor2 = 0 ; for ( int x = i ; x < j ; x ++ ) { xor1 ^= arr [ x ] ; } for ( int x = j ; x <= k ; x ++ ) { xor2 ^= arr [ x ] ; } if ( xor1 == xor2 ) { ans ++ ; } } } } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << xor_triplet ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lg  31 NEW_LINE struct TrieNode { TrieNode * children [ 2 ] ; int sum_of_indexes ; int number_of_indexes ; TrieNode ( ) { this -> children [ 0 ] = nullptr ; this -> children [ 1 ] = nullptr ; this -> sum_of_indexes = 0 ; this -> number_of_indexes = 0 ; } } ; void insert ( TrieNode * node , int num , int index ) { for ( int bits = lg ; bits >= 0 ; bits -- ) { int curr_bit = ( num >> bits ) & 1 ; if ( node -> children [ curr_bit ] == nullptr ) { node -> children [ curr_bit ] = new TrieNode ( ) ; } node = node -> children [ curr_bit ] ; } node -> sum_of_indexes += index ; node -> number_of_indexes ++ ; } int query ( TrieNode * node , int num , int index ) { for ( int bits = lg ; bits >= 0 ; bits -- ) { int curr_bit = ( num >> bits ) & 1 ; if ( node -> children [ curr_bit ] == nullptr ) { return 0 ; } node = node -> children [ curr_bit ] ; } int sz = node -> number_of_indexes ; int sum = node -> sum_of_indexes ; int ans = ( sz * index ) - ( sum ) ; return ans ; } int no_of_triplets ( int arr [ ] , int n ) { int curr_xor = 0 ; int number_of_triplets = 0 ; TrieNode * root = new TrieNode ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; insert ( root , curr_xor , i ) ; curr_xor ^= x ; number_of_triplets += query ( root , curr_xor , i ) ; } return number_of_triplets ; } int main ( ) { int arr [ ] = { 5 , 2 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << no_of_triplets ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE #define MAX  10 NEW_LINE using namespace std ; int findSubarray ( int array [ ] , int n ) { unordered_map < int , int > mp ; mp . insert ( { 0 , 1 } ) ; int answer = 0 ; int preXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int value = 1 ; preXor ^= array [ i ] ; for ( int j = 1 ; j <= MAX ; j ++ ) { int Y = value ^ preXor ; if ( mp . find ( Y ) != mp . end ( ) ) { answer += mp [ Y ] ; } value *= 2 ; } if ( mp . find ( preXor ) != mp . end ( ) ) { mp [ preXor ] ++ ; } else { mp . insert ( { preXor , 1 } ) ; } } return answer ; } int main ( ) { int array [ ] = { 2 , 6 , 7 , 5 , 8 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << findSubarray ( array , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_xor ( int arr [ ] , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxXor = max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; } int main ( ) { int arr [ ] = { 25 , 10 , 2 , 8 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << max_xor ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_xor ( int arr [ ] , int n ) { int maxx = 0 , mask = 0 ; set < int > se ; for ( int i = 30 ; i >= 0 ; i -- ) { mask |= ( 1 << i ) ; for ( int i = 0 ; i < n ; ++ i ) { se . insert ( arr [ i ] & mask ) ; } int newMaxx = maxx | ( 1 << i ) ; for ( int prefix : se ) { if ( se . count ( newMaxx ^ prefix ) ) { maxx = newMaxx ; break ; } } se . clear ( ) ; } return maxx ; } int main ( ) { int arr [ ] = { 25 , 10 , 2 , 8 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << max_xor ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountTriplets ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int first = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { first ^= arr [ j ] ; if ( first == 0 ) ans += ( j - i ) ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 5 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CountTriplets ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void findMajority ( int arr [ ] , int n ) { int len = sizeof ( int ) * 8 ; int number = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) count ++ ; } if ( count > ( n / 2 ) ) number += ( 1 << i ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == number ) count ++ ; if ( count > ( n / 2 ) ) cout << number ; else cout << " Majority ▁ Element ▁ Not ▁ Present " ; } int main ( ) { int arr [ ] = { 3 , 3 , 4 , 2 , 4 , 4 , 2 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMajority ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countBits ( int a , int b ) { int count = 0 ; while ( a b ) { int last_bit_a = a & 1 ; int last_bit_b = b & 1 ; if ( last_bit_a != last_bit_b ) count ++ ; a = a >> 1 ; b = b >> 1 ; } return count ; } int main ( ) { int a = 10 , b = 7 ; cout << countBits ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountSetBits ( int n ) { if ( n == 0 ) return 0 ; if ( ( n & 1 ) == 1 ) return 1 + CountSetBits ( n >> 1 ) ; else return CountSetBits ( n >> 1 ) ; } int main ( ) { int n = 21 ; cout << CountSetBits ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSum ( int BITree [ ] , int index ) { while ( index > 0 ) { sum += BITree [ index ] ; index -= index & ( - index ) ; } return sum ; } void updateBIT ( int BITree [ ] , int n , int index , int val ) { while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } } void convert ( int arr [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; sort ( temp , temp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = lower_bound ( temp , temp + n , arr [ i ] ) - temp + 1 ; } } void findElements ( int arr [ ] , int n ) { convert ( arr , n ) ; int BIT [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BIT [ i ] = 0 ; int smaller_right [ n ] , greater_left [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { smaller_right [ i ] = getSum ( BIT , arr [ i ] - 1 ) ; updateBIT ( BIT , n , arr [ i ] , 1 ) ; } cout << " Smaller ▁ right : ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << smaller_right [ i ] << " ▁ " ; cout << endl ; for ( int i = 1 ; i <= n ; i ++ ) BIT [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { greater_left [ i ] = i - getSum ( BIT , arr [ i ] ) ; updateBIT ( BIT , n , arr [ i ] , 1 ) ; } cout << " Greater ▁ left : ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << greater_left [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 12 , 1 , 2 , 3 , 0 , 11 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE int n , k ; vector < int > al [ N ] ; long long Ideal_pair ; long long bit [ N ] ; bool root_node [ N ] ; long long bit_q ( int i , int j ) { long long sum = 0ll ; while ( j > 0 ) { sum += bit [ j ] ; j -= ( j & ( j * -1 ) ) ; } i -- ; while ( i > 0 ) { sum -= bit [ i ] ; i -= ( i & ( i * -1 ) ) ; } return sum ; } void bit_up ( int i , long long diff ) { while ( i <= n ) { bit [ i ] += diff ; i += i & - i ; } } void dfs ( int node ) { Ideal_pair += bit_q ( max ( 1 , node - k ) , min ( n , node + k ) ) ; bit_up ( node , 1 ) ; for ( int i = 0 ; i < al [ node ] . size ( ) ; i ++ ) dfs ( al [ node ] [ i ] ) ; bit_up ( node , -1 ) ; } void initialise ( ) { Ideal_pair = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { root_node [ i ] = true ; bit [ i ] = 0LL ; } } void Add_Edge ( int x , int y ) { al [ x ] . push_back ( y ) ; root_node [ y ] = false ; } long long Idealpairs ( ) { int r = -1 ; for ( int i = 1 ; i <= n ; i ++ ) if ( root_node [ i ] ) { r = i ; break ; } dfs ( r ) ; return Ideal_pair ; } int main ( ) { n = 6 , k = 3 ; initialise ( ) ; Add_Edge ( 1 , 2 ) ; Add_Edge ( 1 , 3 ) ; Add_Edge ( 3 , 4 ) ; Add_Edge ( 3 , 5 ) ; Add_Edge ( 3 , 6 ) ; cout << Idealpairs ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pairORSum ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << pairORSum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } void countPrimePosition ( int arr [ ] , int n ) { int c0 = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 && isPrime ( i ) ) c0 ++ ; if ( arr [ i ] == 1 && isPrime ( i ) ) c1 ++ ; } cout << " Number ▁ of ▁ 0s ▁ = ▁ " << c0 << endl ; cout << " Number ▁ of ▁ 1s ▁ = ▁ " << c1 ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPrimePosition ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  101 NEW_LINE void prefix ( int arr [ N ] [ N ] , int prefix_xor [ N ] [ N ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { prefix_xor [ i ] [ j ] = arr [ i ] [ j ] ^ prefix_xor [ i - 1 ] [ j ] ^ prefix_xor [ i ] [ j - 1 ] ^ prefix_xor [ i - 1 ] [ j - 1 ] ; } } } void Max_xor ( int prefix_xor [ N ] [ N ] , int n ) { int max_value = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { for ( int i1 = i ; i1 <= n ; i1 ++ ) { for ( int j1 = j ; j1 <= n ; j1 ++ ) { int x = 0 ; x ^= prefix_xor [ i1 ] [ j1 ] ; x ^= prefix_xor [ i - 1 ] [ j - 1 ] ; x ^= prefix_xor [ i1 ] [ j - 1 ] ; x ^= prefix_xor [ i - 1 ] [ j1 ] ; max_value = max ( max_value , x ) ; } } } } cout << max_value << endl ; } int main ( ) { int arr [ N ] [ N ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int n = 4 ; int prefix_xor [ N ] [ N ] = { 0 } ; prefix ( arr , prefix_xor , n ) ; Max_xor ( prefix_xor , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long multiplyByFifteen ( long n ) { long prod = ( n << 4 ) ; prod = prod - n ; return prod ; } int main ( ) { long n = 7 ; cout << multiplyByFifteen ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <cmath> NEW_LINE using namespace std ; void findX ( int arr [ ] , int n ) { int * itr = max_element ( arr , arr + n ) ; int p = log2 ( * itr ) + 1 ; int X = 0 ; for ( int i = 0 ; i < p ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) { count ++ ; } } if ( count > ( n / 2 ) ) { X += 1 << i ; } } long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( X ^ arr [ i ] ) ; cout << " X ▁ = ▁ " << X << " , ▁ Sum ▁ = ▁ " << sum ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findX ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int arr [ 32 ] ; void balTernary ( int ter ) { int carry = 0 , base = 10 ; int i = 32 ; while ( ter > 0 ) { int rem = ter % base ; rem = rem + carry ; if ( rem == 0 ) { arr [ i -- ] = 0 ; carry = 0 ; } else if ( rem == 1 ) { arr [ i -- ] = 1 ; carry = 0 ; } else if ( rem == 2 ) { arr [ i -- ] = -1 ; carry = 1 ; } else if ( rem == 3 ) { arr [ i -- ] = 0 ; carry = 1 ; } ter = ter / base ; } if ( carry == 1 ) arr [ i ] = 1 ; } int ternary ( int number ) { int ans = 0 , rem = 1 , base = 1 ; while ( number > 0 ) { rem = number % 3 ; ans = ans + rem * base ; number /= 3 ; base = base * 10 ; } return ans ; } int main ( ) { int number = 3056 ; int ter = ternary ( number ) ; memset ( arr , 0 , sizeof ( arr ) ) ; balTernary ( ter ) ; int i = 0 ; while ( arr [ i ] == 0 ) { i ++ ; } for ( int j = i ; j <= 32 ; j ++ ) { if ( arr [ j ] == -1 ) cout << ' Z ' ; else cout << arr [ j ] ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minAND ( int arr [ ] , int n ) { int s = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } cout << ( s ) << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; minAND ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; } int main ( ) { int a [ ] = { 0 , 1 , 0 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; check ( a , n ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void findArray ( int q [ ] , int n ) { int arr [ n ] , ans ; for ( int k = 0 , j = 0 ; j < n / 4 ; j ++ ) { ans = q [ k ] ^ q [ k + 3 ] ; arr [ k + 1 ] = q [ k + 1 ] ^ ans ; arr [ k + 2 ] = q [ k + 2 ] ^ ans ; arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) ; arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) ; k += 4 ; } printArray ( arr , n ) ; } int main ( ) { int q [ ] = { 4 , 1 , 7 , 0 } ; int n = sizeof ( q ) / sizeof ( q [ 0 ] ) ; findArray ( q , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isEqualBlock ( int n ) { int first_bit = n % 2 ; int first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; } if ( n == 0 ) return false ; while ( n > 0 ) { int first_bit = n % 2 ; int curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; } int main ( ) { int n = 51 ; if ( isEqualBlock ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void binToDecimal3 ( int n ) { int a [ 64 ] = { 0 } ; int x = 0 , i ; for ( i = 0 ; n > 0 ; i ++ ) { a [ i ] = n % 2 ; n /= 2 ; } x = ( i < 3 ) ? 3 : i ; int d = 0 , p = 0 ; for ( int i = x - 3 ; i < x ; i ++ ) d += a [ i ] * pow ( 2 , p ++ ) ; cout << d << " ▁ " ; d = 0 ; p = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) d += a [ i ] * pow ( 2 , p ++ ) ; cout << d ; } int main ( ) { int n = 86 ; binToDecimal3 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; cout << first_3 << " ▁ " << last_3 ; } int main ( ) { int n = 86 ; binToDecimal3 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; parity ++ ; } if ( parity % 2 == 0 ) return true ; else return false ; } long sumlist ( int a [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkEvenParity ( a [ i ] ) ) sum += a [ i ] ; } return sum ; } int main ( ) { int arr [ ] = { 2 , 4 , 3 , 5 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumlist ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findOddPair ( int A [ ] , int N ) { int oddPair = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; } int main ( ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << findOddPair ( A , N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findevenPair ( int A [ ] , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; } int main ( ) { int A [ ] = { 5 , 4 , 7 , 2 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << findevenPair ( A , N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 != 0 ) count ++ ; } int totalPairs = ( N * ( N - 1 ) / 2 ) ; int oddEvenPairs = count * ( N - count ) ; return totalPairs - oddEvenPairs ; } int main ( ) { int a [ ] = { 5 , 4 , 7 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findEvenPair ( a , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findevenPair ( int A [ ] , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; } int main ( ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findevenPair ( a , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; } int main ( ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findevenPair ( a , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; } int main ( ) { int X = 4 ; cout << " Required ▁ Number ▁ is ▁ : ▁ " << calculate ( X ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ReplaceElements ( int arr [ ] , int n ) { int X = 0 ; for ( int i = 0 ; i < n ; ++ i ) { X ^= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = X ^ arr [ i ] ; } } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 5 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) { cout << arr [ i ] << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countLeadingZeros ( int x ) { unsigned y ; int n ; n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; } int FindStringof1s ( unsigned x , int n ) { int k , p ; p = 0 ; while ( x != 0 ) { k = countLeadingZeros ( x ) ; x = x << k ; p = p + k ; k = countLeadingZeros ( ~ x ) ; if ( k >= n ) return p + 1 ; x = x << k ; p = p + k ; } return -1 ; } int main ( ) { int x = 35 ; int n = 2 ; cout << FindStringof1s ( x , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countZeros ( unsigned int x ) { int total_bits = sizeof ( x ) * 8 ; int res = 0 ; while ( ! ( x & ( 1 << ( total_bits - 1 ) ) ) ) { x = ( x << 1 ) ; res ++ ; } return res ; } int main ( ) { int x = 101 ; cout << countZeros ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) cout << " Equal " else if ( ( x & ( ~ y ) ) > y ) cout << y ; else cout << x ; } int main ( ) { int x = 10 , y = 16 ; LeadingZeros ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distintBitwiseOR ( int arr [ ] , int n ) { unordered_set < int > ans , prev ; for ( int i = 0 ; i < n ; i ++ ) { unordered_set < int > ne ; for ( auto x : prev ) ne . insert ( arr [ i ] x ) ; ne . insert ( arr [ i ] ) ; for ( auto x : ne ) ans . insert ( x ) ; prev = ne ; } return ans . size ( ) ; } int main ( ) { int n = 3 ; int arr [ ] = { 1 , 2 , 4 } ; cout << distintBitwiseOR ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void subset ( int , int , int ) ; void printSubsets ( int numOfBits , int num ) { if ( num >= 0 ) { cout << " { ▁ " ; subset ( numOfBits - 1 , num , numOfBits ) ; cout << " } " << endl ; printSubsets ( numOfBits , num - 1 ) ; } else return ; } void subset ( int nthBit , int num , int numOfBits ) { if ( nthBit >= 0 ) { if ( num & ( 1 << nthBit ) ) { cout << numOfBits - nthBit << " ▁ " ; } subset ( nthBit - 1 , num , numOfBits ) ; } else return ; } int main ( ) { int n = 4 ; printSubsets ( n , pow ( 2 , n ) - 1 ) ; }
#include <iostream> NEW_LINE using namespace std ; int setRightmostUnsetBit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; } int main ( ) { int n = 21 ; cout << setRightmostUnsetBit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int AND ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << AND ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string TwoscomplementbyXOR ( string str ) { int n = str . length ( ) ; bool check_bit = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' && check_bit == 0 ) { continue ; } else { if ( check_bit == 1 ) str [ i ] = ( str [ i ] - '0' ) ^ 1 + '0' ; check_bit = 1 ; } } if ( check_bit == 0 ) return "1" + str ; else return str ; } int main ( ) { string str = "101" ; cout << TwoscomplementbyXOR ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isKthBitSet ( unsigned int n , unsigned int k ) { if ( ( n >> ( k - 1 ) ) & 1 ) return true ; return false ; } unsigned int setKthBit ( unsigned int n , unsigned int k ) { return ( ( 1 << ( k - 1 ) ) n ) ; } bool allBitsAreSet ( unsigned int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } bool bitsAreInAltOrder ( unsigned int n ) { unsigned int num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; } bool bitsAreInAltPatrnInGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { unsigned int num , left_shift ; if ( isKthBitSet ( n , r ) ) { num = n ; left_shift = r ; } else { num = setKthBit ( n , ( r + 1 ) ) ; left_shift = r + 1 ; } num = num & ( ( 1 << left_shift ) - 1 ) ; num = num >> ( l - 1 ) ; return bitsAreInAltOrder ( num ) ; } int main ( ) { unsigned int n = 18 ; unsigned int l = 1 , r = 3 ; if ( bitsAreInAltPatrnInGivenRange ( n , l , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool bitsAreInAltPatrnInGivenTRange ( unsigned int n , unsigned int l , unsigned int r ) { unsigned int num , prev , curr ; num = n >> ( l - 1 ) ; prev = num & 1 ; num = num >> 1 ; for ( int i = 1 ; i <= ( r - l ) ; i ++ ) { curr = num & 1 ; if ( curr == prev ) return false ; prev = curr ; num = num >> 1 ; } return true ; } int main ( ) { unsigned int n = 18 ; unsigned int l = 1 , r = 3 ; if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int increment ( unsigned int i ) { i = - ( ~ i ) ; return i ; } int main ( ) { int n = 3 ; cout << increment ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int bit_count ( int n ) { int count = 0 ; while ( n ) { count ++ ; n = n & ( n - 1 ) ; } return count ; } int maxsum ( int arr [ ] , int n ) { int bits [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { bits [ i ] = bit_count ( arr [ i ] ) ; } int sum [ 32 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { sum [ bits [ i ] ] += arr [ i ] ; } int maximum = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { maximum = max ( sum [ i ] , maximum ) ; } return maximum ; } int main ( ) { int arr [ ] = { 2 , 3 , 8 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxsum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorPairSum ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << xorPairSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkSame ( int n ) { int set = 0 , unset = 0 ; while ( n ) { if ( n & 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; } int main ( ) { int n = 12 ; if ( checkSame ( n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isBalanced ( string s ) { stack < char > st ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) st . push ( s [ i ] ) ; else { if ( st . empty ( ) ) { return false ; } else st . pop ( ) ; } } if ( ! st . empty ( ) ) return false ; return true ; } bool isBalancedSeq ( string s1 , string s2 ) { if ( isBalanced ( s1 + s2 ) ) return true ; return isBalanced ( s2 + s1 ) ; } int main ( ) { string s1 = " ) ( ) ( ( ) ) ) ) " ; string s2 = " ( ( ) ( ( ) ( " ; if ( isBalancedSeq ( s1 , s2 ) ) cout << " Balanced " ; else cout << " Not ▁ Balanced " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void KthCharacter ( int m , int n , int k ) { int distance = pow ( 2 , n ) ; int Block_number = k / distance ; int remaining = k % distance ; int s [ 32 ] , x = 0 ; for ( ; m > 0 ; x ++ ) { s [ x ] = m % 2 ; m = m / 2 ; } int root = s [ x - 1 - Block_number ] ; if ( remaining == 0 ) { cout << root << endl ; return ; } bool flip = true ; while ( remaining > 1 ) { if ( remaining & 1 ) { flip = ! flip ; } remaining = remaining >> 1 ; } if ( flip ) { cout << ! root << endl ; } else { cout << root << endl ; } } int main ( ) { int m = 5 , k = 5 , n = 3 ; KthCharacter ( m , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getInteger ( int L , int R ) { int number = 0 ; for ( int i = L ; i <= R ; i ++ ) number += pow ( 2 , i ) ; return number ; } int main ( ) { int L = 2 , R = 5 ; cout << getInteger ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; } int main ( ) { int L = 2 , R = 5 ; cout << setbitsfromLtoR ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findXor ( int arr [ ] , int n ) { int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; } int main ( ) { int arr [ 3 ] = { 1 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findXor ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void setBitwiseORk ( int n ) { vector < int > v ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ( i n ) == n ) v . push_back ( i ) ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << ' ▁ ' ; } int main ( ) { int n = 5 ; setBitwiseORk ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printOdds ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; int set_bit = res & ( ~ ( res - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << x << " ▁ " << y ; } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 4 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printOdds ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void subsetBitwiseORk ( int arr [ ] , int n , int k ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] k ) == k ) v . push_back ( arr [ i ] ) ; } int ans = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ans |= v [ i ] ; if ( ans != k ) { cout << " Subset ▁ does ▁ not ▁ exist " << endl ; return ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << ' ▁ ' ; } int main ( ) { int k = 3 ; int arr [ ] = { 1 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; subsetBitwiseORk ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findEletobeInserted ( int A [ ] , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) return ans ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int k = 10 ; cout << findEletobeInserted ( A , n , k ) << " ▁ has ▁ to ▁ be ▁ inserted " " ▁ in ▁ the ▁ given ▁ array ▁ to ▁ make ▁ xor ▁ sum ▁ of ▁ " << k << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int BitCount [ 10000 ] = { 0 } ; void fillSetBitsMatrix ( int arr [ ] , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { long temp = arr [ j ] >> i ; if ( temp % 2 != 0 ) BitCount [ j ] += 1 ; } } for ( int i = 1 ; i < n ; i ++ ) BitCount [ i ] += BitCount [ i - 1 ] ; } void Query ( int Q [ ] [ 2 ] , int q ) { for ( int i = 0 ; i < q ; i ++ ) cout << ( BitCount [ Q [ i ] [ 1 ] ] - BitCount [ Q [ i ] [ 0 ] - 1 ] ) << endl ; } int main ( ) { int Arr [ ] = { 1 , 5 , 6 , 10 , 9 , 4 , 67 } ; int n = sizeof ( Arr ) / sizeof ( Arr [ 0 ] ) ; fillSetBitsMatrix ( Arr , n ) ; int q = 2 ; int Q [ 2 ] [ 2 ] = { { 1 , 5 } , { 2 , 6 } } ; Query ( Q , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void decimalToBinaryNumber ( int x , int n ) { int * binaryNumber = new int ( x ) ; int i = 0 ; while ( x > 0 ) { binaryNumber [ i ] = x % 2 ; x = x / 2 ; i ++ ; } for ( int j = 0 ; j < n - i ; j ++ ) cout << '0' ; for ( int j = i - 1 ; j >= 0 ; j -- ) cout << binaryNumber [ j ] ; } void generateGrayarr ( int n ) { int N = 1 << n ; for ( int i = 0 ; i < N ; i ++ ) { int x = i ^ ( i >> 1 ) ; decimalToBinaryNumber ( x , n ) ; cout << endl ; } } int main ( ) { int n = 3 ; generateGrayarr ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define BITS  32 NEW_LINE int andSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << andSum ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  unsigned int NEW_LINE using namespace std ; ll maximize ( ll a ) { ll n = _popcnt32 ( a ) ; if ( n == 32 ) return a ; ll res = ( 1 << n ) - 1 ; return ( res << ( 32 - n ) ) ; } int main ( ) { ll a = 3 ; cout << maximize ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } int main ( ) { int i = 3 ; cout << countSetBits ( i ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isEven ( int n ) { bool isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; } int main ( ) { int n = 101 ; isEven ( n ) ? cout << " Even " : cout << " Odd " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; } int main ( ) { int n = 101 ; isEven ( n ) ? cout << " Even " : cout << " Odd " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkValidPair ( int num1 , int num2 ) { string s1 = to_string ( num1 ) ; string s2 = to_string ( num2 ) ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) for ( int j = 0 ; j < s2 . size ( ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] ) return true ; return false ; } int countPairs ( int arr [ ] , int n ) { int numberOfPairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) numberOfPairs ++ ; return numberOfPairs ; } int main ( ) { int arr [ ] = { 10 , 12 , 24 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int NUM_BITS = 32 ; bool isPowerOf2 ( int num ) { return ( num && ! ( num & ( num - 1 ) ) ) ; } bool checkSubsequence ( int arr [ ] , int n ) { if ( n == 1 ) return isPowerOf2 ( arr [ 0 ] ) ; int total = 0 ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) total = total | ( 1 << i ) ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) { int ans = total ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) ans = ans & arr [ j ] ; } if ( isPowerOf2 ( ans ) ) return true ; } return false ; } int main ( ) { int arr [ ] = { 12 , 13 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkSubsequence ( arr , n ) ) printf ( " YES STRNEWLINE " ) ; else printf ( " NO STRNEWLINE " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findWinner ( int A [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " Alice " ; else return " Bob " ; } int main ( ) { int A [ ] = { 1 , 4 , 3 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << " Winner ▁ = ▁ " << findWinner ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubsets ( int n ) { for ( int i = n ; i > 0 ; i = ( i - 1 ) & n ) cout << i << " ▁ " ; cout << 0 ; } int main ( ) { int n = 9 ; printSubsets ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxXOR ( int n , int k ) { int c = log2 ( n ) + 1 ; return ( ( 1 << c ) - 1 ) ; } int main ( ) { int n = 12 ; int k = 3 ; cout << maxXOR ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { int c = 0 ; while ( n ) { c ++ ; n = n >> 1 ; } return c ; } int XOR ( int a , int b ) { int c = min ( a , b ) ; int d = max ( a , b ) ; if ( count ( c ) < count ( d ) ) c = c << ( count ( d ) - count ( c ) ) ; return ( c ^ d ) ; } int main ( ) { int a = 13 , b = 5 ; cout << XOR ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CheckDivisibilty ( string A ) { int oddbits = 0 , evenbits = 0 ; for ( int counter = 0 ; counter < A . length ( ) ; counter ++ ) { if ( A [ counter ] == '1' ) { if ( counter % 2 == 0 ) { evenbits ++ ; } else { oddbits ++ ; } } } if ( abs ( oddbits - evenbits ) % 3 == 0 ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } } int main ( ) { string A = "10101" ; CheckDivisibilty ( A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int swapBitsInPair ( unsigned int x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; } int main ( ) { unsigned int x = 4 ; cout << swapBitsInPair ( x ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int setevenbits ( int n ) { int temp = n ; int count = 0 ; int res = 0 ; for ( temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n & res ) ; } int setoddbits ( int m ) { int count = 0 ; int res = 0 ; for ( int temp = m ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( m & res ) ; } int getAlternateBits ( int n , int m ) { int tempn = setevenbits ( n ) ; int tempm = setoddbits ( m ) ; return ( tempn tempm ) ; } int main ( ) { int n = 10 ; int m = 11 ; cout << getAlternateBits ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisibleBy10 ( char bin [ ] , int n ) { if ( bin [ n - 1 ] == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; } bool isDivisibleBy20 ( char bin [ ] , int n ) { if ( bin [ n - 1 ] == '1' ) return false ; return isDivisibleBy10 ( bin , n - 1 ) ; } int main ( ) { char bin [ ] = "101000" ; int n = sizeof ( bin ) / sizeof ( bin [ 0 ] ) ; if ( isDivisibleBy20 ( bin , n - 1 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int toggleBits ( int n1 , int n2 ) { return n1 ^ n2 ; } int main ( ) { int n1 = 2 , n2 = 5 ; cout << toggleBitst ( n1 , n2 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; } int main ( ) { int n = 11 ; cout << evenbittogglenumber ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int takeLandFsetbits ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 1 ) + 1 ; } int toggleFandLbits ( int n ) { if ( n == 1 ) return 0 ; return n ^ takeLandFsetbits ( n ) ; } int main ( ) { int n = 10 ; cout << toggleFandLbits ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int reverseBits ( unsigned int n ) { unsigned int rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( n & 1 == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } int main ( ) { unsigned int n = 11 ; cout << reverseBits ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #include <math.h> NEW_LINE int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; } int checkOdious ( int n ) { return ( countSetBits ( n ) % 2 == 1 ) ; } int main ( ) { int num = 32 ; if ( checkOdious ( num ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int setleftmostunsetbit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; } int main ( ) { int n = 10 ; cout << setleftmostunsetbit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxXorSum ( int n , int k ) { if ( k == 1 ) return n ; int res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; } int main ( ) { int n = 4 , k = 3 ; cout << maxXorSum ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPosOfRightmostSetBit ( int n ) { return log2 ( n & - n ) ; } unsigned int toggleLastKBits ( unsigned int n , unsigned int k ) { unsigned int num = ( 1 << k ) - 1 ; return ( n ^ num ) ; } unsigned int incrementByOne ( unsigned int n ) { int k = getPosOfRightmostSetBit ( ~ n ) ; n = ( ( 1 << k ) n ) ; if ( k != 0 ) n = toggleLastKBits ( n , k ) ; return n ; } int main ( ) { unsigned int n = 15 ; cout << incrementByOne ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int togglebit ( int n ) { if ( n == 0 ) return 1 ; int i = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return i ^ n ; } int XNOR ( int num1 , int num2 ) { if ( num1 < num2 ) swap ( num1 , num2 ) ; num1 = togglebit ( num1 ) ; return num1 ^ num2 ; } int main ( ) { int num1 = 10 , num2 = 20 ; cout << XNOR ( num1 , num2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MaximumSum ( int a [ ] , int b [ ] , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } cout << sum1 + sum2 << endl ; } int main ( ) { int A [ ] = { 1 , 2 , 4 , 3 , 2 } ; int B [ ] = { 2 , 3 , 3 , 12 , 1 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; MaximumSum ( A , B , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef unsigned long long int ull ; unsigned int posOfRightmostSetBit ( ull n ) { return log2 ( n & - n ) + 1 ; } unsigned int posOfCarryBit ( ull a , ull b ) { return posOfRightmostSetBit ( a & b ) ; } int main ( ) { ull a = 10 , b = 2 ; cout << posOfCarryBit ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( unsigned int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } bool differAtOneBitPos ( unsigned int a , unsigned int b ) { return isPowerOfTwo ( a ^ b ) ; } int main ( ) { unsigned int a = 13 , b = 9 ; if ( differAtOneBitPos ( a , b ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int ll ; ll power2 ( ll n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 2 ; return power2 ( n / 2 ) * power2 ( n / 2 ) ; } ll multiply ( ll x , ll n ) { return x * power2 ( n ) ; } int main ( ) { ll x = 70 , n = 2 ; cout << multiply ( x , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE typedef long long int ll ; ll multiply ( ll x , ll n ) { return x << n ; } int main ( ) { ll x = 70 , n = 2 ; printf ( " % lld " , multiply ( x , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivBy2PowerM ( unsigned int n , unsigned int m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; } int main ( ) { unsigned int n = 8 , m = 2 ; if ( isDivBy2PowerM ( n , m ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findWinner ( int N ) { return N & 1 ; } int main ( ) { int N = 15 ; findWinner ( N ) ? ( cout << " Player ▁ A " ; ) : ( cout << " Player ▁ B " ; ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countgroup ( int a [ ] , int n ) { int xs = 0 ; for ( int i = 0 ; i < n ; i ++ ) xs = xs ^ a [ i ] ; if ( xs == 0 ) return ( 1 << ( n - 1 ) ) - 1 ; return 0 ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countgroup ( a , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; } int main ( ) { int n = 11 ; cout << evenbittogglenumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisibleby17 ( int n ) { if ( n == 0 n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; } int main ( ) { int n = 35 ; if ( isDivisibleby17 ( n ) ) cout << n << " ▁ is ▁ divisible ▁ by ▁ 17" ; else cout << n << " ▁ is ▁ not ▁ divisible ▁ by ▁ 17" ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long answer ( long long n ) { long m = 2 ; long long ans = 1 ; long long r = 1 ; while ( r < n ) { r = ( int ) ( pow ( 2 , m ) - 1 ) * ( pow ( 2 , m - 1 ) ) ; if ( r < n ) ans = r ; m ++ ; } return ans ; } int main ( ) { long long n = 7 ; cout << answer ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int index ( int i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; } void check ( int n ) { string s [ ] = { " negative " , " zero " , " positive " } ; int val = index ( n ) ; cout << n << " ▁ is ▁ " << s [ val ] << endl ; } int main ( ) { check ( 30 ) ; check ( -20 ) ; check ( 0 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void compute ( unsigned long int S , unsigned long int X ) { unsigned long int A = ( S - X ) / 2 ; int a = 0 , b = 0 ; for ( int i = 0 ; i < 8 * sizeof ( S ) ; i ++ ) { unsigned long int Xi = ( X & ( 1 << i ) ) ; unsigned long int Ai = ( A & ( 1 << i ) ) ; if ( Xi == 0 && Ai == 0 ) { } else if ( Xi == 0 && Ai > 0 ) { a = ( ( 1 << i ) a ) ; b = ( ( 1 << i ) b ) ; } else if ( Xi > 0 && Ai == 0 ) { a = ( ( 1 << i ) a ) ; } { cout << " Not ▁ Possible " ; return ; } } cout << " a ▁ = ▁ " << a << endl << " b ▁ = ▁ " << b ; } int main ( ) { unsigned long int S = 17 , X = 13 ; compute ( S , X ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool checking ( string s ) { int c = 0 ; int n = s . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' ) c ++ ; if ( c >= 6 and s [ i ] == '1' ) return true ; } return false ; } int main ( ) { string s = "100010001" ; if ( checking ( s ) ) cout << " Possible " ; else cout << " Not ▁ possible " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int modifyBit ( int n , int p , int b ) { int mask = 1 << p ; return ( ( n & ~ mask ) | ( b << p ) ) ; } int main ( ) { cout << modifyBit ( 6 , 2 , 0 ) << endl ; cout << modifyBit ( 6 , 5 , 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; } unsigned int countSetBitsInGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return countSetBits ( n & num ) ; } int main ( ) { unsigned int n = 42 ; unsigned int l = 2 , r = 5 ; cout << countSetBitsInGivenRange ( n , l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findUnique ( unsigned int a [ ] , int n , int k ) { int INT_SIZE = 8 * sizeof ( unsigned int ) ; int count [ INT_SIZE ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; unsigned res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; } int main ( ) { unsigned int a [ ] = { 6 , 2 , 5 , 2 , 2 , 6 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; cout << findUnique ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool powerOfTwo ( unsigned int n ) { return ( ! ( n & n - 1 ) ) ; } bool onlyFirstAndLastAreSet ( unsigned int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return powerOfTwo ( n - 1 ) ; } int main ( ) { unsigned int n = 9 ; if ( onlyFirstAndLastAreSet ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool allBitsAreSet ( unsigned int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } bool bitsAreInAltOrder ( unsigned int n ) { unsigned int num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; } int main ( ) { unsigned int n = 10 ; if ( bitsAreInAltOrder ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int setBit ( int xorValue ) { int count = 0 ; while ( xorValue ) { if ( xorValue % 2 ) count ++ ; xorValue /= 2 ; } return count ; } int minFlip ( int n , int k ) { int size = log2 ( n ) + 1 ; int max = pow ( 2 , k ) - 1 ; max = max << ( size - k ) ; int xorValue = ( n ^ max ) ; return ( setBit ( xorValue ) ) ; } int main ( ) { int n = 27 , k = 3 ; cout << " Min ▁ Flips ▁ = ▁ " << minFlip ( n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; } int main ( ) { int n = 17 , l = 2 , r = 3 ; cout << setallbitgivenrange ( n , l , r ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int setBitNumber ( int n ) { if ( n == 0 ) return 0 ; int msb = 0 ; n = n / 2 ; while ( n != 0 ) { n = n / 2 ; msb ++ ; } return ( 1 << msb ) ; } int main ( ) { int n = 0 ; cout << setBitNumber ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int setBitNumber ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n = n + 1 ; return ( n >> 1 ) ; } int main ( ) { int n = 273 ; cout << setBitNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return " Yes " ; return " No " ; } int main ( ) { unsigned int n = 17 ; unsigned int l = 2 , r = 4 ; cout << allBitsSetInTheGivenRange ( n , l , r ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool adjacentSet ( int n ) { return ( n & ( n >> 1 ) ) ; } int main ( ) { int n = 3 ; adjacentSet ( n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getRightMostSetBit ( unsigned int n ) { return log2 ( n & - n ) + 1 ; } int posOfRightMostSameBit ( unsigned int m , unsigned int n ) { return getRightMostSetBit ( ~ ( m ^ n ) ) ; } int main ( ) { int m = 16 , n = 7 ; cout << " Position ▁ = ▁ " << posOfRightMostSameBit ( m , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; static int posOfRightMostSameBit ( int m , int n ) { int loopCounter = 1 ; while ( m > 0 n > 0 ) { bool a = m % 2 == 1 ; bool b = n % 2 == 1 ; if ( ! ( a ^ b ) ) { return loopCounter ; } m = m >> 1 ; n = n >> 1 ; loopCounter ++ ; } return -1 ; } int main ( ) { int m = 16 , n = 7 ; cout << " Position ▁ = ▁ " << posOfRightMostSameBit ( m , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return " Yes " ; return " No " ; } int main ( ) { unsigned int n = 22 ; unsigned int l = 2 , r = 3 ; cout << allBitsSetInTheGivenRange ( n , l , r ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) cout << i << " ▁ " ; } int main ( ) { int n = 3 ; printNonConsecutive ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void shuffle ( int N , int key ) { unsigned int NO_OF_BITS = N ; unsigned int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } cout << reverse_num ; } int main ( ) { int N = 3 ; unsigned int key = 3 ; shuffle ( N , key ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int n ) { int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; } int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( countSetBits ( i ) == 2 ) sum += i ; return sum ; } int main ( ) { int n = 10 ; cout << findSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ull  unsigned long long int NEW_LINE ull findMax ( ull num ) { ull num_copy = num ; int j = sizeof ( unsigned long long int ) * 8 - 1 ; int i = 0 ; while ( i < j ) { int m = ( num_copy >> i ) & 1 ; int n = ( num_copy >> j ) & 1 ; if ( m > n ) { int x = ( 1 << i 1 << j ) ; num = num ^ x ; } i ++ ; j -- ; } return num ; } int main ( ) { ull num = 4 ; cout << findMax ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string isAMultipleOf4 ( int n ) { if ( ( n & 3 ) == 0 ) return " Yes " ; return " No " ; } int main ( ) { int n = 16 ; cout << isAMultipleOf4 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPosOfRightmostSetBit ( int n ) { return log2 ( n & - n ) + 1 ; } int setRightmostUnsetBit ( int n ) { if ( n == 0 ) return 1 ; if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = getPosOfRightmostSetBit ( ~ n ) ; return ( ( 1 << ( pos - 1 ) ) n ) ; } int main ( ) { int n = 21 ; cout << setRightmostUnsetBit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; } int previousSmallerInteger ( int n ) { int pos = getFirstSetBitPos ( n ) ; return ( n & ~ ( 1 << ( pos - 1 ) ) ) ; } int main ( ) { int n = 25 ; cout << previousSmallerInteger ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createMap ( unordered_map < string , char > * um ) { ( * um ) [ "000" ] = '0' ; ( * um ) [ "001" ] = '1' ; ( * um ) [ "010" ] = '2' ; ( * um ) [ "011" ] = '3' ; ( * um ) [ "100" ] = '4' ; ( * um ) [ "101" ] = '5' ; ( * um ) [ "110" ] = '6' ; ( * um ) [ "111" ] = '7' ; } string convertBinToOct ( string bin ) { int l = bin . size ( ) ; int t = bin . find_first_of ( ' . ' ) ; int len_left = t != -1 ? t : l ; for ( int i = 1 ; i <= ( 3 - len_left % 3 ) % 3 ; i ++ ) bin = '0' + bin ; if ( t != -1 ) { int len_right = l - len_left - 1 ; for ( int i = 1 ; i <= ( 3 - len_right % 3 ) % 3 ; i ++ ) bin = bin + '0' ; } unordered_map < string , char > bin_oct_map ; createMap ( & bin_oct_map ) ; int i = 0 ; string octal = " " ; while ( 1 ) { octal += bin_oct_map [ bin . substr ( i , 3 ) ] ; i += 3 ; if ( i == bin . size ( ) ) break ; if ( bin . at ( i ) == ' . ' ) { octal += ' . ' ; i ++ ; } } return octal ; } int main ( ) { string bin = "1111001010010100001.010110110011011" ; cout << " Octal ▁ number ▁ = ▁ " << convertBinToOct ( bin ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " No " ; n = n >> 1 ; } return " Yes " ; } int main ( ) { int n = 7 ; cout << areAllBitsSet ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; } int main ( ) { int n = 7 ; cout << areAllBitsSet ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getFirstSetBitPos ( int n ) { return ( log2 ( n & - n ) + 1 ) - 1 ; } int nextGreaterWithOneMoreSetBit ( int n ) { int pos = getFirstSetBitPos ( ~ n ) ; if ( pos > -1 ) return ( 1 << pos ) | n ; return ( ( n << 1 ) + 1 ) ; } int main ( ) { int n = 10 ; cout << " Next ▁ greater ▁ integer ▁ = ▁ " << nextGreaterWithOneMoreSetBit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long CountZeroBit ( long x ) { unsigned int count = 0 ; while ( x ) { if ( ! ( x & 1LL ) ) count ++ ; x >>= 1LL ; } return count ; } long CountXORandSumEqual ( long x ) { long count = CountZeroBit ( x ) ; return ( 1LL << count ) ; } int main ( ) { long x = 10 ; cout << CountXORandSumEqual ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingNumber ( int arr1 [ ] , int arr2 [ ] , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; } int main ( ) { int arr1 [ ] = { 4 , 8 , 1 , 3 , 7 } ; int arr2 [ ] = { 7 , 4 , 3 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << " Missing ▁ number ▁ = ▁ " << missingNumber ( arr1 , arr2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class BitArray { int * arr ; public : BitArray ( ) { } BitArray ( int n ) { arr = new int [ ( n >> 5 ) + 1 ] ; } bool get ( int pos ) { int index = ( pos >> 5 ) ; int bitNo = ( pos & 0x1F ) ; return ( arr [ index ] & ( 1 << bitNo ) ) != 0 ; } void set ( int pos ) { int index = ( pos >> 5 ) ; int bitNo = ( pos & 0x1F ) ; arr [ index ] |= ( 1 << bitNo ) ; } void checkDuplicates ( int arr [ ] , int n ) { BitArray ba = BitArray ( 320000 ) ; for ( int i = 0 ; i < n ; i ++ ) { int num = arr [ i ] ; if ( ba . get ( num ) ) cout << num << " ▁ " ; else ba . set ( num ) ; } } } ; int main ( ) { int arr [ ] = { 1 , 5 , 1 , 10 , 12 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; BitArray obj = BitArray ( ) ; obj . checkDuplicates ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; } int main ( ) { int x = 10 ; cout << countValues ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructXOR ( int A [ ] , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; } int main ( ) { int A [ ] = { 2 , 4 , 1 , 3 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; constructXOR ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << A [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int bitCount ( int n ) { int count = 0 ; while ( n ) { if ( n & 1 ) ++ count ; n >>= 1 ; } return count ; } long long countPairsWithKDiff ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int xoredNum = arr [ i ] ^ arr [ j ] ; if ( k == bitCount ( xoredNum ) ) ++ ans ; } } return ans ; } int main ( ) { int k = 2 ; int arr [ ] = { 2 , 4 , 1 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Total ▁ pairs ▁ for ▁ k ▁ = ▁ " << k << " ▁ are ▁ " << countPairsWithKDiff ( arr , n , k ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long kBitDifferencePairs ( int arr [ ] , int n , int k ) { int MAX = * max_element ( arr , arr + n ) ; long long count [ MAX + 1 ] ; memset ( count , 0 , sizeof ( count ) ) ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; long long ans = 0 ; if ( k == 0 ) { for ( int i = 0 ; i <= MAX ; ++ i ) ans += ( count [ i ] * ( count [ i ] - 1 ) ) / 2 ; return ans ; } for ( int i = 0 ; i <= MAX ; ++ i ) { if ( ! count [ i ] ) continue ; for ( int j = i + 1 ; j <= MAX ; ++ j ) { if ( __builtin_popcount ( i ^ j ) == k ) ans += count [ i ] * count [ j ] ; } } return ans ; } int main ( ) { int k = 2 ; int arr [ ] = { 2 , 4 , 1 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Total ▁ pairs ▁ for ▁ k ▁ = ▁ " << k << " ▁ are ▁ = ▁ " << kBitDifferencePairs ( arr , n , k ) << " STRNEWLINE " ; k = 3 ; cout << " Total ▁ pairs ▁ for ▁ k ▁ = ▁ " << k << " ▁ are ▁ = ▁ " << kBitDifferencePairs ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTrailingZero ( int x ) { int count = 0 ; while ( ( x & 1 ) == 0 ) { x = x >> 1 ; count ++ ; } return count ; } int main ( ) { cout << countTrailingZero ( 11 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTrailingZero ( int x ) { static const int lookup [ ] = { 32 , 0 , 1 , 26 , 2 , 23 , 27 , 0 , 3 , 16 , 24 , 30 , 28 , 11 , 0 , 13 , 4 , 7 , 17 , 0 , 25 , 22 , 31 , 15 , 29 , 10 , 12 , 6 , 0 , 21 , 14 , 9 , 5 , 20 , 8 , 19 , 18 } ; return lookup [ ( - x & x ) % 37 ] ; } int main ( ) { cout << countTrailingZero ( 48 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m /= 2 ; } return ans ; } int main ( ) { int n = 20 , m = 13 ; cout << multiply ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool EqualNumber ( int A , int B ) { return ( A ^ B ) ; } int main ( ) { int A = 5 , B = 6 ; cout << ! EqualNumber ( A , B ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areSetBitsIncreasing ( int n ) { int prev_count = INT_MAX ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; } int main ( ) { int n = 10 ; if ( areSetBitsIncreasing ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; } int main ( ) { int n = 10 ; if ( findPattern ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int ll ; int msbPos ( ll n ) { int msb_p = -1 ; while ( n ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; } ll andOperator ( ll x , ll y ) { while ( x && y ) { int msb_p1 = msbPos ( x ) ; int msb_p2 = msbPos ( y ) ; if ( msb_p1 != msb_p2 ) break ; ll msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ; x = x - msb_val ; y = y - msb_val ; } return res ; } int main ( ) { ll x = 10 , y = 15 ; cout << andOperator ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; } int main ( ) { int n = 50 ; cout << multiplyTen ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countValues ( int n ) { int unset_bits = 0 ; while ( n ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; } int main ( ) { int n = 12 ; cout << countValues ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char findProffesion ( int level , int pos ) { if ( level == 1 ) return ' e ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' d ' ) return ( pos % 2 ) ? ' d ' : ' e ' ; return ( pos % 2 ) ? ' e ' : ' d ' ; } int main ( void ) { int level = 4 , pos = 2 ; ( findProffesion ( level , pos ) == ' e ' ) ? cout << " Engineer " : cout << " Doctor " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { cout << ( 1 << x ) + ( 1 << y ) << " ▁ " ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } } int main ( ) { printTwoSetBitNums ( 4 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int rand50 ( ) { return rand ( ) & 1 ; } bool rand75 ( ) { return rand50 ( ) | rand50 ( ) ; } int main ( ) { srand ( time ( NULL ) ) ; for ( int i = 0 ; i < 50 ; i ++ ) cout << rand75 ( ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printRepeatingEven ( int arr [ ] , int n ) { long long _xor = 0L ; long long pos ; for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; _xor ^= pos ; } for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; if ( ! ( pos & _xor ) ) { cout << arr [ i ] << " ▁ " ; _xor ^= pos ; } } } int main ( ) { int arr [ ] = { 9 , 12 , 23 , 10 , 12 , 12 , 15 , 23 , 14 , 12 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeatingEven ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int x ) { unsigned int count = 0 ; while ( x ) { x &= ( x - 1 ) ; count ++ ; } return count ; } bool isBleak ( int n ) { for ( int x = 1 ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; } int main ( ) { isBleak ( 3 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isBleak ( 4 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int main ( ) { cout << __builtin_popcount ( 4 ) << endl ; cout << __builtin_popcount ( 15 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INT_BITS  32 NEW_LINE int maxSubarrayXOR ( int set [ ] , int n ) { int index = 0 ; for ( int i = INT_BITS - 1 ; i >= 0 ; i -- ) { int maxInd = index ; int maxEle = INT_MIN ; for ( int j = index ; j < n ; j ++ ) { if ( ( set [ j ] & ( 1 << i ) ) != 0 && set [ j ] > maxEle ) maxEle = set [ j ] , maxInd = j ; } if ( maxEle == INT_MIN ) continue ; swap ( set [ index ] , set [ maxInd ] ) ; maxInd = index ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != maxInd && ( set [ j ] & ( 1 << i ) ) != 0 ) set [ j ] = set [ j ] ^ set [ maxInd ] ; } index ++ ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= set [ i ] ; return res ; } int main ( ) { int set [ ] = { 9 , 8 , 5 } ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; cout << " Max ▁ subset ▁ XOR ▁ is ▁ " ; cout << maxSubarrayXOR ( set , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findXOR ( int Set [ ] , int n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; } int main ( ) { int Set [ ] = { 1 , 2 , 3 } ; int n = sizeof ( Set ) / sizeof ( Set [ 0 ] ) ; cout << " XOR ▁ of ▁ XOR ' s ▁ of ▁ all ▁ subsets ▁ is ▁ " << findXOR ( Set , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int myXOR ( int x , int y ) { for ( int i = 31 ; i >= 0 ; i -- ) { bool b1 = x & ( 1 << i ) ; bool b2 = y & ( 1 << i ) ; bool xoredBit = ( b1 & b2 ) ? 0 : ( b1 b2 ) ; res <<= 1 ; res |= xoredBit ; } return res ; } int main ( ) { int x = 3 , y = 5 ; cout << " XOR ▁ is ▁ " << myXOR ( x , y ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; } int main ( ) { int x = 3 , y = 5 ; cout << " XOR ▁ is ▁ " << myXOR ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int swapBits ( unsigned int n , unsigned int p1 , unsigned int p2 ) { unsigned int bit1 = ( n >> p1 ) & 1 ; unsigned int bit2 = ( n >> p2 ) & 1 ; unsigned int x = ( bit1 ^ bit2 ) ; x = ( x << p1 ) | ( x << p2 ) ; unsigned int result = n ^ x ; } int main ( ) { int res = swapBits ( 28 , 0 , 3 ) ; cout << " Result ▁ = ▁ " << res << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int square ( int n ) { if ( n < 0 ) n = - n ; int res = n ; for ( int i = 1 ; i < n ; i ++ ) res += n ; return res ; } int main ( ) { for ( int n = 1 ; n <= 5 ; n ++ ) cout << " n ▁ = ▁ " << n << " , ▁ n ^ 2 ▁ = ▁ " << square ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  2 NEW_LINE int freivald ( int a [ ] [ N ] , int b [ ] [ N ] , int c [ ] [ N ] ) { bool r [ N ] ; for ( int i = 0 ; i < N ; i ++ ) r [ i ] = random ( ) % 2 ; int br [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) br [ i ] = br [ i ] + b [ i ] [ j ] * r [ j ] ; int cr [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) cr [ i ] = cr [ i ] + c [ i ] [ j ] * r [ j ] ; int axbr [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) axbr [ i ] = axbr [ i ] + a [ i ] [ j ] * br [ j ] ; for ( int i = 0 ; i < N ; i ++ ) if ( axbr [ i ] - cr [ i ] != 0 ) false ; return true ; } bool isProduct ( int a [ ] [ N ] , int b [ ] [ N ] , int c [ ] [ N ] , int k ) { for ( int i = 0 ; i < k ; i ++ ) if ( freivald ( a , b , c ) == false ) return false ; return true ; } int main ( ) { int a [ N ] [ N ] = { { 1 , 1 } , { 1 , 1 } } ; int b [ N ] [ N ] = { { 1 , 1 } , { 1 , 1 } } ; int c [ N ] [ N ] = { { 2 , 2 } , { 2 , 2 } } ; int k = 2 ; if ( isProduct ( a , b , c , k ) ) printf ( " Yes " ) ; else printf ( " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float calc_Expectation ( float a [ ] , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; } int main ( ) { float expect , n = 6.0 ; float a [ 6 ] = { 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 } ; expect = calc_Expectation ( a , n ) ; cout << " Expectation ▁ of ▁ array ▁ E ( X ) ▁ is ▁ : ▁ " << expect << " STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int SumGPUtil ( long long int r , long long int n , long long int m ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return ( 1 + r ) % m ; long long int ans ; if ( n % 2 == 1 ) { ans = ( 1 + r ) * SumGPUtil ( ( r * r ) % m , ( n - 1 ) / 2 , m ) ; } else { ans = 1 + ( r * ( 1 + r ) * SumGPUtil ( ( r * r ) % m , ( n / 2 ) - 1 , m ) ) ; } return ( ans % m ) ; } void SumGP ( long long int a , long long int r , long long int N , long long int M ) { long long int answer ; answer = a * SumGPUtil ( r , N , M ) ; answer = answer % M ; cout << answer << endl ; } int main ( ) { long long int a = 1 ; long long int r = 4 ; long long int N = 10000 ; long long int M = 100000 ; SumGP ( a , r , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LongestSubarray ( int a [ ] , int n , int k ) { int pre [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > k ) pre [ i ] = 1 ; else pre [ i ] = -1 ; } for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = pre [ i - 1 ] + pre [ i ] ; int len = 0 ; int lo = 1 , hi = n ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; bool ok = false ; for ( int i = mid - 1 ; i < n ; i ++ ) { int x = pre [ i ] ; if ( i - mid >= 0 ) x -= pre [ i - mid ] ; if ( x > 0 ) { ok = true ; break ; } } if ( ok == true ) { len = mid ; lo = mid + 1 ; } else hi = mid - 1 ; } return len ; } int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 3 , 7 } ; int k = 3 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << LongestSubarray ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? min ( l1 , l2 ) : -1 ; int y = ( r1 != r2 ) ? max ( r1 , r2 ) : -1 ; cout << x << " ▁ " << y ; } int main ( ) { int l1 = 5 , r1 = 10 , l2 = 1 , r2 = 7 ; findPoints ( l1 , r1 , l2 , r2 ) ; }
#include <iostream> NEW_LINE using namespace std ; unsigned int fact ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } int main ( ) { cout << fact ( 5 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySeach ( vector < int > P , int N ) { int i = 0 ; int j = P . size ( ) - 1 ; int index = -1 ; while ( i <= j ) { int mid = i + ( j - i ) / 2 ; if ( P [ mid ] >= N ) { index = mid ; j = mid - 1 ; } else { i = mid + 1 ; } } return index ; } void minDays ( vector < int > P , vector < int > arr ) { for ( int i = 1 ; i < P . size ( ) ; i ++ ) { P [ i ] += P [ i ] + P [ i - 1 ] ; } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int index = binarySeach ( P , arr [ i ] ) ; if ( index != -1 ) { cout << index + 1 << " ▁ " ; } else { cout << -1 << " ▁ " ; } } } int main ( ) { vector < int > arr = { 400 , 200 , 700 , 900 , 1400 } ; vector < int > P = { 100 , 300 , 400 , 500 , 600 } ; minDays ( P , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; static int search ( vector < int > list , int num ) { int low = 0 , high = list . size ( ) - 1 ; int ans = -1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( list [ mid ] <= num ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } bool isPalindrome ( int n ) { int rev = 0 ; int temp = n ; while ( n > 0 ) { rev = rev * 10 + n % 10 ; n /= 10 ; } return rev == temp ; } int countNumbers ( int L , int R , int K ) { vector < int > list ; for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) ) { list . push_back ( i ) ; } } int count = 0 ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) { int right_index = search ( list , list [ i ] + K - 1 ) ; if ( right_index != -1 ) count = max ( count , right_index - i + 1 ) ; } return count ; } int main ( ) { int L = 98 , R = 112 ; int K = 13 ; cout << countNumbers ( L , R , K ) ; }
#include <iostream> NEW_LINE #include <climits> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; int maximumProfit ( int arr [ ] , int N ) { int ans = INT_MIN ; int price = 0 ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i ++ ) { int count = ( N - i ) ; if ( ans < count * arr [ i ] ) { price = arr [ i ] ; ans = count * arr [ i ] ; } } return price ; } int main ( ) { int arr [ ] = { 22 , 87 , 9 , 50 , 56 , 43 } ; cout << maximumProfit ( arr , 6 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mulsum ( int arr [ ] , int n , int N ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % N == 0 ) { sum = sum + arr [ i ] ; } } cout << sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int N = 3 ; mulsum ( arr , n , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char nextAvailableChar ( vector < int > charset , int start ) { for ( int i = start - 1 ; i >= 0 ; i -- ) { if ( charset [ i ] > 0 ) { charset [ i ] -- ; return char ( i + ' a ' ) ; } } return ' \0' ; } string newString ( string originalLabel , int limit ) { int n = originalLabel . length ( ) ; vector < int > charset ( 26 , 0 ) ; string newStrings = " " ; for ( char i : originalLabel ) charset [ i - ' a ' ] ++ ; for ( int i = 25 ; i >= 0 ; i -- ) { int count = 0 ; while ( charset [ i ] > 0 ) { newStrings += char ( i + ' a ' ) ; charset [ i ] -- ; count ++ ; if ( charset [ i ] > 0 && count == limit ) { char next = nextAvailableChar ( charset , i ) ; if ( next == ' \0' ) return newStrings ; newStrings += next ; count = 0 ; } } } return newStrings ; } int main ( ) { string S = " ccbbb " ; int K = 2 ; cout << ( newString ( S , K ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  4 NEW_LINE void swapEvenOdd ( int arr [ ] , int n ) { int o = -1 , e = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) continue ; int r = -1 ; if ( arr [ i ] % 2 == 0 ) { o ++ ; while ( arr [ o ] % 2 == 0 arr [ o ] < 0 ) o ++ ; r = o ; } else { e ++ ; while ( arr [ e ] % 2 == 1 arr [ e ] < 0 ) e ++ ; r = e ; } arr [ i ] *= -1 ; arr [ r ] *= -1 ; int tmp = arr [ i ] ; arr [ i ] = arr [ r ] ; arr [ r ] = tmp ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ( -1 * arr [ i ] ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; swapEvenOdd ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string rev ( string str ) { int st = 0 ; int ed = str . length ( ) - 1 ; string s = str ; while ( st < ed ) { swap ( s [ st ] , s [ ed ] ) ; st ++ ; ed -- ; } return s ; } bool check ( string a , string b , int n ) { int i = 0 ; int j = n - 1 ; while ( i < n ) { if ( a [ i ] != b [ j ] ) break ; i += 1 ; j -= 1 ; string xa = a . substr ( i , j + 1 - i ) ; string xb = b . substr ( i , j + 1 - i ) ; if ( ( xa == rev ( xa ) ) or ( xb == rev ( xb ) ) ) return true ; } return false ; } int main ( ) { string a = " xbdef " ; string b = " cabex " ; if ( check ( a , b , a . length ( ) ) == true or check ( b , a , a . length ( ) ) == true ) cout << " True " ; else cout << " False " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( vector < int > pSum , int len , int k , vector < int > a ) { int i = 0 ; int j = len ; while ( j <= a . size ( ) ) { int maxSize = a [ j - 1 ] ; int totalNumbers = maxSize * len ; int currNumbers = pSum [ j ] - pSum [ i ] ; if ( currNumbers + k >= totalNumbers ) { return true ; } else { i ++ ; j ++ ; } } return false ; } int maxEqualIdx ( vector < int > arr , int k ) { sort ( arr . begin ( ) , arr . end ( ) ) ; vector < int > prefixSum ( arr . size ( ) ) ; prefixSum [ 1 ] = arr [ 0 ] ; for ( int i = 1 ; i < prefixSum . size ( ) - 1 ; ++ i ) { prefixSum [ i + 1 ] = prefixSum [ i ] + arr [ i ] ; } int max = arr . size ( ) ; int min = 1 ; int ans = 1 ; while ( min <= max ) { int mid = ( max + min ) / 2 ; if ( check ( prefixSum , mid , k , arr ) ) { ans = mid ; min = mid + 1 ; } else { max = mid - 1 ; } } return ans ; } int main ( ) { vector < int > arr = { 1 , 1 , 1 } ; int k = 7 ; cout << ( maxEqualIdx ( arr , k ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int productSum ( int arr [ ] , int N ) { int cntOne = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 1 ) cntOne ++ ; } return cntOne * ( cntOne - 1 ) / 2 ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << productSum ( arr , n ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dfs ( vector < vector < int > > memo , int nums [ ] , int S , int curr_sum , int index , int sum , int N ) { if ( index == N ) { if ( S == curr_sum ) return 1 ; else return 0 ; } if ( memo [ index ] [ curr_sum + sum ] != INT_MIN ) { return memo [ index ] [ curr_sum + sum ] ; } int ans = dfs ( memo , nums , index + 1 , curr_sum + nums [ index ] , S , sum , N ) + dfs ( memo , nums , index + 1 , curr_sum - nums [ index ] , S , sum , N ) ; memo [ index ] [ curr_sum + sum ] = ans ; return ans ; } int findWays ( int nums [ ] , int S , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += nums [ i ] ; vector < vector < int > > memo ( N + 1 , vector < int > ( 2 * sum + 1 , INT_MIN ) ) ; return dfs ( memo , nums , S , 0 , 0 , sum , N ) ; } int main ( ) { int S = 3 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int answer = findWays ( arr , S , N ) ; cout << answer << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findPrevious ( vector < int > a , int n ) { vector < int > ps ( n ) ; ps [ 0 ] = -1 ; stack < int > Stack ; Stack . push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ps [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : -1 ; Stack . push ( i ) ; } return ps ; } vector < int > findNext ( vector < int > a , int n ) { vector < int > ns ( n ) ; ns [ n - 1 ] = n ; stack < int > Stack ; Stack . push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( Stack . size ( ) > 0 && a [ Stack . top ( ) ] >= a [ i ] ) Stack . pop ( ) ; ns [ i ] = Stack . size ( ) > 0 ? Stack . top ( ) : n ; Stack . push ( i ) ; } return ns ; } int findMaximumSum ( vector < int > a , int n ) { vector < int > prev_smaller = findPrevious ( a , n ) ; vector < int > next_smaller = findNext ( a , n ) ; int max_value = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_value = max ( max_value , a [ i ] * ( next_smaller [ i ] - prev_smaller [ i ] - 1 ) ) ; } return max_value ; } int main ( ) { int n = 3 ; vector < int > a { 80 , 48 , 82 } ; cout << findMaximumSum ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; void max_length ( int N , int x , vector < int > & v ) { int i , a ; vector < int > preff , suff ; int ct = 0 ; for ( i = 0 ; i < N ; i ++ ) { a = v [ i ] ; if ( a % x == 0 ) { ct += 1 ; } } if ( ct == N ) { cout << -1 << endl ; return ; } reverse ( v . begin ( ) , v . end ( ) ) ; suff . push_back ( v [ 0 ] ) ; for ( i = 1 ; i < N ; i ++ ) { suff . push_back ( v [ i ] + suff [ i - 1 ] ) ; } reverse ( v . begin ( ) , v . end ( ) ) ; reverse ( suff . begin ( ) , suff . end ( ) ) ; preff . push_back ( v [ 0 ] ) ; for ( i = 1 ; i < N ; i ++ ) { preff . push_back ( v [ i ] + preff [ i - 1 ] ) ; } int ans = 0 ; int lp = 0 ; int rp = N - 1 ; for ( i = 0 ; i < N ; i ++ ) { if ( suff [ i ] % x != 0 && ( ans < ( N - 1 ) ) ) { lp = i ; rp = N - 1 ; ans = max ( ans , N - i ) ; } if ( preff [ i ] % x != 0 && ( ans < ( i + 1 ) ) ) { lp = 0 ; rp = i ; ans = max ( ans , i + 1 ) ; } } for ( i = lp ; i <= rp ; i ++ ) { cout << v [ i ] << " ▁ " ; } } int main ( ) { int x = 3 ; vector < int > v = { D2 : V21 , 3 , 2 , 6 } ; int N = v . size ( ) ; max_length ( N , x , v ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxUpdated ( vector < int > arr ) { int h_score = arr [ 0 ] ; int l_score = arr [ 0 ] ; int i = 1 , j = 1 ; for ( auto n : arr ) { if ( h_score < n ) { h_score = n ; i ++ ; } if ( l_score > n ) { l_score = n ; j ++ ; } } cout << " Number ▁ of ▁ times ▁ maximum ▁ value ▁ " ; cout << " updated ▁ = ▁ " << i << endl ; cout << " Number ▁ of ▁ times ▁ minimum ▁ value ▁ " ; cout << " updated ▁ = ▁ " << j << endl ; } int main ( ) { vector < int > arr ( { 10 , 5 , 20 , 22 } ) ; maxUpdated ( arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void farthest_min ( int a [ ] , int n ) { int suffix_min [ n ] ; suffix_min [ n - 1 ] = a [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffix_min [ i ] = min ( suffix_min [ i + 1 ] , a [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) { int low = i + 1 , high = n - 1 , ans = -1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( suffix_min [ mid ] < a [ i ] ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } cout << ans << " ▁ " ; } } int main ( ) { int a [ ] = { 3 , 1 , 5 , 2 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; farthest_min ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printElements ( int a [ ] , int n ) { sort ( a , a + n , greater < int > ( ) ) ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] != a [ i + 1 ] ) { cout << a [ i ] << " ▁ occurs ▁ " << cnt << " ▁ times STRNEWLINE " ; cnt = 1 ; } else cnt += 1 ; } cout << a [ n - 1 ] << " ▁ occurs ▁ " << cnt << " ▁ times STRNEWLINE " ; } int main ( ) { int a [ ] = { 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printElements ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIndices ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; } int main ( ) { int Arr [ ] = { 3 , 2 , 1 , 1 , 4 } ; int N = sizeof ( Arr ) / sizeof ( Arr [ 0 ] ) ; checkIndices ( Arr , N ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE #include <unordered_map> NEW_LINE #include <vector> NEW_LINE using namespace std ; typedef pair < int , int > Pair ; void findPairs ( int arr [ ] , int n ) { unordered_map < int , vector < Pair > > map ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( map . find ( sum ) != map . end ( ) ) { for ( auto pair : map . find ( sum ) -> second ) { int m = pair . first , n = pair . second ; if ( ( m != i && m != j ) && ( n != i && n != j ) ) { cout << " Pair ▁ First ( " << arr [ i ] << " , ▁ " << arr [ j ] << " Pair Second ( " ▁ < < ▁ arr [ m ] ▁ < < ▁ " , " ▁ < < ▁ arr [ n ] ▁ < < ▁ " ) " return ; } } } map [ sum ] . push_back ( { i , j } ) ; } } cout << " No ▁ such ▁ non - overlapping ▁ pairs ▁ present " ; } int main ( ) { int arr [ ] = { 8 , 4 , 7 , 8 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPairs ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printPairs ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << endl ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 , -1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; printPairs ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTripletsLessThanL ( int n , int L , int * arr ) { sort ( arr , arr + n ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int indexGreater = upper_bound ( arr , arr + n , arr [ i ] + L ) - arr ; int numberOfElements = indexGreater - ( i + 1 ) ; if ( numberOfElements >= 2 ) { ways += ( numberOfElements * ( numberOfElements - 1 ) / 2 ) ; } } return ways ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 4 ; int ans = countTripletsLessThanL ( n , L , arr ) ; cout << " Total ▁ Number ▁ of ▁ ways ▁ = ▁ " << ans << " STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE #include <ctime> NEW_LINE using namespace std ; int getRandom ( int x , int y ) { srand ( time ( NULL ) ) ; return ( x + rand ( ) % ( y - x + 1 ) ) ; } int randomizedBinarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = getRandom ( l , r ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return randomizedBinarySearch ( arr , l , mid - 1 , x ) ; return randomizedBinarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = randomizedBinarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) : printf ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " , result ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string remVowel ( string str ) { vector < char > vowels = { ' a ' , ' e ' , ' i ' , ' o ' , ' u ' , ' A ' , ' E ' , ' I ' , ' O ' , ' U ' } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( find ( vowels . begin ( ) , vowels . end ( ) , str [ i ] ) != vowels . end ( ) ) { str = str . replace ( i , 1 , " " ) ; i -= 1 ; } } return str ; } int main ( ) { string str = " GeeeksforGeeks ▁ - ▁ A ▁ Computer " " ▁ Science ▁ Portal ▁ for ▁ Geeks " ; cout << remVowel ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCostToMakeElementEqual ( int a [ ] , int n ) { int y ; if ( n % 2 == 1 ) y = a [ n / 2 ] ; else y = ( a [ n / 2 ] + a [ ( n - 2 ) / 2 ] ) / 2 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) s += abs ( a [ i ] - y ) ; return s ; } int main ( ) { int a [ ] = { 1 , 100 , 101 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << ( minCostToMakeElementEqual ( a , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSorted ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) return false ; } return true ; } bool sortPoss ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int idx = -1 ; int minVar = arr [ i ] ; int j = i ; while ( j < n ) { if ( arr [ j ] < minVar ) { minVar = arr [ j ] ; idx = j ; } j = j + 2 ; } if ( idx != -1 ) { swap ( arr [ i ] , arr [ idx ] ) ; } } if ( isSorted ( arr , n ) ) return true ; else return false ; } int main ( ) { int arr [ ] = { 3 , 5 , 1 , 2 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( sortPoss ( arr , n ) ) cout << " True " ; else cout << " False " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; long maxSum ( int a [ ] , int n ) { int count [ n + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ min ( a [ i ] , n ) ] ++ ; int size = 0 ; long ans = 0 ; for ( int k = 1 ; k <= n ; k ++ ) { while ( count [ k ] > 0 && size < k ) { size ++ ; ans += size ; count [ k ] -- ; } ans += k * count [ k ] ; } return ans ; } int main ( ) { int arr [ ] = { 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( maxSum ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void answerQueries ( int arr [ ] , int n , vector < pair < int , int > > & queries ) { for ( int i = 0 ; i < queries . size ( ) ; i ++ ) { int ans = 0 ; int l = queries [ i ] . first - 1 ; int r = queries [ i ] . second - 1 ; map < int , int > freq ; for ( int j = l ; j <= r ; j ++ ) { freq [ arr [ j ] ] ++ ; } for ( auto & i : freq ) { ans += ( i . first * i . second ) ; } cout << ans << endl ; } } int main ( ) { int arr [ ] = { 1 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; vector < pair < int , int > > queries = { { 1 , 2 } , { 1 , 3 } } ; answerQueries ( arr , n , queries ) ; }
#include <iostream> NEW_LINE #include <cstring> NEW_LINE #define MAX  256 NEW_LINE using namespace std ; bool compare ( char arr1 [ ] , char arr2 [ ] ) { for ( int i = 0 ; i < MAX ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } bool search ( char * pat , char * txt ) { int M = strlen ( pat ) , N = strlen ( txt ) ; char countP [ MAX ] = { 0 } , countTW [ MAX ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { ( countP [ pat [ i ] ] ) ++ ; ( countTW [ txt [ i ] ] ) ++ ; } for ( int i = M ; i < N ; i ++ ) { if ( compare ( countP , countTW ) ) return true ; ( countTW [ txt [ i ] ] ) ++ ; countTW [ txt [ i - M ] ] -- ; } if ( compare ( countP , countTW ) ) return true ; return false ; } int main ( ) { char txt [ ] = " BACDGABCDA " ; char pat [ ] = " ABCD " ; if ( search ( pat , txt ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int PointInKSquares ( int n , int a [ ] , int k ) { sort ( a , a + n ) ; return a [ n - k ] ; } int main ( ) { int k = 2 ; int a [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int x = PointInKSquares ( n , a , k ) ; cout << " ( " << x << " , ▁ " << x << " ) " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPandigital ( string str ) { if ( str . length ( ) != 9 ) return false ; char ch [ str . length ( ) ] ; strcpy ( ch , str . c_str ( ) ) ; sort ( ch , ch + str . length ( ) ) ; string s = ch ; if ( s . compare ( "123456789" ) == 0 ) return true ; else return true ; } bool PandigitalProduct_1_9 ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 && isPandigital ( to_string ( n ) + to_string ( i ) + to_string ( n / i ) ) ) return true ; return false ; } int main ( ) { int n = 6952 ; if ( PandigitalProduct_1_9 ( n ) == true ) cout << " yes " ; else cout << " no " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printModeMedian ( int a [ ] , int n ) { int b [ n ] ; int max = * max_element ( a , a + n ) ; int t = max + 1 ; int count [ t ] ; for ( int i = 0 ; i < t ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int mode = 0 ; int k = count [ 0 ] ; for ( int i = 1 ; i < t ; i ++ ) { if ( count [ i ] > k ) { k = count [ i ] ; mode = i ; } } for ( int i = 1 ; i < t ; i ++ ) count [ i ] = count [ i ] + count [ i - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ count [ a [ i ] ] - 1 ] = a [ i ] ; count [ a [ i ] ] -- ; } float median ; if ( n % 2 != 0 ) median = b [ n / 2 ] ; else median = ( b [ ( n - 1 ) / 2 ] + b [ ( n / 2 ) ] ) / 2.0 ; cout << " median ▁ = ▁ " << median << endl ; cout << " mode ▁ = ▁ " << mode ; } int main ( ) { int a [ ] = { 1 , 4 , 1 , 2 , 7 , 1 , 2 , 5 , 3 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printModeMedian ( a , n ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; # define MAX  26 NEW_LINE bool function ( string str ) { int l = str . length ( ) ; int counter1 [ MAX ] ; int counter2 [ MAX ] ; memset ( counter1 , 0 , sizeof ( counter1 ) ) ; memset ( counter2 , 0 , sizeof ( counter2 ) ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) counter1 [ str [ i ] - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter2 [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX ; i ++ ) if ( counter2 [ i ] != counter1 [ i ] ) return true ; return false ; } int main ( ) { string str = " abcasdsabcae " ; if ( function ( str ) ) cout << " Yes , ▁ both ▁ halves ▁ differ " << " ▁ by ▁ at ▁ least ▁ one ▁ character " ; else cout << " No , ▁ both ▁ halves ▁ do ▁ " << " not ▁ differ ▁ at ▁ all " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct element { int index , no_of_fact ; } ; int countFactors ( int n ) { int count = 0 ; int sq = sqrt ( n ) ; if ( sq * sq == n ) count ++ ; for ( int i = 1 ; i < sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) count += 2 ; } return count ; } bool compare ( struct element e1 , struct element e2 ) { if ( e1 . no_of_fact == e2 . no_of_fact ) return e1 . index < e2 . index ; return e1 . no_of_fact > e2 . no_of_fact ; } void printOnBasisOfFactors ( int arr [ ] , int n ) { struct element num [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { num [ i ] . index = i ; num [ i ] . no_of_fact = countFactors ( arr [ i ] ) ; } sort ( num , num + n , compare ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ num [ i ] . index ] << " ▁ " ; } int main ( ) { int arr [ ] = { 5 , 11 , 10 , 20 , 9 , 16 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printOnBasisOfFactors ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int res = INT_MAX ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = min ( res , curSeqDiff ) ; } return res ; } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 100 , 101 , 102 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << minDifferenceAmongMaxMin ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getIndexInSortedArray ( int arr [ ] , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; } int main ( ) { int arr [ ] = { 3 , 4 , 3 , 5 , 2 , 3 , 4 , 3 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int idxOfEle = 5 ; cout << getIndexInSortedArray ( arr , n , idxOfEle ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int binarySearch ( int a [ ] , int item , int low , int high ) { while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( item == a [ mid ] ) return mid + 1 ; else if ( item > a [ mid ] ) low = mid + 1 ; else high = mid - 1 ; } return low ; } void insertionSort ( int a [ ] , int n ) { int i , loc , j , k , selected ; for ( i = 1 ; i < n ; ++ i ) { j = i - 1 ; selected = a [ i ] ; loc = binarySearch ( a , selected , 0 , j ) ; while ( j >= loc ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = selected ; } } int main ( ) { int a [ ] = { 37 , 23 , 0 , 17 , 12 , 72 , 31 , 46 , 100 , 88 , 54 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) , i ; insertionSort ( a , n ) ; cout << " Sorted ▁ array : ▁ STRNEWLINE " ; for ( i = 0 ; i < n ; i ++ ) cout << " ▁ " << a [ i ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool possible ( int x , int S , int N ) { int minSum = ( x * ( x + 1 ) ) / 2 ; int maxSum = ( x * ( ( 2 * N ) - x + 1 ) ) / 2 ; if ( S < minSum S > maxSum ) { return false ; } return true ; } void findPermutation ( int N , int L , int R , int S ) { int x = R - L + 1 ; if ( ! possible ( x , S , N ) ) { cout << -1 ; return ; } else { vector < int > v ; for ( int i = N ; i >= 1 ; -- i ) { if ( ( S - i ) >= 0 && possible ( x - 1 , S - i , i - 1 ) ) { S = S - i ; x -- ; v . push_back ( i ) ; } if ( S == 0 ) { break ; } } if ( S != 0 ) { cout << -1 ; return ; } vector < int > v1 ; for ( int i = 1 ; i <= N ; ++ i ) { vector < int > :: iterator it = find ( v . begin ( ) , v . end ( ) , i ) ; if ( it == v . end ( ) ) { v1 . push_back ( i ) ; } } int j = 0 , f = 0 ; for ( int i = 1 ; i < L ; ++ i ) { cout << v1 [ j ] << " ▁ " ; j ++ ; } for ( int i = L ; i <= R ; ++ i ) { cout << v [ f ] << " ▁ " ; f ++ ; } for ( int i = R + 1 ; i <= N ; ++ i ) { cout << v1 [ j ] << " ▁ " ; j ++ ; } } return ; } int main ( ) { int N = 6 , L = 3 , R = 5 , S = 8 ; findPermutation ( N , L , R , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void skipIndices ( int N , int T , int arr [ ] ) { int sum = 0 ; map < int , int > count ; for ( int i = 0 ; i < N ; i ++ ) { int d = sum + arr [ i ] - T ; int k = 0 ; if ( d > 0 ) { for ( auto u = count . rbegin ( ) ; u != count . rend ( ) ; u ++ ) { int j = u -> first ; int x = j * count [ j ] ; if ( d <= x ) { k += ( d + j - 1 ) / j ; break ; } k += count [ j ] ; d -= x ; } } sum += arr [ i ] ; count [ arr [ i ] ] ++ ; cout << k << " ▁ " ; } } int main ( ) { int N = 7 ; int T = 15 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; skipIndices ( N , T , arr ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int countTriplets ( int N , int K ) { if ( K % 2 == 0 ) { long long int x = N / K ; long long int y = ( N + ( K / 2 ) ) / K ; return x * x * x + y * y * y ; } else { long long int x = N / K ; return x * x * x ; } } int main ( ) { int N = 2 , K = 2 ; cout << countTriplets ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void subsetSum ( vector < int > & c , int & ans ) { int L = c . size ( ) ; int mul = ( int ) pow ( 2 , L - 1 ) ; for ( int i = 0 ; i < c . size ( ) ; i ++ ) ans += c [ i ] * mul ; } void subsetGen ( int * arr , int i , int n , int & ans , vector < int > & c ) { if ( i == n ) { subsetSum ( c , ans ) ; return ; } subsetGen ( arr , i + 1 , n , ans , c ) ; c . push_back ( arr [ i ] ) ; subsetGen ( arr , i + 1 , n , ans , c ) ; c . pop_back ( ) ; } int main ( ) { int arr [ ] = { 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int ans = 0 ; vector < int > c ; subsetGen ( arr , 0 , n , ans , c ) ; cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMaxValue ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { return 0 ; } first = second = INT_MIN ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MIN ) return 0 ; else return second ; } int main ( ) { int arr [ ] = { 4 , 5 , 1 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMaxValue ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = max ( a , max ( b , c ) ) ; int smallest = min ( a , min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } } int main ( ) { int a = -2 , b = -1 , c = -4 ; cout << maximumResult ( a , b , c ) ; return 0 ; }
#include <iostream> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; int check ( int n , int marks [ ] ) { int * x = std :: max_element ( marks , marks + 5 ) ; int bonus = 100 - ( int ) ( * x ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; } int main ( ) { int n = 5 ; int marks [ ] = { 0 , 21 , 83 , 45 , 64 } ; cout << check ( n , marks ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  10000 NEW_LINE using namespace std ; int hashTable [ MAX ] ; int minOperations ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) hashTable [ arr [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] ) { for ( int j = i ; j < n ; j ++ ) if ( arr [ j ] % arr [ i ] == 0 ) hashTable [ arr [ j ] ] = 0 ; res ++ ; } } return res ; } int main ( ) { int arr [ ] = { 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Process { } ; void findWaitingTime ( Process proc [ ] , int n , int wt [ ] ) { int rt [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rt [ i ] = proc [ i ] . bt ; int complete = 0 , t = 0 , minm = INT_MAX ; int shortest = 0 , finish_time ; bool check = false ; while ( complete != n ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( proc [ j ] . art <= t ) && ( rt [ j ] < minm ) && rt [ j ] > 0 ) { minm = rt [ j ] ; shortest = j ; check = true ; } } if ( check == false ) { t ++ ; continue ; } rt [ shortest ] -- ; minm = rt [ shortest ] ; if ( minm == 0 ) minm = INT_MAX ; if ( rt [ shortest ] == 0 ) { complete ++ ; check = false ; finish_time = t + 1 ; wt [ shortest ] = finish_time - proc [ shortest ] . bt - proc [ shortest ] . art ; if ( wt [ shortest ] < 0 ) wt [ shortest ] = 0 ; } t ++ ; } } void findTurnAroundTime ( Process proc [ ] , int n , int wt [ ] , int tat [ ] ) { for ( int i = 0 ; i < n ; i ++ ) tat [ i ] = proc [ i ] . bt + wt [ i ] ; } void findavgTime ( Process proc [ ] , int n ) { int wt [ n ] , tat [ n ] , total_wt = 0 , total_tat = 0 ; findWaitingTime ( proc , n , wt ) ; findTurnAroundTime ( proc , n , wt , tat ) ; cout << " Processes ▁ " << " ▁ Burst ▁ time ▁ " << " ▁ Waiting ▁ time ▁ " << " ▁ Turn ▁ around ▁ time STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) { total_wt = total_wt + wt [ i ] ; total_tat = total_tat + tat [ i ] ; cout << " ▁ " << proc [ i ] . pid << " TABSYMBOL TABSYMBOL " << proc [ i ] . bt << " TABSYMBOL TABSYMBOL ▁ " << wt [ i ] << " TABSYMBOL TABSYMBOL ▁ " << tat [ i ] << endl ; } cout << " Average waiting time = " << ( float ) total_wt / ( float ) n ; cout << " Average turn around time = " << ( float ) total_tat / ( float ) n ; } int main ( ) { Process proc [ ] = { { 1 , 6 , 1 } , { 2 , 8 , 1 } , { 3 , 7 , 2 } , { 4 , 3 , 3 } } ; int n = sizeof ( proc ) / sizeof ( proc [ 0 ] ) ; findavgTime ( proc , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE int minimumDeletions ( int A [ ] , int N ) { int dp [ N ] [ MAX ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = 1 ; for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( A [ i ] >= A [ j ] ) { int diff = A [ i ] - A [ j ] ; for ( int k = 0 ; k <= diff ; k ++ ) { dp [ i ] = max ( dp [ i ] , dp [ j ] [ k ] + 1 ) ; } } } } int maxSetSize = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) maxSetSize = max ( maxSetSize , dp [ N - 1 ] [ i ] ) ; return N - maxSetSize ; } int main ( ) { int A [ ] = { 1 , 4 , 5 , 7 , 20 , 21 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minimumDeletions ( A , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumberOfStrings ( int N ) { vector < int > counts ( 5 , 1 ) ; for ( int i = 2 ; i <= N ; i ++ ) { for ( int j = 3 ; j >= 0 ; j -- ) counts [ j ] += counts [ j + 1 ] ; } int ans = 0 ; for ( auto c : counts ) ans += c ; return ans ; } int main ( ) { int N = 2 ; cout << findNumberOfStrings ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 1000 + 5 ] [ 9000 + 5 ] ; int mod = 1000000007 ; int check ( int sum , int x , int y ) { while ( sum > 0 ) { int ln = sum % 10 ; if ( ln != x && ln != y ) { return 0 ; } sum /= 10 ; } return 1 ; } int countNumbers ( int n , int x , int y , int sum ) { memset ( dp , -1 , sizeof ( dp ) ) ; if ( n == 0 ) { return check ( sum , x , y ) ; } if ( dp [ n ] [ sum ] != -1 ) { return dp [ n ] [ sum ] % mod ; } int option1 = countNumbers ( n - 1 , x , y , sum + x ) % mod ; int option2 = countNumbers ( n - 1 , x , y , sum + y ) % mod ; return dp [ n ] [ sum ] = ( option1 + option2 ) % mod ; } int main ( ) { int N = 3 , X = 1 , Y = 5 ; cout << countNumbers ( N , X , Y , 0 ) % mod ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int mask , int i ) { int c = ( mask & ( 1 << i ) ) ; return c != 0 ; } int solve ( vector < vector < int > > a , string s , int n , int prev , int mask , vector < vector < int > > dp ) { if ( mask == 0 ) return 0 ; if ( dp [ mask ] [ prev + 1 ] != -1 ) return dp [ mask ] [ prev + 1 ] ; int ans = 10000 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int id = s [ i ] - ' a ' ; if ( check ( mask , id ) ) { if ( prev == -1 ) { ans = min ( ans , solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; } else { ans = min ( ans , a [ prev ] [ id ] + solve ( a , s , n , id , mask ^ ( 1 << id ) , dp ) ) ; } } } dp [ mask ] [ prev + 1 ] = ans ; return ans ; } void generatePermutation ( int mask , int n , vector < vector < int > > a , string s ) { vector < vector < int > > dp ( ( 1 << n ) + 5 , vector < int > ( n + 5 , -1 ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int id = s [ i ] - ' a ' ; mask |= ( 1 << id ) ; } cout << solve ( a , s , n , -1 , mask , dp ) << endl ; } int main ( ) { int N = 5 ; string str = " abcde " ; vector < vector < int > > mat = { { 0 , 5 , 1 , 5 , 3 } , { 4 , 0 , 9 , 4 , 2 } , { 7 , 9 , 0 , 10 , 7 } , { 1 , 2 , 8 , 0 , 2 } , { 3 , 9 , 7 , 7 , 0 } } ; generatePermutation ( 0 , N , mat , str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int inf = 10000000 ; vector < int > preprocess ( vector < int > a , int n ) { vector < int > p ( n ) ; p [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { p [ i ] = p [ i - 1 ] + a [ i ] ; } return p ; } int Combine ( vector < int > p , int i , int j ) { if ( i == 0 ) return p [ j ] ; else return p [ j ] - p [ i - 1 ] ; } int minCost ( vector < int > a , int i , int j , int k , vector < int > prefix , vector < vector < int > > dp ) { if ( i >= j ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; int best_cost = inf ; for ( int pos = i ; pos < j ; pos ++ ) { int left = minCost ( a , i , pos , k , prefix , dp ) ; int right = minCost ( a , pos + 1 , j , k , prefix , dp ) ; best_cost = min ( best_cost , left + right + ( k * Combine ( prefix , i , j ) ) ) ; } return dp [ i ] [ j ] = best_cost ; } int main ( ) { int n = 4 ; vector < int > a = { 4 , 5 , 6 , 7 } ; int k = 3 ; vector < vector < int > > dp ; dp . resize ( n + 1 , vector < int > ( n + 1 ) ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = -1 ; } } vector < int > prefix = preprocess ( a , n ) ; cout << minCost ( a , 0 , n - 1 , k , prefix , dp ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int n ) { int dp [ n + 1 ] ; dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = INT_MAX ; if ( i % 2 == 0 ) { int x = dp [ i / 2 ] ; if ( x + 1 < dp [ i ] ) { dp [ i ] = x + 1 ; } } if ( i % 3 == 0 ) { int x = dp [ i / 3 ] ; if ( x + 1 < dp [ i ] ) { dp [ i ] = x + 1 ; } } int x = dp [ i - 1 ] ; if ( x + 1 < dp [ i ] ) { dp [ i ] = x + 1 ; } } return dp [ n ] ; } int main ( ) { int n = 15 ; cout << minOperations ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ReverseBitonic ( int arr [ ] , int N ) { int i , j ; int lds [ N ] ; for ( i = 0 ; i < N ; i ++ ) { lds [ i ] = 1 ; } for ( i = 1 ; i < N ; i ++ ) { for ( j = 0 ; j < i ; j ++ ) { if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) { lds [ i ] = lds [ j ] + 1 ; } } } int lis [ N ] ; for ( i = 0 ; i < N ; i ++ ) { lis [ i ] = 1 ; } for ( i = N - 2 ; i >= 0 ; i -- ) { for ( j = N - 1 ; j > i ; j -- ) { if ( arr [ i ] < arr [ j ] && lis [ i ] < lis [ j ] + 1 ) { lis [ i ] = lis [ j ] + 1 ; } } } int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < N ; i ++ ) { if ( lis [ i ] + lds [ i ] - 1 > max ) { max = lis [ i ] + lds [ i ] - 1 ; } } return max ; } int main ( ) { int arr [ ] = { 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Length ▁ of ▁ LBS ▁ is ▁ % d STRNEWLINE " , ReverseBitonic ( arr , N ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPath ( vector < vector < int > > maze , int xpos , int ypos , bool key ) { if ( xpos < 0 || xpos >= maze . size ( ) || ypos < 0 || ypos >= maze . size ( ) ) return false ; if ( maze [ xpos ] [ ypos ] == '1' ) { if ( key == true ) if ( xpos == maze . size ( ) - 1 && ypos == maze . size ( ) - 1 ) return true ; return findPath ( maze , xpos + 1 , ypos , false ) || findPath ( maze , xpos , ypos + 1 , false ) ; return false ; } if ( xpos == maze . size ( ) - 1 && ypos == maze . size ( ) - 1 ) return true ; return findPath ( maze , xpos + 1 , ypos , key ) || findPath ( maze , xpos , ypos + 1 , key ) ; } bool mazeProb ( vector < vector < int > > maze , int xpos , int ypos ) { bool key = true ; if ( findPath ( maze , xpos , ypos , key ) ) return true ; return false ; } int main ( ) { vector < vector < int > > maze = { { '0' , '0' , '1' } , { '1' , '0' , '1' } , { '1' , '1' , '0' } } ; int n = maze . size ( ) ; if ( mazeProb ( maze , 0 , 0 ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != -1 ) return dp [ ind ] ; else { int ans = INT_MAX ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } } int main ( ) { int a [ ] = { 10 , 30 , 40 , 50 , 20 } ; int k = 3 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int dp [ n ] ; memset ( dp , -1 , sizeof dp ) ; cout << FindMinimumCost ( 0 , a , n , k , dp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long answer ( int n ) { int dp [ 10 ] ; int prev [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; } int main ( ) { int n = 2 ; cout << answer ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE const int MAX = 100000 ; ll prefix [ MAX ] ; void sieve_modified ( ) { for ( int i = 2 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; } ll sumEvenFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; } int main ( ) { sieve_modified ( ) ; int l = 6 , r = 10 ; cout << sumEvenFactors ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100000 NEW_LINE #define ll  long long int NEW_LINE ll catalan [ MAX ] ; void catalanDP ( ll n ) { catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } } int CatalanSequence ( int arr [ ] , int n ) { catalanDP ( n ) ; unordered_multiset < int > s ; int a = 1 , b = 1 ; int c ; s . insert ( a ) ; if ( n >= 2 ) s . insert ( b ) ; for ( int i = 2 ; i < n ; i ++ ) { s . insert ( catalan [ i ] ) ; } unordered_multiset < int > :: iterator it ; for ( int i = 0 ; i < n ; i ++ ) { it = s . find ( arr [ i ] ) ; if ( it != s . end ( ) ) s . erase ( it ) ; } return s . size ( ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 5 , 41 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CatalanSequence ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 20 ; int dp [ M ] [ M ] [ 2 ] ; int K ; int countInRangeUtil ( int pos , int cnt , int tight , vector < int > num ) { if ( pos == num . size ( ) ) { if ( cnt <= K ) return 1 ; return 0 ; } if ( dp [ pos ] [ cnt ] [ tight ] != -1 ) return dp [ pos ] [ cnt ] [ tight ] ; int ans = 0 ; int limit = ( tight ? 9 : num [ pos ] ) ; for ( int dig = 0 ; dig <= limit ; dig ++ ) { int currCnt = cnt ; if ( dig != 0 ) currCnt ++ ; int currTight = tight ; if ( dig < num [ pos ] ) currTight = 1 ; ans += countInRangeUtil ( pos + 1 , currCnt , currTight , num ) ; } return dp [ pos ] [ cnt ] [ tight ] = ans ; } int countInRange ( int x ) { vector < int > num ; while ( x ) { num . push_back ( x % 10 ) ; x /= 10 ; } reverse ( num . begin ( ) , num . end ( ) ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return countInRangeUtil ( 0 , 0 , 0 , num ) ; } int main ( ) { int L = 1 , R = 1000 ; K = 3 ; cout << countInRange ( R ) - countInRange ( L - 1 ) << endl ; L = 9995 , R = 10005 , K = 2 ; cout << countInRange ( R ) - countInRange ( L - 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000 NEW_LINE int find ( int index , int openbrk , int n , int dp [ N ] [ N ] , int adj [ ] ) { if ( openbrk < 0 ) return 0 ; if ( index == n ) { if ( openbrk == 0 ) return 1 ; else return 0 ; } if ( dp [ index ] [ openbrk ] != -1 ) return dp [ index ] [ openbrk ] ; if ( adj [ index ] == 1 ) { dp [ index ] [ openbrk ] = find ( index + 1 , openbrk + 1 , n , dp , adj ) ; } else { dp [ index ] [ openbrk ] = find ( index + 1 , openbrk + 1 , n , dp , adj ) + find ( index + 1 , openbrk - 1 , n , dp , adj ) ; } return dp [ index ] [ openbrk ] ; } int main ( ) { int dp [ N ] [ N ] ; int n = 2 ; memset ( dp , -1 , sizeof ( dp ) ) ; int adj [ 4 ] = { 1 , 0 , 0 , 0 } ; cout << find ( 0 , 0 , 2 * n , dp , adj ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxValUtil ( int arr [ ] , int n , int num , int maxLimit , int ind , int & ans ) { if ( ind == n ) { ans = max ( ans , num ) ; return ; } if ( num - arr [ ind ] >= 0 ) { findMaxValUtil ( arr , n , num - arr [ ind ] , maxLimit , ind + 1 , ans ) ; } if ( num + arr [ ind ] <= maxLimit ) { findMaxValUtil ( arr , n , num + arr [ ind ] , maxLimit , ind + 1 , ans ) ; } } int findMaxVal ( int arr [ ] , int n , int num , int maxLimit ) { int ans = 0 ; int ind = 0 ; findMaxValUtil ( arr , n , num , maxLimit , ind , ans ) ; return ans ; } int main ( ) { int num = 1 ; int arr [ ] = { 3 , 10 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxLimit = 15 ; cout << findMaxVal ( arr , n , num , maxLimit ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSets ( vector < int > set1 , vector < int > set2 ) { int i ; for ( i = 0 ; i < set1 . size ( ) ; i ++ ) { cout << set1 [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; for ( i = 0 ; i < set2 . size ( ) ; i ++ ) { cout << set2 [ i ] << " ▁ " ; } } bool findSets ( int arr [ ] , int n , vector < int > & set1 , vector < int > & set2 , int sum1 , int sum2 , int pos ) { if ( pos == n ) { if ( sum1 == sum2 ) { printSets ( set1 , set2 ) ; return true ; } else return false ; } set1 . push_back ( arr [ pos ] ) ; bool res = findSets ( arr , n , set1 , set2 , sum1 + arr [ pos ] , sum2 , pos + 1 ) ; if ( res ) return res ; set1 . pop_back ( ) ; set2 . push_back ( arr [ pos ] ) ; res = findSets ( arr , n , set1 , set2 , sum1 , sum2 + arr [ pos ] , pos + 1 ) ; if ( res == false ) if ( ! set2 . empty ( ) ) set2 . pop_back ( ) ; return res ; } bool isPartitionPoss ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; vector < int > set1 , set2 ; return findSets ( arr , n , set1 , set2 , 0 , 0 , 0 ) ; } int main ( ) { int arr [ ] = { 5 , 5 , 1 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( ! isPartitionPoss ( arr , n ) ) { cout << " - 1" ; } return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE int static const DP_s = 9 ; int getNumMonotone ( int len ) { int DP [ len ] [ DP_s ] ; memset ( DP , 0 , sizeof ( DP ) ) ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < len ; ++ i ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; } int main ( ) { std :: cout << getNumMonotone ( 10 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sequence ( int n ) { int f [ n + 1 ] ; int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; } int main ( ) { int n = 10 ; cout << sequence ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll lis ( ll arr [ ] , ll n ) { ll mpis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; return * max_element ( mpis , mpis + n ) ; } int main ( ) { ll arr [ ] = { 3 , 100 , 4 , 5 , 150 , 6 } ; ll n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " % lld " , lis ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Hosoya ( int n , int m ) { if ( ( n == 0 && m == 0 ) || ( n == 1 && m == 0 ) || ( n == 1 && m == 1 ) || ( n == 2 && m == 1 ) ) return 1 ; if ( n > m ) return Hosoya ( n - 1 , m ) + Hosoya ( n - 2 , m ) ; else if ( m == n ) return Hosoya ( n - 1 , m - 1 ) + Hosoya ( n - 2 , m - 2 ) ; else return 0 ; } void printHosoya ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) cout << Hosoya ( i , j ) << " ▁ " ; cout << endl ; } } int main ( ) { int n = 5 ; printHosoya ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; } int main ( ) { int n = 3 , m = 1 ; cout << eulerian ( n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestSubset ( int a [ ] , int n ) { int dp [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) mxm = max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; } return * max_element ( dp , dp + n ) ; } int main ( ) { int a [ ] = { 1 , 3 , 6 , 13 , 17 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << largestSubset ( a , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countFriendsPairings ( int n ) { int dp [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; } int main ( ) { int n = 4 ; cout << countFriendsPairings ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; } int main ( ) { int n = 4 ; cout << countFriendsPairings ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  5 NEW_LINE #define C  3 NEW_LINE using namespace std ; void precompute ( int mat [ R ] [ C ] , int ryt [ ] [ C + 2 ] , int dwn [ R + 2 ] [ C + 2 ] ) { for ( int j = C - 1 ; j >= 0 ; j -- ) { for ( int i = 0 ; i < R ; ++ i ) { if ( mat [ i ] [ j ] == 0 ) ryt [ i ] [ j ] = 0 ; else ryt [ i ] [ j ] = ryt [ i ] [ j + 1 ] + 1 ; } } for ( int i = R - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < C ; ++ j ) { if ( mat [ i ] [ j ] == 0 ) dwn [ i ] [ j ] = 0 ; else dwn [ i ] [ j ] = dwn [ i + 1 ] [ j ] + 1 ; } } } int solveRowSwap ( int ryt [ R + 2 ] [ C + 2 ] ) { int b [ R ] = { 0 } , ans = 0 ; for ( int j = 0 ; j < C ; j ++ ) { for ( int i = 0 ; i < R ; i ++ ) b [ i ] = ryt [ i ] [ j ] ; sort ( b , b + R ) ; for ( int i = 0 ; i < R ; ++ i ) ans = max ( ans , b [ i ] * ( R - i ) ) ; } return ans ; } int solveColumnSwap ( int dwn [ R + 2 ] [ C + 2 ] ) { int b [ C ] = { 0 } , ans = 0 ; for ( int i = 0 ; i < R ; ++ i ) { for ( int j = 0 ; j < C ; ++ j ) b [ j ] = dwn [ i ] [ j ] ; sort ( b , b + C ) ; for ( int i = 0 ; i < C ; ++ i ) ans = max ( ans , b [ i ] * ( C - i ) ) ; } return ans ; } void findMax1s ( int mat [ R ] [ C ] ) { int ryt [ R + 2 ] [ C + 2 ] , dwn [ R + 2 ] [ C + 2 ] ; memset ( ryt , 0 , sizeof ryt ) ; memset ( dwn , 0 , sizeof dwn ) ; precompute ( mat , ryt , dwn ) ; int rswap = solveRowSwap ( ryt ) ; int cswap = solveColumnSwap ( dwn ) ; ( rswap > cswap ) ? ( cout << " Row ▁ Swap STRNEWLINE " << rswap << endl ) : ( cout << " Column ▁ Swap STRNEWLINE " << cswap << endl ) ; } int main ( ) { int mat [ R ] [ C ] = { { 0 , 0 , 0 } , { 1 , 1 , 0 } , { 1 , 1 , 0 } , { 0 , 0 , 0 } , { 1 , 1 , 0 } } ; findMax1s ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcsOf3 ( string X , string Y , string Z , int m , int n , int o ) { int L [ m + 1 ] [ n + 1 ] [ o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; } int main ( ) { string X = " AGGT12" ; string Y = "12TXAYB " ; string Z = "12XBA " ; int m = X . length ( ) ; int n = Y . length ( ) ; int o = Z . length ( ) ; cout << " Length ▁ of ▁ LCS ▁ is ▁ " << lcsOf3 ( X , Y , Z , m , n , o ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubsequence ( int n , int arr [ ] ) { if ( n == 1 ) return 1 ; int dp [ n ] ; unordered_map < int , int > mapp ; dp [ 0 ] = 1 ; mapp [ arr [ 0 ] ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( abs ( arr [ i ] - arr [ i - 1 ] ) == 1 ) dp [ i ] = dp [ i - 1 ] + 1 ; else { if ( mapp . count ( arr [ i ] + 1 ) > 0 || mapp . count ( arr [ i ] - 1 ) ) { dp [ i ] = 1 + max ( mapp [ arr [ i ] + 1 ] , mapp [ arr [ i ] - 1 ] ) ; } else dp [ i ] = 1 ; } mapp [ arr [ i ] ] = dp [ i ] ; } return ( * max_element ( dp , dp + n ) ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestSubsequence ( n , arr ) ; return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; int findLongestRepeatingSubSeq ( string str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; } int main ( ) { string str = " aabb " ; cout << " The ▁ length ▁ of ▁ the ▁ largest ▁ subsequence ▁ that " " ▁ repeats ▁ itself ▁ is ▁ : ▁ " << findLongestRepeatingSubSeq ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long int lookup [ 50 ] [ 1000 ] [ 1000 ] [ 2 ] ; unsigned long long int countRec ( int digits , int esum , int osum , bool isOdd , int n ) { if ( digits == n ) return ( esum - osum == 1 ) ; if ( lookup [ digits ] [ esum ] [ osum ] [ isOdd ] != -1 ) return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] ; unsigned long long int ans = 0 ; if ( isOdd ) for ( int i = 0 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum , osum + i , false , n ) ; for ( int i = 0 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum + i , osum , true , n ) ; return lookup [ digits ] [ esum ] [ osum ] [ isOdd ] = ans ; } unsigned long long int finalCount ( int n ) { int digits = 0 ; memset ( lookup , -1 , sizeof lookup ) ; unsigned long long int ans = 0 ; int esum = 0 , osum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) ans += countRec ( digits + 1 , esum + i , osum , true , n ) ; return ans ; } int main ( ) { int n = 3 ; cout << " Count ▁ of ▁ " << n << " ▁ digit ▁ numbers ▁ is ▁ " << finalCount ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfPaths ( int m , int n ) { int dp [ n ] = { 1 } ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; } int main ( ) { cout << numberOfPaths ( 3 , 3 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Solution ( vector < int > A ) { int ans = 2 ; int n = A . size ( ) ; if ( n <= 2 ) return n ; vector < int > llap ( n , 2 ) ; sort ( A . begin ( ) , A . end ( ) ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) { int i = j - 1 ; int k = j + 1 ; while ( i >= 0 && k < n ) { if ( A [ i ] + A [ k ] == 2 * A [ j ] ) { llap [ j ] = max ( llap [ k ] + 1 , llap [ j ] ) ; ans = max ( ans , llap [ j ] ) ; i -= 1 ; k += 1 ; } else if ( A [ i ] + A [ k ] < 2 * A [ j ] ) k += 1 ; else i -= 1 ; } } return ans ; } int main ( ) { vector < int > a ( { 9 , 4 , 7 , 2 , 10 } ) ; cout << Solution ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int coinchange ( vector < int > & a , int v , int n , vector < vector < int > > & dp ) { if ( v == 0 ) return dp [ n ] [ v ] = 1 ; if ( n == 0 ) return 0 ; if ( dp [ n ] [ v ] != -1 ) return dp [ n ] [ v ] ; if ( a [ n - 1 ] <= v ) { return dp [ n ] [ v ] = coinchange ( a , v - a [ n - 1 ] , n , dp ) + coinchange ( a , v , n - 1 , dp ) ; } return dp [ n ] [ v ] = coinchange ( a , v , n - 1 , dp ) ; } int32_t main ( ) { int tc = 1 ; while ( tc -- ) { int n , v ; n = 3 , v = 4 ; vector < int > a = { 1 , 2 , 3 } ; vector < vector < int > > dp ( n + 1 , vector < int > ( v + 1 , -1 ) ) ; int res = coinchange ( a , v , n , dp ) ; cout << res << endl ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minumumOperation ( int N , int arr [ ] ) { int sum_arr = 0 ; sum_arr = accumulate ( arr , arr + N , sum_arr ) ; if ( sum_arr >= N ) cout << sum_arr - N << endl ; else cout << 1 << endl ; } int main ( ) { int N = 4 ; int arr [ ] = { 8 , 4 , 6 , 2 } ; minumumOperation ( N , arr ) ; }
#include <iostream> NEW_LINE using namespace std ; int factorial ( int N ) { if ( N == 0 N == 1 ) return 1 ; return N * factorial ( N - 1 ) ; } int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; } int main ( ) { int N = 6 ; cout << nthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Substr ( string s2 , string s1 ) { int i = 0 ; for ( ; i < s1 . length ( ) ; i ++ ) { if ( counter == s2 . length ( ) ) break ; if ( s2 [ counter ] == s1 [ i ] ) { counter ++ ; } else { if ( counter > 0 ) { i -= counter ; } counter = 0 ; } } return counter < s2 . length ( ) ? -1 : i - counter ; } int main ( ) { string s1 = " geeksfffffoorrfoorforgeeks " ; cout << Substr ( " for " , s1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string util ( string sub ) { int n = sub . length ( ) ; int i = 0 ; string ret = " " ; while ( i < n ) { int t = ( sub [ i ] - ' a ' ) + n - 1 - i ; char ch = ( char ) ( t % 26 + 97 ) ; ret = ret + ch ; i ++ ; } return ret ; } void manipulate ( string s ) { int n = s . length ( ) ; int i = 0 , j = 0 ; string res = " " ; while ( i < n ) { if ( s [ i ] == ' ▁ ' ) { res += util ( s . substr ( j , i ) ) ; res = res + " ▁ " ; j = i + 1 ; i = j + 1 ; } else { i ++ ; } } res = res + util ( s . substr ( j , i ) ) ; cout << res << endl ; } int main ( ) { string s = " acm ▁ fkz " ; manipulate ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int composite ( int n ) { int flag = 0 ; int c = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { if ( n % j == 0 ) { c += 1 ; } } if ( c >= 3 ) flag = 1 ; return flag ; } void odd_indices ( int arr [ ] , int n ) { int sum = 0 ; for ( int k = 0 ; k < n ; k += 2 ) { int check = composite ( arr [ k ] ) ; if ( check == 1 ) sum += arr [ k ] ; } cout << sum << endl ; } int main ( ) { int arr [ ] = { 13 , 5 , 8 , 16 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; odd_indices ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > z_function ( string s ) { int n = s . size ( ) ; vector < int > z ( n ) ; for ( int i = 1 , l = 0 , r = 0 ; i < n ; i ++ ) { if ( i <= r ) z [ i ] = min ( r - i + 1 , z [ i - l ] ) ; while ( i + z [ i ] < n && s [ z [ i ] ] == s [ i + z [ i ] ] ) z [ i ] ++ ; if ( i + z [ i ] - 1 > r ) l = i , r = i + z [ i ] - 1 ; } return z ; } int n , len = 0 ; int bit [ 1000005 ] ; string s ; vector < int > z ; map < int , int > m ; void update ( int idx , int val ) { if ( idx == 0 ) return ; while ( idx <= n ) { bit [ idx ] += val ; idx += ( idx & - idx ) ; } } int pref ( int idx ) { int ans = 0 ; while ( idx > 0 ) { ans += bit [ idx ] ; idx -= ( idx & - idx ) ; } return ans ; } int main ( ) { s = " geeksisforgeeksinplatformgeeks " ; n = s . size ( ) ; z = z_function ( s ) ; for ( int i = 1 ; i < n ; i ++ ) { update ( z [ i ] , 1 ) ; } for ( int i = n - 1 ; i > 1 ; i -- ) { if ( z [ i ] != ( n - i ) ) continue ; if ( pref ( n ) - pref ( z [ i ] - 1 ) >= 2 ) { len = max ( len , z [ i ] ) ; } } if ( ! len ) cout << " - 1" ; else cout << s . substr ( 0 , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; template < size_t N > void splitString ( string ( & arr ) [ N ] , string str ) { int n = 0 ; istringstream iss ( str ) ; for ( auto it = istream_iterator < string > ( iss ) ; it != istream_iterator < string > ( ) && n < N ; ++ it , ++ n ) arr [ n ] = * it ; } inline bool ends_with ( std :: string const & value , std :: string const & ending ) { if ( ending . size ( ) > value . size ( ) ) return false ; return std :: equal ( ending . rbegin ( ) , ending . rend ( ) , value . rbegin ( ) ) ; } int endingWith ( string str , string suff ) { int cnt = 0 ; const int size = 50 ; string words [ size ] ; splitString ( words , str ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( ends_with ( words [ i ] , suff ) ) cnt ++ ; } return cnt ; } int main ( ) { string str = " GeeksForGeeks ▁ is ▁ a ▁ computer ▁ " " science ▁ portal ▁ for ▁ geeks " ; string suff = " ks " ; cout << endingWith ( str , suff ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool equalIgnoreCase ( string str1 , string str2 ) { int i = 0 ; transform ( str1 . begin ( ) , str1 . end ( ) , str1 . begin ( ) , :: toupper ) ; transform ( str2 . begin ( ) , str2 . end ( ) , str2 . begin ( ) , :: toupper ) ; int x = str1 . compare ( str2 ) ; if ( x != 0 ) return false ; else return true ; } void equalIgnoreCaseUtil ( string str1 , string str2 ) { bool res = equalIgnoreCase ( str1 , str2 ) ; if ( res == true ) cout << " Same " << endl ; else cout << " Not ▁ Same " << endl ; } int main ( ) { string str1 , str2 ; str1 = " Geeks " ; str2 = " geeks " ; equalIgnoreCaseUtil ( str1 , str2 ) ; str1 = " Geek " ; str2 = " geeksforgeeks " ; equalIgnoreCaseUtil ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isFrequencyEqual ( string str , int len ) { if ( len % 2 == 1 ) return false ; int i , freq [ 26 ] = { 0 } ; for ( i = 0 ; i < len ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) if ( freq [ i ] == len / 2 ) return true ; return false ; } int main ( ) { string str = " geeksforgeeks " ; int len = str . length ( ) ; if ( isFrequencyEqual ( str , len ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string replaceConsonants ( string str ) { string res = " " ; int i = 0 , count = 0 ; while ( i < str . length ( ) ) { if ( str [ i ] != ' a ' && str [ i ] != ' e ' && str [ i ] != ' i ' && str [ i ] != ' o ' && str [ i ] != ' u ' ) { i ++ ; count ++ ; } else { if ( count > 0 ) res += to_string ( count ) ; res += str [ i ] ; i ++ ; count = 0 ; } } if ( count > 0 ) res += to_string ( count ) ; return res ; } int main ( ) { string str = " abcdeiop " ; cout << replaceConsonants ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMinimalReplacements ( string s ) { int n = s . length ( ) ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { cnt += 1 ; if ( i != ( n - 1 ) ) { for ( auto it : "012" ) { if ( it != s [ i + 1 ] && it != s [ i - 1 ] ) { s [ i ] = it ; break ; } } } { for ( auto it : "012" ) { if ( it != s [ i - 1 ] ) { s [ i ] = it ; break ; } } } } } return cnt ; } int main ( ) { string s = "201220211" ; cout << countMinimalReplacements ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextIndex ( string str , int start , char c ) { for ( int i = start ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == c ) return i ; } return -1 ; } int countSubStrings ( string str ) { int i , n = str . length ( ) ; int countX [ n ] ; int count = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' x ' ) count ++ ; countX [ i ] = count ; } int nextIndexX = nextIndex ( str , 0 , ' x ' ) ; int nextIndexY = nextIndex ( str , 0 , ' y ' ) ; count = 0 ; while ( nextIndexX != -1 && nextIndexY != -1 ) { if ( nextIndexX > nextIndexY ) { nextIndexY = nextIndex ( str , nextIndexY + 1 , ' y ' ) ; continue ; } else { count += countX [ nextIndexY ] ; nextIndexX = nextIndex ( str , nextIndexX + 1 , ' x ' ) ; } } return count ; } int main ( ) { string s = " xyyxx " ; cout << countSubStrings ( s ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { int i ; if ( n == 1 ) return false ; for ( i = 2 ; i <= sqrt ( n ) ; i ++ ) if ( n % i == 0 ) return false ; return true ; } bool check_frequency ( string s ) { map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) m [ s [ i ] ] ++ ; for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) if ( m [ ch ] > 0 && ! isPrime ( m [ ch ] ) ) return false ; return true ; } int main ( ) { string s = " geeksforgeeks " ; if ( check_frequency ( s ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; class Solution { public : string remove_k_char ( int k , string s ) { if ( k == 1 ) return " " ; string output = " " ; stack < pair < char , int > > stk ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( stk . empty ( ) == true ) { stk . push ( make_pair ( s [ i ] , 1 ) ) ; } else { if ( s [ i ] == ( stk . top ( ) ) . first ) { stk . push ( { s [ i ] , stk . top ( ) . second + 1 } ) ; if ( stk . top ( ) . second == k ) { int x = k ; while ( x ) { stk . pop ( ) ; x -- ; } } } else { stk . push ( make_pair ( s [ i ] , 1 ) ) ; } } } while ( ! stk . empty ( ) ) { output += stk . top ( ) . first ; stk . pop ( ) ; } reverse ( output . begin ( ) , output . end ( ) ) ; return output ; } } ; int main ( ) { string s = " geeksforgeeks " ; int k = 2 ; Solution obj ; cout << obj . remove_k_char ( k , s ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define NO_OF_CHARS  256 NEW_LINE int firstNonRepeating ( char * str ) { int arr [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) arr [ i ] = -1 ; for ( int i = 0 ; str [ i ] ; i ++ ) { if ( arr [ str [ i ] ] == -1 ) arr [ str [ i ] ] = i ; else arr [ str [ i ] ] = -2 ; } int res = INT_MAX ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( arr [ i ] >= 0 ) res = min ( res , arr [ i ] ) ; return res ; } int main ( ) { char str [ ] = " geeksforgeeks " ; int index = firstNonRepeating ( str ) ; if ( index == INT_MAX ) cout << " Either ▁ all ▁ characters ▁ are ▁ " " repeating ▁ or ▁ string ▁ is ▁ empty " ; else cout << " First ▁ non - repeating ▁ character " " ▁ is ▁ " << str [ index ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string minimize ( string str ) { string mstr = " ▁ " ; int l , i , flagchar [ 26 ] = { 0 } ; char ch ; l = str . length ( ) ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { ch = str . at ( i ) ; if ( flagchar [ ch - 97 ] == 0 ) { mstr = mstr + ch ; flagchar [ ch - 97 ] = 1 ; } } } void replaceMinimizeUtil ( string str ) { string minimizedStr , finalStr = " " ; int i , index , l ; char ch ; l = str . length ( ) ; for ( i = 0 ; i < minimizedStr . length ( ) ; i ++ ) { ch = minimizedStr . at ( i ) ; index = ( ch * ch ) % l ; finalStr = finalStr + str . at ( index ) ; } } int main ( ) { string str = " geeks " ; replaceMinimizeUtil ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void cipher ( char str [ ] ) { for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( isalpha ( str [ i ] ) == 0 && str [ i ] != ' ▁ ' ) { printf ( " Enter ▁ only ▁ alphabets ▁ and ▁ space STRNEWLINE " ) ; return ; } } printf ( " Encrypted ▁ Code ▁ using ▁ Latin ▁ Alphabet STRNEWLINE " ) ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) printf ( " % d ▁ " , str [ i ] - ' A ' + 1 ) ; else if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) printf ( " % d ▁ " , str [ i ] - ' a ' + 1 ) ; if ( str [ i ] == ' ▁ ' ) printf ( " % c " , str [ i ] ) ; } printf ( " STRNEWLINE " ) ; } int main ( ) { char str [ ] = " geeksforgeeks " ; cipher ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPalin ( string word ) { int n = word . length ( ) ; transform ( word . begin ( ) , word . end ( ) , word . begin ( ) , :: tolower ) ; for ( int i = 0 ; i < n ; i ++ , n -- ) if ( word . at ( i ) != word . at ( n - 1 ) ) return false ; return true ; } int countPalin ( string str ) { str = str + " ▁ " ; string word = " " ; int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . at ( i ) ; if ( ch != ' ▁ ' ) word = word + ch ; else { if ( checkPalin ( word ) ) count ++ ; word = " " ; } } return count ; } int main ( ) { cout << countPalin ( " Madam ▁ Arora ▁ teaches ▁ malayalam " ) << endl ; cout << countPalin ( " Nitin ▁ speaks ▁ malayalam " ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool pre [ 100 ] ; int n ; string w ; string s [ 110 ] ; char letter ; void verify ( int position , int index ) { int l = w . length ( ) ; int k = s [ index ] . length ( ) ; if ( position + k > l ) return ; bool same = true ; for ( int i = position ; i < position + k ; i ++ ) { int n , n1 ; char ch = w [ i ] ; char ch1 = s [ index ] [ i - position ] ; if ( ch >= ' a ' && ch <= ' z ' ) n = ch - ' a ' ; else n = ch - ' A ' ; if ( ch1 >= ' a ' && ch1 <= ' z ' ) n1 = ch1 - ' a ' ; else n1 = ch1 - ' A ' ; if ( n != n1 ) same = false ; } if ( same == true ) { for ( int i = position ; i < position + k ; i ++ ) pre [ i ] = true ; return ; } } void solve ( ) { int l = w . length ( ) ; int p = letter - ' a ' ; for ( int i = 0 ; i < 100 ; i ++ ) pre [ i ] = false ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) verify ( i , j ) ; } for ( int i = 0 ; i < l ; i ++ ) { if ( pre [ i ] == true ) { if ( w [ i ] == letter ) w [ i ] = ( letter == ' a ' ) ? ' b ' : ' a ' ; else if ( w [ i ] == ' A ' + p ) w [ i ] = ( letter == ' a ' ) ? ' B ' : ' A ' ; else if ( w [ i ] >= ' a ' && w [ i ] <= ' z ' ) w [ i ] = letter ; else if ( w [ i ] >= ' A ' && w [ i ] <= ' Z ' ) w [ i ] = ' A ' + p ; } } cout << w ; } int main ( ) { n = 3 ; s [ 0 ] = " etr " ; s [ 1 ] = " ed " ; s [ 2 ] = " ied " ; w = " PEtrUnited " ; letter = ' d ' ; solve ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( string N ) { int len = N . length ( ) ; int l = ( len ) / 2 ; int count = 0 ; for ( int i = 1 ; i <= l ; i ++ ) { string s = N . substr ( 0 , i ) ; int l1 = s . length ( ) ; string t = N . substr ( i , l1 ) ; if ( s [ 0 ] == '0' t [ 0 ] == '0' ) continue ; if ( s . compare ( t ) == 0 ) count ++ ; } return count ; } int main ( ) { string N = "2202200" ; cout << calculate ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOccurrences ( string s , int K ) { int n = s . length ( ) ; int C , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' ) c1 ++ ; if ( s [ i ] == ' b ' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; } int main ( ) { string S = " abcb " ; int k = 2 ; cout << countOccurrences ( S , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printStrongNess ( string & input ) { int n = input . length ( ) ; bool hasLower = false , hasUpper = false ; bool hasDigit = false , specialChar = false ; string normalChars = " abcdefghijklmnopqrstu " " vwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890 ▁ " ; for ( int i = 0 ; i < n ; i ++ ) { if ( islower ( input [ i ] ) ) hasLower = true ; if ( isupper ( input [ i ] ) ) hasUpper = true ; if ( isdigit ( input [ i ] ) ) hasDigit = true ; size_t special = input . find_first_not_of ( normalChars ) ; if ( special != string :: npos ) specialChar = true ; } cout << " Strength ▁ of ▁ password : - " ; if ( hasLower && hasUpper && hasDigit && specialChar && ( n >= 8 ) ) cout << " Strong " << endl ; else if ( ( hasLower hasUpper ) && specialChar && ( n >= 6 ) ) cout << " Moderate " << endl ; else cout << " Weak " << endl ; } int main ( ) { string input = " GeeksforGeeks ! @12" ; printStrongNess ( input ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; string findString ( int n , int k ) { string res = " " ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' a ' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; } int main ( ) { int n = 5 , k = 2 ; cout << findString ( n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int getDigit ( int number ) { if ( number < 9 ) return number ; return number / 10 + number % 10 ; } int getSize ( long d ) { string num = to_string ( d ) ; return num . length ( ) ; } long getPrefix ( long number , int k ) { if ( getSize ( number ) > k ) { string num = to_string ( number ) ; return stol ( num . substr ( 0 , k ) ) ; } return number ; } bool prefixMatched ( long number , int d ) { return getPrefix ( number , getSize ( d ) ) == d ; } int sumOfDoubleEvenPlace ( long int number ) { int sum = 0 ; string num = to_string ( number ) ; for ( int i = getSize ( number ) - 2 ; i >= 0 ; i -= 2 ) sum += getDigit ( int ( num [ i ] - '0' ) * 2 ) ; return sum ; } int sumOfOddPlace ( long number ) { int sum = 0 ; string num = to_string ( number ) ; for ( int i = getSize ( number ) - 1 ; i >= 0 ; i -= 2 ) sum += num [ i ] - '0' ; return sum ; } bool isValid ( long int number ) { return ( getSize ( number ) >= 13 && getSize ( number ) <= 16 ) && ( prefixMatched ( number , 4 ) || prefixMatched ( number , 5 ) || prefixMatched ( number , 37 ) || prefixMatched ( number , 6 ) ) && ( ( sumOfDoubleEvenPlace ( number ) + sumOfOddPlace ( number ) ) % 10 == 0 ) ; } int main ( ) { long int number = 5196081888500645L ; cout << number << " ▁ is ▁ " << ( isValid ( number ) ? " valid " : " invalid " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } void FindSubstring ( string str ) { int start = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isVowel ( str [ i ] ) == true ) { hash . insert ( str [ i ] ) ; if ( hash . size ( ) == 5 ) cout << str . substr ( start , i - start + 1 ) << " ▁ " ; } else { start = i + 1 ; hash . clear ( ) ; } } } int main ( ) { string str = " aeoibsddaeiouudb " ; FindSubstring ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string concatenetedString ( string s1 , string s2 ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s2 . size ( ) ; i ++ ) m [ s2 [ i ] ] = 1 ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( m . find ( s1 [ i ] ) == m . end ( ) ) res += s1 [ i ] ; else m [ s1 [ i ] ] = 2 ; } for ( int i = 0 ; i < s2 . size ( ) ; i ++ ) if ( m [ s2 [ i ] ] == 1 ) res += s2 [ i ] ; return res ; } int main ( ) { string s1 = " abcs " ; string s2 = " cxzca " ; cout << concatenetedString ( s1 , s2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; set < string > st ; bool isVowel ( char c ) { return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ; } bool isConsonant ( char c ) { return ! isVowel ( c ) ; } void subsequence ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( isVowel ( str [ i ] ) ) { for ( int j = str . length ( ) - 1 ; j >= i ; j -- ) { if ( isConsonant ( str [ j ] ) ) { string str_sub = str . substr ( i , j + 1 ) ; st . insert ( str_sub ) ; for ( int k = 1 ; k < str_sub . length ( ) - 1 ; k ++ ) { string sb = str_sub ; sb . erase ( sb . begin ( ) + k ) ; subsequence ( sb ) ; } } } } } } int main ( ) { string s = " xabcef " ; subsequence ( s ) ; for ( auto i : st ) cout << i << " ▁ " ; cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string decode ( string str ) { string res = " " ; bool found = false ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { if ( str [ i ] == ' ▁ ' ) { found = false ; continue ; } if ( ! found ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { res += str [ i ] + 32 ; found = true ; } else if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { res += str [ i ] ; found = true ; } } } return res ; } int main ( ) { string in ; in = " A ▁ Step ▁ by ▁ Step ▁ Guide ▁ for ▁ Placement ▁ Preparation ▁ by ▁ GeeksforGeeks " ; cout << " Enciphered ▁ Message : ▁ " ; cout << decode ( in ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } int countVovels ( string str , int n ) { if ( n == 1 ) return isVowel ( str [ n - 1 ] ) ; return countVovels ( str , n - 1 ) + isVowel ( str [ n - 1 ] ) ; } int main ( ) { string str = " abc ▁ de " ; cout << countVovels ( str , str . length ( ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHARS = 256 ; string findSubString ( string str ) { int n = str . length ( ) ; int dist_count = 0 ; unordered_map < int , int > hash_map ; for ( int i = 0 ; i < n ; i ++ ) { hash_map [ str [ i ] ] ++ ; } dist_count = hash_map . size ( ) ; int size = INT_MAX ; string res ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; int visited [ 256 ] = { 0 } ; string sub_str = " " ; for ( int j = i ; j < n ; j ++ ) { if ( visited [ str [ j ] ] == 0 ) { count ++ ; visited [ str [ j ] ] = 1 ; } sub_str += str [ j ] ; if ( count == dist_count ) break ; } if ( sub_str . length ( ) < size && count == dist_count ) { res = sub_str ; size = res . length ( ) ; } } return res ; } int main ( ) { string str = " aabcbcdbca " ; cout << " Smallest ▁ window ▁ containing ▁ all ▁ distinct " " ▁ characters ▁ is : ▁ " << findSubString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRotatedString ( char str [ ] ) { int n = strlen ( str ) ; char temp [ 2 * n + 1 ] ; strcpy ( temp , str ) ; strcat ( temp , str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) printf ( " % c " , temp [ i + j ] ) ; printf ( " STRNEWLINE " ) ; } } int main ( ) { char str [ ] = " geeks " ; printRotatedString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  26 NEW_LINE int getIdx ( char ch ) { return ( ch - ' a ' ) ; } bool allSame ( int freq [ ] , int N ) { int same ; int i ; for ( i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 0 ) { same = freq [ i ] ; break ; } } for ( int j = i + 1 ; j < N ; j ++ ) if ( freq [ j ] > 0 && freq [ j ] != same ) return false ; return true ; } bool possibleSameCharFreqByOneRemoval ( string str ) { int l = str . length ( ) ; int freq [ M ] = { 0 } ; for ( int i = 0 ; i < l ; i ++ ) freq [ getIdx ( str [ i ] ) ] ++ ; if ( allSame ( freq , M ) ) return true ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int i = getIdx ( c ) ; if ( freq [ i ] > 0 ) { freq [ i ] -- ; if ( allSame ( freq , M ) ) return true ; freq [ i ] ++ ; } } return false ; } int main ( ) { string str = " xyyzz " ; if ( possibleSameCharFreqByOneRemoval ( str ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( string str ) { int n = str . length ( ) ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ; else evenDigSum += ( str [ i ] - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; } int main ( ) { string str = "76945" ; check ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ARRAY_SIZE ( a )  sizeof(a)/sizeof(a[0]) NEW_LINE #define ALPHABET_SIZE  (26) NEW_LINE #define CHAR_TO_INDEX ( c )  ((int)c - (int)'a') NEW_LINE struct TrieNode { struct TrieNode * children [ ALPHABET_SIZE ] ; int id ; bool isLeaf ; } ; struct TrieNode * getNode ( void ) { struct TrieNode * pNode = new TrieNode ; pNode -> isLeaf = false ; for ( int i = 0 ; i < ALPHABET_SIZE ; i ++ ) pNode -> children [ i ] = NULL ; return pNode ; } bool isPalindrome ( string str , int i , int len ) { while ( i < len ) { if ( str [ i ] != str [ len ] ) return false ; i ++ , len -- ; } return true ; } void insert ( struct TrieNode * root , string key , int id ) { struct TrieNode * pCrawl = root ; for ( int level = key . length ( ) - 1 ; level >= 0 ; level -- ) { int index = CHAR_TO_INDEX ( key [ level ] ) ; if ( ! pCrawl -> children [ index ] ) pCrawl -> children [ index ] = getNode ( ) ; if ( isPalindrome ( key , 0 , level ) ) ( pCrawl -> pos ) . push_back ( id ) ; pCrawl = pCrawl -> children [ index ] ; } pCrawl -> id = id ; pCrawl -> pos . push_back ( id ) ; pCrawl -> isLeaf = true ; } void search ( struct TrieNode * root , string key , int id , vector < vector < int > > & result ) { struct TrieNode * pCrawl = root ; for ( int level = 0 ; level < key . length ( ) ; level ++ ) { int index = CHAR_TO_INDEX ( key [ level ] ) ; if ( pCrawl -> id >= 0 && pCrawl -> id != id && isPalindrome ( key , level , key . size ( ) - 1 ) ) result . push_back ( { id , pCrawl -> id } ) ; if ( ! pCrawl -> children [ index ] ) return ; pCrawl = pCrawl -> children [ index ] ; } for ( int i : pCrawl -> pos ) { if ( i == id ) continue ; result . push_back ( { id , i } ) ; } } bool checkPalindromePair ( vector < string > vect ) { struct TrieNode * root = getNode ( ) ; for ( int i = 0 ; i < vect . size ( ) ; i ++ ) insert ( root , vect [ i ] , i ) ; vector < vector < int > > result ; for ( int i = 0 ; i < vect . size ( ) ; i ++ ) { search ( root , vect [ i ] , i , result ) ; if ( result . size ( ) > 0 ) return true ; } return false ; } int main ( ) { vector < string > vect = { " geekf " , " geeks " , " or " , " keeg " , " abc " , " bc " } ; checkPalindromePair ( vect ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateAllStringsUtil ( int K , char str [ ] , int n ) { if ( n == K ) { str [ n ] = ' \0' ; cout << str << " ▁ " ; return ; } if ( str [ n - 1 ] == '1' ) { str [ n ] = '0' ; generateAllStringsUtil ( K , str , n + 1 ) ; } if ( str [ n - 1 ] == '0' ) { str [ n ] = '0' ; generateAllStringsUtil ( K , str , n + 1 ) ; str [ n ] = '1' ; generateAllStringsUtil ( K , str , n + 1 ) ; } } void generateAllStrings ( int K ) { if ( K <= 0 ) return ; char str [ K ] ; str [ 0 ] = '0' ; generateAllStringsUtil ( K , str , 1 ) ; str [ 0 ] = '1' ; generateAllStringsUtil ( K , str , 1 ) ; } int main ( ) { int K = 3 ; generateAllStrings ( K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; bool arekAnagrams ( string str1 , string str2 , int k ) { int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; } int main ( ) { string str1 = " anagram " ; string str2 = " grammar " ; int k = 2 ; if ( arekAnagrams ( str1 , str2 , k ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void removeSpaces ( char * str ) { int count = 0 ; for ( int i = 0 ; str [ i ] ; i ++ ) if ( str [ i ] != ' ▁ ' ) str [ count ] = ' \0' ; } int main ( ) { char str [ ] = " g ▁ eeks ▁ for ▁ ge ▁ eeks ▁ " ; removeSpaces ( str ) ; cout << str ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSubStr ( char str [ ] ) { for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; } int main ( ) { char str [ ] = "00100101" ; cout << countSubStr ( str ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cstring> NEW_LINE using namespace std ; int count9s ( char number [ ] ) { int n = strlen ( number ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( number [ i ] == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; } int main ( ) { cout << count9s ( "4189" ) << endl ; cout << count9s ( "1809" ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void divide ( string str , int n ) { if ( str . length ( ) % n != 0 ) { cout << " Invalid ▁ Input : ▁ String ▁ size " ; cout << " ▁ is ▁ not ▁ divisible ▁ by ▁ n " ; return ; } int parts = str . length ( ) / n ; int start = 0 ; while ( start < str . length ( ) ) { cout << str . substr ( start , parts ) << endl ; start += parts ; } } int main ( ) { string str = " a _ simple _ divide _ string _ quest " ; divide ( str , 4 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < int > > countMap ; int cnt = INT_MAX ; void count ( int curCnt , int pos , vector < int > charAvailable , string target , vector < string > stickers ) { if ( curCnt >= cnt ) return ; int m = stickers . size ( ) ; int n = target . size ( ) ; if ( pos == n ) { cnt = min ( cnt , curCnt ) ; return ; } char c = target [ pos ] ; if ( charAvailable > 0 ) { charAvailable -- ; count ( curCnt , pos + 1 , charAvailable , target , stickers ) ; charAvailable ++ ; } else { for ( int i = 0 ; i < m ; i ++ ) { if ( countMap [ i ] == 0 ) continue ; for ( int j = 0 ; j < 26 ; j ++ ) { charAvailable [ j ] += countMap [ i ] [ j ] ; } count ( curCnt + 1 , pos , charAvailable , target , stickers ) ; for ( int j = 0 ; j < 26 ; j ++ ) { charAvailable [ j ] -= countMap [ i ] [ j ] ; } } } } int minStickers ( vector < string > stickers , string target ) { if ( target == " " ) return -1 ; if ( target . size ( ) == 0 ) return 0 ; if ( stickers . size ( ) == 0 ) return -1 ; int m = stickers . size ( ) ; countMap . resize ( m , vector < int > ( 26 , 0 ) ) ; for ( int i = 0 ; i < stickers . size ( ) ; i ++ ) { string s = stickers [ i ] ; for ( char c : s ) { countMap [ i ] ++ ; } } vector < int > temp ( 26 ) ; count ( 0 , 0 , temp , target , stickers ) ; return cnt == INT_MAX ? -1 : cnt ; } int main ( ) { vector < string > str = { " with " , " example " , " science " } ; string target = " thehat " ; int Result = minStickers ( str , target ) ; cout << Result ; }
#include <bits/stdc++.h> NEW_LINE #define breakLine  cout << " NEW_LINE -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - " #define MAX 10 using namespace std ; int arr [ MAX ] , no ; void nQueens ( int k , int n ) ; bool canPlace ( int k , int i ) ; void display ( int n ) ; void nQueens ( int k , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( canPlace ( k , i ) ) { arr [ k ] = i ; if ( k == n ) display ( n ) ; else nQueens ( k + 1 , n ) ; } } } bool canPlace ( int k , int i ) { for ( int j = 1 ; j <= k - 1 ; j ++ ) { if ( arr [ j ] == i || ( abs ( arr [ j ] - i ) == abs ( j - k ) ) ) return false ; } return true ; } void display ( int n ) { breakLine cout < < " Arrangement ▁ No . ▁ " << ++ no ; breakLine for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( arr [ i ] != j ) cout << " TABSYMBOL _ " ; else cout << " TABSYMBOL Q " ; } cout << endl ; } breakLine } int main ( ) { int n = 4 ; nQueens ( 1 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  10 NEW_LINE struct Pair { bool found ; int value ; } ; Pair findLongestPathUtil ( int mat [ R ] [ C ] , int i , int j , int x , int y , bool visited [ R ] [ C ] ) { if ( i == x && j == y ) { Pair p = { true , 0 } ; return p ; } if ( i < 0 i > = R j < 0 j > = C mat [ i ] [ j ] == 0 visited [ i ] [ j ] ) { Pair p = { false , INT_MAX } ; return p ; } visited [ i ] [ j ] = true ; int res = INT_MIN ; Pair sol = findLongestPathUtil ( mat , i , j - 1 , x , y , visited ) ; if ( sol . found ) res = max ( res , sol . value ) ; sol = findLongestPathUtil ( mat , i , j + 1 , x , y , visited ) ; if ( sol . found ) res = max ( res , sol . value ) ; sol = findLongestPathUtil ( mat , i - 1 , j , x , y , visited ) ; if ( sol . found ) res = max ( res , sol . value ) ; sol = findLongestPathUtil ( mat , i + 1 , j , x , y , visited ) ; if ( sol . found ) res = max ( res , sol . value ) ; visited [ i ] [ j ] = false ; if ( res != INT_MIN ) { Pair p = { true , 1 + res } ; return p ; } else { Pair p = { false , INT_MAX } ; return p ; } } void findLongestPath ( int mat [ R ] [ C ] , int i , int j , int x , int y ) { bool visited [ R ] [ C ] ; memset ( visited , false , sizeof visited ) ; Pair p = findLongestPathUtil ( mat , i , j , x , y , visited ) ; if ( p . found ) cout << " Length ▁ of ▁ longest ▁ possible ▁ route ▁ is ▁ " << p . value ; else cout << " Destination ▁ not ▁ reachable ▁ from ▁ given ▁ " " source " ; } int main ( ) { int mat [ R ] [ C ] = { { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 0 , 1 , 1 , 0 , 1 , 1 , 0 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } } ; findLongestPath ( mat , 0 , 0 , 1 , 7 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define V  4 NEW_LINE void printSolution ( int color [ ] ) ; bool isSafe ( bool graph [ V ] [ V ] , int color [ ] ) { for ( int i = 0 ; i < V ; i ++ ) for ( int j = i + 1 ; j < V ; j ++ ) if ( graph [ i ] [ j ] && color [ j ] == color [ i ] ) return false ; return true ; } bool graphColoring ( bool graph [ V ] [ V ] , int m , int i , int color [ V ] ) { if ( i == V ) { if ( isSafe ( graph , color ) ) { printSolution ( color ) ; return true ; } return false ; } for ( int j = 1 ; j <= m ; j ++ ) { color [ i ] = j ; if ( graphColoring ( graph , m , i + 1 , color ) ) return true ; color [ i ] = 0 ; } return false ; } void printSolution ( int color [ ] ) { cout << " Solution ▁ Exists : " " ▁ Following ▁ are ▁ the ▁ assigned ▁ colors ▁ STRNEWLINE " ; for ( int i = 0 ; i < V ; i ++ ) cout << " ▁ " << color [ i ] ; cout << " STRNEWLINE " ; } int main ( ) { bool graph [ V ] [ V ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } , } ; int color [ V ] ; for ( int i = 0 ; i < V ; i ++ ) color [ i ] = 0 ; if ( ! graphColoring ( graph , m , 0 , color ) ) cout << " Solution ▁ does ▁ not ▁ exist " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int A [ ] = { 11 , 15 , 7 , 19 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; unordered_set < int > s ; int i , j , res ; for ( i = 0 ; i < N ; ++ i ) for ( j = i , res = INT_MAX ; j < N ; ++ j ) { res &= A [ j ] ; s . insert ( res ) ; } for ( int i : s ) cout << i << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define LL  long long int NEW_LINE void answerQueries ( LL Q , vector < pair < LL , LL > > query ) { set < LL > s ; s . insert ( 0 ) ; for ( int i = 0 ; i <= 60 ; i ++ ) { for ( int j = i ; j <= 60 ; j ++ ) { for ( int k = j ; k <= 60 ; k ++ ) { if ( j == i && i == k ) s . insert ( 1LL << i ) ; else if ( j == k && i != j ) { LL x = ( 1LL << i ) + ( 1LL << j ) ; s . insert ( x ) ; } else if ( i == j && i != k ) { LL x = ( 1LL << i ) + ( 1LL << k ) ; s . insert ( x ) ; } else if ( i == k && i != j ) { LL x = ( 1LL << k ) + ( 1LL << j ) ; s . insert ( x ) ; } else { LL x = ( 1LL << i ) + ( 1LL << j ) + ( 1LL << k ) ; s . insert ( x ) ; } } } } vector < LL > validNumbers ; for ( auto val : s ) validNumbers . push_back ( val ) ; for ( int i = 0 ; i < Q ; i ++ ) { LL L = query [ i ] . first ; LL R = query [ i ] . second ; if ( R < L ) swap ( L , R ) ; if ( L == 0 ) cout << ( upper_bound ( validNumbers . begin ( ) , validNumbers . end ( ) , R ) - validNumbers . begin ( ) ) << endl ; else cout << ( upper_bound ( validNumbers . begin ( ) , validNumbers . end ( ) , R ) - upper_bound ( validNumbers . begin ( ) , validNumbers . end ( ) , L - 1 ) ) << endl ; } } int main ( ) { int Q = 2 ; vector < pair < LL , LL > > query ( Q ) ; query [ 0 ] . first = 3 ; query [ 0 ] . second = 7 ; query [ 1 ] . first = 10 ; query [ 1 ] . second = 16 ; answerQueries ( Q , query ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minStepsRecur ( int height [ ] , int l , int r , int h ) { if ( l >= r ) return 0 ; int m = l ; for ( int i = l ; i < r ; i ++ ) if ( height [ i ] < height [ m ] ) m = i ; return min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) ; } int minSteps ( int height [ ] , int N ) { return minStepsRecur ( height , 0 , N , 0 ) ; } int main ( ) { int height [ ] = { 2 , 1 , 2 , 5 , 1 } ; int N = sizeof ( height ) / sizeof ( int ) ; cout << minSteps ( height , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long ll ; #define fi  first NEW_LINE #define se  second NEW_LINE void findPoint ( int n , vector < pair < int , int > > p ) { for ( int i = 0 ; i < n * 4 + 1 ; ++ i ) { int x1 = 2e9 , x2 = -2e9 ; int y1 = 2e9 , y2 = -2e9 ; for ( int j = 0 ; j < n * 4 + 1 ; ++ j ) if ( i != j ) { x1 = min ( x1 , p [ j ] . fi ) ; x2 = max ( x2 , p [ j ] . fi ) ; y1 = min ( y1 , p [ j ] . se ) ; y2 = max ( y2 , p [ j ] . se ) ; } bool ok = 1 ; int c1 = 0 , c2 = 0 ; int c3 = 0 , c4 = 0 ; for ( int j = 1 ; j <= n * 4 + 1 ; ++ j ) if ( i != j ) { if ( ( p [ j ] . fi == x1 p [ j ] . fi == x2 ) || ( ( p [ j ] . se == y1 p [ j ] . se == y2 ) ) ) { if ( p [ j ] . fi == x1 ) ++ c1 ; if ( p [ j ] . fi == x2 ) ++ c2 ; if ( p [ j ] . se == y1 ) ++ c3 ; if ( p [ j ] . se == y2 ) ++ c4 ; } else ok = 0 ; } if ( ok && c1 >= n && c2 >= n && c3 >= n && c4 >= n && x2 - x1 == y2 - y1 ) { cout << p [ i ] . fi << " ▁ " << p [ i ] . se << " STRNEWLINE " ; } } } int main ( ) { int N = 2 ; vector < pair < int , int > > arr = { { 0 , 0 } , { 0 , 1 } , { 0 , 2 } , { 1 , 0 } , { 1 , 1 } , { 1 , 2 } , { 2 , 0 } , { 2 , 1 } , { 2 , 2 } } ; findPoint ( N , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int triacontagonalNum ( int n ) { return ( 28 * n * n - 26 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ triacontagonal ▁ Number ▁ is ▁ = ▁ " << triacontagonalNum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int hexacontagonNum ( int n ) { return ( 58 * n * n - 56 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ hexacontagon ▁ Number ▁ is ▁ = ▁ " << hexacontagonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int enneacontagonNum ( int n ) { return ( 88 * n * n - 86 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ enneacontagon ▁ Number ▁ is ▁ = ▁ " << enneacontagonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int triacontakaidigonNum ( int n ) { return ( 30 * n * n - 28 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ triacontakaidigon ▁ Number ▁ is ▁ = ▁ " << triacontakaidigonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int IcosihexagonalNum ( int n ) { return ( 24 * n * n - 22 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ Icosihexagonal ▁ Number ▁ is ▁ = ▁ " << IcosihexagonalNum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int icosikaioctagonalNum ( int n ) { return ( 26 * n * n - 24 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ icosikaioctagonal ▁ Number ▁ is ▁ = ▁ " << icosikaioctagonalNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int octacontagonNum ( int n ) { return ( 78 * n * n - 76 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ octacontagon ▁ Number ▁ is ▁ = ▁ " << octacontagonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int hectagonNum ( int n ) { return ( 98 * n * n - 96 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ hectagon ▁ Number ▁ is ▁ = ▁ " << hectagonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int tetracontagonNum ( int n ) { return ( 38 * n * n - 36 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ tetracontagon ▁ Number ▁ is ▁ = ▁ " << tetracontagonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Perimeter ( int a , int b ) { float perimeter ; perimeter = 2 * 3.14 * sqrt ( ( a * a + b * b ) / ( 2 * 1.0 ) ) ; cout << perimeter ; } int main ( ) { int a = 3 , b = 2 ; Perimeter ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float ReuleauxArea ( float a ) { if ( a < 0 ) return -1 ; float A = 0.70477 * pow ( a , 2 ) ; return A ; } int main ( ) { float a = 6 ; cout << ReuleauxArea ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float hexagonside ( float a ) { if ( a < 0 ) return -1 ; float x = 0.5176 * a ; return x ; } int main ( ) { float a = 6 ; cout << hexagonside ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float hexagonside ( float a ) { if ( a < 0 ) return -1 ; float x = a / 3 ; return x ; } int main ( ) { float a = 6 ; cout << hexagonside ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float findVolume ( float a ) { if ( a < 0 ) return -1 ; float r = a / 2 ; float h = a ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; } int main ( ) { float a = 5 ; cout << findVolume ( a ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findSegment ( int n , int m , int segment_length [ ] ) { double meet_point = ( 1.0 * n ) / 2.0 ; int sum = 0 ; int segment_number = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sum += segment_length [ i ] ; if ( ( double ) sum == meet_point ) { segment_number = -1 ; break ; } if ( sum > meet_point ) { segment_number = i + 1 ; break ; } } return segment_number ; } int main ( ) { int n = 13 ; int m = 3 ; int segment_length [ ] = { 3 , 2 , 8 } ; int ans = findSegment ( n , m , segment_length ) ; cout << ( ans ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long int NEW_LINE ll countMaxIntersect ( ll n ) { return ( n ) * ( n - 1 ) / 2 ; } int main ( ) { ll n = 8 ; cout << countMaxIntersect ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkpoint ( int h , int k , int x , int y , int a ) { int p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; } int main ( ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 ; if ( checkpoint ( h , k , x , y , a ) > 0 ) cout << " Outside " << endl ; else if ( checkpoint ( h , k , x , y , a ) == 0 ) cout << " On ▁ the ▁ parabola " << endl ; else cout << " Inside " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float circlearea ( float a , float b ) { if ( a < 0 b < 0 ) return -1 ; float A = ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ; return A ; } int main ( ) { float a = 8 , b = 10 ; cout << circlearea ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float circlearea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; if ( l < b ) return 3.14 * pow ( l / 2 , 2 ) ; else return 3.14 * pow ( b / 2 , 2 ) ; } int main ( ) { float l = 4 , b = 8 ; cout << circlearea ( l , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; } int main ( ) { int n = 3 ; cout << n << " th ▁ Centered ▁ cube ▁ number : ▁ " ; cout << centered_cube ( n ) ; cout << endl ; n = 10 ; cout << n << " th ▁ Centered ▁ cube ▁ number : ▁ " ; cout << centered_cube ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ; } int main ( ) { double side = 3 ; cout << " Volume ▁ of ▁ octahedron ▁ = " << vol_of_octahedron ( side ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; } int main ( ) { float r1 = 2.3 , r2 = 3.4 , r3 = 5.7 ; cout << " volume ▁ of ▁ ellipsoid ▁ is ▁ : ▁ " << volumeOfEllipsoid ( r1 , r2 , r3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float volumeTriangular ( int a , int b , int h ) { float vol = ( 0.1666 ) * a * b * h ; return vol ; } float volumeSquare ( int b , int h ) { float vol = ( 0.33 ) * b * b * h ; return vol ; } float volumePentagonal ( int a , int b , int h ) { float vol = ( 0.83 ) * a * b * h ; return vol ; } float volumeHexagonal ( int a , int b , int h ) { float vol = a * b * h ; return vol ; } int main ( ) { int b = 4 , h = 9 , a = 4 ; cout << " Volume ▁ of ▁ triangular " << " ▁ base ▁ pyramid ▁ is ▁ " << volumeTriangular ( a , b , h ) << endl ; cout << " Volume ▁ of ▁ square ▁ " << " ▁ base ▁ pyramid ▁ is ▁ " << volumeSquare ( b , h ) << endl ; cout << " Volume ▁ of ▁ pentagonal " << " ▁ base ▁ pyramid ▁ is ▁ " << volumePentagonal ( a , b , h ) << endl ; cout << " Volume ▁ of ▁ Hexagonal " << " ▁ base ▁ pyramid ▁ is ▁ " << volumeHexagonal ( a , b , h ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; } int main ( ) { double side = 4 ; cout << " Area ▁ of ▁ Regular ▁ Octagon ▁ = ▁ " << areaOctagon ( side ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int numberOfDiagonals ( int n ) { return n * ( n - 3 ) / 2 ; } int main ( ) { int n = 5 ; cout << n << " ▁ sided ▁ convex ▁ polygon ▁ have ▁ " ; cout << numberOfDiagonals ( n ) << " ▁ diagonals " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define pdd  pair<double, double> NEW_LINE void displayPoint ( pdd P ) { cout << " ( " << P . first << " , ▁ " << P . second << " ) " << endl ; } pdd lineLineIntersection ( pdd A , pdd B , pdd C , pdd D ) { double a1 = B . second - A . second ; double b1 = A . first - B . first ; double c1 = a1 * ( A . first ) + b1 * ( A . second ) ; double a2 = D . second - C . second ; double b2 = C . first - D . first ; double c2 = a2 * ( C . first ) + b2 * ( C . second ) ; double determinant = a1 * b2 - a2 * b1 ; if ( determinant == 0 ) { return make_pair ( FLT_MAX , FLT_MAX ) ; } else { double x = ( b2 * c1 - b1 * c2 ) / determinant ; double y = ( a1 * c2 - a2 * c1 ) / determinant ; return make_pair ( x , y ) ; } } int main ( ) { pdd A = make_pair ( 1 , 1 ) ; pdd B = make_pair ( 4 , 4 ) ; pdd C = make_pair ( 1 , 8 ) ; pdd D = make_pair ( 2 , 4 ) ; pdd intersection = lineLineIntersection ( A , B , C , D ) ; if ( intersection . first == FLT_MAX && intersection . second == FLT_MAX ) { cout << " The ▁ given ▁ lines ▁ AB ▁ and ▁ CD ▁ are ▁ parallel . STRNEWLINE " ; } else { cout << " The ▁ intersection ▁ of ▁ the ▁ given ▁ lines ▁ AB ▁ " " and ▁ CD ▁ is : ▁ " ; displayPoint ( intersection ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return ceil ( d / ( 2 * r ) ) ; } int main ( ) { int r = 2 , x1 = 0 , y1 = 0 , x2 = 0 , y2 = 4 ; cout << minRevolutions ( r , x1 , y1 , x2 , y2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void preprocess ( int p [ ] , int x [ ] , int y [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) p [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; sort ( p , p + n ) ; } int query ( int p [ ] , int n , int rad ) { int start = 0 , end = n - 1 ; while ( ( end - start ) > 1 ) { int mid = ( start + end ) / 2 ; double tp = sqrt ( p [ mid ] ) ; if ( tp > ( rad * 1.0 ) ) end = mid - 1 ; else start = mid ; } double tp1 = sqrt ( p [ start ] ) , tp2 = sqrt ( p [ end ] ) ; if ( tp1 > ( rad * 1.0 ) ) return 0 ; else if ( tp2 <= ( rad * 1.0 ) ) return end + 1 ; else return start + 1 ; } int main ( ) { int x [ ] = { 1 , 2 , 3 , -1 , 4 } ; int y [ ] = { 1 , 2 , 3 , -1 , 4 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; int p [ n ] ; preprocess ( p , x , y , n ) ; cout << query ( p , n , 3 ) << endl ; cout << query ( p , n , 32 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define eps  1e-6 NEW_LINE double getArea ( double base , double hypotenuse ) { double height = sqrt ( hypotenuse * hypotenuse - base * base ) ; return 0.5 * base * height ; } void printRightAngleTriangle ( int hypotenuse , int area ) { int hsquare = hypotenuse * hypotenuse ; double sideForMaxArea = sqrt ( hsquare / 2.0 ) ; double maxArea = getArea ( sideForMaxArea , hypotenuse ) ; if ( area > maxArea ) { cout << " Not ▁ possiblen " ; return ; } double low = 0.0 ; double high = sideForMaxArea ; double base ; while ( abs ( high - low ) > eps ) { base = ( low + high ) / 2.0 ; if ( getArea ( base , hypotenuse ) >= area ) high = base ; else low = base ; } double height = sqrt ( hsquare - base * base ) ; cout << base << " ▁ " << height << endl ; } int main ( ) { int hypotenuse = 5 ; int area = 6 ; printRightAngleTriangle ( hypotenuse , area ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; } int main ( ) { int r = 5 ; cout << countLattice ( r ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSubArrays ( int arr [ ] , int N , int K , int M ) { int count = 0 ; int sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) { sum += arr [ i ] ; } if ( sum >= K * M ) count ++ ; for ( int i = K ; i < N ; i ++ ) { sum += ( arr [ i ] - arr [ i - K ] ) ; if ( sum >= K * M ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 3 , 6 , 3 , 2 , 1 , 3 , 9 } ; int K = 2 , M = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubArrays ( arr , N , K , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_Numb_ways ( int n ) { int odd_indices = n / 2 ; int even_indices = ( n / 2 ) + ( n % 2 ) ; int arr_odd = pow ( 4 , odd_indices ) ; int arr_even = pow ( 5 , even_indices ) ; return arr_odd * arr_even ; } int main ( ) { int n = 4 ; cout << find_Numb_ways ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void performQueries ( int n , int q , int k , vector < int > & arr , vector < vector < int > > & query ) { for ( int i = 1 ; i <= q ; i ++ ) { int count = 0 ; if ( query [ i - 1 ] [ 0 ] == 1 ) { for ( int j = query [ i - 1 ] [ 1 ] ; j <= query [ i - 1 ] [ 2 ] ; j ++ ) { if ( arr [ j ] == k ) count ++ ; } cout << count << endl ; } else { = arr [ query [ i - 1 ] [ 1 ] ] = query [ i - 1 ] [ 2 ] ; } } } int main ( ) { vector < int > arr = { 9 , 5 , 7 , 6 , 9 , 0 , 0 , 0 , 0 , 5 , 6 , 7 , 3 , 9 , 0 , 7 , 0 , 9 , 0 } ; int Q = 5 ; vector < vector < int > > query = { { 1 , 5 , 14 } , { 2 , 6 , 1 } , { 1 , 0 , 8 } , { 2 , 13 , 0 } , { 1 , 6 , 18 } } ; int N = arr . size ( ) ; int K = 0 ; performQueries ( N , Q , K , arr , query ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findSmallestNumK ( int n ) { int cummAnd = n ; int i = n - 1 ; while ( cummAnd != 0 ) { cummAnd = cummAnd & i ; if ( cummAnd == 0 ) { return i ; } i -- ; } return -1 ; } int main ( ) { int N = 17 ; int lastNum = findSmallestNumK ( N ) ; int K = lastNum == -1 ? lastNum : N - lastNum ; cout << K << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string NimGame ( int N , int A , int B ) { int sum = A + B ; if ( N % sum <= A - 1 ) return " Bob " ; else return " Alice " ; } int main ( ) { int N = 3 , A = 1 , B = 2 ; cout << NimGame ( N , A , B ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void compute ( vector < int > query ) { vector < int > v ( 100001 ) , dp ( 100001 ) ; v [ 1 ] = 1 , v [ 2 ] = 0 ; dp [ 1 ] = 0 , dp [ 2 ] = 0 ; for ( int i = 3 ; i < 100001 ; i ++ ) { if ( i % 2 != 0 ) { if ( ( i / 2 ) % 2 == 0 ) { v [ i ] = 1 ; dp [ i ] = dp [ i - 1 ] ; } else { v [ i ] = v [ i / 2 ] + 1 ; dp [ i ] = dp [ i - 1 ] + v [ i ] - 1 ; } } else { v [ i ] = 0 ; dp [ i ] = dp [ i - 1 ] ; } } for ( auto x : query ) cout << dp [ x ] << endl ; } int main ( ) { vector < int > query = { 5 , 2 } ; compute ( query ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCycles ( int N ) { int res = 0 ; int finalResult = 0 ; int val = 2 * N - 1 ; int s = val ; res = ( N - 1 ) * ( N - 2 ) ; finalResult = res + s ; return finalResult ; } int main ( ) { int N = 5 ; cout << findCycles ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( int a [ ] , int n , int k ) { vector < int > v ; for ( int i = 1 ; i < n ; ++ i ) { v . push_back ( a [ i - 1 ] - a [ i ] ) ; } sort ( v . begin ( ) , v . end ( ) ) ; int res = a [ n - 1 ] - a [ 0 ] ; for ( int i = 0 ; i < k - 1 ; ++ i ) { res += v [ i ] ; } return res ; } int main ( ) { int arr [ ] = { 4 , 8 , 15 , 16 , 23 , 42 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 3 ; cout << find ( arr , N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long power ( long a , long b , long c ) { long result = 1 ; while ( b > 0 ) { if ( ( b & 1 ) == 1 ) { result = ( result * a ) % c ; } b /= 2 ; a = ( a * a ) % c ; } return result ; } long calculate ( long X , long N ) { int a [ 10 ] ; int cyclicity [ 11 ] ; cyclicity [ 1 ] = 1 ; cyclicity [ 2 ] = 4 ; cyclicity [ 3 ] = 4 ; cyclicity [ 4 ] = 2 ; cyclicity [ 5 ] = 1 ; cyclicity [ 6 ] = 1 ; cyclicity [ 7 ] = 4 ; cyclicity [ 8 ] = 4 ; cyclicity [ 9 ] = 2 ; cyclicity [ 10 ] = 1 ; if ( N == 0 N == 1 ) { return ( X % 10 ) ; } else if ( N == 2 N == 3 N == 4 ) { long temp = ( long ) 1e18 ; a [ 2 ] = 2 ; a [ 3 ] = 6 ; a [ 4 ] = 4 ; long v = X % 10 ; if ( v != 0 ) { int u = cyclicity [ ( int ) v ] ; int r = a [ ( int ) N ] % u ; if ( r == 0 ) { if ( v == 2 v == 4 v == 6 v == 8 ) { return 6 ; } else if ( v == 5 ) { return 5 ; } else if ( v == 1 v == 3 v == 7 v == 9 ) { return 1 ; } } else { return ( power ( v , r , temp ) % 10 ) ; } } else { return 0 ; } } return 1 ; } int main ( ) { int X = 18 ; int N = 4 ; long result = calculate ( X , N ) ; cout << result ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LIS ( int arr [ ] , int n ) { map < int , vector < int > > m ; for ( int i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] . push_back ( i ) ; int k = n ; int ans = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( it -> second . back ( ) < k ) { k = it -> second [ 0 ] ; ans += 1 ; } else k = * lower_bound ( it -> second . begin ( ) , it -> second . end ( ) , k ) ; } cout << ans << endl ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; LIS ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void IsPossible ( int a , int b , int x , int y ) { int final = gcd ( x , y ) ; int initial = gcd ( a , b ) ; if ( initial == final ) { cout << " POSSIBLE STRNEWLINE " ; } else { cout << " NOT ▁ POSSIBLE STRNEWLINE " ; } } int main ( ) { int A = 1 , B = 2 , X = 4 , Y = 11 ; IsPossible ( A , B , X , Y ) ; A = 2 , B = 2 , X = 3 , Y = 6 ; IsPossible ( A , B , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int waysToColor ( int arr [ ] , int n , int k ) { int powOf2 [ 500 ] = { 0 } ; int c [ 500 ] [ 500 ] ; for ( int i = 0 ; i <= n ; i ++ ) { c [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j <= i ; j ++ ) { c [ i ] [ j ] = ( c [ i - 1 ] [ j ] + c [ i - 1 ] [ j - 1 ] ) % mod ; } } powOf2 [ 0 ] = powOf2 [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { powOf2 [ i ] = powOf2 [ i - 1 ] * 2 % mod ; } int rem = n - k ; arr [ k ++ ] = n + 1 ; sort ( arr , arr + k ) ; int answer = 1 ; for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ i ] - ( i - 1 >= 0 ? arr [ i - 1 ] : 0 ) - 1 ; answer *= c [ rem ] [ x ] % mod * ( i != 0 && i != k - 1 ? powOf2 [ x ] : 1 ) % mod ; rem -= x ; } return answer ; } int main ( ) { int N = 6 ; int K = 3 ; int arr [ K ] = { 1 , 2 , 6 } ; cout << waysToColor ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int * a , int n ) { sort ( a , a + n ) ; int i = 0 ; int j = n - 1 ; while ( i <= j ) { if ( i == j ) { cout << a [ i ] << " ▁ " ; } else { cout << a [ j ] << " ▁ " ; cout << a [ i ] << " ▁ " ; } i = i + 1 ; j = j - 1 ; } cout << endl ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; printArray ( arr1 , n1 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int SmallestDiv ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return i ; } } return n ; } int main ( ) { int X = 385 ; int ans = SmallestDiv ( X ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumArea ( int l , int b , int x , int y ) { int left , right , above , below ; left = x * b ; right = ( l - x - 1 ) * b ; above = l * y ; below = ( b - y - 1 ) * l ; cout << max ( max ( left , right ) , max ( above , below ) ) ; } int main ( ) { int L = 8 , B = 8 ; int X = 0 , Y = 0 ; maximumArea ( l , b , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void findArray ( int n , int k , int s ) { int vis [ n ] = { 0 } ; int cnt = 0 ; int arr [ n ] ; for ( int i = 0 ; i < n && cnt < k ; i += 2 ) { arr [ i ] = s ; vis [ i ] = 1 ; cnt ++ ; } int val = s ; if ( s % 2 == 0 ) val ++ ; else val = val + 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] == 0 ) { arr [ i ] = val ; } } printArr ( arr , n ) ; } int main ( ) { int n = 8 , k = 3 , s = 12 ; findArray ( n , k , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 100000 ; int prime [ N ] ; int divi [ N ] ; int sum [ N ] ; void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < N ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * p ; i < N ; i += p ) prime [ i ] = 0 ; } } } void DivisorCount ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j += i ) { divi [ j ] ++ ; } } } void pre ( ) { for ( int i = 1 ; i < N ; i ++ ) { if ( prime [ divi [ i ] ] == 1 ) { sum [ i ] = i ; } } for ( int i = 1 ; i < N ; i ++ ) sum [ i ] += sum [ i - 1 ] ; } int main ( ) { int l = 5 , r = 8 ; SieveOfEratosthenes ( ) ; DivisorCount ( ) ; pre ( ) ; cout << sum [ r ] - sum [ l - 1 ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000007 NEW_LINE #define ll  long long int NEW_LINE ll power ( ll x , ll y , ll p ) { ll res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } ll modInverse ( ll n , ll p ) { return power ( n , p - 2 , p ) ; } ll nCrModPFermat ( ll n , ll r , ll p ) { if ( r == 0 ) return 1 ; ll fac [ n + 1 ] ; fac [ 0 ] = 1 ; for ( ll i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; } ll countOdd ( ll n ) { ll x = n / 2 ; if ( n % 2 == 1 ) x ++ ; return x ; } ll counteEven ( ll n ) { ll x = n / 2 ; return x ; } ll CountEvenSumSequences ( ll n ) { ll count = 0 ; for ( ll i = 0 ; i <= n ; i ++ ) { ll even = i , odd = n - i ; if ( odd % 2 == 1 ) continue ; ll tot = ( power ( countOdd ( n ) , odd , M ) * nCrModPFermat ( n , odd , M ) ) % M ; tot = ( tot * power ( counteEven ( n ) , i , M ) ) % M ; count += tot ; count %= M ; } return count ; } int main ( ) { ll n = 5 ; cout << CountEvenSumSequences ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkEvenOdd ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { cout << " Even " ; return ; } } cout << " Odd " ; } int main ( ) { int arr [ ] = { 2 , 12 , 20 , 36 , 38 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkEvenOdd ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  30 NEW_LINE int countMaxLength ( int N ) { int res ; int pre [ MAXN ] , p = 1 ; pre [ 0 ] = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { p *= 2 ; pre [ i ] = pre [ i - 1 ] + i * p ; } int ind ; for ( int i = 1 ; i < MAXN ; i ++ ) { if ( pre [ i ] >= N ) { ind = i ; break ; } } int x = N - pre [ ind - 1 ] ; int y = 2 * ind - 1 ; if ( x >= y ) res = min ( x , y ) ; else res = max ( x , 2 * ( ind - 2 ) + 1 ) ; return res ; } int main ( ) { int N = 25 ; cout << countMaxLength ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorialUsingRecursion ( int n ) { if ( n == 0 ) return 1 ; return n * factorialUsingRecursion ( n - 1 ) ; } int factorialUsingIteration ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; } int main ( ) { int num = 5 ; cout << " Factorial ▁ of ▁ " << num << " ▁ using ▁ Recursion ▁ is : ▁ " << factorialUsingRecursion ( 5 ) << endl ; cout << " Factorial ▁ of ▁ " << num << " ▁ using ▁ Iteration ▁ is : ▁ " << factorialUsingIteration ( 5 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void revereseArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) swap ( arr [ i ] , arr [ n - i - 1 ] ) ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printArray ( arr , n ) ; revereseArray ( arr , n ) ; cout << " Reversed ▁ array ▁ is " << endl ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberofSubsequences ( int a [ ] , int L , int R , int X , int n ) { int ans = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int cnt = 0 , sum = 0 ; int minVal = INT_MAX , maxVal = INT_MIN ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) ) { cnt += 1 ; sum += a [ j ] ; maxVal = max ( maxVal , a [ j ] ) ; minVal = min ( minVal , a [ j ] ) ; } } if ( cnt >= 2 && sum >= L && sum <= R && ( maxVal - minVal >= X ) ) { ans += 1 ; } } return ans ; } int main ( ) { int a [ ] = { 10 , 20 , 30 , 25 } ; int L = 40 , R = 50 , X = 10 ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << numberofSubsequences ( a , L , R , X , N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int Minimum ( int N , int K ) { int sum = N * ( N + 1 ) / 2 ; if ( K > sum ) return -1 ; if ( K <= N ) return 1 ; sum = 0 ; int count = 0 ; while ( N >= 1 && sum < K ) { count += 1 ; sum += N ; N -= 1 ; } return count ; } int main ( ) { int N = 5 , K = 10 ; cout << ( Minimum ( N , K ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestNum ( int arr [ ] , int n ) { set < int > st ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { st . insert ( arr [ i ] ) ; if ( st . find ( -1 * arr [ i ] ) != st . end ( ) ) { res = max ( res , abs ( arr [ i ] ) ) ; } } return res ; } int main ( ) { int arr [ ] = { 3 , 2 , -2 , 5 , -3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largestNum ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElement ( int A [ ] , int N , int X ) { int i = 0 ; int Comparisons = 0 ; int T = 1 ; string Found = " No " ; Comparisons ++ ; if ( N % 2 == 1 ) { i = 1 ; T *= ( A [ 0 ] - X ) ; } for ( ; i < N ; i += 2 ) { Comparisons += 1 ; T *= ( A [ i ] - X ) ; T *= ( A [ i + 1 ] - X ) ; } Comparisons += 1 ; if ( T == 0 ) { cout << " Yes ▁ " << Comparisons ; } else { cout << " No " ; } } int main ( ) { int A [ ] = { -3 , 5 , 11 , 3 , 100 , 2 , 88 , 22 , 7 , 900 , 23 , 4 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int X = 1 ; findElement ( A , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( vector < int > arr , int N , int key ) { int l = 0 ; int h = N - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] >= arr [ mid ] ) { if ( arr [ l ] >= key && key >= arr [ mid ] ) h = mid - 1 ; else l = mid + 1 ; } else { if ( arr [ mid ] >= key && key >= arr [ h ] ) l = mid + 1 ; else h = mid - 1 ; } } return -1 ; } int main ( ) { vector < int > arr = { 10 , 8 , 6 , 5 , 2 , 1 , 13 , 12 } ; int N = arr . size ( ) ; int key = 8 ; int ans = find ( arr , N , key ) ; cout << ans ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCountPairs ( int arr [ ] , int N , int S ) { map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int twice_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . find ( S - arr [ i ] ) != mp . end ( ) ) { twice_count += mp [ S - arr [ i ] ] ; } if ( S - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; } int countPairs ( int arr [ ] , int N ) { int count = 0 ; set < int > S ; for ( int i = 0 ; i < N ; i ++ ) S . insert ( arr [ i ] ) ; for ( int ele : S ) { int sum = 2 * ele ; count += getCountPairs ( arr , N , sum ) ; } return count ; } int main ( ) { int N = 6 ; int arr [ ] = { 4 , 2 , 5 , 1 , 3 , 5 } ; cout << ( countPairs ( arr , N ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumValue ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { ans = max ( ans , arr [ i ] + arr [ j ] + i - j ) ; } } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 9 , 3 , 6 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximumValue ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumValue ( int arr [ ] , int n ) { int maxvalue = arr [ 0 ] ; int result = 0 ; for ( int i = 1 ; i < n ; i ++ ) { result = max ( result , maxvalue + arr [ i ] - i ) ; maxvalue = max ( maxvalue , arr [ i ] + i ) ; } cout << result ; } int main ( ) { int arr [ ] = { 1 , 9 , 3 , 6 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximumValue ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int closestValue ( vector < int > A , int k ) { int close = A . back ( ) ; auto it = lower_bound ( A . begin ( ) , A . end ( ) , k ) ; if ( it != A . end ( ) ) { close = * it ; if ( it != A . begin ( ) ) { if ( ( k - * ( it - 1 ) ) < ( close - k ) ) { close = * ( it - 1 ) ; } } } return close ; } void minPossible ( vector < int > arr , vector < int > brr , vector < int > crr ) { sort ( arr . begin ( ) , arr . end ( ) ) ; sort ( crr . begin ( ) , crr . end ( ) ) ; int minimum = INT_MAX ; for ( int val : brr ) { int arr_close = closestValue ( arr , val ) ; int crr_close = closestValue ( crr , val ) ; if ( abs ( val - arr_close ) + abs ( val - crr_close ) < minimum ) minimum = abs ( val - arr_close ) + abs ( val - crr_close ) ; } cout << minimum ; } int main ( ) { vector < int > a = { 1 , 8 , 5 } ; vector < int > b = { 2 , 9 } ; vector < int > c = { 5 , 4 } ; minPossible ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < pair < int , int > > direction = { { 1 , 0 } , { 0 , -1 } , { -1 , 0 } , { 0 , 1 } } ; int maximumTime ( vector < vector < int > > arr ) { int n = arr . size ( ) ; int m = arr [ 0 ] . size ( ) ; vector < vector < bool > > visited ( n , vector < bool > ( m , 0 ) ) ; queue < pair < pair < int , int > , int > > q ; int uninfected_count = 0 ; int time = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr [ i ] [ j ] == 2 ) { q . push ( { { i , j } , 0 } ) ; visited [ i ] [ j ] = 1 ; } if ( arr [ i ] [ j ] == 1 ) { uninfected_count ++ ; } } } while ( ! q . empty ( ) ) { pair < pair < int , int > , int > current = q . front ( ) ; time = current . second ; q . pop ( ) ; for ( auto it : direction ) { int i = current . first . first + it . first ; int j = current . first . second + it . second ; if ( i < 0 j < 0 i > = n j > = m arr [ i ] [ j ] != 1 visited [ i ] [ j ] != 0 ) { continue ; } q . push ( { { i , j } , time + 1 } ) ; visited [ i ] [ j ] = 1 ; uninfected_count -- ; } } if ( uninfected_count != 0 ) return -1 ; return time ; } int main ( ) { vector < vector < int > > arr = { { 2 , 1 , 0 , 2 , 1 } , { 1 , 0 , 1 , 2 , 1 } , { 1 , 0 , 0 , 2 , 1 } } ; cout << maximumTime ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimum_swaps ( int arr [ ] , int n ) { int count = 0 ; int max_el = * max_element ( arr , arr + n ) ; int min_el = * min_element ( arr , arr + n ) ; if ( min_el == max_el ) return 0 ; int index_max = -1 ; int index_min = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max_el && index_max == -1 ) { index_max = i ; } if ( arr [ i ] == min_el ) { index_min = i ; } } count += index_max ; count += ( n - 1 - index_min ) ; if ( index_min < index_max ) count -= 1 ; return count ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 6 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimum_swaps ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void DFS ( int src , vector < int > Adj [ ] , int & ans , int arr [ ] , int currentMin , int currentMax ) { ans = max ( ans , max ( abs ( currentMax - arr [ src - 1 ] ) , abs ( currentMin - arr [ src - 1 ] ) ) ) ; currentMin = min ( currentMin , arr [ src - 1 ] ) ; currentMax = min ( currentMax , arr [ src - 1 ] ) ; for ( auto & child : Adj [ src ] ) { DFS ( child , Adj , ans , arr , currentMin , currentMax ) ; } } void getMaximumDifference ( int Edges [ ] [ 2 ] , int arr [ ] , int N , int M ) { vector < int > Adj [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; Adj [ u ] . push_back ( v ) ; } int ans = 0 ; DFS ( 1 , Adj , ans , arr , arr [ 0 ] , arr [ 0 ] ) ; cout << ans ; } int main ( ) { int N = 5 , M = 4 ; int Edges [ ] [ 2 ] = { { 1 , 2 } , { 2 , 3 } , { 4 , 5 } , { 1 , 3 } } ; int arr [ ] = { 13 , 8 , 3 , 15 , 18 } ; getMaximumDifference ( Edges , arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isComment ( string line ) { if ( line [ 0 ] == ' / ' && line [ 1 ] == ' / ' && line [ 2 ] != ' / ' ) { cout << " It ▁ is ▁ a ▁ single - line ▁ comment " ; return ; } if ( line [ line . size ( ) - 2 ] == ' * ' && line [ line . size ( ) - 1 ] == ' / ' && line [ 0 ] == ' / ' && line [ 1 ] == ' * ' ) { cout << " It ▁ is ▁ a ▁ multi - line ▁ comment " ; return ; } cout << " It ▁ is ▁ not ▁ a ▁ comment " ; } int main ( ) { string line = " GeeksForGeeks ▁ GeeksForGeeks " ; isComment ( line ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSequence ( int arr [ ] , int N ) { if ( N == 0 ) { cout << 0 ; return ; } sort ( arr , arr + N ) ; int maxLen = 1 ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] arr [ i ] == arr [ i - 1 ] + 1 ) { len ++ ; maxLen = max ( maxLen , len ) ; } else { len = 1 ; } } cout << maxLen ; } int main ( ) { int arr [ ] = { 8 , 5 , 4 , 8 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; longestSequence ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minSum ( int arr [ ] , int N , int Q [ ] , int M ) { for ( int i = 0 ; i < M ; i ++ ) { int val = Q [ i ] ; int front = 0 , rear = 0 ; for ( int j = 0 ; j < N ; j ++ ) { front += arr [ j ] ; if ( arr [ j ] == val ) { break ; } } for ( int j = N - 1 ; j >= 0 ; j -- ) { rear += arr [ j ] ; if ( arr [ j ] == val ) { break ; } } cout << min ( front , rear ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 2 , 3 , 6 , 7 , 4 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int Q [ ] = { 7 , 6 } ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; minSum ( arr , N , Q , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinLength ( int arr [ ] , int N ) { int front = 0 , back = N - 1 ; while ( front < back ) { int x = arr [ front ] ; if ( arr [ front ] != arr [ back ] ) break ; while ( arr [ front ] == x && front <= back ) front ++ ; while ( arr [ back ] == x && front <= back ) back -- ; } cout << back - front + 1 << endl ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 , 3 , 1 , 2 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMinLength ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void prefixArr ( int arr [ ] , int prefix [ ] [ 2 ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 ) { prefix [ i ] [ 0 ] = arr [ i ] ; prefix [ i ] [ 1 ] = arr [ i ] ; } else { prefix [ i ] [ 0 ] = max ( prefix [ i - 1 ] [ 0 ] , arr [ i ] ) ; prefix [ i ] [ 1 ] = min ( prefix [ i - 1 ] [ 1 ] , arr [ i ] ) ; } } } void suffixArr ( int arr [ ] , int suffix [ ] [ 2 ] , int N ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i == N - 1 ) { suffix [ i ] [ 0 ] = arr [ i ] ; suffix [ i ] [ 1 ] = arr [ i ] ; } else { suffix [ i ] [ 0 ] = max ( suffix [ i + 1 ] [ 0 ] , arr [ i ] ) ; suffix [ i ] [ 1 ] = min ( suffix [ i + 1 ] [ 1 ] , arr [ i ] ) ; } } } void maxAndmin ( int prefix [ ] [ 2 ] , int suffix [ ] [ 2 ] , int N , int L , int R ) { int maximum , minimum ; if ( L == 0 && R == N - 1 ) { cout << " No ▁ maximum ▁ and ▁ minimum ▁ value " << endl ; return ; } else if ( L == 0 ) { maximum = suffix [ R + 1 ] [ 0 ] ; minimum = suffix [ R + 1 ] [ 1 ] ; } else if ( R == N - 1 ) { maximum = prefix [ L - 1 ] [ 0 ] ; minimum = prefix [ R - 1 ] [ 1 ] ; } else { maximum = max ( prefix [ L - 1 ] [ 0 ] , suffix [ R + 1 ] [ 0 ] ) ; minimum = min ( prefix [ L - 1 ] [ 1 ] , suffix [ R + 1 ] [ 1 ] ) ; } cout << maximum << " ▁ " << minimum << endl ; } void MinMaxQueries ( int a [ ] , int Q [ ] [ ] ) { int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; int prefix [ N ] [ 2 ] ; int suffix [ N ] [ 2 ] ; prefixArr ( arr , prefix , N ) ; suffixArr ( arr , suffix , N ) ; for ( int i = 0 ; i < q ; i ++ ) { int L = queries [ i ] [ 0 ] ; int R = queries [ i ] [ 1 ] ; maxAndmin ( prefix , suffix , N , L , R ) ; } } int main ( ) { int arr [ ] = { 2 , 3 , 1 , 8 , 3 , 5 , 7 , 4 } ; int queries [ ] [ 2 ] = { { 4 , 6 } , { 0 , 4 } , { 3 , 7 } , { 2 , 5 } } ; MinMaxQueries ( arr , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string finddigits ( string s ) { string num [ ] = { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; vector < int > arr ( 10 ) ; string ans = " " ; int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' z ' ) arr [ 0 ] ++ ; if ( s [ i ] == ' w ' ) arr [ 2 ] ++ ; if ( s [ i ] == ' g ' ) arr [ 8 ] ++ ; if ( s [ i ] == ' x ' ) arr [ 6 ] ++ ; if ( s [ i ] == ' v ' ) arr [ 5 ] ++ ; if ( s [ i ] == ' o ' ) arr [ 1 ] ++ ; if ( s [ i ] == ' s ' ) arr [ 7 ] ++ ; if ( s [ i ] == ' f ' ) arr [ 4 ] ++ ; if ( s [ i ] == ' h ' ) arr [ 3 ] ++ ; if ( s [ i ] == ' i ' ) arr [ 9 ] ++ ; } arr [ 7 ] -= arr [ 6 ] ; arr [ 5 ] -= arr [ 7 ] ; arr [ 4 ] -= arr [ 5 ] ; arr [ 1 ] -= ( arr [ 2 ] + arr [ 4 ] + arr [ 0 ] ) ; arr [ 3 ] -= arr [ 8 ] ; arr [ 9 ] -= ( arr [ 5 ] + arr [ 6 ] + arr [ 8 ] ) ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < arr [ i ] ; j ++ ) { ans += ( char ) ( i + '0' ) ; } } return ans ; } int main ( ) { string s = " owoftnuoer " ; cout << finddigits ( s ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isBinaryStringsEqual ( string str1 , string str2 ) { int str1Zeros = 0 , str1Ones = 0 ; int str2Zeros = 0 , str2Ones = 0 ; int flag = 0 ; int curStr1Ones = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str1 [ i ] == '1' ) { str1Ones ++ ; } else if ( str1 [ i ] == '0' ) { str1Zeros ++ ; } if ( str2 [ i ] == '1' ) { str2Ones ++ ; } else if ( str2 [ i ] == '0' ) { str2Zeros ++ ; } } if ( str1Zeros != str2Zeros && str1Ones != str2Ones ) { cout << " Not ▁ Possible " ; } else { for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { if ( str1 [ i ] != str2 [ i ] ) { if ( str1 [ i ] == '0' && curStr1Ones > 0 ) { str1 [ i ] = '1' ; curStr1Ones -- ; } if ( str1 [ i ] == '0' && curStr1Ones == 0 ) { flag ++ ; break ; } if ( str1 [ i ] == '1' && str2 [ i ] == '0' ) { str1 [ i ] = '0' ; curStr1Ones ++ ; } } } if ( flag == 0 ) { cout << " Possible " ; } else { cout << " Not ▁ Possible " ; } } } int main ( ) { string str1 = "0110" ; string str2 = "0011" ; isBinaryStringsEqual ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define maxN  100 NEW_LINE using namespace std ; int Tree [ 4 * maxN ] ; void build ( int arr [ ] , int index , int s , int e ) { if ( s == e ) Tree [ index ] = arr [ s ] ; else { int m = ( s + e ) / 2 ; build ( arr , 2 * index , s , m ) ; build ( arr , 2 * index + 1 , m + 1 , e ) ; Tree [ index ] = max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) ; } } int atleast_x ( int index , int s , int e , int ql , int qr , int x ) { if ( ql > e qr < s ) return -1 ; if ( s <= ql && e <= qr ) { if ( Tree [ index ] < x ) return -1 ; while ( s != e ) { int m = ( s + e ) / 2 ; if ( Tree [ 2 * index ] >= x ) { e = m ; index = 2 * index ; } else { s = m + 1 ; index = 2 * index + 1 ; } } return s ; } int m = ( s + e ) / 2 ; int val = atleast_x ( 2 * index , s , m , ql , qr , x ) ; if ( val != -1 ) return val ; return atleast_x ( 2 * index + 1 , m + 1 , e , ql , qr , x ) ; } void update ( int index , int s , int e , int new_val , int pos ) { if ( s == e ) Tree [ index ] = new_val ; else { int m = ( s + e ) / 2 ; if ( pos <= m ) { update ( 2 * index , s , m , new_val , pos ) ; } else { update ( 2 * index + 1 , m + 1 , e , new_val , pos ) ; } Tree [ index ] = max ( Tree [ 2 * index ] , Tree [ 2 * index + 1 ] ) ; } } void printAnswer ( int * arr , int n ) { build ( arr , 1 , 0 , n - 1 ) ; cout << atleast_x ( 1 , 0 , n - 1 , 0 , n - 1 , 2 ) << " STRNEWLINE " ; arr [ 2 ] = 5 ; update ( 1 , 0 , n - 1 , 5 , 2 ) ; cout << atleast_x ( 1 , 0 , n - 1 , 0 , n - 1 , 4 ) << " STRNEWLINE " ; cout << atleast_x ( 1 , 0 , n - 1 , 0 , n - 1 , 0 ) << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAnswer ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int delCost ( string s , int cost [ ] ) { int ans = 0 ; map < char , int > forMax ; map < char , int > forTot ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! forMax [ s [ i ] ] ) { forMax [ s [ i ] ] = cost [ i ] ; } else { forMax [ s [ i ] ] = max ( cost [ i ] , forMax [ s [ i ] ] ) ; } if ( ! forTot [ s [ i ] ] ) { forTot [ s [ i ] ] = cost [ i ] ; } else { forTot [ s [ i ] ] = forTot [ s [ i ] ] + cost [ i ] ; } } for ( auto i : forMax ) { ans += forTot [ i . first ] - i . second ; } return ans ; } int main ( ) { string s = " AAABBB " ; int cost [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; cout << ( delCost ( s , cost ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct TreeNode { int val ; TreeNode * left ; TreeNode * right ; TreeNode ( int data ) { this -> val = data ; left = NULL ; right = NULL ; } } ; int find_ht ( TreeNode * root ) { if ( ! root ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return 1 ; return max ( find_ht ( root -> left ) , find_ht ( root -> right ) ) + 1 ; } void find_node ( TreeNode * root , TreeNode * & req_node ) { if ( ! root ) return ; int left_ht = find_ht ( root -> left ) ; int right_ht = find_ht ( root -> right ) ; if ( left_ht > right_ht ) { find_node ( root -> left , req_node ) ; } else if ( right_ht > left_ht ) { find_node ( root -> right , req_node ) ; } else { req_node = root ; return ; } } int main ( ) { struct TreeNode * root = new TreeNode ( 1 ) ; root -> left = new TreeNode ( 2 ) ; root -> right = new TreeNode ( 3 ) ; TreeNode * req_node = NULL ; find_node ( root , req_node ) ; cout << req_node -> val ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isSpiralSorted ( int arr [ ] , int n ) { int start = 0 ; int end = n - 1 ; while ( start < end ) { if ( arr [ start ] > arr [ end ] ) { return false ; } start ++ ; if ( arr [ end ] > arr [ start ] ) { return false ; } end -- ; } return true ; } int main ( ) { int arr [ ] = { 1 , 10 , 14 , 20 , 18 , 12 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSpiralSorted ( arr , N ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxMatch ( int A [ ] , int B [ ] , int M , int N ) { map < int , int > Aindex ; map < int , int > diff ; for ( int i = 0 ; i < M ; i ++ ) { Aindex [ A [ i ] ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { if ( i - Aindex [ B [ i ] ] < 0 ) { diff [ M + i - Aindex [ B [ i ] ] ] += 1 ; } else { diff [ i - Aindex [ B [ i ] ] ] += 1 ; } } int max = 0 ; for ( auto ele = diff . begin ( ) ; ele != diff . end ( ) ; ele ++ ) { if ( ele -> second > max ) { max = ele -> second ; } } return max ; } int main ( ) { int A [ ] = { 5 , 3 , 7 , 9 , 8 } ; int B [ ] = { 8 , 7 , 3 , 5 , 9 } ; int M = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int N = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << maxMatch ( A , B , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxNonEmpSubSeq ( int a [ ] , int n ) { int sum = 0 ; int max = * max_element ( a , a + n ) ; if ( max <= 0 ) { return max ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) { sum += a [ i ] ; } } return sum ; } int main ( ) { int arr [ ] = { -2 , 11 , -4 , 2 , -3 , -10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MaxNonEmpSubSeq ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long getcount ( long long n , int k ) { long long res = ( n >> ( k + 1 ) ) << k ; if ( ( n >> k ) & 1 ) res += n & ( ( 1ll << k ) - 1 ) ; return res ; } int main ( ) { long long int N = 14 ; int K = 2 ; cout << getcount ( N + 1 , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void splitString ( string S , int N ) { char c = S [ N - 1 ] ; int f = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] == c ) { f = 1 ; break ; } } if ( f ) cout << " Yes " ; else cout << " No " ; } int main ( ) { string S = " abcdab " ; int N = S . size ( ) ; splitString ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char longestLastingBulb ( vector < int > onTime , string s ) { char ans ; int n = onTime . size ( ) ; int maxDur = INT_MIN ; int maxPos = INT_MIN ; int currentDiff = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { currentDiff = onTime [ i ] ; maxDur = currentDiff ; maxPos = i ; } else { currentDiff = onTime [ i ] - onTime [ i - 1 ] ; if ( maxDur < currentDiff ) { maxDur = currentDiff ; maxPos = i ; } else { if ( maxDur == currentDiff ) { char one = s [ i ] ; char two = s [ maxPos ] ; if ( one > two ) { maxDur = currentDiff ; maxPos = i ; } } } } } ans = s [ maxPos ] ; return ans ; } int main ( ) { string S = " spuda " ; vector < int > arr = { 12 , 23 , 36 , 46 , 62 } ; cout << longestLastingBulb ( arr , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < pair < pair < int , int > , int > > tup ; void findIntersectingRange ( int N , int ranges [ ] [ 2 ] ) { int curr ; int currPos ; for ( int i = 0 ; i < N ; i ++ ) { int x , y ; x = ranges [ i ] [ 0 ] ; y = ranges [ i ] [ 1 ] ; tup . push_back ( { { x , y } , i + 1 } ) ; } sort ( tup . begin ( ) , tup . end ( ) ) ; curr = tup [ 0 ] . first . second ; currPos = tup [ 0 ] . second ; for ( int i = 1 ; i < N ; i ++ ) { int Q = tup [ i - 1 ] . first . first ; int R = tup [ i ] . first . first ; if ( Q == R ) { if ( tup [ i - 1 ] . first . second < tup [ i ] . first . second ) cout << tup [ i - 1 ] . second << ' ▁ ' << tup [ i ] . second ; else cout << tup [ i ] . second << ' ▁ ' << tup [ i - 1 ] . second ; return ; } int T = tup [ i ] . first . second ; if ( T <= curr ) { cout << tup [ i ] . second << ' ▁ ' << currPos ; return ; } else { curr = T ; currPos = tup [ i ] . second ; } } cout << " - 1 ▁ - 1" ; } int main ( ) { int N = 5 ; int ranges [ ] [ 2 ] = { { 1 , 5 } , { 2 , 10 } , { 3 , 10 } , { 2 , 2 } , { 2 , 15 } } ; findIntersectingRange ( N , ranges ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNGE ( int * arr , int n ) { stack < int > s ; int nge [ n ] , i = 0 ; for ( i = 0 ; i < n ; i ++ ) { nge [ i ] = -1 ; } i = 0 ; while ( i < 2 * n ) { while ( ! s . empty ( ) && arr [ i % n ] > arr [ s . top ( ) ] ) { nge [ s . top ( ) ] = arr [ i % n ] ; s . pop ( ) ; } s . push ( i % n ) ; i ++ ; } for ( i = 0 ; i < n ; i ++ ) { cout << nge [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 4 , -2 , 5 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNGE ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWordsSameRow ( vector < string > & arr ) { unordered_map < char , int > mp { { ' q ' , 1 } , { ' w ' , 1 } , { ' e ' , 1 } , { ' r ' , 1 } , { ' t ' , 1 } , { ' y ' , 1 } , { ' u ' , 1 } , { ' o ' , 1 } , { ' p ' , 1 } , { ' i ' , 1 } , { ' a ' , 2 } , { ' s ' , 2 } , { ' d ' , 2 } , { ' f ' , 2 } , { ' g ' , 2 } , { ' h ' , 2 } , { ' j ' , 2 } , { ' k ' , 2 } , { ' l ' , 2 } , { ' z ' , 3 } , { ' x ' , 3 } , { ' c ' , 3 } , { ' v ' , 3 } , { ' b ' , 3 } , { ' n ' , 3 } , { ' m ' , 3 } } ; for ( auto word : arr ) { if ( ! word . empty ( ) ) { bool flag = true ; int rowNum = mp [ tolower ( word [ 0 ] ) ] ; int M = word . length ( ) ; for ( int i = 1 ; i < M ; i ++ ) { if ( mp [ tolower ( word [ i ] ) ] != rowNum ) { flag = false ; break ; } } if ( flag ) { cout << word << " ▁ " ; } } } } int main ( ) { vector < string > words = { " Yeti " , " Had " , " GFG " , " comment " } ; findWordsSameRow ( words ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_zeroes ( int n , string str ) { int cnt = 0 ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) { if ( str [ i ] == '0' ) cnt ++ ; } return cnt ; } string kReducingStringUtil ( int n , int k , string str , int no_of_zeroes ) { int zeroes_in_2k = ( ( no_of_zeroes ) * ( 2 * k ) ) / n ; int ones_in_2k = 2 * k - zeroes_in_2k ; string temp_str = " " ; for ( int i = 0 ; i < ( zeroes_in_2k ) / 2 ; i ++ ) { temp_str . push_back ( '0' ) ; } for ( int i = 0 ; i < ones_in_2k ; i ++ ) { temp_str . push_back ( '1' ) ; } for ( int i = 0 ; i < ( zeroes_in_2k ) / 2 ; i ++ ) { temp_str . push_back ( '0' ) ; } string final_str = " " ; for ( int i = 0 ; i < n / ( 2 * k ) ; i ++ ) { final_str += ( temp_str ) ; } for ( int i = 0 ; i < n % ( 2 * k ) ; i ++ ) { final_str . push_back ( temp_str [ i ] ) ; } return final_str ; } string kReducingString ( int n , int k , string str ) { int no_of_zeroes = count_zeroes ( n , str ) ; int no_of_ones = n - no_of_zeroes ; if ( no_of_zeroes == 0 no_of_zeroes == n ) { return str ; } if ( k == 1 ) { if ( no_of_zeroes == 0 no_of_zeroes == n ) { return str ; } else { return " Not ▁ Possible " ; } } bool check = 0 ; for ( int i = ( n / k ) ; i < n ; i += ( n / k ) ) { if ( no_of_zeroes == i no_of_ones == i ) { check = 1 ; break ; } } if ( check == 0 ) { return " Not ▁ Possible " ; } return kReducingStringUtil ( n , k , str , no_of_zeroes ) ; } int main ( ) { string str = "0000100001100001" ; int K = 4 ; int N = str . length ( ) ; cout << kReducingString ( N , K , str ) ; return 0 ; }
#include <iostream> NEW_LINE #include <unordered_map> NEW_LINE using namespace std ; int countSum ( int a [ ] , int n , int sum ) { int i , j , k ; int count = 0 ; unordered_map < int , int > m ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { int temp = a [ i ] + a [ j ] ; if ( temp < sum ) count += m [ sum - temp ] ; } for ( j = 0 ; j < i ; j ++ ) { int temp = a [ i ] + a [ j ] ; if ( temp < sum ) m [ temp ] ++ ; } } return count ; } int main ( ) { int arr [ ] = { 4 , 5 , 3 , 1 , 2 , 4 } ; int S = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSum ( arr , N , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE long long int modPower ( long long int x , long long int y ) { long long int res = 1 ; x = x % MOD ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % MOD ; y = y / 2 ; x = ( x * x ) % MOD ; } return res ; } int countPairs ( long long int arr [ ] , int N ) { int pairCount = 0 ; map < long long int , int > hash ; for ( int i = 0 ; i < N ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { long long int modularInverse = modPower ( arr [ i ] , MOD - 2 ) ; pairCount += hash [ modularInverse ] ; if ( arr [ i ] == modularInverse ) { pairCount -- ; } } return pairCount / 2 ; } int main ( ) { long long int arr [ ] = { 2 , 236426 , 280311812 , 500000004 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  9 NEW_LINE bool isinRange ( int board [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( board [ i ] [ j ] <= 0 board [ i ] [ j ] > 9 ) { return false ; } } } return true ; } bool isValidSudoku ( int board [ ] [ N ] ) { if ( isinRange ( board ) == false ) { return false ; } bool unique [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ i ] [ j ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N ; i ++ ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int j = 0 ; j < N ; j ++ ) { int Z = board [ j ] [ i ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } for ( int i = 0 ; i < N - 2 ; i += 3 ) { for ( int j = 0 ; j < N - 2 ; j += 3 ) { memset ( unique , false , sizeof ( unique ) ) ; for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) { int X = i + k ; int Y = j + l ; int Z = board [ X ] [ Y ] ; if ( unique [ Z ] ) { return false ; } unique [ Z ] = true ; } } } } return true ; } int main ( ) { int board [ N ] [ N ] = { { 7 , 9 , 2 , 1 , 5 , 4 , 3 , 8 , 6 } , { 6 , 4 , 3 , 8 , 2 , 7 , 1 , 5 , 9 } , { 8 , 5 , 1 , 3 , 9 , 6 , 7 , 2 , 4 } , { 2 , 6 , 5 , 9 , 7 , 3 , 8 , 4 , 1 } , { 4 , 8 , 9 , 5 , 6 , 1 , 2 , 7 , 3 } , { 3 , 1 , 7 , 4 , 8 , 2 , 9 , 6 , 5 } , { 1 , 3 , 6 , 7 , 4 , 8 , 5 , 9 , 2 } , { 9 , 7 , 4 , 2 , 1 , 5 , 6 , 3 , 8 } , { 5 , 2 , 8 , 6 , 3 , 9 , 4 , 1 , 7 } } ; if ( isValidSudoku ( board ) ) { cout << " Valid " ; } else { cout << " Not ▁ Valid " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int computePos ( int arr [ ] , int n , int value ) { if ( value < arr [ 0 ] ) return 0 ; if ( value > arr [ n - 1 ] ) return n - 1 ; int start = 0 ; int end = n - 1 ; while ( start < end ) { int mid = ( start + end + 1 ) / 2 ; if ( arr [ mid ] >= value ) end = mid - 1 ; else start = mid ; } return start ; } void countShift ( int arr [ ] , int n , vector < vector < int > > & queries ) { for ( auto q : queries ) { int index = q [ 0 ] ; int update = q [ 1 ] ; int newElement = arr [ index ] + update ; int newIndex = computePos ( arr , n , newElement ) ; cout << abs ( newIndex - index ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; vector < vector < int > > queries = { { 0 , -1 } , { 4 , -11 } } ; countShift ( arr , N , queries ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return temp ; } void countReqNodes ( Node * root , int minNodeVal , int & ans ) { if ( root == NULL ) return ; if ( root -> key <= minNodeVal ) { minNodeVal = root -> key ; ans ++ ; } countReqNodes ( root -> left , minNodeVal , ans ) ; countReqNodes ( root -> right , minNodeVal , ans ) ; } int main ( ) { Node * root = newNode ( 8 ) ; root -> left = newNode ( 6 ) ; root -> right = newNode ( 5 ) ; root -> left -> left = newNode ( 6 ) ; root -> left -> right = newNode ( 7 ) ; root -> right -> left = newNode ( 3 ) ; root -> right -> right = newNode ( 9 ) ; int ans = 0 , minNodeVal = INT_MAX ; countReqNodes ( root , minNodeVal , ans ) ; cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minElements ( int A [ ] , int B [ ] , int N , int M ) { map < int , int > map ; for ( int i = 0 ; i < N ; i ++ ) { map [ A [ i ] ] = i ; } vector < int > subseq ; int l = 0 , r = -1 ; for ( int i = 0 ; i < M ; i ++ ) { if ( map . find ( B [ i ] ) != map . end ( ) ) { int e = map [ B [ i ] ] ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( subseq [ m ] < e ) l = m + 1 ; else r = m - 1 ; } if ( r + 1 < subseq . size ( ) ) { subseq [ r + 1 ] = e ; } else { subseq . push_back ( e ) ; } l = 0 ; r = subseq . size ( ) - 1 ; } } return N - subseq . size ( ) ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 } ; int B [ ] = { 2 , 5 , 6 , 4 , 9 , 12 } ; int M = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int N = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << minElements ( A , B , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool palindrome ( vector < int > a , int i , int j ) { while ( i < j ) { if ( a [ i ] != a [ j ] ) return false ; i ++ ; j -- ; } return true ; } int findSubArray ( vector < int > arr , int k ) { int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( palindrome ( arr , i , i + k - 1 ) ) return i ; } return -1 ; } int main ( ) { vector < int > arr = { 2 , 3 , 5 , 1 , 3 } ; int k = 4 ; int ans = findSubArray ( arr , k ) ; if ( ans == -1 ) cout << -1 << " STRNEWLINE " ; else { for ( int i = ans ; i < ans + k ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sfpa ( int V , int src , int Edges [ ] [ 3 ] , int M ) { vector < pair < int , int > > g [ V ] ; for ( int i = 0 ; i < M ; i ++ ) { int u = Edges [ i ] [ 0 ] ; int v = Edges [ i ] [ 1 ] ; int w = Edges [ i ] [ 2 ] ; g [ u ] . push_back ( { v , w } ) ; } vector < int > dist ( V , INT_MAX ) ; vector < bool > inQueue ( V , false ) ; vector < int > cnt ( V , 0 ) ; dist [ src ] = 0 ; queue < int > q ; q . push ( src ) ; inQueue [ src ] = true ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; inQueue [ u ] = false ; for ( pair < int , int > x : g [ u ] ) { int v = x . first ; int cost = x . second ; if ( dist [ v ] > dist [ u ] + cost ) { dist [ v ] = dist [ u ] + cost ; if ( ! inQueue [ v ] ) { q . push ( v ) ; inQueue [ v ] = true ; cnt [ v ] ++ ; if ( cnt [ v ] >= V ) return true ; } } } } return false ; } int main ( ) { int N = 4 ; int src = 0 ; int M = 4 ; int Edges [ ] [ 3 ] = { { 0 , 1 , 1 } , { 1 , 2 , -1 } , { 2 , 3 , -1 } , { 3 , 0 , -1 } } ; if ( sfpa ( N , src , Edges , M ) == true ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define INF  99999 NEW_LINE int floyd_warshall ( int * graph , int V ) { int dist [ V ] [ V ] , i , j , k ; for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { dist [ i ] [ j ] = * ( ( graph + i * V ) + j ) ; } } for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) { dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; } } } } int sum = 0 ; for ( i = 0 ; i < V ; i ++ ) { for ( j = i + 1 ; j < V ; j ++ ) { sum += dist [ i ] [ j ] ; } } return sum ; } int sumOfshortestPath ( int N , int E , int edges [ ] [ 3 ] ) { int g [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { g [ i ] [ j ] = INF ; } } for ( int i = 0 ; i < E ; i ++ ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; int w = edges [ i ] [ 2 ] ; g [ u ] [ v ] = w ; g [ v ] [ u ] = w ; } return floyd_warshall ( ( int * ) g , N ) ; } int main ( ) { int N = 4 ; int E = 3 ; int Edges [ ] [ 3 ] = { { 0 , 1 , 1 } , { 1 , 2 , 2 } , { 2 , 3 , 3 } } ; cout << sumOfshortestPath ( N , E , Edges ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void print_kth_string ( string s , int K ) { int N = s . length ( ) ; int i ; for ( i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' ▁ ' ) K -- ; if ( K == 1 ) break ; } while ( i ++ < N && s [ i ] != ' ▁ ' ) cout << s [ i ] ; } int main ( ) { string s ( "10 ▁ 20 ▁ 30 ▁ 40" ) ; int K = 4 ; print_kth_string ( s , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minPeaks ( vector < int > list ) { int n = list . size ( ) ; vector < int > result ; for ( int i = 0 ; i < n ; i ++ ) { int min = INT_MAX ; int index = -1 ; int size = list . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { if ( j == 0 && j + 1 < size ) { if ( list [ j ] > list [ j + 1 ] && min > list [ j ] ) { min = list [ j ] ; index = j ; } } else if ( j == size - 1 && j - 1 >= 0 ) { if ( list [ j ] > list [ j - 1 ] && min > list [ j ] ) { min = list [ j ] ; index = j ; } } else if ( size == 1 ) { min = list [ j ] ; index = j ; } else if ( list [ j ] > list [ j - 1 ] && list [ j ] > list [ j + 1 ] && min > list [ j ] ) { min = list [ j ] ; index = j ; } } list . erase ( list . begin ( ) + index ) ; result . push_back ( min ) ; } cout << " [ " ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { cout << result [ i ] << " , ▁ " ; } cout << " ] " ; } int main ( ) { vector < int > arr = { 1 , 9 , 7 , 8 , 2 , 6 } ; minPeaks ( arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int N , int X ) { int start = 0 ; int end = N ; while ( start <= end ) { int mid = start + ( end - start ) / 2 ; if ( X == arr [ mid ] ) { return mid ; } else if ( X < arr [ mid ] ) { start = mid + 1 ; } else { end = mid - 1 ; } } return -1 ; } int main ( ) { int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 5 ; cout << binarySearch ( arr , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check_both_present ( int arr [ ] , int N , int a , int b ) { bool f1 = false , f2 = false ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == a ) { f1 = true ; } if ( arr [ i ] == b ) { f2 = true ; } } if ( f1 && f2 ) { return true ; } else { return false ; } } void print_array ( int ans [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } void build_AP ( int N , int a , int b ) { int arr [ N ] , ans [ N ] ; for ( int i = 0 ; i < N ; i ++ ) ans [ i ] = INT_MAX ; int flag = 0 ; if ( a > b ) { swap ( a , b ) ; } int diff = b - a ; for ( int start = 1 ; start <= a ; start ++ ) { for ( int d = 1 ; d <= diff ; d ++ ) { arr [ 0 ] = start ; for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] = arr [ i - 1 ] + d ; } if ( check_both_present ( arr , N , a , b ) && arr [ N - 1 ] < ans [ N - 1 ] ) { for ( int i = 0 ; i < N ; i ++ ) { ans [ i ] = arr [ i ] ; } } } } print_array ( ans , N ) ; } int main ( ) { int N = 5 , A = 20 , B = 50 ; build_AP ( N , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string isPrefixOfWord ( string sentence , string Word ) { stringstream ss ( sentence ) ; vector < string > v ; string temp ; while ( ss >> temp ) { v . push_back ( temp ) ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = 0 ; j < v [ i ] . size ( ) ; j ++ ) { if ( v [ i ] [ j ] != Word [ j ] ) break ; else if ( j == Word . size ( ) - 1 ) return v [ i ] ; } } return " - 1" ; } int main ( ) { string s = " Welcome ▁ to ▁ Geeksforgeeks " ; string word = " Gee " ; cout << isPrefixOfWord ( s , word ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Pair { int idx ; string psf ; int jmps ; } ; void minJumps ( int arr [ ] , int dp [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = INT_MAX ; dp [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int steps = arr [ i ] ; int min = INT_MAX ; for ( int j = 1 ; j <= steps && i + j < n ; j ++ ) { if ( dp [ i + j ] != INT_MAX && dp [ i + j ] < min ) { min = dp [ i + j ] ; } } if ( min != INT_MAX ) dp [ i ] = min + 1 ; } } void possiblePath ( int arr [ ] , int dp [ ] , int n ) { queue < Pair > Queue ; Pair p1 = { 0 , "0" , dp [ 0 ] } ; Queue . push ( p1 ) ; while ( Queue . size ( ) > 0 ) { Pair tmp = Queue . front ( ) ; Queue . pop ( ) ; if ( tmp . jmps == 0 ) { cout << tmp . psf << " STRNEWLINE " ; continue ; } for ( int step = 1 ; step <= arr [ tmp . idx ] ; step ++ ) { if ( tmp . idx + step < n && tmp . jmps - 1 == dp [ tmp . idx + step ] ) { string s1 = tmp . psf + " ▁ - > ▁ " + to_string ( ( tmp . idx + step ) ) ; Pair p2 = { tmp . idx + step , s1 , tmp . jmps - 1 } ; Queue . push ( p2 ) ; } } } } void Solution ( int arr [ ] , int dp [ ] , int size ) { minJumps ( arr , dp , size ) ; possiblePath ( arr , dp , size ) ; } int main ( ) { int arr [ ] = { 3 , 3 , 0 , 2 , 1 , 2 , 4 , 2 , 0 , 0 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int dp [ size ] ; Solution ( arr , dp , size ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void EvenLIS ( int arr [ ] , int n ) { int lis [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( abs ( arr [ i ] ) > abs ( arr [ j ] ) && abs ( arr [ i ] ) % 2 == 0 && abs ( arr [ j ] ) % 2 == 0 && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } int maxlen = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxlen = max ( maxlen , lis [ i ] ) ; cout << maxlen << endl ; } int main ( ) { int arr [ ] = { 11 , -22 , 43 , -54 , 66 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; EvenLIS ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left ; Node * right ; Node ( int val ) { data = val ; left = right = NULL ; } } ; int Sum ( Node * root , int & res ) { if ( root == NULL ) { return 0 ; } int leftSubSum = Sum ( root -> left , res ) ; int rightSubSum = Sum ( root -> right , res ) ; if ( root -> left and root -> right && leftSubSum == rightSubSum ) res += 1 ; return root -> data + leftSubSum + rightSubSum ; } int main ( ) { Node * root = new Node ( 9 ) ; root -> left = new Node ( 2 ) ; root -> left -> left = new Node ( -1 ) ; root -> left -> right = new Node ( 3 ) ; root -> right = new Node ( 4 ) ; root -> right -> right = new Node ( 0 ) ; int res = 0 ; Sum ( root , res ) ; cout << res ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left ; Node * right ; Node ( int val ) { data = val ; left = right = NULL ; } } ; void PrintAlternate ( Node * root ) { queue < Node * > Q ; Q . push ( root ) ; while ( ! Q . empty ( ) ) { int N = Q . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Node * temp = Q . front ( ) ; Q . pop ( ) ; if ( i % 2 == 0 ) { cout << temp -> data << " ▁ " ; } if ( temp -> left ) { Q . push ( temp -> left ) ; } if ( temp -> right ) { Q . push ( temp -> right ) ; } } cout << endl ; } } int main ( ) { Node * root ; root = new Node ( 71 ) ; root -> left = new Node ( 88 ) ; root -> right = new Node ( 99 ) ; root -> left -> left = new Node ( 4 ) ; root -> left -> right = new Node ( 5 ) ; root -> right -> left = new Node ( 6 ) ; root -> right -> right = new Node ( 7 ) ; root -> left -> left -> left = new Node ( 8 ) ; root -> left -> left -> right = new Node ( 9 ) ; root -> left -> right -> left = new Node ( 10 ) ; root -> left -> right -> right = new Node ( 11 ) ; root -> right -> left -> right = new Node ( 13 ) ; root -> right -> right -> left = new Node ( 14 ) ; PrintAlternate ( root ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > countingSubarray ( vector < int > arr , int n ) { vector < int > a ( n ) ; vector < int > nsml ( n , -1 ) ; vector < int > nsmr ( n , n ) ; stack < int > st ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! st . empty ( ) && arr [ st . top ( ) ] >= arr [ i ] ) st . pop ( ) ; nsmr [ i ] = ( ! st . empty ( ) ) ? st . top ( ) : n ; st . push ( i ) ; } while ( ! st . empty ( ) ) st . pop ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! st . empty ( ) && arr [ st . top ( ) ] >= arr [ i ] ) st . pop ( ) ; nsml [ i ] = ( ! st . empty ( ) ) ? st . top ( ) : -1 ; st . push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { nsml [ i ] ++ ; nsmr [ i ] -- ; int r = nsmr [ i ] - i + 1 ; int l = i - nsml [ i ] + 1 ; a [ i ] = r * l ; } return a ; } int main ( ) { int N = 5 ; vector < int > arr = { 3 , 2 , 4 , 1 , 5 } ; auto a = countingSubarray ( arr , N ) ; cout << " [ " ; int n = a . size ( ) - 1 ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " , ▁ " ; cout << a [ n ] << " ] " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string reorderString ( string A , string B ) { int size_a = A . length ( ) ; int size_b = B . length ( ) ; int freq [ 300 ] = { 0 } ; for ( int i = 0 ; i < size_b ; i ++ ) freq [ B [ i ] ] ++ ; for ( int i = 0 ; i < size_a ; i ++ ) freq [ A [ i ] ] -- ; for ( int j = ' a ' ; j <= ' z ' ; j ++ ) { if ( freq [ j ] < 0 ) return " - 1" ; } string answer ; for ( int j = ' a ' ; j < A [ 0 ] ; j ++ ) while ( freq [ j ] > 0 ) { answer . push_back ( j ) ; freq [ j ] -- ; } int first = A [ 0 ] ; for ( int j = 0 ; j < size_a ; j ++ ) { if ( A [ j ] > A [ 0 ] ) break ; if ( A [ j ] < A [ 0 ] ) { answer += A ; A . clear ( ) ; break ; } } while ( freq [ first ] > 0 ) { answer . push_back ( first ) ; -- freq [ first ] ; } answer += A ; for ( int j = ' a ' ; j <= ' z ' ; j ++ ) while ( freq [ j ] -- ) answer . push_back ( j ) ; return answer ; } int main ( ) { string A = " aa " ; string B = " ababab " ; cout << reorderString ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool cmp ( vector < int > a , vector < int > b ) { if ( a [ 0 ] != b [ 0 ] ) return a [ 0 ] < b [ 0 ] ; return a [ 1 ] - b [ 1 ] ; } void maxConcurrentMeetingSlot ( vector < vector < int > > meetings ) { sort ( meetings . begin ( ) , meetings . end ( ) , cmp ) ; priority_queue < int , vector < int > , greater < int > > pq ; pq . push ( meetings [ 0 ] [ 1 ] ) ; int max_len = 0 , max_start = 0 ; int max_end = 0 ; for ( auto k : meetings ) { while ( pq . size ( ) > 0 && k [ 0 ] >= pq . top ( ) ) pq . pop ( ) ; pq . push ( k [ 1 ] ) ; if ( pq . size ( ) > max_len ) { max_len = pq . size ( ) ; max_start = k [ 0 ] ; max_end = pq . top ( ) ; } } cout << max_start << " ▁ " << max_end ; } int main ( ) { vector < vector < int > > meetings = { { 100 , 200 } , { 50 , 300 } , { 300 , 400 } } ; maxConcurrentMeetingSlot ( meetings ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int func ( int n ) { int count = 0 ; if ( n == 2 or n == 1 ) return 1 ; if ( n % 2 == 0 ) count = 1 + func ( n / 2 ) ; if ( n % 2 != 0 ) count = 1 + func ( n * 3 + 1 ) ; return count ; } void findKthElement ( int l , int r , int k ) { vector < int > arr ; for ( int i = l ; i <= r ; i ++ ) arr . push_back ( i ) ; vector < vector < int > > result ; for ( int i : arr ) result . push_back ( { i , func ( i ) } ) ; sort ( result . begin ( ) , result . end ( ) ) ; cout << ( result [ k - 1 ] [ 0 ] ) ; } int main ( ) { int l = 12 ; int r = 15 ; int k = 2 ; findKthElement ( l , r , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkHex ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s [ i ] ; if ( ( ch < '0' ch > '9' ) && ( ch < ' A ' ch > ' F ' ) ) { cout << " No " << endl ; return ; } } cout << " Yes " << endl ; } int main ( ) { string s = " BF57C " ; checkHex ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxWidth ( int N , int M , vector < int > cost , vector < vector < int > > s ) { vector < int > adj [ N ] ; for ( int i = 0 ; i < M ; i ++ ) { adj [ s [ i ] [ 0 ] ] . push_back ( s [ i ] [ 1 ] ) ; } int result = 0 ; queue < int > q ; q . push ( 0 ) ; while ( ! q . empty ( ) ) { int count = q . size ( ) ; result = max ( count , result ) ; while ( count -- ) { int temp = q . front ( ) ; q . pop ( ) ; for ( int i = 0 ; i < adj [ temp ] . size ( ) ; i ++ ) { q . push ( adj [ temp ] [ i ] ) ; } } } return result ; } int main ( ) { int N = 11 , M = 10 ; vector < vector < int > > edges ; edges . push_back ( { 0 , 1 } ) ; edges . push_back ( { 0 , 2 } ) ; edges . push_back ( { 0 , 3 } ) ; edges . push_back ( { 1 , 4 } ) ; edges . push_back ( { 1 , 5 } ) ; edges . push_back ( { 3 , 6 } ) ; edges . push_back ( { 4 , 7 } ) ; edges . push_back ( { 6 , 10 } ) ; edges . push_back ( { 6 , 8 } ) ; edges . push_back ( { 6 , 9 } ) ; vector < int > cost = { 1 , 2 , -1 , 3 , 4 , 5 , 8 , 2 , 6 , 12 , 7 } ; cout << maxWidth ( N , M , cost , edges ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } int LISPrime ( int arr [ ] , int n ) { int lisp [ n ] ; bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , N ) ; lisp [ 0 ] = prime [ arr [ 0 ] ] ? 1 : 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { lisp [ i ] = 0 ; continue ; } lisp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( prime [ arr [ j ] ] && arr [ i ] > arr [ j ] && lisp [ i ] < lisp [ j ] + 1 ) { lisp [ i ] = lisp [ j ] + 1 ; } } } return * max_element ( lisp , lisp + n ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 3 , 2 , 5 , 1 , 7 } ; int M = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << LISPrime ( arr , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } unsigned long int findWays ( unsigned n ) { if ( n & 1 ) return 0 ; return catalan ( n / 2 ) ; } void countNonNPeriodic ( int N ) { cout << findWays ( 2 * N ) - findWays ( N ) ; } int main ( ) { int N = 4 ; countNonNPeriodic ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkSameDiag ( int li [ 6 ] [ 5 ] , int x , int y , int m , int n ) { int I = 0 , J = 0 ; int P = 0 , Q = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( li [ i ] [ j ] == x ) { I = i ; J = j ; } if ( li [ i ] [ j ] == y ) { P = i ; Q = j ; } } } if ( P - Q == I - J P + Q == I + J ) { cout << " YES " ; } else cout << " NO " ; } int main ( ) { int m = 6 ; int n = 5 ; int li [ 6 ] [ 5 ] = { { 32 , 94 , 99 , 26 , 82 } , { 51 , 69 , 52 , 63 , 17 } , { 90 , 36 , 88 , 55 , 33 } , { 93 , 42 , 73 , 39 , 28 } , { 81 , 31 , 83 , 53 , 10 } , { 12 , 29 , 85 , 80 , 87 } } ; int x = 42 ; int y = 80 ; checkSameDiag ( li , x , y , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isValid ( int n , int m , int k ) { int step2 = n - m ; int cnt = ( step2 * ( step2 + 1 ) ) / 2 ; if ( cnt - m == k ) return 0 ; if ( cnt - m > k ) return 1 ; return -1 ; } void countOfOperations ( int n , int k ) { int start = 0 , end = n ; bool ok = 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; int temp = isValid ( n , mid , k ) ; if ( temp == 0 ) { ok = 0 ; cout << mid ; break ; } else if ( temp == 1 ) { start = mid + 1 ; } else { end = mid - 1 ; } } if ( ok ) cout << " - 1" ; } int main ( ) { int N = 5 , K = 4 ; countOfOperations ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool nonLower ( string s ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( ! islower ( s [ i ] ) ) { return true ; } } return false ; } void printCodes ( vector < string > output ) { for ( int i = 0 ; i < output . size ( ) ; i ++ ) { if ( nonLower ( output [ i ] ) ) continue ; cout << ( output [ i ] ) << endl ; } } char getChar ( int n ) { return ( char ) ( n + 96 ) ; } vector < string > getCode ( string str ) { if ( str . size ( ) == 0 ) { vector < string > ans ; ans . push_back ( " " ) ; return ans ; } vector < string > output1 = getCode ( str . substr ( 1 ) ) ; vector < string > output2 ( 0 ) ; int firstDigit = ( str [ 0 ] - '0' ) ; int firstTwoDigit = 0 ; if ( str . size ( ) >= 2 ) { firstTwoDigit = ( str [ 0 ] - '0' ) * 10 + ( str [ 1 ] - '0' ) ; if ( firstTwoDigit >= 10 && firstTwoDigit <= 26 ) { output2 = getCode ( str . substr ( 2 ) ) ; } } vector < string > output ( output1 . size ( ) + output2 . size ( ) ) ; int k = 0 ; for ( int i = 0 ; i < output1 . size ( ) ; i ++ ) { char ch = getChar ( firstDigit ) ; output [ i ] = ch + output1 [ i ] ; k ++ ; } for ( int i = 0 ; i < output2 . size ( ) ; i ++ ) { char ch = getChar ( firstTwoDigit ) ; output [ k ] = ch + output2 [ i ] ; k ++ ; } return output ; } int main ( ) { string input = "101" ; vector < string > output = getCode ( input ) ; printCodes ( output ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isprm ( int n ) { if ( n <= 1 ) return 0 ; if ( n <= 3 ) return 1 ; if ( n % 2 == 0 n % 3 == 0 ) return 0 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) return 0 ; } return 1 ; } int countprime ( int n ) { int count = 0 ; vector < int > primevector ; for ( int i = 2 ; i <= n ; i ++ ) { if ( isprm ( i ) == 1 ) { primevector . push_back ( i ) ; } } int sum = primevector [ 0 ] ; for ( int i = 1 ; i < primevector . size ( ) ; i ++ ) { sum += primevector [ i ] ; if ( sum > n ) break ; if ( isprm ( sum ) == 1 ) { count ++ ; } } return count ; } int main ( ) { int N = 45 ; cout << countprime ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int TEN = 10 ; void updateFreq ( int n , int freq [ ] ) { while ( n ) { int digit = n % TEN ; freq [ digit ] ++ ; n /= TEN ; } } bool areAnagrams ( int a , int b ) { int freqA [ TEN ] = { 0 } ; int freqB [ TEN ] = { 0 } ; updateFreq ( a , freqA ) ; updateFreq ( b , freqB ) ; for ( int i = 0 ; i < TEN ; i ++ ) { if ( freqA [ i ] != freqB [ i ] ) return false ; } return true ; } bool isPowerOf2 ( int N ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( areAnagrams ( 1 << i , N ) ) { cout << ( 1 << i ) ; return true ; } } return false ; } int main ( ) { int N = 46 ; if ( ! isPowerOf2 ( N ) ) { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int right_angled ( int n ) { int count = 0 ; for ( int z = 1 ; z <= n ; z ++ ) { for ( int y = 1 ; y <= z ; y ++ ) { for ( int x = 1 ; x <= y ; x ++ ) { if ( ( x * x ) + ( y * y ) == ( z * z ) ) { count ++ ; } } } } return count ; } int main ( ) { int n = 5 ; cout << right_angled ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( string s ) { int cnt = 0 ; for ( char c : s ) { cnt += c == '0' ? 1 : 0 ; } if ( cnt % 3 != 0 ) return 0 ; int res = 0 , k = cnt / 3 , sum = 0 ; map < int , int > mp ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += s [ i ] == '0' ? 1 : 0 ; if ( sum == 2 * k && mp . find ( k ) != mp . end ( ) && i < s . length ( ) - 1 && i > 0 ) { res += mp [ k ] ; } mp [ sum ] ++ ; } return res ; } int main ( ) { string str = "01010" ; cout << count ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dfs ( int src , int dest , int * vis , vector < int > * adj ) { vis [ src ] = 1 ; if ( src == dest ) { return 1 ; } for ( int u : adj [ src ] ) { if ( ! vis [ u ] ) { int temp = dfs ( u , dest , vis , adj ) ; if ( temp != 0 ) { return temp + 1 ; } } } return 0 ; } int countNodes ( int V , int E , int src , int dest , int edges [ ] [ 2 ] ) { vector < int > adj [ V + 1 ] ; for ( int i = 0 ; i < E ; i ++ ) { adj [ edges [ i ] [ 0 ] ] . push_back ( edges [ i ] [ 1 ] ) ; adj [ edges [ i ] [ 1 ] ] . push_back ( edges [ i ] [ 0 ] ) ; } int vis [ V + 1 ] = { 0 } ; int count = dfs ( src , dest , vis , adj ) ; return count - 2 ; } int main ( ) { int V = 8 , E = 7 ; int src = 5 , dest = 2 ; int edges [ ] [ 2 ] = { { 1 , 4 } , { 4 , 5 } , { 4 , 2 } , { 2 , 6 } , { 6 , 3 } , { 2 , 7 } , { 3 , 8 } } ; cout << countNodes ( V , E , src , dest , edges ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll GCD ( ll a , ll b ) { if ( a == 0 ) return b ; return GCD ( b % a , a ) ; } ll LCM ( ll a , ll b ) { return ( a * b ) / GCD ( a , b ) ; } void checkPairwiseCoPrime ( int A [ ] , int n ) { ll prod = 1 ; ll lcm = 1 ; for ( int i = 0 ; i < n ; i ++ ) { prod *= A [ i ] ; lcm = LCM ( A [ i ] , lcm ) ; } if ( prod == lcm ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { int A [ ] = { 2 , 3 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; checkPairwiseCoPrime ( A , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDiffSubsets ( int arr [ ] , int N ) { int totalSum = 0 ; bool pos = false , neg = false ; int min = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += abs ( arr [ i ] ) ; if ( arr [ i ] > 0 ) pos = true ; if ( arr [ i ] < 0 ) neg = true ; if ( arr [ i ] < min ) min = arr [ i ] ; } if ( pos && neg ) return totalSum ; else return totalSum - 2 * min ; } int main ( ) { int S [ ] = { 1 , 2 , 1 } ; int N = sizeof ( S ) / sizeof ( S [ 0 ] ) ; if ( N < 2 ) cout << ( " Not ▁ Possible " ) ; else cout << ( maxDiffSubsets ( S , N ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDiffSubArray ( int arr [ ] , int n ) { int prefix_sum [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; int suffix_sum [ n ] ; suffix_sum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix_sum [ i ] = suffix_sum [ i + 1 ] + arr [ i ] ; int minDiff = INT_MAX ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int diff = abs ( prefix_sum [ i ] - suffix_sum [ i + 1 ] ) ; if ( diff < minDiff ) minDiff = diff ; } return minDiff ; } int main ( ) { int arr [ ] = { 7 , 9 , 5 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minDiffSubArray ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void dailyTemperatures ( vector < int > & T ) { int n = T . size ( ) ; vector < int > daysOfWait ( n , -1 ) ; stack < int > s ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && T [ s . top ( ) ] < T [ i ] ) { daysOfWait [ s . top ( ) ] = i - s . top ( ) ; s . pop ( ) ; } s . push ( i ) ; } for ( int i = 0 ; i < n ; i ++ ) { cout << daysOfWait [ i ] << " ▁ " ; } } int main ( ) { vector < int > arr { 73 , 74 , 75 , 71 , 69 , 72 , 76 , 73 } ; dailyTemperatures ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int timeT = 0 ; void dfs ( int u , int p , int dis , vector < int > & vis , vector < int > & distance , vector < int > & parent , vector < int > & preTime , vector < int > & postTime , vector < int > Adj [ ] ) { distance [ u ] = dis ; parent [ u ] = p ; vis [ u ] = 1 ; timeT ++ ; preTime [ u ] = timeT ; for ( int i = 0 ; i < Adj [ u ] . size ( ) ; i ++ ) { if ( vis [ Adj [ u ] [ i ] ] == 0 ) { dfs ( Adj [ u ] [ i ] , u , dis + 1 , vis , distance , parent , preTime , postTime , Adj ) ; } } timeT ++ ; postTime [ u ] = timeT ; } void addEdge ( vector < int > Adj [ ] , int u , int v ) { Adj [ u ] . push_back ( v ) ; Adj [ v ] . push_back ( u ) ; } void findNodeU ( int N , int V , int Vertices [ ] , int Edges [ ] [ 2 ] ) { vector < int > vis ( N + 1 , 0 ) ; vector < int > distance ( N + 1 , 0 ) ; vector < int > parent ( N + 1 , 0 ) ; vector < int > preTime ( N + 1 , 0 ) ; vector < int > postTime ( N + 1 , 0 ) ; vector < int > Adj [ N + 1 ] ; int u , v ; for ( int i = 0 ; i < N - 1 ; i ++ ) { addEdge ( Adj , Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) ; } dfs ( 1 , 0 , 0 , vis , distance , parent , preTime , postTime , Adj ) ; int maximumDistance = 0 ; maximumDistance = 0 ; for ( int k = 0 ; k < V ; k ++ ) { if ( maximumDistance < distance [ Vertices [ k ] ] ) { maximumDistance = distance [ Vertices [ k ] ] ; u = Vertices [ k ] ; } if ( parent [ Vertices [ k ] ] != 0 ) { Vertices [ k ] = parent [ Vertices [ k ] ] ; } } bool ans = true ; bool flag ; for ( int k = 0 ; k < V ; k ++ ) { if ( preTime [ Vertices [ k ] ] <= preTime [ u ] && postTime [ Vertices [ k ] ] >= postTime [ u ] ) flag = true ; else flag = false ; ans = ans & flag ; } if ( ans ) cout << u ; else cout << " NO " ; } int main ( ) { int N = 10 ; int V = 5 ; int Vertices [ ] = { 4 , 3 , 8 , 9 , 10 } ; int Edges [ ] [ 2 ] = { { 1 , 2 } , { 1 , 3 } , { 1 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 7 } , { 7 , 8 } , { 7 , 9 } , { 9 , 10 } } ; findNodeU ( N , V , Vertices , Edges ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ans = 0 , allsum = 0 ; vector < int > edges [ 100001 ] ; void addedge ( int a , int b ) { edges [ a ] . push_back ( b ) ; edges [ b ] . push_back ( a ) ; } void findCost ( int r , int p , int arr [ ] ) { int i , cur ; for ( i = 0 ; i < edges [ r ] . size ( ) ; i ++ ) { cur = edges [ r ] . at ( i ) ; if ( cur == p ) continue ; findCost ( cur , r , arr ) ; arr [ r ] += arr [ cur ] ; } int t1 = arr [ r ] ; int t2 = allsum - t1 ; if ( t1 * t2 > ans ) { ans = t1 * t2 ; } } void maximumCost ( int r , int p , int N , int M , int arr [ ] , int Edges [ ] [ 2 ] ) { for ( int i = 0 ; i < N ; i ++ ) { allsum += arr [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { addedge ( Edges [ i ] [ 0 ] , Edges [ i ] [ 1 ] ) ; } findCost ( r , p , arr ) ; } int main ( ) { int a , b , N = 6 ; int arr [ ] = { 13 , 8 , 7 , 4 , 5 , 9 } ; int M = 5 ; int Edges [ ] [ 2 ] = { { 0 , 1 } , { 1 , 2 } , { 1 , 4 } , { 3 , 4 } , { 4 , 5 } } ; maximumCost ( 1 , -1 , N , M , arr , Edges ) ; cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define int  long long int NEW_LINE using namespace std ; const int inf = 1e18 ; int minimumReplacement ( int * arr , int N , int K ) { int ans = inf ; vector < int > max_values ; vector < int > min_values ; map < int , int > sum_equal_to_x ; for ( int i = 0 ; i < N / 2 ; i ++ ) { int mn = min ( arr [ i ] , arr [ N - i - 1 ] ) ; int mx = max ( arr [ i ] , arr [ N - i - 1 ] ) ; sum_equal_to_x [ arr [ i ] + arr [ N - i - 1 ] ] ++ ; min_values . push_back ( mn ) ; max_values . push_back ( mx ) ; } sort ( max_values . begin ( ) , max_values . end ( ) ) ; sort ( min_values . begin ( ) , min_values . end ( ) ) ; for ( int x = 2 ; x <= 2 * K ; x ++ ) { int mp1 = lower_bound ( max_values . begin ( ) , max_values . end ( ) , x - K ) - max_values . begin ( ) ; int mp2 = lower_bound ( min_values . begin ( ) , min_values . end ( ) , x ) - min_values . begin ( ) ; int rep2 = mp1 + ( N / 2 - mp2 ) ; int rep0 = sum_equal_to_x [ x ] ; int rep1 = ( N / 2 - rep2 - rep0 ) ; ans = min ( ans , rep2 * 2 + rep1 ) ; } return ans ; } int32_t main ( ) { int N = 4 ; int K = 3 ; int arr [ ] = { 1 , 2 , 2 , 1 } ; cout << minimumReplacement ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxsubstringLength ( string S , int N ) { int arr [ N ] ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' S [ i ] == ' e ' S [ i ] == ' i ' S [ i ] == ' o ' S [ i ] == ' u ' ) arr [ i ] = 1 ; else arr [ i ] = -1 ; int maxLen = 0 ; int curr_sum = 0 ; unordered_map < int , int > hash ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum += arr [ i ] ; if ( curr_sum == 0 ) maxLen = max ( maxLen , i + 1 ) ; if ( hash . find ( curr_sum ) != hash . end ( ) ) maxLen = max ( maxLen , i - hash [ curr_sum ] ) ; else hash [ curr_sum ] = i ; } return maxLen ; } int main ( ) { string S = " geeksforgeeks " ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; cout << maxsubstringLength ( S , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unordered_map < int , bool > mp ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } bool deleteNode ( int nodeVal ) { return mp . find ( nodeVal ) != mp . end ( ) ; } Node * treePruning ( Node * root , vector < Node * > & result ) { if ( root == NULL ) return NULL ; root -> left = treePruning ( root -> left , result ) ; root -> right = treePruning ( root -> right , result ) ; if ( deleteNode ( root -> key ) ) { if ( root -> left ) { result . push_back ( root -> left ) ; } if ( root -> right ) { result . push_back ( root -> right ) ; } return NULL ; } return root ; } void printInorderTree ( Node * root ) { if ( root == NULL ) return ; printInorderTree ( root -> left ) ; cout << root -> key << " ▁ " ; printInorderTree ( root -> right ) ; } void printForests ( Node * root , int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] ] = true ; } vector < Node * > result ; if ( treePruning ( root , result ) ) result . push_back ( root ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { printInorderTree ( result [ i ] ) ; cout << endl ; } } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 12 ) ; root -> right = newNode ( 13 ) ; root -> right -> left = newNode ( 14 ) ; root -> right -> right = newNode ( 15 ) ; root -> right -> left -> left = newNode ( 21 ) ; root -> right -> left -> right = newNode ( 22 ) ; root -> right -> right -> left = newNode ( 23 ) ; root -> right -> right -> right = newNode ( 24 ) ; int arr [ ] = { 14 , 23 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printForests ( root , arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDistance ( int arr [ ] , int K , int N ) { map < int , int > Map ; int maxDist = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( Map . find ( arr [ i ] ) == Map . end ( ) ) Map [ arr [ i ] ] = i ; if ( Map . find ( arr [ i ] + K ) != Map . end ( ) ) { maxDist = max ( maxDist , i - Map [ arr [ i ] + K ] ) ; } if ( Map . find ( arr [ i ] - K ) != Map . end ( ) ) { maxDist = max ( maxDist , i - Map [ arr [ i ] - K ] ) ; } } if ( maxDist == 0 ) return -1 ; else return maxDist ; } int main ( ) { int arr [ ] = { 11 , 2 , 3 , 8 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << maxDistance ( arr , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int n ) { int ans = 0 ; for ( int y = n + 1 ; y <= n * n + n ; y ++ ) { if ( ( n * n ) % ( y - n ) == 0 ) { ans += 1 ; } } cout << ans ; } int main ( ) { int n = 5 ; solve ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long reverse ( long num ) { long rev = 0 ; while ( num > 0 ) { int r = ( int ) ( num % 10 ) ; rev = rev * 10 + r ; num /= 10 ; } return rev ; } long count ( int N , int A , int B ) { long l = ( long ) pow ( 10 , N - 1 ) , r = ( long ) pow ( 10 , N ) - 1 ; if ( l == 1 ) l = 0 ; long ans = 0 ; for ( long i = l ; i <= r ; i ++ ) { int even_sum = 0 , odd_sum = 0 ; long itr = 0 , num = reverse ( i ) ; while ( num > 0 ) { if ( itr % 2 == 0 ) odd_sum += num % 10 ; else even_sum += num % 10 ; num /= 10 ; itr ++ ; } if ( even_sum % A == 0 && odd_sum % B == 0 ) ans ++ ; } return ans ; } int main ( ) { int N = 2 , A = 5 , B = 3 ; cout << ( count ( N , A , B ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < int > > constructTree ( int n , vector < vector < int > > edges ) { vector < vector < int > > adjl ( n ) ; for ( auto e : edges ) { int u = e [ 0 ] ; int v = e [ 1 ] ; adjl [ u ] . push_back ( v ) ; adjl [ v ] . push_back ( u ) ; } return adjl ; } void DFS ( vector < vector < int > > adjl , vector < int > & parent , int u , int p ) { parent [ u ] = p ; for ( int v : adjl [ u ] ) { if ( v != p ) { DFS ( adjl , parent , v , u ) ; } } } vector < int > valuesFromChildren ( vector < int > parent , vector < int > values ) { vector < int > valuesChildren ( parent . size ( ) ) ; for ( int i = 0 ; i < parent . size ( ) ; i ++ ) { if ( parent [ i ] == -1 ) continue ; else { int p = parent [ i ] ; valuesChildren [ p ] += values [ i ] ; } } return valuesChildren ; } int findSumOfValues ( int v , vector < int > parent , vector < int > valuesChildren ) { int cur_node = v ; int sum = 0 ; while ( cur_node != -1 ) { sum += valuesChildren [ cur_node ] ; cur_node = parent [ cur_node ] ; } return sum ; } int main ( ) { int n = 8 ; vector < vector < int > > edges = { { 0 , 1 } , { 0 , 2 } , { 0 , 3 } , { 1 , 4 } , { 1 , 5 } , { 4 , 7 } , { 3 , 6 } } ; int v = 7 ; vector < int > values = { 1 , 2 , 3 , 0 , 0 , 4 , 3 , 6 } ; vector < vector < int > > adjl = constructTree ( n , edges ) ; vector < int > parent ( n ) ; DFS ( adjl , parent , 0 , -1 ) ; vector < int > valuesChildren = valuesFromChildren ( parent , values ) ; int sum = findSumOfValues ( v , parent , valuesChildren ) ; sum += values [ 0 ] ; cout << sum << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) return true ; return false ; } void countSubstrings ( string s , int n ) { int temp [ ] = { 1 , 0 } ; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum += ( isVowel ( s [ i ] ) ? 1 : 0 ) ; sum %= 2 ; temp [ sum ] ++ ; } result += ( ( temp [ 0 ] * ( temp [ 0 ] - 1 ) ) / 2 ) ; result += ( ( temp [ 1 ] * ( temp [ 1 ] - 1 ) ) / 2 ) ; cout << result ; } int main ( ) { int n = 5 ; string s = " abcde " ; countSubstrings ( s , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( int key ) { Node * temp = new Node ; temp -> key = key ; temp -> left = temp -> right = NULL ; return ( temp ) ; } int findLevel ( Node * root , int k , int level ) { queue < pair < Node * , int > > qt ; qt . push ( make_pair ( root , 0 ) ) ; int count = 1 , b , a = 0 ; while ( ! qt . empty ( ) ) { pair < Node * , int > temp = qt . front ( ) ; qt . pop ( ) ; if ( count == 1 ) { b = temp . second ; } if ( ( temp . first ) -> left ) { qt . push ( make_pair ( temp . first -> left , 2 * temp . second ) ) ; } if ( temp . first -> right ) { qt . push ( make_pair ( temp . first -> right , 2 * temp . second + 1 ) ) ; } count -- ; if ( count == 0 ) { if ( b - a + 1 == k ) return level ; pair < Node * , int > secondLabel = qt . front ( ) ; a = secondLabel . second ; level += 1 ; count = qt . size ( ) ; } } return -1 ; } int main ( ) { Node * root = newNode ( 5 ) ; root -> left = newNode ( 6 ) ; root -> right = newNode ( 2 ) ; root -> right -> right = newNode ( 8 ) ; root -> left -> left = newNode ( 7 ) ; root -> left -> left -> left = newNode ( 5 ) ; root -> left -> right = newNode ( 3 ) ; root -> left -> right -> right = newNode ( 4 ) ; int k = 4 ; cout << findLevel ( root , k , 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool possible ( int arr [ ] , int N , int mid , int K ) { int add = 0 ; for ( int i = N / 2 - ( N + 1 ) % 2 ; i < N ; ++ i ) { if ( mid - arr [ i ] > 0 ) { add += ( mid - arr [ i ] ) ; if ( add > K ) return false ; } } if ( add <= K ) return true ; else return false ; } int findMaxMedian ( int arr [ ] , int N , int K ) { int low = 1 ; int mx = 0 ; for ( int i = 0 ; i < N ; ++ i ) { mx = max ( mx , arr [ i ] ) ; } long long int high = K + mx ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( possible ( arr , N , mid , K ) ) { low = mid + 1 ; } else { high = mid - 1 ; } } if ( N % 2 == 0 ) { if ( low - 1 < arr [ N / 2 ] ) { return ( arr [ N / 2 ] + low - 1 ) / 2 ; } } return low - 1 ; } int main ( ) { int arr [ ] = { 1 , 3 , 6 } ; int K = 10 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort ( arr , arr + N ) ; cout << findMaxMedian ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define LL  long long NEW_LINE bool countLessThanMid ( LL mid , LL N , LL M , LL K ) { LL count = 0 ; for ( int i = 1 ; i <= min ( ( LL ) N , mid ) ; ++ i ) { count = count + min ( mid / i , M ) ; } if ( count >= K ) return false ; else return true ; } LL findKthElement ( LL N , LL M , LL K ) { LL low = 1 , high = N * M ; while ( low <= high ) { LL mid = low + ( high - low ) / 2 ; if ( countLessThanMid ( mid , N , M , K ) ) low = mid + 1 ; else high = mid - 1 ; } return high + 1 ; } int main ( ) { LL N = 2 , M = 3 ; LL int K = 5 ; cout << findKthElement ( N , M , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string S , int K ) { int ans = 0 ; for ( int i = 0 ; i < K ; i ++ ) { int zero = 0 , one = 0 ; for ( int j = i ; j < S . size ( ) ; j += K ) { if ( S [ j ] == '0' ) zero ++ ; else one ++ ; } ans += min ( zero , one ) ; } return ans ; } int main ( ) { string S = "110100101" ; int K = 3 ; cout << minOperations ( S , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSubString ( string S , char C ) { int count = 0 ; int conCount = 0 ; for ( char ch : S ) { if ( ch == C ) conCount ++ ; else { count += ( conCount * ( conCount + 1 ) ) / 2 ; conCount = 0 ; } } count += ( conCount * ( conCount + 1 ) ) / 2 ; cout << count ; } int main ( ) { string S = " geeksforgeeks " ; char C = ' e ' ; countSubString ( S , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int N , vector < string > & s ) { map < vector < int > , int > mp ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { vector < int > a ( 26 , 0 ) ; for ( int j = 0 ; j < s [ i ] . size ( ) ; j ++ ) { a [ s [ i ] [ j ] - ' a ' ] ++ ; } for ( int j = 0 ; j < 26 ; j ++ ) { a [ j ] = a [ j ] % 2 ; } ans += mp [ a ] ; for ( int j = 0 ; j < 26 ; j ++ ) { vector < int > changedCount = a ; if ( a [ j ] == 0 ) changedCount [ j ] = 1 ; else changedCount [ j ] = 0 ; ans += mp [ changedCount ] ; } mp [ a ] ++ ; } return ans ; } int main ( ) { int N = 6 ; vector < string > A = { " aab " , " abcac " , " dffe " , " ed " , " aa " , " aade " } ; cout << getCount ( N , A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } bool KSmallestPerfectBST ( Node * root , int k , int treeSize , int & kth_smallest ) { if ( root == NULL ) return false ; int median_loc = ( treeSize / 2 ) + 1 ; if ( k == median_loc ) { kth_smallest = root -> key ; return true ; } int newTreeSize = treeSize / 2 ; if ( k < median_loc ) { return KSmallestPerfectBST ( root -> left , k , newTreeSize , kth_smallest ) ; } int newK = k - median_loc ; return KSmallestPerfectBST ( root -> right , newK , newTreeSize , kth_smallest ) ; } int main ( ) { Node * root = NULL ; root = insert ( root , 50 ) ; insert ( root , 30 ) ; insert ( root , 20 ) ; insert ( root , 40 ) ; insert ( root , 70 ) ; insert ( root , 60 ) ; insert ( root , 80 ) ; insert ( root , 14 ) ; insert ( root , 25 ) ; insert ( root , 35 ) ; insert ( root , 45 ) ; insert ( root , 55 ) ; insert ( root , 65 ) ; insert ( root , 75 ) ; insert ( root , 85 ) ; int n = 15 , k = 5 ; int ans = -1 ; if ( KSmallestPerfectBST ( root , k , n , ans ) ) { cout << ans << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkrules ( string s ) { if ( s . length ( ) == 0 ) return true ; if ( s [ 0 ] != '1' ) return false ; if ( s . length ( ) > 2 ) { if ( s [ 1 ] == '0' && s [ 2 ] == '0' ) return checkrules ( s . substr ( 3 ) ) ; } return checkrules ( s . substr ( 1 ) ) ; } int main ( ) { string str = "1111" ; if ( checkrules ( str ) ) { cout << " Valid ▁ String " ; } else { cout << " Invalid ▁ String " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isNudeNum ( int n ) { int copy , length , flag = 0 ; copy = n ; string temp ; temp = to_string ( copy ) ; length = temp . length ( ) ; for ( int i = 0 ; i < length ; i ++ ) { int num = temp [ i ] - '0' ; if ( num == 0 or n % num != 0 ) { flag = 1 ; } } if ( flag == 1 ) return false ; else return true ; } int longestNudeSubseq ( int arr [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isNudeNum ( arr [ i ] ) ) answer ++ ; } return answer ; } int main ( ) { int arr [ ] = { 34 , 34 , 2 , 2 , 3 , 333 , 221 , 32 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestNudeSubseq ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubarray ( int a [ ] , int n ) { int l [ n ] ; int r [ n ] ; for ( int i = 0 , count = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) count ++ ; else { l [ i ] = count ; count = 0 ; } } for ( int i = n - 1 , count = 0 ; i >= 0 ; i -- ) { if ( a [ i ] == 1 ) count ++ ; else { r [ i ] = count ; count = 0 ; } } int ans = -1 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] == 0 ) ans = max ( ans , l [ i ] + r [ i ] ) ; } return ans < 0 ? n : ans ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestSubarray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSide ( int a [ ] , int n ) { int sideLength = 0 ; sort ( a , a + n ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] > sideLength ) { sideLength ++ ; } else { break ; } } cout << sideLength << endl ; } int main ( ) { int N = 6 ; int arr [ ] = { 3 , 2 , 1 , 5 , 2 , 4 } ; maxSide ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE void minDiff ( vector < ll > a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) a . push_back ( a [ i ] * 2 ) ; } sort ( a . begin ( ) , a . end ( ) ) ; ll mindifference = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < a . size ( ) ; i ++ ) { mindifference = min ( mindifference , a [ i ] - a [ i - 1 ] ) ; } cout << mindifference << endl ; } int main ( ) { vector < ll > arr = { 3 , 8 , 13 , 30 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minDiff ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > v ; int bin ( int val , int k , int n ) { int lo = 0 ; int hi = n ; int mid ; int ans = -1 ; while ( lo <= hi ) { mid = lo + ( hi - lo ) / 2 ; if ( v [ mid ] - val <= k ) { lo = mid + 1 ; ans = mid ; } else hi = mid - 1 ; } return ans ; } void findSubarraySumK ( int arr [ ] , int N , int K ) { int sum = 0 ; v . push_back ( 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; v . push_back ( sum ) ; } int l = 0 , ans = 0 , r ; for ( int i = 0 ; i < N ; i ++ ) { r = bin ( v [ i ] , K , N ) ; ans = max ( ans , r - i ) ; } cout << ans ; } int main ( ) { int arr [ ] = { 6 , 8 , 14 , 9 , 4 , 11 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 13 ; findSubarraySumK ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingElement ( int arr [ ] , int n ) { int max_ele = arr [ 0 ] ; int min_ele = arr [ 0 ] ; int x = 0 ; int d ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; if ( arr [ i ] < min_ele ) min_ele = arr [ i ] ; } d = ( max_ele - min_ele ) / n ; for ( int i = 0 ; i < n ; i ++ ) { x = x ^ arr [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) { x = x ^ ( min_ele + ( i * d ) ) ; } return x ; } int main ( ) { int arr [ ] = { 12 , 3 , 6 , 15 , 18 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int element = missingElement ( arr , n ) ; cout << element ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int splitArray ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int result = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { result = min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; } int main ( ) { int arr [ ] = { 3 , 1 , 2 , 6 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << splitArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findValue ( int R , int C ) { int k = ( R * ( R - 1 ) ) / 2 + 1 ; int diff = R + 1 ; for ( int i = 1 ; i < C ; i ++ ) { k = ( k + diff ) ; diff ++ ; } return k ; } int main ( ) { int R = 4 ; int C = 4 ; int k = findValue ( R , C ) ; cout << k ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  4 NEW_LINE int FindColumn ( int mat [ N ] [ M ] ) { int row = 0 , col = M - 1 ; int flag = 0 ; while ( row < N && col >= 0 ) { if ( mat [ row ] [ col ] == 1 ) { col -- ; flag = 1 ; } else { row ++ ; } } col ++ ; if ( flag ) return col + 1 ; else return -1 ; } int main ( ) { int mat [ N ] [ M ] = { { 0 , 0 , 0 , 1 } , { 0 , 1 , 1 , 1 } , { 0 , 0 , 1 , 1 } } ; cout << FindColumn ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int N , int M ) { int m = M ; map < int , int > remLen ; int len , remainder ; for ( len = 1 ; len <= N + 1 ; ++ len ) { remainder = M % N ; if ( remLen . find ( remainder ) == remLen . end ( ) ) remLen [ remainder ] = len ; else break ; M = M * 10 + m ; M = M % N ; } int LenA = len ; int LenB = remLen [ remainder ] ; for ( int i = 0 ; i < LenB ; ++ i ) cout << m ; cout << " ▁ " ; for ( int i = 0 ; i < LenA ; ++ i ) cout << m ; return ; } int main ( ) { int N = 8 , M = 2 ; findNumbers ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findSmallest ( string s ) { int len = s . size ( ) ; int loccur [ 26 ] ; memset ( loccur , -1 , sizeof ( loccur ) ) ; for ( int i = len - 1 ; i >= 0 ; -- i ) { int chI = s [ i ] - ' a ' ; if ( loccur [ chI ] == -1 ) { loccur [ chI ] = i ; } } string sorted_s = s ; sort ( sorted_s . begin ( ) , sorted_s . end ( ) ) ; for ( int i = 0 ; i < len ; ++ i ) { if ( s [ i ] != sorted_s [ i ] ) { int chI = sorted_s [ i ] - ' a ' ; int last_occ = loccur [ chI ] ; swap ( s [ i ] , s [ last_occ ] ) ; break ; } } return s ; } int main ( ) { string s = " geeks " ; cout << findSmallest ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int segment_tree [ 4 * 1000000 ] ; int build ( int * A , int start , int end , int node ) { if ( start == end ) segment_tree [ node ] = A [ start ] ; else { int mid = ( start + end ) / 2 ; segment_tree [ node ] = max ( build ( A , start , mid , 2 * node + 1 ) , build ( A , mid + 1 , end , 2 * node + 2 ) ) ; } return segment_tree [ node ] ; } int query ( int start , int end , int l , int r , int node ) { if ( start > r end < l ) return -1 ; if ( start >= l && end <= r ) return segment_tree [ node ] ; int mid = ( start + end ) / 2 ; return max ( query ( start , mid , l , r , 2 * node + 1 ) , query ( mid + 1 , end , l , r , 2 * node + 2 ) ) ; } int longestSubArray ( int * A , int N , int K ) { int res = 1 ; int preSum [ N + 1 ] ; preSum [ 0 ] = A [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) preSum [ i + 1 ] = preSum [ i ] + A [ i ] ; build ( A , 0 , N - 1 , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { int start = i , end = N - 1 , mid , max_index = i ; while ( start <= end ) { mid = ( start + end ) / 2 ; int max_element = query ( 0 , N - 1 , i , mid , 0 ) ; int expected_sum = ( mid - i + 1 ) * max_element ; int actual_sum = preSum [ mid + 1 ] - preSum [ i ] ; if ( expected_sum - actual_sum <= K ) { start = mid + 1 ; max_index = max ( max_index , mid ) ; } else { end = mid - 1 ; } } res = max ( res , max_index - i + 1 ) ; } return res ; } int main ( ) { int arr [ ] = { 2 , 0 , 4 , 6 , 7 } , K = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestSubArray ( arr , N , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countNums ( int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { int lastDigit = ( i % 10 ) ; if ( ( lastDigit % 10 ) == 2 || ( lastDigit % 10 ) == 3 || ( lastDigit % 10 ) == 9 ) { cnt ++ ; } } return cnt ; } int main ( ) { int l = 11 , r = 33 ; cout << countNums ( l , r ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumK ( int a [ ] , int n , int s ) { int maximum = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { maximum = max ( maximum , a [ i ] ) ; } int low = 1 , high = maximum + 1 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ( int ) ( a [ i ] / mid ) ; } if ( sum > s ) low = mid + 1 ; else { ans = min ( ans , mid ) ; high = mid - 1 ; } } return ans ; } int main ( ) { int a [ ] = { 10 , 7 , 8 , 10 , 12 , 19 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int s = 27 ; cout << findMinimumK ( a , n , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int SparseTable [ 100001 ] [ 51 ] ; void buildSparseTable ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { SparseTable [ i ] [ 0 ] = a [ i ] ; } for ( int j = 1 ; j <= 19 ; j ++ ) { for ( int i = 0 ; i <= n - ( 1 << j ) ; i ++ ) { SparseTable [ i ] [ j ] = __gcd ( SparseTable [ i ] [ j - 1 ] , SparseTable [ i + ( 1 << ( j - 1 ) ) ] [ j - 1 ] ) ; } } } int queryForGCD ( int L , int R ) { int returnValue ; int j = int ( log2 ( R - L + 1 ) ) ; returnValue = __gcd ( SparseTable [ L ] [ j ] , SparseTable [ R - ( 1 << j ) + 1 ] [ j ] ) ; return returnValue ; } int nextPosition ( int tempGCD , int startPointer , int prevEndPointer , int n ) { int high = n - 1 ; int low = prevEndPointer ; int mid = prevEndPointer ; int nextPos = prevEndPointer ; while ( high >= low ) { mid = ( ( high + low ) >> 1 ) ; if ( queryForGCD ( startPointer , mid ) == tempGCD ) { nextPos = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return nextPos + 1 ; } int calculateSum ( int a [ ] , int n ) { buildSparseTable ( a , n ) ; int endPointer , startPointer , prevEndPointer , tempGCD ; int tempAns = 0 ; for ( int i = 0 ; i < n ; i ++ ) { endPointer = i ; startPointer = i ; prevEndPointer = i ; tempGCD = a [ i ] ; while ( endPointer < n ) { endPointer = nextPosition ( tempGCD , startPointer , prevEndPointer , n ) ; tempAns += ( ( endPointer - prevEndPointer ) * tempGCD ) ; prevEndPointer = endPointer ; if ( endPointer < n ) { tempGCD = __gcd ( tempGCD , a [ endPointer ] ) ; } } } return tempAns ; } int main ( ) { int n = 6 ; int a [ ] = { 2 , 2 , 2 , 3 , 5 , 5 } ; cout << calculateSum ( a , n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int partition ( int arr [ ] , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j <= high - 1 ; j ++ ) { if ( arr [ j ] <= pivot ) { i ++ ; swap ( arr [ i ] , arr [ j ] ) ; } } swap ( arr [ i + 1 ] , arr [ high ] ) ; return ( i + 1 ) ; } int kthSmallest ( int a [ ] , int left , int right , int k ) { while ( left <= right ) { int pivotIndex = partition ( a , left , right ) ; if ( pivotIndex == k - 1 ) return a [ pivotIndex ] ; else if ( pivotIndex > k - 1 ) right = pivotIndex - 1 ; else left = pivotIndex + 1 ; } return -1 ; } int main ( ) { int arr [ ] = { 10 , 4 , 5 , 8 , 11 , 6 , 26 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << " K - th ▁ smallest ▁ element ▁ is ▁ " << kthSmallest ( arr , 0 , n - 1 , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Max_Sum ( int arr [ ] , int n , int k ) { int p = n ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= k ) { p = i ; break ; } } int maxsum = 0 , a , b ; for ( int i = 0 ; i < p ; i ++ ) { for ( int j = i + 1 ; j < p ; j ++ ) { if ( arr [ i ] + arr [ j ] < k and arr [ i ] + arr [ j ] > maxsum ) { maxsum = arr [ i ] + arr [ j ] ; a = arr [ i ] ; b = arr [ j ] ; } } } cout << a << " ▁ " << b ; } int main ( ) { int arr [ ] = { 5 , 20 , 110 , 100 , 10 } , k = 85 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Max_Sum ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str , int i , int j ) { while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; } int maxLenPalindrome ( string str , int n , char ch ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ch ) { for ( int j = n - 1 ; j >= i ; j -- ) { if ( str [ j ] == ch ) { if ( isPalindrome ( str , i , j ) ) { maxLen = max ( maxLen , j - i + 1 ) ; break ; } } } } } return maxLen ; } int main ( ) { string str = " lapqooqpqpl " ; int n = str . length ( ) ; char ch = ' p ' ; cout << maxLenPalindrome ( str , n , ch ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE void countingsort ( string & s ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count [ s [ i ] - ' a ' ] ++ ; } int index = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { int j = 0 ; while ( j < count [ i ] ) { s [ index ++ ] = i + ' a ' ; j ++ ; } } } bool isPossible ( vector < string > v , string str ) { countingsort ( str ) ; for ( int i = 0 ; i < v . size ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < v . size ( ) ; j ++ ) { string temp = v [ i ] + v [ j ] ; countingsort ( temp ) ; if ( temp . compare ( str ) == 0 ) { return true ; } } } return false ; } int main ( ) { string str = " amazon " ; vector < string > v { " fds " , " oxq " , " zoa " , " epw " , " amn " } ; if ( isPossible ( v , str ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  256 NEW_LINE int freq [ MAX ] [ MAX ] ; void preCalculate ( string str , int n ) { freq [ ( int ) str [ 0 ] ] [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str [ i ] ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = j ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } } int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; } string firstNonRepeating ( string str , int n , int l , int r ) { char t [ 2 ] = " " ; for ( int i = l ; i < r ; i ++ ) { char ch = str [ i ] ; if ( getFrequency ( ch , l , r ) == 1 ) { t [ 0 ] = ch ; return t ; } } return " - 1" ; } int main ( ) { string str = " GeeksForGeeks " ; int n = str . length ( ) ; int queries [ ] [ 2 ] = { { 0 , 3 } , { 2 , 3 } , { 5 , 12 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; freq [ MAX ] [ n ] = { 0 } ; preCalculate ( str , n ) ; for ( int i = 0 ; i < q ; i ++ ) cout << firstNonRepeating ( str , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( string s , int n ) { int ans = INT_MIN ; vector < int > A , L , R ; int freq [ n + 5 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { int count = 0 ; memset ( freq , 0 , sizeof freq ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( s [ j ] - ' a ' == i ) count ++ ; freq [ j ] = count ; } for ( int j = 0 ; j < n ; j ++ ) { L . push_back ( ( 2 * freq [ j - 1 ] ) - j ) ; R . push_back ( ( 2 * freq [ j ] ) - j ) ; } int max_len = INT_MIN ; int min_val = INT_MAX ; for ( int j = 0 ; j < n ; j ++ ) { min_val = min ( min_val , L [ j ] ) ; A . push_back ( min_val ) ; int l = 0 , r = j ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; if ( A [ mid ] <= R [ j ] ) { max_len = max ( max_len , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } } ans = max ( ans , max_len ) ; A . clear ( ) ; R . clear ( ) ; L . clear ( ) ; } return ans ; } int main ( ) { string s = " ababbbacbcbcca " ; int n = s . length ( ) ; cout << maxLength ( s , n ) << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Printksubstring ( string str , int n , int k ) { int total = ( n * ( n + 1 ) ) / 2 ; if ( k > total ) { printf ( " - 1 STRNEWLINE " ) ; return ; } int substring [ n + 1 ] ; substring [ 0 ] = 0 ; int temp = n ; for ( int i = 1 ; i <= n ; i ++ ) { substring [ i ] = substring [ i - 1 ] + temp ; temp -- ; } int l = 1 ; int h = n ; int start = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( substring [ m ] > k ) { start = m ; h = m - 1 ; } else if ( substring [ m ] < k ) l = m + 1 ; else { start = m ; break ; } } int end = n - ( substring [ start ] - k ) ; for ( int i = start - 1 ; i < end ; i ++ ) cout << str [ i ] ; } int main ( ) { string str = " abc " ; int k = 4 ; int n = str . length ( ) ; Printksubstring ( str , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n , int K ) { int maximum = INT_MIN ; int sum [ n ] = { 0 } ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i + K < n ) sum [ i ] = sum [ i + K ] + arr [ i ] ; else sum [ i ] = arr [ i ] ; maximum = max ( maximum , sum [ i ] ) ; } return maximum ; } int main ( ) { int arr [ ] = { 3 , 6 , 4 , 7 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << maxSum ( arr , n , K ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( string s1 , int n1 , string s2 , int n2 ) { int freq1 [ 26 ] = { 0 } ; int freq2 [ 26 ] = { 0 } ; int i , count = 0 ; for ( i = 0 ; i < n1 ; i ++ ) freq1 [ s1 [ i ] - ' a ' ] ++ ; for ( i = 0 ; i < n2 ; i ++ ) freq2 [ s2 [ i ] - ' a ' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) count += ( min ( freq1 [ i ] , freq2 [ i ] ) ) ; return count ; } int main ( ) { string s1 = " geeksforgeeks " , s2 = " platformforgeeks " ; int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; cout << countPairs ( s1 , n1 , s2 , n2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findpair ( int l , int r ) { int c = 0 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { cout << i << " , ▁ " << j ; c = 1 ; break ; } } if ( c == 1 ) break ; } } int main ( ) { int l = 1 , r = 10 ; findpair ( l , r ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int arr [ ] , int N , int K ) { set < int > unique ; for ( int i = 0 ; i < N ; i ++ ) unique . insert ( arr [ i ] ) ; if ( unique . size ( ) == K ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; if ( check ( arr , N , K ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minIndex ( int arr [ ] , int n , int pos ) { int num = arr [ pos ] ; int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; } int main ( ) { int arr [ ] = { 2 , 1 , 1 , 1 , 5 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int pos = 4 ; cout << minIndex ( arr , n , pos ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minIndex ( int arr [ ] , int pos ) { int low = 0 ; int high = pos ; int i = pos ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] != arr [ pos ] ) { low = mid + 1 ; } else { high = mid - 1 ; i = mid ; if ( mid > 0 && arr [ mid - 1 ] != arr [ pos ] ) { break ; } } } return arr [ low ] == arr [ pos ] ? low : i ; } int main ( ) { int arr [ ] = { 2 , 1 , 1 , 1 , 5 , 2 } ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findAnswer ( string str1 , string str2 , int n ) { int l , r ; int ans = 2 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str1 [ i ] != str2 [ i ] ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str1 [ i ] != str2 [ i ] ) { r = i ; break ; } } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 [ i ] != str2 [ i - 1 ] ) { ans -- ; break ; } } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 [ i - 1 ] != str2 [ i ] ) { ans -- ; break ; } } return ans ; } } int main ( ) { string str1 = " toy " , str2 = " try " ; int n = str1 . length ( ) ; cout << findAnswer ( str1 , str2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDifference ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return min ( diff1 , diff2 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinDifference ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDifference ( int arr [ ] , int n ) { int min__ , secondMin , max__ , secondMax ; min__ = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max__ = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max__ ) { secondMax = max__ ; max__ = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min__ ) { secondMin = min__ ; min__ = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } int diff = min ( max__ - secondMin , secondMax - min__ ) ; return diff ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( findMinDifference ( arr , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallest_pair ( int a [ ] , int n ) { int min = INT_MAX , secondMin = INT_MAX ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << smallest_pair ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestsubarray ( int arr [ ] , int n , int k ) { int current_count = 0 ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = max ( current_count , max_count ) ; } return max_count ; } int main ( ) { int arr [ ] = { 2 , 5 , 11 , 32 , 64 , 88 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 8 ; cout << longestsubarray ( arr , n , k ) ; return 0 ; }
#include " iostream " NEW_LINE #include " unordered _ map " NEW_LINE using namespace std ; void removeElements ( int arr [ ] , int n , int k ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; ++ i ) { if ( mp [ arr [ i ] ] >= k ) { cout << arr [ i ] << " ▁ " ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; removeElements ( arr , n , k ) ; return 0 ; }
#include " iostream " NEW_LINE #include " unordered _ map " NEW_LINE using namespace std ; void RemoveElements ( int arr [ ] , int n , int k ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ arr [ i ] ] ++ ; } for ( int i = 0 ; i < n ; ++ i ) { if ( mp [ arr [ i ] ] <= k ) { cout << arr [ i ] << " ▁ " ; } } } int main ( int argc , char const * argv [ ] ) { int arr [ ] = { 1 , 2 , 2 , 3 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; RemoveElements ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int majorityInMatrix ( int arr [ N ] [ M ] ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { mp [ arr [ i ] [ j ] ] ++ ; } } int countMajority = 0 ; for ( auto itr = mp . begin ( ) ; itr != mp . end ( ) ; itr ++ ) { if ( itr -> second >= ( ( N * M ) / 2 ) ) { countMajority ++ ; } } return countMajority ; } int main ( ) { int mat [ N ] [ M ] = { { 1 , 2 , 2 } , { 1 , 3 , 2 } , { 1 , 2 , 6 } } ; cout << majorityInMatrix ( mat ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; } int main ( ) { int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 8 } ; int size = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << " Missing ▁ number : " << search ( ar , size ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int deleteElement ( int A [ ] , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; } int main ( ) { int A [ ] = { 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 } ; int L = 2 , R = 7 ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int res_size = deleteElement ( A , L , R , n ) ; for ( int i = 0 ; i < res_size ; i ++ ) cout << A [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFirst ( int arr [ ] , int n , int x ) { sort ( arr , arr + n ) ; int * ptr = lower_bound ( arr , arr + n , x ) ; return ( * ptr != x ) ? -1 : ( ptr - arr ) ; } int main ( ) { int x = 20 , arr [ ] = { 10 , 30 , 20 , 50 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findFirst ( arr , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFirst ( int arr [ ] , int n , int x ) { int count = 0 ; bool isX = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) isX = true ; else if ( arr [ i ] < x ) count ++ ; } return ( isX == false ) ? -1 : count ; } int main ( ) { int x = 20 , arr [ ] = { 10 , 30 , 20 , 50 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findFirst ( arr , n , x ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findDuplicate ( int arr [ ] ) { int slow = arr [ 0 ] ; int fast = arr [ 0 ] ; do { slow = arr [ slow ] ; fast = arr [ arr [ fast ] ] ; } while ( slow != fast ) ; int ptr1 = arr [ 0 ] ; int ptr2 = slow ; while ( ptr1 != ptr2 ) { ptr1 = arr [ ptr1 ] ; ptr2 = arr [ ptr2 ] ; } return ptr1 ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 1 } ; cout << findDuplicate ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_CHAR  26 NEW_LINE void printGreaterCount ( string str ) { int len = str . length ( ) ; int ans [ len ] = { 0 } , count [ MAX_CHAR ] = { 0 } ; for ( int i = len - 1 ; i >= 0 ; i -- ) { count [ str [ i ] - ' a ' ] ++ ; for ( int j = str [ i ] - ' a ' + 1 ; j < MAX_CHAR ; j ++ ) ans [ i ] += count [ j ] ; } for ( int i = 0 ; i < len ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { string str = " abcd " ; printGreaterCount ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPairs ( int arr [ ] , int n , int sum ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int rem = sum - arr [ i ] ; if ( m . find ( rem ) != m . end ( ) ) { int count = m [ rem ] ; for ( int j = 0 ; j < count ; j ++ ) cout << " ( " << rem << " , ▁ " << arr [ i ] << " ) " << endl ; } m [ arr [ i ] ] ++ ; } } int main ( ) { int arr [ ] = { 1 , 5 , 7 , -1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; printPairs ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int M , int N ) { int count = 0 ; if ( M == 1 ) return N ; if ( N == 1 ) return M ; if ( N > M ) { for ( int i = 1 ; i <= M ; i ++ ) { int numerator = N * i - N + M - i ; int denominator = M - 1 ; if ( numerator % denominator == 0 ) { int j = numerator / denominator ; if ( j >= 1 && j <= N ) count ++ ; } } } else { for ( int j = 1 ; j <= N ; j ++ ) { int numerator = M * j - M + N - j ; int denominator = N - 1 ; if ( numerator % denominator == 0 ) { int i = numerator / denominator ; if ( i >= 1 && i <= M ) count ++ ; } } } return count ; } int main ( ) { int M = 3 , N = 5 ; cout << getCount ( M , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTripletsLessThanL ( int n , int L , int * arr ) { sort ( arr , arr + n ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 3 ; int ans = countTripletsLessThanL ( n , L , arr ) ; cout << " Total ▁ Number ▁ of ▁ ways ▁ = ▁ " << ans << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binary_lower ( int value , int arr [ ] , int n ) { int start = 0 ; int end = n - 1 ; int ans = -1 ; int mid ; while ( start <= end ) { mid = ( start + end ) / 2 ; if ( arr [ mid ] >= value ) { end = mid - 1 ; ans = mid ; } else { start = mid + 1 ; } } return ans ; } int countTriplet ( int arr [ ] , int n , int k ) { int count = 0 ; sort ( arr , arr + n ) ; for ( int i = 2 ; i < n ; i ++ ) { int cur = binary_lower ( arr [ i ] - k , arr , n ) ; if ( cur <= i - 2 ) { count += ( ( i - cur ) * ( i - cur - 1 ) ) / 2 ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 2 , 3 } ; int k = 1 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countTriplet ( arr , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void replaceOriginal ( string s , int n ) { string r ( n , ' ▁ ' ) ; for ( int i = 0 ; i < n ; i ++ ) { r [ i ] = s [ n - 1 - i ] ; if ( s [ i ] != ' a ' && s [ i ] != ' e ' && s [ i ] != ' i ' && s [ i ] != ' o ' && s [ i ] != ' u ' ) { cout << r [ i ] ; } } cout << endl ; } int main ( ) { string s = " geeksforgeeks " ; int n = s . length ( ) ; replaceOriginal ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool swapElement ( int arr1 [ ] , int arr2 [ ] , int n ) { int wrongIdx = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr1 [ i - 1 ] ) wrongIdx = i ; int maximum = INT_MIN ; int maxIdx = -1 ; bool res = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr2 [ i ] > maximum && arr2 [ i ] >= arr1 [ wrongIdx - 1 ] ) { if ( wrongIdx + 1 <= n - 1 && arr2 [ i ] <= arr1 [ wrongIdx + 1 ] ) { maximum = arr2 [ i ] ; maxIdx = i ; res = true ; } } } if ( res ) swap ( arr1 [ wrongIdx ] , arr2 [ maxIdx ] ) ; return res ; } void getSortedArray ( int arr1 [ ] , int arr2 [ ] , int n ) { if ( swapElement ( arr1 , arr2 , n ) ) for ( int i = 0 ; i < n ; i ++ ) cout << arr1 [ i ] << " ▁ " ; else cout << " Not ▁ Possible " << endl ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 7 , 4 , 10 } ; int arr2 [ ] = { 2 , 1 , 6 , 8 , 9 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; getSortedArray ( arr1 , arr2 , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  1000 NEW_LINE struct Node { int start , end ; int length ; int insertionEdge [ 26 ] ; int suffixEdge ; } ; Node root1 , root2 ; Node tree [ MAXN ] ; int currNode ; string s ; int ptr ; void insert ( int currIndex ) { int temp = currNode ; while ( true ) { int currLength = tree [ temp ] . length ; if ( currIndex - currLength >= 1 && ( s [ currIndex ] == s [ currIndex - currLength - 1 ] ) ) break ; temp = tree [ temp ] . suffixEdge ; } if ( tree [ temp ] . insertionEdge [ s [ currIndex ] - ' a ' ] != 0 ) { currNode = tree [ temp ] . insertionEdge [ s [ currIndex ] - ' a ' ] ; return ; } ptr ++ ; tree [ temp ] . insertionEdge [ s [ currIndex ] - ' a ' ] = ptr ; tree [ ptr ] . end = currIndex ; tree [ ptr ] . length = tree [ temp ] . length + 2 ; tree [ ptr ] . start = tree [ ptr ] . end - tree [ ptr ] . length + 1 ; currNode = ptr ; temp = tree [ temp ] . suffixEdge ; if ( tree [ currNode ] . length == 1 ) { tree [ currNode ] . suffixEdge = 2 ; return ; } while ( true ) { int currLength = tree [ temp ] . length ; if ( currIndex - currLength >= 1 && ( s [ currIndex ] == s [ currIndex - currLength - 1 ] ) ) break ; temp = tree [ temp ] . suffixEdge ; } tree [ currNode ] . suffixEdge = tree [ temp ] . insertionEdge [ s [ currIndex ] - ' a ' ] ; } int main ( ) { root1 . length = -1 ; root1 . suffixEdge = 1 ; root2 . length = 0 ; root2 . suffixEdge = 1 ; tree [ 1 ] = root1 ; tree [ 2 ] = root2 ; ptr = 2 ; currNode = 1 ; s = " forgeeksskeegfor " ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) insert ( i ) ; int last = ptr ; for ( int i = tree [ last ] . start ; i <= tree [ last ] . end ; i ++ ) cout << s [ i ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { char data ; struct Node * next ; } ; char maxChar ( struct Node * head ) { struct Node * p = head ; int max = -1 ; char res ; while ( p != NULL ) { struct Node * q = p -> next ; int count = 1 ; while ( q != NULL ) { if ( p -> data == q -> data ) count ++ ; q = q -> next ; } if ( max < count ) { res = p -> data ; max = count ; } p = p -> next ; } return res ; } void push ( struct Node * * head_ref , char new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * head = NULL ; char str [ ] = " skeegforskeeg " ; int i ; for ( i = 0 ; str [ i ] != ' \0' ; i ++ ) push ( & head , str [ i ] ) ; cout << maxChar ( head ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findLastIndex ( string & str , char x ) { int index = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; } int main ( ) { string str = " geeksforgeeks " ; char x = ' e ' ; int index = findLastIndex ( str , x ) ; if ( index == -1 ) cout << " Character ▁ not ▁ found " ; else cout << " Last ▁ index ▁ is ▁ " << index ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findLastIndex ( string & str , char x ) { for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return -1 ; } int main ( ) { string str = " geeksforgeeks " ; char x = ' e ' ; int index = findLastIndex ( str , x ) ; if ( index == -1 ) cout << " Character ▁ not ▁ found " ; else cout << " Last ▁ index ▁ is ▁ " << index ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int middleOfThree ( int a , int b , int c ) { if ( a > b ) { if ( b > c ) return b ; else if ( a > c ) return c ; else return a ; } else { if ( a > c ) return a ; else if ( b > c ) return c ; else return b ; } } int main ( ) { int a = 20 , b = 30 , c = 40 ; cout << middleOfThree ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; } int main ( ) { int l = 1 , r = 5 ; cout << countMaxSetBits ( l , r ) << " STRNEWLINE " ; l = 1 , r = 10 ; cout << countMaxSetBits ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; Node * left , * right ; } ; Node * newNode ( int item ) { Node * temp = new Node ; temp -> key = item ; temp -> left = temp -> right = NULL ; return temp ; } Node * insert ( Node * node , int key ) { if ( node == NULL ) return newNode ( key ) ; if ( key < node -> key ) node -> left = insert ( node -> left , key ) ; else if ( key > node -> key ) node -> right = insert ( node -> right , key ) ; return node ; } int findFloor ( Node * root , int key ) { Node * curr = root , * ans = NULL ; while ( curr ) { if ( curr -> key <= key ) { ans = curr ; curr = curr -> right ; } else curr = curr -> left ; } if ( ans ) return ans -> key ; return -1 ; } int main ( ) { int N = 25 ; Node * root = insert ( root , 19 ) ; insert ( root , 2 ) ; insert ( root , 1 ) ; insert ( root , 3 ) ; insert ( root , 12 ) ; insert ( root , 9 ) ; insert ( root , 21 ) ; insert ( root , 19 ) ; insert ( root , 25 ) ; printf ( " % d " , findFloor ( root , N ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return -1 ; } int main ( ) { int s = 15 ; int n = findS ( s ) ; n == -1 ? cout << " - 1" : cout << n ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int compareStrings ( string str1 , string str2 ) { int i = 0 ; while ( str1 [ i ] == str2 [ i ] && str1 [ i ] != ' \0' ) i ++ ; if ( str1 [ i ] > str2 [ i ] ) return -1 ; return ( str1 [ i ] < str2 [ i ] ) ; } int searchStr ( string arr [ ] , string str , int first , int last ) { if ( first > last ) return -1 ; int mid = ( last + first ) / 2 ; if ( arr [ mid ] . empty ( ) ) { int left = mid - 1 ; int right = mid + 1 ; while ( true ) { if ( left < first && right > last ) return -1 ; if ( right <= last && ! arr [ right ] . empty ( ) ) { mid = right ; break ; } if ( left >= first && ! arr [ left ] . empty ( ) ) { mid = left ; break ; } right ++ ; left -- ; } } if ( compareStrings ( str , arr [ mid ] ) == 0 ) return mid ; if ( compareStrings ( str , arr [ mid ] ) < 0 ) return searchStr ( arr , str , mid + 1 , last ) ; return searchStr ( arr , str , first , mid - 1 ) ; } int main ( ) { string arr [ ] = { " for " , " " , " " , " " , " geeks " , " ide " , " " , " practice " , " " , " " , " quiz " , " " , " " } ; string str = " quiz " ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << searchStr ( arr , str , 0 , n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countReduction ( int num ) { int ans = 0 ; while ( num >= 10 ) { int temp = num ; num = 1 ; while ( temp > 0 ) { int digit = temp % 10 ; temp = temp / 10 ; num *= digit ; } ans ++ ; } return ans ; } bool compare ( int x , int y ) { int x1 = countReduction ( x ) ; int y1 = countReduction ( y ) ; if ( x1 < y1 ) return true ; return false ; } void sortArray ( int a [ ] , int n ) { sort ( a , a + n , compare ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << a [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 39 , 999 , 4 , 9876 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string canSortString ( string S , int N ) { int flag = 1 ; int i , j ; for ( i = N - 2 ; i >= 0 ; i -- ) { if ( S [ i ] == '1' && S [ i + 1 ] == '1' ) { break ; } } for ( int j = i ; j >= 0 ; j -- ) { if ( S [ j ] == '0' && S [ j + 1 ] == '0' ) { flag = 0 ; break ; } } if ( flag == 0 ) { return " No " ; } else { return " Yes " ; } } int main ( ) { string S = "10101011011" ; int N = S . length ( ) ; cout << canSortString ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < int > > transpose ( vector < vector < int > > mat , int row , int col ) { vector < vector < int > > tr ( col , vector < int > ( row ) ) ; for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) { tr [ j ] [ i ] = mat [ i ] [ j ] ; } } return tr ; } void RowWiseSort ( vector < vector < int > > & B ) { for ( int i = 0 ; i < ( int ) B . size ( ) ; i ++ ) { sort ( B [ i ] . begin ( ) , B [ i ] . end ( ) ) ; } } void sortCol ( vector < vector < int > > mat , int N , int M ) { vector < vector < int > > B = transpose ( mat , N , M ) ; RowWiseSort ( B ) ; mat = transpose ( B , M , N ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cout << mat [ i ] [ j ] << " ▁ " ; } cout << ' ' ; } } int main ( ) { vector < vector < int > > mat = { { 1 , 6 , 10 } , { 8 , 5 , 9 } , { 9 , 4 , 15 } , { 7 , 3 , 60 } } ; int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; sortCol ( mat , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void largestArea ( int N , int M , int H [ ] , int V [ ] , int h , int v ) { set < int > s1 ; set < int > s2 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s1 . insert ( i ) ; for ( int i = 1 ; i <= M + 1 ; i ++ ) s2 . insert ( i ) ; for ( int i = 0 ; i < h ; i ++ ) { s1 . erase ( H [ i ] ) ; } for ( int i = 0 ; i < v ; i ++ ) { s2 . erase ( V [ i ] ) ; } int list1 [ s1 . size ( ) ] ; int list2 [ s2 . size ( ) ] ; int i = 0 ; for ( auto it1 = s1 . begin ( ) ; it1 != s1 . end ( ) ; it1 ++ ) { list1 [ i ++ ] = * it1 ; } i = 0 ; for ( auto it2 = s2 . begin ( ) ; it2 != s2 . end ( ) ; it2 ++ ) { list2 [ i ++ ] = * it2 ; } sort ( list1 , list1 + s1 . size ( ) ) ; sort ( list2 , list2 + s2 . size ( ) ) ; int maxH = 0 , p1 = 0 , maxV = 0 , p2 = 0 ; for ( int j = 0 ; j < s1 . size ( ) ; j ++ ) { maxH = max ( maxH , list1 [ j ] - p1 ) ; p1 = list1 [ j ] ; } for ( int j = 0 ; j < s2 . size ( ) ; j ++ ) { maxV = max ( maxV , list2 [ j ] - p2 ) ; p2 = list2 [ j ] ; } cout << ( maxV * maxH ) << endl ; } int main ( ) { int N = 3 , M = 3 ; int H [ ] = { 2 } ; int V [ ] = { 2 } ; int h = sizeof ( H ) / sizeof ( H [ 0 ] ) ; int v = sizeof ( V ) / sizeof ( V [ 0 ] ) ; largestArea ( N , M , H , V , h , v ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimum_sum ( int A [ ] , int N ) { sort ( A , A + N ) ; int sum = INT_MAX ; for ( int i = 0 ; i <= N - 3 ; i ++ ) { sum = min ( sum , abs ( A [ i ] - A [ i + 1 ] ) + abs ( A [ i + 1 ] - A [ i + 2 ] ) ) ; } cout << sum ; } int main ( ) { int A [ ] = { 1 , 1 , 2 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minimum_sum ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sameChar ( string S , int N ) { sort ( S . begin ( ) , S . end ( ) ) ; int mid = S [ N / 2 ] ; int total_operations = 0 ; for ( int i = 0 ; i < N ; i ++ ) { total_operations += abs ( int ( S [ i ] ) - mid ) ; } cout << total_operations ; } int main ( ) { string S = " geeks " ; int N = S . size ( ) ; sameChar ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int arr [ ] , int N ) { int count = 0 ; if ( N < 3 ) return 0 ; for ( int b = 0 ; b < N ; b ++ ) { for ( int a = 0 ; a < N ; a ++ ) { if ( a == b ) continue ; for ( int c = 0 ; c < N ; c ++ ) { if ( c == a c == b ) continue ; int d = arr [ b ] * arr [ b ] / 4 ; if ( arr [ a ] * arr <= d ) count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getCount ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sameStrings ( string str1 , string str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N != M ) { return false ; } int a [ 256 ] = { 0 } , b [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { a [ str1 [ i ] - ' a ' ] ++ ; b [ str2 [ i ] - ' a ' ] ++ ; } int i = 0 ; while ( i < 256 ) { if ( ( a [ i ] == 0 && b [ i ] == 0 ) || ( a [ i ] != 0 && b [ i ] != 0 ) ) { i ++ ; } else { return false ; } } sort ( a , a + 256 ) ; sort ( b , b + 256 ) ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( a [ i ] != b [ i ] ) return false ; } return true ; } int main ( ) { string S1 = " cabbba " , S2 = " abbccc " ; if ( sameStrings ( S1 , S2 ) ) cout << " YES " << endl ; else cout << " ▁ NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSteps ( string A , string B , int M , int N ) { if ( A [ 0 ] > B [ 0 ] ) return 0 ; if ( B [ 0 ] > A [ 0 ] ) { return 1 ; } if ( M <= N && A [ 0 ] == B [ 0 ] && count ( A . begin ( ) , A . end ( ) , A [ 0 ] ) == M && count ( B . begin ( ) , B . end ( ) , B [ 0 ] ) == N ) return -1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] > B [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] < A [ 0 ] ) return 1 ; } for ( int i = 1 ; i < M ; i ++ ) { if ( A [ i ] > A [ 0 ] ) { swap ( A [ i ] , B [ 0 ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } for ( int i = 1 ; i < N ; i ++ ) { if ( B [ i ] < B [ 0 ] ) { swap ( A [ 0 ] , B [ i ] ) ; swap ( A [ 0 ] , B [ 0 ] ) ; return 2 ; } } return 0 ; } int main ( ) { string A = " adsfd " ; string B = " dffff " ; int M = A . length ( ) ; int N = B . length ( ) ; cout << minSteps ( A , B , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findAns ( int A [ ] , int N , int X ) { if ( check ( A , X , N ) ) { return true ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int g = __gcd ( A [ i ] , A [ j ] ) ; if ( g != 1 ) { if ( g <= X ) { return true ; } } } } return false ; } bool check ( int A [ ] , int X , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] > X ) { return false ; } } return true ; } int main ( ) { int X = 4 ; int A [ ] = { 2 , 1 , 5 , 3 , 6 } ; int N = 5 ; if ( findAns ( A , N , X ) ) { cout << " true " ; } else { cout << " false " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string check ( int a [ ] , int b [ ] , int Na , int Nb , int k , int m ) { if ( Na < k Nb < m ) return " No " ; sort ( a , a + Na ) ; sort ( b , b + Nb ) ; if ( a [ k - 1 ] < b [ Nb - m ] ) { return " Yes " ; } return " No " ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 3 , 4 , 5 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int X = 2 , Y = 1 ; cout << check ( arr1 , arr2 , N , M , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int splitArray ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int result = INT_MAX ; for ( int i = 1 ; i < N ; i ++ ) { result = min ( result , arr [ i ] - arr [ i - 1 ] ) ; } return result ; } int main ( ) { int arr [ ] = { 3 , 1 , 2 , 6 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << splitArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSum ( int * arr , int * brr , int N , int K ) { vector < int > crr ; for ( int i = 0 ; i < N ; i ++ ) { crr . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < K ; i ++ ) { crr . push_back ( brr [ i ] ) ; } sort ( crr . begin ( ) , crr . end ( ) , greater < int > ( ) ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( crr [ i ] > 0 ) { sum += crr [ i ] ; } else { break ; } } cout << sum << endl ; } int main ( ) { int arr [ ] = { 7 , 2 , -1 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int brr [ ] = { 1 , 2 , 3 , 2 } ; int K = sizeof ( brr ) / sizeof ( brr [ 0 ] ) ; maxSum ( arr , brr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int xo = ( A [ i ] ^ A [ j ] ) ; int mx = max ( A [ i ] , A [ j ] ) ; if ( xo > mx ) { count ++ ; } } } cout << count ; } int main ( ) { int arr [ ] = { 2 , 4 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTheOrder ( int arr [ ] , string s , int N ) { vector < int > ans ; pair < int , int > A [ N ] ; for ( int i = 0 ; i < N ; i ++ ) A [ i ] = { arr [ i ] , i + 1 } ; sort ( A , A + N ) ; priority_queue < pair < int , int > > q ; int index = 0 ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( s [ i ] == '0' ) { ans . push_back ( A [ index ] . second ) ; q . push ( A [ index ] ) ; index ++ ; } else { ans . push_back ( q . top ( ) . second ) ; q . pop ( ) ; } } for ( auto i : ans ) { cout << i << " ▁ " ; } } int main ( ) { int N = 3 ; int arr [ ] = { 2 , 1 , 3 } ; string s = "001011" ; findTheOrder ( arr , s , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void evenOddDiff ( int a [ ] , int n , int k ) { int j = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) { j ++ ; swap ( a [ i ] , a [ j ] ) ; } } j ++ ; sort ( a , a + j , greater < int > ( ) ) ; sort ( a + j , a + n , greater < int > ( ) ) ; int evenSum = 0 , oddSum = 0 ; for ( int i = 0 ; i < k ; i ++ ) { evenSum += a [ i ] ; } for ( int i = j ; i < ( j + k ) ; i ++ ) { oddSum += a [ i ] ; } cout << abs ( evenSum - oddSum ) ; } int main ( ) { int arr [ ] = { 1 , 8 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; evenOddDiff ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } void rearrangeArr ( int arr [ ] , int N ) { int totalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += arr [ i ] ; } if ( totalSum == 0 ) { cout << " - 1" << endl ; } else if ( totalSum > 0 ) { sort ( arr , arr + N , greater < int > ( ) ) ; printArr ( arr , N ) ; } else { sort ( arr , arr + N ) ; printArr ( arr , N ) ; } } int main ( ) { int arr [ ] = { 1 , -1 , -2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrangeArr ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findSubsets ( vector < int > arr , int N ) { map < int , int > M ; for ( int i = 0 ; i < N ; i ++ ) { M [ arr [ i ] ] ++ ; } vector < int > subsets ; int I = 0 ; for ( auto playerEntry = M . begin ( ) ; playerEntry != M . end ( ) ; playerEntry ++ ) { subsets . push_back ( playerEntry -> second ) ; I ++ ; } return subsets ; } bool subsetSum ( vector < int > subsets , int N , int target ) { bool dp [ N + 1 ] [ target + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) dp [ i ] [ 0 ] = true ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= target ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( j >= subsets [ i - 1 ] ) { dp [ i ] [ j ] |= dp [ i - 1 ] [ j - subsets [ i - 1 ] ] ; } } } return dp [ N ] [ target ] ; } void divideInto2Subset ( vector < int > arr , int N ) { vector < int > subsets = findSubsets ( arr , N ) ; if ( ( N ) % 2 == 1 ) { cout << " No " << endl ; return ; } int subsets_size = subsets . size ( ) ; bool isPossible = subsetSum ( subsets , subsets_size , N / 2 ) ; if ( isPossible ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } } int main ( ) { vector < int > arr { 2 , 1 , 2 , 3 } ; int N = arr . size ( ) ; divideInto2Subset ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <vector> NEW_LINE using namespace std ; int main ( ) { int arr [ ] = { 4 , 7 , 2 , 3 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int count = minOperations ( arr , n ) ; cout << count ; } int minOperations ( int arr [ ] , int n ) { vector < pair < int , int > > vect ; for ( int i = 0 ; i < n ; i ++ ) { vect . push_back ( make_pair ( arr [ i ] , i ) ) ; } sort ( vect . begin ( ) , vect . end ( ) ) ; int res = 1 ; int streak = 1 ; int prev = vect [ 0 ] . second ; for ( int i = 1 ; i < n ; i ++ ) { if ( prev < vect [ i ] . second ) { res ++ ; streak = max ( streak , res ) ; } else res = 1 ; prev = vect [ i ] . second ; } return n - streak ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 1000000007 ; int solve ( vector < int > & values , vector < int > & salary ) { long long ret = 1 ; int amt = 0 ; sort ( values . begin ( ) , values . end ( ) ) ; sort ( salary . begin ( ) , salary . end ( ) ) ; while ( salary . size ( ) ) { while ( values . size ( ) && values . back ( ) >= salary . back ( ) ) { amt ++ ; values . pop_back ( ) ; } if ( amt == 0 ) return 0 ; ret *= amt -- ; ret %= MOD ; salary . pop_back ( ) ; } return ret ; } int main ( ) { vector < int > values { 1 , 2 } , salary { 2 } ; cout << solve ( values , salary ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  201 NEW_LINE int n1 , n2 , n3 ; int dp [ maxN ] [ maxN ] [ maxN ] ; int getMaxSum ( int i , int j , int k , int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { int cnt = 0 ; if ( i >= n1 ) cnt ++ ; if ( j >= n2 ) cnt ++ ; if ( k >= n3 ) cnt ++ ; if ( cnt >= 2 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != -1 ) return dp [ i ] [ j ] [ k ] ; int ans = 0 ; if ( i < n1 && j < n2 ) ans = max ( ans , getMaxSum ( i + 1 , j + 1 , k , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr2 [ j ] ) ; if ( i < n1 && k < n3 ) ans = max ( ans , getMaxSum ( i + 1 , j , k + 1 , arr1 , arr2 , arr3 ) + arr1 [ i ] * arr3 [ k ] ) ; if ( j < n2 && k < n3 ) ans = max ( ans , getMaxSum ( i , j + 1 , k + 1 , arr1 , arr2 , arr3 ) + arr2 [ j ] * arr3 [ k ] ) ; dp [ i ] [ j ] [ k ] = ans ; return dp [ i ] [ j ] [ k ] ; } int maxProductSum ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] ) { memset ( dp , -1 , sizeof ( dp ) ) ; sort ( arr1 , arr1 + n1 ) ; reverse ( arr1 , arr1 + n1 ) ; sort ( arr2 , arr2 + n2 ) ; reverse ( arr2 , arr2 + n2 ) ; sort ( arr3 , arr3 + n3 ) ; reverse ( arr3 , arr3 + n3 ) ; return getMaxSum ( 0 , 0 , 0 , arr1 , arr2 , arr3 ) ; } int main ( ) { n1 = 2 ; int arr1 [ ] = { 3 , 5 } ; n2 = 2 ; int arr2 [ ] = { 2 , 1 } ; n3 = 3 ; int arr3 [ ] = { 4 , 3 , 5 } ; cout << maxProductSum ( arr1 , arr2 , arr3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int n ) { int ans = 0 ; sort ( arr , arr + n ) ; int left = 0 , right = 1 ; while ( right < n ) { if ( arr [ left ] == arr [ right ] ) ans += right - left ; else left = right ; right ++ ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 2 , 3 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool compare ( pair < int , int > p1 , pair < int , int > p2 ) { return p1 . first > p2 . first ; } int maximiseScore ( int A [ ] , int B [ ] , int K , int N ) { vector < pair < int , int > > pairs ( N ) ; for ( int i = 0 ; i < N ; i ++ ) { pairs [ i ] = make_pair ( A [ i ] , B [ i ] ) ; } sort ( pairs . begin ( ) , pairs . end ( ) , compare ) ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( pairs [ i ] . second == 0 ) { sum += pairs [ i ] . first ; } else if ( pairs [ i ] . second == 1 ) { if ( K > 0 ) { sum += pairs [ i ] . first ; K -- ; } else { sum -= pairs [ i ] . first ; } } } return sum ; } int main ( ) { int A [ ] = { 5 , 4 , 6 , 2 , 8 } ; int B [ ] = { 1 , 0 , 1 , 1 , 0 } ; int K = 2 ; int N = sizeof ( A ) / sizeof ( int ) ; cout << maximiseScore ( A , B , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sortString ( string S ) { vector < int > sorted , original ; bool insert = false ; if ( S . length ( ) == 1 ) { cout << 0 << endl ; } int curr = 1 ; for ( int i = 0 ; i < ( S . length ( ) - 1 ) ; i ++ ) { if ( S [ i ] == S [ i + 1 ] ) { curr += 1 ; insert = false ; } else { sorted . push_back ( curr ) ; original . push_back ( curr ) ; curr = 1 ; insert = true ; } } if ( ( S [ ( S . length ( ) - 1 ) ] != S [ ( S . length ( ) - 2 ) ] ) insert == false ) { sorted . push_back ( curr ) ; original . push_back ( curr ) ; } sort ( sorted . begin ( ) , sorted . end ( ) ) ; int t_cost = 0 ; for ( int i = 0 ; i < sorted . size ( ) ; i ++ ) { t_cost += abs ( sorted [ i ] - original [ i ] ) ; } return ( t_cost / 2 ) ; } int main ( ) { string S = " aabbcccdeffffggghhhhhii " ; cout << sortString ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriplet ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int flag = 0 , i ; for ( i = N - 1 ; i - 2 >= 0 ; i -- ) { if ( arr [ i - 2 ] + arr [ i - 1 ] > arr [ i ] ) { flag = 1 ; break ; } } if ( flag ) { cout << arr [ i - 2 ] << " ▁ " << arr [ i - 1 ] << " ▁ " << arr [ i ] << endl ; } else { cout << -1 << endl ; } } int main ( ) { int arr [ ] = { 4 , 2 , 10 , 3 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTriplet ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberofpairs ( int arr [ ] , int N ) { int answer = 0 ; sort ( arr , arr + N ) ; int minDiff = INT_MAX ; for ( int i = 0 ; i < N - 1 ; i ++ ) minDiff = min ( minDiff , arr [ i + 1 ] - arr [ i ] ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( arr [ i + 1 ] - arr [ i ] == minDiff ) answer ++ ; } return answer ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 3 } ; int N = ( sizeof arr ) / ( sizeof arr [ 0 ] ) ; cout << numberofpairs ( arr , N ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int letters [ ] = { 4 , 3 , 3 , 3 , 4 , 4 , 3 , 5 , 5 , 4 } ; int sumOfLetters ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += letters [ n % 10 ] ; n = n / 10 ; } return sum ; } void sortArr ( int arr [ ] , int n ) { vector < pair < int , int > > vp ; for ( int i = 0 ; i < n ; i ++ ) { vp . push_back ( make_pair ( sumOfLetters ( arr [ i ] ) , arr [ i ] ) ) ; } sort ( vp . begin ( ) , vp . end ( ) ) ; for ( int i = 0 ; i < vp . size ( ) ; i ++ ) cout << vp [ i ] . second << " ▁ " ; } int main ( ) { int arr [ ] = { 12 , 10 , 31 , 18 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int block ; struct Query { int L , R , index ; int armstrong ; } ; int count_Armstrong ; bool compare ( Query x , Query y ) { if ( x . L / block != y . L / block ) return x . L / block < y . L / block ; return x . R < y . R ; } bool compare1 ( Query x , Query y ) { return x . index < y . index ; } bool isArmstrong ( int x ) { int n = to_string ( x ) . size ( ) ; int sum1 = 0 ; int temp = x ; while ( temp > 0 ) { int digit = temp % 10 ; sum1 += pow ( digit , n ) ; temp /= 10 ; } if ( sum1 == x ) return true ; return false ; } void add ( int currL , int a [ ] ) { if ( isArmstrong ( a [ currL ] ) ) count_Armstrong ++ ; } void remove ( int currR , int a [ ] ) { if ( isArmstrong ( a [ currR ] ) ) count_Armstrong -- ; } void queryResults ( int a [ ] , int n , Query q [ ] , int m ) { count_Armstrong = 0 ; block = ( int ) sqrt ( n ) ; sort ( q , q + m , compare ) ; int currL = 0 , currR = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] . L , R = q [ i ] . R ; while ( currR <= R ) { add ( currR , a ) ; currR ++ ; } while ( currL > L ) { add ( currL - 1 , a ) ; currL -- ; } while ( currR > R + 1 ) { remove ( currR - 1 , a ) ; currR -- ; } while ( currL < L ) { remove ( currL , a ) ; currL ++ ; } q [ i ] . armstrong = count_Armstrong ; } } void printResults ( Query q [ ] , int m ) { sort ( q , q + m , compare1 ) ; for ( int i = 0 ; i < m ; i ++ ) { cout << q [ i ] . armstrong << endl ; } } int main ( ) { int arr [ ] = { 18 , 153 , 8 , 9 , 14 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Query q [ ] = { { 0 , 5 , 0 , 0 } , { 3 , 5 , 1 , 0 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; queryResults ( arr , n , q , m ) ; printResults ( q , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortArray ( int A [ ] , int N ) { int x , y , z ; if ( N % 4 == 0 N % 4 == 1 ) { for ( int i = 0 ; i < N / 2 ; i ++ ) { x = i ; if ( i % 2 == 0 ) { y = N - i - 2 ; z = N - i - 1 ; } A [ z ] = A [ y ] ; A [ y ] = A [ x ] ; A [ x ] = x + 1 ; } cout << " Sorted ▁ Array : ▁ " ; for ( int i = 0 ; i < N ; i ++ ) cout << A [ i ] << " ▁ " ; } else cout << " - 1" ; } int main ( ) { int A [ ] = { 5 , 4 , 3 , 2 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; sortArray ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int val ; struct node * right , * left ; } ; struct node * newnode ( int key ) { struct node * temp = new node ; temp -> val = key ; temp -> right = NULL ; temp -> left = NULL ; return temp ; } void func ( node * root ) { queue < node * > q ; bool t = true ; q . push ( root ) ; int i = -1 , j = -1 , k = -1 ; while ( ! q . empty ( ) ) { int h = q . size ( ) ; while ( h > 0 ) { root = q . front ( ) ; if ( i == -1 ) { j = root -> val ; } if ( i == -2 ) { if ( j <= root -> val ) { j = root -> val ; i = -3 ; } else { t = false ; break ; } } if ( root -> left != NULL ) { q . push ( root -> left ) ; } if ( root -> right != NULL ) { q . push ( root -> right ) ; } h = h - 1 ; q . pop ( ) ; } i = -2 ; if ( t == false ) { break ; } } if ( t ) cout << " true " << endl ; else cout << " false " << endl ; } int main ( ) { struct node * root = newnode ( 10 ) ; root -> right = newnode ( 50 ) ; root -> right -> right = newnode ( 15 ) ; root -> left = newnode ( 20 ) ; root -> left -> left = newnode ( 50 ) ; root -> left -> right = newnode ( 23 ) ; root -> right -> left = newnode ( 10 ) ; func ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate_minimum_split ( int n , int a [ ] , int k ) { int p [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) p [ i - 1 ] = a [ i ] - a [ i - 1 ] ; sort ( p , p + n - 1 , greater < int > ( ) ) ; int min_sum = 0 ; for ( int i = 0 ; i < k - 1 ; i ++ ) min_sum += p [ i ] ; int res = a [ n - 1 ] - a [ 0 ] - min_sum ; return res ; } int main ( ) { int arr [ 6 ] = { 4 , 8 , 15 , 16 , 23 , 42 } ; int k = 3 ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << calculate_minimum_split ( n , arr , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int myCompare ( string date1 , string date2 ) { string day1 = date1 . substr ( 0 , 2 ) ; string month1 = date1 . substr ( 3 , 2 ) ; string year1 = date1 . substr ( 6 , 4 ) ; string day2 = date2 . substr ( 0 , 2 ) ; string month2 = date2 . substr ( 3 , 2 ) ; string year2 = date2 . substr ( 6 , 4 ) ; if ( year1 < year2 ) return 1 ; if ( year1 > year2 ) return 0 ; if ( month1 < month2 ) return 1 ; if ( month1 > month2 ) return 0 ; if ( day1 < day2 ) return 1 ; if ( day1 > day2 ) return 0 ; } void printDatesAscending ( vector < string > arr ) { sort ( arr . begin ( ) , arr . end ( ) , myCompare ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << " STRNEWLINE " ; } int main ( ) { vector < string > arr ; arr . push_back ( "25-08-1996" ) ; arr . push_back ( "03-08-1970" ) ; arr . push_back ( "09-04-1994" ) ; arr . push_back ( "29-08-1996" ) ; arr . push_back ( "14-02-1972" ) ; printDatesAscending ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } int countVowels ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ count ; return count ; } void sortArr ( string arr [ ] , int n ) { vector < pair < int , string > > vp ; for ( int i = 0 ; i < n ; i ++ ) { vp . push_back ( make_pair ( countVowels ( arr [ i ] ) , arr [ i ] ) ) ; } sort ( vp . begin ( ) , vp . end ( ) ) ; for ( int i = 0 ; i < vp . size ( ) ; i ++ ) cout << vp [ i ] . second << " ▁ " ; } int main ( ) { string arr [ ] = { " lmno " , " pqrst " , " aeiou " , " xyz " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findK ( int arr [ ] , int size , int N ) { sort ( arr , arr + size ) ; int temp_sum = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp_sum += arr [ i ] ; if ( N - temp_sum == arr [ i ] * ( size - i - 1 ) ) { return arr [ i ] ; } } return -1 ; } int main ( ) { int arr [ ] = { 3 , 1 , 10 , 4 , 8 } ; int size = sizeof ( arr ) / sizeof ( int ) ; int N = 16 ; cout << findK ( arr , size , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( ( arr [ l ] == arr [ mid ] ) && ( arr [ h ] == arr [ mid ] ) ) { ++ l ; -- h ; return search ( arr , l , h , key ) ; } if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 3 , 3 , 1 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int key = 3 ; cout << search ( arr , 0 , n - 1 , key ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE int minimumCost ( ll price [ ] , int n ) { sort ( price , price + n ) ; ll totalCost = 0 ; for ( int i = n - 1 ; i > 1 ; i -= 2 ) { if ( i == 2 ) { totalCost += price [ 2 ] + price [ 0 ] ; } else { ll price_first = price [ i ] + price [ 0 ] + 2 * price [ 1 ] ; ll price_second = price [ i ] + price [ i - 1 ] + 2 * price [ 0 ] ; totalCost += min ( price_first , price_second ) ; } } if ( n == 1 ) { totalCost += price [ 0 ] ; } else { totalCost += price [ 1 ] ; } return totalCost ; } int main ( ) { ll price [ ] = { 30 , 40 , 60 , 70 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; cout << minimumCost ( price , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void unique_combination ( int l , int sum , int K , vector < int > & local , vector < int > & A ) { if ( sum == K ) { cout << " { " ; for ( int i = 0 ; i < local . size ( ) ; i ++ ) { if ( i != 0 ) cout << " ▁ " ; cout << local [ i ] ; if ( i != local . size ( ) - 1 ) cout << " , ▁ " ; } cout << " } " << endl ; return ; } for ( int i = l ; i < A . size ( ) ; i ++ ) { if ( sum + A [ i ] > K ) continue ; if ( i > l and A [ i ] == A [ i - 1 ] ) continue ; local . push_back ( A [ i ] ) ; unique_combination ( i + 1 , sum + A [ i ] , K , local , A ) ; local . pop_back ( ) ; } } void Combination ( vector < int > A , int K ) { sort ( A . begin ( ) , A . end ( ) ) ; vector < int > local ; unique_combination ( 0 , 0 , K , local , A ) ; } int main ( ) { vector < int > A = { 10 , 1 , 2 , 7 , 6 , 1 , 5 } ; int K = 8 ; Combination ( A , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solution ( vector < int > & arr , int x ) { int closestSum = INT_MAX ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < arr . size ( ) ; j ++ ) { for ( int k = j + 1 ; k < arr . size ( ) ; k ++ ) { if ( abs ( x - closestSum ) > abs ( x - ( arr [ i ] + arr [ j ] + arr [ k ] ) ) ) closestSum = ( arr [ i ] + arr [ j ] + arr [ k ] ) ; } } } return closestSum ; } int main ( ) { vector < int > arr = { -1 , 2 , 1 , -4 } ; int x = 1 ; cout << solution ( arr , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void addEdge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; } void getindeg ( vector < int > adj [ ] , int V , vector < int > & indeg ) { for ( int i = 0 ; i < V ; i ++ ) { for ( auto x : adj [ i ] ) { indeg [ x ] ++ ; } } } vector < int > topo ( vector < int > adj [ ] , int V , vector < int > & indeg ) { queue < int > q ; for ( int i = 0 ; i < V ; i ++ ) { if ( indeg [ i ] == 0 ) q . push ( i ) ; } vector < int > res ; while ( ! q . empty ( ) ) { int u = q . front ( ) ; q . pop ( ) ; res . push_back ( u ) ; for ( auto x : adj [ u ] ) { indeg [ x ] -- ; if ( indeg [ x ] == 0 ) q . push ( x ) ; } } return res ; } vector < int > makearray ( vector < vector < int > > v , int V ) { vector < int > adj [ V ] ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = 0 ; j < v [ i ] . size ( ) - 1 ; j ++ ) { addEdge ( adj , v [ i ] [ j ] , v [ i ] [ j + 1 ] ) ; } } vector < int > indeg ( V , 0 ) ; getindeg ( adj , V , indeg ) ; vector < int > res = topo ( adj , V , indeg ) ; return res ; } int main ( ) { int n = 10 ; vector < vector < int > > subseqs { { 9 , 1 , 2 , 8 , 3 } , { 6 , 1 , 2 } , { 9 , 6 , 3 , 4 } , { 5 , 2 , 7 } , { 0 , 9 , 5 , 4 } } ; vector < int > res = makearray ( subseqs , n ) ; for ( auto x : res ) { cout << x << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool existsTriplet ( int a [ ] , int b [ ] , int c [ ] , int x , int l1 , int l2 , int l3 ) { if ( l2 <= l1 and l2 <= l3 ) swap ( l2 , l1 ) , swap ( a , b ) ; else if ( l3 <= l1 and l3 <= l2 ) swap ( l3 , l1 ) , swap ( a , c ) ; for ( int i = 0 ; i < l1 ; i ++ ) { int j = 0 , k = l3 - 1 ; while ( j < l2 and k > = 0 ) { if ( a [ i ] + b [ j ] + c [ k ] == x ) return true ; if ( a [ i ] + b [ j ] + c [ k ] < x ) j ++ ; else k -- ; } } return false ; } int main ( ) { int a [ ] = { 2 , 7 , 8 , 10 , 15 } ; int b [ ] = { 1 , 6 , 7 , 8 } ; int c [ ] = { 4 , 5 , 5 } ; int l1 = sizeof ( a ) / sizeof ( int ) ; int l2 = sizeof ( b ) / sizeof ( int ) ; int l3 = sizeof ( c ) / sizeof ( int ) ; int x = 14 ; if ( existsTriplet ( a , b , c , x , l1 , l2 , l3 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE vector < ll > pr ; bool prime [ 10000000 + 1 ] ; void sieve ( ll n ) { for ( int i = 2 ; i <= n ; i += 1 ) { prime [ i ] = 1 ; } for ( ll p = 2 ; ( ll ) p * ( ll ) p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( ll i = ( ll ) p * ( ll ) p ; i <= n ; i += p ) prime [ i ] = false ; } } for ( ll p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) pr . push_back ( p ) ; } ll SemiPrimeSum ( ll N ) { ll ans = 0 ; for ( int i = 0 ; i < pr . size ( ) ; i += 1 ) { for ( int j = i ; j < pr . size ( ) ; j += 1 ) { if ( ( ll ) pr [ i ] * ( ll ) pr [ j ] > N ) break ; ans += ( ll ) pr [ i ] * ( ll ) pr [ j ] ; } } return ans ; } int main ( ) { ll N = 6 ; sieve ( N ) ; cout << SemiPrimeSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void compressArr ( int arr [ ] , int n ) { int i = 0 , j = 0 ; sort ( arr , arr + n ) ; while ( i < n ) { j = i ; while ( ( j + 1 < n ) && ( arr [ j + 1 ] == arr [ j ] + 1 ) ) { j ++ ; } if ( i == j ) { cout << arr [ i ] << " ▁ " ; i ++ ; } else { cout << arr [ i ] << " - " << arr [ j ] << " ▁ " ; i = j + 1 ; } } } int main ( ) { int n = 7 ; int arr [ n ] = { 1 , 3 , 4 , 5 , 6 , 9 , 10 } ; compressArr ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void pendulumArrangement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int odd , temp , in , pos ; pos = n - 1 ; if ( n % 2 == 0 ) odd = n - 1 ; else odd = n - 2 ; while ( odd > 0 ) { temp = arr [ odd ] ; in = odd ; while ( in != pos ) { arr [ in ] = arr [ in + 1 ] ; in ++ ; } arr [ in ] = temp ; odd = odd - 2 ; pos = pos - 1 ; } int start = 0 , end = ( n - 1 ) / 2 ; for ( ; start < end ; start ++ , end -- ) { temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 11 , 2 , 4 , 55 , 6 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pendulumArrangement ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right , * root ; Node ( int data ) { this -> data = data ; left = NULL ; right = NULL ; root = NULL ; } } ; Node * AddNode ( Node * root , int data ) { if ( root == NULL ) { root = new Node ( data ) ; return root ; } if ( root -> data < data ) root -> right = AddNode ( root -> right , data ) ; else if ( root -> data > data ) root -> left = AddNode ( root -> left , data ) ; return root ; } void TargetPair ( Node * node , int tar ) { vector < Node * > LeftList ; vector < Node * > RightList ; Node * curr_left = node ; Node * curr_right = node ; while ( curr_left != NULL || curr_right != NULL || LeftList . size ( ) > 0 && RightList . size ( ) > 0 ) { while ( curr_left != NULL ) { LeftList . push_back ( curr_left ) ; curr_left = curr_left -> left ; } while ( curr_right != NULL ) { RightList . push_back ( curr_right ) ; curr_right = curr_right -> right ; } Node * LeftNode = LeftList [ LeftList . size ( ) - 1 ] ; Node * RightNode = RightList [ RightList . size ( ) - 1 ] ; int leftVal = LeftNode -> data ; int rightVal = RightNode -> data ; if ( leftVal >= rightVal ) break ; if ( leftVal + rightVal < tar ) { LeftList . pop_back ( ) ; curr_left = LeftNode -> right ; } else if ( leftVal + rightVal > tar ) { RightList . pop_back ( ) ; curr_right = RightNode -> left ; } else { cout << LeftNode -> data << " ▁ " << RightNode -> data << endl ; RightList . pop_back ( ) ; LeftList . pop_back ( ) ; curr_left = LeftNode -> right ; curr_right = RightNode -> left ; } } } int main ( ) { Node * root = NULL ; root = AddNode ( root , 2 ) ; root = AddNode ( root , 6 ) ; root = AddNode ( root , 5 ) ; root = AddNode ( root , 3 ) ; root = AddNode ( root , 4 ) ; root = AddNode ( root , 1 ) ; root = AddNode ( root , 7 ) ; int sum = 8 ; TargetPair ( root , sum ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumber ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int max = arr [ n - 1 ] ; int table [ ( 2 * max ) + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = INT_MAX ; int ans = -1 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { int res = table [ i - arr [ j ] ] ; if ( res != INT_MAX && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } } if ( i > arr [ n - 1 ] && table [ i ] == INT_MAX ) { ans = i ; break ; } } return ans ; } int main ( ) { int arr [ ] = { 6 , 7 , 15 } ; int n = ( sizeof ( arr ) / sizeof ( int ) ) ; cout << findNumber ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s ) { int l = s . length ( ) ; sort ( s . begin ( ) , s . end ( ) ) ; for ( int i = 1 ; i < l ; i ++ ) { if ( s [ i ] - s [ i - 1 ] != 1 ) return false ; } return true ; } int main ( ) { string str = " dcef " ; if ( check ( str ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; str = " xyza " ; if ( check ( str ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] ; } bool compare ( int num1 , int num2 ) { string A = to_string ( num1 ) ; string B = to_string ( num2 ) ; return ( A + B ) <= ( B + A ) ; } void printSmallest ( int N , int arr [ ] ) { sort ( arr , arr + N , compare ) ; printArr ( arr , N ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 9 , 21 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printSmallest ( N , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPoints ( int n , int m , vector < int > a , vector < int > b , int x , int y ) { sort ( a . begin ( ) , a . end ( ) ) ; sort ( b . begin ( ) , b . end ( ) ) ; int j = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; } int main ( ) { int x = 1 , y = 4 ; vector < int > a = { 1 , 5 } ; int n = a . size ( ) ; vector < int > b = { 1 , 1 , 2 } ; int m = a . size ( ) ; cout << countPoints ( n , m , a , b , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void merge_and_sort ( int * output , int arr [ ] [ N ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { output [ i * n + j ] = arr [ i ] [ j ] ; } } sort ( output , output + n * k ) ; } int main ( ) { int arr [ ] [ N ] = { { 5 , 7 , 15 , 18 } , { 1 , 8 , 9 , 17 } , { 1 , 4 , 7 , 7 } } ; int n = N ; int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int * output = new int [ n * k ] ; merge_and_sort ( output , arr , n , k ) ; for ( int i = 0 ; i < n * k ; i ++ ) cout << output [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int n , int m , int k , vector < vector < int > > & matrix ) { vector < int > arr ; int mod ; if ( matrix [ 0 ] [ 0 ] < 0 ) { mod = k - ( abs ( matrix [ 0 ] [ 0 ] ) % k ) ; } else { mod = matrix [ 0 ] [ 0 ] % k ; } for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < m ; ++ j ) { arr . push_back ( matrix [ i ] [ j ] ) ; int val = matrix [ i ] [ j ] ; if ( val < 0 ) { int res = k - ( abs ( val ) % k ) ; if ( res != mod ) { return -1 ; } } else { int foo = matrix [ i ] [ j ] ; if ( foo % k != mod ) { return -1 ; } } } } sort ( arr . begin ( ) , arr . end ( ) ) ; int median = arr [ ( n * m ) / 2 ] ; int minOperations = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations += abs ( arr [ i ] - median ) / k ; if ( ( n * m ) % 2 == 0 ) { int median2 = arr [ ( ( n * m ) / 2 ) - 1 ] ; int minOperations2 = 0 ; for ( int i = 0 ; i < n * m ; ++ i ) minOperations2 += abs ( arr [ i ] - median2 ) / k ; minOperations = min ( minOperations , minOperations2 ) ; } return minOperations ; } int main ( ) { vector < vector < int > > matrix = { { 2 , 4 , 6 } , { 8 , 10 , 12 } , { 14 , 16 , 18 } , { 20 , 22 , 24 } } ; int n = matrix . size ( ) ; int m = matrix [ 0 ] . size ( ) ; int k = 2 ; cout << minOperations ( n , m , k , matrix ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSubarray ( int A [ ] , int n ) { int minValue = * min_element ( A , A + n ) ; int maxValue = * max_element ( A , A + n ) ; int pos_min = -1 , pos_max = -1 , ans = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] == minValue ) pos_min = i ; if ( A [ i ] == maxValue ) pos_max = i ; if ( pos_max != -1 and pos_min != -1 ) ans = min ( ans , abs ( pos_min - pos_max ) + 1 ) ; } return ans ; } int main ( ) { int A [ ] = { 1 , 5 , 9 , 7 , 1 , 9 , 4 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minSubarray ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long minimumMoves ( int a [ ] , int n ) { long long operations = 0 ; sort ( a , a + n ) ; for ( int i = 0 ; i < n ; i ++ ) operations += abs ( a [ i ] - ( i + 1 ) ) ; return operations ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumMoves ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printCase ( int n ) { if ( n <= 2 ) { cout << -1 ; return ; } for ( int i = n ; i >= 1 ; i -- ) cout << i << " ▁ " ; } int main ( ) { int n = 3 ; printCase ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMissingNumber ( vector < pair < int , int > > ranges , int m ) { sort ( ranges . begin ( ) , ranges . end ( ) ) ; vector < int > ans ; int prev = 0 ; for ( int j = 0 ; j < ranges . size ( ) ; j ++ ) { int start = ranges [ j ] . first ; int end = ranges [ j ] . second ; for ( int i = prev + 1 ; i < start ; i ++ ) ans . push_back ( i ) ; prev = end ; } for ( int i = prev + 1 ; i <= m ; i ++ ) ans . push_back ( i ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { if ( ans [ i ] <= m ) cout << ans [ i ] << " ▁ " ; } } int main ( ) { int N = 2 , M = 6 ; vector < pair < int , int > > ranges ; ranges . push_back ( { 1 , 2 } ) ; ranges . push_back ( { 4 , 5 } ) ; findMissingNumber ( ranges , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; static bool check ( int n , int k , int * a , int * b ) { sort ( a , a + n ) ; sort ( b , b + n ) ; bool fl = false ; int ind = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { if ( fl == true ) { return false ; } fl = true ; ind = i ; } } if ( ind == -1 | abs ( a [ ind ] - b [ ind ] ) <= k ) { return true ; } return false ; } int main ( ) { int n = 2 , k = 4 ; int a [ ] = { 1 , 5 } ; int b [ ] = { 1 , 1 } ; if ( check ( n , k , a , b ) ) { printf ( " Yes " ) ; } else { printf ( " No " ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE int SubseqWidths ( int A [ ] , int n ) { sort ( A , A + n ) ; int pow2 [ n ] ; pow2 [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; } int main ( ) { int A [ ] = { 5 , 6 , 4 , 3 , 8 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << SubseqWidths ( A , n ) ; return 0 ; }
# include <bits/stdc++.h> NEW_LINE using namespace std ; int maxArrayCover ( vector < int > a , int n , int x ) { sort ( a . begin ( ) , a . end ( ) ) ; int cc = 0 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += a [ i ] ; if ( s > x ) { break ; } cc += 1 ; } if ( accumulate ( a . begin ( ) , a . end ( ) , 0 ) == x ) { return n ; } else { if ( cc == n ) { return n - 1 ; } else { return cc ; } } } int main ( ) { int n = 3 ; int x = 70 ; vector < int > a = { 10 , 20 , 30 } ; printf ( " % d STRNEWLINE " , maxArrayCover ( a , n , x ) ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void QRsort ( int arr [ ] , int size ) { int MAX = * max_element ( arr , arr + size ) ; int MIN = * min_element ( arr , arr + size ) ; cout << " Maximum ▁ Element ▁ found ▁ is ▁ : ▁ " << MAX << endl ; cout << " Minimum ▁ Element ▁ found ▁ is ▁ : ▁ " << MIN << endl ; int COL = MIN ; int ROW = MAX / MIN + 1 ; int matrix [ ROW ] [ COL ] = { 0 } ; for ( int i = 0 ; i < size ; i ++ ) { int quotient = arr [ i ] / MIN ; int remainder = arr [ i ] % MIN ; matrix [ quotient ] [ remainder + 1 ] = arr [ i ] ; } int k = 0 ; for ( int i = 0 ; i < ROW ; i ++ ) { for ( int j = 0 ; j < COL ; j ++ ) { if ( matrix [ i ] [ j ] != 0 ) { arr [ k ++ ] = matrix [ i ] [ j ] ; } } } } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 5 , 3 , 7 , 4 , 8 , 2 , 6 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Initial ▁ Array ▁ : ▁ " << endl ; printArray ( arr , size ) ; QRsort ( arr , size ) ; cout << " Array ▁ after ▁ sorting ▁ : ▁ " << endl ; printArray ( arr , size ) ; }
#include <iostream> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool isPairWiseSorted ( struct Node * head ) { bool flag = true ; struct Node * temp = head ; while ( temp != NULL && temp -> next != NULL ) { if ( temp -> data > temp -> next -> data ) { flag = false ; break ; } temp = temp -> next -> next ; } return flag ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int main ( ) { struct Node * start = NULL ; push ( & start , 5 ) ; push ( & start , 1 ) ; push ( & start , 9 ) ; push ( & start , 9 ) ; push ( & start , 15 ) ; push ( & start , 10 ) ; if ( isPairWiseSorted ( start ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSOP ( int * a , int * b ) { int sop = 0 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; sort ( a , a + n + 1 ) ; sort ( b , b + n + 1 ) ; for ( int i = 0 ; i <= n ; i ++ ) { sop += a [ i ] * b [ i ] ; } return sop ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 4 , 5 , 1 } ; cout << maximumSOP ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; sort ( arr , arr + n ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { int start = 0 , mid = end - 1 ; while ( start < mid ) { long int prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 1 ; cout << countTriplets ( arr , n , m ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int sort3 ( int arr [ ] ) { if ( arr [ 1 ] < arr [ 0 ] ) swap ( arr [ 0 ] , arr [ 1 ] ) ; if ( arr [ 2 ] < arr [ 1 ] ) { swap ( arr [ 1 ] , arr [ 2 ] ) ; if ( arr [ 1 ] < arr [ 0 ] ) swap ( arr [ 1 ] , arr [ 0 ] ) ; } } int main ( ) { int a [ ] = { 10 , 12 , 5 } ; sort3 ( a ) ; for ( int i = 0 ; i < 3 ; i ++ ) cout << a [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void merge ( int arr [ ] , int beg , int mid , int end , int maxele ) { int i = beg ; int j = mid + 1 ; int k = beg ; while ( i <= mid && j <= end ) { if ( arr [ i ] % maxele <= arr [ j ] % maxele ) { arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele ; k ++ ; i ++ ; } else { arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele ; k ++ ; j ++ ; } } while ( i <= mid ) { arr [ k ] = arr [ k ] + ( arr [ i ] % maxele ) * maxele ; k ++ ; i ++ ; } while ( j <= end ) { arr [ k ] = arr [ k ] + ( arr [ j ] % maxele ) * maxele ; k ++ ; j ++ ; } for ( int i = beg ; i <= end ; i ++ ) arr [ i ] = arr [ i ] / maxele ; } void mergeSortRec ( int arr [ ] , int beg , int end , int maxele ) { if ( beg < end ) { int mid = ( beg + end ) / 2 ; mergeSortRec ( arr , beg , mid , maxele ) ; mergeSortRec ( arr , mid + 1 , end , maxele ) ; merge ( arr , beg , mid , end , maxele ) ; } } void mergeSort ( int arr [ ] , int n ) { int maxele = * max_element ( arr , arr + n ) + 1 ; mergeSortRec ( arr , 0 , n - 1 , maxele ) ; } int main ( ) { int arr [ ] = { 999 , 612 , 589 , 856 , 56 , 945 , 243 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; mergeSort ( arr , n ) ; cout << " Sorted ▁ array ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printTriplets ( int arr [ ] , int n , int sum ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( int x = j + 1 ; x <= k ; x ++ ) cout << arr [ i ] << " , ▁ " << arr [ j ] << " , ▁ " << arr [ x ] << endl ; j ++ ; } } } } int main ( ) { int arr [ ] = { 5 , 1 , 3 , 4 , 7 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int sum = 12 ; printTriplets ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string areBookingsPossible ( int A [ ] , int B [ ] , int K , int N ) { sort ( A , A + N ) ; sort ( B , B + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( i + K < N && A [ i + K ] < B [ i ] ) { return " No " ; } } return " Yes " ; } int main ( ) { int arrival [ ] = { 1 , 2 , 3 } ; int departure [ ] = { 2 , 3 , 4 } ; int N = sizeof ( arrival ) / sizeof ( arrival [ 0 ] ) ; int K = 1 ; cout << ( areBookingsPossible ( arrival , departure , K , N ) ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; using Vector = vector < int > ; void printVector ( const Vector & V ) { for ( auto e : V ) { cout << e << " ▁ " ; } cout << endl ; } void insertionSortRecursive ( Vector & V , int N ) { if ( N <= 1 ) return ; insertionSortRecursive ( V , N - 1 ) ; int j = N - 1 ; while ( j > 0 and V [ j ] < V [ j - 1 ] ) { swap ( V [ j ] , V [ j - 1 ] ) ; j -= 1 ; } } int main ( ) { Vector A = { 9 , 8 , 7 , 5 , 2 , 1 , 2 , 3 } ; cout << " Array : ▁ " << endl ; printVector ( A ) ; cout << " After ▁ Sorting ▁ : " << endl ; insertionSortRecursive ( A , A . size ( ) ) ; printVector ( A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; int minElements ( int arr [ ] , int n ) { int halfSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) halfSum = halfSum + arr [ i ] ; halfSum = halfSum / 2 ; sort ( arr , arr + n , greater < int > ( ) ) ; int res = 0 , curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { curr_sum += arr [ i ] ; res ++ ; if ( curr_sum > halfSum ) return res ; } return res ; } int main ( ) { int arr [ ] = { 3 , 1 , 7 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minElements ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextGap ( int gap ) { if ( gap <= 1 ) return 0 ; return ( gap / 2 ) + ( gap % 2 ) ; } void merge ( int * arr1 , int * arr2 , int n , int m ) { int i , j , gap = n + m ; for ( gap = nextGap ( gap ) ; gap > 0 ; gap = nextGap ( gap ) ) { for ( i = 0 ; i + gap < n ; i ++ ) if ( arr1 [ i ] > arr1 [ i + gap ] ) swap ( arr1 [ i ] , arr1 [ i + gap ] ) ; for ( j = gap > n ? gap - n : 0 ; i < n && j < m ; i ++ , j ++ ) if ( arr1 [ i ] > arr2 [ j ] ) swap ( arr1 [ i ] , arr2 [ j ] ) ; if ( j < m ) { for ( j = 0 ; j + gap < m ; j ++ ) if ( arr2 [ j ] > arr2 [ j + gap ] ) swap ( arr2 [ j ] , arr2 [ j + gap ] ) ; } } } int main ( ) { int a1 [ ] = { 10 , 27 , 38 , 43 , 82 } ; int a2 [ ] = { 3 , 9 } ; int n = sizeof ( a1 ) / sizeof ( int ) ; int m = sizeof ( a2 ) / sizeof ( int ) ; merge ( a1 , a2 , n , m ) ; printf ( " First ▁ Array : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , a1 [ i ] ) ; printf ( " Second Array : " for ( int i = 0 ; i < m ; i ++ ) printf ( " % d ▁ " , a2 [ i ] ) ; printf ( " STRNEWLINE " ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void mergeArrays ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 , int arr3 [ ] ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) arr3 [ k ++ ] = arr1 [ i ++ ] ; else arr3 [ k ++ ] = arr2 [ j ++ ] ; } while ( i < n1 ) arr3 [ k ++ ] = arr1 [ i ++ ] ; while ( j < n2 ) arr3 [ k ++ ] = arr2 [ j ++ ] ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int arr2 [ ] = { 2 , 4 , 6 , 8 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int arr3 [ n1 + n2 ] ; mergeArrays ( arr1 , arr2 , n1 , n2 , arr3 ) ; cout << " Array ▁ after ▁ merging " << endl ; for ( int i = 0 ; i < n1 + n2 ; i ++ ) cout << arr3 [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortSquares ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] * arr [ i ] ; sort ( arr , arr + n ) ; } int main ( ) { int arr [ ] = { -6 , -3 , -1 , 2 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Before ▁ sort ▁ " << endl ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; sortSquares ( arr , n ) ; cout << " After Sort " for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int a [ ] , int b [ ] , int n , int k ) { sort ( a , a + n ) ; sort ( b , b + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] + b [ i ] < k ) return false ; return true ; } int main ( ) { int a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 7 , 8 , 9 } ; int k = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; isPossible ( a , b , n , k ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDiff ( int arr [ ] , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; sort ( arr , arr + n ) ; if ( n < m ) return -1 ; int min_diff = INT_MAX ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; } int main ( ) { int arr [ ] = { 12 , 4 , 7 , 9 , 2 , 23 , 25 , 41 , 30 , 40 , 28 , 42 , 30 , 44 , 48 , 43 , 50 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ difference ▁ is ▁ " << findMinDiff ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int setBitCount ( int num ) { int count = 0 ; while ( num ) { if ( num & 1 ) count ++ ; num >>= 1 ; } return count ; } void sortBySetBitCount ( int arr [ ] , int n ) { multimap < int , int > count ; for ( int i = 0 ; i < n ; ++ i ) { count . insert ( { ( -1 ) * setBitCount ( arr [ i ] ) , arr [ i ] } ) ; } for ( auto i : count ) cout << i . second << " ▁ " ; cout << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortBySetBitCount ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinctCount ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( abs ( arr [ i ] ) ) ; return s . size ( ) ; } int main ( ) { int arr [ ] = { -2 , -1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ absolute ▁ distinct ▁ values ▁ : ▁ " << distinctCount ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinctCount ( int arr [ ] , int n ) { int count = n ; int i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) { while ( i != j && arr [ i ] == arr [ i + 1 ] ) count -- , i ++ ; while ( i != j && arr [ j ] == arr [ j - 1 ] ) count -- , j -- ; if ( i == j ) break ; sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) { count -- ; i ++ , j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; } int main ( ) { int arr [ ] = { -2 , -1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ absolute ▁ distinct ▁ values ▁ : ▁ " << distinctCount ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE void sortStrings ( char arr [ ] [ MAX ] , int n ) { char temp [ MAX ] ; for ( int j = 0 ; j < n - 1 ; j ++ ) { for ( int i = j + 1 ; i < n ; i ++ ) { if ( strcmp ( arr [ j ] , arr [ i ] ) > 0 ) { strcpy ( temp , arr [ j ] ) ; strcpy ( arr [ j ] , arr [ i ] ) ; strcpy ( arr [ i ] , temp ) ; } } } } int main ( ) { char arr [ ] [ MAX ] = { " GeeksforGeeks " , " Quiz " , " Practice " , " Gblogs " , " Coding " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortStrings ( arr , n ) ; printf ( " Strings ▁ in ▁ sorted ▁ order ▁ are ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) printf ( " String % d is % s " , i + 1 , arr [ i ] ) ; return 0 ; }
#include <iostream> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; void sortByOneSwap ( int arr [ ] , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] < arr [ i - 1 ] ) { int j = i - 1 ; while ( j >= 0 && arr [ i ] < arr [ j ] ) j -- ; swap ( arr [ i ] , arr [ j + 1 ] ) ; break ; } } } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 10 , 30 , 20 , 40 , 50 , 60 , 70 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Given ▁ array ▁ is ▁ STRNEWLINE " ; printArray ( arr , n ) ; sortByOneSwap ( arr , n ) ; cout << " Sorted ▁ array ▁ is ▁ STRNEWLINE " ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canReach ( string s , int L , int R ) { vector < int > dp ( s . length ( ) ) ; dp [ 0 ] = 1 ; int pre = 0 ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( i >= L ) { pre += dp [ i - L ] ; } if ( i > R ) { pre -= dp [ i - R - 1 ] ; } dp [ i ] = ( pre > 0 ) and ( s [ i ] == '0' ) ; } return dp [ s . length ( ) - 1 ] ; } int main ( ) { string S = "01101110" ; int L = 2 , R = 3 ; cout << ( canReach ( S , L , R ) ? " Yes " : " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string performOperation ( string S , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { if ( S [ i ] == ' a ' ) { S [ i ] = ' b ' ; } else { S [ i ] = ' a ' ; } } else { if ( S [ i ] == ' z ' ) { S [ i ] = ' y ' ; } else { S [ i ] = ' z ' ; } } } return S ; } int main ( ) { string S = " giad " ; int N = S . size ( ) ; cout << performOperation ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int x , int N ) { while ( 1 ) { N -= x ; if ( x < 10 ) break ; int temp2 = 0 ; while ( x ) { temp2 *= 10 ; temp2 += ( x % 10 ) ; x /= 10 ; } x = temp2 ; } if ( ( x < 10 ) && ( N == 0 ) ) { return 1 ; } return 0 ; } int countNoOfsuchX ( int N ) { int k = ceil ( log10 ( N ) ) ; int count = 1 ; for ( int x = ( N - ( k * ( k + 1 ) * 5 ) ) ; x < N ; x ++ ) { if ( check ( x , N ) ) { count += 1 ; } } return count ; } int main ( ) { int N = 9399 ; cout << countNoOfsuchX ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long proc ( vector < int > & v ) { long long int n = v . size ( ) ; int low = v [ n - 1 ] , high = v [ n - 1 ] ; long long int p1 = n , p2 = n ; long long ans = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int x = v [ i ] ; if ( x < low ) { low = x ; ans = 0 ; } else if ( x > high ) { high = x ; ans = 0 ; } if ( x == low ) p1 = i ; if ( x == high ) p2 = i ; ans += n - max ( p1 , p2 ) ; } return ans ; } long long subarray ( vector < int > & v ) { long long int n = v . size ( ) ; if ( n <= 1 ) return n ; long long ans = proc ( v ) ; int low = v [ 0 ] , pos_low = 0 , high = v [ 0 ] , pos_high = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int x = v [ i ] ; if ( x < low ) { low = x ; pos_low = i ; } else if ( x > high ) { high = x ; pos_high = i ; } } vector < int > u ; u = v ; u . erase ( u . begin ( ) + pos_low ) ; ans = max ( ans , proc ( u ) ) ; vector < int > w ; w = v ; w . erase ( w . begin ( ) + pos_high ) ; return max ( ans , proc ( w ) ) ; } int main ( ) { vector < int > v ; v . push_back ( 7 ) ; v . push_back ( 2 ) ; v . push_back ( 5 ) ; v . push_back ( 4 ) ; v . push_back ( 3 ) ; v . push_back ( 1 ) ; cout << subarray ( v ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( vector < int > arr , int N ) { int Sum = 0 ; for ( auto i : arr ) Sum += i ; if ( Sum % N ) return -1 ; int k = Sum / N ; int ans = 0 ; int i = 0 ; while ( i < N ) { ans = ans + abs ( k - arr [ i ] ) ; i += 1 ; } return ans / 2 ; } int main ( ) { vector < int > arr = { 5 , 4 , 1 , 10 } ; int N = arr . size ( ) ; cout << ( find ( arr , N ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSteps ( int a , int b ) { int cnt = 0 ; a = abs ( a - b ) ; cnt = ( a / 5 ) + ( a % 5 ) / 2 + ( a % 5 ) % 2 ; return cnt ; } int main ( ) { int A = 3 , B = 9 ; cout << minimumSteps ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int shortestDistance ( string s , int n ) { vector < int > visited ( 128 , -1 ) ; int ans = INT_MAX ; for ( int right = 0 ; right < n ; right ++ ) { char c = s [ right ] ; int left = visited ; if ( left != -1 ) ans = min ( ans , right - left - 1 ) ; visited = right ; } return ans == INT_MAX ? -1 : ans ; } int main ( ) { string s = " geeksforgeeks " ; int n = 13 ; cout << ( shortestDistance ( s , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string smallestNonSubsequence ( string S , int N ) { int freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( S [ i ] == ' a ' ) freq ++ ; string ans ( freq , ' a ' ) ; if ( freq == N ) ans [ freq - 1 ] = ' b ' ; else ans += ' a ' ; return ans ; } int main ( ) { string S = " abcdefghijklmnopqrstuvwxyz " ; int N = S . length ( ) ; cout << smallestNonSubsequence ( S , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void possibleNumbers ( int N , int M , int A , int B ) { if ( A > B ) { swap ( A , B ) ; } int number = N + M * A ; cout << number << " ▁ " ; if ( A != B ) { for ( int i = 0 ; i < M ; i ++ ) { number = number - A + B ; cout << number << " ▁ " ; } } } int main ( ) { int N = 5 , M = 3 , A = 4 , B = 6 ; possibleNumbers ( N , M , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countUnsetBits ( int N ) { int c = 0 ; while ( N ) { if ( N % 2 == 0 ) { c += 1 ; } N = N >> 1 ; } return c ; } void countBitwiseZero ( int N ) { int unsetBits = countUnsetBits ( N ) ; cout << ( 1 << unsetBits ) ; } int main ( ) { int N = 9 ; countBitwiseZero ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxXORUtil ( int arr [ ] , int N , int xrr , int orr ) { if ( N == 0 ) return xrr ^ orr ; int x = maxXORUtil ( arr , N - 1 , xrr ^ orr , arr [ N - 1 ] ) ; int y = maxXORUtil ( arr , N - 1 , xrr , orr arr [ N - 1 ] ) ; return max ( x , y ) ; } int maximumXOR ( int arr [ ] , int N ) { return maxXORUtil ( arr , N , 0 , 0 ) ; } int main ( ) { int arr [ ] = { 1 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumXOR ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void leastBricks ( vector < vector < int > > wall ) { unordered_map < int , int > map ; int res = 0 ; for ( vector < int > list : wall ) { int width = 0 ; for ( int i = 0 ; i < list . size ( ) - 1 ; i ++ ) { width += list [ i ] ; map [ width ] ++ ; res = max ( res , map [ width ] ) ; } } cout << wall . size ( ) - res ; } int main ( ) { vector < vector < int > > arr { { 1 , 2 , 2 , 1 } , { 3 , 1 , 2 } , { 1 , 3 , 2 } , { 2 , 4 } , { 3 , 1 , 2 } , { 1 , 3 , 1 , 1 } } ; leastBricks ( arr ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void findPermutation ( int N ) { for ( int i = 1 ; i <= N ; i ++ ) cout << i << " ▁ " ; cout << endl ; } int main ( ) { int N = 5 ; findPermutation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfWays ( int N , int X , int Y ) { int S1 = ( N - 1 ) * X + Y ; int S2 = ( N - 1 ) * Y + X ; return ( S2 - S1 + 1 ) ; } int main ( ) { int N = 3 ; int X = 13 ; int Y = 15 ; cout << numberOfWays ( N , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumOperations ( int A [ ] , int N , int K ) { int Count = 0 ; int i = 0 ; while ( i < N - 1 ) { i = i + K - 1 ; Count ++ ; } return Count ; } int main ( ) { int A [ ] = { 5 , 4 , 3 , 1 , 2 } ; int K = 3 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << MinimumOperations ( A , N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define endl  " NEW_LINE " #define ll  long long NEW_LINE using namespace std ; bool is_prime ( ll n ) { if ( n == 1 ) { return false ; } for ( ll i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } void consecutive_primes ( int n ) { ll first = -1 , second = -1 ; for ( ll i = sqrt ( n ) ; i >= 2 ; i -- ) { if ( is_prime ( i ) ) { first = i ; break ; } } for ( ll i = sqrt ( n ) + 1 ; i <= n / 2 ; i ++ ) { if ( is_prime ( i ) ) { second = i ; break ; } } if ( first * second >= n ) { cout << first << " ▁ " << second << endl ; } else { for ( ll i = second + 1 ; i <= n ; i ++ ) { if ( is_prime ( i ) ) { cout << second << " ▁ " << i << endl ; return ; } } } } int main ( ) { ll n = 14 ; consecutive_primes ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 3 ; const int m = 3 ; void countDecrements ( long long arr [ ] [ m ] ) { int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_1 ++ ; if ( 1 - ( i + j ) % 2 == arr [ i ] [ j ] % 2 ) count_2 ++ ; } } cout << min ( count_1 , count_2 ) ; } int main ( ) { long long arr [ ] [ m ] = { { 1 , 2 , 3 } , { 1 , 2 , 3 } , { 1 , 2 , 3 } } ; countDecrements ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( int X , int Y ) { if ( X > 3 ) { cout << " Yes " ; } else if ( X == 1 and Y == 1 ) { cout << " Yes " ; } else if ( X == 2 and Y <= 3 ) { cout << " Yes " ; } else if ( X == 3 and Y <= 3 ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int X = 6 , Y = 8 ; check ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distIntegers ( int L , int R ) { return 2 * R - 2 * L + 1 ; } int main ( ) { int L = 3 , R = 8 ; cout << distIntegers ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void evenXorSubarray ( int arr [ ] , int n ) { int ans = 0 ; int freq [ ] = { 0 , 0 } ; int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { XOR = XOR ^ arr [ i ] ; if ( XOR % 2 == 0 ) { ans += freq [ 0 ] + 1 ; freq [ 0 ] ++ ; } else { ans += freq [ 1 ] ; freq [ 1 ] ++ ; } } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; evenXorSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOccurrences ( int N , int X ) { int count = 0 ; for ( int i = 1 ; i < sqrt ( X ) ; i ++ ) { if ( X % i == 0 ) { int a = i ; int b = X / i ; if ( a <= N && b <= N ) { if ( a == b ) count += 1 ; else count += 2 ; } } } return count ; } int main ( ) { int N = 7 ; int X = 12 ; cout << countOccurrences ( N , X ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void findPerfectIndex ( int N , int K ) { int i = 0 ; for ( ; i < K ; i ++ ) { cout << ( N - K + 1 ) + i << " ▁ " ; } for ( ; i < N ; i ++ ) { cout << i - K + 1 << " ▁ " ; } } int main ( ) { int N = 10 , K = 3 ; findPerfectIndex ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long countPairs ( long L , long R ) { long firstNum = 2 * L ; long lastNum = 2 * R ; long Cntpairs = lastNum - firstNum + 1 ; cout << Cntpairs ; } int main ( ) { long L = 2 , R = 3 ; countPairs ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int A [ ] , int n ) { long long count = ( n * ( n - 1 ) ) / 2 ; unordered_map < long long , long long > ump ; for ( int i = 0 ; i < n ; i ++ ) { ump [ A [ i ] ] ++ ; } for ( auto it = ump . begin ( ) ; it != ump . end ( ) ; ++ it ) { long long c = it -> second ; count = count - ( c * ( c - 1 ) ) / 2 ; } cout << count ; } int main ( ) { int A [ ] = { 1 , 4 , 7 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; countPairs ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrayElementEqual ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum % N == 0 ) { cout << " Yes " ; } else { cout << " No " << endl ; } } int main ( ) { int arr [ ] = { 1 , 5 , 6 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; arrayElementEqual ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string check ( int current_row , int current_col , int destination_row , int destination_col ) { if ( current_row == destination_row ) return " POSSIBLE " ; else if ( current_col == destination_col ) return " POSSIBLE " ; else return " NOT ▁ POSSIBLE " ; } int main ( ) { int current_row = 8 ; int current_col = 8 ; int destination_row = 8 ; int destination_col = 4 ; string output = check ( current_row , current_col , destination_row , destination_col ) ; cout << output ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDiv ( int N , int X , int M , int & res ) { if ( X == 0 ) { if ( N % M == 0 ) { res = N ; return true ; } return false ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( isDiv ( N * 10 + i , X - 1 , M , res ) ) { return true ; } } } int main ( ) { int N = 4 , M = 50 , X = 2 ; int res = -1 ; isDiv ( N , X , M , res ) ; cout << res ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumMoves ( int arr [ ] , int N ) { int sum = 0 ; int maxelement = -1 ; if ( N == 2 ) { cout << 0 ; } for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; maxelement = max ( maxelement , arr [ i ] ) ; } int K = ( sum + N - 2 ) / ( N - 1 ) ; K = max ( maxelement , K ) ; int ans = K * ( N - 1 ) - sum ; cout << ans ; } int main ( ) { int arr [ ] = { 2 , 3 , 7 } ; int N = 3 ; minimumMoves ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printSubsequence ( int N ) { cout << " { ▁ " ; for ( int i = 1 ; i < N - 1 ; i ++ ) { cout << i << " , ▁ " ; } cout << N - 1 << " ▁ } STRNEWLINE " ; cout << " { ▁ " << N << " ▁ } " ; } int main ( ) { int N = 8 ; printSubsequence ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void array_divisbleby_k ( int N , int K ) { bool flag = false ; int d1 , d2 ; for ( int i = 2 ; i * i <= K ; i ++ ) { if ( K % i == 0 ) { flag = true ; d1 = i ; d2 = K / i ; break ; } } if ( flag ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 1 ) { cout << d2 << " ▁ " ; } else { cout << d1 << " ▁ " ; } } } else { cout << -1 ; } } int main ( ) { int N = 5 , K = 21 ; array_divisbleby_k ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print ( vector < vector < char > > arr , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { char a = arr [ i ] [ j ] ; if ( ( i + j ) % 2 == 0 && a == ' F ' ) { arr [ i ] [ j ] = '1' ; } else if ( a == ' F ' ) { arr [ i ] [ j ] = '2' ; } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { cout << arr [ i ] [ j ] ; } cout << endl ; } } int main ( ) { int n = 4 , m = 4 ; vector < vector < char > > arr = { { ' F ' , ' F ' , ' F ' , ' F ' } , { ' F ' , ' O ' , ' F ' , ' F ' } , { ' F ' , ' F ' , ' O ' , ' F ' } , { ' F ' , ' F ' , ' F ' , ' F ' } , } ; print ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeDuplicateLetters ( string s ) { int cnt [ 26 ] = { 0 } ; int vis [ 26 ] = { 0 } ; int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) cnt [ s [ i ] - ' a ' ] ++ ; string res = " " ; for ( int i = 0 ; i < n ; i ++ ) { cnt [ s [ i ] - ' a ' ] -- ; if ( ! vis [ s [ i ] - ' a ' ] ) { while ( res . size ( ) > 0 && res . back ( ) > s [ i ] && cnt [ res . back ( ) - ' a ' ] > 0 ) { vis [ res . back ( ) - ' a ' ] = 0 ; res . pop_back ( ) ; } res += s [ i ] ; vis [ s [ i ] - ' a ' ] = 1 ; } } return res ; } int main ( ) { string S = " acbc " ; cout << removeDuplicateLetters ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumSides ( int n ) { if ( n < 4 ) return -1 ; return n % 2 == 0 ? n / 2 : -1 ; } int main ( ) { int N = 8 ; cout << MaximumSides ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minCost ( string s , int k ) { int n = s . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int a [ 26 ] ; for ( int p = 0 ; p < 26 ; p ++ ) { a [ p ] = 0 ; } for ( int j = i ; j < n ; j += k ) { a [ s [ j ] - ' a ' ] ++ ; } int min_cost = INT_MAX ; for ( int ch = 0 ; ch < 26 ; ch ++ ) { int cost = 0 ; for ( int tr = 0 ; tr < 26 ; tr ++ ) cost += abs ( ch - tr ) * a [ tr ] ; min_cost = min ( min_cost , cost ) ; } ans += min_cost ; } cout << ( ans ) ; } int main ( ) { string S = " abcdefabc " ; int K = 3 ; minCost ( S , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minAbsDiff ( int N ) { if ( N % 4 == 0 N % 4 == 3 ) { return 0 ; } return 1 ; } int main ( ) { int N = 6 ; cout << minAbsDiff ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int N ) { int countPowerof2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( __builtin_popcount ( arr [ i ] ) == 1 ) countPowerof2 ++ ; } int desiredPairs = ( countPowerof2 * ( countPowerof2 - 1 ) ) / 2 ; cout << desiredPairs << ' ▁ ' ; } int main ( ) { int arr [ 4 ] = { 2 , 4 , 7 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  1000000 NEW_LINE int is_prime [ MAXN ] = { 0 } ; int count_of_primes [ MAXN ] = { 0 } ; void sieve ( ) { for ( int i = 3 ; i < MAXN ; i += 2 ) { is_prime [ i ] = 1 ; } for ( int i = 3 ; i * i < MAXN ; i += 2 ) { if ( is_prime [ i ] ) for ( int j = i * i ; j < MAXN ; j += i ) { is_prime [ j ] = 0 ; } } is_prime [ 2 ] = 1 ; for ( int i = 1 ; i < MAXN ; i ++ ) count_of_primes [ i ] = count_of_primes [ i - 1 ] + is_prime [ i ] ; } long long int power ( long long int x , long long int y , long long int p ) { long long result = 1 ; while ( y > 0 ) { if ( y & 1 == 1 ) result = ( result * x ) % p ; x = ( x * x ) % p ; y >>= 1 ; } return result ; } void numberOfWays ( int N ) { long long int count = count_of_primes [ N ] - 1 ; long long int mod = 1000000007 ; long long int answer = power ( 2 , count , mod ) ; if ( N == 1 ) answer = 0 ; cout << answer ; } int main ( ) { sieve ( ) ; int N = 7 ; numberOfWays ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSumOfSquares ( int N , int S ) { int res = 0 ; if ( S < N S > 9 * N ) { cout << ( -1 ) ; return ; } S = S - N ; int c = 0 ; while ( S > 0 ) { c ++ ; if ( S / 8 > 0 ) { res += 9 * 9 ; S -= 8 ; } else { res += ( S + 1 ) * ( S + 1 ) ; break ; } } res = res + ( N - c ) ; cout << ( res ) ; } int main ( ) { int N = 3 ; int S = 12 ; maxSumOfSquares ( N , S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ncr ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int countPath ( int N , int M , int K ) { int answer ; if ( K >= 2 ) answer = 0 ; else if ( K == 0 ) answer = ncr ( N + M - 2 , N - 1 ) ; else { answer = ncr ( N + M - 2 , N - 1 ) ; int X = ( N - 1 ) / 2 + ( M - 1 ) / 2 ; int Y = ( N - 1 ) / 2 ; int midCount = ncr ( X , Y ) ; X = ( ( N - 1 ) - ( N - 1 ) / 2 ) + ( ( M - 1 ) - ( M - 1 ) / 2 ) ; Y = ( ( N - 1 ) - ( N - 1 ) / 2 ) ; midCount *= ncr ( X , Y ) ; answer -= midCount ; } return answer ; } int main ( ) { int N = 3 ; int M = 3 ; int K = 1 ; cout << countPath ( N , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate_steps ( int arr [ ] , int n , int minimum ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int val = arr [ i ] ; if ( arr [ i ] > minimum ) { arr [ i ] = arr [ i ] - minimum ; count += arr [ i ] / 5 ; arr [ i ] = arr [ i ] % 5 ; count += arr [ i ] / 2 ; arr [ i ] = arr [ i ] % 2 ; if ( arr [ i ] ) { count ++ ; } } arr [ i ] = val ; } return count ; } int solve ( int arr [ ] , int n ) { sort ( arr , arr + n , greater < int > ( ) ) ; int minimum = arr [ n - 1 ] ; int count1 = 0 , count2 = 0 , count3 = 0 ; count1 = calculate_steps ( arr , n , minimum ) ; count2 = calculate_steps ( arr , n , minimum - 1 ) ; count3 = calculate_steps ( arr , n , minimum - 2 ) ; return min ( count1 , min ( count2 , count3 ) ) ; } int main ( ) { int arr [ ] = { 3 , 6 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << solve ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string mergePalindromes ( string S , string P ) { unordered_map < char , int > mapS , mapP , mapT ; int n = S . size ( ) , m = P . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mapS [ S [ i ] ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { mapP [ P [ i ] ] ++ ; } for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { if ( mapS [ i ] % 2 == 0 ) { mapT [ i ] += mapS [ i ] ; mapS [ i ] = 0 ; } else { mapT [ i ] += mapS [ i ] - 1 ; mapS [ i ] = 1 ; } if ( mapP [ i ] % 2 == 0 ) { mapT [ i ] += mapP [ i ] ; mapP [ i ] = 0 ; } else { mapT [ i ] += mapP [ i ] - 1 ; mapP [ i ] = 1 ; } } int check = 0 ; for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { if ( mapS [ i ] > 0 && mapP [ i ] > 0 ) { mapT [ i ] += 2 ; check = 1 ; break ; } } string half1 = " " , half2 = " " ; for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { for ( int j = 0 ; ( 2 * j ) < mapT [ i ] ; j ++ ) { half1 += i ; half2 += i ; } } reverse ( half2 . begin ( ) , half2 . end ( ) ) ; if ( check ) { return half1 + half2 ; } for ( char i = ' a ' ; i <= ' z ' ; i ++ ) { if ( mapS [ i ] > 0 mapP [ i ] > 0 ) { half1 += i ; return half1 + half2 ; } } return half1 + half2 ; } int main ( ) { string S = " aeabb " ; string P = " dfedf " ; cout << mergePalindromes ( S , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfSubarray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] -- ; int pref [ N ] ; pref [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) pref [ i ] = pref [ i - 1 ] + arr [ i ] ; map < int , int > mp ; int answer = 0 ; mp [ 0 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { answer += mp [ pref [ i ] ] ; mp [ pref [ i ] ] ++ ; } return answer ; } int main ( ) { int arr [ ] = { 1 , 1 , 0 } ; int N = sizeof arr / sizeof arr [ 0 ] ; cout << countOfSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printsubset ( int n , int k ) { int count = 0 , x = 0 ; vector < int > vec ; while ( n ) { x = n & 1 ; if ( x ) { vec . push_back ( pow ( k , count ) ) ; } n = n >> 1 ; count ++ ; } for ( int i = 0 ; i < vec . size ( ) ; i ++ ) cout << vec [ i ] << " ▁ " ; } int main ( ) { int n = 7 , k = 4 ; printsubset ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( string s , int x , int y ) { int res = 0 ; for ( auto c : s ) { if ( c - '0' == x ) { res ++ ; swap ( x , y ) ; } } if ( x != y && res % 2 == 1 ) -- res ; return res ; } int find_min ( string s ) { int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { count = max ( count , solve ( s , i , j ) ) ; } } return count ; } int main ( ) { string s = "100120013" ; int n = s . size ( ) ; int answer = find_min ( s ) ; cout << ( n - answer ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  10000 NEW_LINE vector < int > adj [ N ] ; int used [ N ] ; int max_matching ; void AddEdge ( int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void Matching_dfs ( int u , int p ) { for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( adj [ u ] [ i ] != p ) { Matching_dfs ( adj [ u ] [ i ] , u ) ; } } if ( ! used [ u ] and ! used [ p ] and p != 0 ) { max_matching ++ ; used [ u ] = used [ p ] = 1 ; } } void maxMatching ( ) { Matching_dfs ( 1 , 0 ) ; cout << max_matching << " STRNEWLINE " ; } int main ( ) { int n = 5 ; AddEdge ( 1 , 2 ) ; AddEdge ( 1 , 3 ) ; AddEdge ( 3 , 4 ) ; AddEdge ( 3 , 5 ) ; maxMatching ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_max ( vector < pair < int , int > > v , int n ) { int count = 0 ; if ( n >= 2 ) count = 2 ; else count = 1 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( v [ i - 1 ] . first < ( v [ i ] . first - v [ i ] . second ) ) count ++ ; else if ( v [ i + 1 ] . first > ( v [ i ] . first + v [ i ] . second ) ) { count ++ ; v [ i ] . first = v [ i ] . first + v [ i ] . second ; } else continue ; } return count ; } int main ( ) { int n = 3 ; vector < pair < int , int > > v ; v . push_back ( { 10 , 20 } ) ; v . push_back ( { 15 , 10 } ) ; v . push_back ( { 20 , 16 } ) ; cout << find_max ( v , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string gcd ( string str1 , string str2 ) { if ( str1 . length ( ) < str2 . length ( ) ) { return gcd ( str2 , str1 ) ; } else if ( str1 . find ( str2 ) != 0 ) { return " " ; } else if ( str2 == " " ) { return str1 ; } else { return gcd ( str1 . substr ( str2 . length ( ) ) , str2 ) ; } } string findGCD ( string arr [ ] , int n ) { string result = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { result = gcd ( result , arr [ i ] ) ; } return result ; } int main ( ) { string arr [ ] = { " GFGGFG " , " GFGGFG " , " GFGGFGGFGGFG " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findGCD ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE #define M  4 NEW_LINE string balancedMatrix ( int mat [ ] [ M ] ) { bool is_balanced = true ; for ( int i = 0 ; i < N && is_balanced ; i ++ ) { for ( int j = 0 ; j < M && is_balanced ; j ++ ) { if ( ( i == 0 i == N - 1 ) && ( j == 0 j == M - 1 ) ) { if ( mat [ i ] [ j ] >= 2 ) is_balanced = false ; } else if ( i == 0 i == N - 1 j == 0 j == M - 1 ) { if ( mat [ i ] [ j ] >= 3 ) is_balanced = false ; } else { if ( mat [ i ] [ j ] >= 4 ) is_balanced = false ; } } } if ( is_balanced ) return " Balanced " ; else return " Unbalanced " ; } int main ( ) { int mat [ N ] [ M ] = { { 1 , 2 , 3 , 4 } , { 3 , 5 , 2 , 6 } , { 5 , 3 , 6 , 1 } , { 9 , 5 , 6 , 0 } } ; cout << balancedMatrix ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string unixTimeToHumanReadable ( long int seconds ) { string ans = " " ; int daysOfMonth [ ] = { 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; long int currYear , daysTillNow , extraTime , extraDays , index , date , month , hours , minutes , secondss , flag = 0 ; daysTillNow = seconds / ( 24 * 60 * 60 ) ; extraTime = seconds % ( 24 * 60 * 60 ) ; currYear = 1970 ; while ( daysTillNow >= 365 ) { if ( currYear % 400 == 0 || ( currYear % 4 == 0 && currYear % 100 != 0 ) ) { daysTillNow -= 366 ; } else { daysTillNow -= 365 ; } currYear += 1 ; } extraDays = daysTillNow + 1 ; if ( currYear % 400 == 0 || ( currYear % 4 == 0 && currYear % 100 != 0 ) ) flag = 1 ; month = 0 , index = 0 ; if ( flag == 1 ) { while ( true ) { if ( index == 1 ) { if ( extraDays - 29 < 0 ) break ; month += 1 ; extraDays -= 29 ; } else { if ( extraDays - daysOfMonth [ index ] < 0 ) { break ; } month += 1 ; extraDays -= daysOfMonth [ index ] ; } index += 1 ; } } else { while ( true ) { if ( extraDays - daysOfMonth [ index ] < 0 ) { break ; } month += 1 ; extraDays -= daysOfMonth [ index ] ; index += 1 ; } } if ( extraDays > 0 ) { month += 1 ; date = extraDays ; } else { if ( month == 2 && flag == 1 ) date = 29 ; else { date = daysOfMonth [ month - 1 ] ; } } hours = extraTime / 3600 ; minutes = ( extraTime % 3600 ) / 60 ; secondss = ( extraTime % 3600 ) % 60 ; ans += to_string ( date ) ; ans += " / " ; ans += to_string ( month ) ; ans += " / " ; ans += to_string ( currYear ) ; ans += " ▁ " ; ans += to_string ( hours ) ; ans += " : " ; ans += to_string ( minutes ) ; ans += " : " ; ans += to_string ( secondss ) ; return ans ; } int main ( ) { long int T = 1595497956 ; string ans = unixTimeToHumanReadable ( T ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double AreaofRectangle ( int L , int W ) { double area = ( W + L ) * ( W + L ) / 2 ; return area ; } int main ( ) { int L = 18 ; int W = 12 ; cout << AreaofRectangle ( L , W ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int downToZero ( int n ) { if ( n <= 3 ) return n ; vector < int > dp ( n + 1 , -1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; int sqr ; for ( int i = 4 ; i <= n ; i ++ ) { sqr = sqrt ( i ) ; int best = INT_MAX ; while ( sqr > 1 ) { if ( i % sqr == 0 ) { best = min ( best , 1 + dp [ sqr ] ) ; } sqr -- ; } best = min ( best , 1 + dp [ i - 1 ] ) ; dp [ i ] = best ; } return dp [ n ] ; } int main ( ) { int n = 4 ; cout << downToZero ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int downToZero ( int n ) { if ( n <= 3 ) return n ; return n % 2 == 0 ? 3 : 4 ; } int main ( ) { int n = 4 ; cout << downToZero ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumrequired ( int A [ ] , int N ) { int K = N ; int ans ; while ( K > 0 ) { if ( K % 2 == 1 ) { ans = K ; break ; } bool ispalindrome = 1 ; for ( int i = 0 ; i < K / 2 ; i ++ ) { if ( A [ i ] != A [ K - 1 - i ] ) ispalindrome = 0 ; } if ( ispalindrome ) { ans = K / 2 ; K /= 2 ; } else { ans = K ; break ; } } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 2 , 1 , 1 , 2 , 2 , 1 } ; int N = sizeof a / sizeof a [ 0 ] ; cout << minimumrequired ( a , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMaxDifference ( int N ) { int M = -1 ; int maxDiff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int diff = ( N ^ i ) - ( N & i ) ; if ( diff >= maxDiff ) { maxDiff = diff ; M = i ; } } return M ; } int main ( ) { int N = 6 ; cout << getMaxDifference ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double cont [ 1000 ] [ 1000 ] ; void num_of_containers ( int n , double x ) { int count = 0 ; cont [ 1 ] [ 1 ] = x ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( cont [ i ] [ j ] >= ( double ) 1 ) { count ++ ; cont [ i + 1 ] [ j ] += ( cont [ i ] [ j ] - ( double ) 1 ) / ( double ) 2 ; cont [ i + 1 ] [ j + 1 ] += ( cont [ i ] [ j ] - ( double ) 1 ) / ( double ) 2 ; } } } cout << count ; } int main ( ) { int n = 3 ; double x = 5 ; num_of_containers ( n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findTriplet ( vector < int > & arr ) { int n = arr . size ( ) ; stack < int > st ; int h3 = INT_MIN , h1 = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { h1 = arr [ i ] ; while ( ! st . empty ( ) && st . top ( ) < arr [ i ] ) { h3 = st . top ( ) ; st . pop ( ) ; } st . push ( arr [ i ] ) ; if ( h1 < h3 ) { return true ; } } return false ; } int main ( ) { vector < int > arr = { 4 , 7 , 5 , 6 } ; if ( findTriplet ( arr ) ) { cout << " ▁ Yes " << ' ' ; } else { cout << " ▁ No " << ' ' ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printVector ( vector < int > & arr ) { if ( arr . size ( ) != 1 ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { cout << arr [ i ] << " ▁ " ; } cout << endl ; } } void findWays ( vector < int > & arr , int i , int n ) { if ( n == 0 ) printVector ( arr ) ; for ( int j = i ; j <= n ; j ++ ) { arr . push_back ( j ) ; findWays ( arr , j , n - j ) ; arr . pop_back ( ) ; } } int main ( ) { int n = 4 ; vector < int > arr ; findWays ( arr , 1 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinctNumbers ( int arr [ ] , int m , int n ) { unordered_map < int , int > count ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; vector < int > fre_arr ( n + 1 , 0 ) ; for ( auto it : count ) { fre_arr [ it . second ] ++ ; } int ans = count . size ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = fre_arr [ i ] ; if ( temp == 0 ) continue ; int t = min ( temp , m / i ) ; ans -= t ; m -= i * t ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 5 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 2 ; cout << distinctNumbers ( arr , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 4 ; const int N = 5 ; void no_of_moves ( int Matrix [ M ] [ N ] , int x , int y ) { int moves = 0 ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( Matrix [ i ] [ j ] != 0 ) { moves += abs ( x - i ) ; moves += abs ( y - j ) ; } } } cout << moves << " STRNEWLINE " ; } int main ( ) { int x = 3 ; int y = 2 ; int Matrix [ M ] [ N ] = { { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 1 , 0 , 1 } , { 0 , 0 , 1 , 1 , 0 } , { 1 , 1 , 1 , 0 , 0 } } ; int num = 1 ; no_of_moves ( Matrix , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Maximum_subsequence ( int A [ ] , int N ) { unordered_map < int , int > frequency ; int max_freq = 0 ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( auto it : frequency ) { if ( it . second > max_freq ) { max_freq = it . second ; } } cout << max_freq << endl ; } int main ( ) { int arr [ ] = { 5 , 2 , 6 , 5 , 2 , 4 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Maximum_subsequence ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeAll ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) cout << " YES " ; else cout << " NO " ; } int main ( ) { int Arr [ ] = { 10 , 4 , 7 , 1 , 3 , 6 } ; int size = sizeof ( Arr ) / sizeof ( Arr [ 0 ] ) ; removeAll ( Arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void FindSubarray ( int arr [ ] , int n ) { if ( n == 1 ) { cout << " No ▁ such ▁ subarray ! " << endl ; } int vis [ n + 1 ] ; memset ( vis , -1 , sizeof ( vis ) ) ; vis [ arr [ 0 ] ] = 0 ; int len = INT_MAX , flag = 0 ; int start , end ; for ( int i = 1 ; i < n ; i ++ ) { int t = arr [ i ] ; if ( vis [ t ] != -1 ) { int distance = i - vis [ t ] + 1 ; if ( distance < len ) { len = distance ; start = vis [ t ] ; end = i ; } flag = 1 ; } vis [ t ] = i ; } if ( flag == 0 ) cout << " No ▁ such ▁ subarray ! " << endl ; else { for ( int i = start ; i <= end ; i ++ ) cout << arr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 2 , 3 , 2 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; FindSubarray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstrings ( string s ) { int n = s . length ( ) ; int answer = ( n * ( n - 1 ) ) / 2 ; int cnt = 1 ; vector < int > v ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) cnt ++ ; else { v . push_back ( cnt ) ; cnt = 1 ; } } if ( cnt > 0 ) v . push_back ( cnt ) ; for ( int i = 0 ; i < v . size ( ) - 1 ; i ++ ) { answer -= ( v [ i ] + v [ i + 1 ] - 1 ) ; } return answer ; } int main ( ) { string s = "00111" ; cout << countSubstrings ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int get_palindrome_time ( string str ) { int hh , mm ; hh = ( str [ 0 ] - 48 ) * 10 + ( str [ 1 ] - 48 ) ; mm = ( str [ 3 ] - 48 ) * 10 + ( str [ 4 ] - 48 ) ; int requiredTime = 0 ; while ( hh % 10 != mm / 10 hh / 10 != mm % 10 ) { ++ mm ; if ( mm == 60 ) { mm = 0 ; ++ hh ; } if ( hh == 24 ) hh = 0 ; ++ requiredTime ; } return requiredTime ; } int main ( ) { string str = "05:39" ; cout << get_palindrome_time ( str ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSubarraySum ( int a [ ] , int n , vector < pair < int , int > > & subarrays ) { int i , maxsum = 0 ; int prefixArray [ n ] = { 0 } ; for ( i = 0 ; i < subarrays . size ( ) ; ++ i ) { prefixArray [ subarrays [ i ] . first - 1 ] ++ ; prefixArray [ subarrays [ i ] . second ] -- ; } for ( i = 1 ; i < n ; i ++ ) { prefixArray [ i ] += prefixArray [ i - 1 ] ; } sort ( prefixArray , prefixArray + n , greater < int > ( ) ) ; sort ( a , a + n , greater < int > ( ) ) ; for ( i = 0 ; i < n ; i ++ ) maxsum += a [ i ] * prefixArray [ i ] ; return maxsum ; } int main ( ) { int n = 6 ; int a [ ] = { 4 , 1 , 2 , 1 , 9 , 2 } ; vector < pair < int , int > > subarrays ; subarrays . push_back ( { 1 , 2 } ) ; subarrays . push_back ( { 1 , 3 } ) ; subarrays . push_back ( { 1 , 4 } ) ; subarrays . push_back ( { 3 , 4 } ) ; cout << maximumSubarraySum ( a , n , subarrays ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void DivideString ( string s , int n , int k ) { int i , c = 0 , no = 1 ; int c1 = 0 , c2 = 0 ; int fr [ 26 ] = { 0 } ; string ans = " " ; for ( i = 0 ; i < n ; i ++ ) { fr [ s [ i ] - ' a ' ] ++ ; } char ch , ch1 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( fr [ i ] == k ) { c ++ ; } if ( fr [ i ] > k && fr [ i ] != 2 * k ) { c1 ++ ; ch = i + ' a ' ; } if ( fr [ i ] == 2 * k ) { c2 ++ ; ch1 = i + ' a ' ; } } for ( i = 0 ; i < n ; i ++ ) ans = ans + "1" ; map < char , int > mp ; if ( c % 2 == 0 c1 > 0 c2 > 0 ) { for ( i = 0 ; i < n ; i ++ ) { if ( fr [ s [ i ] - ' a ' ] == k ) { if ( mp . find ( s [ i ] ) != mp . end ( ) ) { ans [ i ] = '2' ; } else { if ( no <= ( c / 2 ) ) { ans [ i ] = '2' ; no ++ ; mp [ s [ i ] ] = 1 ; } } } } if ( c % 2 == 1 && c1 > 0 ) { no = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch && no <= k ) { ans [ i ] = '2' ; no ++ ; } } } if ( c % 2 == 1 && c1 == 0 ) { no = 1 ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch1 && no <= k ) { ans [ i ] = '2' ; no ++ ; } if ( fr [ s [ i ] - ' a ' ] == k && flag == 0 && ans [ i ] == '1' ) { ans [ i ] = '2' ; flag = 1 ; } } } cout << ans << endl ; } else { cout << " NO " << endl ; } } int main ( ) { string S = " abbbccc " ; int N = S . size ( ) ; int K = 1 ; DivideString ( S , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int l , int r , string & s ) { while ( l <= r ) { if ( s [ l ] != s [ r ] ) return false ; l ++ ; r -- ; } return true ; } int numWays ( string & s ) { int n = s . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isPalindrome ( 0 , i , s ) && isPalindrome ( i + 1 , n - 1 , s ) ) { ans ++ ; } } return ans ; } int main ( ) { string S = " aaaaa " ; cout << numWays ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberofsubstrings ( string str , int k , char charArray [ ] ) { int N = str . length ( ) ; bool available [ 26 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { available [ charArray [ i ] - ' a ' ] = 1 ; } int lastPos = -1 ; int ans = ( N * ( N + 1 ) ) / 2 ; for ( int i = 0 ; i < N ; i ++ ) { if ( available [ str [ i ] - ' a ' ] == 0 ) { ans -= ( ( i - lastPos ) * ( N - i ) ) ; lastPos = i ; } } cout << ans << endl ; } int main ( ) { string str = " abcb " ; int k = 2 ; char charArray [ k ] = { ' a ' , ' b ' } ; numberofsubstrings ( str , k , charArray ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinJumps ( string s ) { vector < int > ones ; int jumps = 0 , median = 0 , ind = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) ones . push_back ( i ) ; } if ( ones . size ( ) == 0 ) return jumps ; median = ones [ ones . size ( ) / 2 ] ; ind = median ; for ( int i = ind ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) { jumps += ind - i ; ind -- ; } } ind = median ; for ( int i = ind ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '1' ) { jumps += i - ind ; ind ++ ; } } return jumps ; } int main ( ) { string S = "00100000010011" ; cout << getMinJumps ( S ) << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string check ( int S , int prices [ ] , int type [ ] , int n ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( ( type [ j ] == 0 && type [ k ] == 1 ) || ( type [ j ] == 1 && type [ k ] == 0 ) ) { if ( prices [ j ] + prices [ k ] <= S ) { return " Yes " ; } } } } return " No " ; } int main ( ) { int prices [ ] = { 3 , 8 , 6 , 5 } ; int type [ ] = { 0 , 1 , 1 , 0 } ; int S = 10 ; int n = 4 ; cout << check ( S , prices , type , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) ans ++ ; } } return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << numPairs ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int BalancedPartition ( string str , int n ) { if ( n == 0 ) return 0 ; int r = 0 , l = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' R ' ) { r ++ ; } else if ( str [ i ] = ' L ' ) { l ++ ; } if ( r == l ) { ans ++ ; } } return ans ; } int main ( ) { string str = " LLRRRLLRRL " ; int n = str . size ( ) ; cout << BalancedPartition ( str , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOccupiedPosition ( int A [ ] , int n ) { int minPos = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] > 0 ) { ++ minPos ; i += 2 ; } } return minPos ; } int main ( ) { int A [ ] = { 8 , 0 , 7 , 0 , 0 , 6 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minOccupiedPosition ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumK ( int a [ ] , int n , int S ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return ceil ( ( ( S + 1 ) * 1.0 ) / ( sum * 1.0 ) ) ; } int main ( ) { int a [ ] = { 10 , 7 , 8 , 10 , 12 , 19 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int S = 200 ; cout << findMinimumK ( a , n , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largestNum ( int n ) { int num = 0 ; for ( int i = 0 ; i <= 32 ; i ++ ) { int x = ( 1 << i ) ; if ( ( x - 1 ) <= n ) num = ( 1 << i ) - 1 ; else break ; } return num ; } int main ( ) { int N = 345 ; cout << largestNum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findString ( int N , int K ) { for ( int i = 0 ; i < N ; i ++ ) { cout << char ( ' A ' + i % K ) ; } } int main ( ) { int N = 10 ; int K = 3 ; findString ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( string s ) { int N , i , cnt = 0 , ans = 0 ; N = s . length ( ) ; for ( i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' R ' ) cnt ++ ; if ( s [ i ] == ' L ' ) ans += cnt ; } return ans ; } int main ( ) { string s = " RRLL " ; cout << count ( s ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void segments ( int n ) { if ( n == 1 n == 0 ) { return ; } if ( n % 2 == 0 ) { cout << "1" ; segments ( n - 2 ) ; } else if ( n % 2 == 1 ) { cout << "7" ; segments ( n - 3 ) ; } } int main ( ) { int n ; n = 11 ; segments ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void horizontalFill ( int records [ ] , int tape [ ] , int nt ) { int sum = 0 ; int Retrieval_Time = 0 ; double Mrt ; int current = 0 ; vector < int > v ; for ( int i = 0 ; i < nt ; i ++ ) { v . clear ( ) ; Retrieval_Time = 0 ; sum = 0 ; cout << " tape ▁ " << i + 1 << " ▁ : ▁ [ ▁ " ; sum += records [ current ] ; while ( sum <= tape [ i ] ) { cout << records [ current ] << " ▁ " ; v . push_back ( records [ current ] ) ; current ++ ; sum += records [ current ] ; } cout << " ] " ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { Retrieval_Time += v [ i ] * ( v . size ( ) - i ) ; } Mrt = ( double ) Retrieval_Time / v . size ( ) ; cout << " TABSYMBOL MRT ▁ : ▁ " << Mrt << endl ; } } int main ( ) { int records [ ] = { 15 , 2 , 8 , 23 , 45 , 50 , 60 , 120 } ; int tape [ ] = { 25 , 80 , 160 } ; int n = sizeof ( records ) / sizeof ( records [ 0 ] ) ; int m = sizeof ( tape ) / sizeof ( tape [ 0 ] ) ; sort ( records , records + n ) ; horizontalFill ( records , tape , m ) ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX_SIZE  10 NEW_LINE void convolution ( int * x , int * h , int n , int m ) { int row_vec [ MAX_SIZE ] , col_vec [ MAX_SIZE ] ; int out [ MAX_SIZE ] = { 0 } ; int circular_shift_mat [ MAX_SIZE ] [ MAX_SIZE ] ; int maxSize = n > m ? n : m ; for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i >= n ) { row_vec [ i ] = 0 ; } else { row_vec [ i ] = x [ i ] ; } } for ( int i = 0 ; i < maxSize ; i ++ ) { if ( i >= m ) { col_vec [ i ] = 0 ; } else { col_vec [ i ] = h [ i ] ; } } int k = 0 , d = 0 ; for ( int i = 0 ; i < maxSize ; i ++ ) { int curIndex = k - d ; for ( int j = 0 ; j < maxSize ; j ++ ) { circular_shift_mat [ j ] [ i ] = row_vec [ curIndex % maxSize ] ; curIndex ++ ; } k = maxSize ; d ++ ; } for ( int i = 0 ; i < maxSize ; i ++ ) { for ( int j = 0 ; j < maxSize ; j ++ ) { out [ i ] += circular_shift_mat [ i ] [ j ] * col_vec [ j ] ; } cout << out [ i ] << " ▁ " ; } } int main ( ) { int x [ ] = { 5 , 7 , 3 , 2 } ; int n = sizeof ( x ) / sizeof ( int ) ; int h [ ] = { 1 , 5 } ; int m = sizeof ( h ) / sizeof ( int ) ; convolution ( x , h , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_palindrome ( string s [ ] , int n ) { int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] . size ( ) % 2 != 0 ) { flag = 1 ; } } if ( flag == 1 ) { return n ; } int z = 0 , o = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < s [ i ] . size ( ) ; j ++ ) { if ( s [ i ] [ j ] == '0' ) z ++ ; else o ++ ; } } if ( o % 2 == 0 && z % 2 == 0 ) { return n ; } else { return n - 1 ; } } int main ( ) { int n = 3 ; string s [ n ] = { "1110" , "100110" , "010101" } ; cout << max_palindrome ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( vector < int > & cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; } int main ( ) { vector < int > cost { 4 , 7 , 8 , 3 , 4 } ; int n = cost . size ( ) ; cout << minCost ( cost , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minFlipsSub ( string mat [ ] , int i , int j ) { int cnt0 = 0 , cnt1 = 0 ; if ( mat [ i ] [ j ] == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i ] [ j + 1 ] == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i + 1 ] [ j ] == '1' ) cnt1 ++ ; else cnt0 ++ ; if ( mat [ i + 1 ] [ j + 1 ] == '1' ) cnt1 ++ ; else cnt0 ++ ; return min ( cnt0 , cnt1 ) ; } int minFlips ( string mat [ ] , int r , int c ) { int res = INT_MAX ; for ( int i = 0 ; i < r - 1 ; i ++ ) { for ( int j = 0 ; j < c - 1 ; j ++ ) { res = min ( res , minFlipsSub ( mat , i , j ) ) ; } } return res ; } int main ( ) { string mat [ ] = { "0101" , "0101" , "0101" } ; int r = sizeof ( mat ) / sizeof ( string ) ; int c = mat [ 0 ] . length ( ) ; cout << minFlips ( mat , r , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findK ( int n , int k ) { int pos ; if ( n % 2 == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; } int countSetBits ( int n , int k ) { int kth = findK ( n , k ) ; return __builtin_popcount ( kth ) ; } int main ( ) { int n = 18 , k = 12 ; cout << countSetBits ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( string str1 , string str2 , int n ) { int cost = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str1 [ i ] != str2 [ i ] ) { if ( i < n - 1 && str1 [ i + 1 ] != str2 [ i + 1 ] ) { swap ( str1 [ i ] , str1 [ i + 1 ] ) ; cost ++ ; } else { cost ++ ; } } } return cost ; } int main ( ) { string str1 = " abb " , str2 = " bba " ; int n = str1 . length ( ) ; cout << minCost ( str1 , str2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_set ( int n ) { if ( n <= 2 ) { cout << " - 1" ; return ; } int sum1 = ( n * ( n - 1 ) ) / 2 ; int sum2 = n ; cout << sum1 << " ▁ " << sum2 ; } int main ( ) { int n = 8 ; find_set ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string get_maximum ( string s , int a [ ] ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = '0' + a [ s [ j ] - '0' ] ; j ++ ; } return s ; } } return s ; } int main ( ) { string s = "1337" ; int a [ ] = { 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 } ; cout << get_maximum ( s , a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSteps ( int n ) { int steps = 0 ; while ( n ) { int largest = sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; } int main ( ) { int n = 85 ; cout << countSteps ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } int maxSum ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int i = 0 ; while ( i < n && k > 0 && arr [ i ] < 0 ) { arr [ i ] *= -1 ; k -- ; i ++ ; } if ( k % 2 == 1 ) { int min = 0 ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ min ] > arr [ i ] ) min = i ; arr [ min ] *= -1 ; } return sumArr ( arr , n ) ; } int main ( ) { int arr [ ] = { -5 , 4 , 1 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; cout << maxSum ( arr , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = min ( c2 , min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += min ( c2 , c1 ) * 12 ; return sum ; } int main ( ) { int c1 = 5 , c2 = 2 , c3 = 3 , c4 = 4 ; cout << Maxsum ( c1 , c2 , c3 , c4 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printArray ( int N , int arr [ ] ) { for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } void replacedArray ( int N , int arr [ ] ) { int pos_sum , neg_sum , i , j , diff ; pos_sum = 0 ; neg_sum = 0 ; for ( i = N - 1 ; i >= 0 ; i -- ) { diff = abs ( pos_sum ) - abs ( neg_sum ) ; if ( arr [ i ] > 0 ) pos_sum += arr [ i ] ; else neg_sum += arr [ i ] ; arr [ i ] = abs ( diff ) ; } } int main ( ) { int N = 5 ; int arr [ ] = { 1 , -1 , 2 , 3 , -2 } ; replacedArray ( N , arr ) ; printArray ( N , arr ) ; N = 6 ; int arr1 [ ] = { -3 , -4 , -2 , 5 , 1 , -2 } ; replacedArray ( N , arr1 ) ; printArray ( N , arr1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; } int main ( ) { int a = 5 , b = 13 , n = 3 ; cout << findCountOfPairs ( a , b , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findArray ( int N , int P ) { int ans = ( P * ( P + 1 ) ) / 2 + ( N - P ) ; int arr [ N + 1 ] ; for ( int i = 1 ; i <= P ; i ++ ) arr [ i ] = i ; for ( int i = P + 1 ; i <= N ; i ++ ) arr [ i ] = 1 ; cout << " The ▁ Minimum ▁ Possible ▁ Sum ▁ is : ▁ " << ans << " STRNEWLINE " ; cout << " The ▁ Array ▁ Elements ▁ are : ▁ STRNEWLINE " ; for ( int i = 1 ; i <= N ; i ++ ) cout << arr [ i ] << ' ▁ ' ; } int main ( ) { int N = 5 , P = 3 ; findArray ( N , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string encryptString ( string str , int n ) { int i = 0 , cnt = 0 ; string encryptedStr = " " ; while ( i < n ) { cnt = i + 1 ; while ( cnt -- ) encryptedStr += str [ i ] ; i ++ ; } return encryptedStr ; } int main ( ) { string str = " geeks " ; int n = str . length ( ) ; cout << encryptString ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findIntersection ( int intervals [ ] [ 2 ] , int N ) { int l = intervals [ 0 ] [ 0 ] ; int r = intervals [ 0 ] [ 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { cout << -1 ; return ; } else { l = max ( l , intervals [ i ] [ 0 ] ) ; r = min ( r , intervals [ i ] [ 1 ] ) ; } } cout << " [ " << l << " , ▁ " << r << " ] " ; } int main ( ) { int intervals [ ] [ 2 ] = { { 1 , 6 } , { 2 , 8 } , { 3 , 10 } , { 5 , 8 } } ; int N = sizeof ( intervals ) / sizeof ( intervals [ 0 ] ) ; findIntersection ( intervals , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cmp ( int a , int b ) { return ( a > b ) - ( a < b ) ; } int maxSubarraySize ( int arr [ ] , int n ) { int ans = 1 ; int anchor = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int c = cmp ( arr [ i - 1 ] , arr [ i ] ) ; if ( c == 0 ) anchor = i ; else if ( i == n - 1 || c * cmp ( arr [ i ] , arr [ i + 1 ] ) != -1 ) { ans = max ( ans , i - anchor + 1 ) ; anchor = i ; } } return ans ; } int main ( ) { int arr [ ] = { 9 , 4 , 2 , 10 , 7 , 8 , 8 , 1 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSubarraySize ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ValidPairs ( int arr [ ] , int n ) { int count [ 121 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] += 1 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) continue ; if ( abs ( arr [ i ] - arr [ j ] ) % 2 == 1 ) continue ; ans += count [ arr [ i ] ] * count [ arr [ j ] ] ; if ( arr [ i ] == arr [ j ] ) ans -= count [ arr [ i ] ] ; } return ans ; } int main ( ) { int arr [ ] = { 16 , 17 , 18 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << ( ValidPairs ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check_distribution ( int n , int k , int age [ ] , int candy [ ] ) { int mxage = * ( std :: max_element ( age , age + n ) ) + 1 ; int mxcandy = * ( std :: max_element ( candy , candy + k ) ) + 1 ; int fr1 [ mxage ] = { 0 } ; int fr2 [ mxcandy ] = { 0 } ; for ( int j = 0 ; j < n ; j ++ ) { fr1 [ age [ j ] ] += 1 ; } for ( int j = 0 ; j < k ; j ++ ) { fr2 [ candy [ j ] ] += 1 ; } k = 0 ; bool Tf = true ; for ( int j = 0 ; j < mxage ; j ++ ) { if ( fr1 [ j ] == 0 ) continue ; bool flag = false ; while ( k < mxcandy ) { if ( fr1 [ j ] <= fr2 [ k ] ) { flag = true ; break ; } k += 1 ; } k = k + 1 ; if ( flag == false ) { Tf = false ; break ; } } if ( Tf ) cout << " YES " << endl ; else cout << " NO " << endl ; } int main ( ) { int age [ ] = { 5 , 15 , 10 } ; int candy [ ] = { 2 , 2 , 2 , 3 , 3 , 4 } ; int n = sizeof ( age ) / sizeof ( age [ 0 ] ) ; int k = sizeof ( candy ) / sizeof ( candy [ 0 ] ) ; check_distribution ( n , k , age , candy ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPalindrome ( string s ) { string x = s ; reverse ( s . begin ( ) , s . end ( ) ) ; return s == x ; } string findStringB ( string A ) { string B = A ; reverse ( A . begin ( ) , A . end ( ) ) ; A = A + B ; if ( checkPalindrome ( B ) ) return B ; return A ; } string reverse ( string input ) { string temparray = input ; int left , right = 0 ; right = temparray . length ( ) - 1 ; for ( left = 0 ; left < right ; left ++ , right -- ) swap ( temparray [ left ] , temparray [ right ] ) ; return temparray ; } int main ( int argc , char const * argv [ ] ) { string A = " ab " ; cout << findStringB ( A ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minChanges ( int A [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; } int main ( ) { int A [ ] = { 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minChanges ( A , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void completeSuquence ( string s ) { int n = s . length ( ) ; int open = 0 , close = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) open ++ ; else close ++ ; if ( close > open ) { cout << " Impossible " << endl ; return ; } } cout << s ; for ( int i = 0 ; i < open - close ; i ++ ) cout << ' ) ' ; cout << endl ; } int main ( ) { string s = " ( ( ) ( ( ) ( " ; completeSuquence ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string smallestPermute ( int n ) { char res [ n + 1 ] ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = 48 + i + 2 ; else res [ i ] = 48 + i ; } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = 48 + i + 2 ; else res [ i ] = 48 + i ; } res [ n - 1 ] = 48 + n - 2 ; res [ n - 2 ] = 48 + n ; res [ n - 3 ] = 48 + n - 1 ; } res [ n ] = ' \0' ; return res ; } int main ( ) { int n = 7 ; cout << smallestPermute ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minInsertions ( int H [ ] , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += ceil ( diff / K ) - 1 ; } return inser ; } int main ( ) { int H [ ] = { 2 , 4 , 8 , 16 } , K = 3 ; int n = sizeof ( H ) / sizeof ( H [ 0 ] ) ; cout << minInsertions ( H , n , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_minimum_operations ( long long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; } int main ( ) { long long n = 4 ; long long ans = count_minimum_operations ( n ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = min ( mn , A [ i ] ) ; mx = max ( mx , A [ i ] ) ; } return max ( 0 , mx - mn - 2 * x ) ; } int main ( ) { int n = 3 , x = 3 ; int A [ ] = { 1 , 3 , 6 } ; cout << minDiff ( n , x , A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSum ( int * a , int n ) { vector < int > l ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . push_back ( i + 1 ) ; else { l . push_back ( i + 1 ) ; l . push_back ( i ) ; } } cout << s << endl ; for ( int i = 0 ; i < l . size ( ) ; i ++ ) cout << l [ i ] << " ▁ " ; } int main ( ) { int n = 4 ; int a [ ] = { 1 , -2 , -3 , 4 } ; maxSum ( a , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void LengthLCP ( string x , string y ) { int fr [ 26 ] = { 0 } ; for ( int i = 0 ; i < b ; i ++ ) { fr [ y [ i ] - 97 ] += 1 ; } int c = 0 ; for ( int i = 0 ; i < a ; i ++ ) { if ( fr [ x [ i ] - 97 ] > 0 ) { c += 1 ; fr [ x [ i ] - 97 ] -= 1 ; } else break ; } cout << ( c ) << endl ; } int main ( ) { string x = " here " , y = " there " ; LengthLCP ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CountPair ( int L , int R ) { int x = ( R - L + 1 ) ; cout << x / 2 << " STRNEWLINE " ; } int main ( ) { int L , R ; L = 1 , R = 8 ; CountPair ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int results ( int n , int k ) { return round ( pow ( n , ( 1.0 / pow ( 2 , k ) ) ) ) ; } int main ( ) { int k = 3 , n = 100000000 ; cout << " Chocolates ▁ left ▁ after ▁ " << k << " ▁ iterations ▁ are ▁ " << results ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int * getSubArray ( int arr [ ] , int n , int K ) { int i = -1 ; int j = -1 ; int currSum = 0 ; int * result = new int [ 3 ] { i , j , abs ( K - abs ( currSum ) ) } ; for ( i = 0 ; i < n ; i ++ ) { currSum = 0 ; for ( j = i ; j < n ; j ++ ) { currSum += arr [ j ] ; int currDev = abs ( K - abs ( currSum ) ) ; if ( currDev < result [ 2 ] ) { result [ 0 ] = i ; result [ 1 ] = j ; result [ 2 ] = currDev ; } if ( currDev == 0 ) return result ; } } return result ; } int main ( ) { int arr [ 8 ] = { 15 , -3 , 5 , 2 , 7 , 6 , 34 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 50 ; int * ans = getSubArray ( arr , n , K ) ; if ( ans [ 0 ] == -1 ) { cout << " The ▁ empty ▁ array ▁ shows ▁ " << " minimum ▁ Deviation " ; } else { for ( int i = ans [ 0 ] ; i <= ans [ 1 ] ; i ++ ) cout << arr [ i ] << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubsequence ( int a [ ] , int n , int q [ ] , int m ) { sort ( a , a + n ) ; int sum = 0 ; int b [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; double av = ( double ) ( sum ) / ( double ) ( i + 1 ) ; b [ i ] = ( ( int ) ( av + 1 ) ) ; } sort ( b , b + n ) ; for ( int i = 0 ; i < m ; i ++ ) { int k = q [ i ] ; int longest = upper_bound ( b , b + n , k ) - b ; cout << " Answer ▁ to ▁ Query " << i + 1 << " : ▁ " << longest << endl ; } } int main ( ) { int a [ ] = { 1 , 3 , 2 , 5 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int q [ ] = { 4 , 2 , 1 , 5 } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; longestSubsequence ( a , n , q , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; } int main ( ) { int N = 4 , M = 4 ; cout << steps ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int DecreasingArray ( int a [ ] , int n ) { int sum = 0 , dif = 0 ; priority_queue < int , vector < int > , greater < int > > pq ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! pq . empty ( ) && pq . top ( ) < a [ i ] ) { dif = a [ i ] - pq . top ( ) ; sum += dif ; pq . pop ( ) ; } pq . push ( a [ i ] ) ; } return sum ; } int main ( ) { int a [ ] = { 3 , 1 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << DecreasingArray ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void subsequence ( char s [ ] , char t [ ] , int n , int k ) { int last = 0 , cnt = 0 , new_last = 0 , size = 0 ; for ( char ch = ' z ' ; ch >= ' a ' ; ch -- ) { cnt = 0 ; for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) cnt ++ ; } if ( cnt >= k ) { for ( int i = last ; i < n ; i ++ ) { if ( s [ i ] == ch ) { t [ size ++ ] = ch ; new_last = i ; } } last = new_last ; } } t [ size ] = ' \0' ; } int main ( ) { char s [ ] = " banana " ; int n = sizeof ( s ) ; int k = 2 ; char t [ n ] ; subsequence ( s , t , n - 1 , k ) ; cout << t << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long swapCount ( string chars ) { int countLeft = 0 , countRight = 0 ; int swap = 0 , imbalance = 0 ; for ( int i = 0 ; i < chars . length ( ) ; i ++ ) { if ( chars [ i ] == ' [ ' ) { countLeft ++ ; if ( imbalance > 0 ) { swap += imbalance ; imbalance -- ; } } else if ( chars [ i ] == ' ] ' ) { countRight ++ ; imbalance = ( countRight - countLeft ) ; } } return swap ; } int main ( ) { string s = " [ ] ] [ ] [ " ; cout << swapCount ( s ) << endl ; s = " [ [ ] [ ] ] " ; cout << swapCount ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pageFaults ( int pages [ ] , int n , int capacity ) { unordered_set < int > s ; unordered_map < int , int > indexes ; int page_faults = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . size ( ) < capacity ) { if ( s . find ( pages [ i ] ) == s . end ( ) ) { s . insert ( pages [ i ] ) ; page_faults ++ ; } indexes [ pages [ i ] ] = i ; } else { if ( s . find ( pages [ i ] ) == s . end ( ) ) { int lru = INT_MAX , val ; for ( auto it = s . begin ( ) ; it != s . end ( ) ; it ++ ) { if ( indexes [ * it ] < lru ) { lru = indexes [ * it ] ; val = * it ; } } s . erase ( val ) ; s . insert ( pages [ i ] ) ; page_faults ++ ; } indexes [ pages [ i ] ] = i ; } } return page_faults ; } int main ( ) { int pages [ ] = { 7 , 0 , 1 , 2 , 0 , 3 , 0 , 4 , 2 , 3 , 0 , 3 , 2 } ; int n = sizeof ( pages ) / sizeof ( pages [ 0 ] ) ; int capacity = 4 ; cout << pageFaults ( pages , n , capacity ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <unordered_map> NEW_LINE using namespace std ; void bestpermutation ( int arr [ ] , int k , int n ) { unordered_map < int , int > h ; for ( int i = 0 ; i < n ; i ++ ) { h . insert ( make_pair ( arr [ i ] , i ) ) ; } if ( n <= k ) { sort ( arr , arr + n , greater < int > ( ) ) ; } else { for ( int j = n ; j >= 1 ; j -- ) { if ( k > 0 ) { int initial_index = h [ j ] ; int best_index = n - j ; if ( initial_index != best_index ) { h [ j ] = best_index ; int element = arr [ best_index ] ; h [ element ] = initial_index ; swap ( arr [ best_index ] , arr [ initial_index ] ) ; k -- ; } } } } } int main ( ) { int arr [ ] = { 3 , 1 , 4 , 2 , 5 } ; int k = 10 ; int n = sizeof ( arr ) / sizeof ( int ) ; bestpermutation ( arr , k , n ) ; cout << " Largest ▁ possible ▁ permutation ▁ after ▁ " << k << " ▁ swaps ▁ is ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void bestFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) { int allocation [ n ] ; memset ( allocation , -1 , sizeof ( allocation ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int bestIdx = -1 ; for ( int j = 0 ; j < m ; j ++ ) { if ( blockSize [ j ] >= processSize [ i ] ) { if ( bestIdx == -1 ) bestIdx = j ; else if ( blockSize [ bestIdx ] > blockSize [ j ] ) bestIdx = j ; } } if ( bestIdx != -1 ) { allocation [ i ] = bestIdx ; blockSize [ bestIdx ] -= processSize [ i ] ; } } cout << " Process No . Process Size Block no . " ; for ( int i = 0 ; i < n ; i ++ ) { cout << " ▁ " << i + 1 << " TABSYMBOL TABSYMBOL " << processSize [ i ] << " TABSYMBOL TABSYMBOL " ; if ( allocation [ i ] != -1 ) cout << allocation [ i ] + 1 ; else cout << " Not ▁ Allocated " ; cout << endl ; } } int main ( ) { int blockSize [ ] = { 100 , 500 , 200 , 300 , 600 } ; int processSize [ ] = { 212 , 417 , 112 , 426 } ; int m = sizeof ( blockSize ) / sizeof ( blockSize [ 0 ] ) ; int n = sizeof ( processSize ) / sizeof ( processSize [ 0 ] ) ; bestFit ( blockSize , m , processSize , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int bestFit ( int weight [ ] , int n , int c ) { int res = 0 ; int bin_rem [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int j ; int min = c + 1 , bi = 0 ; for ( j = 0 ; j < res ; j ++ ) { if ( bin_rem [ j ] >= weight [ i ] && bin_rem [ j ] - weight [ i ] < min ) { bi = j ; min = bin_rem [ j ] - weight [ i ] ; } } if ( min == c + 1 ) { bin_rem [ res ] = c - weight [ i ] ; res ++ ; } bin_rem [ bi ] -= weight [ i ] ; } return res ; } int main ( ) { int weight [ ] = { 2 , 5 , 4 , 7 , 1 , 3 , 8 } ; int c = 10 ; int n = sizeof ( weight ) / sizeof ( weight [ 0 ] ) ; cout << " Number ▁ of ▁ bins ▁ required ▁ in ▁ Best ▁ Fit ▁ : ▁ " << bestFit ( weight , n , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int worstFit ( int weight [ ] , int n , int c ) { int res = 0 ; int bin_rem [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int j ; int mx = -1 , wi = 0 ; for ( j = 0 ; j < res ; j ++ ) { if ( bin_rem [ j ] >= weight [ i ] && bin_rem [ j ] - weight [ i ] > mx ) { wi = j ; mx = bin_rem [ j ] - weight [ i ] ; } } if ( mx == -1 ) { bin_rem [ res ] = c - weight [ i ] ; res ++ ; } bin_rem [ wi ] -= weight [ i ] ; } return res ; } int main ( ) { int weight [ ] = { 2 , 5 , 4 , 7 , 1 , 3 , 8 } ; int c = 10 ; int n = sizeof ( weight ) / sizeof ( weight [ 0 ] ) ; cout << " Number ▁ of ▁ bins ▁ required ▁ in ▁ Worst ▁ Fit ▁ : ▁ " << worstFit ( weight , n , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMax ( int arr [ ] , int n ) { int result = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > result ) result = arr [ i ] ; return result ; } bool isPossible ( int time , int K , int job [ ] , int n ) { int cnt = 1 ; for ( int i = 0 ; i < n ; ) { if ( curr_time + job [ i ] > time ) { curr_time = 0 ; cnt ++ ; } curr_time += job [ i ] ; i ++ ; } } return ( cnt <= K ) ; } int findMinTime ( int K , int T , int job [ ] , int n ) { int end = 0 , start = 0 ; for ( int i = 0 ; i < n ; ++ i ) end += job [ i ] ; int job_max = getMax ( job , n ) ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid >= job_max && isPossible ( mid , K , job , n ) ) { end = mid - 1 ; } else start = mid + 1 ; } return ( ans * T ) ; } int main ( ) { int job [ ] = { 10 , 7 , 8 , 12 , 6 , 8 } ; int n = sizeof ( job ) / sizeof ( job [ 0 ] ) ; int k = 4 , T = 5 ; cout << findMinTime ( k , T , job , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberOfWays ( int n , int k ) { int dp [ 1000 ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 1 ; for ( int i = 1 ; i <= k ; i ++ ) { int numWays = 0 ; for ( int j = 0 ; j < n ; j ++ ) { numWays += dp [ j ] ; } for ( int j = 0 ; j < n ; j ++ ) { dp [ j ] = numWays - dp [ j ] ; } } cout << dp [ 0 ] << endl ; } int main ( ) { int N = 5 , K = 3 ; numberOfWays ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalSubarrays ( int arr [ ] , int n , int k ) { int ans = 0 , i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } ans += ( ( count * ( count + 1 ) ) / 2 ) ; } return ans ; } int countSubarrays ( int arr [ ] , int n , int k ) { int count1 = totalSubarrays ( arr , n , k - 1 ) ; int count2 = totalSubarrays ( arr , n , k ) ; int ans = count2 - count1 ; return ans ; } int main ( ) { int n = 4 , k = 3 ; int arr [ ] = { 2 , 1 , 3 , 4 } ; cout << countSubarrays ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int M = 1000000007 ; int waysOfDecoding ( string s ) { long first = 1 , second = s [ 0 ] == ' * ' ? 9 : s [ 0 ] == '0' ? 0 : 1 ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { long temp = second ; if ( s [ i ] == ' * ' ) { second = 9 * second ; if ( s [ i - 1 ] == '1' ) second = ( second + 9 * first ) % M ; else if ( s [ i - 1 ] == '2' ) second = ( second + 6 * first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + 15 * first ) % M ; } else { second = s [ i ] != '0' ? second : 0 ; if ( s [ i - 1 ] == '1' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == '2' && s [ i ] <= '6' ) second = ( second + first ) % M ; else if ( s [ i - 1 ] == ' * ' ) second = ( second + ( s [ i ] <= '6' ? 2 : 1 ) * first ) % M ; } first = temp ; } return ( int ) second ; } int main ( ) { string s = " * " ; cout << waysOfDecoding ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumWO3Consec ( int A [ ] , int N ) { if ( N == 1 ) return A [ 0 ] ; if ( N == 2 ) return A [ 0 ] + A [ 1 ] ; int third = A [ 0 ] ; int second = third + A [ 1 ] ; int first = max ( second , A [ 1 ] + A [ 2 ] ) ; int sum = max ( max ( third , second ) , first ) ; for ( int i = 3 ; i < N ; i ++ ) { sum = max ( max ( first , second + A [ i ] ) , third + A [ i ] + A [ i - 1 ] ) ; third = second ; second = first ; first = sum ; } return sum ; } int main ( ) { int A [ ] = { 3000 , 2000 , 1000 , 3 , 10 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << maxSumWO3Consec ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubSequence ( pair < int , int > A [ ] , int N ) { int dp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { dp [ i ] = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] . first < A [ i ] . first && A [ j ] . second > A [ i ] . second ) { dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } } } cout << dp [ N - 1 ] << endl ; } int main ( ) { pair < int , int > A [ ] = { { 1 , 2 } , { 2 , 2 } , { 3 , 1 } } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; longestSubSequence ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinOperations ( int n ) { int i , dp [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = 999999 ; } dp [ 2 ] = 0 ; for ( i = 2 ; i < n + 1 ; i ++ ) { if ( i * 5 <= n ) { dp [ i * 5 ] = min ( dp [ i * 5 ] , dp [ i ] + 1 ) ; } if ( i + 3 <= n ) { dp [ i + 3 ] = min ( dp [ i + 3 ] , dp [ i ] + 1 ) ; } } return dp [ n ] ; } int main ( ) { int n = 28 ; int m = findMinOperations ( n ) ; if ( m != 9999 ) cout << m ; else cout << -1 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSortedArrays ( int n , int m ) { vector < int > dp ( m + 1 , 0 ) ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ j ] = dp [ j - 1 ] + dp [ j ] ; } } return dp [ m ] ; } int main ( ) { int n = 2 , m = 3 ; cout << countSortedArrays ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count0 ( string s ) { int count = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == '0' ) { count ++ ; } } return count ; } int solve ( vector < string > vec , int A , int B , int idx ) { if ( idx == vec . size ( ) A + B == 0 ) { return 0 ; } int zero = count0 ( vec [ idx ] ) ; int one = vec [ idx ] . size ( ) - zero ; int inc = 0 ; if ( zero <= A && one <= B ) { inc = 1 + solve ( vec , A - zero , B - one , idx + 1 ) ; } int exc = solve ( vec , A , B , idx + 1 ) ; return max ( inc , exc ) ; } int MaxSubsetlength ( vector < string > arr , int A , int B ) { return solve ( arr , A , B , 0 ) ; } int main ( ) { vector < string > arr = { "1" , "0" , "10" } ; int A = 1 , B = 1 ; cout << MaxSubsetlength ( arr , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isUnique ( string s ) { set < char > Set ; for ( char c : s ) { Set . insert ( c ) ; } return Set . size ( ) == 1 ; } int maxScore ( string s , int a [ ] ) { int n = s . length ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int mx = -1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { string sub = s . substr ( i , j + 1 ) ; if ( isUnique ( sub ) ) mx = max ( mx , a [ sub . length ( ) - 1 ] + maxScore ( s . substr ( 0 , i ) + s . substr ( j + 1 ) , a ) ) ; } } return mx ; } int main ( ) { string s = "011" ; int a [ ] = { 1 , 3 , 1 } ; cout << maxScore ( s , a ) - 1 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define size  1001 NEW_LINE int ans [ size ] [ size ] = { 0 } ; int numberOfUniqueOutcomes ( int n , int s ) { if ( s < n ) ans [ n ] [ s ] = 0 ; else if ( n == 1 n == s ) ans [ n ] [ s ] = 1 ; else if ( ! ans [ n ] [ s ] ) { ans [ n ] [ s ] = numberOfUniqueOutcomes ( n - 1 , s - 1 ) + numberOfUniqueOutcomes ( n - 1 , s - 2 ) ; } return ans [ n ] [ s ] ; } int main ( ) { int N = 5 , S = 8 ; cout << numberOfUniqueOutcomes ( N , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMinimumRemovals ( string str , string X ) { int N = str . size ( ) ; int M = X . size ( ) ; int dp [ N ] [ M ] = { } ; for ( int j = 0 ; j < M ; j ++ ) { if ( str [ 0 ] == X [ j ] ) { dp [ 0 ] [ j ] = 1 ; } } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( str [ i ] == X [ j ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + 1 ; if ( j != 0 ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] ) ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } } cout << dp [ N - 1 ] [ M - 1 ] ; } int main ( ) { string str = " btagd " ; string X = " bad " ; printMinimumRemovals ( str , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100000 ] ; int findWays ( int x ) { if ( x < 0 ) return 0 ; if ( x == 0 ) return 1 ; if ( x == 1 ) return 2 ; if ( x == 2 ) return 4 ; if ( dp [ x ] != -1 ) return dp [ x ] ; int count = findWays ( x - 1 ) ; count += findWays ( x - 2 ) ; count += findWays ( x - 3 ) ; dp [ x ] = count ; return dp [ x ] ; } int main ( ) { int n = 4 ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << findWays ( n ) << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubarraySum ( vector < int > & sum , int k , int row ) { int curSum = 0 , curMax = INT_MIN ; set < int > sumSet ; sumSet . insert ( 0 ) ; for ( int r = 0 ; r < row ; ++ r ) { curSum += sum [ r ] ; auto it = sumSet . lower_bound ( curSum - k ) ; if ( it != sumSet . end ( ) ) { curMax = max ( curMax , curSum - * it ) ; } sumSet . insert ( curSum ) ; } return curMax ; } void maxSumSubmatrix ( vector < vector < int > > & matrix , int k ) { int row = matrix . size ( ) ; int col = matrix [ 0 ] . size ( ) ; int ret = INT_MIN ; for ( int i = 0 ; i < col ; ++ i ) { vector < int > sum ( row , 0 ) ; for ( int j = i ; j < col ; ++ j ) { for ( int r = 0 ; r < row ; ++ r ) { sum [ r ] += matrix [ r ] [ j ] ; } int curMax = maxSubarraySum ( sum , k , row ) ; ret = max ( ret , curMax ) ; } } cout << ret ; } int main ( ) { vector < vector < int > > matrix = { { 1 , 0 , 1 } , { 0 , -2 , 3 } } ; int K = 2 ; maxSumSubmatrix ( matrix , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( vector < vector < int > > & costs , int N ) { if ( N == 0 ) return 0 ; vector < vector < int > > dp ( N , vector < int > ( 3 , 0 ) ) ; dp [ 0 ] [ 0 ] = costs [ 0 ] [ 0 ] ; dp [ 0 ] [ 1 ] = costs [ 0 ] [ 1 ] ; dp [ 0 ] [ 2 ] = costs [ 0 ] [ 2 ] ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 0 ] ; dp [ i ] [ 1 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 2 ] ) + costs [ i ] [ 1 ] ; dp [ i ] [ 2 ] = min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + costs [ i ] [ 2 ] ; } cout << min ( dp [ N - 1 ] [ 0 ] , min ( dp [ N - 1 ] [ 1 ] , dp [ N - 1 ] [ 2 ] ) ) ; } int main ( ) { vector < vector < int > > costs { { 14 , 2 , 11 } , { 11 , 14 , 5 } , { 14 , 3 , 10 } } ; int N = costs . size ( ) ; minCost ( costs , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 2001 ] [ 2001 ] ; int solve ( vector < int > & A , int i , int sum , int N ) { int res = 2001 ; if ( sum < 0 or ( i == N and sum != 0 ) ) { return 2001 ; } if ( sum == 0 or i >= N ) { return dp [ i ] [ sum ] = 0 ; } if ( dp [ i ] [ sum ] != -1 ) { return dp [ i ] [ sum ] ; } res = min ( solve ( A , i + 1 , sum - A [ i ] , N ) + 1 , solve ( A , i + 1 , sum , N ) ) ; return dp [ i ] [ sum ] = res ; } void minOp ( vector < int > & A , int N ) { int sum = 0 ; for ( auto it : A ) { sum += it ; } if ( sum % 2 == 0 ) { memset ( dp , -1 , sizeof ( dp ) ) ; int ans = solve ( A , 0 , sum / 2 , N ) ; if ( ans < 0 ans > N ) { cout << " - 1" << endl ; } else { cout << ans << endl ; } } else { cout << " - 1" << endl ; } } int main ( ) { vector < int > A = { 2 , 3 , 1 , 4 } ; int N = A . size ( ) ; minOp ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 101 ] [ 101 ] [ 1001 ] ; int countAverage ( int n , int K , int * arr ) { dp [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int s = 0 ; s <= 1000 ; s ++ ) { dp [ i + 1 ] [ k + 1 ] [ s + arr [ i ] ] += dp [ i ] [ k ] [ s ] ; dp [ i + 1 ] [ k ] [ s ] += dp [ i ] [ k ] [ s ] ; } } } int cnt = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { cnt += dp [ n ] [ j ] [ K * j ] ; } return cnt ; } int main ( ) { int arr [ ] = { 9 , 7 , 8 , 9 } ; int K = 8 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countAverage ( N , K , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 50 ] [ 50 ] [ 50 ] [ 50 ] ; int FindMaxS ( int X , int Y , int Z , int n , vector < int > & A , vector < int > & B , vector < int > & C ) { if ( X < 0 or Y < 0 or Z < 0 ) return INT_MIN ; if ( n < 0 ) return 0 ; if ( dp [ n ] [ X ] [ Y ] [ Z ] != -1 ) { return dp [ n ] [ X ] [ Y ] [ Z ] ; } int ch = A [ n ] + FindMaxS ( X - 1 , Y , Z , n - 1 , A , B , C ) ; int ca = B [ n ] + FindMaxS ( X , Y - 1 , Z , n - 1 , A , B , C ) ; int co = C [ n ] + FindMaxS ( X , Y , Z - 1 , n - 1 , A , B , C ) ; int no = FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; int maximum = max ( ch , max ( ca , max ( co , no ) ) ) ; return dp [ n ] [ X ] [ Y ] [ Z ] = maximum ; } int main ( ) { int X = 1 ; int Y = 1 ; int Z = 1 ; vector < int > A = { 10 , 0 , 5 } ; vector < int > B = { 5 , 10 , 0 } ; vector < int > C = { 0 , 5 , 10 } ; int n = B . size ( ) ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << FindMaxS ( X , Y , Z , n - 1 , A , B , C ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long double find ( int N , int sum ) { if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } long double s = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) s = s + find ( N - 1 , sum - i ) / 6 ; return s ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; long double probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MOD  1000000007 NEW_LINE using namespace std ; vector < int > MEM = { 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , 256 , 512 , 1024 , 2048 , 4096 } ; int mod_pow2 ( int n ) { while ( n >= MEM . size ( ) ) MEM . push_back ( ( MEM [ -1 ] * 2 ) % MOD ) ; return MEM [ n ] ; } int inversions ( string bstr ) { int total = 0 , zeros = 0 , questions = 0 ; reverse ( bstr . begin ( ) , bstr . end ( ) ) ; for ( char x : bstr ) { int q ; if ( x == '1' ) { int z = zeros * mod_pow2 ( questions ) ; if ( questions == 0 ) q = 0 ; else q = questions * mod_pow2 ( questions - 1 ) ; total = ( total + z + q ) % MOD ; } else if ( x == '0' ) { zeros += 1 ; } else { total *= 2 ; int z = zeros * mod_pow2 ( questions ) ; if ( questions == 0 ) q = 0 ; else q = questions * mod_pow2 ( questions - 1 ) ; total = ( total + z + q ) % MOD ; questions += 1 ; } } return total ; } int main ( ) { string S = " ? 0 ? " ; cout << inversions ( S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minRemovalsUtil ( int arr [ ] , int n ) { int result = 0 ; if ( n < 3 ) { return -1 ; } int leftIncreasing [ n ] = { 0 } ; int rightIncreasing [ n ] = { 0 } ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { leftIncreasing [ i ] = max ( leftIncreasing [ i ] , leftIncreasing [ j ] + 1 ) ; } } } for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j > i ; j -- ) { if ( arr [ j ] < arr [ i ] ) { rightIncreasing [ i ] = max ( rightIncreasing [ i ] , rightIncreasing [ j ] + 1 ) ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( leftIncreasing [ i ] != 0 && rightIncreasing [ i ] != 0 ) { result = max ( result , leftIncreasing [ i ] + rightIncreasing [ i ] ) ; } } return n - ( result + 1 ) ; } void minRemovals ( int arr [ ] , int n ) { int ans = minRemovalsUtil ( arr , n ) ; cout << ans ; } int main ( ) { int arr [ ] = { 2 , 1 , 1 , 5 , 6 , 2 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minRemovals ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void bfs ( int n , vector < int > & a , vector < int > invGr [ ] , vector < int > & ans , int parity ) { queue < int > q ; vector < int > vis ( n + 1 , 0 ) ; vector < int > dist ( n + 1 , 0 ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( a [ i ] + parity ) & 1 ) { q . push ( i ) ; vis [ i ] = 1 ; } } while ( ! q . empty ( ) ) { int v = q . front ( ) ; q . pop ( ) ; for ( int u : invGr [ v ] ) { if ( ! vis [ u ] ) { dist [ u ] = dist [ v ] + 1 ; vis [ u ] = 1 ; if ( ( a [ u ] + parity ) % 2 == 0 ) { if ( ans [ u ] == -1 ) ans [ u ] = dist [ u ] ; } q . push ( u ) ; } } } } void minJumps ( vector < int > & a , vector < int > & jump , int n ) { vector < int > invGr [ n + 1 ] ; vector < int > ans ( n + 1 , -1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int ind : { i + jump [ i ] , i - jump [ i ] } ) { if ( ind >= 1 and ind <= n ) { invGr [ ind ] . push_back ( i ) ; } } } bfs ( n , a , invGr , ans , 0 ) ; bfs ( n , a , invGr , ans , 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { cout << ans [ i ] << ' ▁ ' ; } } int main ( ) { vector < int > arr = { 0 , 4 , 2 , 5 , 2 , 1 } ; vector < int > jump = { 0 , 1 , 2 , 3 , 1 , 2 } ; int N = arr . size ( ) ; minJumps ( arr , jump , N - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < vector < vector < int > > > dp ( 105 , vector < vector < int > > ( 105 ) ) ; int countPaths = 0 ; bool isPerfectSquare ( int n ) { long double sr = sqrt ( n ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } void countUniquePaths ( int a [ ] [ 105 ] , int m , int n , int ans ) { dp [ 0 ] [ 0 ] . push_back ( a [ 0 ] [ 0 ] ) ; for ( int i = 1 ; i < m ; i ++ ) { a [ i ] [ 0 ] *= a [ i - 1 ] [ 0 ] ; dp [ i ] [ 0 ] . push_back ( a [ i ] [ 0 ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { a [ 0 ] [ i ] *= a [ 0 ] [ i - 1 ] ; dp [ 0 ] [ i ] . push_back ( a [ 0 ] [ i ] ) ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { vector < int > top = dp [ i - 1 ] [ j ] ; vector < int > left = dp [ i ] [ j - 1 ] ; vector < int > curr ; for ( int k = 0 ; k < top . size ( ) ; k ++ ) { curr . push_back ( top [ k ] * a [ i ] [ j ] ) ; } for ( int k = 0 ; k < left . size ( ) ; k ++ ) { curr . push_back ( left [ k ] * a [ i ] [ j ] ) ; } dp [ i ] [ j ] = curr ; } } for ( auto i : dp [ m - 1 ] [ n - 1 ] ) { if ( isPerfectSquare ( i ) ) { countPaths ++ ; } } } int main ( ) { int M = 3 , N = 4 ; int mat [ M ] [ 105 ] = { { 1 , 2 , 3 , 1 } , { 3 , 1 , 2 , 4 } , { 2 , 3 , 1 , 1 } } ; countUniquePaths ( mat , M , N , 1 ) ; cout << countPaths ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100000 NEW_LINE int dp [ MAX + 1 ] ; list < int > denomination ; int countMinCoins ( int n , int C [ ] , int m ) { if ( n == 0 ) { dp [ 0 ] = 0 ; return 0 ; } if ( dp [ n ] != -1 ) return dp [ n ] ; int ret = INT_MAX ; for ( int i = 0 ; i < m ; i ++ ) { if ( C [ i ] <= n ) { int x = countMinCoins ( n - C [ i ] , C , m ) ; if ( x != INT_MAX ) ret = min ( ret , 1 + x ) ; } } dp [ n ] = ret ; return ret ; } void findSolution ( int n , int C [ ] , int m ) { if ( n == 0 ) { for ( auto it : denomination ) { cout << it << ' ▁ ' ; } return ; } for ( int i = 0 ; i < m ; i ++ ) { if ( n - C [ i ] >= 0 and dp [ n - C [ i ] ] + 1 == dp [ n ] ) { denomination . push_back ( C [ i ] ) ; findSolution ( n - C [ i ] , C , m ) ; break ; } } } void countMinCoinsUtil ( int X , int C [ ] , int N ) { memset ( dp , -1 , sizeof ( dp ) ) ; int isPossible = countMinCoins ( X , C , N ) ; if ( isPossible == INT_MAX ) { cout << " - 1" ; } else { findSolution ( X , C , N ) ; } } int main ( ) { int X = 21 ; int arr [ ] = { 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countMinCoinsUtil ( X , arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWays ( int N ) { int dp [ N + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 6 ; j ++ ) { if ( i - j >= 0 ) { dp [ i ] = dp [ i ] + dp [ i - j ] ; } } } cout << dp [ N ] ; } int main ( ) { int N = 4 ; findWays ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binCoff ( int n , int r ) { int val = 1 ; int i ; if ( r > ( n - r ) ) { r = ( n - r ) ; } for ( i = 0 ; i < r ; i ++ ) { val *= ( n - i ) ; val /= ( i + 1 ) ; } return val ; } int findWays ( int n ) { n -- ; int a , b , ans ; a = binCoff ( 2 * n , n ) ; b = a / ( n + 1 ) ; ans = b ; return ans ; } int main ( ) { int n = 4 ; cout << findWays ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 1010 ] [ 1010 ] ; int solve ( string s , string t ) { int n = s . size ( ) ; int r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; if ( i > 0 ) { dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j ] ) ; } if ( s [ i ] == t [ j ] ) { int ans = 1 ; if ( i > 0 && j > 0 ) { ans = 1 + dp [ i - 1 ] [ j - 1 ] ; } dp [ i ] [ j ] = max ( dp [ i ] [ j ] , ans ) ; r = max ( r , dp [ i ] [ j ] ) ; } } } return ( n - r ) ; } int main ( ) { string s = " abcde " ; string t = " edacb " ; cout << solve ( s , t ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubstring ( string s , int n ) { map < int , int > index ; int answer = 0 ; int mask = 0 ; index [ mask ] = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( int ) s [ i ] - 97 ; mask ^= ( 1 << temp ) ; if ( index [ mask ] ) { answer = max ( answer , i - index [ mask ] ) ; } else index [ mask ] = i ; for ( int j = 0 ; j < 26 ; j ++ ) { int mask2 = mask ^ ( 1 << j ) ; if ( index [ mask2 ] ) { answer = max ( answer , i - index [ mask2 ] ) ; } } } return answer ; } int main ( ) { string s = " adbabd " ; int n = s . size ( ) ; cout << ( longestSubstring ( s , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 15 ] [ 10 ] ; int solve ( int n , int last , int k ) { if ( n == 1 ) { if ( last == k ) { return ( k - 1 ) ; } else { return 1 ; } } if ( dp [ n ] [ last ] ) return dp [ n ] [ last ] ; if ( last == k ) { return dp [ n ] [ last ] = ( k - 1 ) * solve ( n - 1 , k , k ) + ( k - 1 ) * solve ( n - 1 , 1 , k ) ; } else { return dp [ n ] [ last ] = solve ( n - 1 , k , k ) ; } } int main ( ) { int n = 2 , k = 3 ; int x = solve ( n , k , k ) + solve ( n , 1 , k ) ; cout << x ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print ( vector < int > & occ , string & s ) { for ( int i = 1 ; i <= int ( s . size ( ) ) ; i ++ ) { cout << s . substr ( 0 , i ) << " ▁ occurs ▁ " << occ [ i ] << " ▁ times . " << endl ; } } vector < int > prefix_function ( string & s ) { vector < int > LPS ( s . size ( ) ) ; LPS [ 0 ] = 0 ; for ( int i = 1 ; i < int ( s . size ( ) ) ; i ++ ) { int j = LPS [ i - 1 ] ; while ( j > 0 && s [ i ] != s [ j ] ) { j = LPS [ j - 1 ] ; } if ( s [ i ] == s [ j ] ) { LPS [ i ] = j + 1 ; } else { LPS [ i ] = 0 ; } } return LPS ; } void count_occurence ( string & s ) { int n = s . size ( ) ; vector < int > LPS = prefix_function ( s ) ; vector < int > occ ( n + 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { occ [ LPS [ i ] ] ++ ; } for ( int i = n - 1 ; i > 0 ; i -- ) { occ [ LPS [ i - 1 ] ] += occ [ i ] ; } for ( int i = 0 ; i <= n ; i ++ ) occ [ i ] ++ ; print ( occ , s ) ; } int main ( ) { string A = " ABACABA " ; count_occurence ( A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSum ( int A [ ] , int B [ ] , int length , int X , int Y ) { int l = length ; int l1 = min ( length , X ) ; int l2 = min ( length , Y ) ; int dp [ l1 + 1 ] [ l2 + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 0 ; int max_sum = INT_MIN ; for ( int i = 1 ; i <= l1 ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + A [ i - 1 ] ; max_sum = max ( max_sum , dp [ i ] [ 0 ] ) ; } for ( int i = 1 ; i <= l2 ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + B [ i - 1 ] ; max_sum = max ( max_sum , dp [ 0 ] [ i ] ) ; } for ( int i = 1 ; i <= l1 ; i ++ ) { for ( int j = 1 ; j <= l2 ; j ++ ) { if ( i + j <= l ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] + A [ i + j - 1 ] , dp [ i ] [ j - 1 ] + B [ i + j - 1 ] ) ; max_sum = max ( dp [ i ] [ j ] , max_sum ) ; } } return max_sum ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 } ; int B [ ] = { 5 , 4 , 3 , 2 , 1 } ; int X = 3 , Y = 2 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << maximumSum ( A , B , N , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printpenta ( int n ) { if ( n < 0 ) return ; int first = 0 ; int second = 0 ; int third = 0 ; int fourth = 0 ; int fifth = 1 ; int curr = 0 ; if ( n == 0 n == 1 n == 2 n == 3 ) cout << first << " STRNEWLINE " ; else if ( n == 5 ) cout << fifth << " STRNEWLINE " ; else { for ( int i = 5 ; i < n ; i ++ ) { curr = first + second + third + fourth + fifth ; first = second ; second = third ; third = fourth ; fourth = fifth ; fifth = curr ; } cout << curr << " STRNEWLINE " ; } } int main ( ) { int n = 10 ; printpenta ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 100001 ] [ 20 ] [ 2 ] ; int possibleBinaries ( int pos , int ones , int sum , int k ) { if ( ones == k ) return 0 ; if ( pos == 0 ) return ( sum == 0 ) ? 1 : 0 ; if ( dp [ pos ] [ ones ] [ sum ] != -1 ) return dp [ pos ] [ ones ] [ sum ] ; int ret = possibleBinaries ( pos - 1 , ones + 1 , ( sum + 1 ) % 2 , k ) + possibleBinaries ( pos - 1 , 0 , sum , k ) ; dp [ pos ] [ ones ] [ sum ] = ret ; return dp [ pos ] [ ones ] [ sum ] ; } int main ( ) { int N = 3 ; int K = 2 ; memset ( dp , -1 , sizeof dp ) ; cout << possibleBinaries ( N , 0 , 0 , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE long long dp [ 101 ] [ 101 ] [ 101 ] ; int N , M , K ; void Initialize ( ) { for ( int i = 0 ; i <= 100 ; i ++ ) for ( int j = 0 ; j <= 100 ; j ++ ) for ( int z = 0 ; z <= 100 ; z ++ ) dp [ i ] [ j ] [ z ] = -1 ; } int CountWays ( int i , int j , int k ) { if ( i >= N i < 0 j > = M j < 0 k < 0 ) return 0 ; if ( i == 0 && j == 0 && k == 0 ) return 1 ; if ( dp [ i ] [ j ] [ k ] != -1 ) return dp [ i ] [ j ] [ k ] ; else dp [ i ] [ j ] [ k ] = ( CountWays ( i + 1 , j , k - 1 ) % MOD + CountWays ( i - 1 , j , k - 1 ) % MOD + CountWays ( i , j - 1 , k - 1 ) % MOD + CountWays ( i , j + 1 , k - 1 ) % MOD + CountWays ( i , j , k - 1 ) % MOD ) % MOD ; return dp [ i ] [ j ] [ k ] ; } int main ( ) { N = 3 ; M = 3 ; K = 4 ; Initialize ( ) ; cout << CountWays ( 0 , 0 , K ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int INF = 1e9 + 9 ; struct TrieNode { TrieNode * child [ 26 ] = { NULL } ; } ; void insert ( int idx , string & s , TrieNode * root ) { TrieNode * temp = root ; for ( int i = idx ; i < s . length ( ) ; i ++ ) { if ( temp -> child [ s [ i ] - ' a ' ] == NULL ) temp -> child [ s [ i ] - ' a ' ] = new TrieNode ; temp = temp -> child [ s [ i ] - ' a ' ] ; } } int minCuts ( string S1 , string S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ; TrieNode * root = new TrieNode ; for ( int i = 0 ; i < n2 ; i ++ ) { insert ( i , S2 , root ) ; } vector < int > dp ( n1 + 1 , INF ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { TrieNode * temp = root ; for ( int j = i + 1 ; j <= n1 ; j ++ ) { if ( temp -> child [ S1 [ j - 1 ] - ' a ' ] == NULL ) break ; dp [ j ] = min ( dp [ j ] , dp [ i ] + 1 ) ; temp = temp -> child [ S1 [ j - 1 ] - ' a ' ] ; } } if ( dp [ n1 ] >= INF ) return -1 ; else return dp [ n1 ] ; } int main ( ) { string S1 = " abcdab " ; string S2 = " dabc " ; cout << minCuts ( S1 , S2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinPrizes ( int arr [ ] , int n ) { int totalPrizes = 0 , j , x , y ; for ( int i = 0 ; i < n ; i ++ ) { x = 1 ; j = i ; while ( j > 0 && arr [ j ] > arr [ j - 1 ] ) { x ++ ; j -- ; } j = i ; y = 1 ; while ( j < n - 1 && arr [ j ] > arr [ j + 1 ] ) { y ++ ; j ++ ; } totalPrizes += max ( { x , y } ) ; } cout << totalPrizes << endl ; return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMinPrizes ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > minSqrNum ( int n ) { int arr [ n + 1 ] , k ; int sqrNum [ n + 1 ] ; vector < int > v ; arr [ 0 ] = 0 ; sqrNum [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = arr [ i - 1 ] + 1 ; sqrNum [ i ] = 1 ; k = 1 ; while ( k * k <= i ) { if ( arr [ i ] > arr [ i - k * k ] + 1 ) { arr [ i ] = arr [ i - k * k ] + 1 ; sqrNum [ i ] = k * k ; } k ++ ; } } while ( n > 0 ) { v . push_back ( sqrNum [ n ] ) ; n -= sqrNum [ n ] ; } return v ; } int main ( ) { int n = 10 ; vector < int > v ; v = minSqrNum ( n ) ; for ( auto i = v . begin ( ) ; i != v . end ( ) ; i ++ ) { cout << * i ; if ( i + 1 != v . end ( ) ) cout << " ▁ + ▁ " ; } return 0 ; }
