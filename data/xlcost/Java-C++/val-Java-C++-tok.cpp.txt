#include <bits/stdc++.h> NEW_LINE using namespace std ; void calculateSpan ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << " ▁ - - ▁ " << next << endl ; } } int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNGE ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintMinNumberForPattern ( string seq ) { string result ; stack < int > stk ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) seq [ i ] == ' I ' ) { while ( ! stk . empty ( ) ) { result += to_string ( stk . top ( ) ) ; result += " ▁ " ; stk . pop ( ) ; } } } cout << result << endl ; } int main ( ) { PrintMinNumberForPattern ( " IDID " ) ; PrintMinNumberForPattern ( " I " ) ; PrintMinNumberForPattern ( " DD " ) ; PrintMinNumberForPattern ( " II " ) ; PrintMinNumberForPattern ( " DIDI " ) ; PrintMinNumberForPattern ( " IIDDD " ) ; PrintMinNumberForPattern ( " DDIDDIID " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mostFrequent ( int arr [ ] , int n ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ; int max_count = 0 , res = -1 ; for ( auto i : hash ) { if ( max_count < i . second ) { res = i . first ; max_count = i . second ; } } return res ; } int main ( ) { int arr [ ] = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << mostFrequent ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMissing ( int a [ ] , int b [ ] , int n , int m ) { unordered_set < int > s ; for ( int i = 0 ; i < m ; i ++ ) s . insert ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( s . find ( a [ i ] ) == s . end ( ) ) cout << a [ i ] << " ▁ " ; } int main ( ) { int a [ ] = { 1 , 2 , 6 , 3 , 4 , 5 } ; int b [ ] = { 2 , 4 , 3 , 1 , 0 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 1 ] ) ; findMissing ( a , b , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int subset ( int ar [ ] , int n ) { int res = 0 ; sort ( ar , ar + n ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = max ( res , count ) ; } return res ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subset ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void makePermutation ( int a [ ] , int n ) { unordered_map < int , int > count ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ a [ i ] ] != 1 a [ i ] > n a [ i ] < 1 ) { count [ a [ i ] ] -- ; while ( count . find ( next_missing ) != count . end ( ) ) next_missing ++ ; a [ i ] = next_missing ; count [ next_missing ] = 1 ; } } } int main ( ) { int A [ ] = { 2 , 2 , 3 , 3 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; makePermutation ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << A [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int arr [ ] = { 10 , 2 , -2 , -20 , 10 } ; int k = -10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( sum == k ) res ++ ; } } cout << ( res ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr1 [ i ] ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . find ( x - arr2 [ j ] ) != s . end ( ) ) cout << x - arr2 [ j ] << " ▁ " << arr2 [ j ] << endl ; } int main ( ) { int arr1 [ ] = { 1 , 0 , -4 , 7 , 6 , 4 } ; int arr2 [ ] = { 0 , 2 , 4 , -3 , 2 , 1 } ; int x = 8 ; int n = sizeof ( arr1 ) / sizeof ( int ) ; int m = sizeof ( arr2 ) / sizeof ( int ) ; findPairs ( arr1 , arr2 , n , m , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; } int main ( ) { int a1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int a2 [ ] = { 2 , 3 , 6 , 1 , 2 } ; int a3 [ ] = { 3 , 2 , 4 , 5 , 6 } ; int sum = 9 ; int n1 = sizeof ( a1 ) / sizeof ( a1 [ 0 ] ) ; int n2 = sizeof ( a2 ) / sizeof ( a2 [ 0 ] ) ; int n3 = sizeof ( a3 ) / sizeof ( a3 [ 0 ] ) ; findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longest ( int a [ ] , int n , int k ) { unordered_map < int , int > freq ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) end = i , start = l ; } for ( int i = start ; i <= end ; i ++ ) cout << a [ i ] << " ▁ " ; } int main ( ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; longest ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) cout << " No ▁ such ▁ subarray " ; else cout << startindex << " ▁ to ▁ " << startindex + maxsize - 1 ; return maxsize ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubArray ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printAllAPTriplets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { cout << arr [ j ] << " ▁ " << arr [ i ] << " ▁ " << arr [ k ] << endl ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } } int main ( ) { int arr [ ] = { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAllAPTriplets ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriplets ( int a [ ] , int n , int sum ) { int i ; sort ( a , a + n ) ; bool flag = false ; for ( i = 0 ; i < n - 2 ; i ++ ) { if ( i == 0 a [ i ] > a [ i - 1 ] ) { int start = i + 1 ; int end = n - 1 ; int target = sum - a [ i ] ; while ( start < end ) { if ( start > i + 1 && a [ start ] == a [ start - 1 ] ) { start ++ ; continue ; } if ( end < n - 1 && a [ end ] == a [ end + 1 ] ) { end -- ; continue ; } if ( target == a [ start ] + a [ end ] ) { cout << " [ " << a [ i ] << " , " << a [ start ] << " , " << a [ end ] << " ] ▁ " ; flag = true ; start ++ ; end -- ; } else if ( target > ( a [ start ] + a [ end ] ) ) { start ++ ; } else { end -- ; } } } } if ( flag == false ) { cout << " No ▁ Such ▁ Triplets ▁ Exist " << " STRNEWLINE " ; } } int main ( ) { int a [ ] = { 12 , 3 , 6 , 1 , 6 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int sum = 24 ; findTriplets ( a , n , sum ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] * arr [ j ] * arr [ k ] == m ) count ++ ; return count ; } int main ( ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 24 ; cout << countTriplets ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumoflength ( int arr [ ] , int n ) { unordered_set < int > s ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && s . find ( arr [ j ] ) == s . end ( ) ) { s . insert ( arr [ j ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . erase ( arr [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumoflength ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void leftRotatebyOne ( int arr [ ] , int n ) { int temp = arr [ 0 ] , i ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; leftRotate ( arr , 2 , n ) ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return -1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != -1 ) cout << " Index : ▁ " << i << endl ; else cout << " Key ▁ not ▁ found " ; }
#include <iostream> NEW_LINE using namespace std ; bool pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; } int main ( ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int sum = 16 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( pairInSortedRotated ( arr , n , sum ) ) cout << " Array ▁ has ▁ two ▁ elements ▁ with ▁ sum ▁ 16" ; else cout << " Array ▁ doesn ' t ▁ have ▁ two ▁ elements ▁ with ▁ sum ▁ 16 ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) cout << arr [ i % n ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; leftRotate ( arr , n , k ) ; cout << endl ; k = 3 ; leftRotate ( arr , n , k ) ; cout << endl ; k = 4 ; leftRotate ( arr , n , k ) ; cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr1 , 0 , n1 - 1 ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr2 , 0 , n2 - 1 ) << endl ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr3 , 0 , n3 - 1 ) << endl ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr4 , 0 , n4 - 1 ) << endl ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr5 , 0 , n5 - 1 ) << endl ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr6 , 0 , n6 - 1 ) << endl ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr7 , 0 , n7 - 1 ) << endl ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr8 , 0 , n8 - 1 ) << endl ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr9 , 0 , n9 - 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void splitArr ( int arr [ ] , int length , int rotation ) { int tmp [ length * 2 ] = { 0 } ; for ( int i = 0 ; i < length ; i ++ ) { tmp [ i ] = arr [ i ] ; tmp [ i + length ] = arr [ i ] ; } for ( int i = rotation ; i < rotation + length ; i ++ ) { arr [ i - rotation ] = tmp [ i ] ; } } int main ( ) { int arr [ ] = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int position = 2 ; splitArr ( arr , n , position ) ; for ( int i = 0 ; i < n ; ++ i ) printf ( " % d ▁ " , arr [ i ] ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << A [ i ] << " ▁ " ; cout << endl ; } void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { swap ( arr [ l ] , arr [ r ] ) ; reverse ( arr , ++ l , -- r ) ; } } void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } int main ( ) { int arr [ ] = { -12 , 11 , -13 , -5 , 6 , -7 , 5 , -3 , -6 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrange ( int arr [ ] , int n ) { int temp [ n ] ; int small = 0 , large = n - 1 ; int flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Original ▁ Array STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; rearrange ( arr , n ) ; cout << " Modified Array " for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Original ▁ Array STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; rearrange ( arr , n ) ; cout << " Modified Array " for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int key ; struct Node * left , * right ; } ; Node * newNode ( char k ) { Node * node = new Node ; node -> key = k ; node -> right = node -> left = NULL ; return node ; } bool isLeaf ( Node * node ) { if ( node == NULL ) return false ; if ( node -> left == NULL && node -> right == NULL ) return true ; return false ; } int leftLeavesSum ( Node * root ) { int res = 0 ; if ( root != NULL ) { if ( isLeaf ( root -> left ) ) res += root -> left -> key ; else res += leftLeavesSum ( root -> left ) ; res += leftLeavesSum ( root -> right ) ; } return res ; } int main ( ) { struct Node * root = newNode ( 20 ) ; root -> left = newNode ( 9 ) ; root -> right = newNode ( 49 ) ; root -> right -> left = newNode ( 23 ) ; root -> right -> right = newNode ( 52 ) ; root -> right -> right -> left = newNode ( 50 ) ; root -> left -> left = newNode ( 5 ) ; root -> left -> right = newNode ( 12 ) ; root -> left -> right -> right = newNode ( 12 ) ; cout << " Sum ▁ of ▁ left ▁ leaves ▁ is ▁ " << leftLeavesSum ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregateElements ( int arr [ ] , int n ) { int temp [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; memcpy ( arr , temp , sizeof ( temp ) ) ; } int main ( ) { int arr [ ] = { 1 , -1 , -3 , -2 , 7 , 5 , 11 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregateElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void swap ( int * a , int i , int j ) { int temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; return ; } void printArray ( int * a , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; return ; } int main ( ) { int arr [ ] = { 1 , -3 , 5 , 6 , -3 , 6 , 7 , -4 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printArray ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 && i % 2 == 1 ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < 0 && j % 2 == 0 ) { swap ( arr , i , j ) ; break ; } } } else if ( arr [ i ] < 0 && i % 2 == 0 ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] >= 0 && j % 2 == 1 ) { swap ( arr , i , j ) ; break ; } } } } printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int largest ( int arr [ ] , int n ) { return * max_element ( arr , arr + n ) ; } int main ( ) { int arr [ ] = { 10 , 324 , 45 , 90 , 9808 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double findMean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; } double findMedian ( int a [ ] , int n ) { sort ( a , a + n ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } int main ( ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " Mean ▁ = ▁ " << findMean ( a , n ) << endl ; cout << " Median ▁ = ▁ " << findMedian ( a , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int largest = second = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) { largest = max ( largest , arr [ i ] ) ; } for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] != largest ) second = max ( second , arr [ i ] ) ; } if ( second == INT_MIN ) printf ( " There ▁ is ▁ no ▁ second ▁ largest ▁ element STRNEWLINE " ) ; else printf ( " The ▁ second ▁ largest ▁ element ▁ is ▁ % d STRNEWLINE " , second ) ; } int main ( ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2largest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { cout << " ▁ Invalid ▁ Input ▁ " ; return ; } first = second = INT_MIN ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } if ( second == INT_MIN ) cout << " There ▁ is ▁ no ▁ second ▁ largest " " element STRNEWLINE " ; else cout << " The ▁ second ▁ largest ▁ element ▁ is ▁ " << second ; } int main ( ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2largest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindMaxSum ( vector < int > arr , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } int main ( ) { vector < int > arr = { 5 , 5 , 10 , 100 , 10 , 5 } ; cout << FindMaxSum ( arr , arr . size ( ) ) ; }
#include <iostream> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; } int main ( ) { int a [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int max_sum = maxSubArraySum ( a , n ) ; cout << " Maximum ▁ contiguous ▁ sum ▁ is ▁ " << max_sum ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minJumps ( int arr [ ] , int n ) { if ( n == 1 ) return 0 ; int res = INT_MAX ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { int sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != INT_MAX ) res = min ( res , sub_res + 1 ) ; } } return res ; } int main ( ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ jumps ▁ to " ; cout << " ▁ reach ▁ the ▁ end ▁ is ▁ " << minJumps ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; } int main ( ) { int a [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxSubArraySum ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) j ++ ; sort ( A + i , A + 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; } int main ( ) { int A [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; bool B [ ] = { 0 , 1 , 1 , 1 , 0 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( sortedAfterSwap ( A , B , n ) ) cout << " A ▁ can ▁ be ▁ sorted STRNEWLINE " ; else cout << " A ▁ can ▁ not ▁ be ▁ sorted STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumberOfTriangles ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Total ▁ number ▁ of ▁ triangles ▁ possible ▁ is ▁ " << findNumberOfTriangles ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int comp ( const void * a , const void * b ) { return * ( int * ) a > * ( int * ) b ; } int findNumberOfTriangles ( int arr [ ] , int n ) { qsort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; } int main ( ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Total ▁ number ▁ of ▁ triangles ▁ possible ▁ is ▁ " << findNumberOfTriangles ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << equilibrium ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) cout << " Ceiling ▁ of ▁ " << x << " ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " ; else cout << " ceiling ▁ of ▁ " << x << " ▁ is ▁ " << arr [ index ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCandidate ( int a [ ] , int size ) { int maj_index = 0 , count = 1 ; for ( int i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; } bool isMajority ( int a [ ] , int size , int cand ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( a [ i ] == cand ) count ++ ; if ( count > size / 2 ) return 1 ; else return 0 ; } void printMajority ( int a [ ] , int size ) { int cand = findCandidate ( a , size ) ; if ( isMajority ( a , size , cand ) ) cout << " ▁ " << cand << " ▁ " ; else cout << " No ▁ Majority ▁ Element " ; } int main ( ) { int a [ ] = { 1 , 3 , 3 , 1 , 2 } ; int size = ( sizeof ( a ) ) / sizeof ( a [ 0 ] ) ; printMajority ( a , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findRoot ( pair < int , int > arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) root += ( arr [ i ] . first - arr [ i ] . second ) ; return root ; } int main ( ) { pair < int , int > arr [ ] = { { 1 , 5 } , { 2 , 0 } , { 3 , 0 } , { 4 , 0 } , { 5 , 5 } , { 6 , 5 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " % d STRNEWLINE " , findRoot ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void fillDepth ( int parent [ ] , int i , int depth [ ] ) { if ( depth [ i ] ) return ; if ( parent [ i ] == -1 ) { depth [ i ] = 1 ; return ; } if ( depth [ parent [ i ] ] == 0 ) fillDepth ( parent , parent [ i ] , depth ) ; depth [ i ] = depth [ parent [ i ] ] + 1 ; } int findHeight ( int parent [ ] , int n ) { int depth [ n ] ; for ( int i = 0 ; i < n ; i ++ ) depth [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) fillDepth ( parent , i , depth ) ; int ht = depth [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( ht < depth [ i ] ) ht = depth [ i ] ; return ht ; } int main ( ) { int parent [ ] = { -1 , 0 , 0 , 1 , 1 , 3 , 5 } ; int n = sizeof ( parent ) / sizeof ( parent [ 0 ] ) ; cout << " Height ▁ is ▁ " << findHeight ( parent , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void getPostOrderBST ( int pre [ ] , int N ) { int pivotPoint = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( pre [ 0 ] <= pre [ i ] ) { pivotPoint = i ; break ; } } for ( int i = pivotPoint - 1 ; i > 0 ; i -- ) { cout << pre [ i ] << " ▁ " ; } for ( int i = N - 1 ; i >= pivotPoint ; i -- ) { cout << pre [ i ] << " ▁ " ; } cout << pre [ 0 ] ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; int minDepth ( Node * root ) { if ( root == NULL ) return 0 ; if ( root -> left == NULL && root -> right == NULL ) return 1 ; int l = INT_MAX , r = INT_MAX ; if ( root -> left ) l = minDepth ( root -> left ) ; if ( root -> right ) r = minDepth ( root -> right ) ; return min ( l , r ) + 1 ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return ( temp ) ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; cout << " The ▁ minimum ▁ depth ▁ of ▁ binary ▁ tree ▁ is ▁ : ▁ " << minDepth ( root ) ; return 0 ; }
if ( inMST [ v ] == false && key [ v ] > weight ) { key [ v ] = weight ; pq . push ( make_pair ( key [ v ] , v ) ) ; parent [ v ] = u ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define size  4 NEW_LINE bool checkStar ( int mat [ ] [ size ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; } int main ( ) { int mat [ size ] [ size ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } } ; checkStar ( mat ) ? cout << " Star ▁ Graph " : cout << " Not ▁ a ▁ Star ▁ Graph " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> right = temp -> left = NULL ; return temp ; } Node * KthLargestUsingMorrisTraversal ( Node * root , int k ) { Node * curr = root ; Node * Klargest = NULL ; int count = 0 ; while ( curr != NULL ) { if ( curr -> right == NULL ) { if ( ++ count == k ) Klargest = curr ; curr = curr -> left ; } else { Node * succ = curr -> right ; while ( succ -> left != NULL && succ -> left != curr ) succ = succ -> left ; if ( succ -> left == NULL ) { succ -> left = curr ; curr = curr -> right ; } else { succ -> left = NULL ; if ( ++ count == k ) Klargest = curr ; curr = curr -> left ; } } } return Klargest ; } int main ( ) { Node * root = newNode ( 4 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 7 ) ; root -> left -> left = newNode ( 1 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 6 ) ; root -> right -> right = newNode ( 10 ) ; cout << " Finding ▁ K - th ▁ largest ▁ Node ▁ in ▁ BST ▁ : ▁ " << KthLargestUsingMorrisTraversal ( root , 2 ) -> data ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class TreeNode { public : int val ; TreeNode * left ; TreeNode * right ; TreeNode ( int x ) { val = x ; } } ; set < TreeNode * > s ; stack < TreeNode * > st ; TreeNode * buildTree ( int preorder [ ] , int inorder [ ] , int n ) { TreeNode * root = NULL ; for ( int pre = 0 , in = 0 ; pre < n ; ) { TreeNode * node = NULL ; do { node = new TreeNode ( preorder [ pre ] ) ; if ( root == NULL ) { root = node ; } if ( st . size ( ) > 0 ) { if ( s . find ( st . top ( ) ) != s . end ( ) ) { s . erase ( st . top ( ) ) ; st . top ( ) -> right = node ; st . pop ( ) ; } else { st . top ( ) -> left = node ; } } st . push ( node ) ; } while ( preorder [ pre ++ ] != inorder [ in ] && pre < n ) ; node = NULL ; while ( st . size ( ) > 0 && in < n && st . top ( ) -> val == inorder [ in ] ) { node = st . top ( ) ; st . pop ( ) ; in ++ ; } if ( node != NULL ) { s . insert ( node ) ; st . push ( node ) ; } } return root ; } void printInorder ( TreeNode * node ) { if ( node == NULL ) return ; printInorder ( node -> left ) ; cout << node -> val << " ▁ " ; printInorder ( node -> right ) ; } int main ( ) { int in [ ] = { 9 , 8 , 4 , 2 , 10 , 5 , 10 , 1 , 6 , 3 , 13 , 12 , 7 } ; int pre [ ] = { 1 , 2 , 4 , 8 , 9 , 5 , 10 , 10 , 3 , 6 , 7 , 12 , 13 } ; int len = sizeof ( in ) / sizeof ( int ) ; TreeNode * root = buildTree ( pre , in , len ) ; printInorder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int data ; } ; Node * createNode ( int x ) { Node * p = new Node ; p -> data = x ; p -> left = p -> right = NULL ; return p ; } void insertNode ( struct Node * root , int x ) { Node * p = root , * q = NULL ; while ( p != NULL ) { q = p ; if ( p -> data < x ) p = p -> right ; else p = p -> left ; } if ( q == NULL ) p = createNode ( x ) ; else { if ( q -> data < x ) q -> right = createNode ( x ) ; else q -> left = createNode ( x ) ; } } int maxelpath ( Node * q , int x ) { Node * p = q ; int mx = INT_MIN ; while ( p -> data != x ) { if ( p -> data > x ) { mx = max ( mx , p -> data ) ; p = p -> left ; } else { mx = max ( mx , p -> data ) ; p = p -> right ; } } return max ( mx , x ) ; } int maximumElement ( struct Node * root , int x , int y ) { Node * p = root ; while ( ( x < p -> data && y < p -> data ) || ( x > p -> data && y > p -> data ) ) { if ( x < p -> data && y < p -> data ) p = p -> left ; else if ( x > p -> data && y > p -> data ) p = p -> right ; } return max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; } int main ( ) { int arr [ ] = { 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 } ; int a = 1 , b = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; struct Node * root = createNode ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) insertNode ( root , arr [ i ] ) ; cout << maximumElement ( root , a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isLeaf ( int pre [ ] , int & i , int n , int min , int max ) { if ( i >= n ) return false ; if ( pre [ i ] > min && pre [ i ] < max ) { i ++ ; bool left = isLeaf ( pre , i , n , min , pre [ i - 1 ] ) ; bool right = isLeaf ( pre , i , n , pre [ i - 1 ] , max ) ; if ( ! left && ! right ) cout << pre [ i - 1 ] << " ▁ " ; return true ; } return false ; } void printLeaves ( int preorder [ ] , int n ) { int i = 0 ; isLeaf ( preorder , i , n , INT_MIN , INT_MAX ) ; } int main ( ) { int preorder [ ] = { 890 , 325 , 290 , 530 , 965 } ; int n = sizeof ( preorder ) / sizeof ( preorder [ 0 ] ) ; printLeaves ( preorder , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define n  4 NEW_LINE void interchangeFirstLast ( int m [ ] [ n ] ) { int rows = n ; for ( int i = 0 ; i < n ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } int main ( ) { int m [ n ] [ n ] = { { 8 , 9 , 7 , 6 } , { 4 , 7 , 6 , 5 } , { 3 , 2 , 1 , 8 } , { 9 , 9 , 7 , 7 } } ; interchangeFirstLast ( m ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << m [ i ] [ j ] << " ▁ " ; cout << endl ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; } ; Node * newNode ( int data ) ; int search ( int arr [ ] , int strt , int end , int value ) ; Node * buildUtil ( int in [ ] , int post [ ] , int inStrt , int inEnd , int * pIndex ) { if ( inStrt > inEnd ) return NULL ; Node * node = newNode ( post [ * pIndex ] ) ; ( * pIndex ) -- ; if ( inStrt == inEnd ) return node ; int iIndex = search ( in , inStrt , inEnd , node -> data ) ; node -> right = buildUtil ( in , post , iIndex + 1 , inEnd , pIndex ) ; node -> left = buildUtil ( in , post , inStrt , iIndex - 1 , pIndex ) ; return node ; } Node * buildTree ( int in [ ] , int post [ ] , int n ) { int pIndex = n - 1 ; return buildUtil ( in , post , 0 , n - 1 , & pIndex ) ; } int search ( int arr [ ] , int strt , int end , int value ) { int i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) break ; } return i ; } Node * newNode ( int data ) { Node * node = ( Node * ) malloc ( sizeof ( Node ) ) ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void preOrder ( Node * node ) { if ( node == NULL ) return ; printf ( " % d ▁ " , node -> data ) ; preOrder ( node -> left ) ; preOrder ( node -> right ) ; } int main ( ) { int in [ ] = { 4 , 8 , 2 , 5 , 1 , 6 , 3 , 7 } ; int post [ ] = { 8 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int n = sizeof ( in ) / sizeof ( in [ 0 ] ) ; Node * root = buildTree ( in , post , n ) ; cout << " Preorder ▁ of ▁ the ▁ constructed ▁ tree ▁ : ▁ STRNEWLINE " ; preOrder ( root ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ; void Kroneckerproduct ( int A [ ] [ cola ] , int B [ ] [ colb ] ) { int C [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; cout << C [ i + l + 1 ] [ j + k + 1 ] << " ▁ " ; } } cout << endl ; } } } int main ( ) { int A [ 3 ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } , B [ 2 ] [ 3 ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; } int main ( ) { int n = 4 , k = 7 ; int freq = find ( n , k ) ; if ( freq < 0 ) cout << " ▁ element ▁ not ▁ exist ▁ STRNEWLINE ▁ " ; else cout << " ▁ Frequency ▁ of ▁ " << k << " ▁ is ▁ " << freq << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) cout << 1 << " ▁ " ; else cout << 0 << " ▁ " ; } cout << endl ; } return 0 ; } int main ( ) { int size = 5 ; Identity ( size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void imageSwap ( int mat [ ] [ MAX ] , int n ) { int row = 0 ; for ( int j = 0 ; j < n ; j ++ ) { stack < int > s ; int i = row , k = j ; while ( i < n && k >= 0 ) s . push ( mat [ i ++ ] [ k -- ] ) ; i = row , k = j ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . top ( ) ; s . pop ( ) ; } } int column = n - 1 ; for ( int j = 1 ; j < n ; j ++ ) { stack < int > s ; int i = j , k = column ; while ( i < n && k >= 0 ) s . push ( mat [ i ++ ] [ k -- ] ) ; i = j ; k = column ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . top ( ) ; s . pop ( ) ; } } } void printMatrix ( int mat [ ] [ MAX ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << " ▁ " ; cout << endl ; } } int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int n = 4 ; imageSwap ( mat , n ) ; printMatrix ( mat , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  4 NEW_LINE #define C  4 NEW_LINE int getTotalCoverageOfMatrix ( int mat [ R ] [ C ] ) { int res = 0 ; for ( int i = 0 ; i < R ; i ++ ) { bool isOne = false ; for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int j = C - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } for ( int j = 0 ; j < C ; j ++ ) { bool isOne = false ; for ( int i = 0 ; i < R ; i ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int i = R - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } return res ; } int main ( ) { int mat [ R ] [ C ] = { { 0 , 0 , 0 , 0 } , { 1 , 0 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 } } ; cout << getTotalCoverageOfMatrix ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  6 NEW_LINE void spiralPrint ( int m , int n , int a [ R ] [ C ] , int c ) { int i , k = 0 , l = 0 ; int count = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { count ++ ; if ( count == c ) cout << a [ k ] [ i ] << " ▁ " ; } k ++ ; for ( i = k ; i < m ; ++ i ) { count ++ ; if ( count == c ) cout << a [ i ] [ n - 1 ] << " ▁ " ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { count ++ ; if ( count == c ) cout << a [ m - 1 ] [ i ] << " ▁ " ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { count ++ ; if ( count == c ) cout << a [ i ] [ l ] << " ▁ " ; } l ++ ; } } } int main ( ) { int a [ R ] [ C ] = { { 1 , 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 , 17 , 18 } } , k = 17 ; spiralPrint ( R , C , a , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNegative ( int M [ ] [ 4 ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; } int main ( ) { int M [ 3 ] [ 4 ] = { { -3 , -2 , -1 , 1 } , { -2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; cout << countNegative ( M , 3 , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  10 NEW_LINE int findLargestPlus ( int mat [ N ] [ N ] ) { int left [ N ] [ N ] , right [ N ] [ N ] , top [ N ] [ N ] , bottom [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n ) return 4 * ( n - 1 ) + 1 ; return 0 ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 } , { 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 } , { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 } } ; cout << findLargestPlus ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void add ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; cout << " Result ▁ matrix ▁ is ▁ " << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << " ▁ " ; cout << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void subtract ( int A [ ] [ N ] , int B [ ] [ N ] , int C [ ] [ N ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } int main ( ) { int A [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ N ] [ N ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; cout << " Result ▁ matrix ▁ is ▁ " << endl ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) cout << C [ i ] [ j ] << " ▁ " ; cout << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findPeakUtil ( int arr [ ] , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; } int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ " << findPeak ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRepeating ( int arr [ ] , int size ) { int i , j ; printf ( " ▁ Repeating ▁ elements ▁ are ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) ; void printRepeating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; cout << " The ▁ two ▁ Repeating ▁ elements ▁ are ▁ " << x << " ▁ & ▁ " << y ; } int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRepeating ( int arr [ ] , int size ) { int Xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) Xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) Xor ^= i ; set_bit_no = Xor & ~ ( Xor - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ; else y = y ^ i ; } cout << " The ▁ two ▁ repeating ▁ elements ▁ are ▁ " << y << " ▁ " << x ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return -1 ; } int main ( ) { int arr [ ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Fixed ▁ Point ▁ is ▁ " << linearSearch ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << start << " ▁ and ▁ " << i - 1 ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } cout << " No ▁ subarray ▁ found " ; return 0 ; } int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum ( int a , int b , int c ) { return max ( max ( a , b ) , c ) ; } int minimum ( int a , int b , int c ) { return min ( min ( a , b ) , c ) ; } void smallestDifferenceTriplet ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int n ) { sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + n ) ; sort ( arr3 , arr3 + n ) ; int res_min , res_max , res_mid ; int i = 0 , j = 0 , k = 0 ; int diff = INT_MAX ; while ( i < n && j < n && k < n ) { int sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; int max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; int min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; if ( min == arr1 [ i ] ) i ++ ; else if ( min == arr2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_max = max ; res_mid = sum - ( max + min ) ; res_min = min ; } } cout << res_max << " , ▁ " << res_mid << " , ▁ " << res_min ; } int main ( ) { int arr1 [ ] = { 5 , 2 , 8 } ; int arr2 [ ] = { 10 , 7 , 12 } ; int arr3 [ ] = { 9 , 14 , 6 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << " Triplet ▁ is ▁ " << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] ; return true ; } } } } return false ; } int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find3Numbers ( A , arr_size , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void subArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) cout << arr [ k ] << " ▁ " ; cout << endl ; } } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " All ▁ Non - empty ▁ Subarrays STRNEWLINE " ; subArray ( arr , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <stdlib.h> NEW_LINE int getMin ( int arr [ ] , int n ) ; int getMax ( int arr [ ] , int n ) ; bool areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { bool * visited = ( bool * ) calloc ( n , sizeof ( bool ) ) ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; } int getMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] < min ) min = arr [ i ] ; return min ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; } int main ( ) { int arr [ ] = { 5 , 4 , 2 , 3 , 1 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areConsecutive ( arr , n ) == true ) printf ( " ▁ Array ▁ elements ▁ are ▁ consecutive ▁ " ) ; else printf ( " ▁ Array ▁ elements ▁ are ▁ not ▁ consecutive ▁ " ) ; getchar ( ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) return i ; return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = search ( arr , n , x ) ; ( result == -1 ) ? cout << " Element ▁ is ▁ not ▁ present ▁ in ▁ array " : cout << " Element ▁ is ▁ present ▁ at ▁ index ▁ " << result ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? cout << " Element ▁ is ▁ not ▁ present ▁ in ▁ array " : cout << " Element ▁ is ▁ present ▁ at ▁ index ▁ " << result ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; #define RANGE  255 NEW_LINE void countSort ( char arr [ ] ) { char output [ strlen ( arr ) ] ; int count [ RANGE + 1 ] , i ; memset ( count , 0 , sizeof ( count ) ) ; for ( i = 0 ; arr [ i ] ; ++ i ) ++ count [ arr [ i ] ] ; for ( i = 1 ; i <= RANGE ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( i = 0 ; arr [ i ] ; ++ i ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( i = 0 ; arr [ i ] ; ++ i ) arr [ i ] = output [ i ] ; } int main ( ) { char arr [ ] = " geeksforgeeks " ; countSort ( arr ) ; cout << " Sorted ▁ character ▁ array ▁ is ▁ " << arr ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void countSort ( vector < int > & arr ) { int max = * max_element ( arr . begin ( ) , arr . end ( ) ) ; int min = * min_element ( arr . begin ( ) , arr . end ( ) ) ; int range = max - min + 1 ; vector < int > count ( range ) , output ( arr . size ( ) ) ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) count [ arr [ i ] - min ] ++ ; for ( int i = 1 ; i < count . size ( ) ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( int i = arr . size ( ) - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( int i = 0 ; i < arr . size ( ) ; i ++ ) arr [ i ] = output [ i ] ; } void printArray ( vector < int > & arr ) { for ( int i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } int main ( ) { vector < int > arr = { -5 , -10 , 0 , -3 , 8 , 5 , -1 , 10 } ; countSort ( arr ) ; printArray ( arr ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void cycleSort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle_start = 0 ; cycle_start <= n - 2 ; cycle_start ++ ) { int item = arr [ cycle_start ] ; int pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; if ( pos == cycle_start ) continue ; while ( item == arr [ pos ] ) pos += 1 ; if ( pos != cycle_start ) { swap ( item , arr [ pos ] ) ; writes ++ ; } while ( pos != cycle_start ) { pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; while ( item == arr [ pos ] ) pos += 1 ; if ( item != arr [ pos ] ) { swap ( item , arr [ pos ] ) ; writes ++ ; } } } } int main ( ) { int arr [ ] = { 1 , 8 , 3 , 9 , 10 , 10 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cycleSort ( arr , n ) ; cout << " After ▁ sort ▁ : ▁ " << endl ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE #include <climits> NEW_LINE #include <cstdlib> NEW_LINE using namespace std ; void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = INT_MAX ; int res_l , res_r ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } cout << " The ▁ closest ▁ pair ▁ is ▁ [ " << ar1 [ res_l ] << " , ▁ " << ar2 [ res_r ] << " ] ▁ STRNEWLINE " ; } int main ( ) { int ar1 [ ] = { 1 , 4 , 5 , 7 } ; int ar2 [ ] = { 10 , 20 , 30 , 40 } ; int m = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; int x = 38 ; printClosest ( ar1 , ar2 , m , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; cout << " Following ▁ activities ▁ are ▁ selected ▁ " << endl ; i = 0 ; cout << " ▁ " << i ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { cout << " ▁ " << j ; i = j ; } } } int main ( ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; printMaxActivities ( s , f , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; } int main ( ) { int n = 5 , k = 2 ; cout << " Value ▁ of ▁ C ( " << n << " , ▁ " << k << " ) ▁ is ▁ " << binomialCoeff ( n , k ) ; return 0 ; }
#include <stdio.h> NEW_LINE int getCount ( char keypad [ ] [ 3 ] , int n ) { if ( keypad == NULL n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int row [ ] = { 0 , 0 , -1 , 0 , 1 } ; int col [ ] = { 0 , -1 , 0 , 1 , 0 } ; int count [ 10 ] [ n + 1 ] ; int i = 0 , j = 0 , k = 0 , move = 0 , ro = 0 , co = 0 , num = 0 ; int nextNum = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) { count [ i ] [ 0 ] = 0 ; count [ i ] [ 1 ] = 1 ; } for ( k = 2 ; k <= n ; k ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { if ( keypad [ i ] [ j ] != ' * ' && keypad [ i ] [ j ] != ' # ' ) { num = keypad [ i ] [ j ] - '0' ; count [ num ] [ k ] = 0 ; for ( move = 0 ; move < 5 ; move ++ ) { ro = i + row [ move ] ; co = j + col [ move ] ; if ( ro >= 0 && ro <= 3 && co >= 0 && co <= 2 && keypad [ ro ] [ co ] != ' * ' && keypad [ ro ] [ co ] != ' # ' ) { nextNum = keypad [ ro ] [ co ] - '0' ; count [ num ] [ k ] += count [ nextNum ] [ k - 1 ] ; } } } } } } totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) totalCount += count [ i ] [ n ] ; return totalCount ; } int main ( int argc , char * argv [ ] ) { char keypad [ 4 ] [ 3 ] = { { '1' , '2' , '3' } , { '4' , '5' , '6' } , { '7' , '8' , '9' } , { ' * ' , '0' , ' # ' } } ; printf ( " Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn " , 1 , getCount ( keypad , 1 ) ) ; printf ( " Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn " , 2 , getCount ( keypad , 2 ) ) ; printf ( " Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn " , 3 , getCount ( keypad , 3 ) ) ; printf ( " Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn " , 4 , getCount ( keypad , 4 ) ) ; printf ( " Count ▁ for ▁ numbers ▁ of ▁ length ▁ % d : ▁ % dn " , 5 , getCount ( keypad , 5 ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ; if ( sum == 0 ) return 1 ; unsigned long long int ans = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } unsigned long long int finalCount ( int n , int sum ) { unsigned long long int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } int main ( ) { int n = 2 , sum = 5 ; cout << finalCount ( n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void findCount ( int n , int sum ) { int start = pow ( 10 , n - 1 ) ; int end = pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i <= end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } cout << count ; } int main ( ) { int n = 3 ; int sum = 5 ; findCount ( n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinSquares ( unsigned int n ) { if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1 ; if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; } int main ( ) { cout << getMinSquares ( 6 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigitsFrom1ToNUtil ( int n , int a [ ] ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( log10 ( n ) ) ; int p = ( int ) ( ceil ( pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToNUtil ( n % p , a ) ) ; } int sumOfDigitsFrom1ToN ( int n ) { int d = ( int ) ( log10 ( n ) ) ; int a [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( ceil ( pow ( 10 , i - 1 ) ) ) ; return sumOfDigitsFrom1ToNUtil ( n , a ) ; } int main ( ) { int n = 328 ; cout << " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ is ▁ " << sumOfDigitsFrom1ToN ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } int main ( ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) cout << " Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ " << N << " ▁ keystrokes ▁ is ▁ " << findoptimal ( N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } int main ( ) { string txt = " ABCEABCDABCEABCD " ; string pat = " ABCD " ; search ( pat , txt ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } int main ( ) { float x = 2 ; int y = -3 ; cout << power ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = -1 , m2 = -1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } int main ( ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) cout << " Median ▁ is ▁ " << getMedian ( ar1 , ar2 , n1 ) ; else cout << " Doesn ' t ▁ work ▁ for ▁ arrays " << " ▁ of ▁ unequal ▁ size " ; getchar ( ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; class gfg { public : float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } } ; int main ( ) { gfg g ; int n = 50 ; cout << " Square ▁ root ▁ of ▁ " << n << " ▁ is ▁ " << g . squareRoot ( n ) ; getchar ( ) ; }
#include <iostream> NEW_LINE using namespace std ; class GFG { public : int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; } } ; int main ( ) { GFG g ; cout << endl << g . multiply ( 5 , -11 ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; } int main ( ) { cout << pow ( 5 , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int multiply ( int x , int y ) { if ( y ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; } int pow ( int a , int b ) { if ( b ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; } int main ( ) { cout << pow ( 5 , 3 ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float getAvg ( int x ) { static int sum , n ; sum += x ; return ( ( ( float ) sum ) / ++ n ) ; } void streamAvg ( float arr [ ] , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( arr [ i ] ) ; cout << " Average ▁ of ▁ " << i + 1 << " ▁ numbers ▁ is ▁ " << fixed << setprecision ( 1 ) << avg << endl ; } return ; } int main ( ) { float arr [ ] = { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; streamAvg ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; } int main ( ) { cout << count ( 578 ) << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { cout << C << " ▁ " ; C = C * ( line - i ) / i ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) ; void printCombination ( int arr [ ] , int n , int r ) { int data [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; } void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) cout << data [ j ] << " ▁ " ; cout << endl ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printCombination ( arr , n , r ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findgroups ( int arr [ ] , int n ) { int c [ 3 ] = { 0 } , i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } int main ( ) { int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Required ▁ number ▁ of ▁ groups ▁ are ▁ " << findgroups ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min ( int x , int y ) { return ( x < y ) ? x : y ; } int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) printf ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } float hour_angle = 0.5 * ( h * 60 + m ) ; float minute_angle = 6 * m ; float angle = abs ( hour_angle - minute_angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; } int main ( ) { cout << calcAngle ( 9 , 60 ) << endl ; cout << calcAngle ( 3 , 30 ) << endl ; return 0 ; }
#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; } int main ( ) { cout << find ( 0.70 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_ITER  1000000 NEW_LINE double func ( double x ) { return x * x * x - x * x + 2 ; } void regulaFalsi ( double a , double b ) { if ( func ( a ) * func ( b ) >= 0 ) { cout << " You ▁ have ▁ not ▁ assumed ▁ right ▁ a ▁ and ▁ b STRNEWLINE " ; return ; } double c = a ; for ( int i = 0 ; i < MAX_ITER ; i ++ ) { c = ( a * func ( b ) - b * func ( a ) ) / ( func ( b ) - func ( a ) ) ; if ( func ( c ) == 0 ) break ; else if ( func ( c ) * func ( a ) < 0 ) b = c ; else a = c ; } cout << " The ▁ value ▁ of ▁ root ▁ is ▁ : ▁ " << c ; } int main ( ) { double a = -200 , b = 300 ; regulaFalsi ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) { unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ; unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ; unsigned int Xor = ( set1 ^ set2 ) ; Xor = ( Xor << p1 ) | ( Xor << p2 ) ; unsigned int result = x ^ Xor ; return result ; } int main ( ) { int res = swapBits ( 28 , 0 , 3 , 2 ) ; cout << " Result ▁ = ▁ " << res ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fun ( unsigned int n ) { return n & ( n - 1 ) ; } int main ( ) { int n = 7 ; cout << " The ▁ number ▁ after ▁ unsetting ▁ the " ; cout << " ▁ rightmost ▁ set ▁ bit ▁ " << fun ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfFour ( unsigned int n ) { int count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) cout << test_no << " ▁ is ▁ a ▁ power ▁ of ▁ 4" ; else cout << test_no << " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4" ; }
#include <iostream> NEW_LINE using namespace std ; class gfg { public : int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x < y ) ) ; } int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x < y ) ) ; } } ; int main ( ) { gfg g ; int x = 15 ; int y = 6 ; cout << " Minimum ▁ of ▁ " << x << " ▁ and ▁ " << y << " ▁ is ▁ " ; cout << g . min ( x , y ) ; cout << " Maximum of " ▁ < < ▁ x ▁ < < STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL TABSYMBOL " and " ▁ < < ▁ y ▁ < < ▁ " is " cout << g . max ( x , y ) ; getchar ( ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getOddOccurrence ( int arr [ ] , int size ) { unordered_map < int , int > hash ; for ( int i = 0 ; i < size ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( auto i : hash ) { if ( i . second % 2 != 0 ) { return i . first ; } } return -1 ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getOddOccurrence ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int num_to_bits [ 16 ] = { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; unsigned int countSetBitsRec ( unsigned int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } int main ( ) { int num = 31 ; cout << countSetBitsRec ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; } int main ( ) { unsigned int n = 5 ; cout << nextPowerOf2 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( ceil ( log2 ( n ) ) == floor ( log2 ( n ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << " Yes " << endl : cout << " No " << endl ; isPowerOfTwo ( 64 ) ? cout << " Yes " << endl : cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 2 != 0 ) return 0 ; n = n / 2 ; } return 1 ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isPowerOfTwo ( 64 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; class gfg { public : unsigned int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; } } ; int main ( ) { gfg g ; int n = 12 ; cout << g . getFirstSetBitPos ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int swapBits ( unsigned int x ) { unsigned int even_bits = x & 0xAAAAAAAA ; unsigned int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; } int main ( ) { unsigned int x = 23 ; cout << swapBits ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; } int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned count = 0 ; while ( n ) { n = n >> 1 ; ++ count ; } return count ; } int main ( void ) { int n = 0 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number STRNEWLINE " : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number STRNEWLINE " : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number STRNEWLINE " : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nextGreatest ( int arr [ ] , int size ) { int max_from_right = arr [ size - 1 ] ; arr [ size - 1 ] = -1 ; for ( int i = size - 2 ; i >= 0 ; i -- ) { int temp = arr [ i ] ; arr [ i ] = max_from_right ; if ( max_from_right < temp ) max_from_right = temp ; } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nextGreatest ( arr , size ) ; cout << " The ▁ modified ▁ array ▁ is : ▁ STRNEWLINE " ; printArray ( arr , size ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCircularSum ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int curr_max = a [ 0 ] , max_so_far = a [ 0 ] , curr_min = a [ 0 ] , min_so_far = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = max ( curr_max + a [ i ] , a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; curr_min = min ( curr_min + a [ i ] , a [ i ] ) ; min_so_far = min ( min_so_far , curr_min ) ; } if ( min_so_far == sum ) return max_so_far ; return max ( max_so_far , sum - min_so_far ) ; } int main ( ) { int a [ ] = { 11 , 10 , -20 , 5 , -3 , -5 , 8 , -13 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " Maximum ▁ circular ▁ sum ▁ is ▁ " << maxCircularSum ( a , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 0 ; i < arr_size ; i ++ ) { for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; } int main ( ) { int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ difference ▁ is ▁ " << maxDiff ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; } int main ( ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ maximum ▁ element ▁ is ▁ " << findMaximum ( arr , 0 , n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSwaps ( int arr [ ] , int n ) { int noOfZeroes [ n ] ; memset ( noOfZeroes , 0 , sizeof ( noOfZeroes ) ) ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSwaps ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSwapsToSort ( int arr [ ] , int n ) { pair < int , int > arrPos [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arrPos [ i ] . first = arr [ i ] ; arrPos [ i ] . second = i ; } sort ( arrPos , arrPos + n ) ; vector < bool > vis ( n , false ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] arrPos [ i ] . second == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = 1 ; j = arrPos [ j ] . second ; cycle_size ++ ; } ans += ( cycle_size - 1 ) ; } return ans ; } int minSwapToMakeArraySame ( int a [ ] , int b [ ] , int n ) { map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ b [ i ] ] = i ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = mp [ a [ i ] ] ; return minSwapsToSort ( b , n ) ; } int main ( ) { int a [ ] = { 3 , 6 , 4 , 8 } ; int b [ ] = { 4 , 6 , 8 , 3 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << minSwapToMakeArraySame ( a , b , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int arr [ ] , int n , int sum ) { sort ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; } int main ( ) { int arr [ ] = { 5 , 1 , 3 , 4 , 7 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int sum = 12 ; cout << countTriplets ( arr , n , sum ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwoElements ( int arr [ ] , int size ) { int i ; cout << " ▁ The ▁ repeating ▁ element ▁ is ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else cout << abs ( arr [ i ] ) << " STRNEWLINE " ; } cout << " and ▁ the ▁ missing ▁ element ▁ is ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) cout << ( i + 1 ) ; } } int main ( ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoElements ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } cout << " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " << x << " ▁ & ▁ " << y ; } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoOdd ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findPair ( int arr [ ] , int size , int n ) { int i = 0 ; int j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { cout << " Pair ▁ Found : ▁ ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } cout << " No ▁ such ▁ pair " ; return false ; } int main ( ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 60 ; findPair ( arr , size , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void fourSum ( int X , int arr [ ] , map < int , pair < int , int > > Map , int N ) { int temp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) temp [ i ] = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int curr_sum = arr [ i ] + arr [ j ] ; if ( Map . find ( X - curr_sum ) != Map . end ( ) ) { pair < int , int > p = Map [ X - curr_sum ] ; if ( p . first != i && p . second != i && p . first != j && p . second != j && temp [ p . first ] == 0 && temp [ p . second ] == 0 && temp [ i ] == 0 && temp [ j ] == 0 ) { cout << arr [ i ] << " , " << arr [ j ] << " , " << arr [ p . first ] << " , " << arr [ p . second ] ; temp [ p . second ] = 1 ; temp [ i ] = 1 ; temp [ j ] = 1 ; break ; } } } } } map < int , pair < int , int > > twoSum ( int nums [ ] , int N ) { map < int , pair < int , int > > Map ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { Map [ nums [ i ] + nums [ j ] ] . first = i ; Map [ nums [ i ] + nums [ j ] ] . second = j ; } } return Map ; } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 91 ; map < int , pair < int , int > > Map = twoSum ( arr , n ) ; fourSum ( X , arr , Map , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int deleteElement ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; } int main ( ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 6 ; n = deleteElement ( arr , n , x ) ; cout << " Modified ▁ array ▁ is ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDistance ( int arr [ ] , int n ) { int max1 = INT_MIN , min1 = INT_MAX ; int max2 = INT_MIN , min2 = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { max1 = max ( max1 , arr [ i ] + i ) ; min1 = min ( min1 , arr [ i ] + i ) ; max2 = max ( max2 , arr [ i ] - i ) ; min2 = min ( min2 , arr [ i ] - i ) ; } return max ( max1 - min1 , max2 - min2 ) ; } int main ( ) { int arr [ ] = { -70 , -64 , -6 , -56 , 64 , 61 , -57 , 16 , 48 , -98 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxDistance ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getClosest ( int , int , int ) ; int findClosest ( int arr [ ] , int n , int target ) { if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int target = 11 ; cout << ( findClosest ( arr , n , target ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } cout << endl ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } Node * insertBeg ( Node * head , int val ) { Node * temp = newNode ( val ) ; temp -> next = head ; head = temp ; return head ; } void rearrange ( Node * * head ) { Node * even ; Node * temp , * prev_temp ; Node * i , * j , * k , * l , * ptr ; temp = ( * head ) -> next ; prev_temp = * head ; while ( temp != nullptr ) { Node * x = temp -> next ; if ( temp -> data % 2 != 0 ) { prev_temp -> next = x ; temp -> next = ( * head ) ; ( * head ) = temp ; } else { prev_temp = temp ; } temp = x ; } temp = ( * head ) -> next ; prev_temp = ( * head ) ; while ( temp != nullptr && temp -> data % 2 != 0 ) { prev_temp = temp ; temp = temp -> next ; } even = temp ; prev_temp -> next = nullptr ; i = * head ; j = even ; while ( j != nullptr && i != nullptr ) { k = i -> next ; l = j -> next ; i -> next = j ; j -> next = k ; ptr = j ; i = k ; j = l ; } if ( i == nullptr ) { ptr -> next = j ; } } int main ( ) { Node * head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 1 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 10 ) ; cout << " Linked ▁ List : " << endl ; printList ( head ) ; cout << " Rearranged ▁ List " << endl ; rearrange ( & head ) ; printList ( head ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * next ; } ; void rotate ( Node * * head_ref , int k ) { if ( k == 0 ) return ; Node * current = * head_ref ; while ( current -> next != NULL ) current = current -> next ; current -> next = * head_ref ; current = * head_ref ; for ( int i = 0 ; i < k - 1 ; i ++ ) current = current -> next ; * head_ref = current -> next ; current -> next = NULL ; } void push ( Node * * head_ref , int new_data ) { Node * new_node = new Node ( ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } } int main ( void ) { Node * head = NULL ; for ( int i = 60 ; i > 0 ; i -= 10 ) push ( & head , i ) ; cout << " Given ▁ linked ▁ list ▁ STRNEWLINE " ; printList ( head ) ; rotate ( & head , 4 ) ; cout << " Rotated Linked list " ; printList ( head ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { vector < int > list ; list . push_back ( 1 ) ; list . push_back ( 2 ) ; list . push_back ( 3 ) ; for ( vector < int > :: iterator it = list . begin ( ) ; it != list . end ( ) ; ++ it ) cout << * it << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; struct Node * newNode ( int x ) { Node * temp = new Node ; temp -> data = x ; temp -> next = NULL ; } Node * keyToEnd ( Node * head , int key ) { Node * tail = head ; if ( head == NULL ) { return NULL ; } while ( tail -> next != NULL ) { tail = tail -> next ; } Node * last = tail ; Node * current = head ; Node * prev = NULL ; Node * prev2 = NULL ; while ( current != tail ) { if ( current -> data == key && prev2 == NULL ) { prev = current ; current = current -> next ; head = current ; last -> next = prev ; last = last -> next ; last -> next = NULL ; prev = NULL ; } else { if ( current -> data == key && prev2 != NULL ) { prev = current ; current = current -> next ; prev2 -> next = current ; last -> next = prev ; last = last -> next ; last -> next = NULL ; } else if ( current != tail ) { prev2 = current ; current = current -> next ; } } } return head ; } void printList ( Node * head ) { struct Node * temp = head ; while ( temp != NULL ) { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } printf ( " STRNEWLINE " ) ; } int main ( ) { Node * root = newNode ( 5 ) ; root -> next = newNode ( 2 ) ; root -> next -> next = newNode ( 2 ) ; root -> next -> next -> next = newNode ( 7 ) ; root -> next -> next -> next -> next = newNode ( 2 ) ; root -> next -> next -> next -> next -> next = newNode ( 2 ) ; root -> next -> next -> next -> next -> next -> next = newNode ( 2 ) ; int key = 2 ; cout << " Linked ▁ List ▁ before ▁ operations ▁ : " ; printList ( root ) ; cout << " Linked List after operations : " root = keyToEnd ( root , key ) ; printList ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } int sumOfLastN_NodesUtil ( struct Node * head , int n ) { if ( n <= 0 ) return 0 ; stack < int > st ; int sum = 0 ; while ( head != NULL ) { st . push ( head -> data ) ; head = head -> next ; } while ( n -- ) { sum += st . top ( ) ; st . pop ( ) ; } return sum ; } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 6 ) ; push ( & head , 10 ) ; int n = 2 ; cout << " Sum ▁ of ▁ last ▁ " << n << " ▁ nodes ▁ = ▁ " << sumOfLastN_NodesUtil ( head , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void reverseList ( struct Node * * head_ref ) { struct Node * current , * prev , * next ; current = * head_ref ; prev = NULL ; while ( current != NULL ) { next = current -> next ; current -> next = prev ; prev = current ; current = next ; } * head_ref = prev ; } int sumOfLastN_NodesUtil ( struct Node * head , int n ) { if ( n <= 0 ) return 0 ; reverseList ( & head ) ; int sum = 0 ; struct Node * current = head ; while ( current != NULL && n -- ) { sum += current -> data ; current = current -> next ; } reverseList ( & head ) ; return sum ; } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 6 ) ; push ( & head , 10 ) ; int n = 2 ; cout << " Sum ▁ of ▁ last ▁ " << n << " ▁ nodes ▁ = ▁ " << sumOfLastN_NodesUtil ( head , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void swapNodes ( struct Node * * head_ref , struct Node * currX , struct Node * currY , struct Node * prevY ) { * head_ref = currY ; prevY -> next = currX ; struct Node * temp = currY -> next ; currY -> next = currX -> next ; currX -> next = temp ; } struct Node * recurSelectionSort ( struct Node * head ) { if ( head -> next == NULL ) return head ; struct Node * min = head ; struct Node * beforeMin = NULL ; struct Node * ptr ; for ( ptr = head ; ptr -> next != NULL ; ptr = ptr -> next ) { if ( ptr -> next -> data < min -> data ) { min = ptr -> next ; beforeMin = ptr ; } } if ( min != head ) swapNodes ( & head , head , min , beforeMin ) ; head -> next = recurSelectionSort ( head -> next ) ; return head ; } void sort ( struct Node * * head_ref ) { if ( ( * head_ref ) == NULL ) return ; * head_ref = recurSelectionSort ( * head_ref ) ; } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * head ) { while ( head != NULL ) { cout << head -> data << " ▁ " ; head = head -> next ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 6 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 12 ) ; push ( & head , 10 ) ; cout << " Linked ▁ list ▁ before ▁ sorting : n " ; printList ( head ) ; sort ( & head ) ; cout << " Linked list after sorting : n " ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; Node * next , * prev ; } ; void insert ( Node * * head_ref , int data ) { Node * new_node = new Node ; new_node -> data = data ; if ( * head_ref == NULL ) { new_node -> next = new_node ; new_node -> prev = new_node ; } else { Node * last = ( * head_ref ) -> prev ; new_node -> next = * head_ref ; new_node -> prev = last ; last -> next = ( * head_ref ) -> prev = new_node ; } * head_ref = new_node ; } Node * merge ( Node * first , Node * second ) { if ( ! first ) return second ; if ( ! second ) return first ; if ( first -> data < second -> data ) { first -> next = merge ( first -> next , second ) ; first -> next -> prev = first ; first -> prev = NULL ; return first ; } else { second -> next = merge ( first , second -> next ) ; second -> next -> prev = second ; second -> prev = NULL ; return second ; } } Node * mergeUtil ( Node * head1 , Node * head2 ) { if ( ! head1 ) return head2 ; if ( ! head2 ) return head1 ; Node * last_node ; if ( head1 -> prev -> data < head2 -> prev -> data ) last_node = head2 -> prev ; else last_node = head1 -> prev ; head1 -> prev -> next = head2 -> prev -> next = NULL ; Node * finalHead = merge ( head1 , head2 ) ; finalHead -> prev = last_node ; last_node -> next = finalHead ; return finalHead ; } void printList ( Node * head ) { Node * temp = head ; while ( temp -> next != head ) { cout << temp -> data << " ▁ " ; temp = temp -> next ; } cout << temp -> data << " ▁ " ; } int main ( ) { Node * head1 = NULL , * head2 = NULL ; insert ( & head1 , 8 ) ; insert ( & head1 , 5 ) ; insert ( & head1 , 3 ) ; insert ( & head1 , 1 ) ; insert ( & head2 , 11 ) ; insert ( & head2 , 9 ) ; insert ( & head2 , 7 ) ; insert ( & head2 , 2 ) ; Node * newHead = mergeUtil ( head1 , head2 ) ; cout << " Final ▁ Sorted ▁ List : ▁ " ; printList ( newHead ) ; return 0 ; }
#include <iostream> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; string minLexRotation ( string str ) { int n = str . length ( ) ; string arr [ n ] ; string concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = concat . substr ( i , n ) ; sort ( arr , arr + n ) ; return arr [ 0 ] ; } int main ( ) { cout << minLexRotation ( " GEEKSFORGEEKS " ) << endl ; cout << minLexRotation ( " GEEKSQUIZ " ) << endl ; cout << minLexRotation ( " BCABDADAB " ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE #define log  10  NEW_LINE int level [ MAX ] ; int lca [ MAX ] [ log ] ; int minWeight [ MAX ] [ log ] ; int maxWeight [ MAX ] [ log ] ; vector < int > graph [ MAX ] ; int weight [ MAX ] ; void addEdge ( int u , int v ) { graph [ u ] . push_back ( v ) ; graph [ v ] . push_back ( u ) ; } void dfs ( int node , int parent , int h ) { lca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != -1 ) { minWeight [ node ] [ 0 ] = min ( weight [ node ] , weight [ parent ] ) ; maxWeight [ node ] [ 0 ] = max ( weight [ node ] , weight [ parent ] ) ; } for ( int i = 1 ; i < log ; i ++ ) { if ( lca [ node ] [ i - 1 ] != -1 ) { lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; minWeight [ node ] [ i ] = min ( minWeight [ node ] [ i - 1 ] , minWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; maxWeight [ node ] [ i ] = max ( maxWeight [ node ] [ i - 1 ] , maxWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; } } for ( int i : graph [ node ] ) { if ( i == parent ) continue ; dfs ( i , node , h + 1 ) ; } } void findMinMaxWeight ( int u , int v ) { int minWei = INT_MAX ; int maxWei = INT_MIN ; if ( level [ u ] > level [ v ] ) swap ( u , v ) ; for ( int i = log - 1 ; i >= 0 ; i -- ) { if ( lca [ v ] [ i ] != -1 && level [ lca [ v ] [ i ] ] >= level [ u ] ) { minWei = min ( minWei , minWeight [ v ] [ i ] ) ; maxWei = max ( maxWei , maxWeight [ v ] [ i ] ) ; v = lca [ v ] [ i ] ; } } if ( v == u ) { cout << minWei << " ▁ " << maxWei << endl ; } else { for ( int i = log - 1 ; i >= 0 ; i -- ) { if ( lca [ v ] [ i ] != lca [ u ] [ i ] ) { minWei = min ( minWei , min ( minWeight [ v ] [ i ] , minWeight [ u ] [ i ] ) ) ; maxWei = max ( maxWei , max ( maxWeight [ v ] [ i ] , maxWeight [ u ] [ i ] ) ) ; v = lca [ v ] [ i ] ; u = lca [ u ] [ i ] ; } } minWei = min ( minWei , min ( minWeight [ v ] [ 0 ] , minWeight [ u ] [ 0 ] ) ) ; maxWei = max ( maxWei , max ( maxWeight [ v ] [ 0 ] , maxWeight [ u ] [ 0 ] ) ) ; cout << minWei << " ▁ " << maxWei << endl ; } } int main ( ) { int n = 5 ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 5 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 3 ) ; weight [ 1 ] = -1 ; weight [ 2 ] = 5 ; weight [ 3 ] = -1 ; weight [ 4 ] = 3 ; weight [ 5 ] = -2 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < log ; j ++ ) { lca [ i ] [ j ] = -1 ; minWeight [ i ] [ j ] = INT_MAX ; maxWeight [ i ] [ j ] = INT_MIN ; } } dfs ( 1 , -1 , 0 ) ; findMinMaxWeight ( 1 , 3 ) ; findMinMaxWeight ( 2 , 4 ) ; findMinMaxWeight ( 3 , 5 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ; int findLCA ( int n1 , int n2 , int parent [ ] ) { vector < bool > visited ( MAX , false ) ; visited [ n1 ] = true ; while ( parent [ n1 ] != -1 ) { visited [ n1 ] = true ; n1 = parent [ n1 ] ; } visited [ n1 ] = true ; while ( ! visited [ n2 ] ) n2 = parent [ n2 ] ; return n2 ; } void insertAdj ( int parent [ ] , int i , int j ) { parent [ i ] = j ; } int main ( ) { int parent [ MAX ] ; parent [ 20 ] = -1 ; insertAdj ( parent , 8 , 20 ) ; insertAdj ( parent , 22 , 20 ) ; insertAdj ( parent , 4 , 8 ) ; insertAdj ( parent , 12 , 8 ) ; insertAdj ( parent , 10 , 12 ) ; insertAdj ( parent , 14 , 12 ) ; cout << findLCA ( 10 , 14 , parent ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; typedef long long int ll ; void solve ( int N , int M ) { ll ans = ( N ) * ( M / 2 ) ; if ( M % 2 == 1 ) { ans += ( N + 1 ) / 2 ; } cout << ans << endl ; } int main ( ) { int N , M ; N = 5 ; M = 3 ; solve ( N , M ) ; }
#include <bits/stdc++.h> NEW_LINE #define max_len  100005 NEW_LINE using namespace std ; int cnt [ max_len ] ; void precompute ( string s , string K ) { int n = s . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] + ( s . substr ( i , K . size ( ) ) == K ) ; } } int main ( ) { string s = " ABCABCABABC " ; string K = " ABC " ; precompute ( s , K ) ; vector < pair < int , int > > Q = { { 1 , 6 } , { 5 , 11 } } ; for ( auto it : Q ) { cout << cnt [ it . second - 1 ] - cnt [ it . first - 1 ] << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { cout << ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ; } int main ( ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; } int main ( ) { int n = 1884 ; cout << minSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int repeatingElement ( int arr [ ] , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = max ( M , arr [ i ] ) ; } int sum1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum1 ) / ( N - M ) ; return ans ; } int main ( ) { int arr [ ] = { 2 , 6 , 4 , 3 , 1 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << repeatingElement ( arr , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateMax ( int N , int M , int K ) { int ans = -1 ; int low = 0 , high = M ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int val = 0 ; int L = K - 1 ; int R = N - K ; val += mid ; if ( mid >= L ) { val += ( L ) * ( 2 * mid - L - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( L - mid ) ; } if ( mid >= R ) { val += ( R ) * ( 2 * mid - R - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( R - mid ) ; } if ( val <= M ) { ans = max ( ans , mid ) ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } int main ( ) { int N = 7 , M = 100 , K = 6 ; cout << calculateMax ( N , M , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_index ( int arr [ ] , int N ) { int max_value = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { max_value = max ( max_value , arr [ i ] ) ; } map < int , int > store ; for ( int i = 1 ; i <= max_value ; i ++ ) { store [ i ] ++ ; } if ( store . find ( 1 ) != store . end ( ) ) { store . erase ( 1 ) ; } for ( int i = 2 ; i <= sqrt ( max_value ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= max_value ) { if ( store . find ( i * multiple ) != store . end ( ) ) { store . erase ( i * multiple ) ; } multiple ++ ; } } int prime_sum_from_left = 0 ; int first_array [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { first_array [ i ] = prime_sum_from_left ; if ( store . find ( arr [ i ] ) != store . end ( ) ) { prime_sum_from_left += arr [ i ] ; } } int prime_sum_from_right = 0 ; int second_array [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { second_array [ i ] = prime_sum_from_right ; if ( store . find ( arr [ i ] ) != store . end ( ) ) { prime_sum_from_right += arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( first_array [ i ] == second_array [ i ] ) { return i ; } } return -1 ; } int main ( ) { int arr [ ] = { 11 , 4 , 7 , 6 , 13 , 1 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find_index ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCost ( int A [ ] , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findCost ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isGreaterEqual ( int N , int K , int X ) { return ( ( N * 1LL * ( N + 1 ) / 2 ) - ( ( K - 1 ) * 1LL * K / 2 ) ) >= X ; } void minimumNumber ( int K , int X ) { if ( K > X ) { cout << " - 1" ; return ; } int low = K , high = X , res = -1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( isGreaterEqual ( mid , K , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } cout << res ; } int main ( ) { int K = 5 , X = 13 ; minimumNumber ( K , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GetDiff ( int A [ ] , int N ) { int SuffMaxArr [ N ] ; SuffMaxArr [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; -- i ) { SuffMaxArr [ i ] = max ( SuffMaxArr [ i + 1 ] , A [ i + 1 ] ) ; } int MaximumSum = INT_MIN ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMaxArr [ i ] ) MaximumSum = max ( MaximumSum , A [ i ] + SuffMaxArr [ i ] ) ; } int MinimumSum = INT_MAX ; int SuffMinArr [ N ] ; SuffMinArr [ N - 1 ] = INT_MAX ; for ( int i = N - 2 ; i >= 0 ; -- i ) { SuffMinArr [ i ] = min ( SuffMinArr [ i + 1 ] , A [ i + 1 ] ) ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMinArr [ i ] ) { MinimumSum = min ( MinimumSum , A [ i ] + SuffMinArr [ i ] ) ; } } return abs ( MaximumSum - MinimumSum ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 3 , 7 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << GetDiff ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumOfDigits ( string s ) { int curr = 0 ; int ret = 0 ; for ( auto & ch : s ) { if ( isdigit ( ch ) ) { curr = curr * 10 + ch - '0' ; } else { ret += curr ; curr = 0 ; } } ret += curr ; return ret ; } int main ( ) { string S = "11aa32bbb5" ; cout << sumOfDigits ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumOperations ( int arr [ ] , int N ) { int oddCnt = 0 , evenCnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } cout << min ( oddCnt , evenCnt ) ; } int main ( ) { int arr [ ] = { 4 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minimumOperations ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int a [ ] , int n ) { bool flag = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = 1 ; } if ( flag ) return false ; else return true ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( check ( arr , N ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( string & S ) { int count = 0 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( S [ i ] != S [ i - 1 ] ) { count += 1 ; } } cout << count ; } int main ( ) { string S = "0101010101" ; minOperations ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberOfPairs ( int arr [ ] , int N ) { int set_bits [ 31 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; int bitpos = -1 ; while ( x > 0 ) { bitpos ++ ; x /= 2 ; } for ( int j = 0 ; j <= bitpos ; j ++ ) { count += set_bits [ j ] ; } set_bits [ bitpos ] ++ ; } cout << count ; } int main ( ) { int arr [ ] = { 4 , 16 , 8 , 64 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; numberOfPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximum ( int arr [ ] , int N , int Q , int queries [ ] [ 2 ] ) { int prefix_max [ N + 1 ] = { 0 } ; int suffix_max [ N + 1 ] = { 0 } ; prefix_max [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { prefix_max [ i ] = max ( prefix_max [ i - 1 ] , arr [ i ] ) ; } suffix_max [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffix_max [ i ] = max ( suffix_max [ i + 1 ] , arr [ i ] ) ; } for ( int i = 0 ; i < Q ; i ++ ) { int l = queries [ i ] [ 0 ] ; int r = queries [ i ] [ 1 ] ; if ( l == 0 && r == ( N - 1 ) ) cout << "0 STRNEWLINE " ; else if ( l == 0 ) cout << suffix_max [ r + 1 ] << " STRNEWLINE " ; else if ( r == ( N - 1 ) ) cout << prefix_max [ l - 1 ] << " STRNEWLINE " ; else cout << max ( prefix_max [ l - 1 ] , suffix_max [ r + 1 ] ) << " STRNEWLINE " ; } } int main ( ) { int arr [ ] = { 5 , 6 , 8 , 10 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int queries [ ] [ 2 ] = { { 0 , 1 } , { 0 , 2 } , { 1 , 4 } } ; int Q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; findMaximum ( arr , N , Q , queries ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string minEmail ( string email ) { string ans = " " ; int len = email . length ( ) ; ans += email [ 0 ] ; int i = 1 ; bool notAt = true ; while ( i < len ) { if ( i < len - 3 && notAt && email [ i ] == ' a ' && email [ i + 1 ] == ' t ' ) { ans += ' @ ' ; i += 1 ; notAt = false ; } else if ( i < len - 4 && email [ i ] == ' d ' && email [ i + 1 ] == ' o ' && email [ i + 2 ] == ' t ' ) { ans += ' . ' ; i += 2 ; } else { ans += email [ i ] ; } i += 1 ; } return ans ; } int main ( ) { string email = " geeksforgeeksatgmaildotcom " ; cout << ( minEmail ( email ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countRemainingElements ( int L1 [ ] , int L2 [ ] , int n ) { int one = 0 ; int zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L1 [ i ] == 1 ) one ++ ; else zero ++ ; } int ans = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( L2 [ i ] == 1 ) { one -- ; if ( one < 0 ) { ans = i ; break ; } } else { zero -- ; if ( zero < 0 ) { ans = i ; break ; } } } cout << n - ans ; } int main ( ) { int L1 [ ] = { 1 , 1 , 0 , 0 } ; int L2 [ ] = { 0 , 0 , 0 , 1 } ; int N = sizeof ( L1 ) / sizeof ( L1 [ 0 ] ) ; countRemainingElements ( L1 , L2 , N ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int LCM ( int A , int B ) { return ( A * B / __gcd ( A , B ) ) ; } int findSmallestNumber ( int X ) { int lcm = 1 ; int temp = X ; while ( temp ) { int last = temp % 10 ; temp /= 10 ; if ( ! last ) continue ; lcm = LCM ( lcm , last ) ; } int answer = ( ( X + lcm - 1 ) / lcm ) * lcm ; cout << answer ; } int main ( ) { int X = 280 ; findSmallestNumber ( X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNonMultiples ( int arr [ ] , int n , int k ) { set < int > multiples ; for ( int i = 0 ; i < n ; ++ i ) { if ( multiples . find ( arr [ i ] ) == multiples . end ( ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . insert ( arr [ i ] * j ) ; } } } return k - multiples . size ( ) ; } int countValues ( int arr [ ] , int N , int L , int R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 1 , R = 20 ; cout << countValues ( arr , N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCntTriplet ( int N ) { int cntTriplet = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += N / i ; } else { cntTriplet += ( N / i ) - 1 ; } } return cntTriplet ; } int main ( ) { int N = 3 ; cout << findCntTriplet ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCollectingSpeed ( vector < int > & piles , int H ) { int ans = -1 ; int low = 1 , high ; high = * max_element ( piles . begin ( ) , piles . end ( ) ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } cout << ans ; } int main ( ) { vector < int > arr = { 3 , 6 , 7 , 11 } ; int H = 8 ; minCollectingSpeed ( arr , H ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubArraySignChange ( int arr [ ] , int N ) { unordered_map < int , int > prefixCount ; unordered_map < int , int > suffixCount ; int total = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total += arr [ i ] ; suffixCount [ arr [ i ] ] ++ ; } int prefixSum = 0 ; int suffixSum = 0 ; int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixSum += arr [ i ] ; prefixCount [ arr [ i ] ] ++ ; suffixSum = total - prefixSum ; suffixCount [ arr [ i ] ] -- ; int diff = prefixSum - suffixSum ; if ( diff % 2 == 0 ) { int x = prefixCount + suffixCount [ - diff / 2 ] ; count = count + x ; } } return count ; } int main ( ) { int arr [ ] = { 2 , 2 , -3 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubArraySignChange ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countCommonChar ( int ind , string & S ) { int cnt = 0 ; set < char > ls ; set < char > rs ; for ( int i = 0 ; i < ind ; ++ i ) { ls . insert ( S [ i ] ) ; } for ( int i = ind ; i < S . length ( ) ; ++ i ) { rs . insert ( S [ i ] ) ; } for ( auto v : ls ) { if ( rs . count ( v ) ) { ++ cnt ; } } return cnt ; } void partitionStringWithMaxCom ( string & S ) { int ans = 0 ; for ( int i = 1 ; i < S . length ( ) ; ++ i ) { ans = max ( ans , countCommonChar ( i , S ) ) ; } cout << ans << " STRNEWLINE " ; } int main ( ) { string str = " aabbca " ; partitionStringWithMaxCom ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string SmallestString ( string s , char c ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] > c ) { s . insert ( i , 1 , c ) ; return s ; } } s += c ; return s ; } int main ( ) { string S = " acd " ; char C = ' b ' ; cout << SmallestString ( S , C ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long ll ; ll sumOfPathNodes ( ll N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 N == 3 ) { return N + 1 ; } vector < ll > arr ; arr . push_back ( 1 ) ; ll k = 1 ; bool flag = true ; while ( k < N ) { if ( flag == true ) { k *= 2 ; flag = false ; } else { k *= 4 ; flag = true ; } if ( k > N ) { break ; } arr . push_back ( k ) ; } ll len = arr . size ( ) ; vector < ll > prefix ( len ) ; prefix [ 0 ] = 1 ; for ( ll i = 1 ; i < len ; ++ i ) { prefix [ i ] = arr [ i ] + prefix [ i - 1 ] ; } vector < ll > :: iterator it = lower_bound ( prefix . begin ( ) , prefix . end ( ) , N ) ; ll ind = it - prefix . begin ( ) ; ll final_ans = 0 ; ll temp = N ; while ( ind > 1 ) { ll val = temp - prefix [ ind - 1 ] ; if ( ind % 2 != 0 ) { temp = prefix [ ind - 2 ] + ( val + 1 ) / 2 ; } else { temp = prefix [ ind - 2 ] + ( val + 3 ) / 4 ; } -- ind ; final_ans += temp ; } final_ans += ( N + 1 ) ; return final_ans ; } int main ( ) { ll N = 13 ; cout << sumOfPathNodes ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrangeArray ( int a [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } if ( sum == 0 ) { cout << " - 1" ; return ; } sum = 0 ; int b = 0 ; sort ( a , a + N ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( sum == 0 ) { if ( a [ i ] != a [ N - 1 ] ) { sum -= a [ i ] ; swap ( a [ i ] , a [ N - 1 ] ) ; sum += a [ i ] ; } else { b = 1 ; break ; } } } if ( b == 1 ) { b = 0 ; sum = 0 ; sort ( a , a + N , greater < int > ( ) ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { sum += a [ i ] ; if ( sum == 0 ) { if ( a [ i ] != a [ 0 ] ) { sum -= a [ i ] ; swap ( a [ i ] , a [ 0 ] ) ; sum += a [ i ] ; } else { b = 1 ; break ; } } } } if ( b == 1 ) { cout << " - 1" ; return ; } for ( int i = 0 ; i < N ; i ++ ) { cout << a [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , -1 , 2 , 4 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrangeArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinimumOperations ( string a , string b ) { int step = 0 ; int last_index ; while ( a != b ) { for ( int i = 0 ; i < a . length ( ) ; i ++ ) { if ( a [ i ] != b [ i ] ) { last_index = i ; } } for ( int i = 0 ; i <= last_index ; i ++ ) { a [ i ] = ( a [ i ] == '0' ) ? '1' : '0' ; } step ++ ; } cout << step ; } int main ( ) { string A = "101010" , B = "110011" ; findMinimumOperations ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int num ) { if ( num <= 1 ) return false ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( num % i == 0 ) return false ; return true ; } bool isFulPrime ( int n ) { if ( ! isPrime ( n ) ) return false ; else { while ( n > 0 ) { int rem = n % 10 ; if ( ! ( rem == 2 rem == 3 rem == 5 rem == 7 ) ) return false ; n = n / 10 ; } } return true ; } int countFulPrime ( int L , int R ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( ( i % 2 ) != 0 && isFulPrime ( i ) ) { cnt ++ ; } } return cnt ; } int main ( ) { int L = 1 , R = 100 ; int ans = 0 ; if ( L < 3 ) ans ++ ; cout << ans + countFulPrime ( L , R ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; bool is_prime ( int n ) { if ( n <= 1 ) return 0 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return 0 ; } return 1 ; } void countSmallerPrimes ( int ar [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( ar [ j ] <= ar [ i ] && is_prime ( ar [ j ] ) ) { count ++ ; } } cout << count << " ▁ " ; } } int main ( ) { int ar [ ] = { 43 , 3 , 5 , 7 , 2 , 41 } ; int N = sizeof ar / sizeof ar [ 0 ] ; countSmallerPrimes ( ar , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minLength ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; } int main ( ) { int arr [ ] = { 2 , 1 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minLength ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numSpecial ( vector < vector < int > > & mat ) { int m = mat . size ( ) , n = mat [ 0 ] . size ( ) ; int rows [ m ] ; int cols [ n ] ; int i , j ; for ( i = 0 ; i < m ; i ++ ) { rows [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) rows [ i ] += mat [ i ] [ j ] ; } for ( i = 0 ; i < n ; i ++ ) { cols [ i ] = 0 ; for ( j = 0 ; j < m ; j ++ ) cols [ i ] += mat [ j ] [ i ] ; } int cnt = 0 ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 && rows [ i ] == 1 && cols [ j ] == 1 ) cnt ++ ; } } return cnt ; } int main ( ) { vector < vector < int > > mat = { { 1 , 0 , 0 } , { 0 , 0 , 1 } , { 0 , 0 , 0 } } ; cout << numSpecial ( mat ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > minmaxNumbers ( vector < vector < int > > & matrix , vector < int > & res ) { unordered_set < int > set ; for ( int i = 0 ; i < matrix . size ( ) ; i ++ ) { int minr = INT_MAX ; for ( int j = 0 ; j < matrix [ i ] . size ( ) ; j ++ ) { minr = min ( minr , matrix [ i ] [ j ] ) ; } set . insert ( minr ) ; } for ( int j = 0 ; j < matrix [ 0 ] . size ( ) ; j ++ ) { int maxc = INT_MIN ; for ( int i = 0 ; i < matrix . size ( ) ; i ++ ) { maxc = max ( maxc , matrix [ i ] [ j ] ) ; } if ( set . find ( maxc ) != set . end ( ) ) { res . push_back ( maxc ) ; } } return res ; } int main ( ) { vector < vector < int > > mat = { { 1 , 10 , 4 } , { 9 , 3 , 8 } , { 15 , 16 , 17 } } ; vector < int > ans ; minmaxNumbers ( mat , ans ) ; if ( ans . size ( ) == 0 ) cout << " - 1" << endl ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPrecedingK ( int a [ ] , int n , int K ) { int prefix [ n ] ; prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } int ctr = 0 ; if ( prefix [ K - 1 ] < a [ K ] ) ctr ++ ; for ( int i = K + 1 ; i < n ; i ++ ) { if ( prefix [ i - 1 ] - prefix [ i - K - 1 ] < a [ i ] ) ctr ++ ; } return ctr ; } int main ( ) { int arr [ ] = { 2 , 3 , 8 , 10 , -2 , 7 , 5 , 5 , 9 , 15 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << countPrecedingK ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000 NEW_LINE int countNum ( int N , int sum , int K , bool st , int dp [ M ] [ M ] [ 2 ] ) { if ( N == 0 and sum == 0 ) { return 1 ; } if ( N < 0 ) { return 0 ; } if ( dp [ N ] [ sum ] [ st ] != -1 ) { return dp [ N ] [ sum ] [ st ] ; } int res = 0 ; int start = st == 1 ? 0 : 1 ; for ( int i = start ; i <= 9 ; i ++ ) { res += countNum ( N - 1 , ( sum + i ) % K , K , ( st i > 0 ) , dp ) ; } return dp [ N ] [ sum ] [ st ] = res ; } int main ( ) { int N = 2 , K = 7 ; int dp [ M ] [ M ] [ 2 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << countNum ( N , 0 , K , 0 , dp ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDeletion ( string str ) { int n = str . length ( ) ; int firstIdx1 = -1 ; int lastIdx0 = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { firstIdx1 = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) { lastIdx0 = i ; break ; } } if ( firstIdx1 == -1 lastIdx0 == -1 ) return 0 ; int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < lastIdx0 ; i ++ ) { if ( str [ i ] == '1' ) { count1 ++ ; } } for ( int i = firstIdx1 + 1 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { count0 ++ ; } } return min ( count0 , count1 ) ; } int main ( ) { string str = "1000101" ; cout << minDeletion ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_substring ( string s ) { int n = s . size ( ) ; string str = " " ; vector < int > ans ; if ( n == 0 ) { cout << " - 1" ; return ; } vector < int > last_pos ( 26 , -1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s [ i ] - ' a ' ] == -1 ) { last_pos [ s [ i ] - ' a ' ] = i ; } } int minp = -1 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_pos [ s [ i ] - ' a ' ] ; minp = max ( minp , lp ) ; if ( i == minp ) { str += s [ i ] ; cout << str << ' ▁ ' ; minp = -1 ; str = " " ; } else { str += s [ i ] ; } } } int main ( ) { string S = " ababcbacadefegdehijhklij " ; print_substring ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void partitionString ( string s ) { int n = s . size ( ) ; vector < int > ans ; if ( n == 0 ) { cout << " - 1" ; return ; } vector < int > last_pos ( 26 , -1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s [ i ] - ' a ' ] == -1 ) { last_pos [ s [ i ] - ' a ' ] = i ; } } int minp = -1 , plen = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_pos [ s [ i ] - ' a ' ] ; minp = max ( minp , lp ) ; ++ plen ; if ( i == minp ) { ans . push_back ( plen ) ; minp = -1 ; plen = 0 ; } } for ( int i = 0 ; i < ( int ) ans . size ( ) ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } int main ( ) { string str = " acbbcc " ; partitionString ( str ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int check ( string & s , int k ) { int n = s . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s [ i ] != s [ j ] ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } int main ( ) { string s = "101010" ; int k = 2 ; if ( check ( s , k ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxGCD ( int n ) { int maxHcf = INT_MIN ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { maxHcf = max ( maxHcf , __gcd ( i , j ) ) ; } } return maxHcf ; } int main ( ) { int n = 4 ; cout << maxGCD ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define eps  1e-6 NEW_LINE double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; } double findRoot ( double a , double b , double c , double low , double high ) { double x ; while ( fabs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; } void solve ( double a , double b , double c , double A , double B ) { if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { cout << " No ▁ solution " ; } else { cout << fixed << setprecision ( 4 ) << findRoot ( a , b , c , A , B ) ; } } int main ( ) { double a = 2 , b = -3 , c = -2 , A = 0 , B = 3 ; solve ( a , b , c , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findSubarrays ( vector < int > & a ) { int n = a . size ( ) ; vector < int > freq ( n + 1 ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { if ( count == 0 ) continue ; else { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } count = 0 ; } } else count ++ ; } if ( count > 0 ) { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } } return freq ; } void countRectangles ( vector < int > & a , vector < int > & b , int K ) { int n = a . size ( ) ; int m = b . size ( ) ; vector < int > subA = findSubarrays ( a ) ; vector < int > subB = findSubarrays ( b ) ; int total = 0 ; for ( int i = 1 ; i < subA . size ( ) ; i ++ ) { if ( K % i == 0 and ( K / i ) <= m ) { total = total + subA [ i ] * subB [ K / i ] ; } } cout << total ; } int main ( ) { vector < int > a = { 0 , 0 , 1 , 1 } ; vector < int > b = { 1 , 0 , 1 } ; int K = 2 ; countRectangles ( a , b , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRes ( vector < int > & res ) { int n = res . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << res [ i ] << " ▁ " ; } } void printLBS ( int arr [ ] , int N ) { int lis [ N ] ; int lds [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { lis [ i ] = lds [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { if ( lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } } for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ j ] < arr [ i ] ) { if ( lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; } } } int MaxVal = arr [ 0 ] , inx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( MaxVal < lis [ i ] + lds [ i ] - 1 ) { MaxVal = lis [ i ] + lds [ i ] - 1 ; inx = i ; } } int ct1 = lis [ inx ] ; vector < int > res ; for ( int i = inx ; i >= 0 && ct1 > 0 ; i -- ) { if ( lis [ i ] == ct1 ) { res . push_back ( arr [ i ] ) ; ct1 -- ; } } reverse ( res . begin ( ) , res . end ( ) ) ; int ct2 = lds [ inx ] - 1 ; for ( int i = inx ; i < N && ct2 > 0 ; i ++ ) { if ( lds [ i ] == ct2 ) { res . push_back ( arr [ i ] ) ; ct2 -- ; } } printRes ( res ) ; } int main ( ) { int arr [ ] = { 80 , 60 , 30 , 40 , 20 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printLBS ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int n , int arr [ ] ) { int i , ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { int left = max ( i - 1 , 0 ) ; int right = min ( n - 1 , i + 1 ) ; while ( left >= 0 ) { if ( arr [ left ] > arr [ i ] ) { left ++ ; break ; } left -- ; } if ( left < 0 ) left ++ ; while ( right < n ) { if ( arr [ right ] > arr [ i ] ) { right -- ; break ; } right ++ ; } if ( right >= n ) right -- ; ans = 1 + right - left ; cout << ans << " ▁ " ; } } int main ( ) { int arr [ ] = { 4 , 2 , 1 } ; int n = sizeof arr / sizeof arr [ 0 ] ; solve ( n , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSum ( int BITree [ ] , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans += BITree [ index ] ; index -= index & ( - index ) ; } return ans ; } static void updateBIT ( int BITree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } } int * constructBITree ( int arr [ ] , int n ) { int * BITree = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) BITree [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) updateBIT ( BITree , n , i , arr [ i ] ) ; return BITree ; } int getLowerBound ( int BITree [ ] , int arr [ ] , int n , int k ) { int lb = -1 ; int l = 0 , r = n - 1 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( getSum ( BITree , mid ) >= k ) { r = mid - 1 ; lb = mid ; } else l = mid + 1 ; } return lb ; } void performQueries ( int A [ ] , int n , int q [ ] [ 3 ] ) { int * BITree = constructBITree ( A , n ) ; for ( int i = 0 ; i < sizeof ( q [ 0 ] ) / sizeof ( int ) ; i ++ ) { int id = q [ i ] [ 0 ] ; if ( id == 1 ) { int idx = q [ i ] [ 1 ] ; int val = q [ i ] [ 2 ] ; A [ idx ] += val ; updateBIT ( BITree , n , idx , val ) ; } else { int k = q [ i ] [ 1 ] ; int lb = getLowerBound ( BITree , A , n , k ) ; cout << lb << endl ; } } } int main ( ) { int A [ ] = { 1 , 2 , 3 , 5 , 8 } ; int n = sizeof ( A ) / sizeof ( int ) ; int q [ ] [ 3 ] = { { 1 , 0 , 2 } , { 2 , 5 , 0 } , { 1 , 3 , 5 } } ; performQueries ( A , n , q ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool ContinuousElements ( int a [ ] , int n ) { if ( n == 1 ) return false ; int curr = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { if ( curr == 1 ) return false ; else curr = 0 ; } curr ++ ; } if ( curr == 1 ) return false ; return true ; } int main ( ) { int a [ ] = { 1 , 1 , 2 , 2 , 1 , 3 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( ContinuousElements ( a , n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumCount ( int A [ ] , int B [ ] , int n ) { queue < int > q ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { s . insert ( B [ i ] ) ; q . push ( B [ i ] ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . find ( A [ i ] ) == s . end ( ) ) continue ; while ( ! q . empty ( ) && q . front ( ) != A [ i ] ) { s . erase ( q . front ( ) ) ; q . pop ( ) ; count ++ ; } if ( A [ i ] == q . front ( ) ) { q . pop ( ) ; s . erase ( A [ i ] ) ; } if ( q . empty ( ) ) break ; } cout << count << endl ; } int main ( ) { int N = 4 ; int A [ ] = { 1 , 2 , 3 , 4 } ; int B [ ] = { 1 , 2 , 4 , 3 } ; maximumCount ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_elements ( int arr [ ] , int n ) { int count = 1 ; int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; } int main ( ) { int arr [ ] = { 2 , 1 , 4 , 6 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( count_elements ( arr , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubset ( int * a , int n ) { int sum = 0 ; int cnt = 0 ; vector < int > v ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i - 1 ] - i <= 0 ) { sum += a [ i - 1 ] - i ; cnt += 1 ; } else { v . push_back ( a [ i - 1 ] - i ) ; } } sort ( v . begin ( ) , v . end ( ) ) ; int ptr = 0 ; while ( ptr < v . size ( ) && sum + v [ ptr ] <= 0 ) { cnt += 1 ; ptr += 1 ; sum += v [ ptr ] ; } return cnt ; } int main ( ) { int arr [ ] = { 4 , 1 , 6 , 7 , 8 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSubset ( arr , n ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkArray ( int A [ ] , int B [ ] , int N ) { int start = 0 ; int end = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { start = i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != B [ i ] ) { end = i ; break ; } } reverse ( A + start , A + end + 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { cout << " No " << endl ; return ; } } cout << " Yes " << endl ; } int main ( ) { int A [ ] = { 1 , 3 , 2 , 4 } ; int B [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; checkArray ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int get_subset_count ( int arr [ ] , int K , int N ) { sort ( arr , arr + N ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << get_subset_count ( arr , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binary_searched_find_x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; } int main ( ) { int N = 100 ; cout << binary_searched_find_x ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lenOfLongZigZagArr ( int a [ ] , int n ) { int max = 1 , len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && ( a [ i ] < a [ i + 1 ] ) ) len ++ ; else if ( i % 2 == 1 && ( a [ i ] > a [ i + 1 ] ) ) len ++ ; else { if ( max < len ) max = len ; len = 1 ; } } if ( max < len ) max = len ; return max ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << lenOfLongZigZagArr ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int checkPerfectSquare ( long int N , long int start , long int last ) { long int mid = ( start + last ) / 2 ; if ( start > last ) { return -1 ; } if ( mid * mid == N ) { return mid ; } else if ( mid * mid > N ) { return checkPerfectSquare ( N , start , mid - 1 ) ; } else { return checkPerfectSquare ( N , mid + 1 , last ) ; } } int main ( ) { long int N = 65 ; cout << checkPerfectSquare ( N , 1 , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubArray ( int * a , int n , int k ) { int pref [ n ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i < n - 1 ; ++ i ) { pref [ i ] = pref [ i - 1 ] ; if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) pref [ i ] ++ ; } int peak = 0 , left = 0 ; for ( int i = 0 ; i + k - 1 < n ; ++ i ) if ( pref [ i + k - 2 ] - pref [ i ] > peak ) { peak = pref [ i + k - 2 ] - pref [ i ] ; left = i ; } cout << " Left ▁ = ▁ " << left + 1 << endl ; cout << " Right ▁ = ▁ " << left + k << endl ; cout << " Peak ▁ = ▁ " << peak << endl ; } int main ( ) { int arr [ ] = { 3 , 2 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; findSubArray ( arr , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void FindRank ( int arr [ ] , int length ) { cout << "1" << " ▁ " ; for ( int i = 1 ; i < length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } cout << rank << " ▁ " ; } } int main ( ) { int arr [ ] = { 88 , 14 , 69 , 30 , 29 , 89 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; FindRank ( arr , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000005 ; int fibUpto [ MAX + 1 ] ; void compute ( int sz ) { bool isFib [ sz + 1 ] ; memset ( isFib , false , sizeof ( isFib ) ) ; int prev = 0 , curr = 1 ; isFib [ prev ] = isFib [ curr ] = true ; while ( curr <= sz ) { int temp = curr + prev ; isFib [ temp ] = true ; prev = curr ; curr = temp ; } fibUpto [ 0 ] = 1 ; for ( int i = 1 ; i <= sz ; i ++ ) { fibUpto [ i ] = fibUpto [ i - 1 ] ; if ( isFib [ i ] ) fibUpto [ i ] ++ ; } } int countOfNumbers ( int N , int K ) { compute ( N ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - fibUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans ? N - ans + 1 : 0 ) ; } int main ( ) { int N = 10 , K = 3 ; cout << countOfNumbers ( N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE vector < int > findCount ( string a [ ] , string b [ ] , int n , int m ) { int freq [ MAX ] = { 0 } ; vector < int > smallestFreq ; for ( int i = 0 ; i < n ; i ++ ) { string s = a [ i ] ; memset ( freq , 0 , sizeof freq ) ; for ( int j = 0 ; j < s . size ( ) ; j ++ ) { freq [ s [ j ] - ' a ' ] ++ ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] ) { smallestFreq . push_back ( freq [ j ] ) ; break ; } } } sort ( smallestFreq . begin ( ) , smallestFreq . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < m ; i ++ ) { string s = b [ i ] ; memset ( freq , 0 , sizeof freq ) ; for ( int j = 0 ; j < s . size ( ) ; j ++ ) { freq [ s [ j ] - ' a ' ] ++ ; } int frequency = 0 ; for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] ) { frequency = freq [ j ] ; break ; } } int ind = lower_bound ( smallestFreq . begin ( ) , smallestFreq . end ( ) , frequency ) - smallestFreq . begin ( ) ; ans . push_back ( ind ) ; } return ans ; } void printAnswer ( string a [ ] , string b [ ] , int n , int m ) { vector < int > ans = findCount ( a , b , n , m ) ; for ( auto it : ans ) { cout << it << " ▁ " ; } } int main ( ) { string A [ ] = { " aaa " , " aa " , " bdc " } ; string B [ ] = { " cccch " , " cccd " } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int m = sizeof ( B ) / sizeof ( B [ 0 ] ) ; printAnswer ( A , B , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countLessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; } int countGreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = -1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == -1 ) return 0 ; return ( n - index ) ; } int countTriplets ( int n , int * a , int * b , int * c ) { sort ( a , a + n ) ; sort ( b , b + n ) ; sort ( c , c + n ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int a_index = -1 , c_index = -1 ; int low = countLessThan ( a , n , current ) ; int high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; } int main ( ) { int a [ ] = { 1 , 5 } ; int b [ ] = { 2 , 4 } ; int c [ ] = { 3 , 6 } ; int size = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countTriplets ( size , a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE int divisorcount ( int elem ) { int ans = 0 ; for ( int i = 1 ; i <= sqrt ( elem ) ; i ++ ) { if ( elem % i == 0 ) { if ( i * i == elem ) ans ++ ; else ans += 2 ; } } return ans ; } string findwinner ( int A [ ] , int B [ ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = divisorcount ( A [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { B [ i ] = divisorcount ( B [ i ] ) ; } sort ( A , A + N ) ; sort ( B , B + M ) ; int winA = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = A [ i ] ; int start = 0 ; int end = M - 1 ; int index = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( B [ mid ] <= val ) { index = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } winA += ( index + 1 ) ; } int winB = N * M - winA ; if ( winA > winB ) { return " A " ; } else if ( winB > winA ) { return " B " ; } return " Draw " ; } int main ( ) { int A [ ] = { 4 , 12 , 24 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int B [ ] = { 25 , 28 , 13 , 45 } ; int M = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << findwinner ( A , B , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int arr [ ] , int n , int dist , int k ) { int req = 0 ; int curr = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) curr ++ ; req ++ ; if ( curr == n ) break ; prev = curr - 1 ; } if ( curr != n ) return false ; if ( req <= k ) return true ; return false ; } int minDistance ( int arr [ ] , int n , int k ) { int l = 0 ; int h = arr [ n - 1 ] ; int ans = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( isPossible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else l = m + 1 ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 15 , 36 , 43 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 2 ; cout << minDistance ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countFactor ( int P , int X ) { if ( X < P ) return 0 ; return ( X / P + countFactor ( P , X / P ) ) ; } int findSmallestX ( int Y ) { int low = 0 , high = 5 * Y ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( countFactor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; } int main ( ) { int Y = 10 ; cout << findSmallestX ( Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime [ 1000000 + 5 ] ; void findPrime ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= 1000000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= 1000000 ; i += p ) prime [ i ] = false ; } } } int lenOfLongSubarr ( int arr [ ] , int n ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += prime [ arr [ i ] ] == 0 ? -1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - 1 ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - 1 ] ) ) maxLen = i - um [ sum - 1 ] ; } } return maxLen ; } int main ( ) { findPrime ( ) ; int arr [ ] = { 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << lenOfLongSubarr ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canBeOptimalValue ( int K , int arr [ ] , int N , int B , int & value ) { int tmp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) tmp [ i ] = ( arr [ i ] + K * ( i + 1 ) ) ; sort ( tmp , tmp + N ) ; value = 0 ; for ( int i = 0 ; i < K ; i ++ ) value += tmp [ i ] ; return value <= B ; } void findNoOfElementsandValue ( int arr [ ] , int N , int B ) { int ans = 0 ; int cumulativeValue = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( canBeOptimalValue ( mid , arr , N , B , cumulativeValue ) ) { ans = mid ; start = mid + 1 ; } else end = mid - 1 ; } canBeOptimalValue ( ans , arr , N , B , cumulativeValue ) ; cout << ans << " ▁ " << cumulativeValue << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 6 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int B = 90 ; findNoOfElementsandValue ( arr , N , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexiMiddleSmallest ( int K , int N ) { if ( K % 2 == 0 ) { cout << K / 2 << " ▁ " ; for ( int i = 0 ; i < N - 1 ; ++ i ) { cout << K << " ▁ " ; } cout << " STRNEWLINE " ; exit ( 0 ) ; } vector < int > a ( N , ( K + 1 ) / 2 ) ; for ( int i = 0 ; i < N / 2 ; ++ i ) { if ( a . back ( ) == 1 ) { a . pop_back ( ) ; } else { -- a . back ( ) ; while ( ( int ) a . size ( ) < N ) { a . push_back ( K ) ; } } } for ( auto i : a ) { cout << i << " ▁ " ; } cout << " STRNEWLINE " ; } int main ( ) { int K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPair ( pair < int , int > * arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int a = arr [ i ] . first , b = arr [ i ] . second ; for ( int j = i + 1 ; j < N ; j ++ ) { int c = arr [ j ] . first , d = arr [ j ] . second ; if ( a < c && b > d ) { cout << " ( " << a << " ▁ " << b << " ) , ▁ ( " << c << " ▁ " << d << " ) STRNEWLINE " ; return ; } } } cout << " NO ▁ SUCH ▁ PAIR ▁ EXIST STRNEWLINE " ; } int main ( ) { pair < int , int > arr [ ] = { { 3 , 7 } , { 21 , 23 } , { 4 , 13 } , { 1 , 2 } , { 7 , -1 } } ; findPair ( arr , 5 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCostToRemove ( int arr [ ] , int N , int K ) { int maxCost = 0 ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i += K ) { maxCost += arr [ i + 1 ] ; } return maxCost ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 1 , 5 , 1 , 5 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; cout << maxCostToRemove ( arr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIfPossibleMerge ( int A [ ] , int B [ ] , int N ) { int i = 0 ; int j = 0 ; int prev = -1 ; int flag = 1 ; while ( i < N && j < N ) { if ( A [ i ] < B [ j ] && prev != 0 ) { prev = 0 ; i ++ ; } else if ( B [ j ] < A [ i ] && prev != 1 ) { prev = 1 ; j ++ ; } else if ( A [ i ] == B [ j ] ) { if ( prev != 1 ) { prev = 1 ; j ++ ; } else { prev = 0 ; i ++ ; } } else { flag = 0 ; break ; } } return flag ; } int main ( ) { int A [ 3 ] = { 3 , 5 , 8 } ; int B [ 3 ] = { 2 , 4 , 6 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( checkIfPossibleMerge ( A , B , N ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int n , int a [ ] , int l [ ] [ 2 ] , int q ) { vector < int > v ; int d [ n ] = { 0 } ; for ( int i = 0 ; i < q ; i ++ ) { for ( int x = l [ i ] [ 0 ] ; x <= l [ i ] [ 1 ] ; x ++ ) { if ( d [ x ] == 0 ) { d [ x ] = 1 ; } } } set < int > st ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] == 0 ) { v . push_back ( a [ i ] ) ; st . insert ( i ) ; } } sort ( v . begin ( ) , v . end ( ) , greater < int > ( ) ) ; int c = 0 ; for ( auto it : st ) { a [ it ] = v ; c ++ ; } int pref_sum = 0 ; int temp_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp_sum += a [ i ] ; pref_sum += temp_sum ; } return pref_sum ; } int main ( ) { int arr [ ] = { -8 , 4 , -2 , -6 , 4 , 7 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int q [ ] [ 2 ] = { { 0 , 0 } , { 4 , 5 } } ; int queries = sizeof ( q ) / sizeof ( q [ 0 ] ) ; cout << maxSum ( N , arr , q , queries ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxRearrngeSum ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N , greater < int > ( ) ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxSum += abs ( A [ i ] - B [ i ] ) ; } return maxSum ; } int main ( ) { int A [ ] = { 1 , 2 , 2 , 4 , 5 } ; int B [ ] = { 5 , 5 , 5 , 6 , 6 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << MaxRearrngeSum ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minHeapify ( int brr [ ] , int i , int M ) { int left = 2 * i + 1 ; int right = 2 * i + 2 ; int smallest = i ; if ( left < M && brr [ left ] < brr [ smallest ] ) { smallest = left ; } if ( right < M && brr [ right ] < brr [ smallest ] ) { smallest = right ; } if ( smallest != i ) { swap ( brr [ i ] , brr [ smallest ] ) ; minHeapify ( brr , smallest , M ) ; } } void merge ( int arr [ ] , int brr [ ] , int N , int M ) { for ( int i = 0 ; i < N ; ++ i ) { if ( arr [ i ] > brr [ 0 ] ) { swap ( arr [ i ] , brr [ 0 ] ) ; minHeapify ( brr , 0 , M ) ; } } sort ( brr , brr + M ) ; } void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 2 , 23 , 35 , 235 , 2335 } ; int brr [ ] = { 3 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int M = sizeof ( brr ) / sizeof ( brr [ 0 ] ) ; merge ( arr , brr , N , M ) ; printArray ( arr , N ) ; printArray ( brr , M ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void maxArea ( int point_x [ ] , int point_y [ ] , int n , int length , int width ) { sort ( point_x , point_x + n ) ; sort ( point_y , point_y + n ) ; int dx = point_x [ 0 ] ; int dy = point_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = max ( dx , point_x [ i ] - point_x [ i - 1 ] ) ; dy = max ( dy , point_y [ i ] - point_y [ i - 1 ] ) ; } dx = max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) ; dy = max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) ; cout << ( dx - 1 ) * ( dy - 1 ) ; cout << endl ; } int main ( ) { int length = 15 , width = 8 ; int n = 3 ; int point_x [ ] = { 3 , 11 , 8 } ; int point_y [ ] = { 8 , 2 , 6 } ; maxArea ( point_x , point_y , n , length , width ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; ll findMaxValue ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; ll ans = arr [ n - 1 ] ; ll maxPossible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; } int main ( ) { int arr [ ] = { 4 , 4 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValue ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lexNumbers ( int n ) { vector < string > s ; for ( int i = 1 ; i <= n ; i ++ ) { s . push_back ( to_string ( i ) ) ; } sort ( s . begin ( ) , s . end ( ) ) ; vector < int > ans ; for ( int i = 0 ; i < n ; i ++ ) ans . push_back ( stoi ( s [ i ] ) ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { int n = 15 ; lexNumbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortedAdjacentDifferences ( int arr [ ] , int n ) { int ans [ n ] ; sort ( arr + 0 , arr + n ) ; int l = 0 , r = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) { ans [ i ] = arr [ l ] ; l ++ ; } else { ans [ i ] = arr [ r ] ; r -- ; } } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 5 , -2 , 4 , 8 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortedAdjacentDifferences ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsAP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; double d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != d ) { return false ; } } return true ; } bool checkIsGP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; sort ( arr , arr + n ) ; double r = arr [ 1 ] / arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] / arr [ i - 1 ] != r ) return false ; } return true ; } bool checkIsHP ( double arr [ ] , int n ) { if ( n == 1 ) { return true ; } double rec [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { rec [ i ] = ( ( 1 / arr [ i ] ) ) ; } if ( checkIsAP ( rec , n ) ) return true ; else return false ; } int main ( ) { double arr [ ] = { 1.0 / 5.0 , 1.0 / 10.0 , 1.0 / 15.0 , 1.0 / 20.0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int flag = 0 ; if ( checkIsAP ( arr , n ) ) { cout << " Yes , ▁ An ▁ AP ▁ can ▁ be ▁ formed " << endl ; flag = 1 ; } if ( checkIsGP ( arr , n ) ) { cout << " Yes , ▁ A ▁ GP ▁ can ▁ be ▁ formed " << endl ; flag = 1 ; } if ( checkIsHP ( arr , n ) ) { cout << " Yes , ▁ A ▁ HP ▁ can ▁ be ▁ formed " << endl ; flag = 1 ; } else if ( flag == 0 ) { cout << " No " ; } return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int sortByFreq ( int * arr , int n ) { int maxE = -1 ; for ( int i = 0 ; i < n ; i ++ ) { maxE = max ( maxE , arr [ i ] ) ; } int freq [ maxE + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i <= maxE ; i ++ ) { if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; } void printSortedArray ( int * arr , int cnt ) { for ( int i = 0 ; i < cnt ; i ++ ) { int frequency = arr [ i ] / 100000 ; int value = 100000 - ( arr [ i ] % 100000 ) ; for ( int j = 0 ; j < frequency ; j ++ ) { cout << value << ' ▁ ' ; } } } int main ( ) { int arr [ ] = { 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int cnt = sortByFreq ( arr , n ) ; sort ( arr , arr + cnt , greater < int > ( ) ) ; printSortedArray ( arr , cnt ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxMod ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; } int main ( ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxMod ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; sort ( A , A + n ) ; sort ( B , B + m ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } int main ( ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = sizeof ( A ) / sizeof ( int ) ; int m = sizeof ( B ) / sizeof ( int ) ; int x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getNumber ( int n , int k ) { int arr [ n ] ; int i = 0 ; int odd = 1 ; while ( odd <= n ) { arr [ i ++ ] = odd ; odd += 2 ; } int even = 2 ; while ( even <= n ) { arr [ i ++ ] = even ; even += 2 ; } return arr [ k - 1 ] ; } int main ( ) { int n = 8 , k = 5 ; cout << getNumber ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE int Min_Replace ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int freq [ MAX ] ; memset ( freq , 0 , sizeof freq ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } sort ( freq , freq + n , greater < int > ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << Min_Replace ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; } int main ( ) { int x [ ] = { 1 , 3 , 4 , 5 , 8 } , l [ ] = { 10 , 1 , 2 , 2 , 5 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; cout << Segment ( x , l , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArrangement ( int a [ ] , int n ) { sort ( a , a + n ) ; int b [ n ] ; int low = 0 , high = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) b [ low ++ ] = a [ i ] ; else b [ high -- ] = a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( b [ n - 1 ] + b [ 1 ] <= b [ i ] ) { cout << -1 ; return ; } } else if ( i == ( n - 1 ) ) { if ( b [ n - 2 ] + b [ 0 ] <= b [ i ] ) { cout << -1 ; return ; } } else { if ( b [ i - 1 ] + b [ i + 1 ] <= b [ i ] ) { cout << -1 ; return ; } } } for ( int i = 0 ; i < n ; i ++ ) cout << b [ i ] << " ▁ " ; } int main ( ) { int a [ ] = { 1 , 4 , 4 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printArrangement ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  2 NEW_LINE #define M  2 NEW_LINE bool isMatrixInc ( int a [ N ] [ M ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i - 1 >= 0 ) { if ( a [ i ] [ j ] <= a [ i - 1 ] [ j ] ) return false ; } if ( j - 1 >= 0 ) { if ( a [ i ] [ j ] <= a [ i ] [ j - 1 ] ) return false ; } } } return true ; } int main ( ) { int a [ N ] [ M ] = { { 2 , 10 } , { 11 , 20 } } ; if ( isMatrixInc ( a ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1e7 + 5 ; bool prime [ N ] ; void seive ( ) { for ( int i = 2 ; i < N ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = i + i ; j < N ; j += i ) { prime [ j ] = 1 ; } } } prime [ 1 ] = 1 ; } int maxSizeArr ( int * arr , int n , int k ) { vector < int > v , diff ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) v . push_back ( i ) ; } for ( int i = 1 ; i < v . size ( ) ; i ++ ) { diff . push_back ( v [ i ] - v [ i - 1 ] - 1 ) ; } sort ( diff . begin ( ) , diff . end ( ) ) ; for ( int i = 1 ; i < diff . size ( ) ; i ++ ) { diff [ i ] += diff [ i - 1 ] ; } if ( k > n || ( k == 0 && v . size ( ) ) ) { return -1 ; } else if ( v . size ( ) <= k ) { return ( n - k ) ; } else if ( v . size ( ) > k ) { int tt = v . size ( ) - k ; int sum = 0 ; sum += diff [ tt - 1 ] ; int res = n - ( v . size ( ) + sum ) ; return res ; } } int main ( ) { seive ( ) ; int arr [ ] = { 2 , 4 , 2 , 2 , 4 , 2 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << maxSizeArr ( arr , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; bool sortList ( struct Node * head ) { int startVal = 1 ; while ( head != NULL ) { head -> data = startVal ; startVal ++ ; head = head -> next ; } } void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } } int main ( ) { struct Node * start = NULL ; push ( & start , 2 ) ; push ( & start , 1 ) ; push ( & start , 6 ) ; push ( & start , 4 ) ; push ( & start , 5 ) ; push ( & start , 3 ) ; sortList ( start ) ; printList ( start ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTripletsLessThan ( int arr [ ] , int n , int val ) { sort ( arr , arr + n ) ; int ans = 0 ; int j , k ; int sum ; for ( int i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; } int countTriplets ( int arr [ ] , int n , int a , int b ) { int res ; res = countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ; return res ; } int main ( ) { int arr [ ] = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int a = 8 , b = 16 ; cout << countTriplets ( arr , n , a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLevel ( int boxes [ ] , int n ) { sort ( boxes , boxes + n ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; } int main ( ) { int boxes [ ] = { 10 , 20 , 30 , 50 , 60 , 70 } ; int n = sizeof ( boxes ) / sizeof ( boxes [ 0 ] ) ; cout << maxLevel ( boxes , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; } int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; } int countSwaps ( int arr [ ] , int n ) { int temp [ n ] ; return _mergeSort ( arr , temp , 0 , n - 1 ) ; } int main ( int argv , char * * args ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Number ▁ of ▁ swaps ▁ is ▁ % d ▁ STRNEWLINE " , countSwaps ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSizeArray ( int S , int P ) { if ( S == P ) { return 1 ; } for ( int i = 2 ; i <= S ; i ++ ) { double d = i ; if ( ( S / d ) >= pow ( P , 1.0 / d ) ) { return i ; } } return -1 ; } int main ( ) { int S = 5 , P = 6 ; cout << minimumSizeArray ( S , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubseq ( int arr [ ] , int N , int K ) { int sum = 0 ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( K == 0 ) break ; if ( arr [ i ] < 0 ) { arr [ i ] = - arr [ i ] ; K -- ; } } for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] > 0 ) sum += arr [ i ] ; return sum ; } int main ( ) { int arr [ ] = { 6 , -10 , -1 , 0 , -4 , 2 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSubseq ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTheArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " ▁ " ; } void rearrange ( int arr [ ] , int N ) { if ( N & 1 ) N -- ; int odd_idx = 1 , even_idx = 0 ; int i , max_elem = arr [ N - 1 ] + 1 ; for ( i = 0 ; i < N / 2 ; i ++ ) { arr [ i ] += ( arr [ odd_idx ] % max_elem ) * max_elem ; odd_idx += 2 ; } for ( ; i < N ; i ++ ) { arr [ i ] += ( arr [ even_idx ] % max_elem ) * max_elem ; even_idx += 2 ; } for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] / max_elem ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 16 , 18 , 19 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrange ( arr , N ) ; printTheArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num ) { sm += num % 10 ; num /= 10 ; } int sm2 = 0 ; while ( num2 ) { sm2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm2 ) ; } int convert ( string s ) { int val = 0 ; reverse ( s . begin ( ) , s . end ( ) ) ; int cur = 1 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { val += ( s [ i ] - '0' ) * cur ; cur *= 10 ; } return val ; } void generate ( string s , int len , set < int > & uniq ) { if ( s . size ( ) == len ) { if ( check ( convert ( s ) ) ) { uniq . insert ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + char ( i + '0' ) , len , uniq ) ; } } int totalNumbers ( int L , int R ) { int ans = 0 ; int max_len = log10 ( R ) + 1 ; set < int > uniq ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( " " , i , uniq ) ; } for ( auto x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; } int main ( ) { int L = 22 , R = 22 ; cout << totalNumbers ( L , R ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countArrays ( int n , int k ) { vector < vector < int > > divisors ( k + 1 ) ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 2 * i ; j <= k ; j += i ) { divisors [ j ] . push_back ( i ) ; } } vector < vector < int > > dp ( n + 1 , vector < int > ( k + 1 ) ) ; for ( int j = 1 ; j <= k ; j ++ ) { dp [ 1 ] [ j ] = 1 ; } for ( int x = 2 ; x <= n ; x ++ ) { int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ x - 1 ] [ j ] ; } for ( int y = 1 ; y <= k ; y ++ ) { dp [ x ] [ y ] = sum ; for ( int d : divisors [ y ] ) { dp [ x ] [ y ] = ( dp [ x ] [ y ] - dp [ x - 1 ] [ d ] ) ; } } } int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ n ] [ j ] ; } return sum ; } int main ( ) { int N = 2 , K = 3 ; cout << countArrays ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximumPoints ( int N , int X [ ] , int H [ ] ) { int ans = 0 ; int prev = INT_MIN ; for ( int i = 0 ; i < N ; ++ i ) { if ( prev < ( X [ i ] - H [ i ] ) ) { ++ ans ; prev = X [ i ] ; } else if ( i == N - 1 || ( X [ i ] + H [ i ] ) < X [ i + 1 ] ) { ++ ans ; prev = X [ i ] + H [ i ] ; } else { prev = X [ i ] ; } } return ans ; } int main ( ) { int X [ ] = { 1 , 2 , 3 } ; int H [ ] = { 2 , 5 , 5 } ; int N = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << findMaximumPoints ( N , X , H ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void possibleNumbers ( set < int > & numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . insert ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; } int main ( ) { int N = 5 , M = 3 , A = 4 , B = 6 ; set < int > numbers ; possibleNumbers ( numbers , N , M , A , B ) ; for ( int x : numbers ) { cout << x << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reduceToOne ( long long int N ) { int cnt = 0 ; while ( N != 1 ) { if ( N == 2 or ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = N / ( N / 2 ) ; cnt ++ ; } } return cnt ; } int main ( ) { long long int N = 35 ; cout << reduceToOne ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int S , int K , int N ) { if ( K > N ) { cout << " - 1" << endl ; return ; } int max_sum = 0 , min_sum = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { min_sum += i ; max_sum += N - i + 1 ; } if ( S < min_sum S > max_sum ) { cout << " - 1" << endl ; return ; } int s1 = 0 ; vector < int > nums ; for ( int i = 1 ; i <= N ; i ++ ) { if ( s1 > S ) break ; s1 += i ; nums . push_back ( i ) ; } vector < int > answer ; int s2 = 0 ; for ( int i = 0 ; i < K - 1 ; i ++ ) { answer . push_back ( nums [ i ] ) ; s2 += nums [ i ] ; } answer . push_back ( S - s2 ) ; int Max = N ; for ( int i = answer . size ( ) - 1 ; i >= 0 ; i -- ) { if ( answer [ i ] > Max ) { int extra = answer [ i ] - Max ; if ( i - 1 >= 0 ) answer [ i - 1 ] += extra ; answer [ i ] = Max ; Max -- ; } else break ; } for ( auto x : answer ) cout << x << " ▁ " ; cout << endl ; } int main ( ) { int S = 15 , K = 4 , N = 8 ; solve ( S , K , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minSizeArr ( int A [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += A [ i ] ; if ( K > sum ) { cout << -1 ; return ; } if ( K == sum ) { for ( int i = 0 ; i < N ; i ++ ) { cout << A [ i ] << " ▁ " ; } return ; } int tar = sum - K ; unordered_map < int , int > um ; um [ 0 ] = -1 ; int left , right ; int cur = 0 , maxi = -1 ; for ( int i = 0 ; i < N ; i ++ ) { cur += A [ i ] ; if ( um . find ( cur - tar ) != um . end ( ) && i - um [ cur - tar ] > maxi ) { maxi = i - um [ cur - tar ] ; right = i ; left = um [ cur - tar ] ; } if ( um . find ( cur ) == um . end ( ) ) um [ cur ] = i ; } if ( maxi == -1 ) cout << -1 ; else { for ( int i = 0 ; i <= left ; i ++ ) cout << A [ i ] << " ▁ " ; for ( int i = 0 ; i < right ; i ++ ) cout << A [ N - i - 1 ] << " ▁ " ; } } int main ( ) { int N = 7 ; int A [ ] = { 3 , 2 , 1 , 1 , 1 , 1 , 3 } ; int K = 10 ; minSizeArr ( A , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findEquation ( int A , int B , int C , int K ) { cout << A << " ▁ " << K * B << " ▁ " << K * K * C ; } int main ( ) { int A = 1 , B = 2 , C = 1 , K = 2 ; findEquation ( A , B , C , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canArrayBeReduced ( int arr [ ] , int N ) { if ( N == 1 ) { cout << arr [ 0 ] ; return ; } if ( arr [ 0 ] < arr [ N - 1 ] ) { cout << arr [ N - 1 ] ; } else cout << " Not ▁ Possible " ; } int main ( ) { int arr [ ] = { 6 , 5 , 2 , 4 , 1 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; canArrayBeReduced ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArray ( int arr [ ] , int N ) { int brr [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int K = log ( arr [ i ] ) / log ( 2 ) ; int R = pow ( 2 , K ) ; brr [ i ] = R ; } for ( int i = 0 ; i < N ; i ++ ) { cout << brr [ i ] << " ▁ " ; } } int main ( ) { int arr [ ] = { 11 , 5 , 7 , 3 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; constructArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOpsToTurnArrToZero ( int arr [ ] , int N ) { unordered_set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . find ( arr [ i ] ) != st . end ( ) arr [ i ] == 0 ) { continue ; } else { st . insert ( arr [ i ] ) ; } } cout << st . size ( ) << endl ; } int main ( ) { int arr [ ] = { 3 , 7 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minOpsToTurnArrToZero ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool CheckAllEqual ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return false ; } } return true ; } int minCntOperations ( int arr [ ] , int N ) { int Max = * max_element ( arr , arr + N ) ; bool isPower2 = ! ( Max && ( Max & ( Max - 1 ) ) ) ; if ( isPower2 && CheckAllEqual ( arr , N ) ) { return log2 ( Max ) ; } else { return ceil ( log2 ( Max ) ) + 1 ; } } int main ( ) { int arr [ ] = { 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minCntOperations ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) { sort ( arr , arr + N ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = max ( res , sum ) ; } while ( next_permutation ( arr , arr + N ) ) ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValByRearrArr ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumzero ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 0 ) cout << " Yes " ; else if ( sum > 0 ) { if ( sum % K == 0 ) cout << " Yes " ; else cout << " No " ; } else cout << " No " ; return 0 ; } int main ( ) { int K , N ; int arr1 [ ] = { 1 , -6 , 2 , 2 } ; K = 1 ; N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; sumzero ( arr1 , N , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void path_to_root ( int node ) { while ( node >= 1 ) { cout << node << ' ▁ ' ; node /= 2 ; } } int main ( ) { int N = 7 ; path_to_root ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSmallestNumberPossible ( int N , int K ) { if ( N > 45 * K ) { cout << " - 1" ; return ; } string res = " " ; int count = 0 ; for ( int i = 9 ; i >= 1 ; ) { if ( count == K ) { i -- ; count = 0 ; } if ( N > i ) { N -= i ; res += ( char ) 48 + i ; } else { res += ( char ) N + 48 ; N = 0 ; break ; } count ++ ; } reverse ( res . begin ( ) , res . end ( ) ) ; cout << res ; } int main ( ) { int N = 25 , K = 3 ; findSmallestNumberPossible ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void result ( int n ) { if ( n > 45 ) { cout << -1 ; return ; } string res ; int digit = 9 ; while ( n > digit ) { res = char ( '0' + digit ) + res ; n -= digit ; digit -= 1 ; } if ( n > 0 ) { res = char ( '0' + n ) + res ; } cout << res ; } int main ( ) { int N = 19 ; result ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int aXORb , int aANDb , int aXORc , int aANDc , int bXORc , int bANDc ) { int a , b , c ; int aSUMb ; int aSUMc ; int bSUMc ; aSUMb = aXORb + aANDb * 2 ; aSUMc = aXORc + aANDc * 2 ; bSUMc = bXORc + bANDc * 2 ; a = ( aSUMb - bSUMc + aSUMc ) / 2 ; b = aSUMb - a ; c = aSUMc - a ; cout << " a ▁ = ▁ " << a ; cout << " , ▁ b ▁ = ▁ " << b ; cout << " , ▁ c ▁ = ▁ " << c ; } int main ( ) { int aXORb = 30 , aANDb = 0 , aXORc = 20 , aANDc = 10 , bXORc = 10 , bANDc = 20 ; findNumbers ( aXORb , aANDb , aXORc , aANDc , bXORc , bANDc ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumber ( int N ) { return N & ( N + 1 ) ; } int main ( ) { int N = 39 ; cout << findNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; } int main ( ) { int X = 5 , Y = 2 ; cout << findBitwiseORGivenXORAND ( X , Y ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperation ( int X [ ] , int Y [ ] , int n ) { int C = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; count = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; cout << C ; } int main ( ) { int X [ ] = { 1 , 0 , 0 , 0 , 0 , 1 } ; int Y [ ] = { 1 , 1 , 0 , 1 , 1 , 1 } ; int N = sizeof ( X ) / sizeof ( X [ 0 ] ) ; minOperation ( X , Y , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Remove_one_element ( int arr [ ] , int n ) { int post_odd = 0 , post_even = 0 ; int curr_odd = 0 , curr_even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; int X = curr_odd ^ post_even ; int Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } cout << res << endl ; } int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Remove_one_element ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minCost ( int arr [ ] , int arr_size ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } cout << min ( even , odd ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minCost ( arr , arr_size ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } int findPartition ( int nums [ ] , int N ) { int prefix [ N ] , suffix [ N ] , i , k ; prefix [ 0 ] = nums [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] * nums [ i ] ; } suffix [ N - 1 ] = nums [ N - 1 ] ; for ( i = N - 2 ; i >= 0 ; i -- ) { suffix [ i ] = suffix [ i + 1 ] * nums [ i ] ; } for ( k = 0 ; k < N - 1 ; k ++ ) { if ( GCD ( prefix [ k ] , suffix [ k + 1 ] ) == 1 ) { return k ; } } return -1 ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findPartition ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int palindromeMatrix ( int N , int M , vector < vector < int > > arr ) { int ans = 0 ; for ( int i = 0 ; i < ( N + 1 ) / 2 ; i ++ ) { for ( int j = 0 ; j < ( M + 1 ) / 2 ; j ++ ) { set < pair < int , int > > s ; s . insert ( { i , j } ) ; s . insert ( { i , M - j - 1 } ) ; s . insert ( { N - i - 1 , j } ) ; s . insert ( { N - i - 1 , M - j - 1 } ) ; vector < int > values ; for ( pair < int , int > p : s ) { values . push_back ( arr [ p . first ] [ p . second ] ) ; } int max = * max_element ( values . begin ( ) , values . end ( ) ) ; for ( int k = 0 ; k < values . size ( ) ; k ++ ) { ans += max - values [ k ] ; } } } cout << ans ; } int main ( ) { int N = 3 , M = 3 ; vector < vector < int > > arr = { { 1 , 2 , 1 } , { 3 , 4 , 1 } , { 1 , 2 , 1 } } ; palindromeMatrix ( N , M , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > rearrangeArray ( vector < int > & A , vector < int > & B , int N ) { map < int , int > m ; int xor_value = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xor_value ^= A [ i ] ; xor_value ^= B [ i ] ; m [ B [ i ] ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { B [ i ] = A [ i ] ^ xor_value ; if ( m [ B [ i ] ] ) { m [ B [ i ] ] -- ; } else return vector < int > { } ; } return B ; } void rearrangeArrayUtil ( vector < int > & A , vector < int > & B , int N ) { vector < int > ans = rearrangeArray ( A , B , N ) ; if ( ans . size ( ) ) { for ( auto x : ans ) { cout << x << " ▁ " ; } } else { cout << " - 1" ; } } int main ( ) { vector < int > A = { 13 , 21 , 33 , 49 , 53 } ; vector < int > B = { 54 , 50 , 34 , 22 , 14 } ; int N = ( int ) A . size ( ) ; rearrangeArrayUtil ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfSubarray ( int arr [ ] , int N ) { unordered_map < int , int > mp ; int answer = 0 ; int sum = 0 ; mp [ 1 ] ++ ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; answer += mp [ sum - i ] ; mp [ sum - i ] ++ ; } cout << answer ; } int main ( ) { int arr [ ] = { 1 , 0 , 2 , 1 , 2 , -2 , 2 , 4 } ; int N = sizeof arr / sizeof arr [ 0 ] ; countOfSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } void countInverse ( int arr [ ] , int N , int M ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int gcdOfMandelement = gcd ( M , arr [ i ] ) ; if ( gcdOfMandelement == 1 ) { XOR ^= arr [ i ] ; } } cout << XOR << ' ▁ ' ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int M = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countInverse ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int TotalXorPair ( int arr [ ] , int N ) { int totalXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << TotalXorPair ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void possibleAcyclicGraph ( int N ) { cout << pow ( 2 , N - 1 ) ; return ; } int main ( ) { int N = 4 ; possibleAcyclicGraph ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isComposite ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return true ; } } return false ; } int compositePair ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int prod = arr [ i ] * arr [ j ] ; if ( isComposite ( prod ) ) { res ++ ; } } } return res ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 2 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << compositePair ( arr , N ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int find_next ( int n , int k ) { int M = n + 1 ; while ( 1 ) { if ( M & ( 1ll << k ) ) break ; M ++ ; } return M ; } int main ( ) { int N = 15 , K = 2 ; cout << find_next ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumSubarrays ( int arr [ ] , int N , int target ) { int ans = 0 ; int availIdx = -1 ; int cur_sum = 0 ; unordered_map < int , int > mp ; mp [ 0 ] = -1 ; for ( int i = 0 ; i < N ; i ++ ) { cur_sum += arr [ i ] ; if ( mp . find ( cur_sum - target ) != mp . end ( ) && mp [ cur_sum - target ] >= availIdx ) { ans ++ ; availIdx = i ; } mp [ cur_sum ] = i ; } return ans ; } int main ( ) { int arr [ ] = { 2 , -1 , 4 , 3 , 6 , 4 , 5 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int target = 6 ; cout << maximumSubarrays ( arr , N , target ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getCount ( int N , int M ) { int total_count = 0 ; total_count += ( N / 10 ) ; int x = ( N / 10 ) * 10 ; if ( ( N - x ) >= M ) { total_count = total_count + 1 ; } return total_count ; } int main ( ) { int N = 100 , M = 1 ; cout << getCount ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digitsOf ( int num ) { return to_string ( num ) . size ( ) ; } int count ( int a , int tn ) { int diff = pow ( 10 , digitsOf ( a ) ) ; return ( ( tn - a ) / diff ) + 1 ; } int main ( ) { int n , m ; n = 25 , m = 4500 ; cout << count ( n , m ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minOperations ( int a [ ] , int N ) { int num_of_ops1 , num_of_ops2 , sum ; num_of_ops1 = num_of_ops2 = sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 0 && sum >= 0 ) { num_of_ops1 += ( 1 + abs ( sum ) ) ; sum = -1 ; } else if ( i % 2 == 1 && sum <= 0 ) { num_of_ops1 += ( 1 + abs ( sum ) ) ; sum = 1 ; } } sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 1 && sum >= 0 ) { num_of_ops2 += ( 1 + abs ( sum ) ) ; sum = -1 ; } else if ( i % 2 == 0 && sum <= 0 ) { num_of_ops2 += ( 1 + abs ( sum ) ) ; sum = 1 ; } } return min ( num_of_ops1 , num_of_ops2 ) ; } int main ( ) { int arr [ ] = { 3 , -4 , 5 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { count += __builtin_popcount ( i ) ; } return count ; } int main ( ) { int L = 3 , R = 5 ; cout << " Total ▁ set ▁ bit ▁ count ▁ is ▁ " << countSetBits ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSwaps ( int A [ ] , int n ) { sort ( A , A + n ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n and A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n and A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; } int main ( ) { int A [ ] = { 4 , 3 , 3 , 2 , 5 } ; cout << countSwaps ( A , 5 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int numberOfPairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; } int main ( ) { int n = 8 ; cout << numberOfPairs ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 100000 ; int canTake ; int best ; int dp [ N ] ; bool vis [ N ] ; int dfs ( vector < vector < int > > & g , int * cost , int u , int pre ) { vis [ u ] = true ; dp [ u ] = cost [ u ] ; bool check = 1 ; int cur = cost [ u ] ; for ( auto & x : g [ u ] ) { if ( vis [ x ] && x != pre ) { check = 0 ; } else if ( ! vis [ x ] ) { check &= dfs ( g , cost , x , u ) ; cur = max ( cur , cost [ u ] + dp [ x ] ) ; } } dp [ u ] = cur ; if ( ! check ) { canTake += cost [ u ] ; } else { best = max ( best , dp [ u ] ) ; } return check ; } int FindMaxCost ( vector < vector < int > > & g , int * cost , int source ) { dfs ( g , cost , source , -1 ) ; cout << canTake + best ; } int main ( ) { int n = 5 , m = 5 ; int cost [ ] = { 2 , 2 , 8 , 6 , 9 } ; vector < vector < int > > g ( n ) ; g [ 0 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 0 ) ; g [ 0 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 0 ) ; g [ 0 ] . push_back ( 3 ) ; g [ 3 ] . push_back ( 0 ) ; g [ 1 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 4 ) ; g [ 4 ] . push_back ( 1 ) ; int source = 1 ; FindMaxCost ( g , cost , source ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; } int main ( ) { int N = 5 , M = 7 ; cout << minPoints ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createArray ( int n , int s ) { if ( 2 * n <= s ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << "2" << " ▁ " ; s -= 2 ; } cout << s << endl ; cout << "1" << endl ; } else cout << " - 1" << endl ; } int main ( ) { int N = 1 ; int S = 4 ; createArray ( N , S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSumSubarray ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 && mp . find ( arr [ i ] ) == mp . end ( ) ) mp [ arr [ i ] ] = 1 ; } int first = 0 ; int last = 0 ; int ans = 0 ; int INF = 1e6 ; for ( auto i : mp ) { int mx = i . first ; int curr = 0 ; int curr_start ; for ( int j = 0 ; j < n ; j ++ ) { if ( curr == 0 ) curr_start = j ; int val = arr [ j ] > mx ? - INF : arr [ j ] ; curr += val ; if ( curr < 0 ) curr = 0 ; if ( curr > ans ) { ans = curr ; first = curr_start ; last = j ; } } } cout << first + 1 << " ▁ " << last + 1 ; } int main ( ) { int arr [ ] = { 5 , -2 , 10 , -1 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximumSumSubarray ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minFlip ( string s , int n , int k , char a [ ] , int p ) { bool allowed [ 26 ] = { 0 } ; for ( int i = 0 ; i < p ; i ++ ) { allowed [ a [ i ] - ' a ' ] = true ; } char freq [ k ] [ 26 ] ; for ( int i = 0 ; i < k ; i ++ ) for ( int j = 0 ; j < 26 ; j ++ ) freq [ i ] [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ i % k ] [ s [ i ] - ' a ' ] += 1 ; } int ans = 0 ; int totalpositions = n / k ; for ( int i = 0 ; i < k ; i ++ ) { int maxfrequency = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( freq [ i ] [ j ] > maxfrequency and allowed [ j ] == true ) maxfrequency = freq [ i ] [ j ] ; } ans += ( totalpositions - maxfrequency + ( ( i % k < n % k ) ? 1 : 0 ) ) ; } cout << ans << endl ; } int main ( ) { string S = " nihsiakyt " ; int n = S . length ( ) ; int K = 3 ; char A [ 5 ] = { ' n ' , ' i ' , ' p ' , ' s ' , ' q ' } ; int p = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minFlip ( S , n , K , A , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinDiff ( int n ) { int val = pow ( 2 , n ) ; int sep = n / 2 ; int grp1 = 0 ; int grp2 = 0 ; grp1 = grp1 + val ; for ( int i = 1 ; i < sep ; i ++ ) grp1 = grp1 + pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) grp2 = grp2 + pow ( 2 , i ) ; cout << ( abs ( grp1 - grp2 ) ) ; } int main ( ) { int n = 4 ; MinDiff ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumValue ( int a [ ] , int n ) { int answer = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; } int main ( ) { int N = 6 ; int A [ N ] = { 12 , 3 , 14 , 5 , 9 , 8 } ; cout << MinimumValue ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfSubstrings ( string s ) { int n = s . length ( ) ; int prefix_sum [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) prefix_sum [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int countOfOnes = prefix_sum [ j ] - ( i - 1 >= 0 ? prefix_sum [ i - 1 ] : 0 ) ; int length = j - i + 1 ; if ( countOfOnes > 0 && length % countOfOnes == 0 ) answer ++ ; } } return answer ; } int main ( ) { string S = "1111100000" ; cout << countOfSubstrings ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digit_xor ( int x ) { int xorr = 0 ; while ( x ) { xorr ^= x % 10 ; x = x / 10 ; } return xorr ; } int find_count ( int n ) { map < int , int > mpp ; for ( int i = 1 ; i <= n ; i ++ ) { mpp [ digit_xor ( i ) ] += 1 ; } int maxm = 0 ; for ( auto x : mpp ) { if ( x . second > maxm ) maxm = x . second ; } return maxm ; } int main ( ) { int N = 13 ; cout << find_count ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_val = INT_MAX ; int min_steps = 0 ; int sumOfDigits ( int n ) { string s = to_string ( n ) ; int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += ( s [ i ] - '0' ) ; } return sum ; } void Transform ( int n , int d , int steps ) { if ( n < min_val ) { min_val = n ; min_steps = steps ; } else if ( n == min_val ) { min_steps = min ( min_steps , steps ) ; } if ( steps < 15 ) { Transform ( sumOfDigits ( n ) , d , steps + 1 ) ; Transform ( n + d , d , steps + 1 ) ; } } int main ( ) { int N = 9 , D = 3 ; Transform ( N , D , 0 ) ; cout << min_val << " ▁ " << min_steps ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; } int main ( ) { int A = 6 , B = 15 , M = 3 ; cout << sumDivisibles ( A , B , M ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n ) { unordered_map < int , int > frequency ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ a [ i ] ] ++ ; } int count = 0 ; for ( auto x : frequency ) { int f = x . second ; count += f * ( f - 1 ) / 2 ; } return count ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void decBinary ( int arr [ ] , int n ) { int k = log2 ( n ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } int maxNum ( int n , int k ) { int l = log2 ( n ) + 1 ; int a [ l ] = { 0 } ; decBinary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; } int main ( ) { int n = 4 , k = 1 ; cout << maxNum ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; char maxAlpha ( string str , int len ) { int first [ MAX ] , last [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - ' a ' ) ; if ( first [ index ] == -1 ) first [ index ] = i ; last [ index ] = i ; } int ans = -1 , maxVal = -1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == -1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; } int main ( ) { string str = " abbba " ; int len = str . length ( ) ; cout << maxAlpha ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; default : return false ; } } int vowelPairs ( string s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s [ i ] ) && isVowel ( s [ i + 1 ] ) ) cnt ++ ; } return cnt ; } int main ( ) { string s = " abaebio " ; int n = s . length ( ) ; cout << vowelPairs ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_elimination ( int n , int arr [ ] ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min_elimination ( n , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIfOverlap ( string str ) { int len = str . length ( ) ; int visited [ len + 1 ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' . ' ) continue ; for ( int j = max ( 0 , i - str [ i ] ) ; j <= min ( len , i + str [ i ] ) ; j ++ ) visited [ j ] ++ ; } for ( int i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; } int main ( ) { string str = " . 2 . . 2 . " ; if ( checkIfOverlap ( str ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCorrectOrder ( int n ) { bool flag = true ; int prev = -1 ; int type = -1 ; while ( n != 0 ) { if ( type == -1 ) { if ( prev == -1 ) { prev = n % 10 ; n = n / 10 ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; } int main ( ) { int n = 123454321 ; if ( isCorrectOrder ( n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define V  5 NEW_LINE bool isValidEdge ( int u , int v , vector < bool > inMST ) { if ( u == v ) return false ; if ( inMST [ u ] == false && inMST [ v ] == false ) return false ; else if ( inMST [ u ] == true && inMST [ v ] == true ) return false ; return true ; } void primMST ( int cost [ ] [ V ] ) { vector < bool > inMST ( V , false ) ; inMST [ 0 ] = true ; int edge_count = 0 , mincost = 0 ; while ( edge_count < V - 1 ) { int min = INT_MAX , a = -1 , b = -1 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( cost [ i ] [ j ] < min ) { if ( isValidEdge ( i , j , inMST ) ) { min = cost [ i ] [ j ] ; a = i ; b = j ; } } } } if ( a != -1 && b != -1 ) { printf ( " Edge ▁ % d : ( % d , ▁ % d ) ▁ cost : ▁ % d ▁ STRNEWLINE " , edge_count ++ , a , b , min ) ; mincost = mincost + min ; inMST [ b ] = inMST [ a ] = true ; } } printf ( " Minimum cost = % d " , mincost ) ; } int main ( ) { int cost [ ] [ V ] = { { INT_MAX , 2 , INT_MAX , 6 , INT_MAX } , { 2 , INT_MAX , 3 , 8 , 5 } , { INT_MAX , 3 , INT_MAX , INT_MAX , 7 } , { 6 , 8 , INT_MAX , INT_MAX , 9 } , { INT_MAX , 5 , 7 , 9 , INT_MAX } , } ; primMST ( cost ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void construct ( int n , pair < double , double > ans_pair ) { if ( ans_pair . first == -1 ) { cout << " Not ▁ possible " ; return ; } double a1 = ans_pair . first ; double a2 = ans_pair . second ; double r = a2 / a1 ; cout << " The ▁ resultant ▁ sequence ▁ is : STRNEWLINE " ; for ( int i = 1 ; i <= n ; i ++ ) { double ai = a1 * pow ( r , i - 1 ) ; cout << ai << " ▁ " ; } } void findMinimumOperations ( double * a , int n ) { int ans = INT_MAX ; int c [ ] = { -1 , 0 , 1 } ; int possibilities = 3 ; int pos1 = -1 , pos2 = -1 ; for ( int i = 0 ; i < possibilities ; i ++ ) { for ( int j = 0 ; j < possibilities ; j ++ ) { double a1 = a [ 1 ] + c [ i ] ; double a2 = a [ 2 ] + c [ j ] ; int temp = abs ( a1 - a [ 1 ] ) + abs ( a2 - a [ 2 ] ) ; if ( a1 == 0 a2 == 0 ) continue ; double r = a2 / a1 ; for ( int pos = 3 ; pos <= n ; pos ++ ) { double ai = a1 * pow ( r , pos - 1 ) ; if ( a [ pos ] == ai ) { continue ; } else if ( a [ pos ] + 1 == ai a [ pos ] - 1 == ai ) { temp ++ ; } else { temp = INT_MAX ; break ; } } if ( temp < ans ) { ans = temp ; pos1 = a1 ; pos2 = a2 ; } } } if ( ans == -1 ) { cout << " - 1" ; return ; } cout << " Minimum ▁ Number ▁ of ▁ Operations ▁ are ▁ " << ans << " STRNEWLINE " ; pair < double , double > ans_pair = { pos1 , pos2 } ; construct ( n , ans_pair ) ; } int main ( ) { double a [ ] = { 0 , 7 , 20 , 49 , 125 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; findMinimumOperations ( a , n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { bool visited [ N + 1 ] ; int minimumSwaps = 0 ; memset ( visited , false , sizeof ( visited ) ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; N /= 2 ; cout << findMinimumAdjacentSwaps ( arr , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; } int main ( ) { int arr [ ] = { 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << MinOperation ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printVector ( vector < int > v ) { cout << v . size ( ) << endl ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << " ▁ " ; cout << endl ; } void findTwoGroup ( int n ) { int sum = n * ( n + 1 ) / 2 ; int group1Sum = sum / 2 ; vector < int > group1 , group2 ; for ( int i = n ; i > 0 ; i -- ) { if ( group1Sum - i >= 0 ) { group1 . push_back ( i ) ; group1Sum -= i ; } else { group2 . push_back ( i ) ; } } printVector ( group1 ) ; printVector ( group2 ) ; } int main ( ) { int n = 5 ; findTwoGroup ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; long swapCount ( string s ) { vector < int > pos ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s [ i ] == ' [ ' ) pos . push_back ( i ) ; int count = 0 ; int p = 0 ; long sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( s [ i ] == ' ] ' ) -- count ; if ( count < 0 ) { sum += pos [ p ] - i ; swap ( s [ i ] , s [ pos [ p ] ] ) ; ++ p ; count = 1 ; } } return sum ; } int main ( ) { string s = " [ ] ] [ ] [ " ; cout << swapCount ( s ) << " STRNEWLINE " ; s = " [ [ ] [ ] ] " ; cout << swapCount ( s ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; void countOfNumbers ( int N ) { int ans = 1 ; for ( int index = 1 ; index <= N ; ++ index ) { int choices = 0 ; for ( int digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * 1LL * choices ) % mod ; } cout << ans << endl ; } int main ( ) { int N = 5 ; countOfNumbers ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dfs ( int arr [ ] , int left , int K ) { int q = 0 ; if ( left == 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; q = max ( q , 1 + dfs ( arr , K - i , K ) ) ; arr [ i ] ++ ; } } } else { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; int nleft = ( i <= left ? left - i : K + left - i ) ; q = max ( q , dfs ( arr , nleft , K ) ) ; arr [ i ] ++ ; } } } return q ; } int maxGroups ( int K , int arr [ ] , int n ) { int V [ K ] = { 0 } ; for ( int x = 0 ; x < n ; x ++ ) V [ arr [ x ] % K ] ++ ; int ans = V [ 0 ] + dfs ( V , 0 , K ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << maxGroups ( K , arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestSubsequence ( int * arr , int N ) { int dp [ N ] [ N + 1 ] ; memset ( dp , -1 , sizeof dp ) ; for ( int i = 0 ; i < N ; ++ i ) { dp [ i ] [ 0 ] = 0 ; } dp [ 0 ] [ 1 ] = ( arr [ 0 ] >= 0 ? arr [ 0 ] : -1 ) ; for ( int i = 1 ; i < N ; ++ i ) { for ( int j = 1 ; j <= ( i + 1 ) ; ++ j ) { if ( dp [ i - 1 ] [ j ] != -1 ) { dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } if ( dp [ i - 1 ] [ j - 1 ] >= 0 && dp [ i - 1 ] [ j - 1 ] + arr [ i ] >= 0 ) { dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + arr [ i ] ) ; } } } int ans = 0 ; for ( int j = 0 ; j <= N ; ++ j ) { if ( dp [ N - 1 ] [ j ] >= 0 ) { ans = j ; } } cout << ans << endl ; } int main ( ) { int arr [ ] = { 4 , -4 , 1 , -3 , 1 , -3 } ; int N = sizeof arr / sizeof arr [ 0 ] ; longestSubsequence ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int KvisibleFromLeft ( int N , int K ) { if ( N == K ) return 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; } int main ( ) { int N = 5 , K = 2 ; cout << KvisibleFromLeft ( N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numOfWays ( vector < vector < int > > a , int n , int i , set < int > & blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && blue . find ( j ) == blue . end ( ) ) { blue . insert ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . erase ( j ) ; } } return count ; } int main ( ) { int n = 3 ; vector < vector < int > > mat = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; set < int > mpp ; cout << ( numOfWays ( mat , n , 0 , mpp ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalArrays ( int N , int M ) { int end_with_one [ N + 1 ] ; int end_not_with_one [ N + 1 ] ; end_with_one [ 0 ] = 1 ; end_not_with_one [ 0 ] = 0 ; end_with_one [ 1 ] = 0 ; end_not_with_one [ 1 ] = M - 1 ; for ( int i = 2 ; i < N ; i ++ ) { end_with_one [ i ] = end_not_with_one [ i - 1 ] ; end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; } return end_with_one [ N - 1 ] ; } int main ( ) { int N = 3 , M = 3 ; int temp = totalArrays ( N , M ) ; int ans = M * temp ; cout << ans << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  1000000007 NEW_LINE long long power ( long long X , long long Y ) { long long res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( Y & 1 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } int findValue ( long long int n ) { long long X = 0 ; long long pow_10 = 1 ; while ( n ) { if ( n & 1 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; long long res = power ( 2 , X ) ; return res ; } int main ( ) { long long n = 2 ; cout << findValue ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long countWaysToTileBoard ( long N ) { long dp [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } cout << dp [ N ] ; } int main ( ) { long N = 2 ; countWaysToTileBoard ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int removeSmallestSubarray ( int arr [ ] , int S , int n , int k ) { int target_remainder = S % k ; unordered_map < int , int > map1 ; map1 [ 0 ] = -1 ; int curr_remainder = 0 ; int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 [ curr_remainder ] = i ; int mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . find ( mod ) != map1 . end ( ) ) { res = min ( res , i - map1 [ mod ] ) ; } } if ( res == INT_MAX res == n ) { res = -1 ; } return res ; } int smstSubmatDeleted ( vector < vector < int > > & mat , int N , int M , int K ) { int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) S += mat [ i ] [ j ] ; } int min_area = N * M ; int left = 0 ; int right = 0 ; int width ; int area ; int prefixRowSum [ N ] ; for ( left = 0 ; left < M ; left ++ ) { memset ( prefixRowSum , 0 , sizeof ( prefixRowSum ) ) ; for ( right = left ; right < M ; right ++ ) { for ( int i = 0 ; i < N ; i ++ ) { prefixRowSum [ i ] += mat [ i ] [ right ] ; } width = removeSmallestSubarray ( prefixRowSum , S , N , K ) ; if ( width != -1 ) { area = ( right - left + 1 ) * ( width ) ; if ( area < min_area ) { min_area = area ; } } } } return min_area ; } int main ( ) { vector < vector < int > > mat = { { 6 , 2 , 6 } , { 3 , 2 , 8 } , { 2 , 5 , 3 } } ; int K = 3 ; int N = mat . size ( ) ; int M = mat [ 0 ] . size ( ) ; cout << smstSubmatDeleted ( mat , N , M , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countstrings ( int n , int start ) { if ( n == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = start ; i < 5 ; i ++ ) { cnt += countstrings ( n - 1 , i ) ; } return cnt ; } int countVowelStrings ( int n ) { return countstrings ( n , 0 ) ; } int main ( ) { int n = 2 ; cout << countVowelStrings ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNumberOfStrings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; } int main ( ) { int N = 2 ; cout << findNumberOfStrings ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; const int mod = ( int ) 1e9 + 7 ; ll findTotalPath ( int X , int n , vector < int > & dp ) { if ( X == 0 ) { return 1 ; } ll ans = 0 ; if ( dp [ X ] != -1 ) { return dp [ X ] ; } for ( int i = 1 ; i <= min ( X , n ) ; ++ i ) { ans += findTotalPath ( X - i , n , dp ) % mod ; ans %= mod ; } return dp [ X ] = ans ; } int main ( ) { int n = 3 , X = 2 ; vector < int > dp ( X + 1 , -1 ) ; cout << findTotalPath ( X , n , dp ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE vector < int > SieveOfEratosthenes ( ) { bool seive [ MAX ] ; memset ( seive , true , sizeof ( seive ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( seive [ p ] == true ) { for ( int i = p * p ; i < MAX ; i += p ) { seive [ i ] = false ; } } } vector < int > v ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( seive [ p ] ) { v . push_back ( p ) ; } } return v ; } void build ( int dp [ ] , int arr [ ] , int N ) { dp [ 0 ] = 0 ; dp [ 1 ] = 0 ; vector < int > prime = SieveOfEratosthenes ( ) ; int pref [ N + 1 ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { pref [ i ] = pref [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; for ( int j = 0 ; j <= prime . size ( ) ; j ++ ) { int r = i - 1 ; int l = r - prime [ j ] + 1 ; if ( l < 0 ) break ; int temp = 0 ; temp = pref [ r + 1 ] - pref [ l ] ; if ( l - 2 >= 0 ) temp += dp [ l - 2 + 1 ] ; dp [ i ] = max ( dp [ i ] , temp ) ; } } } void maxSumSubseq ( int arr [ ] , int N ) { int dp [ N + 1 ] ; build ( dp , arr , N ) ; cout << dp [ N ] ; } int main ( ) { int arr [ ] = { 10 , 10 , 7 , 10 , 10 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxSumSubseq ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binCoff ( int N , int R ) { int res = 1 ; if ( R > ( N - R ) ) { R = ( N - R ) ; } for ( int i = 0 ; i < R ; i ++ ) { res *= ( N - i ) ; res /= ( i + 1 ) ; } return res ; } int cntPermutation ( int N ) { int cntPerm ; int C_2N_N = binCoff ( 2 * N , N ) ; cntPerm = C_2N_N / ( N + 1 ) ; return cntPerm ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << cntPermutation ( N / 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return max ( max ( l , m ) , r ) ; } } void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkEqualSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SubarrayWithMaxSum ( vector < int > & nums ) { int endIndex , currMax = nums [ 0 ] ; int globalMax = nums [ 0 ] ; for ( int i = 1 ; i < nums . size ( ) ; ++ i ) { currMax = max ( nums [ i ] , nums [ i ] + currMax ) ; if ( currMax > globalMax ) { globalMax = currMax ; endIndex = i ; } } int startIndex = endIndex ; while ( startIndex >= 0 ) { globalMax -= nums [ startIndex ] ; if ( globalMax == 0 ) break ; startIndex -- ; } for ( int i = startIndex ; i <= endIndex ; ++ i ) { cout << nums [ i ] << " ▁ " ; } } int main ( ) { vector < int > arr = { -2 , -5 , 6 , -2 , -3 , 1 , 5 , -6 } ; SubarrayWithMaxSum ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximizeSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) sum += arr [ i ] ; int leftDP [ n / 2 ] ; int rightDP [ n / 2 ] ; int c = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { int leftDiff = arr [ i ] - arr [ i - 1 ] ; if ( c - 1 < 0 ) leftDP = leftDiff ; else { if ( leftDP > 0 ) leftDP = leftDiff + leftDP ; else leftDP [ i ] = leftDiff ; } int rightDiff ; if ( i + 1 >= n ) rightDiff = 0 ; else rightDiff = arr [ i ] - arr [ i + 1 ] ; if ( c - 1 < 0 ) rightDP = rightDiff ; else { if ( rightDP > 0 ) rightDP = rightDiff + rightDP ; else rightDP = rightDiff ; } c ++ ; } int maxi = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { maxi = max ( maxi , max ( leftDP [ i ] , rightDP [ i ] ) ) ; } return maxi + sum ; } int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 7 , 6 , 8 , 9 , 7 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int ans = maximizeSum ( arr , n ) ; cout << ( ans ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int validsubsequences ( int arr [ ] , int n ) { long long int dp [ n + 1 ] [ 2 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 ) { dp [ i ] [ 1 ] += 1 ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; } else { dp [ i ] [ 0 ] += 1 ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; } } return dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << validsubsequences ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void OddDivisorsCount ( int n , int q , int a [ ] , vector < pair < int , int > > Query ) { int DP [ n ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int x = sqrt ( a [ i ] ) ; if ( x * x == a [ i ] ) DP [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i ] ; } int l , r ; for ( int i = 0 ; i < q ; i ++ ) { l = Query [ i ] . first ; r = Query [ i ] . second ; if ( l == 0 ) { cout << DP [ r ] << endl ; } else { cout << DP [ r ] - DP [ l - 1 ] << endl ; } } } int main ( ) { int N = 5 ; int Q = 3 ; int arr [ ] = { 2 , 4 , 5 , 6 , 9 } ; vector < pair < int , int > > Query Query = { { 0 , 2 } , { 1 , 3 } , { 1 , 4 } } ; OddDivisorsCount ( N , Q , arr , Query ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countStableNum ( string str , int N ) { int count1 [ N ] [ 10 ] ; int count2 [ N ] [ 10 ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) count1 [ i ] [ j ] = count2 [ i ] [ j ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != 0 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count1 [ i ] [ j ] += count1 [ i - 1 ] [ j ] ; } } count1 [ i ] [ str [ i ] - '0' ] ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i != N - 1 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count2 [ i ] [ j ] += count2 [ i + 1 ] [ j ] ; } } count2 [ i ] [ str [ i ] - '0' ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { if ( str [ i ] == '9' ) continue ; int c1 = count1 [ i - 1 ] [ str [ i ] - '0' ] ; int c2 = count2 [ i + 1 ] [ str [ i ] - '0' + 1 ] ; if ( c2 == 0 ) continue ; ans = ( ans + ( c1 * ( ( c2 * ( c2 - 1 ) / 2 ) ) ) ) ; } return ans ; } int main ( ) { string str = "224353" ; int N = str . length ( ) ; cout << countStableNum ( str , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const long long MAX = 1e18 ; long long n , m ; vector < long long > v [ 151 ] ; long long dp [ 151 ] [ 151 ] ; long long min_operation ( long long i , long long j , long long val , long long x ) { if ( i == n - 1 && j == m - 1 ) { if ( val > v [ i ] [ j ] ) { return dp [ i ] [ j ] = MAX ; } else { return dp [ i ] [ j ] = v [ i ] [ j ] - val ; } } if ( i == n j == m ) { return dp [ i ] [ j ] = MAX ; } if ( dp [ i ] [ j ] != -1 ) { return dp [ i ] [ j ] ; } if ( val > v [ i ] [ j ] ) { return dp [ i ] [ j ] = MAX ; } long long tmp = v [ i ] [ j ] - val ; tmp += min ( min_operation ( i + 1 , j , val + x , x ) , min_operation ( i , j + 1 , val + x , x ) ) ; return dp [ i ] [ j ] = tmp ; } long long solve ( long long x ) { long long ans = INT64_MAX ; for ( long long i = 0 ; i < n ; i ++ ) { for ( long long j = 0 ; j < m ; j ++ ) { long long val = v [ i ] [ j ] - x * ( i + j ) ; memset ( dp , -1 , sizeof ( dp ) ) ; val = min_operation ( 0 , 0 , val , x ) ; ans = min ( ans , val ) ; } } return ans ; } int main ( ) { n = 2 , m = 2 ; long long x = 3 ; v [ 0 ] = { 15 , 153 } ; v [ 1 ] = { 135 , 17 } ; cout << solve ( x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll K ; ll N ; vector < int > v ; ll dp [ 20 ] [ 1000 ] [ 10 ] [ 2 ] [ 2 ] ; void init ( ll x ) { memset ( dp , -1 , sizeof ( dp ) ) ; v . clear ( ) ; while ( x > 0 ) { v . push_back ( x % 10 ) ; x /= 10 ; } reverse ( v . begin ( ) , v . end ( ) ) ; N = v . size ( ) ; } ll fun ( ll pos , ll sum , ll st , ll check , ll f ) { if ( pos == N ) { return ( sum == 0 and check == 1 ) ; } if ( dp [ pos ] [ sum ] [ st ] [ check ] [ f ] != -1 ) return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] ; ll lmt = 9 ; if ( ! f ) lmt = v [ pos ] ; ll ans = 0 ; for ( int digit = 0 ; digit <= lmt ; digit ++ ) { ll nf = f ; ll new_sum = ( sum + digit ) % K ; ll new_check = check ; ll new_st = st ; if ( f == 0 and digit < lmt ) nf = 1 ; if ( check == 0 and digit != 0 ) { new_st = digit ; new_check = 1 ; } if ( pos == N - 1 and new_st == digit ) continue ; ans += fun ( pos + 1 , new_sum , new_st , new_check , nf ) ; } return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] = ans ; } void findCount ( int L , int R , int K ) { init ( R ) ; ll r_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; init ( L - 1 ) ; ll l_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; cout << r_ans - l_ans ; } int main ( ) { ll L = 10 ; ll R = 20 ; K = 2 ; findCount ( L , R , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } int findSubarraySum ( int arr [ ] , int n , int K ) { unordered_map < int , int > prevSum ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . find ( currsum - K ) != prevSum . end ( ) ) res += ( prevSum [ currsum - K ] ) ; prevSum [ currsum ] ++ ; } return res ; } void countSubarray ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( isPerfectSquare ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } cout << findSubarraySum ( arr , n , K ) ; } int main ( ) { int arr [ ] = { 2 , 4 , 9 , 2 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countSubarray ( arr , N , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define dim  5 NEW_LINE void createTable ( int mtrx [ ] [ dim ] , int k , int p , int dp [ ] [ dim ] ) { dp [ 0 ] [ 0 ] = mtrx [ 0 ] [ 0 ] ; for ( int j = 1 ; j < dim ; j ++ ) { dp [ 0 ] [ j ] = mtrx [ 0 ] [ j ] + dp [ 0 ] [ j - 1 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { dp [ i ] [ 0 ] = mtrx [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { for ( int j = 1 ; j < dim ; j ++ ) { dp [ i ] [ j ] = mtrx [ i ] [ j ] + dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } } int countSubMatrixUtil ( int dp [ ] [ dim ] , int k , int p ) { int count = 0 ; int subMatSum = 0 ; for ( int i = k - 1 ; i < dim ; i ++ ) { for ( int j = k - 1 ; j < dim ; j ++ ) { if ( i == ( k - 1 ) || j == ( k - 1 ) ) { if ( i == ( k - 1 ) && j == ( k - 1 ) ) { subMatSum = dp [ i ] [ j ] ; } else if ( i == ( k - 1 ) ) { subMatSum = dp [ i ] [ j ] - dp [ i ] [ j - k ] ; } else { subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] ; } } else { subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] - dp [ i ] [ j - k ] + dp [ i - k ] [ j - k ] ; } if ( subMatSum >= p ) { count ++ ; } } } return count ; } int countSubMatrix ( int mtrx [ ] [ dim ] , int k , int p ) { int dp [ dim ] [ dim ] ; for ( int i = 0 ; i < dim ; i ++ ) { for ( int j = 0 ; j < dim ; j ++ ) { dp [ i ] [ j ] = 0 ; } } createTable ( mtrx , k , p , dp ) ; return countSubMatrixUtil ( dp , k , p ) ; } int main ( ) { int mtrx [ dim ] [ dim ] = { { 1 , 7 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 9 , 6 , 7 , 3 } , { 4 , 3 , 2 , 4 , 5 } , { 5 , 1 , 5 , 3 , 1 } } ; int k = 3 ; int p = 35 ; cout << countSubMatrix ( mtrx , k , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWays ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } } int main ( ) { int N = 2 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( vector < int > & v ) { set < int > digits ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { set < int > d ; while ( v [ i ] ) { d . insert ( v [ i ] % 10 ) ; v [ i ] /= 10 ; } for ( auto it : d ) { if ( digits . count ( it ) ) return false ; } for ( auto it : d ) digits . insert ( it ) ; } return true ; } int numberOfSubarrays ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { vector < int > temp ; for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) temp . push_back ( a [ j ] ) ; } if ( check ( temp ) ) answer ++ ; } return answer ; } int main ( ) { int N = 4 ; int A [ ] = { 1 , 12 , 23 , 34 } ; cout << numberOfSubarrays ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumOccurrence ( string s ) { int n = s . length ( ) ; map < string , int > freq ; for ( int i = 0 ; i < n ; i ++ ) { string temp = " " ; temp += s [ i ] ; freq [ temp ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { string temp = " " ; temp += s [ i ] ; temp += s [ j ] ; freq [ temp ] ++ ; } } int answer = INT_MIN ; for ( auto it : freq ) answer = max ( answer , it . second ) ; return answer ; } int main ( ) { string s = " xxxyy " ; cout << maximumOccurrence ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( int * a , int n ) { int maximum = 1 ; int left [ n ] ; int right [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = 1 ; right [ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { right [ i ] = right [ i + 1 ] + 1 ; } maximum = max ( maximum , right [ i ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { left [ i ] = left [ i - 1 ] + 1 ; } } if ( n > 2 ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { maximum = max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; } } } return maximum ; } int main ( ) { int arr [ 6 ] = { 8 , 7 , 3 , 5 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxLength ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lli  long long int NEW_LINE unordered_map < string , lli > dp ; lli solve ( string s , char c ) { if ( s . length ( ) == 1 ) return 0 ; if ( s . length ( ) == 2 ) { if ( s [ 0 ] == s [ 1 ] && s [ 0 ] == c ) return 1 ; else return 0 ; } if ( dp [ s + " ▁ " + c ] ) return dp [ s + " ▁ " + c ] ; lli ans = 0 ; if ( s [ 0 ] == s [ s . length ( ) - 1 ] && s [ 0 ] == c ) { for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) if ( c1 != c ) ans = max ( ans , 1 + solve ( s . substr ( 1 , s . length ( ) - 2 ) , c1 ) ) ; } else { for ( lli i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == c ) { for ( lli j = s . length ( ) - 1 ; j > i ; j -- ) if ( s [ j ] == c ) { if ( j == i ) break ; ans = solve ( s . substr ( i , j - i + 1 ) , c ) ; break ; } break ; } } } dp [ s + " ▁ " + c ] = ans ; return dp [ s + " ▁ " + c ] ; } int main ( ) { string s = " abscrcdba " ; lli ma = 0 ; for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) ma = max ( ma , solve ( s , c1 ) * 2 ) ; cout << ma << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxIncSubarr ( int a [ ] , int n ) { int pre [ n ] = { 0 } ; int pos [ n ] = { 0 } ; pre [ 0 ] = 1 ; pos [ n - 1 ] = 1 ; int l = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) pre [ i ] = pre [ i - 1 ] + 1 ; else pre [ i ] = 1 ; } l = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] < a [ i + 1 ] ) pos [ i ] = pos [ i + 1 ] + 1 ; else pos [ i ] = 1 ; } int ans = 0 ; l = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) l ++ ; else l = 1 ; ans = max ( ans , l ) ; } for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( a [ i - 1 ] < a [ i + 1 ] ) ans = max ( pre [ i - 1 ] + pos [ i + 1 ] , ans ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxIncSubarr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxM  64 NEW_LINE int dp [ maxN ] [ maxM ] ; bool v [ maxN ] [ maxM ] ; int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } int main ( ) { int arr [ ] = { 3 , 7 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 3 ; int ans = findLen ( arr , 0 , 0 , n , m ) ; if ( ans == -1 ) cout << 0 ; else cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxM  64 NEW_LINE int dp [ maxN ] [ maxM ] ; bool v [ maxN ] [ maxM ] ; int findLen ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( ! curr ) return 0 ; else return -1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = 1 ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != -1 ) dp [ i ] [ curr ] = max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } int main ( ) { int arr [ ] = { 3 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 3 ; cout << findLen ( arr , 0 , 0 , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divideArray ( int arr [ ] , int n , int k ) { int dp [ 500 ] [ 500 ] = { 0 } ; k -= 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] = INT_MAX ; int max_ = -1 , sum = 0 ; for ( int l = i ; l < n ; l ++ ) { max_ = max ( max_ , arr [ l ] ) ; sum += arr [ l ] ; int diff = ( l - i + 1 ) * max_ - sum ; if ( j > 0 ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , diff + dp [ l + 1 ] [ j - 1 ] ) ; else dp [ i ] [ j ] = diff ; } } } return dp [ 0 ] [ k ] ; } int main ( ) { int arr [ ] = { 2 , 9 , 5 , 4 , 8 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 2 ; cout << divideArray ( arr , n , k ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxHappiness ( int A , int N , vector < string > v ) { string str ; int val [ N ] , wt [ N ] , c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { str = v [ i ] ; c = 0 ; for ( int j = 0 ; str [ j ] ; j ++ ) { if ( str [ j ] == ' c ' ) c += 4 ; else if ( str [ j ] == ' w ' ) c += 3 ; else if ( str [ j ] == ' m ' ) c += 2 ; else c ++ ; } c *= str . length ( ) ; val [ i ] = c ; wt [ i ] = str . length ( ) ; } int k [ N + 1 ] [ A + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int w = 0 ; w <= A ; w ++ ) { if ( i == 0 w == 0 ) k [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) k [ i ] [ w ] = max ( val [ i - 1 ] + k [ i - 1 ] [ w - wt [ i - 1 ] ] , k [ i - 1 ] [ w ] ) ; else k [ i ] [ w ] = k [ i - 1 ] [ w ] ; } } return k [ N ] [ A ] ; } int main ( ) { int A = 5 ; vector < string > v = { " mmo " , " oo " , " cmw " , " cc " , " c " } ; int N = v . size ( ) ; cout << MaxHappiness ( A , N , v ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE int LIS ( int a [ ] , int n ) { int dp [ N ] , d [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << LIS ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkCombinations ( int a [ ] , int n ) { int pow_set_size = pow ( 2 , n ) ; int counter , j ; for ( counter = 0 ; counter < pow_set_size ; counter ++ ) { int sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( counter & ( 1 << j ) ) else } if ( sum % ( 24 * 60 ) == 0 ) return true ; } return false ; } int main ( ) { int a [ ] = { 60 , 60 , 120 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( checkCombinations ( a , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int makePairs ( vector < int > & pairs , int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int sumOfDigits = 0 , k = i ; while ( k > 0 ) { sumOfDigits += k % 10 ; k /= 10 ; } if ( sumOfDigits <= 162 ) pairs . push_back ( sumOfDigits ) ; } } int countCoPrime ( int a , int b ) { vector < int > pairs ; makePairs ( pairs , a , b ) ; int count = 0 ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) for ( int j = i + 1 ; j < pairs . size ( ) ; j ++ ) if ( __gcd ( pairs [ i ] , pairs [ j ] ) == 1 ) count ++ ; return count ; } int main ( ) { int a = 12 , b = 15 ; cout << countCoPrime ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE int dp [ MAX ] [ MAX ] ; int countRemovals ( int a [ ] , int i , int j , int k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i ] [ j ] = 1 + min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) ; } return dp [ i ] [ j ] ; } int removals ( int a [ ] , int n , int k ) { sort ( a , a + n ) ; memset ( dp , -1 , sizeof ( dp ) ) ; if ( n == 1 ) return 0 ; else return countRemovals ( a , 0 , n - 1 , k ) ; } int main ( ) { int a [ ] = { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 4 ; cout << removals ( a , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; class GFG { public : int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; } } ; int main ( ) { GFG g ; int n = 4 ; cout << g . findStep ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; } int main ( ) { int n = 3 , m = 4 ; cout << dealnnoy ( n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; bool allones ( string s , int n ) { int co = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) co += ( s [ i ] == '1' ) ; return ( co == n ) ; } int findlength ( int arr [ ] , string s , int n , int ind , int st , int dp [ ] [ 3 ] ) { if ( ind >= n ) return 0 ; if ( dp [ ind ] [ st ] != -1 ) return dp [ ind ] [ st ] ; if ( st == 0 ) return dp [ ind ] [ st ] = max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , findlength ( arr , s , n , ind + 1 , 0 , dp ) ) ; else return dp [ ind ] [ st ] = max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , 0 ) ; } int maxLen ( string s , int n ) { if ( allones ( s , n ) ) return -1 ; int arr [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( s [ i ] == '0' ? 1 : -1 ) ; int dp [ MAX ] [ 3 ] ; memset ( dp , -1 , sizeof dp ) ; return findlength ( arr , s , n , 0 , 0 , dp ) ; } int main ( ) { string s = "11000010001" ; int n = 11 ; cout << maxLen ( s , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; # define R  4 NEW_LINE # define C  3 NEW_LINE bool isSafe ( int x , int y ) { return ( x < R && y < C ) ; } int minJump ( int height [ R ] [ C ] , int x , int y ) { if ( x == R - 1 && y == C - 1 ) return 0 ; int diag = INT_MAX ; if ( isSafe ( x + 1 , y + 1 ) ) diag = minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; int down = INT_MAX ; if ( isSafe ( x + 1 , y ) ) down = minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ; int right = INT_MAX ; if ( isSafe ( x , y + 1 ) ) right = minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ; return min ( { down , right , diag } ) ; } int main ( ) { int height [ ] [ C ] = { { 5 , 4 , 2 } , { 9 , 2 , 1 } , { 2 , 5 , 9 } , { 1 , 3 , 11 } } ; cout << minJump ( height , 0 , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long countWays ( int n ) { long dp [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; } int main ( ) { int n = 5 ; cout << " Total ▁ no ▁ of ▁ ways ▁ with ▁ n ▁ = ▁ " << n << " ▁ are : ▁ " << countWays ( n ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ n ] ; memset ( count_jump , 0 , sizeof ( count_jump ) ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != -1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) cout << count_jump [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countWaysToJump ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE long long int maxDecimalValue ( int mat [ ] [ N ] , int i , int j , int p ) { if ( i >= N j >= N ) return 0 ; int result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ; else return result ; } int main ( ) { int mat [ ] [ 4 ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; cout << maxDecimalValue ( mat , 0 , 0 , 0 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE long long int MaximumDecimalValue ( int mat [ ] [ N ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; if ( mat [ 0 ] [ 0 ] == 1 ) for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + pow ( 2 , i ) ; else dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + pow ( 2 , i ) ; else dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + pow ( 2 , i + j ) ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n - 1 ] [ n - 1 ] ; } int main ( ) { int mat [ ] [ 4 ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; cout << MaximumDecimalValue ( mat , 4 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int dp [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; } int main ( ) { int arr [ ] = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 4 ; cout << maxSumPairWithDifferenceLessThanK ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; } int main ( ) { int arr [ ] = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ " " subsequence ▁ is ▁ " << maxSumIS ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int k ; int min = INT_MAX ; int count ; for ( k = i ; k < j ; k ++ ) { count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " << MatrixChainOrder ( arr , 1 , n - 1 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void encodeString ( string str ) { string res = " " ; int small [ 26 ] = { 0 } , capital [ 26 ] = { 0 } , num [ 10 ] = { 0 } ; int n = str . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] >= '0' && str [ i ] <= '9' ) { num [ str [ i ] - 48 ] = i ; } else if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { small [ str [ i ] - 97 ] = i ; } else if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { capital [ str [ i ] - 65 ] = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) && small [ str [ i ] - 97 ] == i ) { int occ = str [ i ] - 96 ; while ( occ -- ) { res += str [ i ] ; } } else if ( ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) && capital [ str [ i ] - 65 ] == i ) { int occ = str [ i ] - 64 ; while ( occ -- ) { res += str [ i ] ; } } else if ( ( str [ i ] >= '0' && str [ i ] <= '9' ) && num [ str [ i ] - 48 ] == i ) { int occ = str [ i ] - 48 ; while ( occ -- ) { res += str [ i ] ; } } else { res += str [ i ] ; } } cout << res ; } int main ( ) { string str = " Ea2 , ▁ 0 , ▁ E " ; encodeString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createGrid ( char grid [ ] [ 1001 ] , bool is1 , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( is1 ) { grid [ i ] [ j ] = '0' ; is1 = false ; } else { grid [ i ] [ j ] = '1' ; is1 = true ; } } if ( M % 2 == 0 ) is1 = ! is1 ; } } bool testGrid ( char testGrid [ ] [ 1001 ] , char Grid [ ] [ 1001 ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( Grid [ i ] [ j ] != ' * ' ) { if ( Grid [ i ] [ j ] != testGrid [ i ] [ j ] ) { return false ; } } } } return true ; } void printGrid ( char grid [ ] [ 1001 ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cout << grid [ i ] [ j ] << " ▁ " ; } cout << endl ; } } void findPossibleGrid ( int N , int M , char grid [ ] [ 1001 ] ) { char gridTest1 [ N ] [ 1001 ] , gridTest2 [ N ] [ 1001 ] ; createGrid ( gridTest1 , true , N , M ) ; createGrid ( gridTest2 , false , N , M ) ; if ( testGrid ( gridTest1 , grid , N , M ) ) { cout << " Yes STRNEWLINE " ; printGrid ( gridTest1 , N , M ) ; } else if ( testGrid ( gridTest2 , grid , N , M ) ) { cout << " Yes STRNEWLINE " ; printGrid ( gridTest2 , N , M ) ; } else { cout << " No STRNEWLINE " ; } } int main ( ) { int N = 4 , M = 4 ; char grid [ ] [ 1001 ] = { { ' * ' , ' * ' , '1' , '0' } , { ' * ' , ' * ' , ' * ' , ' * ' } , { ' * ' , ' * ' , ' * ' , ' * ' } , { ' * ' , ' * ' , '0' , '1' } } ; findPossibleGrid ( N , M , grid ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinMoves ( int arr [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return -1 ; int avg = sum / N ; int total = 0 ; int needCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = max ( max ( abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; } int main ( ) { int arr [ ] = { 1 , 0 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinMoves ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getZarr ( string str , int Z [ ] ) { int n = str . length ( ) ; int k ; int L = 0 ; int R = 0 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i > R ) { L = R = i ; while ( R < n && str [ R - L ] == str [ R ] ) { R ++ ; } Z [ i ] = R - L ; R -- ; } else { k = i - L ; if ( Z [ k ] < R - i + 1 ) { Z [ i ] = Z [ k ] ; } else { L = i ; while ( R < n && str [ R - L ] == str [ R ] ) { R ++ ; } Z [ i ] = R - L ; R -- ; } } } } string goodStr ( string str , string word ) { string concat = word + " $ " + str ; int l = concat . length ( ) ; int Z [ l ] ; getZarr ( concat , Z ) ; string res ; int pSize = word . size ( ) ; for ( int i = 0 ; i < l ; ++ i ) { if ( i + pSize < l - 1 && Z [ i + pSize + 1 ] == pSize ) { i += pSize - 1 ; } else if ( i < str . length ( ) ) { res += str [ i ] ; } } return res ; } int main ( ) { string str = " Z - kmalgorithmkmiskmkmkmhelpfulkminkmsearching " ; string word = " km " ; cout << goodStr ( str , word ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumOfSubarrayProd ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } cout << ( ans ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sumOfSubarrayProd ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int phi ( int n ) { int result = 1 ; for ( int p = 2 ; p < n ; p ++ ) { if ( __gcd ( p , n ) == 1 ) { result ++ ; } } return result ; } bool sameEulerTotient ( int n ) { return phi ( n ) == phi ( 2 * n ) ; } int main ( ) { int N = 13 ; if ( sameEulerTotient ( N ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printOddFactorNumber ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) cout << i << " ▁ " ; } } int main ( ) { int N = 2 , M = 10 ; printOddFactorNumber ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSeries ( int n ) { int k = 2 ; for ( int i = 0 ; i < n ; i ++ ) { cout << ( k * ( 2 * k - 1 ) ) << " ▁ " ; k += 2 ; } cout << endl ; } int main ( ) { int N = 12 ; printSeries ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSinX ( int N ) { int Xi = 0 ; int num = 1 ; while ( N -- ) { cout << " X " << num << " ▁ = ▁ " << Xi ; cout << " ▁ sin ( X " << num << " ) ▁ = ▁ " << fixed ; cout << setprecision ( 6 ) << sin ( Xi ) << endl ; num += 1 ; Xi += 710 ; } } int main ( ) { int N = 5 ; printSinX ( N ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; void sumBetweenZero ( int arr [ ] , int N ) { int i = 0 ; vector < int > A ; int sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { i ++ ; break ; } } for ( ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { A . push_back ( sum ) ; sum = 0 ; } else { sum += arr [ i ] ; } } for ( int i = 0 ; i < A . size ( ) ; i ++ ) { cout << A [ i ] << ' ▁ ' ; } if ( A . size ( ) == 0 ) cout << " - 1" ; } int main ( ) { int arr [ ] = { 1 , 0 , 3 , 4 , 0 , 4 , 4 , 0 , 2 , 1 , 4 , 0 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sumBetweenZero ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countCharacters ( vector < string > & strings , string chars ) { int res = 0 ; unordered_map < char , int > freq ; for ( int i = 0 ; i < chars . length ( ) ; i ++ ) freq [ chars [ i ] ] += 1 ; for ( auto st : strings ) { bool flag = true ; for ( auto c : st ) { if ( ! freq ) { flag = false ; break ; } } if ( flag ) res += st . length ( ) ; } return res ; } int main ( ) { vector < string > strings = { " hi " , " data " , " geeksforgeeks " } ; string chars = " tiadhae " ; cout << countCharacters ( strings , chars ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { cout << ( 3 * i * ( i - 1 ) + 1 ) << " ▁ " ; i ++ ; } } int main ( ) { int n = 4 ; findNumbers ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getEndingIndex ( string str , int n , int i ) { i ++ ; while ( i < n ) { char curr = str [ i ] ; char prev = str [ i - 1 ] ; if ( ( curr == ' a ' && prev == ' z ' ) || ( curr - prev == 1 ) ) i ++ ; else break ; } return i - 1 ; } int largestSubStr ( string str , int n ) { int len = 0 ; int i = 0 ; while ( i < n ) { int end = getEndingIndex ( str , n , i ) ; len = max ( end - i + 1 , len ) ; i = end + 1 ; } return len ; } int main ( ) { string str = " abcabcdefabc " ; int n = str . length ( ) ; cout << ( largestSubStr ( str , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string smallestFreq ( string S1 , string S2 ) { map < string , int > banned ; for ( int i = 0 ; i < S2 . length ( ) ; ++ i ) { string s = " " ; while ( i < S2 . length ( ) && S2 [ i ] != ' ▁ ' ) s += S2 [ i ++ ] ; banned [ s ] ++ ; } map < string , int > result ; string ans ; int freq = 0 ; for ( int i = 0 ; i < S1 . length ( ) ; ++ i ) { string s = " " ; while ( i < S1 . length ( ) && S1 [ i ] != ' ▁ ' ) s += S1 [ i ++ ] ; if ( banned [ s ] == 0 ) { result [ s ] ++ ; if ( result [ s ] > freq || ( result [ s ] == freq && s < ans ) ) { ans = s ; freq = result [ s ] ; } } } return ans ; } int main ( ) { string S1 = " geeks ▁ for ▁ geeks ▁ is ▁ best ▁ place ▁ to ▁ learn " ; string S2 = " bad ▁ place " ; cout << smallestFreq ( S1 , S2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isSubstring ( string s1 , string s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return -1 ; } int main ( ) { string s1 = " for " ; string s2 = " geeksforgeeks " ; int res = isSubstring ( s1 , s2 ) ; if ( res == -1 ) cout << " Not ▁ present " ; else cout << " Present ▁ at ▁ index ▁ " << res ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int patternCount ( string str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . size ( ) ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; } int main ( ) { string str = "1001ab010abc01001" ; cout << patternCount ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxi = 0 ; string ans1 = " " ; void calculate ( string ans ) { int dp [ 26 ] = { 0 } ; for ( int i = 0 ; i < ans . length ( ) ; ++ i ) { dp [ ans [ i ] - ' A ' ] ++ ; } for ( int i = 0 ; i < 26 ; ++ i ) { if ( dp [ i ] % 2 == 1 ) { return ; } } if ( maxi < ans . length ( ) ) { maxi = ans . length ( ) ; ans1 = ans ; } } void longestString ( vector < string > arr , int index , string str ) { if ( index == arr . size ( ) ) { return ; } longestString ( arr , index + 1 , str ) ; str += arr [ index ] ; calculate ( str ) ; longestString ( arr , index + 1 , str ) ; } int main ( ) { vector < string > A = { " ABAB " , " ABF " , " CDA " , " AD " , " CCC " } ; longestString ( A , 0 , " " ) ; cout << ans1 << " ▁ " << ans1 . length ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubsequence ( string str ) { int n = str . size ( ) ; char res [ n ] ; for ( int i = 0 ; i < n ; i ++ ) res [ i ] = 0 ; for ( int pos = 0 ; pos <= 9 ; pos ++ ) { char lst1 = '0' ; bool flag = 1 ; char lst2 = pos + '0' ; for ( int i = 0 ; i < n ; i ++ ) { if ( lst2 <= str [ i ] ) { res [ i ] = '2' ; lst2 = str [ i ] ; } else if ( lst1 <= str [ i ] ) { res [ i ] = '1' ; lst1 = str [ i ] ; } else flag = 0 ; } if ( lst1 > pos + '0' ) flag = 0 ; if ( flag ) { string S1 = " " ; string S2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( res [ i ] == '1' ) { S1 += str [ i ] ; } else { S2 += str [ i ] ; } } cout << S1 << ' ▁ ' << S2 << endl ; return ; } } cout << " - 1" ; } int main ( ) { string S = "040425524644" ; findSubsequence ( S ) ; S = "123456789" ; findSubsequence ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getString ( int curlen , string & ans , string & s , int N , int & K , vector < int > & prod ) { if ( curlen == N ) { K -- ; if ( K == 0 ) ans = s ; return ; } char ch ; int ok , t , i ; for ( ch = '2' ; ch <= '9' ; ch ++ ) { s += ch ; ok = 1 ; t = 1 ; for ( i = curlen ; i >= 0 ; i -- ) { t *= s [ i ] - 48 ; if ( prod [ t ] ) ok = 0 ; prod [ t ] ++ ; } if ( ok ) getString ( curlen + 1 , ans , s , N , K , prod ) ; t = 1 ; for ( i = curlen ; i >= 0 ; i -- ) { t *= s [ i ] - 48 ; prod [ t ] -- ; } s . erase ( s . length ( ) - 1 ) ; } } string kthValidString ( int N , int K ) { if ( N > 10 ) { return " - 1" ; } if ( N == 1 ) { if ( K > 10 ) { return " - 1" ; } string s = " " ; K -- ; s += ( K + '0' ) ; return s ; } string ans = " - 1" ; string s = " " ; vector < int > prod ( 10005 , 0 ) ; getString ( 0 , ans , s , N , K , prod ) ; return ans ; } int main ( ) { int N = 3 , K = 4 ; cout << kthValidString ( N , K ) ; }
#include <iostream> NEW_LINE using namespace std ; string checkIfPossible ( int N , string arr [ ] , string T ) { int freqS [ 256 ] = { 0 } ; int freqT [ 256 ] = { 0 } ; for ( char ch : T ) { freqT [ ch - ' a ' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( char ch : arr [ i ] ) { freqS [ ch - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return " No " ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return " No " ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return " No " ; } } return " Yes " ; } int main ( ) { string arr [ ] = { " abc " , " abb " , " acc " } ; string T = " abc " ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << checkIfPossible ( N , arr , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int groupsOfOnes ( string S , int N ) { int count = 0 ; stack < int > st ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) st . push ( 1 ) ; else { if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } } if ( ! st . empty ( ) ) count ++ ; return count ; } int main ( ) { string S = "100110111" ; int N = S . length ( ) ; cout << groupsOfOnes ( S , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMinimumCost ( string s , int N ) { int count_1 = 0 , count_0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == '1' ) count_1 ++ ; else count_0 ++ ; } int k = abs ( count_0 - count_1 ) ; if ( count_1 == N count_0 == N ) cout << -1 << endl ; else cout << k / 2 << endl ; } int main ( ) { string S = "110110" ; int N = S . length ( ) ; findMinimumCost ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minLength ( string S ) { stack < char > st ; for ( auto ch : S ) { if ( st . empty ( ) ) st . push ( ch ) ; else { char top = st . top ( ) ; if ( abs ( ch - top ) == 1 ) st . pop ( ) ; else { st . push ( ch ) ; } } } return st . size ( ) ; } int main ( ) { string S = "12213" ; cout << minLength ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumDeletions ( string s ) { int right_0 = count ( s . begin ( ) , s . end ( ) , '0' ) ; int left_1 = 0 ; int n = s . size ( ) ; int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) { right_0 -= 1 ; } else { left_1 += 1 ; } res = min ( res , right_0 + left_1 ) ; } return res ; } int main ( ) { string s = "001101" ; int count = minimumDeletions ( s ) ; cout << count ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void cntBalancedParenthesis ( string s , int N ) { int cntPairs = 0 ; int cntCurly = 0 ; int cntSml = 0 ; int cntSqr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' { ' ) { cntCurly ++ ; } else if ( s [ i ] == ' ( ' ) { cntSml ++ ; } else if ( s [ i ] == ' [ ' ) { cntSqr ++ ; } else if ( s [ i ] == ' } ' && cntCurly > 0 ) { cntCurly -- ; cntPairs ++ ; } else if ( s [ i ] == ' ) ' && cntSml > 0 ) { cntSml -- ; cntPairs ++ ; } else if ( s [ i ] == ' ] ' && cntSqr > 0 ) { cntSqr -- ; cntPairs ++ ; } } cout << cntPairs ; } int main ( ) { string s = " { ( } ) " ; int N = s . length ( ) ; cntBalancedParenthesis ( s , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canBeBalanced ( string sequence ) { if ( sequence . size ( ) % 2 ) return false ; stack < char > stack_ , stack2_ ; int countOpen = 0 , countClosed = 0 ; int countSymbol = 0 ; for ( int i = 0 ; i < sequence . size ( ) ; i ++ ) { if ( sequence [ i ] == ' ) ' ) { countClosed ++ ; if ( stack_ . empty ( ) ) { return false ; } else { stack_ . pop ( ) ; } } else { if ( sequence [ i ] == ' $ ' ) { countSymbol ++ ; } else { countOpen ++ ; } stack_ . push ( sequence [ i ] ) ; } } for ( int i = sequence . size ( ) - 1 ; i >= 0 ; i -- ) { if ( sequence [ i ] == ' ( ' ) { if ( stack2_ . empty ( ) ) { return false ; } else { stack2_ . pop ( ) ; } } else { stack2_ . push ( sequence [ i ] ) ; } } int extra = abs ( countClosed - countOpen ) ; if ( countSymbol < extra ) { return false ; } else { countSymbol -= extra ; if ( countSymbol % 2 == 0 ) { return true ; } } return false ; } int main ( ) { string S = " ( ) ( $ " ; if ( canBeBalanced ( S ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxDiffFreq ( vector < pair < int , int > > queries , string S ) { int N = S . size ( ) ; int Q = queries . size ( ) ; for ( int i = 0 ; i < Q ; ++ i ) { int l = queries [ i ] . first - 1 ; int r = queries [ i ] . second - 1 ; int freq [ 26 ] = { 0 } ; for ( int j = l ; j <= r ; j ++ ) { freq [ S [ j ] - ' a ' ] ++ ; } int mx = 0 ; int mn = 99999999 ; for ( int j = 0 ; j < 26 ; j ++ ) { mx = max ( mx , freq [ j ] ) ; if ( freq [ j ] ) mn = min ( mn , freq [ j ] ) ; } cout << mx - mn << endl ; } } int main ( ) { string S = " abaabac " ; vector < pair < int , int > > queries { { 2 , 6 } , { 1 , 7 } } ; maxDiffFreq ( queries , S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isEqualStrings ( string arr [ ] , int N ) { int M = arr [ 0 ] . length ( ) ; int cntFreq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cntFreq [ arr [ i ] [ j ] - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % N != 0 ) { return false ; } } return true ; } int main ( ) { string arr [ ] = { " aab " , " bbc " , " cca " } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isEqualStrings ( arr , N ) ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findFreq ( string str , int N ) { int freq [ 256 ] ; memset ( freq , 0 , sizeof ( freq ) ) ; int max = 0 ; char charMax = '0' ; for ( int i = 0 ; i < N ; i ++ ) { char ch = str [ i ] ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; charMax = ch ; } cout << charMax << " - > " << max << endl ; } } int main ( ) { string str = " abbc " ; int N = str . size ( ) ; findFreq ( str , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfSubstringWithOnlyOnes ( string s ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count = s [ i ] == '1' ? count + 1 : 0 ; res = ( res + count ) ; } return res ; } int main ( ) { string s = "0110111" ; cout << countOfSubstringWithOnlyOnes ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1e5 + 5 ; vector < int > prefix ( N , 0 ) ; vector < int > sum ( N , 0 ) ; bool isSpecial ( char c , vector < char > & special ) { for ( auto & i : special ) if ( i == c ) return true ; return false ; } double countRatio ( string & s , vector < char > & special ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] = int ( isSpecial ( s [ i ] , special ) ) ; if ( i > 0 ) prefix [ i ] += prefix [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { sum [ i ] = prefix [ i ] ; if ( i > 0 ) sum [ i ] += sum [ i - 1 ] ; } double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = sum [ n - 1 ] - ( i > 1 ? sum [ i - 2 ] : 0 ) ; count -= ( i < n ? sum [ n - i - 1 ] : 0 ) ; ans += double ( count ) / double ( i ) ; } return ans ; } int main ( ) { string s = " abcd " ; vector < char > special = { ' b ' , ' c ' } ; double ans = countRatio ( s , special ) ; cout << fixed << setprecision ( 6 ) << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int l = 0 ; int h = str . size ( ) - 1 ; while ( h > l ) { if ( str [ l ++ ] != str [ h -- ] ) { return false ; } } return true ; } string makeOddString ( string str ) { string odd = " " ; for ( int i = 1 ; i < str . size ( ) ; i += 2 ) { odd += str [ i ] ; } return odd ; } void checkOddlyPalindrome ( string str ) { string odd = makeOddString ( str ) ; if ( isPalindrome ( odd ) ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { string str = " ddwfefwde " ; checkOddlyPalindrome ( str ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; bool checkSuffix ( int A , int B ) { string s1 = to_string ( A ) ; string s2 = to_string ( B ) ; int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) { return false ; } } return true ; } int main ( ) { int A = 12345 , B = 45 ; bool result = checkSuffix ( A , B ) ; if ( result ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } bool isPossibleSum ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) { return true ; } else { return false ; } } bool checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i , ++ cnt ; } } if ( num > 1 ) { ++ cnt ; } return cnt == 2 ; } void makeCypherString ( int N ) { string semiPrime = " " ; string sumOfPrime = " " ; string str = to_string ( N ) ; if ( checkSemiprime ( N ) ) { for ( int i = 0 ; str [ i ] ; i ++ ) { if ( i & 1 ) { semiPrime += str [ i ] ; } else { semiPrime += char ( str [ i ] - '0' + 65 ) ; } } } if ( isPossibleSum ( N ) ) { for ( int i = 0 ; str [ i ] ; i ++ ) { if ( i & 1 ) { sumOfPrime += char ( str [ i ] - '0' + 65 ) ; } else { sumOfPrime += str [ i ] ; } } } if ( semiPrime + sumOfPrime == " " ) { cout << " - 1" ; } else { cout << semiPrime + sumOfPrime ; } } int main ( ) { int N = 1011243 ; makeCypherString ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void kth_string ( int n , int k ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( k <= ( n - i - 1 ) ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == i or j == n - k ) cout << ' Y ' ; else cout << ' X ' ; } break ; } k -= ( n - i - 1 ) ; } } int main ( ) { int n = 5 , k = 7 ; kth_string ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string removeDuplicates ( string str ) { int n = str . length ( ) ; string res = " " ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = i + 1 ; j < n ; j ++ ) if ( str [ i ] == str [ j ] ) break ; if ( j == n ) res = res + str [ i ] ; } return res ; } int main ( ) { string str = " geeksforgeeks " ; cout << removeDuplicates ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int value ( char x ) { return ( int ) ( x - ' a ' ) ; } string maximumProduct ( string str , int n ) { string answer = " " , curr = " " ; long long maxProduct = 0 , product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product *= 1LL * value ( str [ i ] ) ; curr += str [ i ] ; if ( product >= maxProduct ) { maxProduct = product ; answer = curr ; } if ( product == 0 ) { product = 1 ; curr = " " ; } } return answer ; } int main ( ) { string str = " sdtfakdhdahdzz " ; int n = str . size ( ) ; cout << maximumProduct ( str , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } int first_y_position = i - 1 ; int second_y_position = k - ( total - n + first_y_position ) ; for ( int j = 1 ; j < first_y_position ; j ++ ) cout << " x " ; cout << " y " ; int j = first_y_position + 1 ; while ( second_y_position > 1 ) { cout << " x " ; second_y_position -- ; j ++ ; } cout << " y " ; while ( j < n ) { cout << " x " ; j ++ ; } } int main ( ) { int n = 5 ; int k = 7 ; kthString ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int XorAscii ( string str , int len ) { int ans = int ( str [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( int ( str [ i ] ) ) ) ; } return ans ; } int main ( ) { string str = " geeksforgeeks " ; int len = str . length ( ) ; cout << XorAscii ( str , len ) << endl ; str = " GfG " ; len = str . length ( ) ; cout << XorAscii ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int productAtKthLevel ( string tree , int k , int & i , int level ) { if ( tree [ i ++ ] == ' ( ' ) { if ( tree [ i ] == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree [ i ] - '0' ; int leftproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; int rightproduct = productAtKthLevel ( tree , k , ++ i , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } } int main ( ) { string tree = " ( 0(5(6 ( ) ( ) ) ( 4 ( ) " " ( 9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) " ; int k = 2 ; int i = 0 ; cout << productAtKthLevel ( tree , k , i , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const string CHARS = " qwertyuiopasdfghjklzxcvbnm " ; const int MAX = 26 ; string getString ( string str , int n ) { unordered_map < char , char > uMap ; for ( int i = 0 ; i < MAX ; i ++ ) { uMap [ CHARS [ i ] ] = CHARS [ ( i + 1 ) % MAX ] ; } for ( int i = 0 ; i < n ; i ++ ) { str [ i ] = uMap [ str [ i ] ] ; } return str ; } int main ( ) { string str = " geeks " ; int n = str . length ( ) ; cout << getString ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const long MOD = 1000000007 ; long countStrings ( long N ) { long dp [ N + 1 ] [ 3 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } long ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; } int main ( ) { long N = 3 ; cout << countStrings ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string maxNumber ( string str , int n ) { int freq [ 2 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' z ' ) { freq [ 0 ] ++ ; } else if ( str [ i ] == ' n ' ) { freq [ 1 ] ++ ; } } string num = " " ; for ( int i = 0 ; i < freq [ 1 ] ; i ++ ) num += '1' ; for ( int i = 0 ; i < freq [ 0 ] ; i ++ ) num += '0' ; return num ; } int main ( ) { string str = " roenenzooe " ; int n = str . length ( ) ; cout << maxNumber ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { string String = " { [ ( ) ] } [ ] " ; vector < char > lst1 = { ' { ' , ' ( ' , ' [ ' } ; vector < char > lst2 = { ' } ' , ' ) ' , ' ] ' } ; vector < char > lst ; int k ; map < char , char > Dict ; Dict . insert ( pair < int , int > ( ' ) ' , ' ( ' ) ) ; Dict . insert ( pair < int , int > ( ' } ' , ' { ' ) ) ; Dict . insert ( pair < int , int > ( ' ] ' , ' [ ' ) ) ; int a = 0 , b = 0 , c = 0 ; if ( count ( lst2 . begin ( ) , lst2 . end ( ) , String [ 0 ] ) ) { cout << 1 << endl ; } else { for ( int i = 0 ; i < String . size ( ) ; i ++ ) { if ( count ( lst1 . begin ( ) , lst1 . end ( ) , String [ i ] ) ) { lst . push_back ( String [ i ] ) ; k = i + 2 ; } else { if ( lst . size ( ) == 0 && ( count ( lst2 . begin ( ) , lst2 . end ( ) , String [ i ] ) ) ) { cout << ( i + 1 ) << endl ; c = 1 ; break ; } else { if ( Dict [ String [ i ] ] == lst [ lst . size ( ) - 1 ] ) { lst . pop_back ( ) ; } else { break ; cout << ( i + 1 ) << endl ; a = 1 ; } } } } if ( lst . size ( ) == 0 && c == 0 ) { cout << 0 << endl ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { cout << k << endl ; } } return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  26 NEW_LINE using namespace std ; string encryptStr ( string str , int n , int x ) { x = x % MAX ; int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ str [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( str [ i ] - ' a ' + x ) % MAX ; str [ i ] = ( char ) ( pos + ' a ' ) ; } else { int pos = ( str [ i ] - ' a ' - x ) ; if ( pos < 0 ) { pos += MAX ; } str [ i ] = ( char ) ( pos + ' a ' ) ; } } return str ; } int main ( ) { string s = " abcda " ; int n = s . size ( ) ; int x = 3 ; cout << encryptStr ( s , n , x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOccurrence ( string s , int position ) { int alpha [ 26 ] = { 0 } , b [ s . size ( ) ] = { 0 } ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { b [ i ] = alpha [ ( int ) s [ i ] - 97 ] ; alpha [ ( int ) s [ i ] - 97 ] ++ ; } return b [ position - 1 ] ; } int main ( ) { string s = " ababababab " ; int p = 9 ; cout << countOccurrence ( s , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <time.h> NEW_LINE using namespace std ; int isPossible ( string str ) { unordered_map < char , int > freq ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ( ) ) ; j ++ ) { freq [ str [ j ] ] ++ ; if ( freq [ str [ j ] ] > max_freq ) max_freq = freq [ str [ j ] ] ; } if ( max_freq <= ( str . length ( ) - max_freq + 1 ) ) return true ; return false ; } int main ( ) { string str = " geeksforgeeks " ; if ( isPossible ( str ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUncommon ( string str1 , string str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = int ( str1 [ i ] ) - ' a ' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = int ( str2 [ i ] ) - ' a ' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { cout << char ( ' a ' + i ) ; } ans = ans / 2 ; i ++ ; } } int main ( ) { string str1 = " geeksforgeeks " ; string str2 = " geeksquiz " ; printUncommon ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cnt = 0 ; vector < int > graph [ 100 ] ; vector < string > weight ( 100 ) ; bool uniqueChars ( string x ) { map < char , int > mp ; int n = x . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) mp [ x [ i ] ] ++ ; if ( mp . size ( ) == x . size ( ) ) return true ; else return false ; } void dfs ( int node , int parent ) { if ( uniqueChars ( weight [ node ] ) ) cnt += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } } int main ( ) { weight [ 1 ] = " abc " ; weight [ 2 ] = " aba " ; weight [ 3 ] = " bcb " ; weight [ 4 ] = " moh " ; weight [ 5 ] = " aa " ; graph [ 1 ] . push_back ( 2 ) ; graph [ 2 ] . push_back ( 3 ) ; graph [ 2 ] . push_back ( 4 ) ; graph [ 1 ] . push_back ( 5 ) ; dfs ( 1 , 1 ) ; cout << cnt ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <stdio.h> NEW_LINE using namespace std ; bool check ( string s , int l ) { vector < int > pos ; for ( int i = 0 ; i < l ; i ++ ) { if ( s [ i ] == '1' ) pos . push_back ( i ) ; } int t = pos . size ( ) ; for ( int i = 1 ; i < t ; i ++ ) { if ( ( pos [ i ] - pos [ i - 1 ] ) != ( pos [ 1 ] - pos [ 0 ] ) ) return false ; } return true ; } int main ( ) { string s = "100010001000" ; int l = s . length ( ) ; if ( check ( s , l ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrefix ( string str , int len , int i , int k ) { if ( i + k > len ) return false ; for ( int j = 0 ; j < k ; j ++ ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; } return true ; } bool isKPeriodic ( string str , int len , int k ) { for ( int i = k ; i < len ; i += k ) if ( ! isPrefix ( str , len , i , k ) ) return false ; return true ; } int main ( ) { string str = " geeksgeeks " ; int len = str . length ( ) ; int k = 5 ; if ( isKPeriodic ( str , len , k ) ) cout << ( " Yes " ) ; else cout << ( " No " ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pangramCost ( int arr [ ] , string str ) { int cost = 0 ; bool occurred [ 26 ] = { false } ; for ( int i = 0 ; i < str . size ( ) ; i ++ ) occurred [ str [ i ] - ' a ' ] = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( ! occurred [ i ] ) cost += arr [ i ] ; } return cost ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 } ; string str = " abcdefghijklmopqrstuvwz " ; cout << pangramCost ( arr , str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( string s ) { int i , j ; int fr [ 26 ] = { 0 } ; int n = s . size ( ) ; for ( i = 0 ; i < n ; i ++ ) { char x = s [ i ] ; fr [ x - ' a ' ] += 1 ; } int minimum = INT_MAX ; for ( i = 0 ; i < 26 ; i ++ ) { for ( j = i + 1 ; j < 26 ; j ++ ) { int z = fr [ i ] + fr [ j ] ; minimum = min ( minimum , n - z ) ; } } return minimum ; } int main ( ) { string s = " geeksforgeeks " ; cout << check ( s ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string separateChar ( string str ) { int n = str . size ( ) , digitSum = 0 ; int alphabetSum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isdigit ( str [ i ] ) ) digitSum += str [ i ] - '0' ; else { alphabetSum += str [ i ] - ' a ' + 1 ; alphabetSum %= 26 ; } } string sumStr = to_string ( digitSum ) ; char alphabetStr = char ( alphabetSum + ' a ' - 1 ) ; sumStr += alphabetStr ; return sumStr ; } int main ( ) { string str = "3652adyz3423" ; cout << separateChar ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countWords ( string str ) { int count = 1 ; for ( int i = 1 ; i < str . length ( ) - 1 ; i ++ ) { if ( isupper ( str [ i ] ) ) count ++ ; } return count ; } int main ( ) { string str = " geeksForGeeks " ; cout << countWords ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( string s ) { int max = 0 , i , j = 0 , countk = 0 , countr = 0 ; int table [ s . length ( ) ] [ 2 ] ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ' R ' ) countr ++ ; else table [ j ++ ] [ 0 ] = countr ; } j -- ; for ( i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' K ' ) { countk ++ ; table [ j -- ] [ 1 ] = countk ; } if ( min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) > max ) max = min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) ; } return max ; } int main ( ) { string s = " RKRRRKKRRKKKKRR " ; int n = find ( s ) ; cout << ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int powerOfJump ( string s ) { int count = 1 ; int max_so_far = INT_MIN ; char ch = s [ s . length ( ) - 1 ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; } int main ( ) { string st = "1010101" ; cout << powerOfJump ( st ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string multiply ( string num1 , string num2 ) { int n1 = num1 . size ( ) ; int n2 = num2 . size ( ) ; if ( n1 == 0 n2 == 0 ) return "0" ; vector < int > result ( n1 + n2 , 0 ) ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 [ i ] - '0' ; i_n2 = 0 ; for ( int j = n2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 [ j ] - '0' ; int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . size ( ) - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == -1 ) return "0" ; string s = " " ; while ( i >= 0 ) s += std :: to_string ( result [ i -- ] ) ; return s ; } int main ( ) { string str1 = "454545454545454545" ; cout << multiply ( str1 , str1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool match_words ( string dictionary [ ] , string sentence [ ] , int n , int m ) { unordered_map < string , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ dictionary [ i ] ] ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( mp [ sentence [ i ] ] ) mp [ sentence [ i ] ] -= 1 ; else return false ; } return true ; } int main ( ) { string dictionary [ ] = { " find " , " a " , " geeks " , " all " , " for " , " on " , " geeks " , " answers " , " inter " } ; int n = sizeof ( dictionary ) / sizeof ( dictionary [ 0 ] ) ; string sentence [ ] = { " find " , " all " , " answers " , " on " , " geeks " , " for " , " geeks " } ; int m = sizeof ( sentence ) / sizeof ( sentence [ 0 ] ) ; if ( match_words ( dictionary , sentence , n , m ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_sub ( string s , int k ) { int len = s . length ( ) ; int lp = 0 , rp = 0 ; int ans = 0 ; int hash_char [ 26 ] = { 0 } ; for ( ; rp < len ; rp ++ ) { hash_char [ s [ rp ] - ' a ' ] ++ ; while ( hash_char [ s [ rp ] - ' a ' ] > k ) { hash_char [ s [ lp ] - ' a ' ] -- ; lp ++ ; } ans += rp - lp + 1 ; } return ans ; } int main ( ) { string s = " aaabb " ; int k = 2 ; cout << find_sub ( s , k ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool transformString ( string & s ) { char ch = ' a ' ; if ( s . size ( ) < 26 ) return false ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( int ( ch ) > int ( ' z ' ) ) break ; if ( s [ i ] <= ch ) { s [ i ] = ch ; ch = char ( int ( ch ) + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; } int main ( ) { string str = " aaaaaaaaaaaaaaaaaaaaaaaaaa " ; if ( transformString ( str ) ) cout << str << endl ; else cout << " Not ▁ Possible " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int i = 0 , j = str . size ( ) - 1 ; while ( i < j ) if ( str [ i ++ ] != str [ j -- ] ) return false ; return true ; } string removePalinWords ( string str ) { string final_str = " " , word = " " ; str = str + " ▁ " ; int n = str . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != ' ▁ ' ) word = word + str [ i ] ; else { if ( ! ( isPalindrome ( word ) ) ) final_str += word + " ▁ " ; word = " " ; } } return final_str ; } int main ( ) { string str = " Text ▁ contains ▁ malayalam ▁ and ▁ level ▁ words " ; cout << removePalinWords ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ASCIISentence ( std :: string str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str [ i ] - NULL ; cout << convert ; } } int main ( ) { string str = " GeeksforGeeks " ; cout << " ASCII ▁ Sentence : " << std :: endl ; ASCIISentence ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void convert ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . at ( i ) == ' ▁ ' ) str . at ( i ) = ' _ ' ; else str . at ( i ) = tolower ( str . at ( i ) ) ; } cout << str ; } int main ( ) { string str = " I ▁ got ▁ intern ▁ at ▁ geeksforgeeks " ; convert ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNextWord ( string s , int m ) { m += 97 ; int n = s . length ( ) ; int i = s . length ( ) - 1 ; s [ i ] ++ ; while ( i >= 0 && i <= n - 1 ) { if ( s [ i ] >= m ) { s [ i ] = ' a ' ; s [ -- i ] ++ ; } else if ( s [ i ] == s [ i - 1 ] s [ i ] == s [ i - 2 ] ) s [ i ] ++ ; else i ++ ; } if ( i <= -1 ) cout << " - 1" ; else cout << s ; } int main ( ) { string str = " abcd " ; int k = 4 ; findNextWord ( str , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string nextWord ( string s ) { if ( s == " " ) return " a " ; int i = s . length ( ) - 1 ; while ( s [ i ] == ' z ' && i >= 0 ) i -- ; if ( i == -1 ) s = s + ' a ' ; else s [ i ] ++ ; return s ; } int main ( ) { string str = " samez " ; cout << nextWord ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; int leastCount ( string s1 , string s2 , int n ) { int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { count1 [ s1 [ i ] - ' a ' ] += 1 ; count2 [ s2 [ i ] - ' a ' ] += 1 ; } int res = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count1 [ i ] != 0 ) { res += abs ( count1 [ i ] - count2 [ i ] ) ; } } return res ; } int main ( ) { string s1 = " abc " ; string s2 = " cdd " ; int len = s1 . length ( ) ; int res = leastCount ( s1 , s2 , len ) ; cout << res << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <stdlib.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; void printLCSubStr ( char * X , char * Y , int m , int n ) { int LCSuff [ m + 1 ] [ n + 1 ] ; int len = 0 ; int row , col ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; if ( len < LCSuff [ i ] [ j ] ) { len = LCSuff [ i ] [ j ] ; row = i ; col = j ; } } else LCSuff [ i ] [ j ] = 0 ; } } if ( len == 0 ) { cout << " No ▁ Common ▁ Substring " ; return ; } char * resultStr = ( char * ) malloc ( ( len + 1 ) * sizeof ( char ) ) ; while ( LCSuff [ row ] [ col ] != 0 ) { row -- ; col -- ; } cout << resultStr ; } int main ( ) { char X [ ] = " OldSite : GeeksforGeeks . org " ; char Y [ ] = " NewSite : GeeksQuiz . com " ; int m = strlen ( X ) ; int n = strlen ( Y ) ; printLCSubStr ( X , Y , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int substringConversions ( string str , int k , int b ) { for ( int i = 0 ; i + k <= str . size ( ) ; i ++ ) { string sub = str . substr ( i , k ) ; int sum = 0 , counter = 0 ; for ( int i = sub . size ( ) - 1 ; i >= 0 ; i -- ) { sum = sum + ( ( sub . at ( i ) - '0' ) * pow ( b , counter ) ) ; counter ++ ; } cout << sum << " ▁ " ; } } int main ( ) { string str = "12212" ; int b = 3 , k = 3 ; substringConversions ( str , b , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; bool checkCorrectOrNot ( string s ) { int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s [ i ] - ' a ' ] ++ ; count2 [ s [ j ] - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; } int main ( ) { string s = " abab " ; if ( checkCorrectOrNot ( s ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int remainderWith7 ( string num ) { int series [ ] = { 1 , 3 , 2 , -1 , -3 , -2 } ; int series_index = 0 ; for ( int i = num . size ( ) - 1 ; i >= 0 ; i -- ) { int digit = num [ i ] - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; } int main ( ) { string str = "12345" ; cout << " Remainder ▁ with ▁ 7 ▁ is ▁ " << remainderWith7 ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int CHARS = 26 ; bool isValidString ( string str ) { int freq [ CHARS ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) count_freq1 ++ ; else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) count_freq1 ++ ; if ( freq [ k ] == freq2 ) count_freq2 ++ ; return false ; } if ( count_freq1 > 1 && count_freq2 > 1 ) return false ; } return true ; } int main ( ) { char str [ ] = " abcbc " ; if ( isValidString ( str ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isReversible ( string str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; } int main ( ) { string str = " aba " ; if ( isReversible ( str ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string encodeString ( string str ) { unordered_map < char , int > map ; string res = " " ; int i = 0 ; for ( char ch : str ) { if ( map . find ( ch ) == map . end ( ) ) map [ ch ] = i ++ ; res += to_string ( map [ ch ] ) ; } return res ; } void findMatchedWords ( unordered_set < string > dict , string pattern ) { int len = pattern . length ( ) ; string hash = encodeString ( pattern ) ; for ( string word : dict ) { if ( word . length ( ) == len && encodeString ( word ) == hash ) cout << word << " ▁ " ; } } int main ( ) { unordered_set < string > dict = { " abb " , " abc " , " xyz " , " xyy " } ; string pattern = " foo " ; findMatchedWords ( dict , pattern ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string pattern , string word ) { if ( pattern . length ( ) != word . length ( ) ) return false ; char ch [ 128 ] = { 0 } ; int len = word . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( ch [ pattern [ i ] ] == 0 ) ch [ pattern [ i ] ] = word [ i ] ; else if ( ch [ pattern [ i ] ] != word [ i ] ) return false ; } return true ; } void findMatchedWords ( unordered_set < string > dict , string pattern ) { int len = pattern . length ( ) ; for ( string word : dict ) { if ( check ( pattern , word ) ) cout << word << " ▁ " ; } } int main ( ) { unordered_set < string > dict = { " abb " , " abc " , " xyz " , " xyy " } ; string pattern = " foo " ; findMatchedWords ( dict , pattern ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string intToRoman ( int num ) { string m [ ] = { " " , " M " , " MM " , " MMM " } ; string c [ ] = { " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM " } ; string x [ ] = { " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " } ; string i [ ] = { " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " } ; string thousands = m [ num / 1000 ] ; string hundereds = c [ ( num % 1000 ) / 100 ] ; string tens = x [ ( num % 100 ) / 10 ] ; string ones = i [ num % 10 ] ; string ans = thousands + hundereds + tens + ones ; return ans ; } int main ( ) { int number = 3549 ; cout << intToRoman ( number ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string zigZagConcat ( string s , int n ) { if ( n <= 1 ) { return s ; } string result = " " ; for ( int rowNum = 0 ; rowNum < n ; rowNum ++ ) { int i = rowNum ; bool up = true ; while ( i < s . length ( ) ) { result += s [ i ] ; if ( rowNum == 0 rowNum == n - 1 ) { i += ( 2 * n - 2 ) ; } else { if ( up ) { i += ( 2 * ( n - rowNum ) - 2 ) ; } else { i += rowNum * 2 ; } up ^= true ; } } } return result ; } int main ( ) { string str = " GEEKSFORGEEKS " ; int n = 3 ; cout << zigZagConcat ( str , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumXOR ( int arr [ ] , int n , int K ) { K ++ ; int maxXor = INT_MIN ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { if ( __builtin_popcount ( i ) == K ) { int cur_xor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( i & ( 1 << j ) ) cur_xor = cur_xor ^ arr [ j ] ; } maxXor = max ( maxXor , cur_xor ) ; } } return maxXor ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int M = 2 ; cout << maximumXOR ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void TowerOfHanoi ( int N ) { for ( int x = 1 ; x <= pow ( 2 , N ) - 1 ; x ++ ) { cout << " Move ▁ from ▁ Rod ▁ " << ( ( x & x - 1 ) % 3 + 1 ) << " ▁ to ▁ Rod ▁ " << ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) << endl ; } } int main ( ) { int N = 3 ; TowerOfHanoi ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( vector < vector < int > > & board , int i , int j , int K ) { if ( board [ i ] [ j ] <= K ) { return true ; } return false ; } bool findPath ( vector < vector < int > > & board , int X , int Y , int M , int N , int K ) { if ( X < 0 X == M Y < 0 Y == N ) { return true ; } if ( isValid ( board , X , Y , K ) ) { int board_XY = board [ X ] [ Y ] ; board [ X ] [ Y ] = INT_MAX ; if ( findPath ( board , X + 1 , Y , M , N , K - board_XY ) || findPath ( board , X - 1 , Y , M , N , K - board_XY ) || findPath ( board , X , Y + 1 , M , N , K - board_XY ) || findPath ( board , X , Y - 1 , M , N , K - board_XY ) ) { return true ; } board [ X ] [ Y ] = board_XY ; } return false ; } int main ( ) { vector < vector < int > > grid = { { 25 , 5 , 25 , 25 , 25 , 25 } , { 25 , 1 , 1 , 5 , 12 , 25 } , { 25 , 1 , 12 , 0 , 15 , 25 } , { 22 , 1 , 11 , 2 , 19 , 15 } , { 25 , 2 , 2 , 1 , 12 , 15 } , { 25 , 9 , 10 , 1 , 11 , 25 } , { 25 , 25 , 25 , 25 , 25 , 25 } } ; int K = 17 ; int M = grid . size ( ) ; int N = grid [ 0 ] . size ( ) ; int X = 2 , Y = 3 ; if ( findPath ( grid , X , Y , M , N , K ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int & N , int & P1 , int & P2 , int & X , bool Move , bool QuitP1 , bool QuitP2 ) { if ( N == 0 or ( QuitP1 and QuitP2 ) ) { cout << " Number ▁ of ▁ pens ▁ remaining " << " ▁ in ▁ the ▁ box : ▁ " << N << endl ; cout << " Number ▁ of ▁ pens ▁ collected " << " ▁ by ▁ P1 : ▁ " << P1 << endl ; cout << " Number ▁ of ▁ pens ▁ collected " << " ▁ by ▁ P2 : ▁ " << P2 << endl ; return ; } if ( Move == 0 and QuitP1 == false ) { int req_P1 = pow ( 2 , X ) ; if ( req_P1 <= N ) { P1 += req_P1 ; N -= req_P1 ; } else { QuitP1 = true ; } } else if ( Move == 1 and QuitP2 == false ) { int req_P2 = pow ( 3 , X ) ; if ( req_P2 <= N ) { P2 += req_P2 ; N -= req_P2 ; } else { QuitP2 = true ; } } X ++ ; Move = ( ( Move == 1 ) ? 0 : 1 ) ; solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) ; } void PenGame ( int N ) { int P1 = 0 ; int P2 = 0 ; int X = 0 ; bool Move = 0 ; bool QuitP1 = 0 ; bool QuitP2 = 0 ; solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) ; } int main ( ) { int N = 22 ; PenGame ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canPlace ( int a [ ] , int n , int p , int sep ) { int prisoners_placed = 1 ; int last_prisoner_placed = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int current_cell = a [ i ] ; if ( current_cell - last_prisoner_placed >= sep ) { prisoners_placed ++ ; last_prisoner_placed = current_cell ; if ( prisoners_placed == p ) { return true ; } } } return false ; } int maxDistance ( int cell [ ] , int n , int p ) { sort ( cell , cell + n ) ; int start = 0 ; int end = cell [ n - 1 ] - cell [ 0 ] ; int ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( canPlace ( cell , n , p , mid ) ) { ans = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; } int main ( ) { int cell [ ] = { 1 , 2 , 8 , 4 , 9 } ; int n = sizeof ( cell ) / sizeof ( int ) ; int p = 3 ; cout << maxDistance ( cell , n , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxLen  30 NEW_LINE int seg [ 3 * maxLen ] ; int build ( int l , int r , int in , int * arr ) { if ( l == r ) return seg [ in ] = arr [ l ] ; int mid = ( l + r ) / 2 ; return seg [ in ] = __gcd ( build ( l , mid , 2 * in + 1 , arr ) , build ( mid + 1 , r , 2 * in + 2 , arr ) ) ; } int query ( int l , int r , int l1 , int r1 , int in ) { if ( l1 <= l and r <= r1 ) return seg [ in ] ; if ( l > r1 or r < l1 ) return 0 ; int mid = ( l + r ) / 2 ; return __gcd ( query ( l , mid , l1 , r1 , 2 * in + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * in + 2 ) ) ; } int findLen ( int * arr , int n ) { build ( 0 , n - 1 , 0 , arr ) ; int i = 0 , j = 0 ; int ans = INT_MAX ; while ( i < n ) { while ( j < n and query ( 0 , n - 1 , i , j , 0 ) != 1 ) j ++ ; if ( j == n ) break ; ans = min ( ( j - i + 1 ) , ans ) ; i ++ ; j = max ( j , i ) ; } if ( ans == INT_MAX ) return -1 ; else return ans ; } int main ( ) { int arr [ ] = { 2 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findLen ( arr , n ) ; return 0 ; }
#include <iomanip> NEW_LINE #include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void findArea ( double a , double b , double c ) { double area = 4 * 3.141592653 * pow ( ( pow ( a * b , 1.6 ) + pow ( a * c , 1.6 ) + pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; cout << fixed << setprecision ( 2 ) << area ; } int main ( ) { double A = 11 , B = 12 , C = 13 ; findArea ( A , B , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double findRadius ( double r1 , double r2 , double r3 ) { double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 ; } int main ( ) { double r1 = 1 ; double r2 = 1 ; double r3 = 1 ; double r4 = findRadius ( r1 , r2 , r3 ) ; cout << " The ▁ radius ▁ of ▁ fourth ▁ circle : ▁ " << r4 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumRectangleArea ( int A [ ] , int N ) { int ans ; sort ( A , A + 2 * N ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; } int main ( ) { int A [ ] = { 2 , 4 , 1 , 5 , 3 , 6 , 7 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; N /= 2 ; cout << minimumRectangleArea ( A , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return sqrt ( r ) ; } int main ( ) { double A = 3.0 , B = 2.0 ; cout << eccHyperbola ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; } int main ( ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; cout << calculateArea ( A , B , C , D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalCircles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; } int main ( ) { int L = 3 ; int B = 8 ; cout << totalCircles ( L , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double findRadius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = sqrt ( a3 / 3.14 ) ; return r3 ; } int main ( ) { double r1 = 8 , r2 = 6 ; cout << findRadius ( r1 , r2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_lcm ( int a , int b , int c ) { int g = __gcd ( a , b ) ; int LCM1 = ( a * b ) / g ; g = __gcd ( LCM1 , c ) ; int LCM = ( LCM1 * c ) / g ; return LCM ; } void minimumCuboids ( int L , int B , int H ) { int lcm = find_lcm ( L , B , H ) ; int volume_cube = lcm * lcm * lcm ; int volume_cuboid = L * B * H ; cout << ( volume_cube / volume_cuboid ) ; } int main ( ) { int L = 1 , B = 1 , H = 2 ; minimumCuboids ( L , B , H ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CrossProduct ( vector < vector < int > > & A ) { int X1 = ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y1 = ( A [ 1 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; int X2 = ( A [ 2 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y2 = ( A [ 2 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; return ( X1 * Y2 - Y1 * X2 ) ; } bool isConvex ( vector < vector < int > > & points ) { int N = points . size ( ) ; int prev = 0 ; int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { vector < vector < int > > temp = { points [ i ] , points [ ( i + 1 ) % N ] , points [ ( i + 2 ) % N ] } ; curr = CrossProduct ( temp ) ; if ( curr != 0 ) { if ( curr * prev < 0 ) { return false ; } else { prev = curr ; } } } return true ; } int main ( ) { vector < vector < int > > points = { { 0 , 0 } , { 0 , 1 } , { 1 , 1 } , { 1 , 0 } } ; if ( isConvex ( points ) ) { cout << " Yes " << " STRNEWLINE " ; } else { cout << " No " << " STRNEWLINE " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double distance ( int r , int R ) { double d = sqrt ( pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; } int main ( ) { int r = 2 ; int R = 5 ; cout << ( round ( distance ( r , R ) * 100.0 ) / 100.0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double minAnglRot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; } int main ( ) { int N = 4 ; cout << " Angle ▁ of ▁ Rotational ▁ Symmetry : ▁ " << minAnglRot ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double Area_of_Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * sqrt ( x ) ; return area ; } int main ( ) { int a = 9 ; int b = 12 ; int c = 15 ; double ans = Area_of_Triangle ( a , b , c ) ; cout << ans ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isTridecagon ( int N ) { float n = ( 9 + sqrt ( 88 * N + 81 ) ) / 22 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int i = 13 ; if ( isTridecagon ( i ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkOverlap ( int R , int Xc , int Yc , int X1 , int Y1 , int X2 , int Y2 ) { int Xn = max ( X1 , min ( Xc , X2 ) ) ; int Yn = max ( Y1 , min ( Yc , Y2 ) ) ; int Dx = Xn - Xc ; int Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; } int main ( ) { int R = 1 ; int Xc = 0 , Yc = 0 ; int X1 = 1 , Y1 = -1 ; int X2 = 3 , Y2 = 1 ; if ( checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) ) { cout << " True " << endl ; } else { cout << " False " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkIntersection ( pair < int , int > p1 , pair < int , int > p2 , pair < int , int > p ) { int val ; if ( p1 . second == p2 . second && p1 . second == p . second ) { if ( p . first <= max ( p1 . first , p2 . first ) && ( p . first >= min ( p1 . first , p2 . first ) ) ) return 1 ; } if ( p1 . first == p2 . first && p1 . first == p . first ) { if ( p . second <= max ( p1 . second , p2 . second ) && ( p . second >= min ( p1 . second , p2 . second ) ) ) return 1 ; } else { val = ( p . second - p1 . second ) * ( p2 . first - p1 . first ) - ( p . first - p1 . first ) * ( p2 . second - p1 . second ) ; if ( val == 0 ) if ( ( p . first <= max ( p1 . first , p2 . first ) && ( p . first >= min ( p1 . first , p2 . first ) ) ) && ( p . second <= max ( p1 . second , p2 . second ) && ( p . second >= min ( p1 . second , p2 . second ) ) ) ) return 1 ; } return 0 ; } void towerOfSight ( pair < int , int > a , pair < int , int > b , pair < int , int > c , pair < int , int > d ) { int flag = 0 ; if ( checkIntersection ( a , c , b ) ) flag = 1 ; else if ( checkIntersection ( a , c , d ) ) flag = 1 ; else if ( checkIntersection ( b , d , a ) ) flag = 1 ; else if ( checkIntersection ( b , d , c ) ) flag = 1 ; flag ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; } int main ( ) { pair < int , int > a = { 0 , 0 } ; pair < int , int > b = { 0 , -2 } ; pair < int , int > c = { 2 , 0 } ; pair < int , int > d = { 0 , 2 } ; towerOfSight ( a , b , c , d ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; } int main ( ) { int R = 7 ; cout << ( area ( R ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int * P , int * Q , int N , int M ) { int A [ 2 ] = { 0 } , B [ 2 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } int main ( ) { int P [ ] = { 1 , 3 , 2 } , Q [ ] = { 3 , 0 } ; int N = sizeof ( P ) / sizeof ( P [ 0 ] ) ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; cout << countPairs ( P , Q , N , M ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void new_vol ( double x ) { if ( x > 0 ) { cout << " % ▁ change ▁ in ▁ the ▁ " << " volume ▁ of ▁ the ▁ hemisphere : ▁ " << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << " % " << " ▁ increase STRNEWLINE " ; } else if ( x < 0 ) { cout << " % ▁ change ▁ in ▁ the ▁ " << " volume ▁ of ▁ the ▁ hemisphere : ▁ " << pow ( x , 3 ) / 10000 + 3 * x + ( 3 * pow ( x , 2 ) ) / 100 << " % ▁ decrease STRNEWLINE " ; } else { cout << " Volume ▁ remains ▁ the ▁ same . " ; } } int main ( ) { double x = -10.0 ; new_vol ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << countIntersections ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Area ( int d , int h1 , int h2 ) { float area ; area = 0.5 * d * ( h1 + h2 ) ; return area ; } int main ( ) { int d = 6 , h1 = 4 , h2 = 3 ; cout << " Area ▁ of ▁ Quadrilateral ▁ = ▁ " << ( Area ( d , h1 , h2 ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void angleextcycquad ( int z ) { cout << " The ▁ exterior ▁ angle ▁ of ▁ the " << " ▁ cyclic ▁ quadrilateral ▁ is ▁ " << z << " ▁ degrees " << endl ; } int main ( ) { int z = 48 ; angleextcycquad ( z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isPerfect ( int N ) { int sumOfDivisors = 1 ; for ( int i = 2 ; i <= N / 2 ; ++ i ) { if ( N % i == 0 ) { sumOfDivisors += i ; } } if ( sumOfDivisors == N ) { return 1 ; } else return 0 ; } int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += ( N % 10 ) ; N = N / 10 ; } return sum ; } void countPerfectNumbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; ++ i ) { if ( isPerfect ( arr [ i ] ) ) { int sum = sumOfDigits ( arr [ i ] ) ; if ( isPerfect ( sum ) ) { cout << arr [ i ] << " ▁ " ; } } } } int main ( ) { int arr [ ] = { 3 , 8 , 12 , 28 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPerfectNumbers ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void fizzBuzz ( int N ) { int count3 = 0 ; int count5 = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count3 ++ ; count5 ++ ; bool flag = false ; if ( count3 == 3 ) { cout << " Fizz " ; count3 = 0 ; flag = true ; } if ( count5 == 5 ) { cout << " Buzz " ; count5 = 0 ; flag = true ; } if ( ! flag ) { cout << i ; } cout << " ▁ " ; } } int main ( ) { int N = 15 ; fizzBuzz ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; } int main ( ) { int arr [ ] = { -4 , -3 , 0 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfTiles ( int N , int M ) { if ( N % 2 == 1 ) { return -1 ; } return ( N * 1LL * M ) / 2 ; } int main ( ) { int N = 2 , M = 4 ; cout << numberOfTiles ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkSamePosition ( int arr [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . find ( temp ) != mp . end ( ) ) { cout << " Yes " ; return ; } mp [ temp ] ++ ; } cout << " No " ; } int main ( ) { int arr [ ] = { 5 , 4 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkSamePosition ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int convertToASCII ( int N ) { string num = to_string ( N ) ; for ( char ch : num ) { cout << ch << " ▁ ( " << ( int ) ch << " ) STRNEWLINE " ; } } int main ( ) { int N = 36 ; convertToASCII ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkPossible ( int * arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { cout << " No STRNEWLINE " ; return ; } else { arr [ i ] -= arr [ i - 1 ] ; arr [ i - 1 ] = 0 ; } } if ( arr [ n - 1 ] == 0 ) { cout << " Yes STRNEWLINE " ; } else { cout << " No STRNEWLINE " ; } } int main ( ) { int arr [ ] = { 2 , 3 , 3 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkPossible ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } cout << res ; } int main ( ) { int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; singleDigitSubarrayCount ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int Fact ( int N ) { long long int result = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { result = ( result * i ) ; } return result ; } void numberOfWays ( int M , int arr [ ] , int N ) { int B [ M ] = { 0 } ; int counter [ M + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) { if ( B [ i % M ] == 0 ) { B [ i % M ] = arr [ i ] ; counter [ arr [ i ] ] ++ ; if ( counter [ arr [ i ] ] > 1 ) { cout << 0 << endl ; return ; } } else if ( B [ i % M ] != arr [ i ] ) { cout << 0 << endl ; return ; } } } int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( B [ i ] == 0 ) { cnt ++ ; } } cout << Fact ( cnt ) << endl ; } int main ( ) { int M = 4 ; int arr [ ] = { 1 , 0 , 3 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; numberOfWays ( M , arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long ll ; void noOfArraysPossible ( ll N , ll M ) { ll ans = 1 ; for ( ll i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } cout << ans ; } int main ( ) { ll N = 2 , M = 3 ; noOfArraysPossible ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumOperationReq ( int N ) { int cntDecr = 0 ; int temp = N ; while ( temp > 0 ) { int X = sqrt ( temp ) ; if ( X * X == temp ) { break ; } temp = temp - 2 ; cntDecr += 1 ; } int cntIncr = 0 ; while ( true ) { int X = sqrt ( N ) ; if ( X * X == N ) { break ; } N = N + 2 ; cntIncr += 1 ; } return min ( cntIncr , cntDecr ) ; } int main ( ) { int N = 15 ; cout << MinimumOperationReq ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxDisconnected ( int N , int E ) { int curr = 1 ; int rem = E ; while ( rem > 0 ) { rem = rem - min ( curr , rem ) ; curr ++ ; } if ( curr > 1 ) { return N - curr ; } else { return N ; } } int main ( ) { int N = 5 , E = 1 ; cout << maxDisconnected ( N , E ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } string deleteIth ( string str , int i ) { str . erase ( str . begin ( ) + i ) ; return str ; } bool isPrimePossible ( int N ) { string s = to_string ( N ) ; int l = s . length ( ) ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l ; i ++ ) { string str = deleteIth ( s , i ) ; int num = stoi ( str ) ; if ( isPrime ( num ) ) return true ; } return false ; } int main ( ) { int N = 610 ; isPrimePossible ( N ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Find_min ( set < int > & diff_mod , map < int , int > count_mod , int k ) { int min_oprn = INT_MAX ; int oprn = 0 ; for ( int x = 0 ; x < k ; x ++ ) { oprn = 0 ; for ( auto w : diff_mod ) { if ( w != x ) { if ( w == 0 ) { oprn += min ( x , k - x ) * count_mod [ w ] ; } else { oprn += min ( abs ( x - w ) , k + x - w ) * count_mod [ w ] ; } } } if ( oprn < min_oprn ) min_oprn = oprn ; } return min_oprn ; } int Cal_min ( int arr [ ] , int n , int k ) { set < int > diff_mod ; map < int , int > count_mod ; for ( int i = 0 ; i < n ; i ++ ) { diff_mod . insert ( arr [ i ] % k ) ; count_mod [ arr [ i ] % k ] ++ ; } return Find_min ( diff_mod , count_mod , k ) ; } int main ( ) { int arr [ ] = { 2 , 35 , 48 , 23 , 52 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << Cal_min ( arr , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void inverseEqual ( int arr [ ] , int n ) { int brr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int present_index = arr [ i ] - 1 ; brr [ present_index ] = i + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != brr [ i ] ) { cout << " No " << endl ; return ; } } cout << " Yes " << endl ; } int main ( ) { int n = 4 ; int arr [ n ] = { 1 , 4 , 3 , 2 } ; inverseEqual ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int SquareRoot ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; } int main ( ) { int N = 81 ; cout << SquareRoot ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) cout << " No " << endl ; else if ( ( n & 1 ) or n == 2 ) cout << " Yes " << endl ; else { int tmp = n ; int val = 1 ; while ( tmp > k and tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) cout << " No " << endl ; else if ( n / tmp == 2 and cnt == 1 ) cout << " No " << endl ; else cout << " Yes " << endl ; } } int main ( ) { long long n = 1 , k = 1 ; findWinner ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_crazy_primes ( int L , int R ) { int prime [ R + 1 ] = { 0 } ; int countPrime [ R + 1 ] = { 0 } ; int freqPrime [ R + 1 ] = { 0 } ; prime [ 0 ] = prime [ 1 ] = 1 ; for ( int p = 2 ; p * p <= R ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * p ; i <= R ; i += p ) prime [ i ] = 1 ; } } for ( int i = 1 ; i <= R ; i ++ ) { countPrime [ i ] = countPrime [ i - 1 ] ; if ( ! prime [ i ] ) { countPrime [ i ] ++ ; } } for ( int i = 1 ; i <= R ; i ++ ) { freqPrime [ i ] = freqPrime [ i - 1 ] ; if ( ! prime [ countPrime [ i ] ] ) { freqPrime [ i ] ++ ; } } return ( freqPrime [ R ] - freqPrime [ L - 1 ] ) ; } int main ( ) { int L = 4 , R = 12 ; cout << count_crazy_primes ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void compute ( int a [ ] , int N , int K ) { map < long , long > eqVal ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . find ( val ) != eqVal . end ( ) ) { long numVal = eqVal [ val ] ; maxX = max ( maxX , val + ( K * numVal ) ) ; eqVal [ val ] ++ ; } else { eqVal [ val ] ++ ; maxX = max ( maxX , val ) ; } } cout << ( maxX == 0 ? 0 : maxX + 1 ) << endl ; } int main ( ) { int K = 3 ; int a [ ] = { 1 , 2 , 2 , 18 } ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; compute ( a , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } bool isSelfNum ( int n ) { for ( int m = 1 ; m <= n ; m ++ ) { if ( m + getSum ( m ) == n ) return false ; } return true ; } int main ( ) { int n = 20 ; if ( isSelfNum ( n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int seriesSumUtil ( int k , int n , int prevSum , int multi , int add ) { if ( k == n + 1 ) { return prevSum ; } multi = multi * k ; add = add + k ; prevSum = prevSum + multi - add ; return seriesSumUtil ( k + 1 , n , prevSum , multi , add ) ; } int seriesSum ( int n ) { if ( n == 1 ) return 0 ; int prevSum = 0 ; int multi = 1 ; int add = 1 ; return seriesSumUtil ( 2 , n , prevSum , multi , add ) ; } int main ( ) { int N = 5 ; cout << seriesSum ( N ) << " ▁ " ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } void smallestNumber ( int N ) { int i = 1 ; while ( 1 ) { if ( getSum ( i ) == N ) { cout << i ; break ; } i ++ ; } } int main ( ) { int N = 10 ; smallestNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool iszygodromeNum ( int N ) { string s = to_string ( N ) ; s = ' ▁ ' + s + ' ▁ ' ; for ( int i = 1 ; i < s . size ( ) - 1 ; i ++ ) { if ( s [ i ] != s [ i - 1 ] && s [ i ] != s [ i + 1 ] ) { return false ; } } return true ; } int main ( ) { int n = 1122 ; if ( iszygodromeNum ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int canReplace ( int array [ ] , int n ) { int i = 0 , count = 0 ; while ( i < n ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == n - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; } int main ( ) { int array [ 5 ] = { 1 , 0 , 0 , 0 , 1 } ; cout << canReplace ( array , 5 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << MegagonNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int TetracontaoctagonalNum ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << TetracontaoctagonalNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findIndex ( int n ) { float x = sqrt ( 2 * pow ( 10 , ( n - 1 ) ) ) ; return round ( x ) ; } int main ( ) { int n = 3 ; cout << findIndex ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void smallestNumber ( int N ) { cout << N * floor ( ( pow ( 10 , N ) - 1 ) / N ) ; } int main ( ) { int N = 2 ; smallestNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int icosikaiheptagonalNum ( int n ) { return ( 25 * n * n - 23 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << "3rd ▁ icosikaiheptagonal ▁ Number ▁ is ▁ " << icosikaiheptagonalNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool istriacontagonal ( int N ) { float n = ( 26 + sqrt ( 224 * N + 676 ) ) / 56 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int i = 30 ; if ( istriacontagonal ( i ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Maxlength ( int arr [ ] , int N ) { vector < int > zeroindex ; int maxlen ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zeroindex . push_back ( i ) ; } if ( zeroindex . size ( ) == 0 ) { maxlen = N ; } else { maxlen = zeroindex [ 0 ] ; for ( int i = 0 ; i < zeroindex . size ( ) - 1 ; i ++ ) { if ( zeroindex [ i + 1 ] - zeroindex [ i ] - 1 > maxlen ) { maxlen = zeroindex [ i + 1 ] - zeroindex [ i ] - 1 ; } } if ( N - zeroindex [ zeroindex . size ( ) - 1 ] - 1 > maxlen ) { maxlen = N - zeroindex [ zeroindex . size ( ) - 1 ] - 1 ; } } cout << maxlen << endl ; } int main ( ) { int N = 9 ; int arr [ ] = { 7 , 1 , 0 , 1 , 2 , 0 , 9 , 2 , 1 } ; Maxlength ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int n ) { for ( int x = 1 ; x <= sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { int small = x ; int big = n / x ; if ( small % 2 == big % 2 ) { int a = ( small + big ) / 2 ; int b = ( big - small ) / 2 ; cout << a << " ▁ " << b << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { int n = 7 ; solve ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } int derivative ( int x ) { return 3 * x * x ; } int Image ( int x , int k ) { return x * x * x - k ; } int next_power ( int a_t , int t , int a1 , int prime , int k ) { int power_p = ( int ) pow ( prime , t + 1 ) ; int next_a = ( a_t - Image ( a_t , k ) * inv ( derivative ( a1 ) , prime ) ) % power_p ; if ( next_a < 0 ) return next_a += power_p ; return next_a ; } int powerOfPrime ( int prime , int power , int k , int a1 ) { if ( derivative ( a1 ) != 0 ) { int a_t = a1 ; for ( int p = 1 ; p < power ; p ++ ) { a_t = next_power ( a_t , p , a1 , prime , k ) ; } return a_t ; } return -1 ; } int main ( ) { int prime = 7 , a1 = 3 ; int power = 2 , k = 3 ; cout << powerOfPrime ( prime , power , k , a1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << productPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinSteps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; } int main ( ) { int N = 6 , K = 3 ; cout << getMinSteps ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCenterednonadecagonal ( int N ) { float n = ( 19 + sqrt ( 152 * N + 209 ) ) / 38 ; return ( n - ( int ) n ) == 0 ; } int main ( ) { int n = 20 ; if ( isCenterednonadecagonal ( n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void cntArray ( int A [ ] , int N ) { int result = 0 ; int frequency [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { int frequency_of_i = frequency [ i ] ; result += + ( ( frequency_of_i ) * ( frequency_of_i + 1 ) ) / 2 ; } cout << result << endl ; } int main ( ) { int A [ ] = { 1 , 5 , 6 , 1 , 9 , 5 , 8 , 10 , 8 , 9 } ; int N = sizeof ( A ) / sizeof ( int ) ; cntArray ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int subarray ( int arr [ ] , int n ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = max ( ans , temp ) ; temp = 1 ; } } ans = max ( ans , temp ) ; return ans ; } int main ( ) { int arr [ ] = { 2 , 2 , 1 , 1 , 2 , 2 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subarray ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void findMaxMinSubArray ( int arr [ ] , int K , int n ) { int min = n ; int max = 0 ; int left ; int right ; int tmp ; for ( int i = 0 ; i < n ; i ++ ) { tmp = 1 ; left = i ; while ( left - 1 >= 0 && abs ( arr [ left ] - arr [ left - 1 ] ) <= K ) { left -- ; tmp ++ ; } right = i ; while ( right + 1 <= n - 1 && abs ( arr [ right ] - arr [ right + 1 ] ) <= K ) { right ++ ; tmp ++ ; } if ( min > tmp ) min = tmp ; if ( max < tmp ) max = tmp ; } cout << min << " , ▁ " << max << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 6 , 7 } ; int K = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMaxMinSubArray ( arr , K , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSteps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return -1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; } int main ( ) { int a = 75 ; int b = 17 ; cout << minimumSteps ( a , b , 0 ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } int countSquares ( int n ) { int cnt = 0 ; for ( int i = pow ( 10 , ( n - 1 ) ) ; i < pow ( 10 , n ) ; i ++ ) { if ( i != 0 && isPerfectSquare ( i ) ) cnt ++ ; } return cnt ; } int main ( ) { int n = 3 ; cout << countSquares ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool printArr ( int n ) { if ( n % 4 == 0 ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) cout << i * 2 << ' ▁ ' ; for ( int i = 1 ; i < n / 2 ; i ++ ) cout << i * 2 - 1 << ' ▁ ' ; cout << n + n / 2 - 1 << ' ' ; } else cout << " - 1" ; } int main ( ) { int n = 22 ; printArr ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double CgpaCalc ( double marks [ ] , int n ) { double grade [ n ] ; double cgpa , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { grade [ i ] = ( marks [ i ] / 10 ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += grade [ i ] ; } cgpa = sum / n ; return cgpa ; } int main ( ) { int n = 5 ; double marks [ ] = { 90 , 80 , 70 , 80 , 90 } ; double cgpa = CgpaCalc ( marks , n ) ; cout << " CGPA ▁ = ▁ " ; printf ( " % .1f STRNEWLINE " , cgpa ) ; cout << " CGPA ▁ Percentage ▁ = ▁ " ; printf ( " % .2f " , cgpa * 9.5 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkGoldenRatio ( float a , float b ) { if ( a <= b ) { float temp = a ; a = b ; b = temp ; } std :: stringstream ratio1 ; ratio1 << std :: fixed << std :: setprecision ( 3 ) << ( a / b ) ; std :: stringstream ratio2 ; ratio2 << std :: fixed << std :: setprecision ( 3 ) << ( a + b ) / a ; if ( ( ratio1 . str ( ) == ratio2 . str ( ) ) && ratio1 . str ( ) == "1.618" ) { cout << " Yes " << endl ; return true ; } else { cout << " No " << endl ; return false ; } } int main ( ) { float a = 0.618 ; float b = 1 ; checkGoldenRatio ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; int minNum ( int n , int k ) { int x = ( int ) ( log ( n ) / log ( k ) ) + 1 ; int mn = pow ( k , x ) - n ; return mn ; } int main ( ) { int n = 20 , k = 5 ; cout << minNum ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CntcontSubs ( int a [ ] , int n ) { int prod = 1 ; vector < pair < int , int > > vect ; vect . push_back ( make_pair ( 0 , 2 ) ) ; vector < int > two , zero ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] % 4 ; if ( a [ i ] < 0 ) a [ i ] = a [ i ] + 4 ; if ( a [ i ] == 2 ) two . push_back ( i + 1 ) ; if ( a [ i ] == 0 ) zero . push_back ( i + 1 ) ; if ( a [ i ] == 0 a [ i ] == 2 ) vect . push_back ( make_pair ( i + 1 , a [ i ] ) ) ; } vect . push_back ( make_pair ( n + 1 , 2 ) ) ; int total = ( n * ( n + 1 ) ) / 2 ; if ( two . empty ( ) ) return total ; else { int sum = 0 ; int pos1 = -1 , pos2 = -1 , pos3 = -1 ; int sz = vect . size ( ) ; for ( int i = 1 ; i + 1 < sz ; i ++ ) { if ( vect [ i ] . second == 2 ) { sum += ( vect [ i ] . first - vect [ i - 1 ] . first ) * ( vect [ i + 1 ] . first - vect [ i ] . first ) - 1 ; } } return total - sum - two . size ( ) ; } } int main ( ) { int a [ ] = { 5 , 4 , 2 , 9 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << CntcontSubs ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int countSubsets ( int a [ ] , int n ) { int answer = 0 ; int powerOfTwo [ 100005 ] ; powerOfTwo [ 0 ] = 1 ; for ( int i = 1 ; i < 100005 ; i ++ ) powerOfTwo [ i ] = ( powerOfTwo [ i - 1 ] * 2 ) % mod ; unordered_map < int , int > frequency ; for ( int i = 0 ; i < n ; i ++ ) frequency [ a [ i ] ] ++ ; for ( auto el : frequency ) { if ( el . first != 0 ) answer = ( answer % mod + powerOfTwo [ el . second - 1 ] ) % mod ; else answer = ( answer % mod + powerOfTwo [ el . second ] - 1 + mod ) % mod ; } return answer ; } int main ( ) { int N = 6 ; int A [ N ] = { 1 , 3 , 2 , 1 , 2 , 1 } ; cout << countSubsets ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long product ( vector < vector < int > > & mat , int n ) { long long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1LL * d1 * d2 ; } int main ( ) { vector < vector < int > > mat = { { 5 , 8 , 1 } , { 5 , 10 , 3 } , { -6 , 17 , -9 } } ; int n = mat . size ( ) ; cout << product ( mat , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int * arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; } int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 } ; int queries = 3 ; int q [ queries ] [ 2 ] = { { 2 , 4 } , { 2 , 6 } , { 5 , 6 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; for ( int i = 0 ; i < queries ; i ++ ) cout << findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int subarrayPossible ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum <= 0 ) return 1 ; } sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( sum <= 0 ) return 1 ; } return 0 ; } int main ( ) { int arr [ ] = { 10 , 5 , -12 , 7 , -10 , 20 , 30 , -10 , 50 , 60 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( subarrayPossible ( arr , size ) ) cout << " Yes " << " STRNEWLINE " ; else cout << " No " << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define limit  10000000 NEW_LINE using namespace std ; int position [ limit + 1 ] ; void sieve ( ) { position [ 0 ] = -1 , position [ 1 ] = -1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = -1 ; } } } int main ( ) { sieve ( ) ; int n = 11 ; cout << position [ n ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double maxSubArraySum ( double a [ ] , int size ) { double max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } double minPossibleSum ( double a [ ] , int n , double x ) { double mxSum = maxSubArraySum ( a , n ) ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } sum = sum - mxSum + mxSum / x ; cout << setprecision ( 2 ) << sum << endl ; } int main ( ) { int N = 3 ; double X = 2 ; double A [ N ] = { 1 , -2 , 3 } ; minPossibleSum ( A , N , X ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } int countReverse ( int arr [ ] , int n ) { unordered_map < int , int > freq ; for ( int i = 0 ; i < n ; ++ i ) ++ freq [ arr [ i ] ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { -- freq [ arr [ i ] ] ; res += freq [ reverse ( arr [ i ] ) ] ; } return res ; } int main ( ) { int a [ ] = { 16 , 61 , 12 , 21 , 25 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countReverse ( a , n ) << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isPossible ( int A [ ] , int n , int k ) { int countOfTwo = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] % 2 == 0 ) { countOfTwo ++ ; } } if ( k == 0 && countOfTwo == n ) cout << " NO STRNEWLINE " ; else if ( countOfTwo >= k ) { cout << " Yes STRNEWLINE " ; } else cout << " No STRNEWLINE " ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isPossible ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define size  10001 NEW_LINE using namespace std ; int prime [ size ] ; int freq [ size ] ; void sieve ( int a , int b ) { prime [ 1 ] = 1 ; for ( int i = 2 ; i * i < size ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * 2 ; j < size ; j += i ) prime [ j ] = 1 ; } } for ( int p = 1 ; p < size ; p ++ ) { for ( int q = 1 ; q < size ; q ++ ) { if ( prime [ p ] == 0 && prime [ q ] == 0 && a * p + b * q < size ) { freq [ a * p + b * q ] ++ ; } } } } int main ( ) { int queries = 2 , a = 1 , b = 2 ; sieve ( a , b ) ; int arr [ queries ] = { 15 , 25 } ; for ( int i = 0 ; i < queries ; i ++ ) { cout << freq [ arr [ i ] ] << " ▁ " ; } return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printModulus ( int X , int Y ) { int n = max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) cout << i << " ▁ " ; } } int main ( ) { int X , Y ; X = 10 ; Y = 20 ; printModulus ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string check ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) count ++ ; } if ( count & 1 ) return " Odd " ; else return " Even " ; } int main ( ) { int arr [ ] = { 3 , 9 , 12 , 13 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << check ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <stdlib.h> NEW_LINE using namespace std ; bool isDivisible ( int n ) { int d ; while ( n / 100 ) { d = n % 10 ; n /= 10 ; n = abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; } int main ( ) { int N = 59173 ; if ( isDivisible ( N ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; } int main ( ) { int n = 4 ; cout << properDivisorSum ( n ) << endl ; n = 5 ; cout << properDivisorSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; } int main ( ) { int n = 4 ; cout << properDivisorSum ( n ) << endl ; n = 5 ; cout << properDivisorSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 1e5 ; bool isPrime [ sz + 1 ] ; void generatePrime ( ) { int i , j ; memset ( isPrime , true , sizeof ( isPrime ) ) ; isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } } void Pair_of_PrimeXor ( int A [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime [ ( A [ i ] ^ A [ j ] ) ] ) { cout << " ( " << A [ i ] << " , ▁ " << A [ j ] << " ) ▁ " ; } } } } int main ( ) { int A [ ] = { 1 , 3 , 6 , 11 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; generatePrime ( ) ; Pair_of_PrimeXor ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } void printMinCountPrime ( int N ) { int minCount ; if ( isPrime ( N ) ) { minCount = 1 ; } else if ( N % 2 == 0 ) { minCount = 2 ; } else { if ( isPrime ( N - 2 ) ) { minCount = 2 ; } else { minCount = 3 ; } } cout << minCount << endl ; } int main ( ) { int N = 100 ; printMinCountPrime ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSteps ( int n ) { int steps = 0 ; while ( n ) { int largest = cbrt ( n ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; } int main ( ) { int n = 150 ; cout << countSteps ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rad ( double d , double h ) { cout << " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " << ( ( d * d ) / ( 8 * h ) + h / 2 ) << endl ; } int main ( ) { double d = 4 , h = 1 ; rad ( d , h ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Area ( float r ) { if ( r < 0 ) return -1 ; float x = ( 2 * r ) / sqrt ( 5 ) ; float A = 0.70477 * pow ( x , 2 ) ; return A ; } int main ( ) { float r = 5 ; cout << Area ( r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) return -1 ; return 2 * a * sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ; } int main ( ) { float a = 9 , n = 10 ; cout << polydiagonal ( n , a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define PI  3.14159265 NEW_LINE using namespace std ; float area_circumscribed ( float c ) { return ( c * c * ( PI / 4 ) ) ; } int main ( ) { float c = 8 ; cout << area_circumscribed ( c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxArea ( float perimeter ) { int length = ( int ) ceil ( perimeter / 4 ) ; int breadth = ( int ) floor ( perimeter / 4 ) ; return length * breadth ; } int main ( ) { float n = 38 ; cout << " Maximum ▁ Area ▁ = ▁ " << maxArea ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; float Perimeter ( float s , int n ) { float perimeter = 1 ; perimeter = n * s ; return perimeter ; } int main ( ) { int n = 5 ; float s = 2.5 , peri ; peri = Perimeter ( s , n ) ; cout << " Perimeter ▁ of ▁ Regular ▁ Polygon " << " ▁ with ▁ " << n << " ▁ sides ▁ of ▁ length ▁ " << s << " ▁ = ▁ " << peri << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float hexadiagonal ( float a ) { if ( a < 0 ) return -1 ; return 2 * a ; } int main ( ) { float a = 4 ; cout << hexadiagonal ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float radius = sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ; return radius ; } int main ( ) { float l = 4 , b = 3 ; cout << findRadiusOfcircumcircle ( l , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) cout << " NO " << endl ; else cout << " YES " << endl ; } int main ( ) { int n = 100 ; int x = 51 , y = 100 ; halfsquare ( n , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 and x < x2 and y > y1 and y < y2 ) return true ; return false ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = fabs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = sqrt ( a * a + b * b + c * c ) ; cout << " Perpendicular ▁ distance ▁ is ▁ " << ( d / e ) ; return ; } int main ( ) { float x1 = 4 ; float y1 = -4 ; float z1 = 3 ; float a = 2 ; float b = -2 ; float c = 5 ; float d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; } int main ( ) { int n = 4 ; cout << pentagon_pyramidal ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isRectangle ( int a , int b , int c , int d ) { if ( a == b == c == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } int main ( ) { int a , b , c , d ; a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; } int main ( ) { double a = 1 , b = 2 , c = 1 , d = 2 ; cout << maxArea ( a , b , c , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkCollision ( int a , int b , int c , int x , int y , int radius ) { int dist = ( abs ( a * x + b * y + c ) ) / sqrt ( a * a + b * b ) ; if ( radius == dist ) cout << " Touch " << endl ; else if ( radius > dist ) cout << " Intersect " << endl ; else cout << " Outside " << endl ; } int main ( ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; } int main ( ) { int x1 = -10 , y1 = 8 ; int x2 = 14 , y2 = -24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) cout << " Circle ▁ touch ▁ to " << " ▁ each ▁ other . " ; else if ( t < 0 ) cout << " Circle ▁ not ▁ touch " << " ▁ to ▁ each ▁ other . " ; else cout << " Circle ▁ intersect " << " ▁ to ▁ each ▁ other . " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumCost ( int arr [ ] , int N , int X , int Y ) { int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) ) { even_count ++ ; } } int cost1 = X * min ( odd_count , even_count ) ; int cost2 = Y * ( max ( odd_count , even_count ) - min ( odd_count , even_count ) ) ; int cost3 = ( odd_count + even_count ) * Y ; return min ( cost1 + cost2 , cost3 ) ; } int main ( ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 } , X = 10 , Y = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumCost ( arr , N , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximizeSubset ( int N , int arr [ ] , int M , int x = 0 ) { if ( x == M ) { return 0 ; } int ans = 0 ; for ( int i = x ; i < M ; i ++ ) { if ( N % arr [ i ] == 0 ) { ans = max ( ans , maximizeSubset ( N / arr [ i ] , arr , M , x + 1 ) + 1 ) ; } } return ans ; } int main ( ) { int N = 64 ; int arr [ ] = { 1 , 2 , 4 , 8 , 16 , 32 } ; int M = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximizeSubset ( N , arr , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; } int countPairs ( int L , int R ) { int cntPair = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { int x = getProduct ( a ) ; int y = getProduct ( b ) ; if ( x && y && ( a * y ) == ( b * x ) ) { cntPair ++ ; } } } return cntPair ; } int main ( ) { int L = 1 ; int R = 100 ; cout << countPairs ( 1 , 100 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( vector < vector < int > > & matrix ) { int r = matrix . size ( ) ; int c = matrix [ 0 ] . size ( ) ; int sum = 0 ; int mini = INT_MAX ; int count = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { int k = matrix [ i ] [ j ] ; mini = min ( mini , abs ( k ) ) ; if ( k < 0 ) count ++ ; sum += abs ( k ) ; } } if ( count % 2 == 0 ) { return sum ; } else { return ( sum - 2 * mini ) ; } } int main ( ) { vector < vector < int > > matrix = { { 2 , -2 } , { -2 , 2 } } ; cout << maxSum ( matrix ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubsequences ( vector < int > arr ) { int odd = 0 ; for ( int x : arr ) { if ( x & 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } int main ( ) { vector < int > arr = { 1 , 3 , 3 } ; cout << countSubsequences ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void updateArray ( vector < int > & arr , int K ) { int sum = 0 ; vector < int > res ; for ( int i = 0 ; i < ( int ) arr . size ( ) ; i ++ ) { if ( arr [ i ] < K ) { sum += arr [ i ] ; } else { if ( sum != 0 ) { res . push_back ( sum ) ; } sum = 0 ; res . push_back ( arr [ i ] ) ; } } if ( sum != 0 ) res . push_back ( sum ) ; for ( auto & it : res ) cout << it << ' ▁ ' ; } int main ( ) { vector < int > arr = { 200 , 6 , 36 , 612 , 121 , 66 , 63 , 39 , 668 , 108 } ; int K = 100 ; updateArray ( arr , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countQuadruples ( int A [ ] , int N ) { int ans = 0 ; unordered_map < int , int > freq ; for ( int i = 0 ; i < N ; i ++ ) { ans += freq [ A [ i ] ] ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { freq [ A [ i ] * A [ j ] * A [ k ] ] ++ ; } } } return ans ; } int main ( ) { int arr [ ] = { 10 , 2 , 2 , 7 , 40 , 160 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countQuadruples ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long countCells ( int n , int m , int s ) { int mx1 = -1 ; int cont1 = 0 ; for ( int i = 0 ; i < s && i < n ; ++ i ) { int aux = ( n - ( i + 1 ) ) / s + 1 ; if ( aux > mx1 ) { mx1 = cont1 = aux ; } else if ( aux == mx1 ) cont1 += aux ; } int mx2 = -1 ; int cont2 = 0 ; for ( int i = 0 ; i < s && i < m ; ++ i ) { int aux = ( m - ( i + 1 ) ) / s + 1 ; if ( aux > mx2 ) mx2 = cont2 = aux ; else if ( aux == mx2 ) cont2 += aux ; } return ( long long ) ( cont1 * cont2 ) ; } int main ( ) { int N = 5 , M = 5 , K = 2 ; cout << countCells ( N , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumSubarray ( vector < int > arr , int n , int m ) { vector < int > mapu ( m + 1 , 0 ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mapu [ arr [ i ] ] ++ ; if ( mapu [ arr [ i ] ] == ( n / m ) + 1 ) c ++ ; } if ( c == 0 ) return 0 ; int ans = n ; int l = 0 , r = 0 ; while ( r < n ) { if ( -- mapu [ arr [ r ] ] == ( n / m ) ) c -- ; if ( c == 0 ) { while ( l <= r && c == 0 ) { ans = min ( ans , r - l + 1 ) ; if ( ++ mapu [ arr [ l ] ] > ( n / m ) ) c ++ ; l ++ ; } } r ++ ; } return ans ; } int main ( ) { vector < int > arr = { 1 , 1 , 2 , 1 , 1 , 2 } ; int M = 2 ; int N = arr . size ( ) ; cout << minimumSubarray ( arr , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res = res * i ; } return res ; } int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } void countWays ( string s , string t ) { int n = s . length ( ) ; int sum1 = 0 , sum2 = 0 , K = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { sum1 ++ ; } else sum1 -- ; } int m = t . length ( ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( t [ i ] == '1' ) { sum2 ++ ; } else if ( t [ i ] == '0' ) { sum2 -- ; } else K ++ ; } int P = abs ( sum1 - sum2 ) ; if ( P > K or ( K - P ) % 2 ) { cout << 0 ; return ; } cout << nCr ( K , ( P + K ) / 2 ) ; } int main ( ) { string S1 = "1010" ; string S2 = "10 ? ? " ; countWays ( S1 , S2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long ABS ( long long x ) { return max ( x , - x ) ; } void findFraction ( long long x , long long y , long long n ) { long long A = -1 , B = -1 ; for ( long long i = 1 ; i <= n ; i ++ ) { long long d = ( i * x ) / y ; if ( d >= 0 && ( A == -1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d , B = i ; d ++ ; if ( d >= 0 && ( A == -1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d , B = i ; } cout << A << " / " << B << endl ; } int main ( ) { long long x = 3 , y = 7 , n = 6 ; findFraction ( x , y , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < string > FractionSplit ( long long n , long long d ) { vector < string > UnitFactions ; while ( n > 0 ) { long long x = ( d + n - 1 ) / n ; string s = "1 / " + to_string ( x ) ; UnitFactions . push_back ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; } int main ( ) { long long n = 13 , d = 18 ; auto res = FractionSplit ( n , d ) ; for ( string s : res ) cout << s << " , ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumDistance ( vector < int > arr , int N ) { int ind = 0 ; int prev = arr [ ind ] ; int s = arr . size ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int distance = INT_MAX ; if ( i < arr [ 0 ] ) { distance = arr [ 0 ] - i ; } else if ( i >= prev && ind + 1 < s && i <= arr [ ind + 1 ] ) { distance = min ( i - prev , arr [ ind + 1 ] - i ) ; if ( i == arr [ ind + 1 ] ) { distance = 0 ; prev = arr [ ind + 1 ] ; ind ++ ; } } else { distance = i - prev ; } cout << distance << " ▁ " ; } } int main ( ) { int N = 5 ; vector < int > arr = { 0 , 4 } ; minimumDistance ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOfPairs ( int arr [ ] , int N , int X ) { int count = 0 ; unordered_map < int , int > M ; for ( int i = 0 ; i < N ; i ++ ) { M [ ( arr [ i ] & X ) ] ++ ; } for ( auto m : M ) { int p = m . second ; count += p * ( p - 1 ) / 2 ; } return count ; } int main ( ) { int arr [ ] = { 3 , 2 , 5 , 4 , 6 , 7 } ; int X = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countOfPairs ( arr , N , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void primeFactorization ( int N ) { int sieve [ N / 2 + 1 ] = { 0 } ; for ( int i = 2 ; i <= N / 2 ; i ++ ) { if ( sieve [ i ] == 0 ) { for ( int j = i * i ; j <= N / 2 ; j += i ) { sieve [ j ] = 1 ; } } } vector < int > prime ; for ( int i = 3 ; i <= N / 2 ; i ++ ) if ( sieve [ i ] == 0 ) prime . push_back ( i ) ; int x = prime . size ( ) ; cout << "2 - > " << x << endl ; for ( int i : prime ) cout << i << " - > 1" << endl ; } int main ( ) { int N = 18 ; primeFactorization ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int noOfWays ( int N , int K ) { string S = to_string ( N ) ; int ans = 1 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { int count = 1 ; while ( i < S . length ( ) && S [ i ] - '0' + S [ i - 1 ] - '0' == K ) { count ++ ; i ++ ; } if ( count % 2 ) ans *= ( count + 1 ) / 2 ; } return ans ; } int main ( ) { int N = 1454781 ; int K = 9 ; cout << noOfWays ( N , K ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUnitaryDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i && __gcd ( i , n / i ) == 1 ) { printf ( " % d ▁ " , i ) ; } else { if ( __gcd ( i , n / i ) == 1 ) { printf ( " % d ▁ % d ▁ " , i , n / i ) ; } } } } } int main ( ) { int N = 12 ; printUnitaryDivisors ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getPermutation ( int N ) { if ( N <= 3 ) { cout << -1 ; return ; } int i = N ; if ( N % 2 == 0 ) i -- ; while ( i >= 1 ) { cout << i << " ▁ " ; i -= 2 ; } cout << 4 << " ▁ " << 2 << " ▁ " ; i = 6 ; while ( i <= N ) { cout << i << " ▁ " ; i += 2 ; } } int main ( ) { int N = 9 ; getPermutation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxScoreSubArray ( int * a , int * b , int n ) { int res = 0 ; for ( int mid = 0 ; mid < n ; mid ++ ) { int straightScore = a [ mid ] * b [ mid ] , reverseScore = a [ mid ] * a [ mid ] ; int prev = mid - 1 , next = mid + 1 ; res = max ( res , max ( straightScore , reverseScore ) ) ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = max ( res , max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } straightScore = 0 ; reverseScore = 0 ; prev = mid - 1 , next = mid ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = max ( res , max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } } cout << res ; } int main ( ) { int A [ ] = { 13 , 4 , 5 } ; int B [ ] = { 10 , 22 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maxScoreSubArray ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countValues ( int A , int B , int C ) { if ( B >= A ) { cout << 0 ; return ; } if ( B == 0 ) { cout << C / A ; return ; } int ans = C / A ; if ( ans * A + B <= C ) { ans ++ ; } cout << ans ; } int main ( ) { int A = 6 , B = 3 , N = 15 ; countValues ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxFrequency ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int start = 0 , end = 0 ; int sum = 0 , res = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum += arr [ end ] ; while ( ( end - start + 1 ) * arr [ end ] - sum > K ) { sum -= arr [ start ] ; start ++ ; } res = max ( res , end - start + 1 ) ; } cout << res << endl ; } int main ( ) { int arr [ ] = { 1 , 4 , 8 , 13 } ; int N = 4 ; int K = 5 ; maxFrequency ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int arr [ ] , int n , int x ) { int count = 0 ; map < int , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { mp [ arr [ i ] - x * i ] ++ ; } for ( auto x : mp ) { int n = x . second ; count += ( n * ( n - 1 ) ) / 2 ; } cout << count ; } int main ( ) { int n = 6 , x = 3 ; int arr [ ] = { 5 , 4 , 8 , 11 , 13 , 16 } ; countPairs ( arr , n , x ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int sumOfDivisors ( int N ) { return N ; } int main ( ) { int N = 5 ; cout << sumOfDivisors ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findXORS ( int arr1 [ ] , int arr2 [ ] , int N , int M ) { int XORS1 = 0 ; int XORS2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XORS1 ^= arr1 [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { XORS2 ^= arr2 [ i ] ; } return XORS1 and XORS2 ; } int main ( ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 6 , 5 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int M = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << findXORS ( arr1 , arr2 , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ceilDifference ( int arr [ ] , int n , int x ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += ceil ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int totalCeilSum = ceil ( ( double ) ( totalSum ) / ( double ) ( x ) ) ; return abs ( perElementSum - totalCeilSum ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ceilDifference ( arr , N , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countTriplets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; } int main ( ) { int N = 10 ; cout << countTriplets ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minStepK ( int arr [ ] , int N , int K ) { int E = 0 ; int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 == 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return -1 ; else return K - S ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; cout << minStepK ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n , bool prime [ ] ) { prime [ 0 ] = 0 ; prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } } void countPrime ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( n , prime ) ; int dp [ n + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] += dp [ i - 1 ] ; if ( prime [ i ] == 1 && prime [ i - 2 ] == 1 ) { dp [ i ] ++ ; } } cout << dp [ n ] ; } int main ( ) { int N = 6 ; countPrime ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumOfSquaredDifferences ( int arr [ ] , int N ) { int ans = 0 ; int sumA = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; cout << ans ; } int main ( ) { int arr [ ] = { 2 , 8 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sumOfSquaredDifferences ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countAPs ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; } int main ( ) { int S = 12 , D = 1 ; cout << countAPs ( S , D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinct ( vector < int > arr , int N ) { set < int > st ; for ( int i = 0 ; i < N ; i ++ ) { st . insert ( arr [ i ] ) ; } return st . size ( ) ; } int maxSubarraySumUtil ( vector < int > arr , int N , int K , int totalDistinct ) { if ( K > N ) return 0 ; int mx = 0 ; int sum = 0 ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] += 1 ; sum += arr [ i ] ; if ( i >= K ) { mp [ arr [ i - K ] ] -= 1 ; sum -= arr [ i - K ] ; if ( mp [ arr [ i - K ] ] == 0 ) mp . erase ( arr [ i - K ] ) ; } if ( mp . size ( ) == totalDistinct ) mx = max ( mx , sum ) ; } return mx ; } void maxSubarraySum ( vector < int > arr , int K ) { int N = arr . size ( ) ; int totalDistinct = distinct ( arr , N ) ; cout << maxSubarraySumUtil ( arr , N , K , totalDistinct ) ; } int main ( ) { vector < int > arr { 7 , 7 , 2 , 4 , 2 , 7 , 4 , 6 , 6 , 6 } ; int K = 6 ; maxSubarraySum ( arr , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int processDiagonal ( vector < int > arr ) { int ans = 0 ; int getBit = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { int S = 0 ; int NS = 0 ; for ( auto j : arr ) { if ( getBit & j ) S += 1 ; else NS += 1 ; } if ( S > NS ) ans += pow ( 2 , i ) ; getBit <<= 1 ; } return ans ; } int findSum ( vector < vector < int > > mat ) { int i = 0 ; int j = 0 ; vector < int > priDiag ; while ( i < mat . size ( ) ) { priDiag . push_back ( mat [ i ] [ j ] ) ; i += 1 ; j += 1 ; } i = 0 ; j = mat . size ( ) - 1 ; vector < int > secDiag ; while ( i < mat . size ( ) ) { secDiag . push_back ( mat [ i ] [ j ] ) ; i += 1 ; j -= 1 ; } return processDiagonal ( priDiag ) + processDiagonal ( secDiag ) ; } int main ( ) { vector < vector < int > > mat { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; cout << findSum ( mat ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool ispalin ( int num ) { string s = to_string ( num ) ; int st = 0 , ed = s . size ( ) - 1 ; while ( st <= ed ) { if ( s [ st ] != s [ ed ] ) return false ; st ++ ; ed -- ; } return true ; } void CalculateXORandOR ( int n ) { int CalculateXOR = 0 ; int CalculateOR = 0 ; int start = pow ( 10 , n - 1 ) ; int end = pow ( 10 , n ) - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( ispalin ( i ) ) { CalculateXOR = CalculateXOR ^ i ; CalculateOR = CalculateOR | i ; } } cout << " XOR ▁ = ▁ " << CalculateXOR ; cout << " ▁ OR ▁ = ▁ " << CalculateOR ; } int main ( ) { int n = 4 ; CalculateXORandOR ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int powOfPositive ( int n ) { int pos = floor ( log2 ( n ) ) ; return pow ( 2 , pos ) ; } int powOfNegative ( int n ) { int pos = ceil ( log2 ( n ) ) ; return ( -1 * pow ( 2 , pos ) ) ; } void highestPowerOf2 ( int n ) { if ( n > 0 ) { cout << powOfPositive ( n ) ; } else { n = - n ; cout << powOfNegative ( n ) ; } } int main ( ) { int n = -24 ; highestPowerOf2 ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int summation ( int n ) { int abs_sum = n * ( n + 1 ) / 2 ; int sign = n + 1 % 2 == 0 ? 1 : -1 ; int result_sum = sign * abs_sum ; return result_sum ; } int main ( ) { int N = 2 ; cout << summation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPower ( int x , int y ) { int res1 = log ( y ) / log ( x ) ; double res2 = log ( y ) / log ( x ) ; return ( res1 == res2 ) ; } int countPower ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isPower ( arr [ i ] , arr [ j ] ) || isPower ( arr [ j ] , arr [ i ] ) ) res ++ ; return res ; } int main ( ) { int a [ ] = { 16 , 2 , 3 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPower ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << noOfCards ( n ) << " , ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pairCount ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; } int main ( ) { int n = 9 , m = 3 ; cout << pairCount ( n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } int count_of_subarrays ( int N ) { int count = binomialCoeff ( 2 * N - 1 , N ) ; return count ; } int main ( ) { int N = 3 ; cout << count_of_subarrays ( N ) << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxGCD ( int N , int K ) { int minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return -1 ; int i = sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = max ( res , N / i ) ; if ( N / i >= minSum ) res = max ( res , i ) ; } i -- ; } return res ; } int main ( ) { int N = 18 , K = 3 ; cout << maxGCD ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long double getSum ( int n ) { long double sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * pow ( 10 , n - 1 ) * pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; } int main ( ) { int n = 3 ; long double ans = getSum ( n ) ; cout << setprecision ( 12 ) << ans << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int * arr , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = max ( m , arr [ i ] ) ; int freq [ m + 2 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= m + 1 ; i ++ ) { int j = i ; int cnt = 0 ; while ( j <= m ) { cnt += freq [ j ] ; j += i ; } if ( ! cnt ) return i ; } return m + 1 ; } int main ( ) { int arr [ ] = { 2 , 12 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMin ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDel ( int * arr , int n ) { int min_num = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) min_num = min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; } int main ( ) { int arr [ ] = { 3 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMinDel ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } int digitPowSum ( int n ) { int sum = 0 ; int pw = countDigits ( n ) ; while ( n > 0 ) { int d = n % 10 ; sum += pow ( d , pw ) ; pw -- ; n /= 10 ; } return sum ; } int countNum ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == digitPowSum ( i ) ) { count ++ ; } } return count ; } int main ( ) { int n = 200 ; cout << countNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void perfectSquares ( float l , float r ) { for ( int i = l ; i <= r ; i ++ ) { if ( sqrt ( i ) == ( int ) sqrt ( i ) ) cout << i << " ▁ " ; } } int main ( ) { int l = 2 , r = 24 ; perfectSquares ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { cout << " Second ▁ Player ▁ wins ▁ the ▁ game " ; } else { cout << " First ▁ Player ▁ wins ▁ the ▁ game " ; } } int main ( ) { int n = 7 ; findWinner ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) / GCD ; } int MinLCM ( int a [ ] , int n ) { int Prefix [ n + 2 ] ; int Suffix [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } int main ( ) { int a [ ] = { 5 , 15 , 9 , 36 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinLCM ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MOD = 1000000007 ; int factMod ( int n ) { long fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= ( i % MOD ) ; fact %= MOD ; } return fact ; } int countWays ( int n , int m ) { return factMod ( m ) ; } int main ( ) { int n = 2 , m = 2 ; cout << countWays ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isComposite ( int n ) { for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return true ; } return false ; } int Power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } bool isEulerPseudoprime ( int N , int A ) { if ( A <= 0 ) return false ; if ( N % 2 == 0 || ! isComposite ( N ) ) return false ; if ( __gcd ( A , N ) != 1 ) return false ; int mod = Power ( A , ( N - 1 ) / 2 , N ) ; if ( mod != 1 && mod != N - 1 ) return false ; return true ; } int main ( ) { int N = 121 , A = 3 ; if ( isEulerPseudoprime ( N , A ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int geometricMean ( int n ) { return sqrt ( n ) ; } int main ( ) { int n = 16 ; cout << geometricMean ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return -1 ; } int main ( ) { int a = 2 , b = 16 ; cout << find_k ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntSubSets ( int arr [ ] , int n ) { int maxVal = * max_element ( arr , arr + n ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( pow ( 2 , cnt ) - 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << cntSubSets ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSum ( int n ) { return ( ( n - 1 ) + pow ( n , 2 ) ) ; } int main ( ) { int n = 3 ; cout << getSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cntEdges ( int n ) { int edges = pow ( 2 , n ) - 2 ; return edges ; } int main ( ) { int n = 4 ; cout << cntEdges ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { return 15 * pow ( 16 , n - 1 ) ; } int main ( ) { int n = 2 ; cout << count ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float findProb ( int arr [ ] , int n ) { long maxSum = INT_MIN , maxCount = 0 , totalPairs = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum == maxSum ) { maxCount ++ ; } else if ( sum > maxSum ) { maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } } float prob = ( float ) maxCount / ( float ) totalPairs ; return prob ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findProb ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int previousFibonacci ( int n ) { double a = n / ( ( 1 + sqrt ( 5 ) ) / 2.0 ) ; return round ( a ) ; } int main ( ) { int n = 8 ; cout << ( previousFibonacci ( n ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; } int main ( ) { int n = 3 ; cout << count ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ways ( int n ) { return n / 2 ; } int main ( ) { int n = 2 ; cout << ways ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( sum / n ) + 1 ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMinValue ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumPairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum ( int arr [ ] , int n ) { int sum = 0 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 1 , 10 , 2 , 2 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long getCount ( int A , int B2 , int C ) { long long count = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { long long j = ( B2 / i ) + 1 ; if ( C >= j ) count = ( count + C - j + 1 ) ; if ( A >= j && C >= i ) count = ( count + ( C - i + 1 ) * ( A - j + 1 ) ) ; if ( A >= j ) A = j - 1 ; } return count ; } long long countTriplets ( int A , int B , int C ) { long long ans = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { ans = ( ans + getCount ( A , i * i , C ) ) ; } return ans ; } int main ( ) { int A , B , C ; A = 3 , B = 2 , C = 2 ; cout << countTriplets ( A , B , C ) ; }
#include <iostream> NEW_LINE using namespace std ; int sum ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; } int repeatedSum ( int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { n = sum ( n ) ; } return n ; } int main ( ) { int n = 2 , k = 2 ; cout << repeatedSum ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100000 NEW_LINE bool prime [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } int smallestPrime ( int d ) { int l = pow ( 10 , d - 1 ) ; int r = pow ( 10 , d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( prime [ i ] ) { return i ; } } return -1 ; } int largestPrime ( int d ) { int l = pow ( 10 , d - 1 ) ; int r = pow ( 10 , d ) - 1 ; for ( int i = r ; i >= l ; i -- ) { if ( prime [ i ] ) { return i ; } } return -1 ; } int main ( ) { SieveOfEratosthenes ( ) ; int queries [ ] = { 2 , 5 } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) { cout << smallestPrime ( queries [ i ] ) << " ▁ " << largestPrime ( queries [ i ] ) << endl ; } return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; } int main ( ) { int n = 5 ; if ( possible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) cout << " Increasing " ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << " Decreasing " ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) cout << " Increasing ▁ then ▁ decreasing " ; else cout << " Decreasing ▁ then ▁ increasing " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkType ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; } int main ( ) { double a = 1 , b = 2 , c = 9 , d = 13 , x = 5 ; cout << sum ( a , b , c , d , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRoots ( long a , long b , long c ) { cout << 1 << " , ▁ " << c / ( a * 1.0 ) ; } int main ( ) { long a = 2 ; long b = 3 ; long c = -5 ; printRoots ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Max_sum ( int a [ ] , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( pos == 1 and neg == 1 ) break ; } int sum = 0 ; if ( pos == 1 and neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) sum += abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; } int main ( ) { int a [ ] = { 1 , 3 , 5 , -2 , -6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Max_sum ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void decimalToBinary ( int n ) { if ( n == 0 ) { cout << "0" ; return ; } decimalToBinary ( n / 2 ) ; cout << n % 2 ; } int main ( ) { int n = 13 ; decimalToBinary ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Vertices ( int x , int y ) { int val = abs ( x ) + abs ( y ) ; cout << val * ( x < 0 ? -1 : 1 ) << " ▁ 0 ▁ " ; cout << "0 ▁ " << val * ( y < 0 ? -1 : 1 ) ; } int main ( ) { int x = 3 , y = 3 ; Vertices ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  32 NEW_LINE unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; } int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; int f [ MAX + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) f [ countSetBits ( arr [ i ] ) ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j ++ ) { if ( i + j == k ) { if ( i == j ) count += ( ( f [ i ] * ( f [ i ] - 1 ) ) / 2 ) ; else count += ( f [ i ] * f [ j ] ) ; } } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; cout << pairs ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cnt_neg ; bool exists_zero ; void preProcess ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) cnt_neg ++ ; if ( arr [ i ] == 0 ) exists_zero = true ; } } bool isPossible ( int k ) { if ( ! exists_zero ) { if ( k >= cnt_neg and ( k - cnt_neg ) % 2 == 0 ) return true ; else return false ; } else { if ( k >= cnt_neg ) return true ; else return false ; } } int main ( ) { int arr [ ] = { -1 , 2 , -3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; preProcess ( arr , n ) ; int queries [ ] = { 1 , 2 , 3 , 4 } ; int q = sizeof ( queries ) / sizeof ( int ) ; for ( int i = 0 ; i < q ; i ++ ) { if ( isPossible ( queries [ i ] ) ) cout << " Yes " << endl ; else cout << " No " << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE int prime [ MAX + 1 ] ; void updatePrimes ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { prime [ i ] = 1 ; } prime [ 0 ] = prime [ 1 ] = 0 ; for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j <= MAX ; j += i ) { prime [ j ] = 0 ; } } } for ( int i = 1 ; i <= MAX ; i ++ ) { prime [ i ] += prime [ i - 1 ] ; } } int getDifference ( int l , int r ) { int total = r - l + 1 ; int primes = prime [ r ] - prime [ l - 1 ] ; int composites = total - primes ; return ( abs ( primes - composites ) ) ; } int main ( ) { int queries [ ] [ 2 ] = { { 1 , 10 } , { 5 , 30 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; updatePrimes ( ) ; for ( int i = 0 ; i < q ; i ++ ) cout << getDifference ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findIndex ( int a [ ] , int n , int k ) { int index = -1 , max_ceil = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] + k - 1 ) / k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= max_ceil ) { max_ceil = a [ i ] ; index = i ; } } return index ; } int main ( ) { int arr [ ] = { 31 , 12 , 25 , 27 , 32 , 19 } ; int K = 5 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findIndex ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count_Segment ( int p [ ] , int n ) { int count = 0 ; int upto [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) upto [ i ] = 0 ; int j = 0 , curr = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( p [ i ] > p [ i - 1 ] and p [ i ] > p [ i + 1 ] ) { curr = p [ i ] ; j = i - 1 ; while ( j >= 0 and p [ j ] < curr ) { upto [ p [ j ] ] = curr ; j -= 1 ; } j = i + 1 ; while ( j < n and p [ j ] < curr ) { if ( upto [ curr - p [ j ] ] == curr ) count += 1 ; j += 1 ; } } } return count ; } int main ( ) { int p [ ] = { 3 , 4 , 1 , 5 , 2 } ; int n = sizeof ( p ) / sizeof ( p [ 0 ] ) ; cout << ( Count_Segment ( p , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int validPosition ( int arr [ ] , int N , int K ) { int count = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 2 , 1 , 6 , 7 } , K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << validPosition ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1000 ; int countPairs ( int arr [ ] , int n ) { int size = ( 2 * N ) + 1 ; int freq [ size ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } return ans ; } int main ( ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPower ( string str , int len ) { int ans = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) ans ++ ; else break ; } return ans ; } int main ( ) { string str = "100100" ; int len = str . length ( ) ; cout << highestPower ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int n ) { int fac [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; } int main ( ) { int n = 19 ; if ( isPossible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int arr [ ] , int n ) { unordered_map < int , int > umap ; for ( int i = 0 ; i < n ; i ++ ) umap [ arr [ i ] ] ++ ; unordered_map < int , int > :: iterator itr ; for ( itr = umap . begin ( ) ; itr != umap . end ( ) ; itr ++ ) if ( ( itr -> second ) % 2 == 1 ) return false ; return true ; } int main ( ) { int arr [ ] = { 2 , 2 , 7 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isPerfectSquare ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMaxValPair ( vector < long long > & v , int n ) { sort ( v . begin ( ) , v . end ( ) ) ; long long N = v [ n - 1 ] ; if ( N % 2 == 1 ) { long long first_maxima = N / 2 ; long long second_maxima = first_maxima + 1 ; long long ans1 = 3e18 , ans2 = 3e18 ; long long from_left = -1 , from_right = -1 ; long long from = -1 ; for ( long long i = 0 ; i < n ; ++ i ) { if ( v [ i ] > first_maxima ) { from = i ; break ; } else { long long diff = first_maxima - v [ i ] ; if ( diff < ans1 ) { ans1 = diff ; from_left = v [ i ] ; } } } from_right = v [ from ] ; long long diff1 = first_maxima - from_left ; long long diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) cout << N << " ▁ " << from_left ; else cout << N << " ▁ " << from_right ; } else { long long maxima = N / 2 ; long long ans1 = 3e18 ; long long R = -1 ; for ( long long i = 0 ; i < n - 1 ; ++ i ) { long long diff = abs ( v [ i ] - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v [ i ] ; } } cout << N << " ▁ " << R ; } } int main ( ) { vector < long long > v = { 1 , 1 , 2 , 3 , 6 , 1 } ; int n = v . size ( ) ; printMaxValPair ( v , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countQuadruples ( int a [ ] , int n ) { unordered_map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) mpp [ a [ i ] ] ++ ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mpp [ a [ j ] ] -- ; mpp [ a [ k ] ] -- ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) count += mpp [ first ] * mpp [ fourth ] ; else count += mpp [ first ] * ( mpp [ fourth ] - 1 ) ; } mpp [ a [ j ] ] ++ ; mpp [ a [ k ] ] ++ ; } } return count ; } int main ( ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countQuadruples ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; } int main ( ) { int n = 8 , m = 5 ; cout << getPosition ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int parity ( int a ) { return a % 3 ; } int solve ( int array [ ] , int size ) { int operations = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { int pari1 = parity ( array [ i ] ) ; int pari2 = parity ( array [ i + 2 ] ) ; if ( pari1 == pari2 ) { if ( pari1 == 0 ) array [ i + 1 ] = 1 ; else if ( pari1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( pari1 == 0 && pari2 == 1 ) || ( pari1 == 1 && pari2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( pari1 == 1 && pari2 == 2 ) || ( pari1 == 2 && pari2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( pari1 == 2 && pari2 == 0 ) || ( pari1 == 0 && pari2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; } int main ( ) { int array [ ] = { 2 , 1 , 3 , 0 } ; int size = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << solve ( array , size ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkArray ( int arr [ ] , int n ) { return ( arr [ 0 ] % 2 ) && ( arr [ n - 1 ] % 2 ) && ( n % 2 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( int ) checkArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int n , vector < pair < int , int > > points ) { set < pair < int , int > > pts ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) pts . insert ( points [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points [ i ] . first + points [ j ] . first ; int y = points [ i ] . second + points [ j ] . second ; if ( x % 2 == 0 && y % 2 == 0 ) if ( pts . find ( make_pair ( x / 2 , y / 2 ) ) != pts . end ( ) ) ct ++ ; } return ct ; } int main ( ) { vector < pair < int , int > > points = { { 1 , 1 } , { 2 , 2 } , { 3 , 3 } } ; int n = points . size ( ) ; cout << countTriplets ( n , points ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } ll lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; ll lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; } int minPerfectCube ( int arr [ ] , int n ) { ll minPerfectCube ; ll lcm = lcmOfArray ( arr , n ) ; minPerfectCube = ( long long ) lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; } int main ( ) { int arr [ ] = { 10 , 125 , 14 , 42 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minPerfectCube ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxGCD ( int N , int P ) { int ans = 1 ; unordered_map < int , int > prime_factors ; for ( int i = 2 ; i * i <= P ; i ++ ) { while ( P % i == 0 ) { prime_factors [ i ] ++ ; P /= i ; } } if ( P != 1 ) prime_factors [ P ] ++ ; for ( auto v : prime_factors ) ans *= pow ( v . first , v . second / N ) ; return ans ; } int main ( ) { int N = 3 , P = 24 ; cout << maxGCD ( N , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > getPerfectSquares ( int n ) { vector < int > perfectSquares ; int current = 1 , i = 1 ; while ( current <= n ) { perfectSquares . push_back ( current ) ; current = pow ( ++ i , 2 ) ; } return perfectSquares ; } int countTriplets ( int n ) { vector < int > perfectSquares = getPerfectSquares ( pow ( n , 2 ) ) ; int count = 0 ; for ( int a = 1 ; a <= n ; a ++ ) { int aSquare = pow ( a , 2 ) ; for ( int i = 0 ; i < perfectSquares . size ( ) ; i ++ ) { int cSquare = perfectSquares [ i ] ; int bSquare = abs ( cSquare - aSquare ) ; int b = sqrt ( bSquare ) ; int c = sqrt ( cSquare ) ; if ( c < a || ( find ( perfectSquares . begin ( ) , perfectSquares . end ( ) , bSquare ) == perfectSquares . end ( ) ) ) continue ; if ( ( b >= a ) && ( b <= c ) && ( aSquare + bSquare == cSquare ) ) count ++ ; } } return count ; } int main ( ) { int n = 10 ; cout << countTriplets ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinSteps ( int SourceX , int SourceY , int DestX , int DestY ) { cout << max ( abs ( SourceX - DestX ) , abs ( SourceY - DestY ) ) << endl ; while ( ( SourceX != DestX ) || ( SourceY != DestY ) ) { if ( SourceX < DestX ) { cout << ' U ' ; SourceX ++ ; } if ( SourceX > DestX ) { cout << ' D ' ; SourceX -- ; } if ( SourceY > DestY ) { cout << ' L ' ; SourceY -- ; } if ( SourceY < DestY ) { cout << ' R ' ; SourceY ++ ; } cout << endl ; } } int main ( ) { int sourceX = 4 , sourceY = 4 ; int destinationX = 7 , destinationY = 0 ; MinSteps ( sourceX , sourceY , destinationX , destinationY ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp /= 10 ; } if ( reverse_num == num ) { return true ; } return false ; } bool isOddLength ( int num ) { int count = 0 ; while ( num > 0 ) { num /= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; } long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; } int main ( ) { int L = 110 , R = 1130 ; cout << " ▁ " << sumOfAllPalindrome ( L , R ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool productSumDivisible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) return true ; return false ; } int main ( ) { int n = 1234 ; int len = 4 ; if ( productSumDivisible ( n , len ) ) cout << " TRUE " ; else cout << " FALSE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } cout << " Sum ▁ = ▁ " << sum ; cout << " Product = " } int main ( ) { int n = 1012 ; countDigit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE bool prime [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } void productOfKthPrimes ( int arr [ ] , int n , int k ) { int c = 0 ; long long int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { product *= arr [ i ] ; c = 0 ; } } } cout << product << endl ; } int main ( ) { SieveOfEratosthenes ( ) ; int n = 5 , k = 2 ; int arr [ n ] = { 2 , 3 , 5 , 7 , 11 } ; productOfKthPrimes ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; } int main ( ) { int n = 2 ; cout << nthKyneaNumber ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; } int main ( ) { int n = 6 ; cout << fnMod ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int modExp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b & 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; } int check ( int num ) { if ( num & 1 num < 3 ) return -1 ; else if ( num % 4 == 0 ) return modExp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return -1 ; } int main ( ) { int num = 10 ; cout << check ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } int main ( ) { int B = 10 , C = 28 ; B = 100 - B ; C = 100 - C ; cout << Race ( B , C ) << " ▁ meters " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } unsigned long int catalan ( unsigned int n ) { unsigned long int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } int main ( ) { int n = 3 ; cout << catalan ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iomanip> NEW_LINE #include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float d = sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) + pow ( z2 - z1 , 2 ) * 1.0 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " ▁ Distance ▁ is ▁ " << d ; return ; } int main ( ) { float x1 = 2 ; float y1 = -5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ; distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findGreater ( int a , int b , int n ) { if ( ! ( n & 1 ) ) { a = abs ( a ) ; b = abs ( b ) ; } if ( a == b ) cout << " a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n " ; else if ( a > b ) cout << " a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n " ; else cout << " b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n " ; } int main ( ) { int a = 12 , b = 24 , n = 5 ; findGreater ( a , b , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int subtractOne ( int x ) { int m = 1 ; while ( ! ( x & m ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { cout << subtractOne ( 13 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const double PI = 3.142 ; double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * -1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; } int main ( ) { float x = 50 ; int n = 5 ; cout << cosXSertiesSum ( x , 5 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findBucketNo ( int p ) { return ceil ( ( sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; } int main ( ) { int p = 10 ; cout << findBucketNo ( p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  50002 NEW_LINE vector < int > primes ; void sieve ( ) { bool isPrime [ MAX ] ; memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( isPrime [ p ] ) primes . push_back ( p ) ; } long long int power ( long long int x , long long int y ) { long long int count = 0 ; long long int z = y ; while ( x >= z ) { count += ( x / z ) ; z *= y ; } return count ; } long long int modMult ( long long int a , long long int b , long long int mod ) { long long int res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } long long int countWays ( long long int n , long long int m ) { long long int ans = 1 ; for ( int i = 1 ; i < primes . size ( ) ; i ++ ) { long long int powers = power ( n , primes [ i ] ) ; if ( powers == 0 ) break ; ans = modMult ( ans , powers + 1 , m ) % m ; } if ( ( ( ans - 1 ) % m ) < 0 ) return ( ans - 1 + m ) % m ; else return ( ans - 1 ) % m ; } int main ( ) { sieve ( ) ; long long int n = 4 , m = 7 ; cout << countWays ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { cout << i << " , ▁ " << j << " , ▁ " << k ; return ; } } } cout << " No ▁ Triplet " ; } int main ( ) { int n = 12 ; pythagoreanTriplet ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } int repeatedNumberSum ( int n , int x ) { int sum = x * digSum ( n ) ; return digSum ( sum ) ; } int main ( ) { int n = 24 , x = 3 ; cout << repeatedNumberSum ( n , x ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX  100000 NEW_LINE int multiply ( int x , int res [ ] , int res_size ) { int carry = 0 ; for ( int i = 0 ; i < res_size ; i ++ ) { int prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry ) { res [ res_size ] = carry % 10 ; carry = carry / 10 ; res_size ++ ; } return res_size ; } void power ( int x , int n ) { if ( n == 0 ) { cout << "1" ; return ; } int res [ MAX ] ; int res_size = 0 ; int temp = x ; while ( temp != 0 ) { res [ res_size ++ ] = temp % 10 ; temp = temp / 10 ; } for ( int i = 2 ; i <= n ; i ++ ) res_size = multiply ( x , res , res_size ) ; cout << x << " ^ " << n << " ▁ = ▁ " ; for ( int i = res_size - 1 ; i >= 0 ; i -- ) cout << res [ i ] ; } int main ( ) { int exponent = 100 ; int base = 20 ; power ( base , exponent ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double findArea ( double d ) { return ( d * d ) / 2.0 ; } int main ( ) { double d = 10 ; cout << ( findArea ( d ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void findNumbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) cout << "1" << " ▁ " ; cout << "2" << " ▁ " ; cout << n + d << endl ; } int main ( ) { int N = 3 , D = 5 ; findNumbers ( N , D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } int main ( ) { int n = 2 ; cout << AvgofSquareN ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LCM ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; } int lcmOfNumerator ( vector < pair < int , int > > vect ) { int lcm = vect [ 0 ] . first ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) lcm = LCM ( vect [ i ] . first , lcm ) ; return lcm ; } int gcdOfDemoninators ( vector < pair < int , int > > vect ) { int gcd = vect [ 0 ] . second ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) gcd = __gcd ( vect [ i ] . second , gcd ) ; return gcd ; } void lcmOfRationals ( vector < pair < int , int > > vect ) { cout << lcmOfNumerator ( vect ) << " / " << gcdOfDemoninators ( vect ) ; } int main ( ) { vector < pair < int , int > > vect ; vect . push_back ( make_pair ( 2 , 7 ) ) ; vect . push_back ( make_pair ( 3 , 14 ) ) ; vect . push_back ( make_pair ( 5 , 3 ) ) ; lcmOfRationals ( vect ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * pow ( r , i - 1 ) ) ) ; return sum ; } int main ( ) { int a = 1 , d = 1 , b = 2 , r = 2 , n = 3 ; cout << sumofNterm ( a , d , b , r , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return -1 ; } int main ( ) { int a = 1 , b = 4 , c = 5 ; cout << first ( a , b , c ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isPrime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; } int minimumSum ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; } int main ( ) { int n = 27 ; cout << minimumSum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; } int main ( ) { int n = 4 ; cout << term ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; } int main ( ) { int x = 2 ; int n = 5 ; cout << fixed << setprecision ( 2 ) << sum ( x , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( fabs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - floor ( a / b ) * b ) ) ; } int main ( ) { double a = 1.20 , b = 22.5 ; cout << gcd ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void gcdMax ( int a [ ] , int b [ ] , int n , int N ) { int cnt [ N ] = { 0 } ; int first [ N ] = { 0 } , second [ N ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] ) first [ i ] = max ( first [ i ] , j ) ; memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = true ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] ) second [ i ] = max ( second [ i ] , j ) ; int i ; for ( i = N - 1 ; i >= 0 ; i -- ) if ( first [ i ] && second [ i ] ) break ; cout << " Maximum ▁ GCD ▁ pair ▁ with ▁ maximum ▁ " " sum ▁ is ▁ " << first [ i ] << " ▁ " << second [ i ] << endl ; } int main ( ) { int a [ ] = { 3 , 1 , 4 , 2 , 8 } ; int b [ ] = { 5 , 2 , 12 , 8 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int N = 20 ; gcdMax ( a , b , n , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + 1 ; for ( int j = r ; j < n ; j ++ ) { if ( a [ i ] == a [ j ] ) r += 1 ; else break ; } int d = r - i ; ans += ( d * ( d + 1 ) / 2 ) ; i = r - 1 ; } return ans ; } int main ( ) { int a [ ] = { 2 , 4 , 5 , 3 , 3 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << calculate ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int n ) { int rem = 0 ; int sum_of_digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_of_digits += rem ; n = n / 10 ; } return sum_of_digits ; } int count ( int n ) { int c = 0 ; for ( int i = n - 97 ; i <= n ; i ++ ) { int a = sum ( i ) ; int b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; } int main ( ) { int n = 9939 ; cout << count ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #include <cmath> NEW_LINE vector < int > SieveOfEratosthenes ( int n ) { bool prime [ n + 1 ] ; memset ( prime , false , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = true ; } vector < int > lis ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) lis . push_back ( p ) ; return lis ; } int setBits ( int n ) { return __builtin_popcount ( n ) ; } int main ( ) { int x = 4 , y = 8 ; int count = 0 ; vector < int > primeArr = SieveOfEratosthenes ( ceil ( log2 ( y ) ) ) ; for ( int i = x ; i < y + 1 ; i ++ ) { int temp = setBits ( i ) ; for ( int j = 0 ; j < primeArr . size ( ) ; j ++ ) { if ( temp == primeArr [ j ] ) { count += 1 ; break ; } } } cout << count << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTrailingZeroes ( int N ) { int res = log2 ( N ^ ( N - 1 ) ) ; return res >= 0 ? res : 0 ; } int main ( ) { int N = 12 ; cout << countTrailingZeroes ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int prod_of_max_min ( int n ) { int largest = 0 ; int smallest = 10 ; while ( n ) { int r = n % 10 ; largest = max ( r , largest ) ; smallest = min ( r , smallest ) ; n = n / 10 ; } return largest * smallest ; } int formed_no ( int N , int K ) { if ( K == 1 ) { return N ; } int answer = N ; while ( K -- ) { int a_current = prod_of_max_min ( answer ) ; if ( a_current == 0 ) break ; answer += a_current ; } return answer ; } int main ( ) { int N = 487 , K = 100000000 ; cout << formed_no ( N , K ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int subsetSum ( int arr [ ] , int n , int i , int sum , int count ) { if ( i == n ) { if ( sum == 0 ) { count ++ ; } return count ; } count = subsetSum ( arr , n , i + 1 , sum - arr [ i ] , count ) ; count = subsetSum ( arr , n , i + 1 , sum , count ) ; return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int sum = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subsetSum ( arr , n , 0 , sum , 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool doesContainB ( int a , int b , int c ) { if ( a == b ) return true ; if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) return true ; return false ; } int main ( ) { int a = 1 , b = 7 , c = 3 ; if ( doesContainB ( a , b , c ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <stdio.h> NEW_LINE int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } int main ( ) { printf ( " % d " , subtractOne ( 13 ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digitSum ( long long int n ) { int digSum = 0 ; while ( n ) { digSum += n % 10 ; n /= 10 ; } return digSum ; } long long int countInteger ( long long int n , long long int s ) { if ( n < s ) return 0 ; for ( long long int i = s ; i <= min ( n , s + 163 ) ; i ++ ) if ( ( i - digitSum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; } int main ( ) { long long int n = 1000 , s = 100 ; cout << countInteger ( n , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float sumOfSeries ( int n ) { return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) ; } int main ( ) { int n = 3 ; cout << sumOfSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { cout << -1 << endl ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) cout << r * i << " ▁ " ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; cout << res << endl ; } } int main ( ) { int n = 24 ; int k = 4 ; print_sequence ( n , k ) ; n = 24 , k = 5 ; print_sequence ( n , k ) ; n = 6 , k = 4 ; print_sequence ( n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigit ( long long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; } int main ( void ) { long long n = 345289467 ; cout << " Number ▁ of ▁ digits ▁ : " << countDigit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string decToBin ( int n ) { if ( n == 0 ) return "0" ; string bin = " " ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; } int main ( ) { int n = 38 ; cout << decToBin ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool findNoIsDivisibleOrNot ( int a [ ] , int n , int l ) { for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; } int main ( ) { int a [ ] = { 14 , 12 , 4 , 18 } ; int n = 2 ; int l = ( sizeof ( a ) / sizeof ( a [ 0 ] ) ) ; if ( findNoIsDivisibleOrNot ( a , n , l ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; } int main ( ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getTotalXorOfSubarrayXors ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNthEvenDigitNumber ( int n ) { if ( n == 1 ) return 0 ; vector < int > v ; n = n - 1 ; while ( n > 0 ) { v . push_back ( n % 5 ) ; n = n / 5 ; } int result = 0 ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v [ i ] ; } return 2 * result ; } int main ( ) { cout << findNthEvenDigitNumber ( 2 ) << endl ; cout << findNthEvenDigitNumber ( 10 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long moduloMultiplication ( long long a , long long b , long long mod ) { a %= mod ; while ( b ) { if ( b & 1 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; } return res ; } int main ( ) { long long a = 426 ; long long b = 964 ; long long m = 235 ; cout << moduloMultiplication ( a , b , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void kFactors ( int n , int k ) { vector < int > P ; while ( n % 2 == 0 ) { P . push_back ( 2 ) ; n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . push_back ( i ) ; } } if ( n > 2 ) P . push_back ( n ) ; if ( P . size ( ) < k ) { cout << " - 1" << endl ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) cout << P [ i ] << " , ▁ " ; int product = 1 ; for ( int i = k - 1 ; i < P . size ( ) ; i ++ ) product = product * P [ i ] ; cout << product << endl ; } int main ( ) { int n = 54 , k = 3 ; kFactors ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE int perfectDiv [ MAX ] ; void precomputeCounts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) { for ( int j = i * i ; j < MAX ; j += i * i ) ++ perfectDiv [ j ] ; } } int countPerfectDivisors ( int n ) { return perfectDiv [ n ] ; } int main ( ) { precomputeCounts ( ) ; int n = 16 ; cout << " Total ▁ perfect ▁ divisors ▁ of ▁ " << n << " ▁ = ▁ " << countPerfectDivisors ( n ) << " STRNEWLINE " ; n = 12 ; cout << " Total ▁ perfect ▁ divisors ▁ of ▁ " << n << " ▁ = ▁ " << countPerfectDivisors ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 ) ans *= 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; } int main ( ) { int n = 72 ; cout << findMinNumber ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n , bool prime [ ] ) { for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } void mersennePrimes ( int n ) { bool prime [ n + 1 ] ; SieveOfEratosthenes ( n , prime ) ; for ( int k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { long long num = ( 1 << k ) - 1 ; if ( prime [ num ] ) cout << num << " ▁ " ; } } int main ( ) { int n = 31 ; cout << " Mersenne ▁ prime ▁ numbers ▁ smaller ▁ " << " than ▁ or ▁ equal ▁ to ▁ " << n << endl ; mersennePrimes ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfect ( int n ) { int s = sqrt ( n ) ; return ( s * s == n ) ; } int divisorsCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count += 1 ; else count += 2 ; } } return count ; } int kDivisors ( int a , int b , int k ) { for ( int i = a ; i <= b ; i ++ ) { if ( isPerfect ( i ) ) if ( divisors ( i ) == k ) count ++ ; } return count ; } int main ( ) { int a = 2 , b = 49 , k = 3 ; cout << kDivisors ( a , b , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long ll ; int findCountOfSolutions ( int n , int p ) { ll ans = 0 ; for ( ll x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { ll last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; } int main ( ) { ll n = 10 , p = 5 ; printf ( " % lld STRNEWLINE " , findCountOfSolutions ( n , p ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int kaprekarRec ( int n , int & prev ) { if ( n == 0 ) return 0 ; prev = n ; int digits [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { digits [ i ] = n % 10 ; n = n / 10 ; } sort ( digits , digits + 4 ) ; int asc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) asc = asc * 10 + digits [ i ] ; sort ( digits , digits + 4 , std :: greater < int > ( ) ) ; int desc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) desc = desc * 10 + digits [ i ] ; int diff = abs ( asc - desc ) ; if ( diff == prev ) return diff ; return kaprekarRec ( diff , prev ) ; } int kaprekar ( int n ) { int prev = 0 ; return kaprekarRec ( n , prev ) ; } int main ( ) { cout << kaprekar ( 1000 ) << endl ; cout << kaprekar ( 1112 ) << endl ; cout << kaprekar ( 9812 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; char xor_c ( char a , char b ) { return ( a == b ) ? '0' : '1' ; } char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; } string binarytoGray ( string binary ) { string gray = " " ; gray += binary [ 0 ] ; for ( int i = 1 ; i < binary . length ( ) ; i ++ ) { gray += xor_c ( binary [ i - 1 ] , binary [ i ] ) ; } return gray ; } string graytoBinary ( string gray ) { string binary = " " ; binary += gray [ 0 ] ; for ( int i = 1 ; i < gray . length ( ) ; i ++ ) { if ( gray [ i ] == '0' ) binary += binary [ i - 1 ] ; else binary += flip ( binary [ i - 1 ] ) ; } return binary ; } int main ( ) { string binary = "01001" ; cout << " Gray ▁ code ▁ of ▁ " << binary << " ▁ is ▁ " << binarytoGray ( binary ) << endl ; string gray = "01101" ; cout << " Binary ▁ code ▁ of ▁ " << gray << " ▁ is ▁ " << graytoBinary ( gray ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSum ( int BITree [ ] , int index ) { while ( index > 0 ) { sum += BITree [ index ] ; index -= index & ( - index ) ; } return sum ; } void updateBIT ( int BITree [ ] , int n , int index , int val ) { while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } } void convert ( int arr [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; sort ( temp , temp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = lower_bound ( temp , temp + n , arr [ i ] ) - temp + 1 ; } } int getInvCount ( int arr [ ] , int n ) { convert ( arr , n ) ; int BIT [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BIT [ i ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { invcount += getSum ( BIT , arr [ i ] - 1 ) ; updateBIT ( BIT , n , arr [ i ] , 1 ) ; } return invcount ; } int main ( ) { int arr [ ] = { 8 , 4 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << " Number ▁ of ▁ inversions ▁ are ▁ : ▁ " << getInvCount ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int mod ( string num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; } int main ( ) { string num = "12316767678678" ; cout << mod ( num , 10 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; } int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) { cout << " Phi " << " ( " << n << " ) " << " ▁ = ▁ " << phi ( n ) << endl ; } return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int largestPower ( int n , int p ) { int x = 0 ; while ( n ) { n /= p ; x += n ; } return x ; } int main ( ) { int n = 10 , p = 3 ; cout << " The ▁ largest ▁ power ▁ of ▁ " << p << " ▁ that ▁ divides ▁ " << n << " ! ▁ is ▁ " << largestPower ( n , p ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { cout << square << " ▁ " ; square = square + odd ; odd = odd + 2 ; } } int main ( ) { int n = 5 ; printSquares ( n ) ; }
#include <iostream> NEW_LINE using namespace std ; int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } int main ( ) { int num = 5 ; cout << " Factorial ▁ of ▁ " << num << " ▁ is ▁ " << factorial ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Or_of_Ands_for_each_query ( int arr [ ] , int n , int queries [ ] [ 2 ] , int q ) { int bits [ 32 ] = { 0 } ; for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( 1 << i ) & arr [ j ] ) { bits [ i ] ++ ; } } } for ( int p = 0 ; p < q ; p ++ ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( 1 << i ) & arr [ queries [ p ] [ 0 ] ] ) { bits [ i ] -- ; } if ( queries [ p ] [ 1 ] & ( 1 << i ) ) { bits [ i ] ++ ; } } arr [ queries [ p ] [ 0 ] ] = queries [ p ] [ 1 ] ; int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( bits [ i ] != 0 ) { ans |= ( 1 << i ) ; } } cout << ans << endl ; } } int main ( ) { int n = 3 , q = 2 ; int arr [ ] = { 3 , 5 , 7 } ; int queries [ 2 ] [ 2 ] = { { 1 , 2 } , { 2 , 1 } } ; Or_of_Ands_for_each_query ( arr , n , queries , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findmax ( int arr [ ] , int n , int k ) { int trav , i ; int c = 0 , maximum = 0 ; for ( i = 0 ; i < n - k + 1 ; i ++ ) { trav = i - 1 ; c = 0 ; while ( trav >= 0 && arr [ trav ] == 1 ) { trav -- ; c ++ ; } trav = i + k ; while ( trav < n && arr [ trav ] == 1 ) { trav ++ ; c ++ ; } c += k ; if ( c > maximum ) maximum = c ; } return maximum ; } int main ( ) { int k = 3 ; int arr [ ] = { 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int ans = findmax ( arr , n , k ) ; cout << ans << ' ' ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAndXor ( int arr [ ] , int n ) { int ans = INT_MAX ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxAndXor ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubarray ( int arr [ ] , int K , int N ) { if ( K % 2 != 0 ) return 0 ; if ( N < K ) return 0 ; int start = 0 ; int i = 0 ; int count = 0 ; int currXor = arr [ i ++ ] ; while ( i < K ) { currXor ^= arr [ i ] ; i ++ ; } if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ++ ] ; while ( i < N ) { currXor ^= arr [ i ] ; i ++ ; if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ++ ] ; } return count ; } int main ( ) { int arr [ ] = { 2 , 4 , 4 , 2 , 2 , 4 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( countSubarray ( arr , K , N ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumFlips ( int X , int Y , int Z ) { int res = 0 ; while ( X > 0 Y > 0 Z > 0 ) { if ( ( ( X & 1 ) || ( Y & 1 ) ) && ( Z & 1 ) ) { X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; continue ; } else if ( ! ( X & 1 ) && ! ( Y & 1 ) && ( Z & 1 ) ) { res ++ ; } else if ( ( X & 1 ) || ( Y & 1 ) == 1 ) { if ( ( X & 1 ) && ( Y & 1 ) && ! ( Z & 1 ) ) { res += 2 ; } else if ( ( ( X & 1 ) || ( Y & 1 ) ) && ! ( Z & 1 ) ) { res ++ ; } } X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; } return res ; } int main ( ) { int X = 5 , Y = 8 , Z = 6 ; cout << minimumFlips ( X , Y , Z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) & 1 ) { n = n ^ ( 1ll << bit ) ; break ; } } cout << " The ▁ number ▁ after ▁ unsetting ▁ the " ; cout << " ▁ rightmost ▁ set ▁ bit ▁ " << n ; } int main ( ) { int N = 12 ; FlipBits ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } int main ( ) { int n = 10 ; cout << bitwiseAndOdd ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long multiplyByFifteen ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; } int main ( ) { long n = 7 ; cout << multiplyByFifteen ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countX ( int n ) { string binary = bitset < 8 > ( n ) . to_string ( ) ; int count = 0 ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { if ( binary . at ( i ) == '1' ) count ++ ; } int answer = ( int ) pow ( 2 , count ) ; return answer ; } int main ( ) { int n = 5 ; int answer = countX ( n ) ; cout << ( answer ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void alternate ( int & a , int & b , int & x ) { x = a ^ b ^ x ; } int main ( ) { int a = -10 ; int b = 15 ; int x = a ; cout << " x ▁ is ▁ : ▁ " << x ; alternate ( a , b , x ) ; cout << " After exchange " cout << " STRNEWLINE x ▁ is ▁ : ▁ " << x ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } cout << " Number ▁ of ▁ different ▁ bits ▁ : ▁ " << count << endl ; } int main ( ) { int A = 12 , B = 15 ; solve ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; Node * newNode ( int data ) { Node * node = new Node ; node -> data = data ; node -> left = node -> right = NULL ; return ( node ) ; } void printSetBit ( Node * root ) { if ( root == NULL ) return ; cout << " Set ▁ bits ▁ in ▁ Node ▁ " << root -> data << " ▁ = ▁ " << __builtin_popcount ( root -> data ) << " STRNEWLINE " ; printSetBit ( root -> left ) ; printSetBit ( root -> right ) ; } int main ( ) { Node * root = newNode ( 16 ) ; root -> left = newNode ( 13 ) ; root -> left -> left = newNode ( 14 ) ; root -> left -> right = newNode ( 12 ) ; root -> right = newNode ( 11 ) ; root -> right -> left = newNode ( 10 ) ; root -> right -> right = newNode ( 16 ) ; printSetBit ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MakePreSum ( int arr [ ] , int presum [ ] , int n ) { presum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) presum [ i ] = presum [ i - 1 ] + arr [ i ] ; } int BinaryLifting ( int presum [ ] , int n , int x ) { int pos = 0 ; int LOGN = log2 ( n ) ; if ( x <= presum [ 0 ] ) return 0 ; for ( int i = LOGN ; i >= 0 ; i -- ) { if ( pos + ( 1 << i ) < n && presum [ pos + ( 1 << i ) ] < x ) { pos += ( 1 << i ) ; } } return pos + 1 ; } int main ( ) { int arr [ ] = { 2 , 5 , 7 , 1 , 6 , 9 , 12 , 4 , 6 } ; int x = 8 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int presum [ n ] = { 0 } ; MakePreSum ( arr , presum , n ) ; cout << BinaryLifting ( presum , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; } int main ( ) { unsigned int n = 17 ; unsigned int l = 2 , r = 4 ; if ( allBitsSetInTheGivenRange ( n , l , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool onlyFirstAndLastAreSet ( unsigned int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; } int main ( ) { unsigned int n = 9 ; if ( onlyFirstAndLastAreSet ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  unsigned int NEW_LINE using namespace std ; ll minimize ( ll a ) { ll n = _popcnt32 ( a ) ; return ( pow ( 2 , n ) - 1 ) ; } int main ( ) { ll a = 11 ; cout << minimize ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } void constructSTUtil ( int arr [ ] , int ss , int se , int * st , int si , int operation ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return ; } int mid = getMid ( ss , se ) ; constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , ! operation ) ; constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , ! operation ) ; if ( operation == 1 ) { st [ si ] = ( st [ 2 * si + 1 ] st [ 2 * si + 2 ] ) ; } else { st [ si ] = ( st [ 2 * si + 1 ] ^ st [ 2 * si + 2 ] ) ; } } int * constructST ( int arr [ ] , int n ) { int x = ( int ) ( ceil ( log2 ( n ) ) ) ; int max_size = 2 * ( int ) pow ( 2 , x ) - 1 ; int * st = new int [ max_size ] ; int operationAtRoot = ( x % 2 == 0 ? 0 : 1 ) ; constructSTUtil ( arr , 0 , n - 1 , st , 0 , operationAtRoot ) ; return st ; } int main ( ) { int leaves [ ] = { 1 , 6 , 3 , 7 , 5 , 9 , 10 , 4 } ; int n = sizeof ( leaves ) / sizeof ( leaves [ 0 ] ) ; int * segmentTree = constructST ( leaves , n ) ; int rootIndex = 0 ; cout << " Value ▁ at ▁ Root ▁ Node ▁ = ▁ " << segmentTree [ rootIndex ] ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isFibbinaryNum ( unsigned int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; } int main ( ) { unsigned int n = 10 ; if ( isFibbinaryNum ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divide ( long long dividend , long long divisor ) { int sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? -1 : 1 ; dividend = abs ( dividend ) ; divisor = abs ( divisor ) ; long long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1LL << i ; } } if ( sign == -1 ) quotient = - quotient ; return quotient ; } int main ( ) { int a = 10 , b = 3 ; cout << divide ( a , b ) << " STRNEWLINE " ; a = 43 , b = -8 ; cout << divide ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = max ( res , arr [ i ] & arr [ j ] ) ; return res ; } int main ( ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ AND ▁ Value ▁ = ▁ " << maxAND ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int setAllBitsAfterMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; } void toggle ( int & n ) { n = n ^ setAllBitsAfterMSB ( n ) ; } int main ( ) { int n = 10 ; toggle ( n ) ; cout << n ; return 0 ; }
#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; int constructNthNumber ( int group_no , int aux_num , int op ) { int INT_SIZE = 32 ; int a [ INT_SIZE ] = { 0 } ; int num = 0 , len_f ; int i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; } int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { op = 2 ; aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 ) op = 0 ; else op = 1 ; aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; } int main ( ) { int n = 9 ; cout << getNthNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int toggleLastMBits ( unsigned int n , unsigned int m ) { unsigned int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; } int main ( ) { unsigned int n = 107 ; unsigned int m = 4 ; cout << toggleLastMBits ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorPairCount ( int arr [ ] , int n , int x ) { unordered_map < int , int > m ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . find ( curr_xor ) != m . end ( ) ) result += m [ curr_xor ] ; m [ arr [ i ] ] ++ ; } return result ; } int main ( ) { int arr [ ] = { 2 , 5 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 0 ; cout << " Count ▁ of ▁ pairs ▁ with ▁ given ▁ XOR ▁ = ▁ " << xorPairCount ( arr , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( int arr [ ] , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; } int main ( ) { int arr [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxLength ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDigits ( int N , int K ) { int digits_num = floor ( log10 ( N ) + 1 ) ; int temp_sum = 0 ; int temp = digits_num ; int result ; int X , var ; int sum = 0 ; int num2 = N ; while ( num2 != 0 ) { sum += num2 % 10 ; num2 /= 10 ; } if ( sum <= K ) { X = 0 ; } else { while ( temp > 0 ) { var = ( N / ( pow ( 10 , temp - 1 ) ) ) ; temp_sum += var % 10 ; if ( temp_sum >= K ) { var /= 10 ; var ++ ; result = var * pow ( 10 , temp ) ; break ; } temp -- ; } X = result - N ; return X ; } } int main ( ) { int N = 11 , K = 1 ; cout << minDigits ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int upperBound ( int arr [ ] , int N , int K ) { int l = 0 ; int r = N ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] <= K ) { l = mid + 1 ; } else { r = mid ; } } return l ; } void NDivKWithFreq ( int arr [ ] , int N , int K ) { sort ( arr , arr + N ) ; int i = 0 ; while ( i < N ) { int X = upperBound ( arr , N , arr [ i ] ) ; if ( ( X - i ) > N / 4 ) { cout << arr [ i ] << " ▁ " ; } i = X ; } } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 6 , 6 , 6 , 6 , 7 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; NDivKWithFreq ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float getMaxMedian ( int arr [ ] , int n , int k ) { int size = n + k ; sort ( arr , arr + n ) ; if ( size % 2 == 0 ) { float median = ( float ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } float median = arr [ size / 2 ] ; return median ; } int main ( ) { int arr [ ] = { 3 , 2 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << getMaxMedian ( arr , n , k ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; # define MAX  26 NEW_LINE bool function ( string str ) { int l = str . length ( ) ; int counter [ MAX ] ; memset ( counter , 0 , sizeof ( counter ) ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) counter [ str [ i ] - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter [ str [ i ] - ' a ' ] -- ; for ( int i = 0 ; i < MAX ; i ++ ) if ( counter [ i ] != 0 ) return true ; return false ; } int main ( ) { string str = " abcasdsabcae " ; if ( function ( str ) ) cout << " Yes , ▁ both ▁ halves ▁ differ " << " ▁ by ▁ at ▁ least ▁ one ▁ character " ; else cout << " No , ▁ both ▁ halves ▁ do " << " ▁ not ▁ differ ▁ at ▁ all " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSorted ( int a , int b , int c ) { int get_max = max ( a , max ( b , c ) ) ; int get_min = - max ( - a , max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; cout << get_min << " ▁ " << get_mid << " ▁ " << get_max ; } int main ( ) { int a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void insertionSort ( int arr [ ] , int n ) { int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; insertionSort ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxNumPalindrome ( string S ) { int i = 0 ; int freq [ 26 ] = { 0 } ; int freqPair = 0 ; int len = S . length ( ) / 3 ; while ( i < S . length ( ) ) { freq [ S [ i ] - ' a ' ] ++ ; i ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { freqPair += ( freq [ i ] / 2 ) ; } return min ( freqPair , len ) ; } int main ( ) { string S = " geeksforg " ; cout << maxNumPalindrome ( S ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int height ( int s , vector < int > adj [ ] , int * visited ) { visited [ s ] = 1 ; int h = 0 ; for ( auto & child : adj [ s ] ) { if ( visited [ child ] == 0 ) { h = max ( h , 1 + height ( child , adj , visited ) ) ; } } return h ; } int minimumGroups ( vector < int > adj [ ] , int N ) { int visited [ N + 1 ] = { 0 } ; int groups = INT_MIN ; for ( int i = 1 ; i <= N ; i ++ ) { if ( visited [ i ] == 0 ) { int comHeight ; comHeight = height ( i , adj , visited ) ; groups = max ( groups , comHeight ) ; } } return groups ; } void addEdge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } int main ( ) { int N = 5 ; vector < int > adj [ N + 1 ] ; addEdge ( adj , 1 , 2 ) ; addEdge ( adj , 3 , 2 ) ; addEdge ( adj , 4 , 3 ) ; cout << minimumGroups ( adj , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; } int main ( ) { int n = 11 , k = 2 ; cout << find_sum ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ; int minCost ( int cost [ R ] [ C ] , int m , int n ) { if ( n < 0 m < 0 ) return INT_MAX ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; cout << minCost ( cost , 2 , 2 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countSmaller ( string str ) { int n = str . length ( ) ; int arr [ 26 ] = { 0 } ; int ans [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { arr [ str [ i ] - ' a ' ] ++ ; int ct = 0 ; for ( int j = 0 ; j < str [ i ] - ' a ' ; j ++ ) { ct += arr [ j ] ; } ans [ i ] = ct ; } for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } int main ( ) { string str = " edcbaa " ; countSmaller ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string processWords ( char * input ) { char * p ; vector < string > s ; p = strtok ( input , " ▁ " ) ; while ( p != NULL ) { s . push_back ( p ) ; p = strtok ( NULL , " ▁ " ) ; } string charBuffer ; for ( string values : s ) charBuffer += values [ 0 ] ; return charBuffer ; } int main ( ) { char input [ ] = " geeks ▁ for ▁ geeks " ; cout << processWords ( input ) ; return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE #include <vector> NEW_LINE using namespace std ; void generateGrayarr ( int n ) { if ( n <= 0 ) return ; vector < string > arr ; arr . push_back ( "0" ) ; arr . push_back ( "1" ) ; int i , j ; for ( i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( j = i - 1 ; j >= 0 ; j -- ) arr . push_back ( arr [ j ] ) ; for ( j = 0 ; j < i ; j ++ ) arr [ j ] = "0" + arr [ j ] ; for ( j = i ; j < 2 * i ; j ++ ) arr [ j ] = "1" + arr [ j ] ; } for ( i = 0 ; i < arr . size ( ) ; i ++ ) cout << arr [ i ] << endl ; } int main ( ) { generateGrayarr ( 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  5 NEW_LINE using namespace std ; bool isSafe ( int row , int col , int m [ ] [ MAX ] , int n , bool visited [ ] [ MAX ] ) { if ( row == -1 row == n col == -1 col == n visited [ row ] [ col ] m [ row ] [ col ] == 0 ) return false ; return true ; } void printPathUtil ( int row , int col , int m [ ] [ MAX ] , int n , string & path , vector < string > & possiblePaths , bool visited [ ] [ MAX ] ) { if ( row == -1 row == n col == -1 col == n visited [ row ] [ col ] m [ row ] [ col ] == 0 ) return ; if ( row == n - 1 && col == n - 1 ) { possiblePaths . push_back ( path ) ; return ; } visited [ row ] [ col ] = true ; if ( isSafe ( row + 1 , col , m , n , visited ) ) { path . push_back ( ' D ' ) ; printPathUtil ( row + 1 , col , m , n , path , possiblePaths , visited ) ; path . pop_back ( ) ; } if ( isSafe ( row , col - 1 , m , n , visited ) ) { path . push_back ( ' L ' ) ; printPathUtil ( row , col - 1 , m , n , path , possiblePaths , visited ) ; path . pop_back ( ) ; } if ( isSafe ( row , col + 1 , m , n , visited ) ) { path . push_back ( ' R ' ) ; printPathUtil ( row , col + 1 , m , n , path , possiblePaths , visited ) ; path . pop_back ( ) ; } if ( isSafe ( row - 1 , col , m , n , visited ) ) { path . push_back ( ' U ' ) ; printPathUtil ( row - 1 , col , m , n , path , possiblePaths , visited ) ; path . pop_back ( ) ; } visited [ row ] [ col ] = false ; } void printPath ( int m [ MAX ] [ MAX ] , int n ) { vector < string > possiblePaths ; string path ; bool visited [ n ] [ MAX ] ; memset ( visited , false , sizeof ( visited ) ) ; printPathUtil ( 0 , 0 , m , n , path , possiblePaths , visited ) ; for ( int i = 0 ; i < possiblePaths . size ( ) ; i ++ ) cout << possiblePaths [ i ] << " ▁ " ; } int main ( ) { int m [ MAX ] [ MAX ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 } } ; int n = sizeof ( m ) / sizeof ( m [ 0 ] ) ; printPath ( m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDirectPath ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; } int main ( ) { int N = 5 ; cout << countDirectPath ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( pow ( ( x - h ) , 2 ) / pow ( a , 2 ) ) + ( pow ( ( y - k ) , 2 ) / pow ( b , 2 ) ) ; return p ; } int main ( ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 , b = 5 ; if ( checkpoint ( h , k , x , y , a , b ) > 1 ) cout << " Outside " << endl ; else if ( checkpoint ( h , k , x , y , a , b ) == 1 ) cout << " On ▁ the ▁ ellipse " << endl ; else cout << " Inside " << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void center ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " , ▁ " << ( float ) ( y1 + y2 ) / 2 ; } int main ( ) { int x1 = -9 , y1 = 3 , x2 = 5 , y2 = -7 ; center ( x1 , x2 , y1 , y2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } int main ( ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; cout << " Area ▁ is : ▁ " << area ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double areaCube ( double a ) { return ( a * a * a ) ; } double surfaceCube ( double a ) { return ( 6 * a * a ) ; } int main ( ) { double a = 5 ; cout << " Area ▁ = ▁ " << areaCube ( a ) << endl ; cout << " Total ▁ surface ▁ area ▁ = ▁ " << surfaceCube ( a ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; pair < double , double > mirrorImage ( double a , double b , double c , double x1 , double y1 ) { double temp = -2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; double x = temp * a + x1 ; double y = temp * b + y1 ; return make_pair ( x , y ) ; } int main ( ) { double a = -1.0 ; double b = 1.0 ; double c = 0.0 ; double x1 = 1.0 ; double y1 = 0.0 ; pair < double , double > image = mirrorImage ( a , b , c , x1 , y1 ) ; cout << " Image ▁ of ▁ point ▁ ( " << x1 << " , ▁ " << y1 << " ) ▁ " ; cout << " by ▁ mirror ▁ ( " << a << " ) x ▁ + ▁ ( " << b << " ) y ▁ + ▁ ( " << c << " ) ▁ = ▁ 0 , ▁ is ▁ : " ; cout << " ( " << image . first << " , ▁ " << image . second << " ) " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { if ( n == 1 n == 0 ) return 1 ; else return n * fact ( n - 1 ) ; } int findValue ( int n , int r , int a ) { int k = ( a - 1 ) / fact ( n ) ; int answer = k ; for ( int i = 1 ; i < n + 1 ; i ++ ) answer = answer * ( n + r - i ) ; answer = answer + 1 ; return answer ; } int main ( ) { int N = 1 ; int A = 2 ; int R = 3 ; cout << ( findValue ( N , R , A ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countNo ( int A , int N , int L , int R ) { int ans = L - 1 + N + floor ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } cout << ans << endl ; } int main ( ) { int A = 5 , N = 10 , L = 4 , R = 20 ; countNo ( A , N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE bool prime [ MAX ] ; void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } } int sumPrime ( int k ) { SieveOfEratosthenes ( ) ; vector < int > v ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) v . push_back ( i ) ; } int sum = 0 ; int skip = ( k * ( k - 1 ) ) / 2 ; while ( k > 0 ) { sum += v [ skip ] ; skip ++ ; k -- ; } return sum ; } int main ( ) { int k = 3 ; cout << sumPrime ( k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextOccurrence ( string str , int n , int start , char ch ) { for ( int i = start ; i < n ; i ++ ) { if ( str [ i ] == ch ) return i ; } return -1 ; } int countSubStr ( string str , int n , char ch ) { int cnt = 0 ; int j = nextOccurrence ( str , n , 0 , ch ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j != -1 && j < i ) { j = nextOccurrence ( str , n , j + 1 , ch ) ; } if ( j == -1 ) break ; cnt += ( n - j ) ; } return cnt ; } int main ( ) { string str = " geeksforgeeks " ; int n = str . length ( ) ; char ch = ' k ' ; cout << countSubStr ( str , n , ch ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int x , unsigned int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } int main ( ) { int L = 2 , P = pow ( 10 , 9 ) ; int ans = power ( 325 , L , P ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void revereseArray ( int arr [ ] , int n ) { int rev [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rev [ n - i - 1 ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = rev [ i ] ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printArray ( arr , n ) ; revereseArray ( arr , n ) ; cout << " Reversed ▁ array ▁ is " << endl ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findString ( string str , int M ) { int N = str . length ( ) ; M = min ( M , N ) ; string s1 = " " ; while ( M != 0 ) { s1 = " " ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '0' ) { if ( ( str [ i - 1 ] == '1' && str [ i + 1 ] != '1' ) || ( str [ i - 1 ] != '1' && str [ i + 1 ] == '1' ) ) s1 += '1' ; else s1 += '0' ; } else s1 += '1' ; } if ( str == s1 ) break ; str = s1 ; M -- ; } cout << s1 ; } int main ( ) { string str = "0110100" ; int M = 3 ; findString ( str , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void indivisibleDigits ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int num = 0 ; cout << arr [ i ] << " : ▁ " ; for ( int j = 2 ; j < 10 ; j ++ ) { int temp = arr [ i ] ; bool flag = true ; while ( temp > 0 ) { if ( ( temp % 10 ) != 0 && ( temp % 10 ) % j == 0 ) { flag = false ; break ; } temp /= 10 ; } if ( flag ) { cout << j << ' ▁ ' ; } } cout << endl ; } } int main ( ) { int arr [ ] = { 4162 , 1152 , 99842 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; indivisibleDigits ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( string s1 , string s2 ) { int s1_0 = 0 , s2_0 = 0 ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( s1 [ i ] == '0' ) { s1_0 ++ ; } if ( s2 [ i ] == '0' ) { s2_0 ++ ; } } if ( s1_0 != s2_0 ) { cout << " NO " << endl ; return ; } else { int Count1 = 0 , Count2 = 0 ; for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) { if ( s1 [ i ] == '0' ) { Count1 ++ ; } if ( s2 [ i ] == '0' ) { Count2 ++ ; } if ( Count1 < Count2 ) { cout << " NO " << endl ; return ; } } cout << " YES " << endl ; } } int main ( ) { string s1 = "100111" ; string s2 = "111010" ; check ( s1 , s2 ) ; s1 = "110100" ; s2 = "010101" ; check ( s1 , s2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxEvenIntegers ( int arr [ ] , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = max ( ans , cnt ) ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 7 , 6 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxEvenIntegers ( arr , N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string check ( int arr [ ] , int n ) { map < int , int > hm ; for ( int i = 0 ; i < n ; i ++ ) { hm [ arr [ i ] ] = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { hm [ arr [ j ] ] ++ ; bool flag = false ; for ( auto x : hm ) { if ( x . second == 1 ) { flag = true ; break ; } } if ( ! flag ) return " No " ; } hm . clear ( ) ; } return " Yes " ; } int main ( ) { int arr [ ] = { 1 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << check ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_index ( int arr [ ] , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << find_index ( arr , n , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string str ) { int i = 0 , j = str . size ( ) - 1 ; while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; } void formPalindrome ( string a , string b , int n ) { char aa [ n + 2 ] ; char bb [ n + 2 ] ; for ( int i = 0 ; i < n + 2 ; i ++ ) { aa [ i ] = ' ▁ ' ; bb [ i ] = ' ▁ ' ; } for ( int i = 1 ; i <= n ; i ++ ) { aa [ i ] = a [ i - 1 ] ; bb [ i ] = b [ i - 1 ] ; } bool ok = false ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { string la = " " ; string ra = " " ; string lb = " " ; string rb = " " ; for ( int j = 1 ; j <= i - 1 ; j ++ ) { if ( aa [ j ] == ' ▁ ' ) la += " " ; else la += aa [ j ] ; if ( bb [ j ] == ' ▁ ' ) lb += " " ; else lb += bb [ j ] ; } for ( int j = i ; j <= n + 1 ; j ++ ) { if ( aa [ j ] == ' ▁ ' ) ra += " " ; else ra += aa [ j ] ; if ( bb [ j ] == ' ▁ ' ) rb += " " ; else rb += bb [ j ] ; } if ( isPalindrome ( la + rb ) || isPalindrome ( lb + ra ) ) { ok = true ; break ; } } if ( ok ) cout << ( " Yes " ) ; else cout << ( " No " ) ; } int main ( ) { string A = " bdea " ; string B = " abbb " ; int N = 4 ; formPalindrome ( A , B , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCrossed ( string path ) { if ( path . size ( ) == 0 ) return false ; bool ans = false ; set < pair < int , int > > set ; int x = 0 , y = 0 ; set . insert ( { x , y } ) ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { if ( path [ i ] == ' N ' ) set . insert ( { x , y ++ } ) ; if ( path [ i ] == ' S ' ) set . insert ( { x , y -- } ) ; if ( path [ i ] == ' E ' ) set . insert ( { x ++ , y } ) ; if ( path [ i ] == ' W ' ) set . insert ( { x -- , y } ) ; if ( set . find ( { x , y } ) != set . end ( ) ) { ans = true ; break ; } } if ( ans ) cout << " Crossed " ; else cout << " Not ▁ Crossed " ; } int main ( ) { string path = " NESW " ; isCrossed ( path ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lenghtOfLongestAP ( int A [ ] , int n ) { unordered_map < int , unordered_map < int , int > > dp ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; dp [ d ] [ j ] = dp [ d ] . count ( i ) ? dp [ d ] [ i ] + 1 : 2 ; res = max ( res , dp [ d ] [ j ] ) ; } } return res ; } int main ( ) { int arr [ ] = { 20 , 1 , 15 , 3 , 10 , 5 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << lenghtOfLongestAP ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkSumOfNatural ( int n ) { int i = 1 ; bool flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) cout << " YES " ; else cout << " NO " ; } int main ( ) { int n = 25 ; checkSumOfNatural ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int n ) { double sr = sqrt ( n ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } void SubarrayHavingPerfectSquare ( vector < int > arr , int k ) { pair < int , int > ans ; int sum = 0 , i ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } bool found = false ; if ( isPerfectSquare ( sum ) ) { ans . first = 0 ; ans . second = i - 1 ; } else { for ( int j = i ; j < arr . size ( ) ; j ++ ) { sum = sum + arr [ j ] - arr [ j - k ] ; if ( isPerfectSquare ( sum ) ) { found = true ; ans . first = j - k + 1 ; ans . second = j ; } } for ( int k = ans . first ; k <= ans . second ; k ++ ) { cout << arr [ k ] << " ▁ " ; } } if ( found == false ) { cout << " - 1" ; } } int main ( ) { vector < int > arr ; arr = { 20 , 34 , 51 , 10 , 99 , 87 , 23 , 45 } ; int K = 3 ; SubarrayHavingPerfectSquare ( arr , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mirrorMatrix ( int mat1 [ ] [ 4 ] , int mat2 [ ] [ 4 ] , int N ) { int row = 0 ; int col = 0 ; bool isMirrorImage = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int N = 4 ; int mat1 [ ] [ 4 ] = { { 1 , 2 , 3 , 4 } , { 0 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int mat2 [ ] [ 4 ] = { { 4 , 3 , 2 , 1 } , { 8 , 7 , 6 , 0 } , { 12 , 11 , 10 , 9 } , { 16 , 15 , 14 , 13 } } ; mirrorMatrix ( mat1 , mat2 , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int splitstring ( string s ) { int n = s . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '0' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ; int zerosInEachSubstring = zeros / 3 ; int waysOfFirstCut = 0 , waysOfSecondCut = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) count ++ ; if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ; else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; } return waysOfFirstCut * waysOfSecondCut ; } int main ( ) { string s = "01010" ; cout << " The ▁ number ▁ of ▁ ways ▁ to ▁ split ▁ is ▁ " << splitstring ( s ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool canTransform ( string str1 , string str2 ) { string s1 = " " ; string s2 = " " ; for ( char c : str1 ) { if ( c != ' C ' ) { s1 += c ; } } for ( char c : str2 ) { if ( c != ' C ' ) { s2 += c ; } } if ( s1 != s2 ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ; while ( i < n and j < n ) { if ( str1 [ i ] == ' C ' ) { i ++ ; } else if ( str2 [ j ] == ' C ' ) { j ++ ; } else { if ( ( str1 [ i ] == ' A ' and i < j ) or ( str1 [ i ] == ' B ' and i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; } int main ( ) { string str1 = " BCCABCBCA " ; string str2 = " CBACCBBAC " ; if ( canTransform ( str1 , str2 ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int X = 1 ; int diameter = 0 ; map < int , bool > mp ; void dfs ( int current_node , int prev_node , int len , bool add_to_map , vector < vector < int > > & adj ) { if ( len > diameter ) { diameter = len ; X = current_node ; } if ( add_to_map && len == diameter ) { mp [ current_node ] = 1 ; } for ( auto & it : adj [ current_node ] ) { if ( it != prev_node ) dfs ( it , current_node , len + 1 , add_to_map , adj ) ; } } void dfsUtility ( vector < vector < int > > & adj ) { dfs ( 1 , -1 , 0 , 0 , adj ) ; int farthest_node = X ; dfs ( farthest_node , -1 , 0 , 0 , adj ) ; dfs ( farthest_node , -1 , 0 , 1 , adj ) ; dfs ( X , -1 , 0 , 1 , adj ) ; } void printDiameters ( vector < vector < int > > & adj ) { dfsUtility ( adj ) ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( mp [ i ] == 1 ) cout << diameter + 1 << " , ▁ " ; else cout << diameter << " , ▁ " ; } } int main ( ) { vector < vector < int > > adj ( 7 ) ; adj [ 1 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 1 ) ; adj [ 1 ] . push_back ( 3 ) ; adj [ 3 ] . push_back ( 1 ) ; adj [ 2 ] . push_back ( 4 ) ; adj [ 4 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 5 ) ; adj [ 5 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 6 ) ; adj [ 6 ] . push_back ( 2 ) ; printDiameters ( adj ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int knapSack ( int nums [ ] , int S , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += nums [ i ] ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; int dp [ ( S + sum ) / 2 + 1 ] ; for ( int i = 0 ; i <= ( S + sum ) / 2 ; i ++ ) dp [ i ] = 0 ; dp [ 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int i = ( S + sum ) / 2 ; i >= nums [ j ] ; i -- ) { dp [ i ] += dp [ i - nums [ j ] ] ; } } return dp [ ( S + sum ) / 2 ] ; } int main ( ) { int S = 3 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int answer = knapSack ( arr , S , 5 ) ; cout << answer << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int no_of_substring ( string s , int N ) { int fre [ 26 ] ; int str_len ; str_len = ( int ) s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < str_len ; i ++ ) { memset ( fre , 0 , sizeof ( fre ) ) ; int max_index = 0 ; int dist = 0 ; for ( int j = i ; j < str_len ; j ++ ) { int x = s [ j ] - ' a ' ; if ( fre [ x ] == 0 ) dist ++ ; fre [ x ] ++ ; max_index = max ( max_index , fre [ x ] ) ; if ( dist >= N && ( ( max_index * dist ) == ( j - i + 1 ) ) ) count ++ ; } } return count ; } int main ( ) { string s = " abhay " ; int N = 3 ; cout << no_of_substring ( s , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mat [ 1001 ] [ 1001 ] ; int r , c , x , y ; int dx [ ] = { 0 , -1 , -1 , -1 , 0 , 1 , 1 , 1 } ; int dy [ ] = { 1 , 1 , 0 , -1 , -1 , -1 , 0 , 1 } ; void FindMinimumDistance ( ) { queue < pair < int , int > > q ; q . push ( { x , y } ) ; mat [ x ] [ y ] = 0 ; while ( ! q . empty ( ) ) { x = q . front ( ) . first ; y = q . front ( ) . second ; q . pop ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a > = r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . push ( { a , b } ) ; } } } } int main ( ) { r = 5 , c = 5 , x = 1 , y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; FindMinimumDistance ( ) ; mat [ t ] [ l ] = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { cout << mat [ i ] [ j ] << " ▁ " ; } cout << endl ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) return true ; return false ; } void countSubstrings ( string s , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( isVowel ( s [ j ] ) ) { count ++ ; } if ( count % 2 == 0 ) result ++ ; } } cout << result ; } int main ( ) { int n = 5 ; string s = " abcde " ; countSubstrings ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkPalindrome ( string S ) { int N = S . size ( ) ; bool first_half = true ; bool second_half = true ; int cnt = ( N / 2 ) - 1 ; for ( int i = 0 ; i < ( ( N / 2 ) / 2 ) ; i ++ ) { if ( S [ i ] != S [ cnt ] ) { first_half = false ; break ; } if ( S [ N / 2 + i ] != S [ N / 2 + cnt ] ) { second_half - false ; break ; } cnt -- ; } if ( first_half && second_half ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } } int main ( ) { string S = " momdad " ; checkPalindrome ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubarray ( int arr [ ] , int n , int k ) { int i , j , Max = 1 ; set < int > s ; for ( i = 0 ; i < n - 1 ; i ++ ) { s . insert ( arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) { if ( abs ( arr [ i ] - arr [ j ] ) == 0 || abs ( arr [ i ] - arr [ j ] ) == k ) { if ( ! s . count ( arr [ j ] ) ) { if ( s . size ( ) == 2 ) break ; else s . insert ( arr [ j ] ) ; } } else break ; } if ( s . size ( ) == 2 ) { Max = max ( Max , j - i ) ; s . clear ( ) ; } else s . clear ( ) ; } return Max ; } int main ( ) { int arr [ ] = { 1 , 0 , 2 , 2 , 5 , 5 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 1 ; int length = longestSubarray ( arr , N , K ) ; if ( length == 1 ) cout << -1 ; else cout << length ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int prefix_2D [ 2005 ] [ 2005 ] ; int subMatrixSum ( int i , int j , int len ) { return prefix_2D [ i ] [ j ] - prefix_2D [ i ] [ j - len ] - prefix_2D [ i - len ] [ j ] + prefix_2D [ i - len ] [ j - len ] ; } int numberOfWays ( int a [ ] , int b [ ] , int n , int m , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) prefix_2D [ i ] [ j ] = 1 ; else prefix_2D [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_2D [ i ] [ j ] += prefix_2D [ i ] [ j - 1 ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_2D [ i ] [ j ] += prefix_2D [ i - 1 ] [ j ] ; } } int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int low = 1 ; int high = min ( i , j ) ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( subMatrixSum ( i , j , mid ) >= k ) { high = mid ; } else { low = mid + 1 ; } } if ( subMatrixSum ( i , j , low ) >= k ) { answer += ( min ( i , j ) - low + 1 ) ; } } } return answer ; } int main ( ) { int N = 2 , M = 3 ; int A [ N ] = { 1 , 2 } ; int B [ M ] = { 1 , 2 , 3 } ; int K = 1 ; cout << numberOfWays ( A , B , N , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define NO_OF_CHARS  256 NEW_LINE int firstRepeating ( string & str ) { bool visited [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) visited [ i ] = false ; int res = -1 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( visited [ str [ i ] ] == false ) visited [ str [ i ] ] = true ; else res = i ; } return res ; } int main ( ) { string str = " geeksforgeeks " ; int index = firstRepeating ( str ) ; if ( index == -1 ) printf ( " Either ▁ all ▁ characters ▁ are ▁ " " distinct ▁ or ▁ string ▁ is ▁ empty " ) ; else printf ( " First ▁ Repeating ▁ character " " ▁ is ▁ % c " , str [ index ] ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSumPairs ( int a [ ] , int n ) { unordered_map < int , int > mpp ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { mpp [ a [ i ] + a [ j ] ] ++ ; } } int occur = 0 ; for ( auto it : mpp ) { if ( it . second > occur ) { occur = it . second ; } } for ( auto it : mpp ) { if ( it . second == occur ) cout << it . first << endl ; } } int main ( ) { int a [ ] = { 1 , 8 , 3 , 11 , 4 , 9 , 2 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; findSumPairs ( a , n ) ; return 0 ; }
#include " climits " NEW_LINE #include " iostream " NEW_LINE #include " unordered _ map " NEW_LINE using namespace std ; int findSmallestAfterDel ( int arr [ ] , int m , int del [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ del [ i ] ] ++ ; } int smallestElement = INT_MAX ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . find ( arr [ i ] ) != mp . end ( ) ) { mp [ arr [ i ] ] -- ; if ( mp [ arr [ i ] ] == 0 ) mp . erase ( arr [ i ] ) ; } else smallestElement = min ( smallestElement , arr [ i ] ) ; } return smallestElement ; } int main ( ) { int array [ ] = { 5 , 12 , 33 , 4 , 56 , 12 , 20 } ; int m = sizeof ( array ) / sizeof ( array [ 0 ] ) ; int del [ ] = { 12 , 4 , 56 , 5 } ; int n = sizeof ( del ) / sizeof ( del [ 0 ] ) ; cout << findSmallestAfterDel ( array , m , del , n ) ; return 0 ; }
#include " climits " NEW_LINE #include " iostream " NEW_LINE #include " unordered _ map " NEW_LINE using namespace std ; int findlargestAfterDel ( int arr [ ] , int m , int del [ ] , int n ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < n ; ++ i ) { mp [ del [ i ] ] ++ ; } int largestElement = INT_MIN ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . find ( arr [ i ] ) != mp . end ( ) ) { mp [ arr [ i ] ] -- ; if ( mp [ arr [ i ] ] == 0 ) mp . erase ( arr [ i ] ) ; } else largestElement = max ( largestElement , arr [ i ] ) ; } return largestElement ; } int main ( ) { int array [ ] = { 5 , 12 , 33 , 4 , 56 , 12 , 20 } ; int m = sizeof ( array ) / sizeof ( array [ 0 ] ) ; int del [ ] = { 12 , 33 , 56 , 5 } ; int n = sizeof ( del ) / sizeof ( del [ 0 ] ) ; cout << findlargestAfterDel ( array , m , del , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return abs ( min1 - max1 ) ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , 4 , -10 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Largest ▁ gap ▁ is ▁ : ▁ " << solve ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void getMinimumSum ( int arr [ ] , int n ) { vector < int > res ; vector < int > pos ; vector < int > neg ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos . push_back ( i ) ; else if ( arr [ i ] < 0 ) neg . push_back ( i ) ; } if ( pos . size ( ) >= 2 && neg . size ( ) >= 2 ) { int posMax = INT_MIN , posMaxIdx = -1 ; int posMin = INT_MAX , posMinIdx = -1 ; int negMax = INT_MIN , negMaxIdx = -1 ; int negMin = INT_MAX , negMinIdx = -1 ; for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos [ i ] ] > posMax ) { posMaxIdx = pos [ i ] ; posMax = arr [ posMaxIdx ] ; } } for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos [ i ] ] < posMin && pos [ i ] != posMaxIdx ) { posMinIdx = pos [ i ] ; posMin = arr [ posMinIdx ] ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( abs ( arr [ neg [ i ] ] ) > negMax ) { negMaxIdx = neg [ i ] ; negMax = abs ( arr [ negMaxIdx ] ) ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( abs ( arr [ neg [ i ] ] ) < negMin && neg [ i ] != negMaxIdx ) { negMinIdx = neg [ i ] ; negMin = abs ( arr [ negMinIdx ] ) ; } } double posVal = -1.0 * ( double ) posMax / ( double ) posMin ; double negVal = -1.0 * ( double ) negMax / ( double ) negMin ; if ( posVal < negVal ) { res . push_back ( arr [ posMinIdx ] ) ; res . push_back ( arr [ posMaxIdx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != posMinIdx && i != posMaxIdx ) { res . push_back ( arr [ i ] ) ; } } } else { res . push_back ( arr [ negMinIdx ] ) ; res . push_back ( arr [ negMaxIdx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != negMinIdx && i != negMaxIdx ) { res . push_back ( arr [ i ] ) ; } } } for ( int i = 0 ; i < res . size ( ) ; i ++ ) { cout << res [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } else if ( pos . size ( ) >= 2 ) { int posMax = INT_MIN , posMaxIdx = -1 ; int posMin = INT_MAX , posMinIdx = -1 ; for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos [ i ] ] > posMax ) { posMaxIdx = pos [ i ] ; posMax = arr [ posMaxIdx ] ; } } for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos [ i ] ] < posMin && pos [ i ] != posMaxIdx ) { posMinIdx = pos [ i ] ; posMin = arr [ posMinIdx ] ; } } res . push_back ( arr [ posMinIdx ] ) ; res . push_back ( arr [ posMaxIdx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != posMinIdx && i != posMaxIdx ) { res . push_back ( arr [ i ] ) ; } } for ( int i = 0 ; i < res . size ( ) ; i ++ ) { cout << res [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } else if ( neg . size ( ) >= 2 ) { int negMax = INT_MIN , negMaxIdx = -1 ; int negMin = INT_MAX , negMinIdx = -1 ; for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( abs ( arr [ neg [ i ] ] ) > negMax ) { negMaxIdx = neg [ i ] ; negMax = abs ( arr [ negMaxIdx ] ) ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( abs ( arr [ neg [ i ] ] ) < negMin && neg [ i ] != negMaxIdx ) { negMinIdx = neg [ i ] ; negMin = abs ( arr [ negMinIdx ] ) ; } } res . push_back ( arr [ negMinIdx ] ) ; res . push_back ( arr [ negMaxIdx ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( i != negMinIdx && i != negMaxIdx ) res . push_back ( arr [ i ] ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; cout << " STRNEWLINE " ; } else { cout << " No ▁ swap ▁ required STRNEWLINE " ; } } int main ( ) { int arr [ ] = { -4 , 1 , 6 , -3 , -2 , -1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getMinimumSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int missingNum ( int arr [ ] , int n ) { int minvalue = * min_element ( arr , arr + n ) ; int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; } int main ( ) { int arr [ ] = { 13 , 12 , 11 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << missingNum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumMex ( int arr [ ] , int N ) { vector < int > ans ; sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 arr [ i ] != arr [ i - 1 ] ) ans . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { if ( i > 0 && arr [ i ] == arr [ i - 1 ] ) ans . push_back ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 0 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximumMex ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > bubble_sort ( vector < int > ar ) { if ( ar . size ( ) <= 1 ) return ar ; if ( ar . size ( ) == 2 ) { if ( ar [ 0 ] < ar [ 1 ] ) return ar ; else return { ar [ 1 ] , ar [ 0 ] } ; } int a = ar [ 0 ] ; int b = ar [ 1 ] ; vector < int > bs ; for ( int i = 2 ; i < ar . size ( ) ; i ++ ) bs . push_back ( ar [ i ] ) ; vector < int > res ; if ( a < b ) { vector < int > temp1 ; temp1 . push_back ( b ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . push_back ( bs [ i ] ) ; vector < int > v = bubble_sort ( temp1 ) ; v . insert ( v . begin ( ) , a ) ; res = v ; } else { vector < int > temp1 ; temp1 . push_back ( a ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . push_back ( bs [ i ] ) ; vector < int > v = bubble_sort ( temp1 ) ; v . insert ( v . begin ( ) , b ) ; res = v ; } vector < int > pass ; for ( int i = 0 ; i < res . size ( ) - 1 ; i ++ ) pass . push_back ( res [ i ] ) ; vector < int > ans = bubble_sort ( pass ) ; ans . push_back ( res [ res . size ( ) - 1 ] ) ; return ans ; } int main ( ) { vector < int > arr { 1 , 3 , 4 , 5 , 6 , 2 } ; vector < int > res = bubble_sort ( arr ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solution ( int A , int B , int C ) { int arr [ 3 ] ; arr [ 0 ] = A , arr [ 1 ] = B , arr [ 2 ] = C ; sort ( arr , arr + 3 ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; } int main ( ) { int A = 8 , B = 1 , C = 5 ; cout << solution ( A , B , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_length = 0 ; vector < int > store ; vector < int > ans ; void find_max_length ( vector < int > & arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . push_back ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) { max_length = store . size ( ) ; ans = store ; } } for ( int i = index + 1 ; i < arr . size ( ) ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . pop_back ( ) ; } else return ; } return ; } int longestSubsequence ( vector < int > arr , int n , int k ) { sort ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; } int main ( ) { vector < int > arr { -3 , 0 , 1 , 1 , 2 } ; int n = arr . size ( ) ; int k = 1 ; cout << longestSubsequence ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getNumber ( int n , int k ) { int pos ; if ( n % 2 == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; } int main ( ) { int n = 8 , k = 5 ; cout << getNumber ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSequences ( int arr [ ] , int n ) { int count = 1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; } int main ( ) { int arr [ ] = { 1 , 7 , 3 , 5 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSequences ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkFittingArrays ( int A [ ] , int B [ ] , int N ) { sort ( A , A + N ) ; sort ( B , B + N ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; } int main ( ) { int A [ ] = { 7 , 5 , 3 , 2 } ; int B [ ] = { 5 , 4 , 8 , 7 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( checkFittingArrays ( A , B , N ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void stableSelectionSort ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } void printArray ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int a [ ] = { 4 , 5 , 3 , 2 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; stableSelectionSort ( a , n ) ; printArray ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } } int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; } void pancakeSort ( int * arr , int n ) { for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { int mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pancakeSort ( arr , n ) ; cout << " Sorted ▁ Array ▁ " << endl ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findArrayWithMaxProduct ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] >= 0 ) { arr [ i ] = - arr [ i ] - 1 ; } if ( N % 2 == 1 ) { int max_element = -1 ; int index = -1 ; for ( int i = 0 ; i < N ; i ++ ) if ( abs ( arr [ i ] ) > max_element ) { max_element = abs ( arr [ i ] ) ; index = i ; } arr [ index ] = - arr [ index ] - 1 ; } for ( int i = 0 ; i < N ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; } int main ( ) { int arr [ ] = { -3 , 0 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findArrayWithMaxProduct ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1e5 + 5 ; int visited [ N ] ; void construct_tree ( int weights [ ] , int n ) { int minimum = * min_element ( weights , weights + n ) ; int maximum = * max_element ( weights , weights + n ) ; if ( minimum == maximum ) { cout << " No " ; return ; } else { cout << " Yes " << endl ; } int root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { cout << 1 << " ▁ " << i + 1 << " ▁ " << endl ; visited [ i + 1 ] = 1 ; } } int notroot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { cout << notroot << " ▁ " << i + 1 << endl ; visited [ i + 1 ] = 1 ; } } } int main ( ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = sizeof ( weights ) / sizeof ( weights [ 0 ] ) ; construct_tree ( weights , N ) ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; void addEdge ( vector < int > adj [ ] , int u , int v ) { adj [ u ] . push_back ( v ) ; adj [ v ] . push_back ( u ) ; } void DFS ( int u , vector < int > adj [ ] , int & cnt , vector < bool > & visited , int fre [ ] , string S ) { visited [ u ] = true ; cnt ++ ; fre [ S [ u ] - ' a ' ] ++ ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adj [ u ] [ i ] ] ) { DFS ( adj [ u ] [ i ] , adj , cnt , visited , fre , S ) ; } } } int minimumOperations ( string & S , int m ) { int V = 100 ; vector < int > adj [ V ] ; int total = 0 , N = S . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { addEdge ( adj , i , N - i - 1 ) ; addEdge ( adj , N - i - 1 , i ) ; } for ( int i = 0 ; i < N - m ; i ++ ) { addEdge ( adj , i , i + m ) ; addEdge ( adj , i + m , i ) ; } vector < bool > visited ( V , 0 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { int fre [ 26 ] = { 0 } ; int cnt = 0 , maxx = -1 ; DFS ( i , adj , cnt , visited , fre , S ) ; for ( int j = 0 ; j < 26 ; j ++ ) maxx = max ( maxx , fre [ j ] ) ; total += cnt - maxx ; } } cout << total ; } int main ( ) { string S = " abaaba " ; int K = 2 ; minimumOperations ( S , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int clearLastBit ( int N , int K ) { int mask = ( -1 << K + 1 ) ; return N = N & mask ; } int main ( ) { int N = 730 , K = 3 ; cout << clearLastBit ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int r , int b , int g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } } int main ( ) { int R = 1 , B = 3 , G = 6 ; if ( isPossible ( R , B , G ) ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int countSetBitsUtil ( unsigned int x ) { if ( x <= 0 ) return 0 ; return ( ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ) ; } unsigned int countSetBits ( unsigned int L , unsigned int R ) { int bitCount = 0 ; for ( int i = L ; i <= R ; i ++ ) { bitCount += countSetBitsUtil ( i ) ; } return bitCount ; } int main ( ) { int L = 3 , R = 5 ; printf ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ % d " , countSetBits ( L , R ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinCost ( vector < int > A , vector < int > B , int N ) { int mini = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { mini = min ( mini , min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } int main ( ) { int N = 3 ; vector < int > A = { 1 , 4 , 2 } ; vector < int > B = { 10 , 6 , 12 } ; cout << getMinCost ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findM ( int N ) { int M = 0 ; int MSB = ( int ) log2 ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ! ( N & ( 1 << i ) ) ) M += ( 1 << i ) ; } return M ; } int main ( ) { int N = 6 ; cout << findM ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxModulosum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; } int main ( ) { int a [ ] = { 3 , 4 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxModulosum ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int makeZero ( int x , int y , int a , int b ) { if ( x > y ) x = y , y = x ; int tot_cost = ( y - x ) * a ; int cost1 = 2 * x * a ; int cost2 = x * b ; tot_cost += min ( cost1 , cost2 ) ; cout << tot_cost ; } int main ( ) { int X = 1 , Y = 3 ; int cost1 = 391 , cost2 = 555 ; makeZero ( X , Y , cost1 , cost2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void splitFraction ( int n , int d ) { int ar [ n ] ; int first = d + n - 1 ; ar [ 0 ] = first ; for ( int i = 1 ; i < n ; i ++ ) { int temp = -- first ; first ++ ; ar [ i ] = first * temp ; -- first ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ar [ i ] % n == 0 ) { cout << "1 / " << ar [ i ] / n << " , ▁ " ; } else { cout << n << " / " << ar [ i ] << " , ▁ " ; } } } int main ( ) { int N = 4 ; int D = 2 ; splitFraction ( N , D ) ; }
#include <iostream> NEW_LINE using namespace std ; int findMinimumSubsequences ( string A , string B ) { int numberOfSubsequences = 1 ; int sizeOfB = B . size ( ) ; int sizeOfA = A . size ( ) ; int inf = 1000000 ; int next [ 26 ] [ sizeOfB ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < sizeOfB ; j ++ ) { next [ i ] [ j ] = inf ; } } for ( int i = 0 ; i < sizeOfB ; i ++ ) { next [ B [ i ] - ' a ' ] [ i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOfB - 2 ; j >= 0 ; j -- ) { if ( next [ i ] [ j ] == inf ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } int pos = 0 ; int i = 0 ; while ( i < sizeOfA ) { if ( pos == 0 && next [ A [ i ] - ' a ' ] [ pos ] == inf ) { numberOfSubsequences = -1 ; break ; } else if ( pos < sizeOfB && next [ A [ i ] - ' a ' ] [ pos ] < inf ) { int nextIndex = next [ A [ i ] - ' a ' ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; } int main ( ) { string A = " aacbe " ; string B = " aceab " ; cout << findMinimumSubsequences ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_minimum_operations ( long long n ) { if ( n == 2 ) { return 1 ; } else if ( n == 1 ) { return 0 ; } if ( n % 3 == 0 ) { return 1 + count_minimum_operations ( n / 3 ) ; } else if ( n % 3 == 1 ) { return 1 + count_minimum_operations ( n - 1 ) ; } else { return 1 + count_minimum_operations ( n + 1 ) ; } } int main ( ) { long long n = 4 ; long long ans = count_minimum_operations ( n ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; } int main ( ) { int K , P , N ; K = 4 ; P = 1 ; N = 10 ; cout << problemsLeft ( K , P , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define V  5 NEW_LINE int parent [ V ] ; int find ( int i ) { while ( parent [ i ] != i ) i = parent [ i ] ; return i ; } void union1 ( int i , int j ) { int a = find ( i ) ; int b = find ( j ) ; parent [ a ] = b ; } void kruskalMST ( int cost [ ] [ V ] ) { for ( int i = 0 ; i < V ; i ++ ) parent [ i ] = i ; int edge_count = 0 ; while ( edge_count < V - 1 ) { int min = INT_MAX , a = -1 , b = -1 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( find ( i ) != find ( j ) && cost [ i ] [ j ] < min ) { min = cost [ i ] [ j ] ; a = i ; b = j ; } } } union1 ( a , b ) ; printf ( " Edge ▁ % d : ( % d , ▁ % d ) ▁ cost : % d ▁ STRNEWLINE " , edge_count ++ , a , b , min ) ; mincost += min ; } printf ( " Minimum cost = % d " , mincost ) ; } int main ( ) { int cost [ ] [ V ] = { { INT_MAX , 2 , INT_MAX , 6 , INT_MAX } , { 2 , INT_MAX , 3 , 8 , 5 } , { INT_MAX , 3 , INT_MAX , INT_MAX , 7 } , { 6 , 8 , INT_MAX , INT_MAX , 9 } , { INT_MAX , 5 , 7 , 9 , INT_MAX } , } ; kruskalMST ( cost ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinCost ( pair < int , int > arr [ ] , int X , int n , int i = 0 ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return INT_MAX ; int inc = findMinCost ( arr , X - arr [ i ] . first , n , i + 1 ) ; if ( inc != INT_MAX ) inc += arr [ i ] . second ; int exc = findMinCost ( arr , X , n , i + 1 ) ; return min ( inc , exc ) ; } int main ( ) { pair < int , int > arr [ ] = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int ans = findMinCost ( arr , X , n ) ; if ( ans != INT_MAX ) cout << ans ; else cout << -1 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; map < string , int > dp ; int maxScore ( string s , vector < int > a ) { if ( dp . find ( s ) != dp . end ( ) ) return dp [ s ] ; int n = s . size ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int head = 0 ; int mx = -1 ; while ( head < n ) { int tail = head ; while ( tail < n ) { if ( s [ tail ] != s [ head ] ) { head = tail ; break ; } string sub = s . substr ( head , tail + 1 ) ; mx = max ( mx , a [ sub . size ( ) - 1 ] + maxScore ( s . substr ( 0 , head ) + s . substr ( tail + 1 , s . size ( ) ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp [ s ] = mx ; return mx ; } int main ( ) { string s = " abb " ; vector < int > a = { 1 , 3 , 1 } ; cout << ( maxScore ( s , a ) - 1 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int kadane ( vector < int > v ) { int currSum = 0 ; int maxSum = INT_MIN ; for ( int i = 0 ; i < ( int ) v . size ( ) ; i ++ ) { currSum += v [ i ] ; if ( currSum > maxSum ) { maxSum = currSum ; } if ( currSum < 0 ) { currSum = 0 ; } } return maxSum ; } void maxSubmatrixSum ( vector < vector < int > > A ) { int r = A . size ( ) ; int c = A [ 0 ] . size ( ) ; int * * prefix = new int * [ r ] ; for ( int i = 0 ; i < r ; i ++ ) { prefix [ i ] = new int ; for ( int j = 0 ; j < c ; j ++ ) { prefix [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { if ( j == 0 ) prefix [ i ] [ j ] = A [ i ] [ j ] ; else prefix [ i ] [ j ] = A [ i ] [ j ] + prefix [ i ] [ j - 1 ] ; } } int maxSum = INT_MIN ; for ( int i = 0 ; i < c ; i ++ ) { for ( int j = i ; j < c ; j ++ ) { vector < int > v ; for ( int k = 0 ; k < r ; k ++ ) { int el = 0 ; if ( i == 0 ) el = prefix [ k ] [ j ] ; else el = prefix [ k ] [ j ] - prefix [ k ] [ i - 1 ] ; v . push_back ( el ) ; } maxSum = max ( maxSum , kadane ( v ) ) ; } } cout << maxSum << " STRNEWLINE " ; } int main ( ) { vector < vector < int > > matrix = { { 0 , -2 , -7 , 0 } , { 9 , 2 , -6 , 2 } , { -4 , 1 , -4 , 1 } , { -1 , 8 , 0 , -2 } } ; maxSubmatrixSum ( matrix ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberofpairs ( vector < vector < int > > v , int k ) { int n = v . size ( ) ; if ( n % 2 == 1 ) { cout << 0 ; return ; } int ans = 0 ; int dp [ k ] [ 2 ] ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i + j ) % 2 == 0 ) dp [ v [ i ] [ j ] - 1 ] [ 0 ] ++ ; else dp [ v [ i ] [ j ] - 1 ] [ 1 ] ++ ; } } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i + 1 ; j < k ; j ++ ) { ans += dp [ i ] [ 0 ] * dp [ j ] [ 1 ] ; ans += dp [ i ] [ 1 ] * dp [ j ] [ 0 ] ; } } cout << ans ; } int main ( ) { vector < vector < int > > mat = { { 1 , 2 } , { 3 , 4 } } ; int K = 4 ; numberofpairs ( mat , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxGCD ( int arr [ ] , int N ) { int high = 0 ; for ( int i = 0 ; i < N ; i ++ ) { high = max ( high , arr [ i ] ) ; } int count [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { count [ arr [ i ] ] += 1 ; } int counter = 0 ; for ( int i = high ; i > 0 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } } int maxlen ( int i , int j , int arr [ ] , int arr1 [ ] , int N , int maxgcd ) { int a = 1 ; if ( i >= N or j >= N ) return 0 ; if ( __gcd ( arr [ i ] , arr1 [ j ] ) == maxgcd && arr [ i ] != arr1 [ j ] ) { a = max ( a , 1 + maxlen ( i , j + 1 , arr , arr1 , N , maxgcd ) ) ; return a ; } return max ( maxlen ( i + 1 , j , arr , arr1 , N , maxgcd ) , maxlen ( i , j + 1 , arr , arr1 , N , maxgcd ) ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 8 , 5 , 6 } ; int arr1 [ ] = { 1 , 2 , 8 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort ( arr , arr + n ) ; sort ( arr1 , arr1 + n ) ; int maxgcd = findMaxGCD ( arr , n ) ; cout << maxlen ( 0 , 0 , arr , arr1 , n , maxgcd ) + 1 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findWays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != -1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } int main ( ) { int N = 4 ; int dp [ N + 1 ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << findWays ( N , dp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; } int main ( ) { int N = 6 ; cout << minDays ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countNums ( int N ) { int dp [ N ] [ 16 ] ; memset ( dp , 0 , sizeof ( dp [ 0 ] [ 0 ] ) * N * 16 ) ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 16 ; k ++ ) { int xo = j ^ k ; dp [ i ] [ xo ] += dp [ i - 1 ] [ k ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 ] [ i ] ; cout << ( count ) << endl ; } int main ( ) { int N = 1 ; countNums ( N ) ; }
#include <iostream> NEW_LINE using namespace std ; int count ( int a [ ] , int M , int N ) { int cnt = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 } ; int m = 100 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count ( arr , m , n ) ; return 0 ; }
