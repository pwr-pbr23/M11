#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMaxOfMin ( int arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = INT_MIN ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } cout << maxOfMin << " ▁ " ; } } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMaxOfMin ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <stack> NEW_LINE using namespace std ; void printMaxOfMin ( int arr [ ] , int n ) { stack < int > s ; int left [ n + 1 ] ; int right [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = -1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) left [ i ] = s . top ( ) ; s . push ( i ) ; } while ( ! s . empty ( ) ) s . pop ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . top ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) right [ i ] = s . top ( ) ; s . push ( i ) ; } int ans [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) ans [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMaxOfMin ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2 ) { sort ( arr , arr + n ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; } int main ( ) { int arr [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; int k1 = 3 , k2 = 6 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumBetweenTwoKth ( arr , n , k1 , k2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; struct Node * newNode ( int x ) { struct Node * temp = new Node ; temp -> data = x ; temp -> left = temp -> right = NULL ; return temp ; } ; int count ( Node * root ) { if ( root == NULL ) return 0 ; return count ( root -> left ) + count ( root -> right ) + 1 ; } int checkRec ( Node * root , int n , bool & res ) { if ( root == NULL ) return 0 ; int c = checkRec ( root -> left , n , res ) + 1 + checkRec ( root -> right , n , res ) ; if ( c == n - c ) res = true ; return c ; } bool check ( Node * root ) { int n = count ( root ) ; bool res = false ; checkRec ( root , n , res ) ; return res ; } int main ( ) { struct Node * root = newNode ( 5 ) ; root -> left = newNode ( 1 ) ; root -> right = newNode ( 6 ) ; root -> left -> left = newNode ( 3 ) ; root -> right -> left = newNode ( 7 ) ; root -> right -> right = newNode ( 4 ) ; check ( root ) ? printf ( " YES " ) : printf ( " NO " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSymPairs ( int arr [ ] [ 2 ] , int row ) { unordered_map < int , int > hM ; for ( int i = 0 ; i < row ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; if ( hM . find ( sec ) != hM . end ( ) && hM [ sec ] == first ) cout << " ( " << sec << " , ▁ " << first << " ) " << endl ; else hM [ first ] = sec ; } } int main ( ) { int arr [ 5 ] [ 2 ] ; arr [ 0 ] [ 0 ] = 11 ; arr [ 0 ] [ 1 ] = 20 ; arr [ 1 ] [ 0 ] = 30 ; arr [ 1 ] [ 1 ] = 40 ; arr [ 2 ] [ 0 ] = 5 ; arr [ 2 ] [ 1 ] = 10 ; arr [ 3 ] [ 0 ] = 40 ; arr [ 3 ] [ 1 ] = 30 ; arr [ 4 ] [ 0 ] = 10 ; arr [ 4 ] [ 1 ] = 5 ; findSymPairs ( arr , 5 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct item { string name ; int price ; } ; int countItems ( item list1 [ ] , int m , item list2 [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( list1 [ i ] . name . compare ( list2 [ j ] . name ) == 0 ) && ( list1 [ i ] . price != list2 [ j ] . price ) ) count ++ ; return count ; } int main ( ) { item list1 [ ] = { { " apple " , 60 } , { " bread " , 20 } , { " wheat " , 50 } , { " oil " , 30 } } ; item list2 [ ] = { { " milk " , 20 } , { " bread " , 15 } , { " wheat " , 40 } , { " apple " , 60 } } ; int m = sizeof ( list1 ) / sizeof ( list1 [ 0 ] ) ; int n = sizeof ( list2 ) / sizeof ( list2 [ 0 ] ) ; cout << " Count ▁ = ▁ " << countItems ( list1 , m , list2 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubarraySum ( int arr [ ] , int n , int sum ) { unordered_map < int , int > prevSum ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . find ( currsum - sum ) != prevSum . end ( ) ) res += ( prevSum [ currsum - sum ] ) ; prevSum [ currsum ] ++ ; } return res ; } int main ( ) { int arr [ ] = { 10 , 2 , -2 , -20 , 10 } ; int sum = -10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSubarraySum ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_PATH_SIZE  1000 NEW_LINE struct Node { char data ; Node * left , * right ; } ; Node * newNode ( char data ) { struct Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } struct PATH { int Hd ; char key ; } ; void printPath ( vector < PATH > path , int size ) { int minimum_Hd = INT_MAX ; PATH p ; for ( int it = 0 ; it < size ; it ++ ) { p = path [ it ] ; minimum_Hd = min ( minimum_Hd , p . Hd ) ; } for ( int it = 0 ; it < size ; it ++ ) { p = path [ it ] ; int noOfUnderScores = abs ( p . Hd - minimum_Hd ) ; for ( int i = 0 ; i < noOfUnderScores ; i ++ ) cout << " _ ▁ " ; cout << p . key << endl ; } cout << " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " << endl ; } void printAllPathsUtil ( Node * root , vector < PATH > & AllPath , int HD , int order ) { if ( root == NULL ) return ; if ( root -> left == NULL && root -> right == NULL ) { AllPath [ order ] = ( PATH { HD , root -> data } ) ; printPath ( AllPath , order + 1 ) ; return ; } AllPath [ order ] = ( PATH { HD , root -> data } ) ; printAllPathsUtil ( root -> left , AllPath , HD - 1 , order + 1 ) ; printAllPathsUtil ( root -> right , AllPath , HD + 1 , order + 1 ) ; } void printAllPaths ( Node * root ) { if ( root == NULL ) return ; vector < PATH > Allpaths ( MAX_PATH_SIZE ) ; printAllPathsUtil ( root , Allpaths , 0 , 0 ) ; } int main ( ) { Node * root = newNode ( ' A ' ) ; root -> left = newNode ( ' B ' ) ; root -> right = newNode ( ' C ' ) ; root -> left -> left = newNode ( ' D ' ) ; root -> left -> right = newNode ( ' E ' ) ; root -> right -> left = newNode ( ' F ' ) ; root -> right -> right = newNode ( ' G ' ) ; printAllPaths ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; } int main ( ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr1 , 0 , n1 - 1 ) << endl ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr2 , 0 , n2 - 1 ) << endl ; int arr3 [ ] = { 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr3 , 0 , n3 - 1 ) << endl ; int arr4 [ ] = { 1 , 2 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr4 , 0 , n4 - 1 ) << endl ; int arr5 [ ] = { 2 , 1 } ; int n5 = sizeof ( arr5 ) / sizeof ( arr5 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr5 , 0 , n5 - 1 ) << endl ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = sizeof ( arr6 ) / sizeof ( arr6 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr6 , 0 , n6 - 1 ) << endl ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = sizeof ( arr7 ) / sizeof ( arr7 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr7 , 0 , n7 - 1 ) << endl ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = sizeof ( arr8 ) / sizeof ( arr8 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr8 , 0 , n8 - 1 ) << endl ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = sizeof ( arr9 ) / sizeof ( arr9 [ 0 ] ) ; cout << " The ▁ minimum ▁ element ▁ is ▁ " << findMin ( arr9 , 0 , n9 - 1 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE void printArray ( int array [ ] , int length ) { std :: cout << " [ " ; for ( int i = 0 ; i < length ; i ++ ) { std :: cout << array [ i ] ; if ( i < ( length - 1 ) ) std :: cout << " , ▁ " ; else std :: cout << " ] " << std :: endl ; } } void reverse ( int array [ ] , int start , int end ) { while ( start < end ) { int temp = array [ start ] ; array [ start ] = array [ end ] ; array [ end ] = temp ; start ++ ; end -- ; } } void rearrange ( int array [ ] , int start , int end ) { if ( start == end ) return ; rearrange ( array , ( start + 1 ) , end ) ; if ( array [ start ] >= 0 ) { reverse ( array , ( start + 1 ) , end ) ; reverse ( array , start , end ) ; } } int main ( ) { int array [ ] = { -12 , -11 , -13 , -5 , -6 , 7 , 5 , 3 , 6 } ; int length = ( sizeof ( array ) / sizeof ( array [ 0 ] ) ) ; int countNegative = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( array [ i ] < 0 ) countNegative ++ ; } std :: cout << " array : ▁ " ; printArray ( array , length ) ; rearrange ( array , 0 , ( length - 1 ) ) ; reverse ( array , countNegative , ( length - 1 ) ) ; std :: cout << " rearranged ▁ array : ▁ " ; printArray ( array , length ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ; else break ; } } int main ( ) { int arr [ ] = { 1 , -3 , 5 , 6 , -3 , 6 , 7 , -4 , 9 , 10 } ; int n = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; rearrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find3largest ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { cout << arr [ n - i ] << " ▁ " ; check = arr [ n - i ] ; count ++ ; } } else break ; } } int main ( ) { int arr [ ] = { 12 , 45 , 1 , -1 , 45 , 54 , 23 , 5 , 0 , -10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; find3largest ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print2Smallest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { cout << " ▁ Invalid ▁ Input ▁ " ; return ; } first = second = INT_MAX ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == INT_MAX ) cout << " There ▁ is ▁ no ▁ second ▁ smallest ▁ element STRNEWLINE " ; else cout << " The ▁ smallest ▁ element ▁ is ▁ " << first << " ▁ and ▁ second ▁ " " Smallest ▁ element ▁ is ▁ " << second << endl ; } int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2Smallest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } int main ( ) { int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Smallest ▁ missing ▁ element ▁ is ▁ " << findFirstMissing ( arr , 0 , n - 1 ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE int tree [ 4 * MAX ] ; int arr [ MAX ] ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int a , int b ) { return a * b / gcd ( a , b ) ; } void build ( int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) / 2 ; build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ; int left_lcm = tree [ 2 * node ] ; int right_lcm = tree [ 2 * node + 1 ] ; tree [ node ] = lcm ( left_lcm , right_lcm ) ; } int query ( int node , int start , int end , int l , int r ) { if ( end < l start > r ) return 1 ; if ( l <= start && r >= end ) return tree [ node ] ; int mid = ( start + end ) / 2 ; int left_lcm = query ( 2 * node , start , mid , l , r ) ; int right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return lcm ( left_lcm , right_lcm ) ; } int main ( ) { arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ; build ( 1 , 0 , 10 ) ; cout << query ( 1 , 0 , 10 , 2 , 5 ) << endl ; cout << query ( 1 , 0 , 10 , 5 , 10 ) << endl ; cout << query ( 1 , 0 , 10 , 0 , 10 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lowerIndex ( int arr [ ] , int n , int x ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; } int upperIndex ( int arr [ ] , int n , int y ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; } int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; return count ; } int main ( ) { int arr [ ] = { 1 , 4 , 4 , 9 , 10 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort ( arr , arr + n ) ; int i = 1 , j = 4 ; cout << countInRange ( arr , n , i , j ) << endl ; i = 9 , j = 12 ; cout << countInRange ( arr , n , i , j ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void type1 ( int arr [ ] , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) arr [ i ] ++ ; } void type2 ( int arr [ ] , int query [ ] [ 3 ] , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; } } int main ( ) { int n = 5 , m = 5 ; int arr [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = 0 ; int temp [ 15 ] = { 1 , 1 , 2 , 1 , 4 , 5 , 2 , 1 , 2 , 2 , 1 , 3 , 2 , 3 , 4 } ; int query [ 5 ] [ 3 ] ; int j = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { query [ i ] [ 0 ] = temp [ j ++ ] ; query [ i ] [ 1 ] = temp [ j ++ ] ; query [ i ] [ 2 ] = temp [ j ++ ] ; } for ( int i = 1 ; i <= m ; i ++ ) if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; void swap ( int * x , int * y ) { int temp = * x ; * x = * y ; * y = temp ; } void sortInWave ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( & arr [ i ] , & arr [ i + 1 ] ) ; } int main ( ) { int arr [ ] = { 10 , 90 , 49 , 2 , 1 , 5 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortInWave ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define NA  -1 NEW_LINE void moveToEnd ( int mPlusN [ ] , int size ) { int j = size - 1 ; for ( int i = size - 1 ; i >= 0 ; i -- ) if ( mPlusN [ i ] != NA ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } int merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( j == n ) || ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } int main ( ) { int mPlusN [ ] = { 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = sizeof ( N ) / sizeof ( N [ 0 ] ) ; int m = sizeof ( mPlusN ) / sizeof ( mPlusN [ 0 ] ) - n ; moveToEnd ( mPlusN , m + n ) ; merge ( mPlusN , N , m , n ) ; printArray ( mPlusN , m + n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; } int main ( ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " ▁ Number ▁ of ▁ inversions ▁ are ▁ " << getInvCount ( arr , n ) ; return 0 ; }
# include <bits/stdc++.h> NEW_LINE # include <stdlib.h> NEW_LINE # include <math.h> NEW_LINE using namespace std ; void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { cout << " Invalid ▁ Input " ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( abs ( min_sum ) > abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } cout << " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ " << arr [ min_l ] << " ▁ and ▁ " << arr [ min_r ] ; } int main ( ) { int arr [ ] = { 1 , 60 , -10 , 70 , -80 , 85 } ; minAbsSumPair ( arr , 6 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( a [ lo ++ ] , a [ mid ++ ] ) ; break ; case 1 : mid ++ ; break ; case 2 : swap ( a [ mid ] , a [ hi -- ] ) ; break ; } } } void printArray ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort012 ( arr , n ) ; cout << " array ▁ after ▁ segregation ▁ " ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { cout << " The ▁ complete ▁ array ▁ is ▁ sorted " ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } cout << " The ▁ unsorted ▁ subarray ▁ which " << " ▁ makes ▁ the ▁ given ▁ array " << endl << " sorted ▁ lies ▁ between ▁ the ▁ indees ▁ " << s << " ▁ and ▁ " << e ; return ; } int main ( ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printUnsorted ( arr , arr_size ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return -1 ; } int main ( ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) cout << " Element ▁ not ▁ found " ; else cout << " Element ▁ Found ▁ at ▁ Position : ▁ " << position + 1 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; key = 10 ; cout << " Index : ▁ " << binarySearch ( arr , 0 , n - 1 , key ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return -1 ; } int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " First ▁ equilibrium ▁ index ▁ is ▁ " << equilibrium ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return -1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } } int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 20 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) cout << " Ceiling ▁ of ▁ " << x << " ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " ; else cout << " ceiling ▁ of ▁ " << x << " ▁ is ▁ " << arr [ index ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE struct Node { int data ; struct Node * left ; struct Node * right ; } ; int getHeight ( struct Node * Node ) { if ( Node == NULL ) return 0 ; else { int lHeight = getHeight ( Node -> left ) ; int rHeight = getHeight ( Node -> right ) ; if ( lHeight > rHeight ) return ( lHeight + 1 ) ; else return ( rHeight + 1 ) ; } } struct Node * newNode ( int data ) { struct Node * Node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int getTotalHeight ( struct Node * root ) { if ( root == NULL ) return 0 ; return getTotalHeight ( root -> left ) + getHeight ( root ) + getTotalHeight ( root -> right ) ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( " Sum ▁ of ▁ heights ▁ of ▁ all ▁ Nodes ▁ = ▁ % d " , getTotalHeight ( root ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int majorityElement ( int * arr , int n ) { sort ( arr , arr + n ) ; int count = 1 , max_ele = -1 , temp = arr [ 0 ] , ele , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : -1 ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << majorityElement ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isMajority ( int arr [ ] , int n , int x ) { int i ; int last_index = n % 2 ? ( n / 2 + 1 ) : ( n / 2 ) ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return 1 ; } return 0 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 4 ; if ( isMajority ( arr , n , x ) ) cout << x << " ▁ appears ▁ more ▁ than ▁ " << n / 2 << " ▁ times ▁ in ▁ arr [ ] " << endl ; else cout << x << " ▁ does ▁ not ▁ appear ▁ more ▁ than " << n / 2 << " ▁ times ▁ in ▁ arr [ ] " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left ; struct Node * right ; } ; struct Node * newNode ( int data ) { struct Node * Node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; Node -> data = data ; Node -> left = NULL ; Node -> right = NULL ; return ( Node ) ; } int getTotalHeightUtil ( struct Node * root , int & sum ) { if ( root == NULL ) return 0 ; int lh = getTotalHeightUtil ( root -> left , sum ) ; int rh = getTotalHeightUtil ( root -> right , sum ) ; int h = max ( lh , rh ) + 1 ; sum = sum + h ; return h ; } int getTotalHeight ( Node * root ) { int sum = 0 ; getTotalHeightUtil ( root , sum ) ; return sum ; } int main ( ) { struct Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; printf ( " Sum ▁ of ▁ heights ▁ of ▁ all ▁ Nodes ▁ = ▁ % d " , getTotalHeight ( root ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void bfs ( int n , int m , int num ) { queue < int > q ; q . push ( num ) ; while ( ! q . empty ( ) ) { int stepNum = q . front ( ) ; q . pop ( ) ; if ( stepNum <= m && stepNum >= n ) cout << stepNum << " ▁ " ; if ( num == 0 stepNum > m ) continue ; int lastDigit = stepNum % 10 ; int stepNumA = stepNum * 10 + ( lastDigit - 1 ) ; int stepNumB = stepNum * 10 + ( lastDigit + 1 ) ; if ( lastDigit == 0 ) q . push ( stepNumB ) ; else if ( lastDigit == 9 ) q . push ( stepNumA ) ; else { q . push ( stepNumA ) ; q . push ( stepNumB ) ; } } } void displaySteppingNumbers ( int n , int m ) { for ( int i = 0 ; i <= 9 ; i ++ ) bfs ( n , m , i ) ; } int main ( ) { int n = 0 , m = 21 ; displaySteppingNumbers ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { struct node * left ; int data ; struct node * right ; } ; void levelOrder ( node * root ) { if ( root == NULL ) return ; queue < node * > q ; node * curr ; q . push ( root ) ; q . push ( NULL ) ; while ( q . size ( ) > 1 ) { curr = q . front ( ) ; q . pop ( ) ; if ( curr == NULL ) { q . push ( NULL ) ; cout << " STRNEWLINE " ; } else { if ( curr -> left ) q . push ( curr -> left ) ; if ( curr -> right ) q . push ( curr -> right ) ; cout << curr -> data << " ▁ " ; } } } node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = NULL ; temp -> right = NULL ; return temp ; } int main ( ) { node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> left -> right = newNode ( 5 ) ; root -> right -> right = newNode ( 6 ) ; levelOrder ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int shortestChainLen ( string start , string target , set < string > & D ) { if ( start == target ) return 0 ; if ( D . find ( target ) == D . end ( ) ) return 0 ; int level = 0 , wordlength = start . size ( ) ; queue < string > Q ; Q . push ( start ) ; while ( ! Q . empty ( ) ) { ++ level ; int sizeofQ = Q . size ( ) ; for ( int i = 0 ; i < sizeofQ ; ++ i ) { string word = Q . front ( ) ; Q . pop ( ) ; for ( int pos = 0 ; pos < wordlength ; ++ pos ) { char orig_char = word [ pos ] ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) { word [ pos ] = c ; if ( word == target ) return level + 1 ; if ( D . find ( word ) == D . end ( ) ) continue ; D . erase ( word ) ; Q . push ( word ) ; } word [ pos ] = orig_char ; } } } return 0 ; } int main ( ) { set < string > D ; D . insert ( " poon " ) ; D . insert ( " plee " ) ; D . insert ( " same " ) ; D . insert ( " poie " ) ; D . insert ( " plie " ) ; D . insert ( " poin " ) ; D . insert ( " plea " ) ; string start = " toon " ; string target = " plea " ; cout << " Length ▁ of ▁ shortest ▁ chain ▁ is : ▁ " << shortestChainLen ( start , target , D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void printList ( struct Node * node ) { while ( node != NULL ) { cout << node -> data << " ▁ " ; node = node -> next ; } cout << endl ; } int countNodes ( struct Node * s ) { int count = 0 ; while ( s != NULL ) { count ++ ; s = s -> next ; } return count ; } void swapKth ( struct Node * * head_ref , int k ) { int n = countNodes ( * head_ref ) ; if ( n < k ) return ; if ( 2 * k - 1 == n ) return ; Node * x = * head_ref ; Node * x_prev = NULL ; for ( int i = 1 ; i < k ; i ++ ) { x_prev = x ; x = x -> next ; } Node * y = * head_ref ; Node * y_prev = NULL ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { y_prev = y ; y = y -> next ; } if ( x_prev ) x_prev -> next = y ; if ( y_prev ) y_prev -> next = x ; Node * temp = x -> next ; x -> next = y -> next ; y -> next = temp ; if ( k == 1 ) * head_ref = y ; if ( k == n ) * head_ref = x ; } int main ( ) { struct Node * head = NULL ; for ( int i = 8 ; i >= 1 ; i -- ) push ( & head , i ) ; cout << " Original ▁ Linked ▁ List : ▁ " ; printList ( head ) ; for ( int k = 1 ; k < 9 ; k ++ ) { swapKth ( & head , k ) ; cout << " Modified List for k = " printList ( head ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next , * prev ; } ; int countPairs ( struct Node * first , struct Node * second , int value ) { int count = 0 ; while ( first != NULL && second != NULL && first != second && second -> next != first ) { if ( ( first -> data + second -> data ) == value ) { count ++ ; first = first -> next ; second = second -> prev ; } else if ( ( first -> data + second -> data ) > value ) second = second -> prev ; else first = first -> next ; } return count ; } int countTriplets ( struct Node * head , int x ) { if ( head == NULL ) return 0 ; struct Node * current , * first , * last ; int count = 0 ; last = head ; while ( last -> next != NULL ) last = last -> next ; for ( current = head ; current != NULL ; current = current -> next ) { first = current -> next ; count += countPairs ( first , last , x - current -> data ) ; } return count ; } void insert ( struct Node * * head , int data ) { struct Node * temp = new Node ( ) ; temp -> data = data ; temp -> next = temp -> prev = NULL ; if ( ( * head ) == NULL ) ( * head ) = temp ; else { temp -> next = * head ; ( * head ) -> prev = temp ; ( * head ) = temp ; } } int main ( ) { struct Node * head = NULL ; insert ( & head , 9 ) ; insert ( & head , 8 ) ; insert ( & head , 6 ) ; insert ( & head , 5 ) ; insert ( & head , 4 ) ; insert ( & head , 2 ) ; insert ( & head , 1 ) ; int x = 17 ; cout << " Count ▁ = ▁ " << countTriplets ( head , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { char data ; struct Node * next ; } ; Node * newNode ( char key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } void printlist ( Node * head ) { if ( ! head ) { cout << " Empty ▁ List STRNEWLINE " ; return ; } while ( head != NULL ) { cout << head -> data << " ▁ " ; if ( head -> next ) cout << " - > ▁ " ; head = head -> next ; } cout << endl ; } bool isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } Node * arrange ( Node * head ) { Node * newHead = head ; Node * latestVowel ; Node * curr = head ; if ( head == NULL ) return NULL ; if ( isVowel ( head -> data ) ) latestVowel = head ; else { while ( curr -> next != NULL && ! isVowel ( curr -> next -> data ) ) curr = curr -> next ; if ( curr -> next == NULL ) return head ; latestVowel = newHead = curr -> next ; curr -> next = curr -> next -> next ; latestVowel -> next = head ; } while ( curr != NULL && curr -> next != NULL ) { if ( isVowel ( curr -> next -> data ) ) { if ( curr == latestVowel ) { latestVowel = curr = curr -> next ; } else { Node * temp = latestVowel -> next ; latestVowel -> next = curr -> next ; latestVowel = latestVowel -> next ; curr -> next = curr -> next -> next ; latestVowel -> next = temp ; } } else { curr = curr -> next ; } } return newHead ; } int main ( ) { Node * head = newNode ( ' a ' ) ; head -> next = newNode ( ' b ' ) ; head -> next -> next = newNode ( ' c ' ) ; head -> next -> next -> next = newNode ( ' e ' ) ; head -> next -> next -> next -> next = newNode ( ' d ' ) ; head -> next -> next -> next -> next -> next = newNode ( ' o ' ) ; head -> next -> next -> next -> next -> next -> next = newNode ( ' x ' ) ; head -> next -> next -> next -> next -> next -> next -> next = newNode ( ' i ' ) ; printf ( " Linked ▁ list ▁ before ▁ : STRNEWLINE " ) ; printlist ( head ) ; head = arrange ( head ) ; printf ( " Linked ▁ list ▁ after ▁ : STRNEWLINE " ) ; printlist ( head ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct Node { int data ; Node * left , * right ; Node ( int x ) { data = x ; left = right = NULL ; } } ; Node * insert ( Node * root , int x ) { if ( root == NULL ) return new Node ( x ) ; if ( x < root -> data ) root -> left = insert ( root -> left , x ) ; else if ( x > root -> data ) root -> right = insert ( root -> right , x ) ; return root ; } Node * kthSmallest ( Node * root , int & k ) { if ( root == NULL ) return NULL ; Node * left = kthSmallest ( root -> left , k ) ; if ( left != NULL ) return left ; k -- ; if ( k == 0 ) return root ; return kthSmallest ( root -> right , k ) ; } void printKthSmallest ( Node * root , int k ) { int count = 0 ; Node * res = kthSmallest ( root , k ) ; if ( res == NULL ) cout << " There ▁ are ▁ less ▁ than ▁ k ▁ nodes ▁ in ▁ the ▁ BST " ; else cout << " K - th ▁ Smallest ▁ Element ▁ is ▁ " << res -> data ; } int main ( ) { Node * root = NULL ; int keys [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; for ( int x : keys ) root = insert ( root , x ) ; int k = 3 ; printKthSmallest ( root , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { struct Node * left , * right ; int key ; } ; struct Node * newNode ( int key ) { struct Node * ptr = new Node ; ptr -> key = key ; ptr -> left = ptr -> right = NULL ; return ptr ; } struct Node * insert ( struct Node * root , int key ) { if ( ! root ) root = newNode ( key ) ; else if ( root -> key > key ) root -> left = insert ( root -> left , key ) ; else if ( root -> key < key ) root -> right = insert ( root -> right , key ) ; return root ; } int distanceFromRoot ( struct Node * root , int x ) { if ( root -> key == x ) return 0 ; else if ( root -> key > x ) return 1 + distanceFromRoot ( root -> left , x ) ; return 1 + distanceFromRoot ( root -> right , x ) ; } int distanceBetween2 ( struct Node * root , int a , int b ) { if ( ! root ) return 0 ; if ( root -> key > a && root -> key > b ) return distanceBetween2 ( root -> left , a , b ) ; if ( root -> key < a && root -> key < b ) return distanceBetween2 ( root -> right , a , b ) ; if ( root -> key >= a && root -> key <= b ) return distanceFromRoot ( root , a ) + distanceFromRoot ( root , b ) ; } int findDistWrapper ( Node * root , int a , int b ) { if ( a > b ) swap ( a , b ) ; return distanceBetween2 ( root , a , b ) ; } int main ( ) { struct Node * root = NULL ; root = insert ( root , 20 ) ; insert ( root , 10 ) ; insert ( root , 5 ) ; insert ( root , 15 ) ; insert ( root , 30 ) ; insert ( root , 25 ) ; insert ( root , 35 ) ; int a = 5 , b = 55 ; cout << findDistWrapper ( root , 5 , 35 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; bool inRange ( node * root , int low , int high ) { return root -> data >= low && root -> data <= high ; } bool getCountUtil ( node * root , int low , int high , int * count ) { if ( root == NULL ) return true ; bool l = getCountUtil ( root -> left , low , high , count ) ; bool r = getCountUtil ( root -> right , low , high , count ) ; if ( l && r && inRange ( root , low , high ) ) { ++ * count ; return true ; } return false ; } int getCount ( node * root , int low , int high ) { int count = 0 ; getCountUtil ( root , low , high , & count ) ; return count ; } node * newNode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return ( temp ) ; } int main ( ) { node * root = newNode ( 10 ) ; root -> left = newNode ( 5 ) ; root -> right = newNode ( 50 ) ; root -> left -> left = newNode ( 1 ) ; root -> right -> left = newNode ( 40 ) ; root -> right -> right = newNode ( 100 ) ; int l = 5 ; int h = 45 ; cout << " Count ▁ of ▁ subtrees ▁ in ▁ [ " << l << " , ▁ " << h << " ] ▁ is ▁ " << getCount ( root , l , h ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; cout << arr [ start ] << " ▁ " ; printSorted ( arr , start * 2 + 2 , end ) ; } int main ( ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; int arr_size = sizeof ( arr ) / sizeof ( int ) ; printSorted ( arr , 0 , arr_size - 1 ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinOpeartion ( int matrix [ ] [ 2 ] , int n ) { int sumRow [ n ] , sumCol [ n ] ; memset ( sumRow , 0 , sizeof ( sumRow ) ) ; memset ( sumCol , 0 , sizeof ( sumCol ) ) ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { sumRow [ i ] += matrix [ i ] [ j ] ; sumCol [ j ] += matrix [ i ] [ j ] ; } int maxSum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { maxSum = max ( maxSum , sumRow [ i ] ) ; maxSum = max ( maxSum , sumCol [ i ] ) ; } int count = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { int diff = min ( maxSum - sumRow [ i ] , maxSum - sumCol [ j ] ) ; matrix [ i ] [ j ] += diff ; sumRow [ i ] += diff ; sumCol [ j ] += diff ; count += diff ; if ( sumRow [ i ] == maxSum ) ++ i ; if ( sumCol [ j ] == maxSum ) ++ j ; } return count ; } void printMatrix ( int matrix [ ] [ 2 ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) cout << matrix [ i ] [ j ] << " ▁ " ; cout << " STRNEWLINE " ; } } int main ( ) { int matrix [ ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } } ; cout << findMinOpeartion ( matrix , 2 ) << " STRNEWLINE " ; printMatrix ( matrix , 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; int smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return -1 ; int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { cout << " n ▁ Found ▁ at ▁ " << i << " , ▁ " << j ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } cout << " n ▁ Element ▁ not ▁ found " ; return 0 ; } int main ( ) { int mat [ 4 ] [ 4 ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; search ( mat , 4 , 29 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; bool areSumSame ( int a [ ] [ MAX ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 , sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; } int main ( ) { int n = 4 ; int m = 4 ; int M [ n ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 9 , 5 , 3 , 1 } , { 0 , 3 , 5 , 6 } , { 0 , 4 , 5 , 6 } } ; cout << areSumSame ( M , n , m ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  5 NEW_LINE #define M  5 NEW_LINE using namespace std ; int minOperation ( bool arr [ N ] [ M ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == 0 ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; else arr [ k ] [ h ] = 1 ; } } } } } return ans ; } int main ( ) { bool mat [ N ] [ M ] = { 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; cout << minOperation ( mat ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; } int main ( ) { int n = 7 ; cout << spiralDiaSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void printMatrixDiagonal ( int mat [ MAX ] [ MAX ] , int n ) { int i = 0 , j = 0 ; bool isUp = true ; for ( int k = 0 ; k < n * n ; ) { if ( isUp ) { for ( ; i >= 0 && j < n ; j ++ , i -- ) { cout << mat [ i ] [ j ] << " ▁ " ; k ++ ; } if ( i < 0 && j <= n - 1 ) i = 0 ; if ( j == n ) i = i + 2 , j -- ; } else { for ( ; j >= 0 && i < n ; i ++ , j -- ) { cout << mat [ i ] [ j ] << " ▁ " ; k ++ ; } if ( j < 0 && i <= n - 1 ) j = 0 ; if ( i == n ) j = j + 2 , i -- ; } isUp = ! isUp ; } } int main ( ) { int mat [ MAX ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int n = 3 ; printMatrixDiagonal ( mat , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  4 NEW_LINE int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void replacematrix ( int mat [ R ] [ C ] , int n , int m ) { int rgcd [ R ] = { 0 } , cgcd [ C ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = max ( rgcd [ i ] , cgcd [ j ] ) ; } int main ( ) { int m [ R ] [ C ] = { 1 , 2 , 3 , 3 , 4 , 5 , 6 , 6 , 7 , 8 , 9 , 9 , } ; replacematrix ( m , R , C ) ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) cout << m [ i ] [ j ] << " ▁ " ; cout << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int sortedCount ( int mat [ ] [ MAX ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; } int main ( ) { int m = 4 , n = 5 ; int mat [ ] [ MAX ] = { { 1 , 2 , 3 , 4 , 5 } , { 4 , 3 , 1 , 2 , 6 } , { 8 , 7 , 6 , 5 , 4 } , { 5 , 7 , 8 , 9 , 10 } } ; cout << sortedCount ( mat , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5 NEW_LINE int findMaxValue ( int mat [ ] [ N ] ) { int maxValue = INT_MIN ; int maxArr [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = max ( mat [ i ] [ j ] , max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , -1 , -4 , -20 } , { -8 , -3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { -4 , -1 , 1 , 7 , -6 } , { 0 , -4 , 10 , -5 , 1 } } ; cout << " Maximum ▁ Value ▁ is ▁ " << findMaxValue ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ROW  4 NEW_LINE #define COL  5 NEW_LINE void findUniqueRows ( int M [ ROW ] [ COL ] ) { for ( int i = 0 ; i < ROW ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < i ; j ++ ) { flag = 1 ; for ( int k = 0 ; k <= COL ; k ++ ) if ( M [ i ] [ k ] != M [ j ] [ k ] ) flag = 0 ; if ( flag == 1 ) break ; } if ( flag == 0 ) { for ( int j = 0 ; j < COL ; j ++ ) cout << M [ i ] [ j ] << " ▁ " ; cout << endl ; } } } int main ( ) { int M [ ROW ] [ COL ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 0 , 0 } } ; findUniqueRows ( M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; struct Cell { int r ; int c ; } ; void printSums ( int mat [ ] [ C ] , struct Cell arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 , r = arr [ i ] . r , c = arr [ i ] . c ; for ( int j = 0 ; j < R ; j ++ ) for ( int k = 0 ; k < C ; k ++ ) if ( j != r && k != c ) sum += mat [ j ] [ k ] ; cout << sum << endl ; } } int main ( ) { int mat [ ] [ C ] = { { 1 , 1 , 2 } , { 3 , 4 , 6 } , { 5 , 3 , 2 } } ; struct Cell arr [ ] = { { 0 , 0 } , { 1 , 1 } , { 0 , 1 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printSums ( mat , arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define n  5 NEW_LINE void printSumTricky ( int mat [ ] [ n ] , int k ) { if ( k > n ) return ; int stripSum [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; cout << sum << " ▁ " ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; cout << sum << " ▁ " ; } cout << endl ; } } int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE #define MAX_K  1000 NEW_LINE using namespace std ; int dp [ R ] [ C ] [ MAX_K ] ; int pathCountDPRecDP ( int mat [ ] [ C ] , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ) ; if ( dp [ m ] [ n ] [ k ] != -1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; } int pathCountDP ( int mat [ ] [ C ] , int k ) { memset ( dp , -1 , sizeof dp ) ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; } int main ( ) { int k = 12 ; int mat [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 6 , 5 } , { 3 , 2 , 1 } } ; cout << pathCountDP ( mat , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; int x [ ] = { 0 , 1 , 1 , -1 , 1 , 0 , -1 , -1 } ; int y [ ] = { 1 , 0 , 1 , 1 , -1 , -1 , 0 , -1 } ; int dp [ R ] [ C ] ; bool isvalid ( int i , int j ) { if ( i < 0 j < 0 i > = R j > = C ) return false ; return true ; } bool isadjacent ( char prev , char curr ) { return ( ( curr - prev ) == 1 ) ; } int getLenUtil ( char mat [ R ] [ C ] , int i , int j , char prev ) { if ( ! isvalid ( i , j ) || ! isadjacent ( prev , mat [ i ] [ j ] ) ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; int ans = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) ; return dp [ i ] [ j ] = ans ; } int getLen ( char mat [ R ] [ C ] , char s ) { memset ( dp , -1 , sizeof dp ) ; int ans = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == s ) { for ( int k = 0 ; k < 8 ; k ++ ) ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; } int main ( ) { char mat [ R ] [ C ] = { { ' a ' , ' c ' , ' d ' } , { ' h ' , ' b ' , ' a ' } , { ' i ' , ' g ' , ' f ' } } ; cout << getLen ( mat , ' a ' ) << endl ; cout << getLen ( mat , ' e ' ) << endl ; cout << getLen ( mat , ' b ' ) << endl ; cout << getLen ( mat , ' f ' ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRepeating ( int arr [ ] , int size ) { int * count = new int [ sizeof ( int ) * ( size - 2 ) ] ; int i ; cout << " ▁ Repeating ▁ elements ▁ are ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " ▁ " ; else count [ arr [ i ] ] ++ ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRepeating ( int arr [ ] , int size ) { int i ; cout << " The ▁ repeating ▁ elements ▁ are " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else cout << " ▁ " << abs ( arr [ i ] ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return -1 ; } int main ( ) { int arr [ 10 ] = { -10 , -1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Fixed ▁ Point ▁ is ▁ " << binarySearch ( arr , 0 , n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << i << " ▁ and ▁ " << j - 1 ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } cout << " No ▁ subarray ▁ found " ; return 0 ; } int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ; int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } int minCost ( int cost [ R ] [ C ] , int m , int n ) { if ( n < 0 m < 0 ) return INT_MAX ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; cout << minCost ( cost , 2 , 2 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <limits.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; int min ( int x , int y , int z ) ; int minCost ( int cost [ R ] [ C ] , int m , int n ) { int i , j ; int tc [ R ] [ C ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; } int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; cout << " ▁ " << minCost ( cost , 2 , 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " << MatrixChainOrder ( arr , size ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max ( int a , int b ) { return ( a > b ) ? a : b ; } int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; cout << knapSack ( W , wt , val , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max ( int a , int b ) { return ( a > b ) ? a : b ; } int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; } int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; cout << knapSack ( W , wt , val , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max ( int x , int y ) { return ( x > y ) ? x : y ; } int lps ( char * seq , int i , int j ) { if ( i == j ) return 1 ; if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ; if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ; return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } int main ( ) { char seq [ ] = " GEEKSFORGEEKS " ; int n = strlen ( seq ) ; cout << " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " << lps ( seq , 0 , n - 1 ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <limits.h> NEW_LINE int max ( int a , int b ) { return ( a > b ) ? a : b ; } int cutRod ( int price [ ] , int n ) { int val [ n + 1 ] ; val [ 0 ] = 0 ; int i , j ; for ( i = 1 ; i <= n ; i ++ ) { int max_val = INT_MIN ; for ( j = 0 ; j < i ; j ++ ) max_val = max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Maximum ▁ Obtainable ▁ Value ▁ is ▁ % dn " , cutRod ( arr , size ) ) ; getchar ( ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int count ( int n ) { int table [ n + 1 ] , i ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; } int main ( void ) { int n = 20 ; cout << " Count ▁ for ▁ " << n << " ▁ is ▁ " << count ( n ) << endl ; n = 13 ; cout << " Count ▁ for ▁ " << n << " ▁ is ▁ " << count ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; } } int main ( ) { char txt [ ] = " AABAACAADAABAAABAA " ; char pat [ ] = " AABA " ; search ( pat , txt ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define d  256 NEW_LINE void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ; int p = 0 ; int t = 0 ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; } if ( j == M ) cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; } if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } int main ( ) { char txt [ ] = " GEEKS ▁ FOR ▁ GEEKS " ; char pat [ ] = " GEEK " ; int q = 101 ; search ( pat , txt , q ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; class gfg { public : int power ( int x , unsigned int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } } ; int main ( ) { gfg g ; int x = 2 ; unsigned int y = 3 ; cout << g . power ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } bool isInside ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x , int y ) { float A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; float A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; float A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; float A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; } int main ( ) { if ( isInside ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) printf ( " Inside " ) ; else printf ( " Not ▁ Inside " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE bool isLucky ( int n ) { static int counter = 2 ; int next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; } int main ( ) { int x = 5 ; if ( isLucky ( x ) ) cout << x << " ▁ is ▁ a ▁ lucky ▁ no . " ; else cout << x << " ▁ is ▁ not ▁ a ▁ lucky ▁ no . " ; }
#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } int findSmallerInRight ( char * str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; } int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; int i ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; } int main ( ) { char str [ ] = " string " ; cout << findRank ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } int main ( ) { int n = 8 , k = 2 ; cout << " Value ▁ of ▁ C ( " << n << " , ▁ " << k << " ) ▁ is ▁ " << binomialCoeff ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPascal ( int n ) { int arr [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; cout << arr [ line ] [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 5 ; printPascal ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float exponential ( int n , float x ) { float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; } int main ( ) { int n = 10 ; float x = 1.0f ; cout << " e ^ x ▁ = ▁ " << fixed << setprecision ( 5 ) << exponential ( n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void primeFactors ( int n ) { while ( n % 2 == 0 ) { cout << 2 << " ▁ " ; n = n / 2 ; } for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { cout << i << " ▁ " ; n = n / i ; } } if ( n > 2 ) cout << n << " ▁ " ; } int main ( ) { int n = 315 ; primeFactors ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) ; void printCombination ( int arr [ ] , int n , int r ) { int data [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; } void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) cout << data [ j ] << " ▁ " ; cout << endl ; return ; } if ( i >= n ) return ; data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; combinationUtil ( arr , n , r , index , data , i + 1 ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printCombination ( arr , n , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; } int main ( ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " << getSingle ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INT_SIZE  32 NEW_LINE int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; } int main ( ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " << getSingle ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = 0 ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; } int main ( ) { int n = 17 ; cout << countSetBits ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } int main ( ) { cout << Add ( 15 , 32 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } int main ( ) { int x = 12 , y = 15 , z = 5 ; cout << " Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ " << smallest ( x , y , z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int addOne ( int x ) { int m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } int main ( ) { cout << addOne ( 13 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int addOne ( int x ) { return ( - ( ~ x ) ) ; } int main ( ) { cout << addOne ( 13 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define bool  int NEW_LINE class GFG { public : bool isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } } ; int main ( ) { GFG g ; int test_no = 64 ; if ( g . isPowerOfFour ( test_no ) ) cout << test_no << " ▁ is ▁ a ▁ power ▁ of ▁ 4" ; else cout << test_no << " is ▁ not ▁ a ▁ power ▁ of ▁ 4" ; getchar ( ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int absbit32 ( int x , int y ) { int sub = x - y ; int mask = ( sub >> 31 ) ; return ( sub ^ mask ) - mask ; } int max ( int x , int y ) { int abs = absbit32 ( x , y ) ; return ( x + y + abs ) / 2 ; } int min ( int x , int y ) { int abs = absbit32 ( x , y ) ; return ( x + y - abs ) / 2 ; } int main ( ) { cout << max ( 2 , 3 ) << endl ; cout << max ( 2 , -3 ) << endl ; cout << max ( -2 , -3 ) << endl ; cout << min ( 2 , 3 ) << endl ; cout << min ( 2 , -3 ) << endl ; cout << min ( -2 , -3 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } int main ( ) { int i = 9 ; cout << countSetBits ( i ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int BitsSetTable256 [ 256 ] ; void initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i / 2 ] ; } } int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; } int main ( ) { initialize ( ) ; int n = 9 ; cout << countSetBits ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } int main ( ) { unsigned int n = 0 ; cout << nextPowerOf2 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int main ( ) { unsigned int n = 5 ; cout << nextPowerOf2 ( n ) ; return 0 ; }
# include <bits/stdc++.h> NEW_LINE # define bool  int NEW_LINE using namespace std ; bool getParity ( unsigned int n ) { bool parity = 0 ; while ( n ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } int main ( ) { unsigned int n = 7 ; cout << " Parity ▁ of ▁ no ▁ " << n << " ▁ = ▁ " << ( getParity ( n ) ? " odd " : " even " ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define bool  int NEW_LINE bool isPowerOfTwo ( int x ) { return x && ( ! ( x & ( x - 1 ) ) ) ; } int main ( ) { isPowerOfTwo ( 31 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isPowerOfTwo ( 64 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int PositionRightmostSetbit ( int n ) { int p = 1 ; while ( n > 0 ) { if ( n & 1 ) { return p ; } p ++ ; n = n >> 1 ; } return -1 ; } int main ( ) { int n = 18 ; int pos = PositionRightmostSetbit ( n ) ; if ( pos != -1 ) cout << pos ; else cout << 0 ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; } int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned i = 1 , pos = 1 ; while ( ! ( i & n ) ) { i = i << 1 ; ++ pos ; } return pos ; } int main ( void ) { int n = 16 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number " << endl : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number " << endl : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number " << endl : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int x = 10 , y = 5 ; x = x * y ; y = x / y ; x = x / y ; cout << " After ▁ Swapping : ▁ x ▁ = " << x << " , ▁ y = " << y ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int x = 10 , y = 5 ; x = x ^ y ; y = x ^ y ; x = x ^ y ; cout << " After ▁ Swapping : ▁ x ▁ = " << x << " , ▁ y = " << y ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; } int main ( ) { int x = 10 ; swap ( & x , & x ) ; cout << " After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ " << x ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int & a , int & b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; cout << " After ▁ swapping : ▁ a ▁ = ▁ " << a << " , ▁ b ▁ = ▁ " << b ; } int main ( ) { int a = 5 , b = 10 ; swap ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } int main ( ) { int arr [ ] = { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , arr_size ) ; cout << " Array ▁ after ▁ segregation ▁ " ; for ( i = 0 ; i < 6 ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = -1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; } int main ( ) { int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxDiff = maxIndexDiff ( arr , n ) ; cout << " STRNEWLINE " << maxDiff ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { vector < long long int > v { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int n = v . size ( ) ; vector < long long int > maxFromEnd ( n + 1 , INT_MIN ) ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { maxFromEnd [ i ] = max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; } int result = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int low = i + 1 , high = v . size ( ) - 1 , ans = i ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( v [ i ] <= maxFromEnd [ mid ] ) { ans = max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } result = max ( result , ans - i ) ; } cout << result << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; } int main ( ) { int arr [ ] = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ maximum ▁ element ▁ is ▁ " << findMaximum ( arr , 0 , n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; } int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( x %= 2 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } void allQueries ( int q , int l [ ] , int r [ ] ) { for ( int i = 0 ; i < q ; i ++ ) cout << ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) << endl ; } int main ( ) { int q = 3 ; int l [ ] = { 2 , 2 , 5 } ; int r [ ] = { 4 , 8 , 9 } ; allQueries ( q , l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double probability ( int a [ ] , int b [ ] , int size1 , int size2 ) { int max1 = INT_MIN , count1 = 0 ; for ( int i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max1 ) { max1 = a [ i ] ; count1 = 1 ; } else if ( a [ i ] == max1 ) { count1 ++ ; } } int max2 = INT_MIN , count2 = 0 ; for ( int i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max2 ) { max2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max2 ) { count2 ++ ; } } return ( double ) ( count1 * count2 ) / ( size1 * size2 ) ; } int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int b [ ] = { 1 , 3 , 3 } ; int size1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int size2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << probability ( a , b , size1 , size2 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minswaps ( int arr [ ] , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; } int main ( ) { int arr [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; cout << minswaps ( arr , 9 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortedMerge ( int a [ ] , int b [ ] , int res [ ] , int n , int m ) { sort ( a , a + n ) ; sort ( b , b + m ) ; int i = 0 , j = 0 , k = 0 ; while ( i < n && j < m ) { if ( a [ i ] <= b [ j ] ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } else { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } while ( i < n ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } while ( j < m ) { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } int main ( ) { int a [ ] = { 10 , 5 , 15 } ; int b [ ] = { 20 , 3 , 2 , 12 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; int res [ n + m ] ; sortedMerge ( a , b , res , n , m ) ; cout << " Sorted ▁ merge ▁ list ▁ : " ; for ( int i = 0 ; i < n + m ; i ++ ) cout << " ▁ " << res [ i ] ; cout << " n " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int singleelement ( int arr [ ] , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 5 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort ( arr , arr + size ) ; cout << singleelement ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMissingNo ( int a [ ] , int n ) { int total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int miss = getMissingNo ( arr , n ) ; cout << miss ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMissingNo ( int a [ ] , int n ) { int i , total = 1 ; for ( i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 } ; cout << getMissingNo ( arr , sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMissingNo ( int a [ ] , int n ) { int n_elements_sum = n * ( n + 1 ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; } int main ( ) { int a [ ] = { 1 , 2 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) + 1 ; int miss = getMissingNo ( a , n ) ; cout << ( miss ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) cout << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] << " , ▁ " << A [ l ] ; } } } } int main ( ) { int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int X = 91 ; findFourElements ( A , n , X ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMajority ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int leastFrequent ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int min_count = n + 1 , res = -1 , curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << leastFrequent ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printmissingk ( int arr [ ] , int n , int k ) { map < int , int > d ; for ( int i = 0 ; i < n ; i ++ ) d [ arr [ i ] ] = arr [ i ] ; int cnt = 1 ; int fl = 0 ; for ( int i = 0 ; i < ( n + k ) ; i ++ ) { if ( d . find ( cnt ) == d . end ( ) ) { fl += 1 ; cout << cnt << " ▁ " ; if ( fl == k ) break ; } cnt += 1 ; } } int main ( ) { int arr [ ] = { 1 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; ; printmissingk ( arr , n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int max_neg = INT_MIN ; int min_pos = INT_MAX ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = max ( max_neg , a [ i ] ) ; } if ( a [ i ] > 0 ) min_pos = min ( min_pos , a [ i ] ) ; prod = prod * a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return min_pos ; if ( ! ( count_neg & 1 ) && count_neg != 0 ) { prod = prod / max_neg ; } return prod ; } int main ( ) { int a [ ] = { -1 , -1 , -2 , 4 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minProductSubset ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; int countCommon ( Node * a , Node * b ) { int count = 0 ; for ( ; a && b ; a = a -> next , b = b -> next ) if ( a -> data == b -> data ) ++ count ; else break ; return count ; } int maxPalindrome ( Node * head ) { int result = 0 ; Node * prev = NULL , * curr = head ; while ( curr ) { Node * next = curr -> next ; curr -> next = prev ; result = max ( result , 2 * countCommon ( prev , next ) + 1 ) ; result = max ( result , 2 * countCommon ( curr , next ) ) ; prev = curr ; curr = next ; } return result ; } Node * newNode ( int key ) { Node * temp = new Node ; temp -> data = key ; temp -> next = NULL ; return temp ; } int main ( ) { Node * head = newNode ( 2 ) ; head -> next = newNode ( 4 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 2 ) ; head -> next -> next -> next -> next -> next = newNode ( 15 ) ; cout << maxPalindrome ( head ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void freeList ( Node * node ) { while ( node != NULL ) { Node * next = node -> next ; delete ( node ) ; node = next ; } } Node * deleteKthNode ( struct Node * head , int k ) { if ( head == NULL ) return NULL ; if ( k == 1 ) { freeList ( head ) ; return NULL ; } struct Node * ptr = head , * prev = NULL ; int count = 0 ; while ( ptr != NULL ) { count ++ ; if ( k == count ) { delete ( prev -> next ) ; prev -> next = ptr -> next ; count = 0 ; } if ( count != 0 ) prev = ptr ; ptr = prev -> next ; } return head ; } void displayList ( struct Node * head ) { struct Node * temp = head ; while ( temp != NULL ) { cout << temp -> data << " ▁ " ; temp = temp -> next ; } } struct Node * newNode ( int x ) { Node * temp = new Node ; temp -> data = x ; temp -> next = NULL ; return temp ; } int main ( ) { struct Node * head = newNode ( 1 ) ; head -> next = newNode ( 2 ) ; head -> next -> next = newNode ( 3 ) ; head -> next -> next -> next = newNode ( 4 ) ; head -> next -> next -> next -> next = newNode ( 5 ) ; head -> next -> next -> next -> next -> next = newNode ( 6 ) ; head -> next -> next -> next -> next -> next -> next = newNode ( 7 ) ; head -> next -> next -> next -> next -> next -> next -> next = newNode ( 8 ) ; int k = 3 ; head = deleteKthNode ( head , k ) ; displayList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; ( * head_ref ) = new_node ; } void sumOfLastN_Nodes ( struct Node * head , int * n , int * sum ) { if ( ! head ) return ; sumOfLastN_Nodes ( head -> next , n , sum ) ; if ( * n > 0 ) { * sum = * sum + head -> data ; -- * n ; } } int sumOfLastN_NodesUtil ( struct Node * head , int n ) { if ( n <= 0 ) return 0 ; int sum = 0 ; sumOfLastN_Nodes ( head , & n , & sum ) ; return sum ; } int main ( ) { struct Node * head = NULL ; push ( & head , 12 ) ; push ( & head , 4 ) ; push ( & head , 8 ) ; push ( & head , 6 ) ; push ( & head , 10 ) ; int n = 2 ; cout << " Sum ▁ of ▁ last ▁ " << n << " ▁ nodes ▁ = ▁ " << sumOfLastN_NodesUtil ( head , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { char data ; struct Node * next ; struct Node * prev ; } ; void push ( struct Node * * head_ref , char new_data ) { struct Node * new_node = new Node ; new_node -> data = new_data ; new_node -> next = ( * head_ref ) ; new_node -> prev = NULL ; if ( ( * head_ref ) != NULL ) ( * head_ref ) -> prev = new_node ; ( * head_ref ) = new_node ; } bool isPalindrome ( struct Node * left ) { if ( left == NULL ) return true ; struct Node * right = left ; while ( right -> next != NULL ) right = right -> next ; while ( left != right ) { if ( left -> data != right -> data ) return false ; left = left -> next ; right = right -> prev ; } return true ; } int main ( ) { struct Node * head = NULL ; push ( & head , ' l ' ) ; push ( & head , ' e ' ) ; push ( & head , ' v ' ) ; push ( & head , ' e ' ) ; push ( & head , ' l ' ) ; if ( isPalindrome ( head ) ) printf ( " It ▁ is ▁ Palindrome " ) ; else printf ( " Not ▁ Palindrome " ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct Node { int data ; struct Node * left , * right ; } ; void printLeafNodes ( Node * root ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { cout << root -> data << " ▁ " ; return ; } if ( root -> left ) printLeafNodes ( root -> left ) ; if ( root -> right ) printLeafNodes ( root -> right ) ; } Node * newNode ( int data ) { Node * temp = new Node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { Node * root = newNode ( 1 ) ; root -> left = newNode ( 2 ) ; root -> right = newNode ( 3 ) ; root -> left -> left = newNode ( 4 ) ; root -> right -> left = newNode ( 5 ) ; root -> right -> right = newNode ( 8 ) ; root -> right -> left -> left = newNode ( 6 ) ; root -> right -> left -> right = newNode ( 7 ) ; root -> right -> right -> left = newNode ( 9 ) ; root -> right -> right -> right = newNode ( 10 ) ; printLeafNodes ( root ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; struct node { int data ; struct node * left , * right ; } ; void printkdistanceNodeDown ( node * root , int k ) { if ( root == NULL k < 0 ) return ; if ( k == 0 ) { cout << root -> data << endl ; return ; } printkdistanceNodeDown ( root -> left , k - 1 ) ; printkdistanceNodeDown ( root -> right , k - 1 ) ; } int printkdistanceNode ( node * root , node * target , int k ) { if ( root == NULL ) return -1 ; if ( root == target ) { printkdistanceNodeDown ( root , k ) ; return 0 ; } int dl = printkdistanceNode ( root -> left , target , k ) ; if ( dl != -1 ) { if ( dl + 1 == k ) cout << root -> data << endl ; else printkdistanceNodeDown ( root -> right , k - dl - 2 ) ; return 1 + dl ; } int dr = printkdistanceNode ( root -> right , target , k ) ; if ( dr != -1 ) { if ( dr + 1 == k ) cout << root -> data << endl ; else printkdistanceNodeDown ( root -> left , k - dr - 2 ) ; return 1 + dr ; } return -1 ; } node * newnode ( int data ) { node * temp = new node ; temp -> data = data ; temp -> left = temp -> right = NULL ; return temp ; } int main ( ) { node * root = newnode ( 20 ) ; root -> left = newnode ( 8 ) ; root -> right = newnode ( 22 ) ; root -> left -> left = newnode ( 4 ) ; root -> left -> right = newnode ( 12 ) ; root -> left -> right -> left = newnode ( 10 ) ; root -> left -> right -> right = newnode ( 14 ) ; node * target = root -> left -> right ; printkdistanceNode ( root , target , 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE int findMaximumDiagonalSumOMatrixf ( int A [ ] [ N ] ) { int maxDiagonalSum = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ j ] [ ( i + j ) % N ] ; } maxDiagonalSum = max ( maxDiagonalSum , curr ) ; } for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ ( i + j ) % N ] [ j ] ; } maxDiagonalSum = max ( maxDiagonalSum , curr ) ; } return maxDiagonalSum ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 1 , 2 } , { 2 , 1 , 2 } , { 1 , 2 , 2 } } ; cout << findMaximumDiagonalSumOMatrixf ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void left_rotate ( int arr [ ] ) { int last = arr [ 1 ] ; for ( int i = 3 ; i < 6 ; i = i + 2 ) { arr [ i - 2 ] = arr [ i ] ; } arr [ 6 - 1 ] = last ; } void right_rotate ( int arr [ ] ) { int start = arr [ 6 - 2 ] ; for ( int i = 6 - 4 ; i >= 0 ; i = i - 2 ) { arr [ i + 2 ] = arr [ i ] ; } arr [ 0 ] = start ; } void rotate ( int arr [ ] ) { left_rotate ( arr ) ; right_rotate ( arr ) ; for ( int i = 0 ; i < 6 ; i ++ ) { cout << ( arr [ i ] ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; rotate ( arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRotation ( int arr [ ] , int low , int high ) { if ( low > high ) { return 0 ; } int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid ; } if ( arr [ mid ] > arr [ low ] ) { return countRotation ( arr , mid + 1 , high ) ; } if ( arr [ mid ] < arr [ high ] ) { return countRotation ( arr , low , mid - 1 ) ; } else { int rightIndex = countRotation ( arr , mid + 1 , high ) ; int leftIndex = countRotation ( arr , low , mid - 1 ) ; if ( rightIndex == 0 ) { return leftIndex ; } return rightIndex ; } } int main ( ) { int arr1 [ ] = { 4 , 5 , 1 , 2 , 3 } ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << countRotation ( arr1 , 0 , N - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE const int MAX = 100005 ; using namespace std ; int seg [ 4 * MAX ] ; void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } } int query ( int node , int l , int r , int start , int end , int a [ ] ) { if ( l > end or r < start ) return 0 ; if ( start <= l and r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; } void orsum ( int a [ ] , int n , int q , int k [ ] ) { build ( 1 , 0 , n - 1 , a ) ; for ( int j = 0 ; j < q ; j ++ ) { int i = k [ j ] % ( n / 2 ) ; int sec = query ( 1 , 0 , n - 1 , n / 2 - i , n - i - 1 , a ) ; int first = ( query ( 1 , 0 , n - 1 , 0 , n / 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; int temp = sec + first ; cout << temp << endl ; } } int main ( ) { int a [ ] = { 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int q = 2 ; int k [ q ] = { 4 , 2 } ; orsum ( a , n , q , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumEqual ( int a [ ] , int b [ ] , int n ) { vector < int > store ( 1e5 ) ; for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } vector < int > ans ( 1e5 ) ; for ( int i = 0 ; i < n ; i ++ ) { int d = abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } int finalans = 0 ; for ( int i = 0 ; i < 1e5 ; i ++ ) finalans = max ( finalans , ans [ i ] ) ; cout << finalans << " STRNEWLINE " ; } int main ( ) { int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maximumEqual ( A , B , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRotation ( int n ) { int count = 0 ; do { int digit = n % 10 ; if ( digit == 0 ) count ++ ; n = n / 10 ; } while ( n != 0 ) ; return count ; } int main ( ) { int n = 10203 ; cout << countRotation ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int a [ ] , int n ) { if ( n <= 2 ) return true ; int flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] > a [ i + 1 ] and a [ i + 1 ] > a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] < a [ i + 1 ] and a [ i + 1 ] < a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; int val1 = INT_MAX , mini = -1 , val2 = INT_MIN , maxi ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < val1 ) { mini = i ; val1 = a [ i ] ; } if ( a [ i ] > val2 ) { maxi = i ; val2 = a [ i ] ; } } flag = 1 ; for ( int i = 0 ; i < maxi ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 and maxi + 1 == mini ) { flag = 1 ; for ( int i = mini ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } flag = 1 ; for ( int i = 0 ; i < mini ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 and maxi - 1 == mini ) { flag = 1 ; for ( int i = maxi ; i < n - 1 ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } return false ; } int main ( ) { int a [ ] = { 4 , 5 , 6 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isPossible ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } void cal ( int num ) { int digits = numberOfDigits ( num ) ; int powTen = pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int firstDigit = num / powTen ; int left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; cout << left << " ▁ " ; num = left ; } } int main ( ) { int num = 1445 ; cal ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CheckKCycles ( int n , string s ) { bool ff = true ; int x = 0 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( s . substr ( i ) + s . substr ( 0 , i ) ) . length ( ) ; if ( x >= s . length ( ) ) { continue ; } ff = false ; break ; } if ( ff ) { cout << ( " Yes " ) ; } else { cout << ( " No " ) ; } } int main ( ) { int n = 3 ; string s = "123" ; CheckKCycles ( n , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateNumbers ( int m ) { vector < int > numbers ; int k_max , x ; for ( int y = 0 ; y < 10 ; y ++ ) { k_max = ( int ) ( pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / ( int ) ( pow ( 10 , m - 1 ) + y ) ; for ( int k = 1 ; k <= k_max ; k ++ ) { x = ( int ) ( y * ( pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ; if ( ( int ) ( y * ( pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) numbers . push_back ( 10 * x + y ) ; } } sort ( numbers . begin ( ) , numbers . end ( ) ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) cout << ( numbers [ i ] ) << endl ; } int main ( ) { int m = 3 ; generateNumbers ( m ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE void rotate90Clockwise ( int arr [ N ] [ N ] ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) cout << arr [ i ] [ j ] << " ▁ " ; cout << ' ' ; } } int main ( ) { int arr [ N ] [ N ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; rotate90Clockwise ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findStartIndexOfArray ( int arr [ ] , int low , int high ) { if ( low > high ) { return -1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) return mid + 1 ; if ( arr [ mid - 1 ] > arr [ mid ] ) return mid ; if ( arr [ low ] > arr [ mid ] ) return findStartIndexOfArray ( arr , low , mid - 1 ) ; else return findStartIndexOfArray ( arr , mid + 1 , high ) ; } void restoreSortedArray ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) return ; int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; reverse ( arr , arr + start ) ; reverse ( arr + start , arr + n ) ; reverse ( arr , arr + n ) ; } void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }
class Node { public : int data ; Node * next ; } ;
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int data ) { struct Node * ptr1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * temp = * head_ref ; ptr1 -> data = data ; ptr1 -> next = * head_ref ; if ( * head_ref != NULL ) { while ( temp -> next != * head_ref ) temp = temp -> next ; temp -> next = ptr1 ; } else ptr1 -> next = ptr1 ; * head_ref = ptr1 ; } void deleteNode ( Node * & head_ref , Node * del ) { if ( head_ref == del ) head_ref = del -> next ; struct Node * temp = head_ref ; while ( temp -> next != del ) { temp = temp -> next ; } temp -> next = del -> next ; free ( del ) ; return ; } bool isEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( x & 1 ) parity ++ ; x = x >> 1 ; } if ( parity % 2 == 0 ) return true ; else return false ; } void deleteEvenParityNodes ( Node * & head ) { if ( head == NULL ) return ; if ( head == head -> next ) { if ( isEvenParity ( head -> data ) ) head = NULL ; return ; } struct Node * ptr = head ; struct Node * next ; do { next = ptr -> next ; if ( isEvenParity ( ptr -> data ) ) deleteNode ( head , ptr ) ; ptr = next ; } while ( ptr != head ) ; if ( head == head -> next ) { if ( isEvenParity ( head -> data ) ) head = NULL ; return ; } } void printList ( struct Node * head ) { if ( head == NULL ) { cout << " Empty ▁ List STRNEWLINE " ; return ; } struct Node * temp = head ; if ( head != NULL ) { do { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } while ( temp != head ) ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 21 ) ; push ( & head , 13 ) ; push ( & head , 6 ) ; push ( & head , 34 ) ; push ( & head , 9 ) ; push ( & head , 11 ) ; deleteEvenParityNodes ( head ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; } ; void push ( struct Node * * head_ref , int data ) { struct Node * ptr1 = ( struct Node * ) malloc ( sizeof ( struct Node ) ) ; struct Node * temp = * head_ref ; ptr1 -> data = data ; ptr1 -> next = * head_ref ; if ( * head_ref != NULL ) { while ( temp -> next != * head_ref ) temp = temp -> next ; temp -> next = ptr1 ; } else ptr1 -> next = ptr1 ; * head_ref = ptr1 ; } void deleteNode ( Node * head_ref , Node * del ) { struct Node * temp = head_ref ; if ( head_ref == del ) head_ref = del -> next ; while ( temp -> next != del ) { temp = temp -> next ; } temp -> next = del -> next ; free ( del ) ; return ; } int digitSum ( int num ) { int sum = 0 ; while ( num ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; } void deleteEvenDigitSumNodes ( Node * head ) { struct Node * ptr = head ; struct Node * next ; do { if ( ! ( digitSum ( ptr -> data ) & 1 ) ) deleteNode ( head , ptr ) ; next = ptr -> next ; ptr = next ; } while ( ptr != head ) ; } void printList ( struct Node * head ) { struct Node * temp = head ; if ( head != NULL ) { do { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } while ( temp != head ) ; } } int main ( ) { struct Node * head = NULL ; push ( & head , 21 ) ; push ( & head , 13 ) ; push ( & head , 6 ) ; push ( & head , 34 ) ; push ( & head , 11 ) ; push ( & head , 9 ) ; deleteEvenDigitSumNodes ( head ) ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { int data ; struct Node * next ; struct Node * prev ; } ; void insertNode ( struct Node * * start , int value ) { if ( * start == NULL ) { struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = new_node -> prev = new_node ; * start = new_node ; return ; } Node * last = ( * start ) -> prev ; struct Node * new_node = new Node ; new_node -> data = value ; new_node -> next = * start ; ( * start ) -> prev = new_node ; new_node -> prev = last ; last -> next = new_node ; } void displayList ( struct Node * start ) { struct Node * temp = start ; while ( temp -> next != start ) { printf ( " % d ▁ " , temp -> data ) ; temp = temp -> next ; } printf ( " % d ▁ " , temp -> data ) ; } int searchList ( struct Node * start , int search ) { struct Node * temp = start ; int count = 0 , flag = 0 , value ; if ( temp == NULL ) return -1 ; else { while ( temp -> next != start ) { count ++ ; if ( temp -> data == search ) { flag = 1 ; count -- ; break ; } temp = temp -> next ; } if ( temp -> data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) cout << " STRNEWLINE " << search << " ▁ found ▁ at ▁ location ▁ " << count << endl ; else cout << " STRNEWLINE " << search << " ▁ not ▁ found " << endl ; } } int main ( ) { struct Node * start = NULL ; insertNode ( & start , 4 ) ; insertNode ( & start , 5 ) ; insertNode ( & start , 7 ) ; insertNode ( & start , 8 ) ; insertNode ( & start , 6 ) ; printf ( " Created ▁ circular ▁ doubly ▁ linked ▁ list ▁ is : ▁ " ) ; displayList ( start ) ; searchList ( start , 5 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000 NEW_LINE int weight [ MAX ] ; int level [ MAX ] ; int par [ MAX ] ; bool prime [ MAX + 1 ] ; vector < int > graph [ MAX ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } void dfs ( int node , int parent , int h ) { par [ node ] = parent ; level [ node ] = h ; for ( int child : graph [ node ] ) { if ( child == parent ) continue ; dfs ( child , node , h + 1 ) ; } } int findPrimeOnPath ( int u , int v ) { int count = 0 ; if ( level [ u ] > level [ v ] ) swap ( u , v ) ; int d = level [ v ] - level [ u ] ; while ( d -- ) { if ( prime [ weight [ v ] ] ) count ++ ; v = par [ v ] ; } if ( v == u ) { if ( prime [ weight [ v ] ] ) count ++ ; return count ; } while ( v != u ) { if ( prime [ weight [ v ] ] ) count ++ ; if ( prime [ weight [ u ] ] ) count ++ ; u = par [ u ] ; v = par [ v ] ; } if ( prime [ weight [ v ] ] ) count ++ ; return count ; } int main ( ) { SieveOfEratosthenes ( ) ; weight [ 1 ] = 5 ; weight [ 2 ] = 10 ; weight [ 3 ] = 11 ; weight [ 4 ] = 8 ; weight [ 5 ] = 6 ; graph [ 1 ] . push_back ( 2 ) ; graph [ 2 ] . push_back ( 3 ) ; graph [ 2 ] . push_back ( 4 ) ; graph [ 1 ] . push_back ( 5 ) ; dfs ( 1 , -1 , 0 ) ; int u = 3 , v = 5 ; cout << findPrimeOnPath ( u , v ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { Node * left ; Node * right ; int data ; } ; Node * newNode ( int key ) { Node * node = new Node ( ) ; node -> left = node -> right = NULL ; node -> data = key ; return node ; } bool FindPath ( Node * root , vector < int > & path , int key ) { if ( root == NULL ) return false ; path . push_back ( root -> data ) ; if ( root -> data == key ) return true ; if ( FindPath ( root -> left , path , key ) || FindPath ( root -> right , path , key ) ) return true ; path . pop_back ( ) ; return false ; } int minMaxNodeInPath ( Node * root , int a , int b ) { vector < int > Path1 ; vector < int > Path2 ; int min1 = INT_MAX ; int max1 = INT_MIN ; int min2 = INT_MAX ; int max2 = INT_MIN ; int i = 0 ; int j = 0 ; if ( FindPath ( root , Path1 , a ) && FindPath ( root , Path2 , b ) ) { for ( i = 0 ; i < Path1 . size ( ) && Path2 . size ( ) ; i ++ ) if ( Path1 [ i ] != Path2 [ i ] ) break ; i -- ; j = i ; for ( ; i < Path1 . size ( ) ; i ++ ) { if ( min1 > Path1 [ i ] ) min1 = Path1 [ i ] ; if ( max1 < Path1 [ i ] ) max1 = Path1 [ i ] ; } for ( ; j < Path2 . size ( ) ; j ++ ) { if ( min2 > Path2 [ j ] ) min2 = Path2 [ j ] ; if ( max2 < Path2 [ j ] ) max2 = Path2 [ j ] ; } cout << " Min ▁ = ▁ " << min ( min1 , min2 ) << endl ; cout << " Max ▁ = ▁ " << max ( max1 , max2 ) ; } else cout << " Max = -1 " ; } int main ( ) { Node * root = newNode ( 20 ) ; root -> left = newNode ( 8 ) ; root -> right = newNode ( 22 ) ; root -> left -> left = newNode ( 5 ) ; root -> left -> right = newNode ( 3 ) ; root -> right -> left = newNode ( 4 ) ; root -> right -> right = newNode ( 25 ) ; root -> left -> right -> left = newNode ( 10 ) ; root -> left -> right -> right = newNode ( 14 ) ; int a = 5 ; int b = 1454 ; minMaxNodeInPath ( root , a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  100001 NEW_LINE vector < int > tree [ MAXN ] ; int path [ 3 ] [ MAXN ] ; void dfs ( int cur , int prev , int pathNumber , int ptr , int node , bool & flag ) { for ( int i = 0 ; i < tree [ cur ] . size ( ) ; i ++ ) { if ( tree [ cur ] [ i ] != prev and ! flag ) { path [ pathNumber ] [ ptr ] = tree [ cur ] [ i ] ; if ( tree [ cur ] [ i ] == node ) { flag = true ; path [ pathNumber ] [ ptr + 1 ] = -1 ; return ; } dfs ( tree [ cur ] [ i ] , cur , pathNumber , ptr + 1 , node , flag ) ; } } } int LCA ( int a , int b ) { if ( a == b ) return a ; path [ 1 ] [ 0 ] = path [ 2 ] [ 0 ] = 1 ; bool flag = false ; dfs ( 1 , 0 , 1 , 1 , a , flag ) ; flag = false ; dfs ( 1 , 0 , 2 , 1 , b , flag ) ; int i = 0 ; while ( path [ 1 ] [ i ] == path [ 2 ] [ i ] ) i ++ ; return path [ 1 ] [ i - 1 ] ; } void addEdge ( int a , int b ) { tree [ a ] . push_back ( b ) ; tree [ b ] . push_back ( a ) ; } int main ( ) { int n = 8 ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 3 , 8 ) ; cout << " LCA ( 4 , ▁ 7 ) ▁ = ▁ " << LCA ( 4 , 7 ) << endl ; cout << " LCA ( 4 , ▁ 6 ) ▁ = ▁ " << LCA ( 4 , 6 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIfDivisible ( string str , long long int num ) { long long int powerOf2 = log2 ( num ) ; if ( str . length ( ) < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; long long int i , number = 0 ; int len = str . length ( ) ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str [ i ] - '0' ) * pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num ) return false ; else return true ; } int main ( ) { string str = "213467756564" ; long long int num = 4 ; if ( checkIfDivisible ( str , num ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int longest_subarray ( int arr [ ] , int d ) { int i = 0 , j = 1 , e = 0 ; for ( i = 0 ; i < d - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { j = j + 1 ; } else { j = 1 ; } if ( e < j ) { e = j ; } } return e ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longest_subarray ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int n = 10005 ; vector < bool > Prime ( n + 1 , true ) ; void SieveOfEratosthenes ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= 10005 ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < 10005 ; j += i ) { Prime [ j ] = false ; } } } } void primeDegreeNodes ( int N , int M , int edges [ ] [ 2 ] ) { vector < int > Adj [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { int x = edges [ i ] [ 0 ] ; int y = edges [ i ] [ 1 ] ; Adj [ x ] . push_back ( y ) ; Adj [ y ] . push_back ( x ) ; } SieveOfEratosthenes ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { int x = Adj [ i ] . size ( ) ; if ( Prime [ x ] ) cout << i << ' ▁ ' ; } } int main ( ) { int N = 4 , M = 6 ; int edges [ M ] [ 2 ] = { { 1 , 2 } , { 1 , 3 } , { 1 , 4 } , { 2 , 3 } , { 2 , 4 } , { 3 , 4 } } ; primeDegreeNodes ( N , M , edges ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int countWays ( int colored [ ] , int count , int n ) { if ( count == n ) { return 1 ; } int answer = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( colored [ i ] == 0 ) { if ( colored [ i - 1 ] == 1 colored [ i + 1 ] == 1 ) { colored [ i ] = 1 ; answer = ( answer + countWays ( colored , count + 1 , n ) ) % mod ; colored [ i ] = 0 ; } } } return answer ; } int waysToColor ( int arr [ ] , int n , int k ) { int colored [ n + 2 ] = { 0 } ; for ( int i = 0 ; i < k ; i ++ ) { colored [ arr [ i ] ] = 1 ; } return countWays ( colored , k , n ) ; } int main ( ) { int N = 6 ; int K = 3 ; int arr [ K ] = { 1 , 2 , 6 } ; cout << waysToColor ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPermutation ( int arr [ ] , int n ) { long long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; long long prefix [ n + 1 ] = { 0 } ; prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long long lsum = prefix [ i ] ; long long rsum = sum - prefix [ i ] ; long long l_len = i + 1 , r_len = n - i - 1 ; if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) && ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) return true ; } return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 3 , 4 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; if ( checkPermutation ( arr , n ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNextNumber ( int n ) { int h [ 10 ] = { 0 } ; int i = 0 , msb = n , rem = 0 ; int next_num = -1 , count = 0 ; while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb /= 10 ; count ++ ; } h [ msb ] = 1 ; count ++ ; for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } } if ( next_num == -1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } } if ( next_num > 0 ) { for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } } for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; } if ( next_num > n ) cout << next_num << " STRNEWLINE " ; else cout << " Not ▁ Possible ▁ STRNEWLINE " ; } else { cout << " Not ▁ Possible ▁ STRNEWLINE " ; } } int main ( ) { int n = 2019 ; findNextNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTheNumber ( int n ) { if ( n == 1 ) { cout << " Impossible " << endl ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { cout << "5" ; } cout << "4" ; } int main ( ) { int n = 12 ; findTheNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAXN = 1000005 ; int even [ MAXN ] , odd [ MAXN ] ; void precompute ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd [ i ] = 1 ; if ( arr [ i ] % 2 == 0 ) even [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } } bool isOdd ( int L , int R ) { int cnt = odd [ R ] ; if ( L > 0 ) cnt -= odd [ L - 1 ] ; if ( cnt == R - L + 1 ) return true ; return false ; } void performQueries ( int a [ ] , int n , int q [ ] [ 2 ] , int m ) { precompute ( a , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] [ 0 ] , R = q [ i ] [ 1 ] ; if ( isOdd ( L , R ) ) cout << " Odd STRNEWLINE " ; else cout << " Even STRNEWLINE " ; } } int main ( ) { int a [ ] = { 2 , 1 , 5 , 7 , 6 , 8 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int q [ ] [ 2 ] = { { 0 , 2 } , { 1 , 2 } , { 2 , 3 } , { 3 , 6 } } ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; performQueries ( a , n , q , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string getWinner ( string str , int len ) { int total = 0 ; if ( str [ 0 ] == ' G ' str [ len - 1 ] == ' G ' ) return " First " ; else { for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' S ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " First " ; return " Second " ; } } int main ( ) { string str = " GSSS " ; int len = str . length ( ) ; cout << getWinner ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void findArrangement ( int arr [ ] , int n ) { if ( n < 2 ) { cout << " - 1" ; return ; } int minVal = * min_element ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == minVal ) { swap ( arr [ i ] , arr [ n - 1 ] ) ; break ; } } int andVal = arr [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { andVal &= arr [ i ] ; } if ( andVal == arr [ n - 1 ] ) printArr ( arr , n ) ; else cout << " - 1" ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; findArrangement ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxOperations ( int X , int Y ) { if ( X > Y ) return -1 ; int diff = Y - X ; if ( diff == 1 ) return -1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; } int main ( ) { int X = 5 , Y = 16 ; cout << maxOperations ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void randomList ( int m , int n ) { int arr [ m ] = { 0 } ; srand ( time ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ rand ( ) % m ] ++ ; } printArr ( arr , m ) ; } int main ( ) { int m = 4 , n = 8 ; randomList ( m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find_maximum_value ( int a [ ] , int n ) { int sum = 0 ; int minimum = INT_MAX ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = min ( minimum , abs ( a [ i ] ) ) ; sum += abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; } int main ( ) { int a [ ] = { 5 , 4 , 6 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << find_maximum_value ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return -1 ; } int main ( ) { int p = 24 , q = 48 ; cout << getMinVal ( p , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_prefix ( string temp , string str ) { if ( temp . length ( ) < str . length ( ) ) return 0 ; else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] != temp [ i ] ) return 0 ; } return 1 ; } } string lexicographicallyString ( string input [ ] , int n , string str ) { sort ( input , input + n ) ; for ( int i = 0 ; i < n ; i ++ ) { string temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return " - 1" ; } int main ( ) { string arr [ ] = { " apple " , " appe " , " apl " , " aapl " , " appax " } ; string S = " app " ; int N = 5 ; cout << lexicographicallyString ( arr , N , S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSumPair ( int arr [ ] , int N ) { if ( N < 5 ) { return -1 ; } int prefixMin [ N ] ; prefixMin [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N - 1 ; i ++ ) { prefixMin [ i ] = min ( arr [ i ] , prefixMin [ i - 1 ] ) ; } int ans = INT_MAX ; for ( int i = 3 ; i < N - 1 ; i ++ ) { ans = min ( ans , arr [ i ] + prefixMin [ i - 2 ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 5 , 2 , 4 , 6 , 3 , 7 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << minSumPair ( arr , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findCount ( string number ) { int sum = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { sum += number [ i ] - 48 ; } int count = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { int remaining_sum = sum - ( number [ i ] - 48 ) ; for ( int j = 0 ; j <= 9 ; ++ j ) { if ( ( remaining_sum + j ) % 3 == 0 && j != number [ i ] - 48 ) { ++ count ; } } } cout << count ; } int main ( ) { string number = "235" ; findCount ( number ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll n , m , k , l , r , i ; ll check ( ll v , vector < ll > & a ) { ll tec = 0 , ans = 0 ; vector < ll > b ( n + k + 1 ) ; for ( i = 0 ; i < n ; i ++ ) { tec -= b [ i ] ; if ( a [ i ] + tec < v ) { ll mov = v - a [ i ] - tec ; ans = ans + mov ; tec += mov ; b [ i + k ] = mov ; } } return ( ans <= m ) ; } ll FindLargest ( vector < ll > a ) { l = 1 ; r = pow ( 10 , 10 ) ; while ( r - l > 0 ) { ll tm = ( l + r + 1 ) / 2 ; if ( check ( tm , a ) ) l = tm ; else r = tm - 1 ; } return l ; } int main ( ) { vector < ll > a { 2 , 2 , 2 , 2 , 1 , 1 } ; m = 2 ; k = 3 ; n = a . size ( ) ; cout << FindLargest ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void numberofBoxes ( int W , int B , int O ) { int low = 0 , high = min ( W , B ) ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( ( ( W >= mid ) and ( B >= mid ) ) and ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } cout << ans ; } int main ( ) { int W = 3 , B = 3 , O = 1 ; numberofBoxes ( W , B , O ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int A , int B ) { for ( int i = 1 ; i <= B ; i ++ ) { int y = A ^ i ; if ( y > 0 and ( i y ) == B ) { cout << i << " ▁ " << y << endl ; } } } int main ( ) { int A = 8 , B = 10 ; findPairs ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool ischar ( char x ) { if ( ( x >= ' A ' && x <= ' Z ' ) || ( x >= ' a ' && x <= ' z ' ) ) { return 1 ; } return 0 ; } bool isnum ( char x ) { if ( x >= '0' && x <= '9' ) return 1 ; return 0 ; } void findIdandDomain ( string S , int N ) { string ID , Domain ; vector < string > words ; string curr = " " ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' ▁ ' ) { words . push_back ( curr ) ; curr = " " ; } else { if ( S [ i ] == ' . ' ) { if ( i + 1 == N || ( i + 1 < N && S [ i + 1 ] == ' ▁ ' ) ) continue ; } curr += S [ i ] ; } } if ( curr . length ( ) ) words . push_back ( curr ) ; for ( string ss : words ) { if ( ss . size ( ) == 10 ) { bool flag = 0 ; for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j >= 5 && j < 9 ) { if ( isnum ( ss [ j ] ) == 0 ) flag = 1 ; } else { if ( ischar ( ss [ j ] ) == 0 ) flag = 1 ; } } if ( ! flag ) { ID = ss ; } } if ( ss . substr ( 0 , 3 ) == " www " && ss . substr ( ss . length ( ) - 3 , 3 ) == " com " ) { Domain = ss . substr ( 4 , ss . size ( ) - 4 ) ; } } cout << " ID ▁ = ▁ " << ID << endl ; cout << " Domain ▁ = ▁ " << Domain ; } int main ( ) { string S = " We ▁ thank ▁ ABCDE1234F ▁ for ▁ visiting ▁ " " us ▁ and ▁ buying ▁ " " products ▁ item ▁ AMZrr @ ! k . ▁ For ▁ more ▁ " " offers , ▁ visit ▁ " " us ▁ at ▁ www . amazon . com " ; int N = S . length ( ) ; findIdandDomain ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTriplets ( int D , vector < int > & arr ) { unordered_map < int , int > freq ; int ans = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { if ( freq . find ( arr [ i ] - D ) != freq . end ( ) && freq . find ( arr [ i ] - 2 * D ) != freq . end ( ) ) { ans += freq [ arr [ i ] - D ] * freq [ arr [ i ] - 2 * D ] ; } freq [ arr [ i ] ] ++ ; } return ans ; } int main ( ) { vector < int > arr { 1 , 2 , 4 , 5 , 7 , 8 , 10 } ; int D = 1 ; cout << countTriplets ( D , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool bound ( int w , int h , int N , int x ) { int val = ( x / w ) * ( x / h ) ; if ( val >= N ) return true ; else return false ; } int FindSquare ( int N , int W , int H ) { int i = 1 ; int j = W * H * N ; while ( i < j ) { int mid = i + ( j - i ) / 2 ; if ( bound ( W , H , N , mid ) ) j = mid ; else i = mid + 1 ; } return j ; } int main ( ) { int W = 2 ; int H = 3 ; int N = 10 ; cout << FindSquare ( N , W , H ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } } void sumOfPrimeSquare ( int n ) { bool flag = false ; bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , n ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) continue ; int dif = n - i ; if ( ceil ( ( double ) sqrt ( dif ) ) == floor ( ( double ) sqrt ( dif ) ) ) { flag = true ; break ; } } if ( flag ) { cout << " Yes " ; } else cout << " No " ; } int main ( ) { int N = 27 ; sumOfPrimeSquare ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; bool check ( int arr [ ] , int M , int K , int ind ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 1 ; j < K ; j ++ ) { if ( arr [ ind + i ] != arr [ ind + i + j * M ] ) { return false ; } } } return true ; } bool SubarrayRepeatsKorMore ( int arr [ ] , int N , int M , int K ) { for ( int ind = 0 ; ind <= N - M * K ; ind ++ ) { if ( check ( arr , M , K , ind ) ) { return true ; } } return false ; } int main ( ) { int arr [ ] = { 2 , 1 , 2 , 1 , 1 , 1 , 3 } ; int M = 2 , K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( SubarrayRepeatsKorMore ( arr , N , M , K ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumNumber ( int K , int X ) { if ( K > X ) { cout << " - 1" ; return ; } int ans = 0 ; int sum = 0 ; for ( int i = K ; i <= X ; i ++ ) { sum += i ; if ( sum >= X ) { ans = i ; break ; } } cout << ans ; } int main ( ) { int K = 5 , X = 13 ; minimumNumber ( K , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int peakIndex ( int arr [ ] , int N ) { if ( N < 3 ) return -1 ; int i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return -1 ; int ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return -1 ; } int main ( ) { int arr [ ] = { 0 , 1 , 0 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << peakIndex ( arr , N ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = abs ( arr [ i ] ) ; sort ( arr , arr + N ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } cout << ans ; } int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void evenproduct ( int arr [ ] , int length ) { int count = 0 ; for ( int i = 0 ; i < length + 1 ; i ++ ) { int product = 1 ; for ( int j = i ; j < length + 1 ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } cout << count ; } int main ( ) { int arr [ ] = { 7 , 5 , 4 , 9 } ; int length = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) - 1 ; evenproduct ( arr , length ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalWays ( int n , string str ) { vector < int > IdxOf0s ; int cntWays = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { IdxOf0s . push_back ( i ) ; } } int M = IdxOf0s . size ( ) ; if ( M == 0 or M % 2 ) { return 0 ; } for ( int i = 2 ; i < M ; i += 2 ) { cntWays = cntWays * ( IdxOf0s [ i ] - IdxOf0s [ i - 1 ] ) ; } return cntWays ; } int main ( ) { string str = "00100" ; int n = str . length ( ) ; cout << totalWays ( n , str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountSubarray ( int arr [ ] , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 7 , 9 , 3 , 2 , 1 , 8 , 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << CountSubarray ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countDivisors ( long long int n ) { int count = 0 ; vector < long long int > divisor ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) divisor . push_back ( i ) ; else { divisor . push_back ( i ) ; divisor . push_back ( n / i ) ; } } } divisor . push_back ( n ) ; for ( auto x : divisor ) { x -= 1 ; if ( ( n / x ) == ( n % x ) ) count ++ ; } cout << count ; } int main ( ) { long long int N = 1000000000000 ; countDivisors ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxLength ( int N , vector < int > arr ) { vector < int > dp ( N + 1 , 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 2 * i ; j <= N ; j += i ) { if ( arr [ i - 1 ] < arr [ j - 1 ] ) { dp [ j ] = max ( dp [ j ] , dp [ i ] + 1 ) ; } } } return * max_element ( dp . begin ( ) , dp . end ( ) ) ; } int main ( ) { vector < int > arr { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int N = arr . size ( ) ; cout << findMaxLength ( N , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long power ( long long x , long long N ) { long long res = 1 ; while ( N > 0 ) { if ( N & 1 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; } void findValX_Y ( long long N ) { if ( N <= 1 ) { cout << -1 << endl ; return ; } int xMax ; xMax = log2 ( N ) ; int yMax ; yMax = ( log2 ( N ) / log2 ( 5.0 ) ) ; for ( long long i = 1 ; i <= xMax ; i ++ ) { for ( long long j = 1 ; j <= yMax ; j ++ ) { long long a = power ( 2 , i ) ; long long b = power ( 5 , j ) ; if ( a + b == N ) { cout << i << " ▁ " << j << endl ; return ; } } } cout << -1 << endl ; } int main ( ) { long long N = 129 ; findValX_Y ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string toggleQuery ( string str , int Q [ ] [ 2 ] , int M ) { int N = str . length ( ) ; int prefixCnt [ N + 1 ] = { 0 } ; for ( int i = 0 ; i < M ; i ++ ) { prefixCnt [ Q [ i ] [ 0 ] ] += 1 ; prefixCnt [ Q [ i ] [ 1 ] + 1 ] -= 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { prefixCnt [ i ] += prefixCnt [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( prefixCnt [ i ] % 2 ) { str [ i ] = '1' - str [ i ] + '0' ; } } return str ; } int main ( ) { string str = "101010" ; int Q [ ] [ 2 ] = { { 0 , 1 } , { 2 , 5 } , { 2 , 3 } , { 1 , 4 } , { 0 , 5 } } ; int M = sizeof ( Q ) / sizeof ( Q [ 0 ] ) ; cout << toggleQuery ( str , Q , M ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxiConsecutiveSubarray ( int arr [ ] , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = max ( maxi , cnt ) ; i = j ; } return maxi ; } int main ( ) { int N = 11 ; int arr [ ] = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; cout << maxiConsecutiveSubarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countRemovableElem ( int arr [ ] , int N ) { int hash [ N + 1 ] = { 0 } ; int mex = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= N ) hash [ arr [ i ] ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] == 0 ) { mex = i ; break ; } } cout << N - ( mex - 1 ) ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 1 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countRemovableElem ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printIndexes ( string str ) { int N = str . length ( ) ; int cntFreq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ str [ i ] ] ++ ; } int cntLeftFreq [ 256 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { int cntLeft = 0 ; int cntRight = 0 ; for ( int j = str [ i ] - 1 ; j >= 0 ; j -- ) { cntLeft += cntLeftFreq [ j ] ; cntRight += cntFreq [ j ] - cntLeftFreq [ j ] ; } cntLeftFreq [ str [ i ] ] ++ ; if ( cntLeft == cntRight && cntLeft != 0 ) { cout << i << " ▁ " ; } } } int main ( ) { string str = " aabacdabbb " ; printIndexes ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkConcat ( string str1 , string str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N % M != 0 ) { return false ; } for ( int i = 0 ; i < N ; i ++ ) { if ( str1 [ i ] != str2 [ i % M ] ) { return false ; } } return true ; } int main ( ) { string str1 = " abcabcabc " ; string str2 = " abc " ; if ( checkConcat ( str1 , str2 ) ) { cout << " Yes " ; } else { cout << " No " ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPosition ( vector < vector < int > > mat ) { int n = mat . size ( ) ; int m = mat [ 0 ] . size ( ) ; vector < int > row ( n ) ; vector < int > col ( m ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { col [ j ] ++ ; row [ i ] ++ ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( row [ i ] == col [ j ] ) { count ++ ; } } } return count ; } int main ( ) { vector < vector < int > > mat = { { 0 , 1 } , { 1 , 1 } } ; cout << ( countPosition ( mat ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void position ( int arr [ ] [ 2 ] , int N ) { int pos = -1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == -1 ) { cout << pos ; } else { cout << pos + 1 ; } } int main ( ) { int arr [ ] [ 2 ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; position ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mini = 105 , ans , n ; vector < vector < int > > g ( 100 ) ; int size [ 100 ] ; void create_graph ( ) { g [ 1 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 3 ) ; g [ 3 ] . push_back ( 1 ) ; g [ 1 ] . push_back ( 4 ) ; g [ 4 ] . push_back ( 1 ) ; g [ 2 ] . push_back ( 5 ) ; g [ 5 ] . push_back ( 2 ) ; g [ 2 ] . push_back ( 6 ) ; g [ 6 ] . push_back ( 2 ) ; } void dfs ( int node , int parent ) { size [ node ] = 1 ; int mx = 0 ; for ( int y : g [ node ] ) { if ( y == parent ) continue ; dfs ( y , node ) ; size [ node ] += size [ y ] ; mx = max ( mx , size [ y ] ) ; } mx = max ( mx , n - size [ node ] ) ; if ( mx < mini ) { mini = mx ; ans = node ; } } int main ( ) { n = 6 ; create_graph ( ) ; dfs ( 1 , -1 ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isPossible ( int arr [ ] , int N ) { int mn = INT_MAX ; int B [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { mn = min ( mn , arr [ i ] ) ; B [ i ] = arr [ i ] ; } sort ( arr , arr + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != B [ i ] ) { if ( B [ i ] % mn != 0 ) { cout << " No " ; return ; } } } cout << " Yes " ; return ; } int main ( ) { int N = 6 ; int arr [ ] = { 4 , 3 , 6 , 6 , 2 , 9 } ; isPossible ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkArrInStack ( stack < int > s , int arr [ ] , int n ) { map < int , int > freq ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; while ( ! s . empty ( ) ) { int poppedEle = s . top ( ) ; s . pop ( ) ; if ( freq [ poppedEle ] ) freq [ poppedEle ] -= 1 ; } if ( freq . size ( ) == 0 ) return 0 ; return 1 ; } int main ( ) { stack < int > s ; s . push ( 10 ) ; s . push ( 20 ) ; s . push ( 30 ) ; s . push ( 40 ) ; s . push ( 50 ) ; int arr [ ] = { 20 , 30 } ; int n = sizeof arr / sizeof arr [ 0 ] ; if ( checkArrInStack ( s , arr , n ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string palindromePrefix ( string S ) { int n = S . size ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { string curr = S . substr ( 0 , i + 1 ) ; int l = 0 , r = curr . size ( ) - 1 ; bool is_palindrome = 1 ; while ( l < r ) { if ( curr [ l ] != curr [ r ] ) { is_palindrome = 0 ; break ; } l ++ ; r -- ; } if ( is_palindrome ) return curr ; } return " " ; } string maxPalindrome ( string S ) { int n = S . size ( ) ; if ( n <= 1 ) { return S ; } string pre = " " , suff = " " ; int i = 0 , j = n - 1 ; while ( S [ i ] == S [ j ] && i < j ) { i ++ ; j -- ; } i -- ; j ++ ; pre = S . substr ( 0 , i + 1 ) ; suff = S . substr ( j ) ; if ( j - i == 1 ) { return pre + suff ; } if ( j - i == 2 ) { string mid_char = S . substr ( i + 1 , 1 ) ; return pre + mid_char + suff ; } string rem_str = S . substr ( i + 1 , j - i - 1 ) ; string pre_of_rem_str = palindromePrefix ( rem_str ) ; reverse ( rem_str . begin ( ) , rem_str . end ( ) ) ; string suff_of_rem_str = palindromePrefix ( rem_str ) ; if ( pre_of_rem_str . size ( ) >= suff_of_rem_str . size ( ) ) { return pre + pre_of_rem_str + suff ; } else { return pre + suff_of_rem_str + suff ; } } int main ( ) { string S = " geeksforskeeg " ; cout << maxPalindrome ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( string s ) { int sum = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . size ( ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { sum += ( j - i ) ; } } } return sum ; } int main ( ) { string s = " ttt " ; cout << findSum ( s ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int min_flips ( string & str , int k ) { if ( str . size ( ) == 0 ) return 0 ; int ans = 0 ; int cnt_zeros = 0 ; for ( char ch : str ) { if ( ch == '0' ) { ++ cnt_zeros ; } else { cnt_zeros = 0 ; } if ( cnt_zeros == k ) { ++ ans ; cnt_zeros = 0 ; } } return ans ; } int main ( ) { string str = "11100000011" ; int k = 3 ; cout << min_flips ( str , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void count ( int N ) { if ( N == 1 ) { cout << ( 10 ) << endl ; return ; } int dp [ N ] [ 10 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; for ( int i = 1 ; i < 10 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) temp += dp [ i - 1 ] [ j ] ; for ( int j = 0 ; j < 10 ; j ++ ) dp [ i ] [ j ] = temp - dp [ i - 1 ] [ j ] ; } int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) ans += dp [ N - 1 ] [ i ] ; cout << ans << endl ; } int main ( ) { int N = 2 ; count ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ctr = 0 ; int find ( vector < int > & parent , int x ) { if ( parent [ x ] == x ) return x ; parent [ x ] = find ( parent , parent [ x ] ) ; return parent [ x ] ; } void setUnion ( vector < int > & parent , vector < int > & rank , int x , int y ) { int parentx = find ( parent , x ) ; int parenty = find ( parent , y ) ; if ( parenty == parentx ) return ; ctr -- ; if ( rank [ parentx ] < rank [ parenty ] ) { parent [ parentx ] = parenty ; } else if ( rank [ parentx ] > rank [ parenty ] ) { parent [ parenty ] = parentx ; } else { parent [ parentx ] = parenty ; rank [ parenty ] ++ ; } } vector < int > solve ( int n , int m , vector < pair < int , int > > & query ) { vector < int > result ( query . size ( ) ) ; vector < int > parent ( n * m ) ; for ( int i = 0 ; i < n * m ; i ++ ) parent [ i ] = i ; vector < int > rank ( n * m , 1 ) ; vector < bool > grid ( n * m , 0 ) ; for ( int i = 0 ; i < query . size ( ) ; i ++ ) { int x = query [ i ] . first ; int y = query [ i ] . second ; if ( grid [ m * x + y ] == 1 ) { result [ i ] = ctr ; continue ; } grid [ m * x + y ] = 1 ; ctr ++ ; if ( x > 0 and grid [ m * ( x - 1 ) + y ] == 1 ) setUnion ( parent , rank , m * x + y , m * ( x - 1 ) + y ) ; if ( y > 0 and grid [ m * ( x ) + y - 1 ] == 1 ) setUnion ( parent , rank , m * x + y , m * ( x ) + y - 1 ) ; if ( x < n - 1 and grid [ m * ( x + 1 ) + y ] == 1 ) setUnion ( parent , rank , m * x + y , m * ( x + 1 ) + y ) ; if ( y < m - 1 and grid [ m * ( x ) + y + 1 ] == 1 ) setUnion ( parent , rank , m * x + y , m * ( x ) + y + 1 ) ; result [ i ] = ctr ; } return result ; } int main ( ) { int N = 3 , M = 3 , K = 4 ; vector < pair < int , int > > query = { { 0 , 0 } , { 1 , 1 } , { 1 , 0 } , { 1 , 2 } } ; vector < int > result = solve ( N , M , query ) ; for ( int i = 0 ; i < K ; i ++ ) cout << result [ i ] << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int cnt = 0 ; void dfs ( int * val , int * cost , vector < vector < int > > & tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . size ( ) ; i ++ ) { dfs ( val , cost , tr , tr [ u ] [ i ] , s ) ; } } int main ( ) { int n = 9 ; int val [ ] = { 88 , 22 , 83 , 14 , 95 , 91 , 98 , 53 , 11 } ; int cost [ ] = { -1 , 24 , -8 , 67 , 64 , 65 , 12 , -80 , 8 } ; vector < vector < int > > tr ( n + 1 ) ; tr [ 0 ] . push_back ( 3 ) ; tr [ 0 ] . push_back ( 4 ) ; tr [ 4 ] . push_back ( 6 ) ; tr [ 6 ] . push_back ( 2 ) ; tr [ 2 ] . push_back ( 1 ) ; tr [ 2 ] . push_back ( 8 ) ; tr [ 8 ] . push_back ( 5 ) ; tr [ 5 ] . push_back ( 7 ) ; dfs ( val , cost , tr , 0 , 0 ) ; cout << n - cnt ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > findLargest ( int beg , int end , vector < int > arr , int n ) { if ( beg == end ) { vector < int > compared ( n , 0 ) ; compared [ 0 ] = 1 ; compared [ 1 ] = arr [ beg ] ; return compared ; } vector < int > compared1 = findLargest ( beg , ( beg + end ) / 2 , arr , n ) ; vector < int > compared2 = findLargest ( ( beg + end ) / 2 + 1 , end , arr , n ) ; if ( compared1 [ 1 ] > compared2 [ 1 ] ) { int k = compared1 [ 0 ] + 1 ; compared1 [ 0 ] = k ; compared1 [ k ] = compared2 [ 1 ] ; return compared1 ; } else { int k = compared2 [ 0 ] + 1 ; compared2 [ 0 ] = k ; compared2 [ k ] = compared1 [ 1 ] ; return compared2 ; } } void findSecondLargest ( int end , vector < int > arr ) { vector < int > compared1 = findLargest ( 0 , end - 1 , arr , end ) ; vector < int > compared2 = findLargest ( 2 , compared1 [ 0 ] + 2 , compared1 , compared1 [ 0 ] ) ; cout << compared2 [ 1 ] ; } int main ( ) { int N = 10 ; vector < int > arr { 20 , 1990 , 12 , 1110 , 1 , 59 , 12 , 15 , 120 , 1110 } ; findSecondLargest ( N , arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountsubString ( char str [ ] , int n ) { int c = 0 ; for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; char temp = str [ i ] , f = 0 ; if ( j == i ) { c ++ ; continue ; } int k = i + 1 ; while ( temp > str [ k ] && k <= j ) { temp = str [ k ] ; k ++ ; } if ( k > j ) { c ++ ; f = 2 ; } while ( temp < str [ k ] && k <= j && f != 2 ) { temp = str [ k ] ; k ++ ; } if ( k > j && f != 2 ) { c ++ ; f = 0 ; } } } return c ; } int main ( ) { char str [ ] = " bade " ; cout << CountsubString ( str , strlen ( str ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > generateSequence ( int * freq , int n ) { map < int , int > m ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { m [ i ] = freq [ i ] ; total += freq [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( m [ i ] ) { vector < int > sequence ; auto mcopy = m ; mcopy [ i ] -- ; sequence . push_back ( i ) ; int last = i ; for ( int i = 0 ; i < total - 1 ; i ++ ) { if ( mcopy [ last - 1 ] ) { mcopy [ last - 1 ] -- ; sequence . push_back ( last - 1 ) ; last -- ; } else if ( mcopy [ last + 1 ] ) { mcopy [ last + 1 ] -- ; sequence . push_back ( last + 1 ) ; last ++ ; } else break ; } if ( sequence . size ( ) == total ) { return sequence ; } } } vector < int > empty ; return empty ; } void PrintSequence ( int freq [ ] , int n ) { vector < int > sequence = generateSequence ( freq , n ) ; if ( sequence . size ( ) == 0 ) { cout << " - 1" ; } else { for ( int i = 0 ; i < sequence . size ( ) ; i ++ ) { cout << sequence [ i ] << " ▁ " ; } } } int main ( ) { int freq [ ] = { 2 , 2 , 2 , 3 , 1 } ; int N = 5 ; PrintSequence ( freq , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void medianChange ( vector < int > & arr1 , vector < int > & arr2 ) { int N = arr1 . size ( ) ; vector < float > median ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } for ( auto & x : arr2 ) { auto it = find ( arr1 . begin ( ) , arr1 . end ( ) , x ) ; arr1 . erase ( it ) ; N -- ; if ( N & 1 ) { median . push_back ( arr1 [ N / 2 ] * 1.0 ) ; } else { median . push_back ( ( arr1 [ N / 2 ] + arr1 [ ( N - 1 ) / 2 ] ) / 2.0 ) ; } } for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { cout << median [ i + 1 ] - median [ i ] << ' ▁ ' ; } } int main ( ) { vector < int > arr1 = { 2 , 4 , 6 , 8 , 10 } ; vector < int > arr2 = { 4 , 6 } ; medianChange ( arr1 , arr2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countFac ( int n ) { int m = n ; int count = 0 ; for ( int i = 2 ; ( i * i ) <= m ; ++ i ) { int total = 0 ; while ( n % i == 0 ) { n /= i ; ++ total ; } int temp = 0 ; for ( int j = 1 ; ( temp + j ) <= total ; ++ j ) { temp += j ; ++ count ; } } if ( n != 1 ) ++ count ; return count ; } int main ( ) { int N = 24 ; cout << countFac ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMissing ( int arr [ ] , int left , int right , int diff ) { if ( right <= left ) return INT_MAX ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; } int missingElement ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissing ( arr , 0 , n - 1 , diff ) ; } int main ( ) { int arr [ ] = { 2 , 8 , 6 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << missingElement ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int naive_find_x ( int N ) { int c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; } int main ( ) { int N = 100 ; cout << naive_find_x ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorOfSum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; } int main ( ) { int n = 3 ; int A [ n ] = { 1 , 2 , 3 } ; cout << xorOfSum ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } void fibonacci ( int arr [ ] , int n ) { int max_val = * max_element ( arr , arr + n ) ; set < int > hash ; createHash ( hash , max_val ) ; int minimum = INT_MAX ; int maximum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . find ( arr [ i ] ) != hash . end ( ) ) { minimum = min ( minimum , arr [ i ] ) ; maximum = max ( maximum , arr [ i ] ) ; } } cout << minimum << " , ▁ " << maximum << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; fibonacci ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool permutation ( int arr [ ] , int n ) { set < int > hash ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . insert ( arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; } int main ( ) { int arr [ ] = { 1 , 2 , 5 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; if ( permutation ( arr , n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int m , int n , int arr [ ] ) { int desired [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = m ; m -- ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > desired [ i ] desired [ i ] < 1 ) { return false ; } } return true ; } int minOperations ( int arr [ ] , int n ) { int start = ( int ) arr [ n - 1 ] ; int end = * ( max_element ( arr , arr + n ) ) + n ; int max_arr = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , n , arr ) ) { max_arr = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } int desired [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = max_arr ; max_arr -- ; } int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { operations += ( desired [ i ] - arr [ i ] ) ; } return operations ; } int main ( ) { int arr [ ] = { 4 , 4 , 5 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int costToPanagram ( string str , int cost [ ] ) { int i , n = str . length ( ) ; int occurrences [ 26 ] = { 0 } ; for ( i = 0 ; i < n ; i ++ ) occurrences [ str [ i ] - ' a ' ] ++ ; int gain = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( occurrences [ i ] == 0 ) gain -= ( 2 * cost [ i ] ) ; else if ( occurrences [ i ] > 1 ) gain += ( cost [ i ] * ( occurrences [ i ] - 1 ) ) ; } if ( gain >= 0 ) return 0 ; return ( gain * -1 ) ; } int main ( ) { int cost [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; string str = " geeksforgeeks " ; cout << costToPanagram ( str , cost ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int strScore ( string str [ ] , string s , int n ) { unordered_map < string , int > m ; for ( int i = 0 ; i < n ; i ++ ) m [ str [ i ] ] = i + 1 ; if ( m . find ( s ) == m . end ( ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) score += s [ i ] - ' a ' + 1 ; score = score * m [ s ] ; return score ; } int main ( ) { string str [ ] = { " geeksforgeeks " , " algorithms " , " stack " } ; string s = " algorithms " ; int n = sizeof ( str ) / sizeof ( str [ 0 ] ) ; int score = strScore ( str , s , n ) ; cout << score ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string replacePi ( string input ) { string output ; int size = input . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { if ( i + 1 < size and input [ i ] == ' p ' and input [ i + 1 ] == ' i ' ) { output += "3.14" ; i ++ ; } else { output += input [ i ] ; } } return output ; } int main ( ) { string input = "2 ▁ * ▁ pi ▁ + ▁ 3 ▁ * ▁ pi ▁ = ▁ 5 ▁ * ▁ pi " ; cout << replacePi ( input ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfElements ( int height [ ] , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; } int main ( ) { int n = 6 ; int height [ ] = { 4 , 8 , 2 , 0 , 0 , 5 } ; cout << numberOfElements ( height , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int getMin ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = min ( res , arr [ i ] ) ; return res ; } int getMax ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = max ( res , arr [ i ] ) ; return res ; } int findSum ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min + max ; } int findProduct ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min * max ; } int main ( ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ = ▁ " << findSum ( arr , n ) << endl ; cout << " Product ▁ = ▁ " << findProduct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string sortString ( string str , int n ) { string new_str = " " ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( str [ j ] == i ) new_str += str [ j ] ; return new_str ; } int main ( ) { string str = " geeksforgeeks " ; int n = str . size ( ) ; cout << sortString ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void occurrenceDays ( int n , string firstday ) { string days [ ] = { " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " } ; int count [ 7 ] ; for ( int i = 0 ; i < 7 ; i ++ ) count [ i ] = 4 ; int pos ; for ( int i = 0 ; i < 7 ; i ++ ) { if ( firstday == days [ i ] ) { pos = i ; break ; } } int inc = n - 28 ; for ( int i = pos ; i < pos + inc ; i ++ ) { if ( i > 6 ) count [ i % 7 ] = 5 ; else count [ i ] = 5 ; } for ( int i = 0 ; i < 7 ; i ++ ) { cout << days [ i ] << " ▁ " << count [ i ] << endl ; } } int main ( ) { int n = 31 ; string firstday = " Tuesday " ; occurrenceDays ( n , firstday ) ; return 0 ; }
#include <iostream> NEW_LINE #include <ctime> NEW_LINE using namespace std ; int getRandom ( int x , int y ) { srand ( time ( NULL ) ) ; return ( x + rand ( ) % ( y - x + 1 ) ) ; } int randomizedBinarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = getRandom ( l , r ) ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return -1 ; } int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = randomizedBinarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) : printf ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " , result ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSorted ( pair < int , int > * arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] . first > arr [ i - 1 ] . first ) { return false ; } } return true ; } string isPossibleToSort ( pair < int , int > * arr , int N ) { int group = arr [ 0 ] . second ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] . second != group ) { return " Yes " ; } } if ( isSorted ( arr , N ) ) { return " Yes " ; } else { return " No " ; } } int main ( ) { pair < int , int > arr [ ] = { { 340000 , 2 } , { 45000 , 1 } , { 30000 , 2 } , { 50000 , 4 } } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << isPossibleToSort ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxLenSubset ( int a [ ] , int n ) { sort ( a , a + n ) ; int index = 0 , maxlen = -1 ; int i = 0 ; while ( i < n ) { int j = i ; int len = 1 ; while ( j < n - 1 ) { if ( 2 * a [ j ] >= a [ j + 1 ] ) { len ++ ; } else break ; j ++ ; } if ( maxlen < len ) { maxlen = len ; index = i ; } j ++ ; i = j ; } i = index ; while ( maxlen > 0 ) { cout << a [ i ] << " ▁ " ; maxlen -- ; i ++ ; } } int main ( ) { int a [ ] = { 3 , 1 , 5 , 11 } ; int n = sizeof ( a ) / sizeof ( int ) ; maxLenSubset ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSum ( int arr [ ] , int N ) { int sum ; sort ( arr , arr + N ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; cout << sum ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maximumSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minOperation ( int a [ ] , int N ) { int totOps = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { totOps += abs ( a [ i ] - a [ i + 1 ] ) ; } int maxOps = max ( abs ( a [ 0 ] - a [ 1 ] ) , abs ( a [ N - 1 ] - a [ N - 2 ] ) ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { maxOps = max ( maxOps , abs ( a [ i ] - a [ i - 1 ] ) + abs ( a [ i ] - a [ i + 1 ] ) - abs ( a [ i - 1 ] - a [ i + 1 ] ) ) ; } cout << totOps - maxOps << endl ; } int main ( ) { int arr [ ] = { 1 , -1 , 0 , 1 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minOperation ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void numOperation ( int arr [ ] , int N , int D ) { sort ( arr , arr + N ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ( arr [ i + 1 ] - arr [ i ] ) % D != 0 ) { cout << " - 1" ; return ; } } int count = 0 ; int mid = arr [ N / 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { count += abs ( mid - arr [ i ] ) / D ; } cout << count ; } int main ( ) { int N = 4 , D = 2 ; int arr [ ] = { 2 , 4 , 6 , 8 } ; numOperation ( arr , N , D ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSum ( int A [ ] , int N , int K ) { sort ( A , A + N ) ; int sum = 0 ; for ( int i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } cout << sum ; } int main ( ) { int K = 4 ; int A [ ] = { 2 , 3 , 1 , 4 , 7 , 5 , 6 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; findSum ( A , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( int l = 0 ; i <= m ; i ++ ) { bool found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( int i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; } int mergeSortUtil ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; } int mergeSort ( int arr [ ] , int N , int K ) { int temp [ N ] ; cout << mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ; } int main ( ) { int arr [ ] = { 5 , 6 , 2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; mergeSort ( arr , N , K ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void Bubble_Sort ( int arr [ ] , int n ) { bool flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { swap ( arr [ j ] , arr [ j + 1 ] ) ; flag = true ; } } if ( flag == false ) break ; } } int main ( ) { int n = 5 ; int arr [ 5 ] = { 2 , 0 , 1 , 4 , 3 } ; Bubble_Sort ( arr , n ) ; cout << " The ▁ Sorted ▁ Array ▁ by ▁ using ▁ Bubble ▁ Sort ▁ is ▁ : ▁ " ; for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minRemovals ( int A [ ] , int N ) { sort ( A , A + N ) ; int mx = A [ N - 1 ] ; int sum = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { cout << 0 << " STRNEWLINE " ; } else { cout << 2 * mx - sum << " STRNEWLINE " ; } } int main ( ) { int A [ ] = { 3 , 3 , 2 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minRemovals ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxRectangle ( vector < vector < int > > sequence , int size ) { long long int X_Cord [ size ] , Y_Cord [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { X_Cord [ i ] = sequence [ i ] [ 0 ] ; Y_Cord [ i ] = sequence [ i ] [ 1 ] ; } sort ( X_Cord , X_Cord + size ) ; sort ( Y_Cord , Y_Cord + size ) ; long long int X_Max = 0 , Y_Max = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { X_Max = max ( X_Max , X_Cord [ i + 1 ] - X_Cord [ i ] ) ; Y_Max = max ( Y_Max , Y_Cord [ i + 1 ] - Y_Cord [ i ] ) ; } return X_Max * Y_Max ; } int main ( ) { vector < vector < int > > point = { { -2 , 0 } , { 2 , 0 } , { 4 , 0 } , { 4 , 2 } } ; int n = point . size ( ) ; cout << maxRectangle ( point , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkArrangement ( int A1 [ ] , int A2 [ ] , int n , int k ) { sort ( A1 , A1 + n ) ; sort ( A2 , A2 + n , greater < int > ( ) ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) cout << " No " ; else cout << " Yes " ; } int main ( ) { int arr1 [ ] = { 1 , 3 , 4 , 5 } ; int arr2 [ ] = { 2 , 0 , 1 , 1 } ; int K = 6 ; int N = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; checkArrangement ( arr1 , arr2 , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortarray ( int arr [ ] , int N ) { if ( N == 3 ) cout << " NO " << endl ; else if ( N % 4 == 0 N % 4 == 1 ) { cout << " YES " << endl ; cout << ( N / 2 ) << endl ; int k = 1 ; for ( int l = 0 ; l < ( N / 4 ) ; l ++ ) { cout << k << " ▁ " << k + 1 << " ▁ " << N << endl ; cout << k + 1 << " ▁ " << N << " ▁ " << N - 1 << endl ; k = k + 2 ; N = N - 2 ; } } else cout << " NO " << endl ; } int main ( ) { int N = 5 ; int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; sortarray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSum ( int arr [ ] , int K , int L , int size ) { if ( K * L > size ) return -1 ; int minsum = 0 ; sort ( arr , arr + size ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; } int main ( ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSum ( arr , K , L , length ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findKthSmallest ( int arr [ ] , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int counter [ max + 1 ] = { 0 } ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } } int main ( ) { int arr [ ] = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 5 ; cout << findKthSmallest ( arr , N , K ) ; return 0 ; }
#include <stdio.h> NEW_LINE #define N  4 NEW_LINE void func ( int a [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] > a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } else { for ( int j = 0 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] < a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { printf ( " % d ▁ " , a [ i ] [ j ] ) ; } printf ( " STRNEWLINE " ) ; } } int main ( ) { int a [ N ] [ N ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; map < int , int > g [ 200005 ] ; set < int > s , ns ; void dfs ( int x ) { vector < int > v ; v . clear ( ) ; ns . clear ( ) ; for ( int it : s ) { if ( ! g [ x ] [ it ] ) { v . push_back ( it ) ; } else { ns . insert ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } } void weightOfMST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . insert ( i ) ; } for ( ; s . size ( ) ; ) { ++ cnt ; int t = * s . begin ( ) ; s . erase ( t ) ; dfs ( t ) ; } cout << cnt - 1 ; } int main ( ) { int N = 6 , M = 11 ; int edges [ ] [ ] = { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , { 1 , 6 } , { 2 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 4 } , { 3 , 5 } , { 3 , 6 } } ; for ( int i = 0 ; i < M ; ++ i ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; g [ u ] [ v ] = 1 ; g [ v ] [ u ] = 1 ; } weightOfMST ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sortDiff ( vector < int > arr , int n ) { sort ( arr . begin ( ) , arr . end ( ) ) ; vector < int > out ; while ( n > 0 ) { out . push_back ( arr [ n / 2 ] ) ; arr . erase ( arr . begin ( ) + n / 2 ) ; n = n - 1 ; } for ( auto i : out ) cout << i << " ▁ " ; } int main ( ) { vector < int > a = { 8 , 1 , 2 , 3 , 0 } ; int n = 5 ; sortDiff ( a , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( vector < int > A , vector < int > B ) { int n = A . size ( ) ; sort ( A . begin ( ) , A . end ( ) ) ; sort ( B . begin ( ) , B . end ( ) ) ; int ans = 0 , i ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } int main ( ) { vector < int > A = { 30 , 28 , 45 , 22 } ; vector < int > B = { 35 , 25 , 22 , 48 } ; cout << countPairs ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } void sortArr ( int arr [ ] , int n ) { vector < pair < int , int > > vp ; for ( int i = 0 ; i < n ; i ++ ) { vp . push_back ( make_pair ( reversDigits ( arr [ i ] ) , arr [ i ] ) ) ; } sort ( vp . begin ( ) , vp . end ( ) ) ; for ( int i = 0 ; i < vp . size ( ) ; i ++ ) cout << vp [ i ] . second << " ▁ " ; } int main ( ) { int arr [ ] = { 12 , 10 , 102 , 31 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > orgazineInOrder ( vector < int > vec , vector < int > op , int n ) { vector < int > result ( n ) ; sort ( vec . begin ( ) , vec . end ( ) ) ; int i = 0 , j = n - 1 , k = 0 ; while ( i <= j && k <= n - 2 ) { if ( op [ k ] == ' < ' ) { result [ k ] = vec [ i ++ ] ; } else { result [ k ] = vec [ j -- ] ; } k ++ ; } result [ n - 1 ] = vec [ i ] ; return result ; } int main ( ) { vector < int > vec ( { 8 , 2 , 7 , 1 , 5 , 9 } ) ; vector < int > op ( { ' > ' , ' > ' , ' < ' , ' > ' , ' < ' } ) ; vector < int > result = orgazineInOrder ( vec , op , vec . size ( ) ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { cout << result [ i ] << " ▁ " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ; bool lineExists ( int x [ ] , int y [ ] , int v [ ] , int n ) { int size = ( 2 * MAX ) + 1 ; long arr [ size ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { arr [ x [ i ] + MAX ] += v [ i ] ; } for ( int i = 1 ; i < size ; i ++ ) arr [ i ] += arr [ i - 1 ] ; if ( arr [ size - 1 ] == 0 ) return true ; if ( arr [ size - 1 ] - arr [ 0 ] == 0 ) return true ; for ( int i = 1 ; i < size - 1 ; i ++ ) { if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i - 1 ] ) return true ; if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i ] ) return true ; if ( arr [ i ] == arr [ size - 1 ] - arr [ i ] ) return true ; } if ( arr [ size - 2 ] == 0 ) return true ; return false ; } int main ( ) { int x [ ] = { -3 , 5 , 8 } ; int y [ ] = { 8 , 7 , 9 } ; int v [ ] = { 8 , 2 , 10 } ; int n = sizeof ( x ) / sizeof ( int ) ; if ( lineExists ( x , y , v , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int a [ ] , int n ) { sort ( a , a + n ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 1 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( vector < int > ar , int k ) { sort ( ar . begin ( ) , ar . end ( ) ) ; int opsNeeded = 0 ; for ( int i = 0 ; i < k ; i ++ ) { opsNeeded += ar [ k - 1 ] - ar [ i ] ; } int ans = opsNeeded ; for ( int i = k ; i < ar . size ( ) ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = min ( ans , opsNeeded ) ; } return ans ; } int main ( ) { vector < int > arr = { 3 , 1 , 9 , 100 } ; int n = arr . size ( ) ; int k = 3 ; cout << minOperations ( arr , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float knapSack ( int W , float wt [ ] , float val [ ] , int n ) { float maxratio = INT_MIN ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; } int main ( ) { float val [ ] = { 14 , 27 , 44 , 19 } ; float wt [ ] = { 6 , 7 , 9 , 8 } ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; int W = 50 ; cout << knapSack ( W , wt , val , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * left ; Node * right ; Node ( int x ) { data = x ; left = right = NULL ; } } ; void inorder ( Node * root ) { if ( root != NULL ) { inorder ( root -> left ) ; cout << root -> data << " ▁ " ; inorder ( root -> right ) ; } } void merge ( Node * root1 , Node * root2 ) { if ( ! root1 && ! root2 ) return ; if ( ! root1 ) { inorder ( root2 ) ; return ; } if ( ! root2 ) { inorder ( root1 ) ; return ; } Node * temp1 = root1 ; Node * prev1 = NULL ; while ( temp1 -> left ) { prev1 = temp1 ; temp1 = temp1 -> left ; } Node * temp2 = root2 ; Node * prev2 = NULL ; while ( temp2 -> left ) { prev2 = temp2 ; temp2 = temp2 -> left ; } if ( temp1 -> data <= temp2 -> data ) { cout << temp1 -> data << " ▁ " ; if ( prev1 == NULL ) { merge ( root1 -> right , root2 ) ; } else { prev1 -> left = temp1 -> right ; merge ( root1 , root2 ) ; } } else { cout << temp2 -> data << " ▁ " ; if ( prev2 == NULL ) { merge ( root1 , root2 -> right ) ; } else { prev2 -> left = temp2 -> right ; merge ( root1 , root2 ) ; } } } int main ( ) { Node * root1 = NULL , * root2 = NULL ; root1 = new Node ( 3 ) ; root1 -> left = new Node ( 1 ) ; root1 -> right = new Node ( 5 ) ; root2 = new Node ( 4 ) ; root2 -> left = new Node ( 2 ) ; root2 -> right = new Node ( 6 ) ; merge ( root1 , root2 ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; long long mod = 1000000007 ; long long arr [ 1001 ] [ 1001 ] ; void Preprocess ( ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000 ; ++ i ) { arr [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) { arr [ i ] [ j ] = ( arr [ i - 1 ] [ j - 1 ] + arr [ i - 1 ] [ j ] ) % mod ; } arr [ i ] [ i ] = 1 ; } } long long powmod ( long long a , long long n ) { if ( ! n ) return 1 ; long long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 ) return ( pt * a ) % mod ; else return pt ; } long long CountSubset ( int * val , int n ) { long long ans = powmod ( 2 , n - 1 ) ; sort ( val , val + n ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && val [ j ] == val [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + arr [ l + r ] [ l ] ) % mod ; j ++ ; } } return ans ; } int main ( ) { Preprocess ( ) ; int val [ ] = { 2 , 3 , 2 } ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; cout << CountSubset ( val , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void reArrange ( string words [ ] , int n ) { map < string , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ words [ i ] ] = i + 1 ; sort ( words , words + n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << mp [ words [ i ] ] << " ▁ " ; } int main ( ) { string words [ ] = { " live " , " place " , " travel " , " word " , " sky " } ; int n = sizeof ( words ) / sizeof ( words [ 0 ] ) ; reArrange ( words , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimizeleftOverSum ( int a [ ] , int n ) { vector < int > v1 , v2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 ) v1 . push_back ( a [ i ] ) ; else v2 . push_back ( a [ i ] ) ; } if ( v1 . size ( ) > v2 . size ( ) ) { sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 [ i ++ ] ; } return sum ; } else if ( v2 . size ( ) > v1 . size ( ) ) { sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 [ i ++ ] ; } return sum ; } else return 0 ; } int main ( ) { int a [ ] = { 2 , 2 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinimizeleftOverSum ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printNumbers ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int A = arr [ n - 1 ] , B = -1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } cout << " A ▁ = ▁ " << A << " , ▁ B ▁ = ▁ " << B ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNumbers ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } void removeMin ( int arr [ ] , int n ) { int i , minVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minVal = min ( minVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; } void removeFromMax ( int arr [ ] , int n ) { int i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; } void modifyArray ( int arr [ ] , int n , int k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; } int main ( ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; modifyArray ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findProduct ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) prod = prod * arr [ i ] ; } return prod ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findProduct ( arr , n ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int main ( ) { int a [ ] = { 10 , 12 , 5 } ; sort ( a , a + 3 ) ; for ( int i = 0 ; i < 3 ; i ++ ) cout << a [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE void operations ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; ll i = 0 , sum = 0 ; while ( k -- ) { while ( i < n && arr [ i ] - sum == 0 ) i ++ ; if ( i < n && arr [ i ] - sum > 0 ) { cout << arr [ i ] - sum << " ▁ " ; sum = arr [ i ] ; } else cout << 0 << endl ; } } int main ( ) { int k = 5 ; int arr [ ] = { 3 , 6 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; operations ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSum ( int arr [ ] , int n ) { vector < int > evenArr ; vector < int > oddArr ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) oddArr . push_back ( arr [ i ] ) ; else evenArr . push_back ( arr [ i ] ) ; } sort ( evenArr . begin ( ) , evenArr . end ( ) , greater < int > ( ) ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr [ j ] ; arr [ i ++ ] = oddArr [ j ] ; sum += evenArr [ j ] * oddArr [ j ] ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ required ▁ sum ▁ = ▁ " << minSum ( arr , n ) ; cout << " Sorted array in required format : " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void bitonicGenerator ( int arr [ ] , int n ) { vector < int > evenArr ; vector < int > oddArr ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( i % 2 ) ) evenArr . push_back ( arr [ i ] ) ; else oddArr . push_back ( arr [ i ] ) ; } sort ( evenArr . begin ( ) , evenArr . end ( ) ) ; sort ( oddArr . begin ( ) , oddArr . end ( ) , greater < int > ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) arr [ i ++ ] = evenArr [ j ] ; for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) arr [ i ++ ] = oddArr [ j ] ; } int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; bitonicGenerator ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countBits ( int a ) { int count = 0 ; while ( a ) { if ( a & 1 ) count += 1 ; a = a >> 1 ; } return count ; } void sortBySetBitCount ( int arr [ ] , int n ) { vector < vector < int > > count ( 32 ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . push_back ( arr [ i ] ) ; } for ( int i = 31 ; i >= 0 ; i -- ) { vector < int > v1 = count [ i ] ; for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) arr [ j ++ ] = v1 [ i ] ; } } void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i & 1 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; } int main ( ) { int arr [ ] = { 6 , 8 , 4 , 5 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ is ▁ " << solve ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long KthSolution ( long long X , long long K ) { long long ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ! ( X & ( 1LL << i ) ) ) { if ( K & 1 ) { ans |= ( 1LL << i ) ; } K >>= 1 ; if ( ! K ) { break ; } } } return ans ; } int main ( ) { long long X = 5 , K = 5 ; cout << KthSolution ( X , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findAnagram ( string s ) { string check = s ; int i = 0 , j = s . length ( ) - 1 ; while ( i < s . length ( ) && j >= 0 ) { if ( s [ i ] != s [ j ] && check [ i ] != s [ j ] && check [ j ] != s [ i ] ) { swap ( s [ i ] , s [ j ] ) ; i ++ ; j = s . length ( ) - 1 ; } else { j -- ; } } if ( s . length ( ) % 2 != 0 ) { int mid = s . length ( ) / 2 ; if ( check [ mid ] == s [ mid ] ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( check [ i ] != s [ mid ] && s [ i ] != s [ mid ] ) { swap ( s [ i ] , s [ mid ] ) ; break ; } } } } bool ok = true ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( check [ i ] == s [ i ] ) { ok = false ; break ; } } if ( ok ) cout << s ; else cout << -1 ; } int main ( ) { string S = " geek " ; findAnagram ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minTime ( string word ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { int k = word [ i ] - ' a ' ; int a = abs ( curr - k ) ; int b = 26 - abs ( curr - k ) ; ans += min ( a , b ) ; ans ++ ; curr = word [ i ] - ' a ' ; } cout << ans ; } int main ( ) { string str = " zjpc " ; minTime ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumSumArray ( int arr [ ] , int N ) { vector < int > arrA ( N ) , ans ( N ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arrA [ i ] = arr [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { vector < int > arrB ( N ) ; int maximum = arrA [ i ] ; arrB [ i ] = maximum ; for ( int j = i - 1 ; j >= 0 ; j -- ) { arrB [ j ] = min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } maximum = arrA [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { arrB [ j ] = min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) sum += arrB [ j ] ; if ( sum > maxSum ) { maxSum = sum ; ans = arrB ; } } for ( int val : ans ) { cout << val << " ▁ " ; } } int main ( ) { int A [ ] = { 10 , 6 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; maximumSumArray ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestMerge ( string word1 , string word2 ) { string merge = " " ; while ( word1 . size ( ) != 0 || word2 . size ( ) != 0 ) { if ( word1 >= word2 ) { merge = merge + word1 [ 0 ] ; word1 . erase ( word1 . begin ( ) + 0 ) ; } else { merge = merge + word2 [ 0 ] ; word2 . erase ( word2 . begin ( ) + 0 ) ; } } return merge ; } int main ( ) { string S1 = " xyzxyz " ; string S2 = " xywzxyx " ; cout << largestMerge ( S1 , S2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumOfCombinationOf4OR5 ( vector < int > arr , int N ) { vector < int > ans ( N , -1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 4 ) { continue ; } int sum = INT_MAX , cnt = 0 ; for ( int j = 0 ; j <= arr [ i ] ; j += 4 ) { if ( ( arr [ i ] - j ) % 5 == 0 ) { sum = min ( sum , cnt + ( arr [ i ] - j ) / 5 ) ; } cnt ++ ; } if ( sum != INT_MAX ) ans [ i ] = sum ; } for ( auto num : ans ) cout << num << " ▁ " ; } int main ( ) { vector < int > arr = { 7 , 15 , 17 , 22 } ; int N = arr . size ( ) ; sumOfCombinationOf4OR5 ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string largestString ( string s , int k ) { for ( int i = 0 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] != ' z ' && k > 0 ) { s [ i ] = ' z ' ; k -- ; } } return s ; } int main ( ) { string s = " dbza " ; int k = 1 ; cout << largestString ( s , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void RemoveOneChar ( string A , string B , int N , int M ) { int X = 0 ; int Y = N - 1 ; for ( int i = 0 ; i < M ; i ++ ) { if ( A [ X ] != B [ i ] ) break ; X ++ ; } for ( int i = M - 1 ; i >= 0 ; i -- ) { if ( A [ Y ] != B [ i ] ) break ; Y -- ; } if ( N - M == 1 && Y < X ) { cout << X - Y + 1 << endl ; for ( int i = Y ; i <= X ; i ++ ) cout << i + 1 << " ▁ " ; cout << endl ; } else cout << -1 << endl ; } int main ( ) { string A = " abaac " ; string B = " abac " ; int N = A . length ( ) ; int M = B . length ( ) ; RemoveOneChar ( A , B , N , M ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countOfPairs ( int x , int y ) { int count = 0 ; for ( int k = 1 ; k * k <= x ; ++ k ) { count += max ( 0 , min ( y , x / k - 1 ) - k ) ; } cout << count << " STRNEWLINE " ; } int main ( ) { int x = 4 ; int y = 5 ; countOfPairs ( x , y ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void getDate ( int d , string m ) { int days [ ] = { 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; string month [ ] = { " January " , " February " , " March " , " April " , " May " , " June " , " July " , " August " , " September " , " October " , " November " , " December " } ; int cnt = 183 ; int cur_month ; for ( int i = 0 ; i < 12 ; i ++ ) if ( m == month [ i ] ) cur_month = i ; int cur_date = d ; while ( 1 ) { while ( cnt > 0 && cur_date <= days [ cur_month ] ) { cnt -= 1 ; cur_date += 1 ; } if ( cnt == 0 ) break ; cur_month = ( cur_month + 1 ) % 12 ; cur_date = 1 ; } cout << cur_date << " ▁ " << month [ cur_month ] << endl ; } int main ( ) { int D = 15 ; string M = " January " ; getDate ( D , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printLastElement ( int arr [ ] , int N ) { bool leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } cout << arr [ head - 1 ] ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printLastElement ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string freqCheck ( string S , int N ) { int hash [ 26 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { hash [ S [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hash [ i ] > 2 ) { return " Yes " ; } } return " No " ; } int main ( ) { string S = " geekseekforgeeks " ; int N = S . length ( ) ; cout << freqCheck ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minsteps ( vector < int > & A ) { int n = A . size ( ) ; vector < int > left ( n , 0 ) , right ( n , 0 ) , res ( n , 0 ) ; int count = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { left [ i ] = left [ i - 1 ] + count ; count += A [ i ] ; } count = A [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] + count ; count += A [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { res [ i ] = left [ i ] + right [ i ] ; cout << res [ i ] << " ▁ " ; } cout << " STRNEWLINE " ; } int main ( ) { vector < int > A = { 1 , 0 , 1 , 0 } ; minsteps ( A ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumOperations ( vector < int > & A , int K ) { vector < int > isflipped ( A . size ( ) , 0 ) ; int ans = 0 ; for ( int i = 0 ; i < A . size ( ) ; i ++ ) { if ( i > 0 ) { isflipped [ i ] += isflipped [ i - 1 ] ; isflipped [ i ] %= 2 ; } if ( A [ i ] == 0 && ! isflipped [ i ] ) { if ( ( A . size ( ) - i + 1 ) <= K ) { cout << -1 ; return ; } ans ++ ; isflipped [ i ] ++ ; isflipped [ i + K ] -- ; } else if ( A [ i ] == 1 && isflipped [ i ] ) { if ( ( A . size ( ) - i + 1 ) <= K ) { cout << -1 ; return ; } ans ++ ; isflipped [ i ] ++ ; isflipped [ i + K ] -- ; } } cout << ans ; } int main ( ) { vector < int > arr = { 0 , 1 , 0 } ; int K = 1 ; minimumOperations ( arr , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ConvertArray ( int arr [ ] , int N ) { if ( N == 1 ) { cout << " Operation ▁ 1 ▁ : ▁ " << 1 << " ▁ " << 1 << endl ; cout << " Added ▁ elements : ▁ " << -1 * arr [ 0 ] << endl ; cout << endl ; cout << " Operation ▁ 2 ▁ : ▁ " << 1 << " ▁ " << 1 << endl ; cout << " Added ▁ elements : ▁ " << 1 * arr [ 0 ] << endl ; cout << endl ; cout << " Operation ▁ 3 ▁ : ▁ " << 1 << " ▁ " << 1 << endl ; cout << " Added ▁ elements : ▁ " << -1 * arr [ 0 ] << endl ; } else { cout << " Operation ▁ 1 ▁ : ▁ " << 1 << " ▁ " << N << endl ; cout << " Added ▁ elements : ▁ " ; for ( int i = 0 ; i < N ; i ++ ) { cout << -1 * arr [ i ] * N << " ▁ " ; } cout << endl ; cout << endl ; cout << " Operation ▁ 2 ▁ : ▁ " << 1 << " ▁ " << N - 1 << endl ; cout << " Added ▁ elements : ▁ " ; for ( int i = 0 ; i < N - 1 ; i ++ ) { cout << arr [ i ] * ( N - 1 ) << " ▁ " ; } cout << endl ; cout << endl ; cout << " Operation ▁ 3 ▁ : ▁ " << N << " ▁ " << N << endl ; cout << " Added ▁ elements : ▁ " ; cout << arr [ N - 1 ] * ( N - 1 ) << endl ; } } int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ConvertArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE void countOfPrimefactors ( vector < int > & CountDistinct ) { bool prime [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( long long int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( long long int j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } } int CountEvenPair ( int A [ ] , int B [ ] , int N , int M ) { vector < int > countDistinct ( MAX + 1 ) ; countOfPrimefactors ( countDistinct ) ; int evenCount = 0 ; int oddCount = 0 ; int evenPairs = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( countDistinct [ B [ i ] ] == 0 ) continue ; if ( countDistinct [ B [ i ] ] & 1 ) { oddCount ++ ; } else { evenCount ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( countDistinct [ A [ i ] ] == 0 ) continue ; if ( countDistinct [ A [ i ] ] & 1 ) { evenPairs += ( evenCount ) ; } else { evenPairs += evenCount + oddCount ; } } return evenPairs ; } int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 4 , 5 , 6 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int M = sizeof ( B ) / sizeof ( B [ 0 ] ) ; cout << CountEvenPair ( A , B , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubarray ( int arr [ ] , int N , int K ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( sum == K ) maxLen = i + 1 ; if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - K ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - K ] ) ) maxLen = i - um [ sum - K ] ; } } return maxLen ; } void minRequiredOperation ( int arr [ ] , int N , int K ) { int TotalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) TotalSum += arr [ i ] ; int maxLen = longestSubarray ( arr , N , TotalSum - K ) ; if ( maxLen == -1 ) { cout << -1 ; } else cout << N - maxLen ; } int main ( ) { int arr [ ] = { 1 , 3 , 1 , 1 , 2 } ; int K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; minRequiredOperation ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countEvenOdd ( int L , int R ) { int range = R - L + 1 ; int even = ( range / 4 ) * 2 ; if ( ( L & 1 ) && ( range % 4 == 3 ) ) { even ++ ; } else if ( ! ( L & 1 ) && ( range % 4 ) ) { even ++ ; } cout << " Even ▁ = ▁ " << even << " , ▁ Odd ▁ = ▁ " << range - even ; } int main ( ) { int L = 2 , R = 7 ; countEvenOdd ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumCandy ( int candies [ ] , int safety [ ] , int N , int M ) { int total = 0 ; int ans = INT_MAX ; bool all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = min ( ans , safety [ i ] ) ; } else { ans = min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; } int main ( ) { int A [ ] = { 2 , 4 , 1 , 9 , 6 } ; int B [ ] = { 8 , 7 , 3 , 12 , 7 } ; int M = 0 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << maximumCandy ( A , B , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void construct_Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { cout << K * i << " ▁ " ; } } int main ( ) { int N = 3 , K = 3 ; construct_Array ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Print ( int N ) { if ( ( N / 2 ) % 2 == 1 || ( N % 2 == 1 ) ) { cout << -1 << endl ; return ; } int CurEven = 2 , CurOdd = 1 ; int SumOdd = 0 , SumEven = 0 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { cout << CurEven << " ▁ " ; SumEven += CurEven ; CurEven += 2 ; } for ( int i = 0 ; i < N / 2 - 1 ; i ++ ) { cout << CurOdd << " ▁ " ; SumOdd += CurOdd ; CurOdd += 2 ; } CurOdd = SumEven - SumOdd ; cout << CurOdd << ' ' ; } int main ( ) { int N = 12 ; Print ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinimumMoves ( int A [ ] , int B [ ] , int N ) { int totalOperations = 0 ; int carry = 0 ; int K = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int nearestMultiple = ceil ( ( double ) ( A [ i ] + carry ) / ( double ) ( B [ i ] ) ) * B [ i ] ; K = nearestMultiple - ( A [ i ] + carry ) ; totalOperations += K ; carry += K ; } return totalOperations ; } int main ( ) { int A [ ] = { 3 , 4 , 5 , 2 , 5 , 5 , 9 } ; int B [ ] = { 1 , 1 , 9 , 6 , 3 , 8 , 7 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << MinimumMoves ( A , B , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumDeviation ( int A [ ] , int N ) { set < int > s ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) s . insert ( A [ i ] ) ; else s . insert ( 2 * A [ i ] ) ; } int diff = * s . rbegin ( ) - * s . begin ( ) ; while ( ( int ) s . size ( ) && * s . rbegin ( ) % 2 == 0 ) { int maxEl = * s . rbegin ( ) ; s . erase ( maxEl ) ; s . insert ( maxEl / 2 ) ; diff = min ( diff , * s . rbegin ( ) - * s . begin ( ) ) ; } cout << diff ; } int main ( ) { int A [ ] = { 4 , 1 , 5 , 20 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; minimumDeviation ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void FindwinnerOfGame ( string & S ) { int cntZero = 0 ; int cntConOne = 0 ; int nimSum = 0 ; int N = S . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == '1' ) { cntConOne += 1 ; } else { nimSum ^= cntConOne ; cntConOne = 0 ; cntZero ++ ; } } nimSum ^= cntConOne ; if ( cntZero % 2 == 0 ) { cout << " Tie " ; } else if ( nimSum ) { cout << " player ▁ 1" ; } else { cout << " player ▁ 2" ; } } int main ( ) { string S = "0110011" ; FindwinnerOfGame ( S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minMoves ( vector < int > arr ) { int N = arr . size ( ) ; if ( N <= 2 ) return 0 ; int ans = INT_MAX ; for ( int i = -1 ; i <= 1 ; i ++ ) { for ( int j = -1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = abs ( i ) + abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag ) ans = min ( ans , moves ) ; } } if ( ans == INT_MAX ) return -1 ; return ans ; } int main ( ) { vector < int > arr = { 4 , 8 , 9 , 17 , 27 } ; cout << minMoves ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxksum ( int L , int R , int K ) { int N = ( R / 10 - L / 10 ) + 1 ; if ( K > N ) { cout << -1 ; return ; } R = R / 10 ; int X = R - K ; int sum = 10 * ( ( R * ( R + 1 ) ) / 2 - ( X * ( X + 1 ) ) / 2 ) ; cout << sum ; } int main ( ) { int L = 16 , R = 60 , K = 4 ; maxksum ( L , R , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLongestNonDecreasing ( int A [ ] , int N ) { int res = 0 ; int start = 0 ; int end = N - 1 ; int prev = -1 ; while ( start <= end ) { if ( A [ start ] <= A [ end ] ) { if ( prev == -1 ) { prev = A [ start ] ; res ++ ; start ++ ; } else { if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else { break ; } } } else { if ( prev == -1 ) { prev = A [ end ] ; res ++ ; end -- ; } else { if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else { break ; } } } } return res ; } int main ( ) { int A [ ] = { 1 , 1 , 3 , 5 , 4 , 3 , 6 , 2 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << findLongestNonDecreasing ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { cout << " ( " << i << " , ▁ " << N - i << " ) , ▁ " ; } } int main ( ) { int N = 5 ; findPairs ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOperation ( int arr [ ] , int N , int K ) { int cntOpe = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K > arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 2 ; } else { cntOpe += 1 ; } } else if ( K < arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 1 ; } else { cntOpe += 2 ; } } } return cntOpe ; } int main ( ) { int arr [ ] = { 8 , 7 , 2 , 1 , 3 } ; int K = 5 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinOperation ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int clstNum ( int N ) { return ( N - 1 ) ; } int main ( ) { int N = 11 ; cout << clstNum ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float pairProductMean ( int arr [ ] , int N ) { vector < int > pairArray ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . push_back ( pairProduct ) ; } } int length = pairArray . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray [ i ] ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pairProductMean ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minProd ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return max ( X - ( N - Y + 1 ) , 1 ) ; ; } int main ( ) { int X = 47 , Y = 42 , N = 167 ; cout << minProd ( X , Y , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void factorsOf3 ( int arr [ ] , int N ) { int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 3 == 0 ) a ++ ; else if ( arr [ i ] % 3 == 1 ) b ++ ; else if ( arr [ i ] % 3 == 2 ) c ++ ; } if ( a >= 1 && a <= b + c + 1 ) cout << " Yes " << endl ; else if ( a == 0 && b == 0 && c > 0 ) cout << " Yes " << endl ; else if ( a == 0 && c == 0 && b > 0 ) cout << " Yes " << endl ; else cout << " No " << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; factorsOf3 ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxBottles ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; } int main ( ) { int n = 9 , e = 3 ; int s = maxBottles ( n , e ) ; cout << s << endl ; }
#include <stdio.h> NEW_LINE #define ll  long long NEW_LINE ll power ( ll x , ll n ) { ll temp ; if ( n == 0 ) return 1 ; temp = power ( x , n / 2 ) ; if ( n % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } ll count_Total_Numbers ( ll n , ll x ) { ll total , multiples = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i % x == 0 ) multiples ++ ; } if ( n == 1 ) return multiples ; total = ( multiples - 1 ) * power ( multiples , n - 1 ) ; return total ; } int main ( ) { ll N = 1 , X = 3 ; printf ( " % lld ▁ " , count_Total_Numbers ( N , X ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minLength ( int A [ ] , int N ) { int elem = A [ 0 ] , count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; } int main ( ) { int arr [ ] = { 2 , 1 , 3 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minLength ( arr , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minSubarrays ( int arr [ ] , int n ) { int right = n - 1 ; int left = 0 ; int subarrays = 0 ; while ( right >= 0 ) { for ( left = 0 ; left <= right ; left += 1 ) { if ( __gcd ( arr [ left ] , arr [ right ] ) > 1 ) { subarrays += 1 ; right = left - 1 ; break ; } if ( left == right && __gcd ( arr [ left ] , arr [ right ] ) == 1 ) { return 0 ; } } } return subarrays ; } int main ( ) { int N = 6 ; int arr [ ] = { 2 , 3 , 4 , 4 , 4 , 3 } ; cout << minSubarrays ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissingElements ( int arr [ ] , int N ) { int diff = arr [ 0 ] - 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { cout << i + diff << " ▁ " ; diff ++ ; } } } } int main ( ) { int arr [ ] = { 6 , 7 , 10 , 11 , 13 } ; int N = sizeof ( arr ) / sizeof ( int ) ; printMissingElements ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMissingElements ( int arr [ ] , int N ) { int b [ arr [ N - 1 ] + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int i = arr [ 0 ] ; i <= arr [ N - 1 ] ; i ++ ) { if ( b [ i ] == 0 ) { cout << i << " ▁ " ; } } } int main ( ) { int arr [ ] = { 6 , 7 , 10 , 11 , 13 } ; int N = sizeof ( arr ) / sizeof ( int ) ; printMissingElements ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1e9 + 7 ; int power ( int x , int y ) { if ( y == 0 ) return 1 ; int p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( y & 1 ) p = ( x * p ) % mod ; return p ; } int NumberOfTrees ( int arr [ ] , int N ) { int maxElement = * max_element ( arr , arr + N ) ; int level [ maxElement + 1 ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < maxElement ; i ++ ) { ans = ( ans * power ( level [ i ] , level [ i + 1 ] ) ) % mod ; } return ans ; } int main ( ) { int N = 7 ; int arr [ ] = { 0 , 3 , 2 , 1 , 2 , 2 , 1 } ; cout << NumberOfTrees ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int carryCount ( int num1 , int num2 ) { int count = 0 ; while ( num2 != 0 ) { int carry = num1 & num2 ; num1 = num1 ^ num2 ; num2 = carry << 1 ; count += __builtin_popcount ( num2 ) ; } return count ; } int main ( ) { int A = 15 , B = 10 ; cout << carryCount ( 15 , 10 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int calculateProfit ( int n , int * earnings , int * cost , int e ) { int profit = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int earning_per_day = 0 ; int daily_spent_food = 0 ; if ( i == ( n - 1 ) ) { earning_per_day = earnings [ i ] * e ; profit = profit + earning_per_day ; break ; } if ( cost [ i ] < earnings [ i ] ) { earning_per_day = earnings [ i ] * e ; daily_spent_food = cost [ i ] * e ; profit = profit + earning_per_day - daily_spent_food ; } } cout << profit << endl ; } int main ( ) { int n = 4 ; int earnings [ ] = { 1 , 8 , 6 , 7 } ; int cost [ ] = { 1 , 3 , 4 , 1 } ; int e = 5 ; calculateProfit ( n , earnings , cost , e ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPair ( int A , int B , int N ) { int X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { cout << " - 1" ; } else { X = X / 2 ; Y = N - X ; cout << X << " ▁ " << Y ; } } int main ( ) { int A = 1 ; int B = 3 ; int N = 4 ; findPair ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int a [ ] , int n ) { int ma = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = max ( ma , abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } cout << " Amplitude ▁ = ▁ " << ma ; cout << endl ; return true ; } int main ( ) { int a [ ] = { 1 , 2 , 1 , 5 , 0 , 7 , -6 } ; int n = sizeof a / sizeof a [ 0 ] ; int wave = ( n - 1 ) / 2 ; if ( check ( a , n ) ) cout << " Waves ▁ = ▁ " << wave ; else cout << " - 1" ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string ConstructBinaryString ( int N , int M , int K ) { if ( M < ( N - 1 ) || M > K * ( N + 1 ) ) return " - 1" ; string ans = " " ; int l = min ( K , M / ( N - 1 ) ) ; int temp = N ; while ( temp -- ) { ans += '0' ; if ( temp == 0 ) break ; for ( int i = 0 ; i < l ; i ++ ) { ans += '1' ; } } M -= ( N - 1 ) * l ; if ( M == 0 ) return ans ; l = min ( M , K ) ; for ( int i = 0 ; i < l ; i ++ ) ans += '1' ; M -= l ; while ( M > 0 ) { ans = '1' + ans ; M -- ; } return ans ; } int main ( ) { int N = 5 , M = 9 , K = 2 ; cout << ConstructBinaryString ( N , M , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int noOfFactors ( int N ) { if ( N == 1 ) return 1 ; int count = 0 ; int ans = 1 ; while ( N % 2 == 0 ) { count ++ ; N = N / 2 ; } ans *= ( count / 2 + 1 ) ; for ( int i = 3 ; i * i <= N ; i = i + 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } ans *= ( count / 2 + 1 ) ; } return ans ; } int main ( ) { int N = 100 ; cout << noOfFactors ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print_path ( int N , int jump , int coin ) { if ( jump > coin || jump * ( N - 1 ) < coin ) { cout << " - 1" << endl ; } else { int pos = 1 ; while ( jump > 0 ) { int tmp = min ( N - 1 , coin - ( jump - 1 ) ) ; if ( pos + tmp <= N ) { pos += tmp ; } else { pos -= tmp ; } cout << pos << " ▁ " ; coin -= tmp ; jump -= 1 ; } } } int main ( ) { int N = 5 , K = 4 , M = 12 ; print_path ( N , K , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minChanges ( string str , int N ) { int res ; int count0 = 0 , count1 = 0 ; for ( char x : str ) { count0 += ( x == '0' ) ; } res = count0 ; for ( char x : str ) { count0 -= ( x == '0' ) ; count1 += ( x == '1' ) ; res = min ( res , count1 + count0 ) ; } return res ; } int main ( ) { int N = 9 ; string str = "000101001" ; cout << minChanges ( str , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count_triangles ( int a , int b , int c , int d ) { int ans = 0 ; for ( int x = a ; x <= b ; ++ x ) { int num_greater_than_d = max ( d , c + x ) - max ( d , b + x - 1 ) ; ans += num_greater_than_d * ( d - c + 1 ) ; int r = min ( max ( c , c + x ) , d ) - c ; int l = min ( max ( c , b + x - 1 ) , d ) - c ; int x1 = ( r * ( r + 1 ) ) / 2 ; int x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; } int main ( ) { int a = 2 , b = 3 , c = 4 , d = 5 ; cout << count_triangles ( a , b , c , d ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printKParts ( int N , int K ) { if ( N % K == 0 ) { for ( int i = 1 ; i < K ; i ++ ) cout << "1 , ▁ " ; cout << N - ( K - 1 ) << endl ; } else { if ( K == 2 ) { cout << " Not ▁ Possible " << endl ; return ; } for ( int i = 1 ; i < K - 1 ; i ++ ) cout << 1 << " , ▁ " ; cout << 2 << " , ▁ " << N - K << endl ; } } int main ( ) { int N = 18 , K = 5 ; printKParts ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = max ( max_sum , i + j ) ; } } return max_sum ; } int main ( ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; cout << max_sum << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getPairs ( vector < int > A , vector < int > B , int n ) { vector < int > D ( n ) ; for ( int i = 0 ; i < n ; i ++ ) { D [ i ] = A [ i ] - B [ i ] ; } sort ( D . begin ( ) , D . end ( ) ) ; long long total = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( D [ i ] > 0 ) { total += n - i - 1 ; } else { int k = upper_bound ( D . begin ( ) , D . end ( ) , - D [ i ] ) - D . begin ( ) ; total += n - k ; } } return total ; } int main ( ) { int n = 5 ; vector < int > A ; vector < int > B ; A . push_back ( 4 ) ; A . push_back ( 8 ) ; A . push_back ( 2 ) ; A . push_back ( 6 ) ; A . push_back ( 2 ) ; B . push_back ( 4 ) ; B . push_back ( 5 ) ; B . push_back ( 4 ) ; B . push_back ( 1 ) ; B . push_back ( 3 ) ; cout << getPairs ( A , B , n ) ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll fact [ 14 ] ; int size = 1 ; void preCompute ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; fact [ i - 1 ] <= N ; i ++ ) { fact [ i ] = ( fact [ i - 1 ] * i ) ; size ++ ; } } void findMin ( int N ) { preCompute ( N ) ; int originalN = N ; vector < int > ans ; for ( int i = size - 1 ; i >= 0 ; i -- ) { while ( N >= fact [ i ] ) { N -= fact [ i ] ; ans . push_back ( fact [ i ] ) ; } } cout << ans . size ( ) << " STRNEWLINE " ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) cout << ans [ i ] << " ▁ " ; } int main ( ) { int n = 27 ; findMin ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int k_sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; } int main ( ) { int a [ ] = { 6 , 1 , 2 , 7 } , k = 10 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << k_sum ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr1 [ ] , int arr2 [ ] , int n ) { int initialParity = 0 , finalParity = 0 ; int sum = 0 , minPositive = INT_MAX , maxNegative = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { initialParity += arr2 [ i ] ; if ( arr1 [ i ] >= 0 ) { finalParity += 1 ; sum += arr1 [ i ] ; minPositive = min ( minPositive , arr1 [ i ] ) ; } else { maxNegative = max ( maxNegative , arr1 [ i ] ) ; } } if ( initialParity % 2 == finalParity % 2 ) { return sum ; } else { if ( minPositive + maxNegative >= 0 ) { return sum + maxNegative ; } else { return sum - minPositive ; } } } int main ( ) { int arr1 [ ] = { 2 , -4 , 5 , 3 } ; int arr2 [ ] = { 0 , 1 , 0 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << maxSum ( arr1 , arr2 , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCapacity ( int enter [ ] , int exit [ ] , int n ) { int minCap = 0 ; int currCap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = max ( minCap , currCap ) ; } return minCap ; } int main ( ) { int enter [ ] = { 3 , 5 , 2 , 0 } ; int exit [ ] = { 0 , 2 , 4 , 4 } ; int n = sizeof ( enter ) / sizeof ( enter [ 0 ] ) ; cout << minCapacity ( enter , exit , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMin ( int arr [ ] , int n ) { int minVal = * min_element ( arr , arr + n ) ; return minVal ; } int main ( ) { int arr [ ] = { 5 , 3 , 1 , 6 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMin ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubarray ( int arr [ ] , int n ) { int maxMean = 0 ; for ( int i = 1 ; i < n ; i ++ ) maxMean = max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int subarrayLength = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; } int main ( ) { int arr [ ] = { 4 , 3 , 3 , 2 , 1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestSubarray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 24 ; int countOp ( int x ) { int arr [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; bool flag = true ; int ans ; int operations = 0 ; bool flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } int main ( ) { int x = 39 ; cout << countOp ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCoins ( int X , int Y ) { if ( X < Y ) swap ( X , Y ) ; int coins = X ; X -- ; coins += max ( X , Y ) ; return coins ; } int main ( ) { int X = 7 , Y = 5 ; cout << maxCoins ( X , Y ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printArray ( int N , int arr [ ] ) { for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; } void replacedArray ( int N , int arr [ ] ) { int pos_sum , neg_sum , i , j , diff ; for ( i = 0 ; i < N ; i ++ ) { pos_sum = 0 ; neg_sum = 0 ; for ( j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] > 0 ) pos_sum += arr [ j ] ; else neg_sum += arr [ j ] ; } diff = abs ( pos_sum ) - abs ( neg_sum ) ; arr [ i ] = abs ( diff ) ; } } int main ( ) { int N = 5 ; int arr [ ] = { 1 , -1 , 2 , 3 , -2 } ; replacedArray ( N , arr ) ; printArray ( N , arr ) ; N = 6 ; int arr1 [ ] = { -3 , -4 , -2 , 5 , 1 , -2 } ; replacedArray ( N , arr1 ) ; printArray ( N , arr1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int max ( long long a , long long b ) { if ( a > b ) return a ; else return b ; } long long int smallestSide ( long long int a [ ] ) { sort ( a , a + 4 ) ; long long side1 , side2 , side3 , side4 , side11 , side12 , sideOfSquare ; side1 = a [ 0 ] + a [ 3 ] ; side2 = a [ 1 ] + a [ 2 ] ; side3 = a [ 0 ] + a [ 1 ] ; side4 = a [ 2 ] + a [ 3 ] ; side11 = max ( side1 , side2 ) ; side12 = max ( side3 , side4 ) ; sideOfSquare = max ( side11 , side12 ) ; return sideOfSquare ; } int main ( ) { long long int side [ 4 ] ; cout << " Test ▁ Case ▁ 1 STRNEWLINE " ; side [ 0 ] = 2 ; side [ 1 ] = 2 ; side [ 2 ] = 2 ; side [ 3 ] = 2 ; cout << smallestSide ( side ) << endl ; cout << " Test Case 2 " side [ 0 ] = 100000000000000 ; side [ 1 ] = 123450000000000 ; side [ 2 ] = 987650000000000 ; side [ 3 ] = 987654321000000 ; cout << smallestSide ( side ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } int maxSum ( int a [ ] , int n ) { int S = 0 ; int S1 = maxSubArraySum ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; } int main ( ) { int a [ ] = { -35 , 32 , -24 , 0 , 27 , -10 , 0 , -19 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxSum ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 3 ; const int m = 4 ; int maxMatrixScore ( int A [ n ] [ m ] , int K ) { map < int , int > update ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] [ 0 ] == 0 ) { int ans = 0 ; for ( int j = 1 ; j < m ; ++ j ) ans = ans + A [ i ] [ j ] * pow ( 2 , m - j - 1 ) ; update [ ans ] = i ; } } map < int , int > :: iterator it = update . begin ( ) ; while ( K > 0 && it != update . end ( ) ) { int idx = it -> second ; for ( int j = 0 ; j < m ; ++ j ) A [ idx ] [ j ] = ( A [ idx ] [ j ] + 1 ) % 2 ; it ++ ; K -- ; } int ans = 0 ; for ( int j = 0 ; j < m ; ++ j ) { int zero = 0 , one = 0 ; for ( int i = 0 ; i < n ; ++ i ) { A [ i ] [ j ] == 0 ? zero ++ : one ++ ; } if ( K > 0 && zero > one ) { ans += zero * pow ( 2 , m - j - 1 ) ; K -- ; } else ans += one * pow ( 2 , m - j - 1 ) ; } return ans ; } int main ( ) { int A [ n ] [ m ] = { { 0 , 0 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 0 } } ; int K = 2 ; cout << maxMatrixScore ( A , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximizeAnd ( int i , int mask , int * A , int * B , int N , vector < vector < int > > & dp ) { if ( i == N ) return 0 ; if ( dp [ i ] [ mask ] != -1 ) return dp [ i ] [ mask ] ; for ( int j = 0 ; j < N ; ++ j ) { if ( ! ( mask & ( 1 << j ) ) ) { dp [ i ] [ mask ] = max ( dp [ i ] [ mask ] , ( A [ i ] & B [ j ] ) + maximizeAnd ( i + 1 , mask | ( 1 << j ) , A , B , N , dp ) ) ; } } return dp [ i ] [ mask ] ; } int maximizeAndUtil ( int * A , int * B , int N ) { vector < vector < int > > dp ( N , vector < int > ( 1 << N + 1 , -1 ) ) ; return maximizeAnd ( 0 , 0 , A , B , N , dp ) ; } int main ( ) { int A [ ] = { 3 , 5 , 7 , 11 } ; int B [ ] = { 2 , 6 , 10 , 12 } ; int N = sizeof A / sizeof A [ 0 ] ; cout << maximizeAndUtil ( A , B , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lisOtimised ( string s ) { int dp [ 30 ] = { 0 } ; int N = s . size ( ) ; int lis = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { int val = s [ i ] - ' a ' ; int curr = 0 ; for ( int j = 0 ; j < val ; j ++ ) { curr = max ( curr , dp [ j ] ) ; } curr ++ ; lis = max ( lis , curr ) ; dp [ val ] = max ( dp [ val ] , curr ) ; } return lis ; } int main ( ) { string s = " fdryutiaghfse " ; cout << lisOtimised ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1e9 ; int MinimumLength ( int A [ ] , int N , int K ) { sort ( A , A + N ) ; int suffix [ N + 1 ] = { 0 } ; for ( int i = N - 1 ; i >= 0 ; i -- ) suffix [ i ] = suffix [ i + 1 ] + A [ i ] ; int dp [ N + 1 ] [ K + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= K ; j ++ ) dp [ i ] [ j ] = MAX ; dp [ N ] [ 0 ] = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = K ; j >= 0 ; j -- ) { if ( j <= A [ i ] ) { dp [ i ] [ j ] = A [ i ] ; continue ; } if ( dp [ i + 1 ] [ j - A [ i ] ] == MAX ) dp [ i ] [ j ] = MAX ; else dp [ i ] [ j ] = min ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - A [ i ] ] + A [ i ] ) ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( suffix [ i ] - dp [ i ] [ K ] >= K ) { return N - i ; } } return -1 ; } int main ( ) { int arr [ ] = { 7 , 4 , 5 , 6 , 8 } ; int K = 13 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinimumLength ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float dp [ 105 ] [ 605 ] ; float find ( int N , int sum ) { if ( dp [ N ] [ sum ] ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return 1.0 / 6 ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; } int main ( ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0 ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; cout << fixed << setprecision ( 6 ) << probability ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; double findMedXOR ( int mat [ ] [ 2 ] , int N , int M ) { int dp [ N ] [ M ] ; int med [ N * M ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; med [ 0 ] = dp [ 0 ] [ 0 ] ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ^ mat [ i ] [ 0 ] ; med [ len ++ ] = dp [ i ] [ 0 ] ; } for ( int i = 1 ; i < M ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ^ mat [ 0 ] [ i ] ; med [ len ++ ] = dp [ 0 ] [ i ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ^ dp [ i ] [ j - 1 ] ^ dp [ i - 1 ] [ j - 1 ] ^ mat [ i ] [ j ] ; med [ len ++ ] = dp [ i ] [ j ] ; } } sort ( med , med + len ) ; if ( len % 2 == 0 ) { return ( med [ ( len / 2 ) ] + med [ ( len / 2 ) - 1 ] ) / 2.0 ; } return med [ len / 2 ] ; } int main ( ) { int mat [ ] [ 2 ] = { { 1 , 2 } , { 2 , 3 } } ; int N = sizeof ( mat ) / sizeof ( mat [ 0 ] ) ; int M = 2 ; cout << findMedXOR ( mat , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; map < string , int > dp ; int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { string s = to_string ( sm1 ) + " _ " + to_string ( sm2 ) + to_string ( j ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . find ( s ) != dp . end ( ) ) return dp [ s ] ; else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return dp [ s ] = max ( max ( l , m ) , r ) ; } } void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkEqualSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void manipulation ( vector < vector < int > > & matrix , vector < int > & q ) { int x1 = q [ 0 ] , y1 = q [ 1 ] , x2 = q [ 2 ] , y2 = q [ 3 ] ; for ( int i = x1 - 1 ; i < x2 ; i ++ ) { for ( int j = y1 - 1 ; j < y2 ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) matrix [ i ] [ j ] = 0 ; else matrix [ i ] [ j ] = 1 ; } } } void queries_fxn ( vector < vector < int > > & matrix , vector < vector < int > > & queries ) { for ( auto q : queries ) manipulation ( matrix , q ) ; } int main ( ) { vector < vector < int > > matrix = { { 0 , 1 , 0 } , { 1 , 1 , 0 } } ; vector < vector < int > > queries = { { 1 , 1 , 2 , 3 } , { 1 , 1 , 1 , 1 } , { 1 , 2 , 2 , 3 } } ; queries_fxn ( matrix , queries ) ; cout << " [ " ; for ( int i = 0 ; i < matrix . size ( ) ; i ++ ) { cout << " [ " ; for ( int j = 0 ; j < matrix [ i ] . size ( ) ; j ++ ) cout << matrix [ i ] [ j ] << " ▁ " ; if ( i == matrix . size ( ) - 1 ) cout << " ] " ; else cout << " ] , ▁ " ; } cout << " ] " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long fib [ 101 ] , dp1 [ 101 ] ; long long dp2 [ 101 ] , v [ 101 ] ; void fibonacci ( ) { fib [ 1 ] = 1 ; fib [ 2 ] = 2 ; for ( int i = 3 ; i <= 87 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } int find ( int num ) { int cnt = 0 ; for ( int i = 87 ; i > 0 ; i -- ) { if ( num >= fib [ i ] ) { v [ cnt ++ ] = i ; num -= fib [ i ] ; } } reverse ( v , v + cnt ) ; dp1 [ 0 ] = 1 ; dp2 [ 0 ] = ( v [ 0 ] - 1 ) / 2 ; for ( int i = 1 ; i < cnt ; i ++ ) { dp1 [ i ] = dp1 [ i - 1 ] + dp2 [ i - 1 ] ; dp2 [ i ] = ( ( v [ i ] - v [ i - 1 ] ) / 2 ) * dp2 [ i - 1 ] + ( ( v [ i ] - v [ i - 1 ] - 1 ) / 2 ) * dp1 [ i - 1 ] ; } return ( dp1 [ cnt - 1 ] + dp2 [ cnt - 1 ] ) ; } int main ( ) { fibonacci ( ) ; int num = 13 ; cout << find ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countNums ( int N ) { int l = ( int ) pow ( 10 , N - 1 ) ; int r = ( int ) pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int xorr = 0 , temp = i ; while ( temp > 0 ) { xorr = xorr ^ ( temp % 10 ) ; temp /= 10 ; } if ( xorr <= 9 ) count ++ ; } cout << count ; } int main ( ) { int N = 2 ; countNums ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long getCount ( int n , int k ) { if ( n == 1 ) return 10 ; long long dp [ n + 1 ] [ 11 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j < 11 ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = max ( 0 , j - k ) ; int r = min ( 9 , j + k ) ; dp [ i ] [ l ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ r + 1 ] -= dp [ i - 1 ] [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } long long count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ n ] [ i ] ; return count ; } int main ( ) { int N = 2 , K = 1 ; cout << getCount ( N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define X  6 NEW_LINE #define Z  2 NEW_LINE bool existPath ( int V , int edges [ X ] [ Z ] , int u , int v ) { bool mat [ V ] [ V ] ; memset ( mat , false , sizeof ( mat ) ) ; for ( int i = 0 ; i < X ; i ++ ) mat [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = true ; for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] || mat [ i ] [ k ] && mat [ k ] [ j ] ; } } } if ( u >= V v >= V ) { return false ; } if ( mat [ u ] [ v ] ) return true ; return false ; } int main ( ) { int V = 4 ; int edges [ X ] [ Z ] = { { 0 , 2 } , { 0 , 1 } , { 1 , 2 } , { 2 , 3 } , { 2 , 0 } , { 3 , 3 } } ; int u = 1 , v = 3 ; if ( existPath ( V , edges , u , v ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate_maximum_splits ( int arr [ ] , int N ) { int pre [ ] = { 0 , -1 , -1 } ; int dp [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; int C = 0 ; for ( int i = 0 ; i < N ; i ++ ) { C = C + arr [ i ] ; C = C % 3 ; if ( pre [ C ] == -1 ) { dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = max ( dp [ i - 1 ] , dp [ pre [ C ] ] + 1 ) ; } pre [ C ] = i ; } return dp [ N - 1 ] ; } int main ( ) { int arr [ ] = { 2 , 36 , 1 , 9 , 2 , 0 , 1 , 8 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( calculate_maximum_splits ( arr , N ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void precompute ( int nextpos [ ] , int arr [ ] , int N ) { nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } } void findIndex ( int query [ ] [ 3 ] , int arr [ ] , int N , int Q ) { int nextpos [ N ] ; precompute ( nextpos , arr , N ) ; for ( int i = 0 ; i < Q ; i ++ ) { int l , r , x ; l = query [ i ] [ 0 ] ; r = query [ i ] [ 1 ] ; x = query [ i ] [ 2 ] ; int ans = -1 ; if ( arr [ l ] != x ) ans = l ; else { int d = nextpos [ l ] ; if ( d <= r ) ans = d ; } cout << ans << " STRNEWLINE " ; } } int main ( ) { int N , Q ; N = 6 ; Q = 3 ; int arr [ ] = { 1 , 2 , 1 , 1 , 3 , 5 } ; int query [ Q ] [ 3 ] = { { 0 , 3 , 1 } , { 1 , 5 , 2 } , { 2 , 3 , 1 } } ; findIndex ( query , arr , N , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void twoStringsEquality ( string s , string t ) { int n = s . length ( ) ; vector < vector < int > > dp ( n , vector < int > ( n + 1 , 0 ) ) ; if ( s [ n - 1 ] == t [ 0 ] ) dp [ n - 1 ] [ 1 ] = 1 ; if ( s [ n - 1 ] == t [ n - 1 ] ) dp [ n - 1 ] [ 0 ] = 1 ; for ( int i = n - 1 ; i > 0 ; i -- ) { for ( int j = 0 ; j <= n - i ; j ++ ) { if ( dp [ i ] [ j ] ) { if ( s [ i - 1 ] == t [ j ] ) dp [ i - 1 ] [ j + 1 ] = 1 ; if ( s [ i - 1 ] == t [ i + j - 1 ] ) dp [ i - 1 ] [ j ] = 1 ; } } } bool ans = false ; for ( int i = 0 ; i <= n ; i ++ ) { if ( dp [ 0 ] [ i ] == 1 ) { ans = true ; break ; } } if ( ans == true ) cout << " Yes " << " STRNEWLINE " ; else cout << " No " << " STRNEWLINE " ; } int main ( ) { string S = " abab " ; string T = " baab " ; twoStringsEquality ( S , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool hasSquareOfZeroes ( vector < vector < int > > & matrix , int r1 , int c1 , int r2 , int c2 , unordered_map < string , bool > & cache ) ; bool isSquareOfZeroes ( vector < vector < int > > & matrix , int r1 , int c1 , int r2 , int c2 ) ; bool squareOfZeroes ( vector < vector < int > > matrix ) { int lastIdx = matrix . size ( ) - 1 ; unordered_map < string , bool > cache ; return hasSquareOfZeroes ( matrix , 0 , 0 , lastIdx , lastIdx , cache ) ; } bool hasSquareOfZeroes ( vector < vector < int > > & matrix , int r1 , int c1 , int r2 , int c2 , unordered_map < string , bool > & cache ) { if ( r1 >= r2 c1 >= c2 ) return false ; string key = to_string ( r1 ) + ' - ' + to_string ( c1 ) + ' - ' + to_string ( r2 ) + ' - ' + to_string ( c2 ) ; if ( cache . find ( key ) != cache . end ( ) ) return cache [ key ] ; cache [ key ] = isSquareOfZeroes ( matrix , r1 , c1 , r2 , c2 ) || hasSquareOfZeroes ( matrix , r1 + 1 , c1 + 1 , r2 - 1 , c2 - 1 , cache ) || hasSquareOfZeroes ( matrix , r1 , c1 + 1 , r2 - 1 , c2 , cache ) || hasSquareOfZeroes ( matrix , r1 + 1 , c1 , r2 , c2 - 1 , cache ) || hasSquareOfZeroes ( matrix , r1 + 1 , c1 + 1 , r2 , c2 , cache ) || hasSquareOfZeroes ( matrix , r1 , c1 , r2 - 1 , c2 - 1 , cache ) ; return cache [ key ] ; } bool isSquareOfZeroes ( vector < vector < int > > & matrix , int r1 , int c1 , int r2 , int c2 ) { for ( int row = r1 ; row < r2 + 1 ; row ++ ) { if ( matrix [ row ] [ c1 ] != 0 matrix [ row ] [ c2 ] != 0 ) return false ; } for ( int col = c1 ; col < c2 + 1 ; col ++ ) { if ( matrix [ r1 ] [ col ] != 0 matrix [ r2 ] [ col ] != 0 ) return false ; } return true ; } int main ( ) { vector < vector < int > > matrix { { 1 , 1 , 1 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 } , { 0 , 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 1 , 0 , 1 } , { 0 , 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 0 , 1 } } ; int ans ; ans = squareOfZeroes ( matrix ) ; if ( ans == 1 ) { cout << " True " << endl ; } else { cout << " False " << endl ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void canMakePaliQueries ( string str , vector < vector < int > > & Q ) { int n = str . length ( ) ; vector < vector < int > > dp ( 26 , vector < int > ( n , 0 ) ) ; for ( int i = 0 ; i < 26 ; i ++ ) { char currentChar = i + ' a ' ; for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = ( str [ j ] == currentChar ) ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + ( str [ j ] == currentChar ) ; } } } for ( auto query : Q ) { int left = query [ 0 ] ; int right = query [ 1 ] ; int k = query [ 2 ] ; int unMatchedCount = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int occurrence = dp [ i ] [ right ] - dp [ i ] [ left ] + ( str [ left ] == ( i + ' a ' ) ) ; if ( occurrence & 1 ) unMatchedCount ++ ; } int ans = unMatchedCount / 2 ; if ( ans <= k ) { cout << " YES STRNEWLINE " ; } else { cout << " NO STRNEWLINE " ; } } } int main ( ) { string str = " GeeksforGeeks " ; vector < vector < int > > Q ; Q = { { 1 , 5 , 3 } , { 5 , 7 , 0 } , { 8 , 11 , 3 } , { 3 , 10 , 5 } , { 0 , 9 , 5 } } ; canMakePaliQueries ( str , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaximumSum ( int a [ ] , int n ) { int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) dp [ i ] [ j ] = INT_MIN ; } for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int val = INT_MIN ; if ( ( i - 2 >= 0 && dp [ i - 2 ] [ j - 1 ] != INT_MIN ) i - 2 < 0 ) { val = a [ i - 1 ] + ( i - 2 >= 0 ? dp [ i - 2 ] [ j - 1 ] : 0 ) ; } if ( i - 1 >= j ) { val = max ( val , dp [ i - 1 ] [ j ] ) ; } dp [ i ] [ j ] = val ; } } return dp [ n ] [ n / 2 ] ; } int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << MaximumSum ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 500 ] [ 500 ] [ 500 ] ; int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ prev ] [ left ] != -1 ) return dp [ pos ] [ prev ] [ left ] ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return dp [ pos ] [ prev ] [ left ] = answer ; } int countWaystoDivide ( int n , int k ) { memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , 1 , n , k ) ; } int main ( ) { int N = 8 ; int K = 4 ; cout << countWaystoDivide ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100000 ; int divisors [ MAX ] ; int generateDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } } int findMaxMultiples ( int * arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; } int main ( ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMaxMultiples ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int eggDrop ( int n , int k ) { vector < vector < int > > dp ( k + 1 , vector < int > ( n + 1 , 0 ) ) ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; } int main ( ) { int n = 2 , k = 36 ; cout << eggDrop ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define n  3 NEW_LINE #define m  3 NEW_LINE int countSquareMatrices ( int a [ ] [ m ] , int N , int M ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] == 0 ) continue ; a [ i ] [ j ] = min ( min ( a [ i - 1 ] [ j ] , a [ i ] [ j - 1 ] ) , a [ i - 1 ] [ j - 1 ] ) + 1 ; } } for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) count += a [ i ] [ j ] ; return count ; } int main ( ) { int arr [ ] [ m ] = { { 1 , 0 , 1 } , { 1 , 1 , 0 } , { 1 , 1 , 0 } } ; cout << countSquareMatrices ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define V_SUM_MAX  1000 NEW_LINE #define N_MAX  100 NEW_LINE #define W_MAX  10000000 NEW_LINE int dp [ V_SUM_MAX + 1 ] [ N_MAX ] ; bool v [ V_SUM_MAX + 1 ] [ N_MAX ] ; int solveDp ( int r , int i , int * w , int * val , int n ) { if ( r <= 0 ) return 0 ; if ( i == n ) return W_MAX ; if ( v [ r ] [ i ] ) return dp [ r ] [ i ] ; v [ r ] [ i ] = 1 ; dp [ r ] [ i ] = min ( solveDp ( r , i + 1 , w , val , n ) , w [ i ] + solveDp ( r - val [ i ] , i + 1 , w , val , n ) ) ; return dp [ r ] [ i ] ; } int maxWeight ( int * w , int * val , int n , int c ) { for ( int i = V_SUM_MAX ; i >= 0 ; i -- ) { if ( solveDp ( i , 0 , w , val , n ) <= c ) { return i ; } } return 0 ; } int main ( ) { int w [ ] = { 3 , 4 , 5 } ; int val [ ] = { 30 , 50 , 60 } ; int n = sizeof ( w ) / sizeof ( int ) ; int C = 8 ; cout << maxWeight ( w , val , n , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxM  64 NEW_LINE int dp1 [ maxN ] [ maxM ] ; bool v1 [ maxN ] [ maxM ] ; int findCnt ( int * arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = 1 ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; } int main ( ) { int arr [ ] = { 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int m = 0 ; cout << findCnt ( arr , 0 , ( ( 1 << 6 ) - 1 ) , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000007 NEW_LINE int dp [ 55 ] [ 55 ] ; int NoofWays ( int face , int throws , int sum ) { if ( sum == 0 && throws == 0 ) return 1 ; if ( sum < 0 throws == 0 ) return 0 ; if ( dp [ throws ] [ sum ] != -1 ) return dp [ throws ] [ sum ] ; int ans = 0 ; for ( int i = 1 ; i <= face ; i ++ ) { ans += NoofWays ( face , throws - 1 , sum - i ) ; } return dp [ throws ] [ sum ] = ans ; } int main ( ) { int faces = 6 , throws = 3 , sum = 12 ; memset ( dp , -1 , sizeof dp ) ; cout << NoofWays ( faces , throws , sum ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define bitscount  32 NEW_LINE #define n  3 NEW_LINE using namespace std ; int prefix_count [ bitscount ] [ n ] [ n ] ; void findPrefixCount ( int arr [ ] [ n ] ) { for ( int i = 0 ; i < bitscount ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] ; } } } for ( int i = 0 ; i < bitscount ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] ; } int rangeAnd ( int x1 , int y1 , int x2 , int y2 ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int p ; if ( x1 == 0 and y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] ; else if ( x1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] ; else if ( y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] ; else p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] + prefix_count [ i ] [ x1 - 1 ] [ y1 - 1 ] ; if ( p == ( x2 - x1 + 1 ) * ( y2 - y1 + 1 ) ) ans = ( ans | ( 1 << i ) ) ; } return ans ; } int main ( ) { int arr [ ] [ n ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; findPrefixCount ( arr ) ; int queries [ ] [ 4 ] = { { 1 , 1 , 1 , 1 } , { 1 , 2 , 2 , 2 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) cout << rangeAnd ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , queries [ i ] [ 2 ] , queries [ i ] [ 3 ] ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int n ; int solve ( int i , int x , int dp [ ] [ 4 ] ) { if ( i < 0 ) return x == 3 ; if ( dp [ i ] [ x ] != -1 ) return dp [ i ] [ x ] ; dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) ; dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) ; return dp [ i ] [ x ] ; } int main ( ) { n = 4 ; int dp [ n ] [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < 4 ; j ++ ) dp [ i ] [ j ] = -1 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 3 ] = ( 1 << ( i + 1 ) ) ; } cout << solve ( n - 1 , 0 , dp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubArraySum ( int arr [ ] , int size ) { int max_so_far = arr [ 0 ] ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( arr [ i ] , curr_max + arr [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; } int lenOfLongSubarrWithGivenSum ( int arr [ ] , int n , int k ) { unordered_map < int , int > um ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == k ) maxLen = i + 1 ; if ( um . find ( sum ) == um . end ( ) ) um [ sum ] = i ; if ( um . find ( sum - k ) != um . end ( ) ) { if ( maxLen < ( i - um [ sum - k ] ) ) maxLen = i - um [ sum - k ] ; } } return maxLen ; } int lenLongSubarrWithMaxSum ( int arr [ ] , int n ) { int maxSum = maxSubArraySum ( arr , n ) ; return lenOfLongSubarrWithGivenSum ( arr , n , maxSum ) ; } int main ( ) { int arr [ ] = { 5 , -2 , -1 , 3 , -4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Length ▁ of ▁ longest ▁ subarray ▁ having ▁ maximum ▁ sum ▁ = ▁ " << lenLongSubarrWithMaxSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct data { int element ; int position ; } ; struct data findMinElement ( int arr [ ] , int n ) { struct data result ; int prefixSum [ n ] = { 0 } ; int suffixSum [ n ] = { 0 } ; prefixSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; } suffixSum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffixSum [ i ] = suffixSum [ i + 1 ] + arr [ i ] ; } int min = suffixSum [ 0 ] ; int pos ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( abs ( suffixSum [ i + 1 ] - prefixSum [ i ] ) < min ) { min = abs ( suffixSum [ i + 1 ] - prefixSum [ i ] ) ; if ( suffixSum [ i + 1 ] < prefixSum [ i ] ) pos = i + 1 ; else pos = i ; } } result . element = min ; result . position = pos ; return result ; } int main ( ) { int arr [ ] = { 10 , 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; struct data values ; values = findMinElement ( arr , n ) ; cout << " Minimum ▁ element ▁ : ▁ " << values . element << endl << " Position ▁ : ▁ " << values . position ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findInd ( int key , int i , int n , int k , int arr [ ] ) { int start , end , mid , ind = -1 ; start = i + 1 ; end = n - 1 ; while ( start < end ) { mid = start + ( end - start ) / 2 ; if ( arr [ mid ] - key <= k ) { ind = mid ; start = mid + 1 ; } else { end = mid ; } } return ind ; } int removals ( int arr [ ] , int n , int k ) { int i , j , ans = n - 1 ; sort ( arr , arr + n ) ; for ( i = 0 ; i < n ; i ++ ) { j = findInd ( arr [ i ] , i , n , k , arr ) ; if ( j != -1 ) { ans = min ( ans , n - ( j - i + 1 ) ) ; } } return ans ; } int main ( ) { int a [ ] = { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 4 ; cout << removals ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( char s [ ] , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; } int main ( ) { char s [ ] = " ( ) ( ( ( ( ( ( ) " ; int n = strlen ( s ) ; cout << maxLength ( s , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10 NEW_LINE int lcs ( int dp [ MAX ] [ MAX ] [ MAX ] , int arr1 [ ] , int n , int arr2 [ ] , int m , int k ) { if ( k < 0 ) return -1e7 ; if ( n < 0 m < 0 ) return 0 ; int & ans = dp [ n ] [ m ] [ k ] ; if ( ans != -1 ) return ans ; ans = max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; return ans ; } int main ( ) { int k = 1 ; int arr1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int arr2 [ ] = { 5 , 3 , 1 , 4 , 2 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int dp [ MAX ] [ MAX ] [ MAX ] ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << lcs ( dp , arr1 , n , arr2 , m , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLenSub ( int arr [ ] , int n ) { int mls [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; } int main ( ) { int arr [ ] = { 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ length ▁ subsequence ▁ = ▁ " << maxLenSub ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define max  100000 NEW_LINE int baseconversion ( int arr [ ] , int num , int base ) { int i = 0 , rem , j ; if ( num == 0 ) { return 0 ; } while ( num > 0 ) { rem = num % base ; arr [ i ++ ] = rem ; num /= base ; } return i ; } int main ( ) { int arr [ max ] = { 0 } ; int n = 10 ; int size = baseconversion ( arr , n - 1 , 6 ) ; if ( size == 0 ) cout << size ; for ( int i = size - 1 ; i >= 0 ; i -- ) { cout << arr [ i ] ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  1000 NEW_LINE using namespace std ; int numofArray ( int n , int m ) { int dp [ MAX ] [ MAX ] ; vector < int > di [ MAX ] ; vector < int > mu [ MAX ] ; memset ( dp , 0 , sizeof dp ) ; memset ( di , 0 , sizeof di ) ; memset ( mu , 0 , sizeof mu ) ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . push_back ( i ) ; mu [ i ] . push_back ( j ) ; } di [ i ] . push_back ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( auto x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( auto x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; } int main ( ) { int n = 3 , m = 3 ; cout << numofArray ( n , m ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define Row  6 NEW_LINE #define Col  6 NEW_LINE using namespace std ; int largestKSubmatrix ( int a [ ] [ Col ] ) { int dp [ Row ] [ Col ] ; memset ( dp , sizeof ( dp ) , 0 ) ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ; else dp [ i ] [ j ] = 1 ; } result = max ( result , dp [ i ] [ j ] ) ; } } return result ; } int main ( ) { int a [ Row ] [ Col ] = { 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 7 , 7 , 7 , 4 , 1 , 2 , 7 , 7 , 7 , 4 , 4 , 4 , 7 , 7 , 7 , 4 , 5 , 5 , 5 , 1 , 2 , 7 , 8 , 7 , 9 , 4 , 4 , 4 } ; cout << largestKSubmatrix ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDivisibleSubseq ( string str , int n ) { int len = str . length ( ) ; int dp [ len ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ ( str [ 0 ] - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str [ i ] - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str [ i ] - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; } int main ( ) { string str = "1234" ; int n = 4 ; cout << countDivisibleSubseq ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100 NEW_LINE int L [ N ] [ N ] ; set < string > findLCS ( string X , string Y , int m , int n ) { set < string > s ; if ( m == 0 n == 0 ) { s . insert ( " " ) ; return s ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { set < string > tmp = findLCS ( X , Y , m - 1 , n - 1 ) ; for ( string str : tmp ) s . insert ( str + X [ m - 1 ] ) ; } else { if ( L [ m - 1 ] [ n ] >= L [ m ] [ n - 1 ] ) s = findLCS ( X , Y , m - 1 , n ) ; if ( L [ m ] [ n - 1 ] >= L [ m - 1 ] [ n ] ) { set < string > tmp = findLCS ( X , Y , m , n - 1 ) ; s . insert ( tmp . begin ( ) , tmp . end ( ) ) ; } } return s ; } int LCS ( string X , string Y , int m , int n ) { for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } int main ( ) { string X = " AGTGATG " ; string Y = " GTTAG " ; int m = X . length ( ) ; int n = Y . length ( ) ; cout << " LCS ▁ length ▁ is ▁ " << LCS ( X , Y , m , n ) << endl ; set < string > s = findLCS ( X , Y , m , n ) ; for ( string str : s ) cout << str << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; } int main ( ) { int n = 3 ; cout << countIntegralSolutions ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSubsetSum ( int arr [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; } bool findPartiion ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return isSubsetSum ( arr , n , sum / 2 ) ; } int main ( ) { int arr [ ] = { 3 , 1 , 5 , 9 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findPartiion ( arr , n ) == true ) cout << " Can ▁ be ▁ divided ▁ into ▁ two ▁ subsets ▁ " " of ▁ equal ▁ sum " ; else cout << " Can ▁ not ▁ be ▁ divided ▁ into ▁ two ▁ subsets " " ▁ of ▁ equal ▁ sum " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find ( int N , vector < vector < int > > Arr ) { int amount = 0 ; vector < int > mid_odd ; for ( int i = 0 ; i < N ; i ++ ) { int siz = Arr [ i ] . size ( ) ; for ( int j = 0 ; j < siz / 2 ; j ++ ) amount = amount + Arr [ i ] [ j ] ; if ( siz % 2 == 1 ) mid_odd . push_back ( Arr [ i ] [ siz / 2 ] ) ; } sort ( mid_odd . begin ( ) , mid_odd . end ( ) ) ; for ( int i = 0 ; i < mid_odd . size ( ) ; i ++ ) if ( i % 2 == 0 ) amount = amount + mid_odd [ i ] ; cout << amount << endl ; } int main ( ) { int N = 2 ; vector < vector < int > > Arr { { 5 , 2 , 3 , 4 } , { 1 , 6 } } ; find ( N , Arr ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printDiagonalTraversal ( vector < vector < int > > & nums ) { int max_size = nums . size ( ) ; for ( int i = 0 ; i < nums . size ( ) ; i ++ ) { if ( max_size < nums [ i ] . size ( ) ) { max_size = nums [ i ] . size ( ) ; } } vector < vector < int > > v ( 2 * max_size - 1 ) ; for ( int i = 0 ; i < nums . size ( ) ; i ++ ) { for ( int j = 0 ; j < nums [ i ] . size ( ) ; j ++ ) { v [ i + j ] . push_back ( nums [ i ] [ j ] ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { reverse ( v [ i ] . begin ( ) , v [ i ] . end ( ) ) ; for ( int j = 0 ; j < v [ i ] . size ( ) ; j ++ ) cout << v [ i ] [ j ] << " ▁ " ; } } int main ( ) { vector < vector < int > > arr = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; printDiagonalTraversal ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int OddLengthSum ( vector < int > & arr ) { int sum = 0 ; int l = arr . size ( ) ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; } int main ( ) { vector < int > arr = { 1 , 5 , 3 , 1 , 2 } ; cout << OddLengthSum ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long N_bonacci [ 100 ] ; void N_bonacci_nums ( int n , int k ) { N_bonacci [ 0 ] = 1 ; for ( int i = 1 ; i <= 50 ; ++ i ) { for ( int j = i - 1 ; j >= i - k and j >= 0 ; -- j ) N_bonacci [ i ] += N_bonacci [ j ] ; } vector < long long > ans ; for ( int i = 50 ; i >= 0 ; -- i ) if ( n - N_bonacci [ i ] >= 0 ) { ans . push_back ( N_bonacci [ i ] ) ; n -= N_bonacci [ i ] ; } if ( ans . size ( ) == 1 ) ans . push_back ( 0 ) ; cout << ans . size ( ) << endl ; for ( int i = 0 ; i < ans . size ( ) ; ++ i ) cout << ans [ i ] << " , ▁ " ; } int main ( ) { int n = 21 , k = 5 ; N_bonacci_nums ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkBitonic ( string s ) { int i , j ; for ( i = 1 ; i < s . size ( ) ; i ++ ) { if ( s [ i ] > s [ i - 1 ] ) continue ; if ( s [ i ] <= s [ i - 1 ] ) break ; } if ( i == s . size ( ) - 1 ) return 1 ; for ( j = i + 1 ; j < s . size ( ) ; j ++ ) { if ( s [ j ] < s [ j - 1 ] ) continue ; if ( s [ j ] >= s [ j - 1 ] ) break ; } i = j ; if ( i != s . size ( ) ) return 0 ; return 1 ; } int main ( ) { string s = " abcdfgcba " ; ( checkBitonic ( s ) == 1 ) ? cout << " YES " : cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void makeArray ( int a [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) cout << i * n << " ▁ " ; } int main ( ) { int N = 6 ; int arr [ N ] ; makeArray ( arr , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int checkQwertyRow ( char x ) { set < char > first_row = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , ' - ' , ' = ' } ; set < char > second_row = { ' Q ' , ' W ' , ' E ' , ' R ' , ' T ' , ' Y ' , ' U ' , ' I ' , ' O ' , ' P ' , ' [ ' , ' ] ' , ' q ' , ' w ' , ' e ' , ' r ' , ' t ' , ' y ' , ' u ' , ' i ' , ' o ' , ' p ' } ; set < char > third_row = { ' A ' , ' S ' , ' D ' , ' F ' , ' G ' , ' H ' , ' J ' , ' K ' , ' L ' , ' ; ' , ' : ' , ' a ' , ' s ' , ' d ' , ' f ' , ' g ' , ' h ' , ' j ' , ' k ' , ' l ' } ; set < char > fourth_row = { ' Z ' , ' X ' , ' C ' , ' V ' , ' B ' , ' N ' , ' M ' , ' , ' , ' . ' , ' / ' , ' z ' , ' x ' , ' c ' , ' v ' , ' b ' , ' n ' , ' m ' } ; if ( first_row . count ( x ) > 0 ) { return 1 ; } else if ( second_row . count ( x ) > 0 ) { return 2 ; } else if ( third_row . count ( x ) > 0 ) { return 3 ; } else if ( fourth_row . count ( x ) > 0 ) { return 4 ; } return 0 ; } bool checkValidity ( string str ) { char x = str [ 0 ] ; int row = checkQwertyRow ( x ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { x = str [ i ] ; if ( row != checkQwertyRow ( x ) ) { return false ; } } return true ; } int main ( ) { string str = " GeeksforGeeks " ; if ( checkValidity ( str ) ) cout << " Yes " ; else cout << " No " ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long fib ( long long n ) { long long f0 = 0 ; long long f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { long long rem = n % 60 ; if ( rem == 0 ) return 0 ; for ( long long i = 2 ; i < rem + 3 ; i ++ ) { long long f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } long long s = f1 - 1 ; return s ; } } int main ( ) { long long m = 10087887 ; long long n = 2983097899 ; long long final = abs ( fib ( n ) - fib ( m - 1 ) ) ; cout << final % 10 << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printPattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { cout << " / " ; } else { cout << " \ \" ; } } else { cout << " * " ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } cout << endl ; return printPattern ( i + 1 , 0 , n ) ; } int main ( ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverseStr ( string & str , int l , int h ) { int n = h - l ; for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( str [ i + l ] , str [ n - i - 1 + l ] ) ; } } void reverseString ( string & s , int A [ ] , int n ) { reverseStr ( s , 0 , A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) reverseStr ( s , A [ i - 1 ] , A [ i ] ) ; reverseStr ( s , A [ n - 1 ] , s . length ( ) ) ; } int main ( ) { string s = " abcdefgh " ; int A [ ] = { 2 , 4 , 6 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; reverseString ( s , A , n ) ; cout << s ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * pow ( 2 , r - 2 ) ; int d = pow ( 2 , r - 1 ) ; c = c - r ; int element = a + d * c ; return element ; } int main ( ) { int N = 4 , R = 3 , C = 4 ; cout << getElement ( N , R , C ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string S1 , string S2 ) { int n1 = S1 . size ( ) ; int n2 = S2 . size ( ) ; unordered_map < int , int > mp ; for ( int i = 0 ; i < n1 ; i ++ ) { mp [ S1 [ i ] ] ++ ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp [ S2 [ i ] ] ) { mp [ S2 [ i ] ] -- ; } else if ( mp [ S2 [ i ] - 1 ] && mp [ S2 [ i ] - 2 ] ) { mp [ S2 [ i ] - 1 ] -- ; mp [ S2 [ i ] - 2 ] -- ; } else { return false ; } } return true ; } int main ( ) { string S1 = " abbat " ; string S2 = " cat " ; if ( check ( S1 , S2 ) ) cout << " YES " ; else cout << " NO " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lengthNPalindrome ( int N , int K ) { int half = N / 2 ; if ( N & 1 ) { half += 1 ; } int ans = 1 ; for ( int i = 1 ; i <= half ; i ++ ) { ans *= K ; K -- ; } return ans ; } int palindromicStrings ( int N , int K ) { if ( N == 1 ) { return K ; } if ( N == 2 ) { return 2 * K ; } int ans = 0 ; ans += ( 2 * K ) ; for ( int i = 3 ; i <= N ; i ++ ) { ans += lengthNPalindrome ( i , K ) ; } return ans ; } int main ( ) { int N = 4 , K = 3 ; cout << palindromicStrings ( N , K ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; int LCS ( string & S , int N , string & T , int M , vector < vector < int > > & dp ) { if ( N == 0 or M == 0 ) return 0 ; if ( dp [ N ] [ M ] != -1 ) return dp [ N ] [ M ] ; if ( S [ N - 1 ] == T [ M - 1 ] ) { return dp [ N ] [ M ] = 1 + LCS ( S , N - 1 , T , M - 1 , dp ) ; } return dp [ N ] [ M ] = max ( LCS ( S , N - 1 , T , M , dp ) , LCS ( S , N , T , M - 1 , dp ) ) ; } int minimumCharacter ( string & S ) { string T = " abcdefghijklmnopqrstuvwxyz " ; int N = S . length ( ) , M = T . length ( ) ; vector < vector < int > > dp ( N + 1 , vector < int > ( M + 1 , -1 ) ) ; return ( 26 - LCS ( S , N , T , M , dp ) ) ; } int main ( ) { string S = " abcdadc " ; cout << minimumCharacter ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string MinValue ( string N , int X ) { int len = N . size ( ) ; int position = len + 1 ; if ( N [ 0 ] == ' - ' ) { for ( int i = len - 1 ; i >= 1 ; i -- ) { if ( ( N [ i ] - '0' ) < X ) { position = i ; } } } else { for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( ( N [ i ] - '0' ) > X ) { position = i ; } } } N . insert ( N . begin ( ) + position , X + '0' ) ; return N ; } int main ( ) { string N = "89" ; int X = 1 ; cout << MinValue ( N , X ) << " STRNEWLINE " ; }
#include <iostream> NEW_LINE using namespace std ; void countOperations ( string S ) { int n = S . length ( ) ; int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S [ i ] == '0' ) { cnt ++ ; } else { if ( cnt > 0 ) { cnt -- ; ans ++ ; } } } cout << ans ; } int main ( ) { string S = "110011010" ; countOperations ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n <= 1 ) return false ; else if ( n == 2 ) return true ; else if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; } void checkPermutation ( string s1 , string s2 ) { int freq [ 26 ] = { 0 } ; for ( char ch : s1 ) { freq [ ch - ' a ' ] -- ; } for ( char ch : s2 ) { freq [ ch - ' a ' ] ++ ; } bool isAllChangesPrime = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) { continue ; } else if ( ! isPrime ( abs ( freq [ i ] ) ) ) { isAllChangesPrime = false ; break ; } } if ( isAllChangesPrime ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { string S1 = " gekforgk " ; string S2 = " geeksforgeeks " ; checkPermutation ( S1 , S2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumOperations ( string S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S [ i ] == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } cout << ans ; } int main ( ) { string S = "001" ; int N = S . length ( ) ; minimumOperations ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int num ) { bool flag = false ; if ( num > 1 ) { for ( int i = 2 ; i < num ; i ++ ) { if ( ( num % i ) == 0 ) { flag = true ; break ; } } } if ( flag ) return false ; else return true ; } int order ( int x ) { int n = 0 ; while ( x != 0 ) { n = n + 1 ; x = x / 10 ; } return n ; } bool isArmstrong ( int x ) { int n = order ( x ) ; int temp = x ; int sum1 = 0 ; while ( temp != 0 ) { int r = temp % 10 ; sum1 = sum1 + pow ( r , n ) ; temp = temp / 10 ; } return ( sum1 == x ) ; } int count_armstrong ( vector < string > li ) { int c = 0 ; for ( string ele : li ) { int val = 0 ; for ( char che : ele ) val += che ; if ( isArmstrong ( val ) ) c += 1 ; } return c ; } int count_prime ( vector < string > li ) { int c = 0 ; for ( string ele : li ) { int val = 0 ; for ( char che : ele ) val += che ; if ( isPrime ( val ) ) c += 1 ; } return c ; } int main ( ) { vector < string > arr = { " geeksforgeeks " , " a " , " computer " , " science " , " portal " , " for " , " geeks " } ; cout << " Number ▁ of ▁ Armstrong ▁ Strings ▁ are : ▁ " << count_armstrong ( arr ) << endl ; cout << " Number ▁ of ▁ Prime ▁ Strings ▁ are : ▁ " << count_prime ( arr ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( string S , int X , int Y ) { int N = S . length ( ) ; int temp_x = 0 , temp_y = 0 ; int count = 0 ; set < pair < int , int > > s ; s . insert ( { X , Y } ) ; for ( int i = 0 ; i < N ; i ++ ) { temp_x = X ; temp_y = Y ; if ( S [ i ] == ' U ' ) { X ++ ; } else if ( S [ i ] == ' D ' ) { X -- ; } else if ( S [ i ] == ' R ' ) { Y ++ ; } else { Y -- ; } if ( s . find ( { temp_x + X , temp_y + Y } ) != s . end ( ) ) { count ++ ; } else { s . insert ( { temp_x + X , temp_y + Y } ) ; } } return count ; } int main ( ) { string S = " RDDUDL " ; int X = 0 , Y = 0 ; cout << count ( S , X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countMinMoves ( string str ) { int n = str . size ( ) ; int a [ n ] = { 0 } ; int j , ans = 0 , i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ) ' ) { a [ i ] += sum - 1 ; } else { a [ i ] += sum + 1 ; } sum = a [ i ] ; } if ( sum == 0 ) { i = 1 ; while ( i < n ) { j = i - 1 ; while ( i < n && a [ i ] != 0 ) i ++ ; if ( i < n && a [ i - 1 ] < 0 ) { ans += i - j ; if ( j == 0 ) ans ++ ; } i ++ ; } cout << ans << endl ; } else cout << " - 1 STRNEWLINE " ; } int main ( ) { string str = " ) ( ( ) " ; countMinMoves ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PrintStack ( stack < char > s ) { if ( s . empty ( ) ) return ; char x = s . top ( ) ; s . pop ( ) ; PrintStack ( s ) ; cout << x ; s . push ( x ) ; } void minString ( string s ) { stack < char > Stack ; Stack . push ( s [ 0 ] ) ; for ( int i = 1 ; i < s . size ( ) ; i ++ ) { if ( Stack . empty ( ) ) { Stack . push ( s [ i ] ) ; } else { if ( Stack . top ( ) == s [ i ] ) { Stack . pop ( ) ; } else { Stack . push ( s [ i ] ) ; } } } PrintStack ( Stack ) ; } int main ( ) { string str = "101001" ; minString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string ShortenString ( string str1 ) { stack < char > st ; int i = 0 ; while ( i < str1 . length ( ) ) { if ( st . empty ( ) || str1 [ i ] != st . top ( ) ) { st . push ( str1 [ i ] ) ; i ++ ; } else { st . pop ( ) ; i ++ ; } } if ( st . empty ( ) ) { return ( " Empty ▁ String " ) ; } else { string short_string = " " ; while ( ! st . empty ( ) ) { short_string = st . top ( ) + short_string ; st . pop ( ) ; } return ( short_string ) ; } } int main ( ) { string str1 = " azzxzy " ; cout << ShortenString ( str1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRev ( string str ) { stack < string > st ; stringstream ss ( str ) ; string temp ; while ( getline ( ss , temp , ' ▁ ' ) ) { st . push ( temp ) ; } while ( ! st . empty ( ) ) { cout << st . top ( ) << " ▁ " ; st . pop ( ) ; } } int main ( ) { string str ; str = " geeks ▁ quiz ▁ practice ▁ code " ; printRev ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSetBitCount ( string s , int k ) { int maxCount = 0 , n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } maxCount = count ; for ( int i = k ; i < n ; i ++ ) { if ( s [ i - k ] == '1' ) count -- ; if ( s [ i ] == '1' ) count ++ ; maxCount = max ( maxCount , count ) ; } return maxCount ; } int main ( ) { string s = "100111010" ; int k = 3 ; cout << ( maxSetBitCount ( s , k ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s ) { bool ok = true ; for ( int i = 0 ; i + 1 < s . size ( ) ; ++ i ) ok &= ( abs ( s [ i ] - s [ i + 1 ] ) != 1 ) ; return ok ; } string monotonousString ( string s ) { string odd = " " , even = " " ; for ( int i = 0 ; i < s . size ( ) ; ++ i ) { if ( s [ i ] % 2 == 0 ) odd += s [ i ] ; else even += s [ i ] ; } sort ( odd . begin ( ) , odd . end ( ) ) ; sort ( even . begin ( ) , even . end ( ) ) ; if ( check ( odd + even ) ) return " Yes " ; else if ( check ( even + odd ) ) return " Yes " ; return " No " ; } int main ( ) { string str = " abcd " ; string ans ; ans = monotonousString ( str ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findStr ( string S ) { int n = S . size ( ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( S [ i ] != ' a ' ) { S [ i ] = ' a ' ; return S ; } } S [ n - 1 ] = ' b ' ; return n < 2 ? " ▁ - 1 ▁ " : S ; } int main ( ) { string str = " a " ; cout << findStr ( str ) << endl ; string str1 = " abccba " ; cout << findStr ( str1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void convertString ( string str1 , string str2 , string str3 ) { map < char , int > freq ; for ( int i = 0 ; str3 [ i ] ; i ++ ) { freq [ str3 [ i ] ] ++ ; } int ptr1 = 0 ; int ptr2 = 0 ; bool flag = true ; while ( ptr1 < str1 . length ( ) && ptr2 < str2 . length ( ) ) { if ( str1 [ ptr1 ] == str2 [ ptr2 ] ) { ptr1 ++ ; ptr2 ++ ; } else { if ( freq [ str3 [ ptr2 ] ] > 0 ) { freq [ str3 [ ptr2 ] ] -- ; ptr2 ++ ; } else { flag = false ; break ; } } } if ( flag && ptr1 == str1 . length ( ) && ptr2 == str2 . length ( ) ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } int main ( ) { string str1 = " abyzfe " ; string str2 = " abcdeyzf " ; string str3 = " popode " ; convertString ( str1 , str2 , str3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <set> NEW_LINE using namespace std ; void distinct ( string S [ ] , int M , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { set < char > set1 ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( set1 . find ( S [ i ] [ j ] ) == set1 . end ( ) ) set1 . insert ( S [ i ] [ j ] ) ; } int c = set1 . size ( ) ; if ( c <= M ) count += 1 ; } cout << ( count ) ; } int main ( ) { string S [ ] = { " HERBIVORES " , " AEROPLANE " , " GEEKSFORGEEKS " } ; int M = 7 ; int n = sizeof ( S ) / sizeof ( S [ 0 ] ) ; distinct ( S , M , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void String ( int l , int x , int y ) { int p = 97 ; for ( int j = 0 ; j < l ; j ++ ) { char ans = ( char ) ( p + ( j % y ) ) ; cout << ans ; } } int main ( ) { int l = 6 ; int x = 5 ; int y = 3 ; String ( l , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPeriodicString ( string S ) { int l = 2 * S . length ( ) ; int count = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S [ i ] == '1' ) count ++ ; } if ( count == S . length ( ) count == 0 ) cout << S << " STRNEWLINE " ; else { char arr [ l ] ; for ( int i = 0 ; i < l ; i += 2 ) { arr [ i ] = '1' ; arr [ i + 1 ] = '0' ; } for ( int i = 0 ; i < l ; i ++ ) cout << arr [ i ] ; cout << " STRNEWLINE " ; } } int main ( ) { string S = "1111001" ; findPeriodicString ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void group_formed ( string S ) { int count = 1 ; for ( int i = 0 ; i < S . size ( ) - 1 ; i ++ ) { if ( S [ i ] != S [ i + 1 ] ) count += 1 ; } cout << ( count ) ; } int main ( ) { string S = " TTWWW " ; group_formed ( S ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string ReverseComplement ( string s , int n , int k ) { int rev = ( k + 1 ) / 2 ; int complement = k - rev ; if ( rev % 2 ) reverse ( s . begin ( ) , s . end ( ) ) ; if ( complement % 2 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } } return s ; } int main ( ) { string str = "10011" ; int k = 5 ; int n = str . size ( ) ; cout << ReverseComplement ( str , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool repeatingString ( string s , int n , int k ) { if ( n % k != 0 ) { return false ; } int frequency [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; } int main ( ) { string s = " abcdcba " ; int n = s . size ( ) ; int k = 3 ; if ( repeatingString ( s , n , k ) ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; void printValue ( char digit ) { switch ( digit ) { case '0' : cout << " Zero ▁ " ; break ; case '1' : cout << " One ▁ " ; break ; case '2' : cout << " Two ▁ " ; break ; case '3' : cout << " Three ▁ " ; break ; case '4' : cout << " Four ▁ " ; break ; case '5' : cout << " Five ▁ " ; break ; case '6' : cout << " Six ▁ " ; break ; case '7' : cout << " Seven ▁ " ; break ; case '8' : cout << " Eight ▁ " ; break ; case '9' : cout << " Nine ▁ " ; break ; } } void printWord ( string N ) { int i , length = N . length ( ) ; for ( i = 0 ; i < length ; i ++ ) { printValue ( N [ i ] ) ; } } int main ( ) { string N = "123" ; printWord ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double jaro_distance ( string s1 , string s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; int max_dist = floor ( max ( len1 , len2 ) / 2 ) - 1 ; int match = 0 ; int hash_s1 [ s1 . length ( ) ] = { 0 } , hash_s2 [ s2 . length ( ) ] = { 0 } ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = max ( 0 , i - max_dist ) ; j < min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; } int main ( ) { string s1 = " CRATE " , s2 = " TRACE " ; cout << jaro_distance ( s1 , s2 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSwaps ( string s , int k ) { int ans = 0 ; int c_one = 0 , c_zero = 0 ; for ( int i = s . size ( ) - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) c_one ++ ; if ( s [ i ] == '0' ) c_zero ++ , ans += c_one ; if ( c_zero == k ) break ; } if ( c_zero < k ) return -1 ; return ans ; } int main ( ) { string s = "100111" ; int k = 2 ; cout << findMinSwaps ( s , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { char data ; Node * left , * right ; Node ( char _val ) { data = _val ; left = right = NULL ; } } ; Node * addinBT ( Node * root , char data ) { if ( root == NULL ) { root = new Node ( data ) ; } else { queue < Node * > Q ; Q . push ( root ) ; while ( ! Q . empty ( ) ) { Node * temp = Q . front ( ) ; Q . pop ( ) ; if ( temp -> left == NULL ) { temp -> left = new Node ( data ) ; break ; } else Q . push ( temp -> left ) ; if ( temp -> right == NULL ) { temp -> right = new Node ( data ) ; break ; } else Q . push ( temp -> right ) ; } } return root ; } void print ( Node * root ) { queue < Node * > Q ; Q . push ( root ) ; while ( Q . size ( ) ) { Node * temp = Q . front ( ) ; Q . pop ( ) ; cout << temp -> data ; if ( temp -> left ) Q . push ( temp -> left ) ; if ( temp -> right ) Q . push ( temp -> right ) ; } } bool checkvowel ( char ch ) { ch = tolower ( ch ) ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) { return true ; } else { return false ; } } Node * removevowels ( Node * root ) { queue < Node * > Q ; Q . push ( root ) ; Node * root1 = NULL ; while ( ! Q . empty ( ) ) { Node * temp = Q . front ( ) ; Q . pop ( ) ; if ( ! checkvowel ( temp -> data ) ) { root1 = addinBT ( root1 , temp -> data ) ; } if ( temp -> left ) { Q . push ( temp -> left ) ; } if ( temp -> right ) { Q . push ( temp -> right ) ; } } return root1 ; } int main ( ) { string s = " geeks " ; Node * root = NULL ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) { root = addinBT ( root , s [ i ] ) ; } root = removevowels ( root ) ; print ( root ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  2 NEW_LINE bool isVowel ( char ch ) { return ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) ; } void performQueries ( string str , int len , int queries [ ] [ N ] , int q ) { int pre [ len ] ; if ( isVowel ( str [ 0 ] ) ) pre [ 0 ] = 1 ; else pre [ 0 ] = 0 ; for ( int i = 1 ; i < len ; i ++ ) { if ( isVowel ( str [ i ] ) ) pre [ i ] = 1 + pre [ i - 1 ] ; else pre [ i ] = pre [ i - 1 ] ; } for ( int i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 0 ) { cout << pre [ queries [ i ] [ 1 ] ] << " STRNEWLINE " ; } else { cout << ( pre [ queries [ i ] [ 1 ] ] - pre [ queries [ i ] [ 0 ] - 1 ] ) << " STRNEWLINE " ; } } } int main ( ) { string str = " geeksforgeeks " ; int len = str . length ( ) ; int queries [ ] [ N ] = { { 1 , 3 } , { 2 , 4 } , { 1 , 9 } } ; int q = ( sizeof ( queries ) / sizeof ( queries [ 0 ] ) ) ; performQueries ( str , len , queries , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxN  20 NEW_LINE #define maxM  64 NEW_LINE int cntSplits ( string s ) { if ( s [ s . size ( ) - 1 ] == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) c_zero += ( s [ i ] == '0' ) ; return ( int ) pow ( 2 , c_zero - 1 ) ; } int main ( ) { string s = "10010" ; cout << cntSplits ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string decToBinary ( int n ) { int binaryNum [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } string binary = " " ; for ( int j = i - 1 ; j >= 0 ; j -- ) binary += to_string ( binaryNum [ j ] ) ; return binary ; } int countFreq ( string & pat , string & txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { res ++ ; j = 0 ; } } return res ; } void findOccurrence ( int arr [ ] , int n , string pattern ) { for ( int i = 0 ; i < n ; i ++ ) { string binary = decToBinary ( arr [ i ] ) ; cout << countFreq ( pattern , binary ) << " ▁ " ; } } int main ( ) { int arr [ ] = { 5 , 106 , 7 , 8 } ; string pattern = "10" ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findOccurrence ( arr , n , pattern ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_winner ( string str , int n ) { string str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str [ i ] ; } else { str2 += str [ i ] ; } } sort ( str1 . begin ( ) , str1 . end ( ) ) ; sort ( str2 . begin ( ) , str2 . end ( ) ) ; if ( str1 < str2 ) cout << " A " ; else if ( str2 < str1 ) cout << " B " ; else cout << " Tie " ; } int main ( ) { string str = " geeksforgeeks " ; int n = str . length ( ) ; find_winner ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } string duplicateVowels ( string str ) { int t = str . length ( ) ; string res = " " ; for ( int i = 0 ; i < t ; i ++ ) { if ( isVowel ( str [ i ] ) ) { res += str [ i ] ; } res += str [ i ] ; } return res ; } int main ( ) { string str = " helloworld " ; cout << " Original ▁ String : ▁ " << str << endl ; string res = duplicateVowels ( str ) ; cout << " String ▁ with ▁ Vowels ▁ duplicated : ▁ " << res << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string replacePi ( string s ) { if ( s . length ( ) == 0 || s . length ( ) == 1 ) return s ; if ( s [ 0 ] == ' p ' && s [ 1 ] == ' i ' ) { string smallOutput = replacePi ( s . substr ( 2 ) ) ; return "3.14" + smallOutput ; } else { return s [ 0 ] + replacePi ( s . substr ( 1 ) ) ; } } int main ( ) { string s = " pipppiiipi " ; string result = replacePi ( s ) ; cout << result << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE int largestSubSeq ( string arr [ ] , int n ) { int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { string str = arr [ i ] ; bool hash [ MAX ] = { 0 } ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str [ j ] - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } return * ( max_element ( count , count + MAX ) ) ; } int main ( ) { string arr [ ] = { " ab " , " bc " , " de " } ; int n = sizeof ( arr ) / sizeof ( string ) ; cout << largestSubSeq ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; set < string > stringSet ; void find_permutation ( string & str1 , string & str2 , int len1 , int len2 , int i , int j , string res ) { if ( res . length ( ) == len1 + len2 ) { stringSet . insert ( res ) ; return ; } if ( i < len1 ) find_permutation ( str1 , str2 , len1 , len2 , i + 1 , j , res + str1 [ i ] ) ; if ( j < len2 ) find_permutation ( str1 , str2 , len1 , len2 , i , j + 1 , res + str2 [ j ] ) ; } void print_set ( ) { set < string > :: iterator itr ; for ( itr = stringSet . begin ( ) ; itr != stringSet . end ( ) ; itr ++ ) cout << ( * itr ) << endl ; } int main ( ) { string str1 = " aa " , str2 = " ab " ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; find_permutation ( str1 , str2 , len1 , len2 , 0 , 0 , " " ) ; print_set ( ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSubStr ( string s , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 2 ; ) { if ( s [ i ] == '0' && s [ i + 1 ] == '1' && s [ i + 2 ] == '0' ) { count ++ ; i += 3 ; } else if ( s [ i ] == '1' && s [ i + 1 ] == '0' && s [ i + 2 ] == '1' ) { count ++ ; i += 3 ; } else { i ++ ; } } return count ; } int main ( ) { string s = "10101010101" ; int n = s . length ( ) ; cout << countSubStr ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countTotalDistinct ( string str ) { int cnt = 0 ; set < string > items ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { string temp = " " ; set < char > ans ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str [ j ] ; ans . insert ( str [ j ] ) ; if ( items . find ( temp ) == items . end ( ) ) { items . insert ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; } int main ( ) { string str = " ABCA " ; cout << countTotalDistinct ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverse ( char k [ ] ) { stack < char * > s ; char * token = strtok ( k , " ▁ " ) ; while ( token != NULL ) { s . push ( token ) ; token = strtok ( NULL , " ▁ " ) ; } while ( ! s . empty ( ) ) { cout << s . top ( ) << " ▁ " ; s . pop ( ) ; } } int main ( ) { char k [ ] = " geeks ▁ for ▁ geeks " ; reverse ( k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalin ( int i , int j , int k , int l , int p , int q , string s ) { int start = i , end = q ; while ( start < end ) { if ( s [ start ] != s [ end ] ) return false ; start ++ ; if ( start == j + 1 ) start = k ; end -- ; if ( end == p - 1 ) end = l ; } return true ; } int countSubStr ( string s ) { int count = 0 ; int n = s . size ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k ; l < n - 1 ; l ++ ) { for ( int p = l + 1 ; p < n ; p ++ ) { for ( int q = p ; q < n ; q ++ ) { if ( isPalin ( i , j , k , l , p , q , s ) ) { count ++ ; } } } } } } } return count ; } int main ( ) { string s = " abca " ; cout << countSubStr ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 256 ; static string lastNonRepeating ( string str , int n ) { int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . at ( i ) ] ++ ; for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = str . at ( i ) ; if ( freq [ ch ] == 1 ) { string res ; res += ch ; return res ; } } return " - 1" ; } int main ( ) { string str = " GeeksForGeeks " ; int n = str . size ( ) ; cout << lastNonRepeating ( str , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE int performQueries ( int l , int r , int prefix [ N ] [ 26 ] ) { l -- ; r -- ; bool flag = false ; int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = prefix [ r ] [ i ] ; if ( l > 0 ) cnt -= prefix [ l - 1 ] [ i ] ; if ( cnt % 2 == 1 ) { flag = true ; count += cnt - 1 ; } else count += cnt ; } if ( flag ) count += 1 ; return count ; } void preCalculate ( string s , int prefix [ N ] [ 26 ] ) { int n = s . size ( ) ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] [ s [ i ] - ' a ' ] ++ ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) prefix [ i ] [ j ] += prefix [ i - 1 ] [ j ] ; } } int main ( ) { string s = " amim " ; int prefix [ N ] [ 26 ] ; memset ( prefix , 0 , sizeof prefix ) ; preCalculate ( s , prefix ) ; int queries [ ] [ 2 ] = { { 1 , 4 } , { 3 , 4 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) { cout << performQueries ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , prefix ) << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string FirstAndLast ( string str ) { string ch = str ; for ( int i = 0 ; i < ch . length ( ) ; i ++ ) { int k = i ; while ( i < ch . length ( ) && ch [ i ] != ' ▁ ' ) i ++ ; ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return ch ; } int main ( ) { string str = " Geeks ▁ for ▁ Geeks " ; cout << str << " STRNEWLINE " ; cout << FirstAndLast ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > compute_lps ( string s ) { int n = s . size ( ) ; vector < int > lps ( n ) ; int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } void Longestsubstring ( string s ) { vector < int > lps = compute_lps ( s ) ; int n = s . size ( ) ; if ( lps [ n - 1 ] == 0 ) { cout << -1 ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { cout << s . substr ( 0 , lps [ i ] ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) cout << -1 ; else cout << s . substr ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ; } int main ( ) { string s = " fixprefixsuffix " ; Longestsubstring ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findMaxLenEven ( string str ) { int n = str . length ( ) ; int i = 0 ; int currlen = 0 ; int maxlen = 0 ; int st = -1 ; while ( i < n ) { if ( str [ i ] == ' ▁ ' ) { if ( currlen % 2 == 0 ) { if ( maxlen < currlen ) { maxlen = currlen ; st = i - currlen ; } } currlen = 0 ; } else { currlen ++ ; } i ++ ; } if ( currlen % 2 == 0 ) { if ( maxlen < currlen ) { maxlen = currlen ; st = i - currlen ; } } if ( st == -1 ) return " - 1" ; return str . substr ( st , maxlen ) ; } int main ( ) { string str = " this ▁ is ▁ a ▁ test ▁ string " ; cout << findMaxLenEven ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findMinLenStr ( string str , int k ) { int n = str . length ( ) ; int st = 0 ; int end = 0 ; int cnt [ 26 ] ; memset ( cnt , 0 , sizeof ( cnt ) ) ; int distEle = 0 ; int currlen ; int minlen = n ; int startInd = -1 ; while ( end < n ) { cnt [ str [ end ] - ' a ' ] ++ ; if ( cnt [ str [ end ] - ' a ' ] == 1 ) distEle ++ ; if ( distEle > k ) { while ( st < end && distEle > k ) { if ( cnt [ str [ st ] - ' a ' ] == 1 ) distEle -- ; cnt [ str [ st ] - ' a ' ] -- ; st ++ ; } } if ( distEle == k ) { while ( st < end && cnt [ str [ st ] - ' a ' ] > 1 ) { cnt [ str [ st ] - ' a ' ] -- ; st ++ ; } currlen = end - st + 1 ; if ( currlen < minlen ) { minlen = currlen ; startInd = st ; } } end ++ ; } return str . substr ( startInd , minlen ) ; } int main ( ) { string str = " efecfefd " ; int k = 4 ; cout << findMinLenStr ( str , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalPairs ( string s1 , string s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( int ( s1 [ i ] ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( int ( s2 [ i ] ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } int main ( ) { string s1 = " geeks " , s2 = " for " ; cout << totalPairs ( s1 , s2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Preprocess ( string A , string B ) { int n = A . size ( ) ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { map < char , int > mp ; mp [ A [ i ] ] ++ ; mp [ A [ n - i - 1 ] ] ++ ; mp [ B [ i ] ] ++ ; mp [ B [ n - i - 1 ] ] ++ ; int sz = mp . size ( ) ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ) ; else if ( sz == 2 ) ans += mp [ A [ i ] ] != 2 ; } if ( n % 2 == 1 && A [ n / 2 ] != B [ n / 2 ] ) ans ++ ; return ans ; } int main ( ) { string A = " abacaba " , B = " bacabaa " ; cout << Preprocess ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printPattern ( char s [ ] , int n ) { cout << s << " STRNEWLINE " ; int i = 0 , j = n - 2 ; while ( i < j ) { char c = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = c ; i ++ ; j -- ; } i = 0 ; j = n - 2 ; while ( j - i > 1 ) { s [ i ] = s [ j ] = ' * ' ; cout << s << " STRNEWLINE " ; i ++ ; j -- ; } } int main ( ) { char s [ ] = " geeks " ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; printPattern ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char bitToBeFlipped ( string s ) { char last = s [ s . length ( ) - 1 ] ; char first = s [ 0 ] ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } } int main ( ) { string s = "1101011000" ; cout << bitToBeFlipped ( s ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool check ( string s ) { int freq [ 26 ] = { 0 } ; int n = s . length ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s [ i ] - 97 ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( freq [ i ] % 2 == 1 ) return false ; return true ; } int main ( ) { string s = " abaccaba " ; check ( s ) ? cout << " Yes " << endl : cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( string s ) { unordered_map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { m [ s [ i ] ] ++ ; } string new_string = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m [ s [ i ] ] % 2 == 0 ) continue ; new_string += s [ i ] ; } cout << new_string << endl ; } int main ( ) { string s = " aabbbddeeecc " ; solve ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumLength ( string s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ 26 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) arr [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; } int main ( ) { string str = " afddewqd " ; cout << minimumLength ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = INT_MAX ; int minOperation ( string & s , int i , int j , int count ) { if ( ( i >= s . size ( ) && j < 0 ) || ( i == j ) ) return MAX ; if ( s [ i ] == s [ j ] ) return count ; if ( i >= s . size ( ) ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; } int main ( ) { string s = " bacdefghipalop " ; int ans = minOperation ( s , 0 , s . size ( ) - 1 , 0 ) ; if ( ans == MAX ) cout << -1 ; else cout << ans ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; void frequency ( int fre [ ] [ MAX_CHAR ] , string s [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { string str = s [ i ] ; for ( int j = 0 ; j < str . size ( ) ; j ++ ) fre [ i ] [ str [ j ] - ' a ' ] ++ ; } } void LongestSequence ( int fre [ ] [ MAX_CHAR ] , int n ) { for ( int i = MAX_CHAR - 1 ; i >= 0 ; i -- ) { int mi = fre [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; j ++ ) mi = min ( fre [ j ] [ i ] , mi ) ; while ( mi -- ) cout << ( char ) ( ' a ' + i ) ; } } int main ( ) { string s [ ] = { " loo " , " lol " , " olive " } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; int fre [ n ] [ 26 ] = { 0 } ; frequency ( fre , s , n ) ; LongestSequence ( fre , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minimumFlip ( string s , int x , int y ) { s = s + s ; bool isOpposite = false ; if ( x > y ) { swap ( x , y ) ; isOpposite = true ; } int valClockwise = 0 ; char cur = s [ x ] ; for ( int i = x ; i <= y ; i ++ ) { if ( s [ i ] != cur ) { cur = s [ i ] ; valClockwise ++ ; } } int valAnticlockwise = 0 ; cur = s [ y ] ; x += s . length ( ) ; for ( int i = y ; i <= x ; i ++ ) { if ( s [ i ] != cur ) { cur = s [ i ] ; valAnticlockwise ++ ; } } if ( valClockwise <= valAnticlockwise ) { if ( ! isOpposite ) cout << " Clockwise ▁ " << valClockwise << endl ; else cout << " Anti - clockwise ▁ " << valAnticlockwise << endl ; } else { if ( ! isOpposite ) cout << " Anti - clockwise ▁ " << valAnticlockwise << endl ; else cout << " Clockwise ▁ " << valClockwise << endl ; } } int main ( ) { int x = 0 , y = 8 ; string s = "000110" ; minimumFlip ( s , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string LexicographicalMaxString ( string str ) { char maxchar = ' a ' ; vector < int > index ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] >= maxchar ) { maxchar = str [ i ] ; index . push_back ( i ) ; } } string maxstring = " " ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( str . substr ( index [ i ] , str . length ( ) ) > maxstring ) { maxstring = str . substr ( index [ i ] , str . length ( ) ) ; } } return maxstring ; } int main ( ) { string str = " acbacbc " ; cout << LexicographicalMaxString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; struct Node { string c ; struct Node * next ; } ; struct Node * newNode ( string c ) { Node * temp = new Node ; temp -> c = c ; temp -> next = NULL ; return temp ; } ; void reverse_word ( string & str ) { reverse ( str . begin ( ) , str . end ( ) ) ; } void reverse ( struct Node * head ) { struct Node * ptr = head ; while ( ptr != NULL ) { reverse_word ( ptr -> c ) ; ptr = ptr -> next ; } } void printList ( struct Node * head ) { while ( head != NULL ) { cout << head -> c << " ▁ " ; head = head -> next ; } } int main ( ) { Node * head = newNode ( " Geeksforgeeks " ) ; head -> next = newNode ( " a " ) ; head -> next -> next = newNode ( " computer " ) ; head -> next -> next -> next = newNode ( " science " ) ; head -> next -> next -> next -> next = newNode ( " portal " ) ; head -> next -> next -> next -> next -> next = newNode ( " for " ) ; head -> next -> next -> next -> next -> next -> next = newNode ( " geeks " ) ; cout << " List ▁ before ▁ reverse : ▁ STRNEWLINE " ; printList ( head ) ; reverse ( head ) ; cout << " List after reverse : " ; printList ( head ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void binary_conversion ( string & s , int m ) { while ( m ) { int tmp = m % 2 ; s += tmp + '0' ; m = m / 2 ; } reverse ( s . begin ( ) , s . end ( ) ) ; } int find_character ( int n , int m , int i ) { string s ; binary_conversion ( s , m ) ; string s1 = " " ; for ( int x = 0 ; x < n ; x ++ ) { for ( int y = 0 ; y < s . length ( ) ; y ++ ) { if ( s [ y ] == '1' ) s1 += "10" ; else s1 += "01" ; } s = s1 ; s1 = " " ; } return s [ i ] - '0' ; } int main ( ) { int m = 5 , n = 2 , i = 8 ; cout << find_character ( n , m , i ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubSequence ( string s , int num ) { int res = 0 ; int i = 0 ; while ( num ) { if ( num & 1 ) res += s [ i ] - '0' ; i ++ ; num = num >> 1 ; } return res ; } int combinedSum ( string s ) { int n = s . length ( ) ; int c_sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; } int main ( ) { string s = "123" ; cout << combinedSum ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void solve ( string s ) { int l = s . length ( ) ; int x = l / 2 ; int y = l ; string p = " " ; while ( x > 0 && y > l / 2 ) { p += s [ x - 1 ] ; x -- ; p += s [ y - 1 ] ; y -- ; } if ( y > l / 2 ) { p += s [ y - 1 ] ; y -- ; } cout << p ; } int main ( ) { string s = " sunshine " ; solve ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  26 NEW_LINE void printAnagramAndChanges ( string X , string Y ) { int countx [ MAX ] = { 0 } , county [ MAX ] = { 0 } , ctrx [ MAX ] = { 0 } , ctry [ MAX ] = { 0 } ; int change = 0 ; int l = X . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { countx [ X [ i ] - ' A ' ] ++ ; county [ Y [ i ] - ' A ' ] ++ ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( countx [ i ] > county [ i ] ) ctrx [ i ] += ( countx [ i ] - county [ i ] ) ; else if ( countx [ i ] < county [ i ] ) ctry [ i ] += ( county [ i ] - countx [ i ] ) ; change += abs ( county [ i ] - countx [ i ] ) ; } for ( int i = 0 ; i < l ; i ++ ) { if ( ctrx [ X [ i ] - ' A ' ] == 0 ) continue ; int j ; for ( j = 0 ; j < MAX ; j ++ ) if ( ( ctry [ j ] ) > 0 ) break ; if ( countx [ X [ i ] - ' A ' ] == ctrx [ X [ i ] - ' A ' ] X [ i ] - ' A ' > j ) { countx [ X [ i ] - ' A ' ] -- ; ctrx [ X [ i ] - ' A ' ] -- ; ctry [ j ] -- ; X [ i ] = ' A ' + j ; } else countx [ X [ i ] - ' A ' ] -- ; } cout << " Anagram ▁ : ▁ " << X << endl ; cout << " Number ▁ of ▁ changes ▁ made ▁ : ▁ " << change / 2 ; } int main ( ) { string x = " CDBABC " , y = " ADCABD " ; printAnagramAndChanges ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOccurrences ( char * str , string word ) { char * p ; vector < string > a ; p = strtok ( str , " ▁ " ) ; while ( p != NULL ) { a . push_back ( p ) ; p = strtok ( NULL , " ▁ " ) ; } int c = 0 ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) if ( word == a [ i ] ) c ++ ; return c ; } int main ( ) { char str [ ] = " GeeksforGeeks ▁ A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks ▁ " ; string word = " portal " ; cout << countOccurrences ( str , word ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < string > splitStrings ( string str , char dl ) { string word = " " ; int num = 0 ; str = str + dl ; int l = str . size ( ) ; vector < string > substr_list ; for ( int i = 0 ; i < l ; i ++ ) { if ( str [ i ] != dl ) word = word + str [ i ] ; else { if ( ( int ) word . size ( ) != 0 ) substr_list . push_back ( word ) ; word = " " ; } } return substr_list ; } int main ( ) { string str = " geeks ; for ; geeks " ; char dl = ' ; ' ; vector < string > res = splitStrings ( str , dl ) ; for ( auto x : res ) cout << x << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubseq ( string s ) { int n = s . length ( ) ; int pre_count_0 [ n + 2 ] ; int pre_count_1 [ n + 1 ] ; int post_count_0 [ n + 1 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s [ j - 1 ] == '0' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s [ n - j ] == '0' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; } int main ( ) { string s = "000011100000" ; cout << longestSubseq ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool shouldSwap ( char str [ ] , int start , int curr ) { for ( int i = start ; i < curr ; i ++ ) if ( str [ i ] == str [ curr ] ) return 0 ; return 1 ; } void findPermutations ( char str [ ] , int index , int n ) { if ( index >= n ) { cout << str << endl ; return ; } for ( int i = index ; i < n ; i ++ ) { bool check = shouldSwap ( str , index , i ) ; if ( check ) { swap ( str [ index ] , str [ i ] ) ; findPermutations ( str , index + 1 , n ) ; swap ( str [ index ] , str [ i ] ) ; } } } int main ( ) { char str [ ] = " ABCA " ; int n = strlen ( str ) ; findPermutations ( str , 0 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 256 ; int maximumChars ( string & str ) { int n = str . length ( ) ; int res = -1 ; int firstInd [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = -1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str [ i ] ] ; if ( first_ind == -1 ) firstInd [ str [ i ] ] = i ; else res = max ( res , abs ( i - first_ind - 1 ) ) ; } return res ; } int main ( ) { string str = " abba " ; cout << maximumChars ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValid ( string p ) { int n = p . length ( ) ; int c1 = 0 , c0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] == '0' ) c0 ++ ; if ( p [ i ] == '1' ) c1 ++ ; } return ( c0 == c1 ) ? true : false ; } int longestSub ( string s ) { int max_len = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( isValid ( s . substr ( i , j - i + 1 ) ) && max_len < j - i + 1 ) max_len = j - i + 1 ; } } return max_len ; } int main ( ) { string s = "101001000" ; cout << longestSub ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 256 ; void printDuo ( string & str ) { int countChar [ MAX_CHAR ] = { 0 } ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) countChar [ str [ i ] - ' a ' ] ++ ; string str1 = " " , str2 = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( countChar [ i ] > 1 ) str2 = str2 + ( char ) ( i + ' a ' ) ; else if ( countChar [ i ] == 1 ) str1 = str1 + ( char ) ( i + ' a ' ) ; } cout << " String ▁ with ▁ characters ▁ occurring ▁ " << " once : STRNEWLINE " ; cout << str1 << " STRNEWLINE " ; cout << " String ▁ with ▁ characters ▁ occurring ▁ " << " multiple ▁ times : STRNEWLINE " ; cout << str2 << " STRNEWLINE " ; } int main ( ) { string str = " lovetocode " ; printDuo ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <string.h> NEW_LINE using namespace std ; int findRepeatFirstN2 ( char * s ) { int p = -1 , i , j ; for ( i = 0 ; i < strlen ( s ) ; i ++ ) { for ( j = i + 1 ; j < strlen ( s ) ; j ++ ) { if ( s [ i ] == s [ j ] ) { p = i ; break ; } } if ( p != -1 ) break ; } return p ; } int main ( ) { char str [ ] = " geeksforgeeks " ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == -1 ) cout << " Not ▁ found " ; else cout << str [ pos ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ; char stringPalindrome ( string A , string B ) { int countA [ MAX_CHAR ] = { 0 } ; int countB [ MAX_CHAR ] = { 0 } ; int l1 = A . length ( ) , l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' A ' ; return ' B ' ; } int main ( ) { string a = " abcdea " ; string b = " bcdesg " ; cout << stringPalindrome ( a , b ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findLen ( string & A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ; while ( r < n ) { if ( A [ r ] != ch ) ++ cnt ; while ( cnt > k ) { if ( A [ l ] != ch ) -- cnt ; ++ l ; } maxlen = max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; } int answer ( string & A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = max ( maxlen , findLen ( A , n , k , i + ' A ' ) ) ; maxlen = max ( maxlen , findLen ( A , n , k , i + ' a ' ) ) ; } return maxlen ; } int main ( ) { int n = 5 , k = 2 ; string A = " ABABA " ; cout << " Maximum ▁ length ▁ = ▁ " << answer ( A , n , k ) << endl ; n = 6 , k = 4 ; string B = " HHHHHH " ; cout << " Maximum ▁ length ▁ = ▁ " << answer ( B , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int replaceDig ( int x , int from , int to ) { int result = 0 ; int multiply = 1 ; while ( x > 0 ) { int reminder = x % 10 ; if ( reminder == from ) result = result + to * multiply ; else result = result + reminder * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; } void calculateMinMaxSum ( int x1 , int x2 ) { int minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) ; int maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) ; cout << " Minimum ▁ sum ▁ = ▁ " << minSum ; cout << " nMaximum ▁ sum ▁ = ▁ " << maxSum ; } int main ( ) { int x1 = 5466 , x2 = 4555 ; calculateMinMaxSum ( x1 , x2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findTwoscomplement ( string str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str [ i ] == '1' ) break ; if ( i == -1 ) return '1' + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str [ k ] == '1' ) str [ k ] = '0' ; else str [ k ] = '1' ; } return str ; ; } int main ( ) { string str = "00000101" ; cout << findTwoscomplement ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isPerfect ( int x ) { int sum_div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; } void subsetSum ( int arr [ ] , int n ) { long long total = 1 << n ; for ( long long i = 0 ; i < total ; i ++ ) { long long sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( i & ( 1 << j ) ) sum += arr [ j ] ; if ( isPerfect ( sum ) ) { cout << sum << " ▁ " ; } } } int main ( ) { int arr [ ] = { 5 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; subsetSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkUntil ( int num , int K , int N , vector < int > & ans ) { if ( N == 1 ) { ans . push_back ( num ) ; return ; } if ( ( num % 10 + K ) <= 9 ) checkUntil ( 10 * num + ( num % 10 + K ) , K , N - 1 , ans ) ; if ( K ) { if ( ( num % 10 - K ) >= 0 ) checkUntil ( 10 * num + num % 10 - K , K , N - 1 , ans ) ; } } void check ( int K , int N , vector < int > & ans ) { for ( int i = 1 ; i <= 9 ; i ++ ) { checkUntil ( i , K , N , ans ) ; } } void print ( vector < int > & ans ) { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] << " , ▁ " ; } } int main ( ) { int N = 4 , K = 8 ; vector < int > ans ; check ( K , N , ans ) ; print ( ans ) ; return 0 ; }
#include <stdio.h> NEW_LINE #define N  4 NEW_LINE bool solveMazeUtil ( int maze [ N ] [ N ] , int x , int y , int sol [ N ] [ N ] ) ; void printSolution ( int sol [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) printf ( " ▁ % d ▁ " , sol [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } } bool isSafe ( int maze [ N ] [ N ] , int x , int y ) { if ( x >= 0 && x < N && y >= 0 && y < N && maze [ x ] [ y ] != 0 ) return true ; return false ; } bool solveMaze ( int maze [ N ] [ N ] ) { int sol [ N ] [ N ] = { { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; if ( solveMazeUtil ( maze , 0 , 0 , sol ) == false ) { printf ( " Solution ▁ doesn ' t ▁ exist " ) ; return false ; } printSolution ( sol ) ; return true ; } bool solveMazeUtil ( int maze [ N ] [ N ] , int x , int y , int sol [ N ] [ N ] ) { if ( x == N - 1 && y == N - 1 ) { sol [ x ] [ y ] = 1 ; return true ; } if ( isSafe ( maze , x , y ) == true ) { sol [ x ] [ y ] = 1 ; for ( int i = 1 ; i <= maze [ x ] [ y ] && i < N ; i ++ ) { if ( solveMazeUtil ( maze , x + i , y , sol ) == true ) return true ; if ( solveMazeUtil ( maze , x , y + i , sol ) == true ) return true ; } sol [ x ] [ y ] = 0 ; return false ; } return false ; } int main ( ) { int maze [ N ] [ N ] = { { 2 , 1 , 0 , 0 } , { 3 , 0 , 0 , 1 } , { 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 1 } } ; solveMaze ( maze ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define maxSize  50 NEW_LINE using namespace std ; vector < vector < double > > matrix_product ( vector < vector < double > > a , vector < vector < double > > b ) { vector < vector < double > > c ( 7 ) ; for ( int i = 0 ; i < 7 ; i ++ ) c [ i ] . resize ( 7 , 0 ) ; for ( int i = 0 ; i < 7 ; i ++ ) for ( int j = 0 ; j < 7 ; j ++ ) for ( int k = 0 ; k < 7 ; k ++ ) c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; return c ; } vector < vector < double > > mul_expo ( vector < vector < double > > mul , int p ) { vector < vector < double > > s = { { 1 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } } ; while ( p != 1 ) { if ( p % 2 == 1 ) s = matrix_product ( s , mul ) ; mul = matrix_product ( mul , mul ) ; p /= 2 ; } return matrix_product ( mul , s ) ; } double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 6 ) return 6 ; vector < vector < double > > mul = { { ( double ) 7 / 6 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { ( double ) -1 / 6 , 0 , 0 , 0 , 0 , 0 , 0 } } ; mul = mul_expo ( mul , x - 6 ) ; return ( mul [ 0 ] [ 0 ] + mul [ 1 ] [ 0 ] + mul [ 2 ] [ 0 ] + mul [ 3 ] [ 0 ] + mul [ 4 ] [ 0 ] + mul [ 5 ] [ 0 ] ) * 6 ; } int main ( ) { int n = 10 ; cout << expectedSteps ( n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll F ( ll A , ll B ) { if ( A == 1 ) return ( 4 % B ) ; else { ll temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } } int main ( ) { ll A = 25 , B = 50 ; cout << F ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return -1 ; } int main ( ) { int arr [ ] = { 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int index = binarySearch ( arr , 1 , n - 2 ) ; if ( index != -1 ) cout << arr [ index ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int isPossibleToReach ( int A [ ] , int N , int X , int Y ) { double distance = sqrt ( double ( X * X + Y * Y ) ) ; double mx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { mx += double ( A [ i ] ) ; } if ( mx < distance ) { cout << " NO " ; return 0 ; } if ( ( mx - distance ) < 0.000001 ) { cout << " YES " ; return 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( distance + mx < double ( 2 ) * double ( A [ i ] ) ) { cout << " No " ; return 0 ; } } cout << " Yes " ; return 0 ; } int main ( ) { int A [ ] = { 2 , 5 } ; int X = 5 , Y = 4 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; isPossibleToReach ( A , N , X , Y ) ; return 0 ; }
#include <cmath> NEW_LINE #include <iostream> NEW_LINE using namespace std ; double point_distance ( int x1 , int y1 , int x2 , int y2 ) { int p = ( x2 - x1 ) ; int q = ( y2 - y1 ) ; double distance = sqrt ( p * p + q * q ) ; return distance ; } void tangentAngle ( int x1 , int y1 , int x2 , int y2 , double radius ) { double distance = point_distance ( x1 , y1 , x2 , y2 ) ; if ( radius / distance > 1 radius / distance < -1 ) { cout << -1 ; } double result = 2 * asin ( radius / distance ) * 180 / 3.1415 ; cout << result << " ▁ degrees " ; } int main ( ) { int radius = 4 ; int x1 = 7 , y1 = 12 ; int x2 = 3 , y2 = 4 ; tangentAngle ( x1 , y1 , x2 , y2 , radius ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define RADIAN  0.01745329252 NEW_LINE float Area_of_Rhombus ( int a , int theta ) { float area = ( a * a ) * sin ( ( RADIAN * theta ) ) ; return area ; } int main ( ) { int a = 4 ; int theta = 60 ; float ans = Area_of_Rhombus ( a , theta ) ; printf ( " % 0.2f " , ans ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define PI  3.147 NEW_LINE double Length_Diagonal ( int a , int b , double theta ) { double diagonal = sqrt ( ( pow ( a , 2 ) + pow ( b , 2 ) ) - 2 * a * b * cos ( theta * ( PI / 180 ) ) ) ; return diagonal ; } int main ( ) { int a = 3 ; int b = 5 ; double theta = 45 ; double ans = Length_Diagonal ( a , b , theta ) ; printf ( " % .2f " , ans ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumTiles ( int n , int m ) { cout << ( m * n ) / 2 << endl ; } int main ( ) { int M = 3 ; int N = 4 ; maximumTiles ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double find ( double x , double y , vector < vector < int > > & p ) { double mind = 0 ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { double a = p [ i ] [ 0 ] , b = p [ i ] [ 1 ] ; mind += sqrt ( ( x - a ) * ( x - a ) + ( y - b ) * ( y - b ) ) ; } return mind ; } double getMinDistSum ( vector < vector < int > > & p ) { double x = 0 , y = 0 ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) { x += p [ i ] [ 0 ] ; y += p [ i ] [ 1 ] ; } x = x / p . size ( ) ; y = y / p . size ( ) ; double mind = find ( x , y , p ) ; return mind ; } int main ( ) { vector < vector < int > > vec = { { 0 , 1 } , { 1 , 0 } , { 1 , 2 } , { 2 , 1 } } ; double d = getMinDistSum ( vec ) ; cout << d << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i < n + 1 ; i ++ ) res = res * i ; return res ; } int nCr ( int n , int r ) { return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; } int main ( ) { int n = 5 ; cout << ( nCr ( n , 4 ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int areaSquare ( int L , int B ) { int large = max ( L , B ) ; int small = min ( L , B ) ; if ( large >= 2 * small ) return large * large ; else return ( 2 * small ) * ( 2 * small ) ; } int main ( ) { int L = 7 ; int B = 4 ; cout << areaSquare ( L , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double pie = 3.1415926535897 ; double findsolution ( double d , double h , double m , double n ) { double k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return -1 ; double ans = ( h / ( k - n ) ) ; return ans ; } int main ( ) { double d = 1 , h = 1 , m = 1 , n = 1 ; cout << findsolution ( d , h , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int angle ( int n ) { return 2 * n ; } int main ( ) { int n = 30 ; cout << angle ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return true ; return false ; } int main ( ) { int a = 80 , b = 70 , c = 100 , d = 110 ; if ( Valid ( a , b , c , d ) ) cout << " Valid ▁ quadrilateral " ; else cout << " Invalid ▁ quadrilateral " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void lengchord ( int z ) { cout << " The ▁ length ▁ is ▁ " << z << endl ; } int main ( ) { int z = 48 ; lengchord ( z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n ) { int count = 0 ; map < double , int > mp ; for ( int i = 0 ; i < n ; i ++ ) { int y = a [ i ] ; if ( y != 0 && y != 1 ) { double x = ( ( y * 1.0 ) / ( 1 - y ) ) * y ; count += mp [ x ] ; } mp [ y ] ++ ; } return count ; } int main ( ) { int arr [ ] = { -4 , -3 , 0 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool contains ( int num , int K , int base ) { bool isThere = 0 ; while ( num ) { int remainder = num % base ; if ( remainder == K ) { isThere = 1 ; } num /= base ; } return isThere ; } void count ( int n , int k , vector < vector < int > > v ) { int pref [ 1000005 ] = { 0 } ; for ( int i = 1 ; i < 1e6 + 5 ; i ++ ) { bool present = contains ( i , k , 10 ) || contains ( i , k , 8 ) ; pref [ i ] += pref [ i - 1 ] + present ; } for ( int i = 0 ; i < n ; ++ i ) { cout << v [ i ] [ 1 ] - v [ i ] [ 0 ] + 1 - ( pref [ v [ i ] [ 1 ] ] - pref [ v [ i ] [ 0 ] - 1 ] ) << ' ▁ ' ; } } int main ( ) { int K = 7 ; vector < vector < int > > Q = { { 2 , 5 } , { 1 , 15 } } ; int N = Q . size ( ) ; count ( N , K , Q ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pronic ( int num ) { int N = ( int ) sqrt ( num ) ; if ( N * ( N + 1 ) <= num ) { return N ; } return N - 1 ; } int countPronic ( int A , int B ) { return pronic ( B ) - pronic ( A - 1 ) ; } int main ( ) { int A = 3 ; int B = 20 ; cout << countPronic ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumMoves ( int * a , int n ) { int min_element = INT_MAX ; int max_element = INT_MIN ; int min_ind = -1 ; int max_ind = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= min_element ) { min_element = a [ i ] ; min_ind = i ; } if ( a [ i ] > max_element ) { max_element = a [ i ] ; max_ind = i ; } } if ( max_ind == min_ind ) { return 0 ; } else if ( max_ind > min_ind ) { return max_ind + ( n - min_ind - 2 ) ; } else { return max_ind + n - min_ind - 1 ; } } int main ( ) { int arr [ ] = { 35 , 46 , 17 , 23 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumMoves ( arr , N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findIndex ( int arr [ ] , int n , int K ) { int sum = 0 ; int res = -1 ; int mini = 1e9 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = sum - arr [ i ] ; if ( temp % K == 0 ) { if ( res == -1 mini > arr [ i ] ) { res = i + 1 ; mini = arr [ i ] ; } } } return res ; } int main ( ) { int arr [ ] = { 14 , 7 , 8 , 2 , 4 } ; int K = 7 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findIndex ( arr , N , K ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int countSetBits ( int N ) { int count = 0 ; while ( N ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } int main ( ) { int N = 4 ; int bits = countSetBits ( N ) ; cout << " Odd ▁ " << " : ▁ " << pow ( 2 , bits ) << " STRNEWLINE " ; cout << " Even ▁ " << " : ▁ " << N + 1 - pow ( 2 , bits ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long double find_Variance ( int n ) { long long int numerator = n * n - 1 ; long double ans = ( numerator * 1.0 ) / 12 ; return ans ; } int main ( ) { int N = 5 ; cout << fixed << setprecision ( 6 ) << find_Variance ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int arr [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } int sum_odd = 0 , sum_even = 0 ; for ( auto itr = mp . begin ( ) ; itr != mp . end ( ) ; itr ++ ) { if ( itr -> second % 2 != 0 ) sum_odd += ( itr -> first ) * ( itr -> second ) ; if ( itr -> second % 2 == 0 ) sum_even += ( itr -> first ) * ( itr -> second ) ; } int diff = sum_even - sum_odd ; return diff ; } int main ( ) { int arr [ ] = { 1 , 5 , 5 , 2 , 4 , 3 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSum ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSum ( int a , int b , int n ) { if ( n == 1 ) { cout << a ; return ; } int s = a + b ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int x = a xor b ; s += x ; a = b ; b = x ; } cout << s ; } int main ( ) { int a = 2 , b = 5 , N = 8 ; findSum ( a , b , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int onesComplement ( unsigned int n , int maxElement ) { int bits = floor ( log2 ( maxElement ) ) + 1 ; return ( ( 1 << bits ) - 1 ) ^ n ; } int findNumber ( int arr [ ] , int n ) { unsigned int res = 0 ; int maxElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res = res ^ arr [ i ] ; if ( maxElement < arr [ i ] ) maxElement = arr [ i ] ; } res = onesComplement ( res , maxElement ) ; return ( res ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findNumber ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTheGreatestX ( int P , int Q ) { map < int , int > divisiors ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 and Q > 1 ) { Q /= i ; divisiors [ i ] ++ ; } } if ( Q > 1 ) divisiors [ Q ] ++ ; int ans = 0 ; for ( auto i : divisiors ) { int frequency = i . second ; int temp = P ; int cur = 0 ; while ( temp % i . first == 0 ) { temp /= i . first ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . first ; } ans = max ( temp , ans ) ; } cout << ans ; } int main ( ) { int P = 10 , Q = 4 ; findTheGreatestX ( P , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countXORSetBitsAdjElemRange1_N ( int N ) { int total_set_bits = 0 ; int bit_Position = 1 ; while ( N ) { total_set_bits += ( ( N + 1 ) / 2 * bit_Position ) ; N -= ( N + 1 ) / 2 ; bit_Position ++ ; } return total_set_bits ; } int main ( ) { int N = 4 ; cout << countXORSetBitsAdjElemRange1_N ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define size_int  32 NEW_LINE int functionMax ( int arr [ ] , int n ) { vector < int > setBit [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( arr [ i ] & ( 1 << j ) ) setBit [ j ] . push_back ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) { swap ( arr [ 0 ] , arr [ setBit [ i ] [ 0 ] ] ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << functionMax ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int highestPower ( int n ) { return log ( n ) / log ( 2 ) ; } int main ( ) { int n = 15 ; cout << highestPower ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void print ( int N ) { for ( int i = 0 ; i < 100000 ; i ++ ) { if ( pow ( i + 1 , 3 ) - pow ( i , 3 ) == N ) { cout << i << ' ▁ ' << i + 1 ; return ; } } } bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; } bool diffCube ( int N ) { return isPerfectSquare ( 12 * N - 3 ) ; } int main ( ) { int N = 19 ; if ( diffCube ( N ) ) { cout << " Yes STRNEWLINE " ; print ( N ) ; } else { cout << " No STRNEWLINE " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; } int main ( ) { int x = 5 , y = 2 ; if ( is_possible ( x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; class Node { public : int data ; Node * left , * right ; Node ( int data , Node * left , Node * right ) { this -> data = data ; this -> left = left ; this -> right = right ; } } ; Node * newNode ( int data ) { Node * tmp = new Node ( data , NULL , NULL ) ; return tmp ; } void inorder ( Node * node ) { if ( node == NULL ) return ; inorder ( node -> left ) ; cout << node -> data << " ▁ " ; inorder ( node -> right ) ; } Node * MaximumBinaryTree ( Node * t1 , Node * t2 ) { if ( t1 == NULL ) return t2 ; if ( t2 == NULL ) return t1 ; t1 -> data = max ( t1 -> data , t2 -> data ) ; t1 -> left = MaximumBinaryTree ( t1 -> left , t2 -> left ) ; t1 -> right = MaximumBinaryTree ( t1 -> right , t2 -> right ) ; return t1 ; } int main ( ) { Node * root1 = newNode ( 3 ) ; root1 -> left = newNode ( 2 ) ; root1 -> right = newNode ( 6 ) ; root1 -> left -> left = newNode ( 20 ) ; Node * root2 = newNode ( 5 ) ; root2 -> left = newNode ( 1 ) ; root2 -> right = newNode ( 8 ) ; root2 -> left -> right = newNode ( 2 ) ; root2 -> right -> right = newNode ( 8 ) ; Node * root3 = MaximumBinaryTree ( root1 , root2 ) ; inorder ( root3 ) ; }
#include <iostream> NEW_LINE using namespace std ; int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } int main ( ) { int a = 3 , n = 5 ; cout << powerOptimised ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int x , int y ) { if ( x == 0 ) return y ; return gcd ( y % x , x ) ; } int findDistinct ( int arr [ ] , int n ) { int maximum = * max_element ( arr , arr + n ) ; if ( n == 1 ) return 1 ; if ( n == 2 ) { return ( maximum / gcd ( arr [ 0 ] , arr [ 1 ] ) ) ; } int k = gcd ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { k = gcd ( k , arr [ i ] ) ; } return ( maximum / k ) ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findDistinct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define lli  long long int NEW_LINE void isEqualFactors ( lli N ) { lli ev_count = 0 , od_count = 0 ; for ( lli i = 1 ; i <= sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count == od_count ) cout << " YES " << endl ; else cout << " NO " << endl ; } int main ( ) { lli N = 10 ; isEqualFactors ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxOR ( int arr [ ] , int n ) { int max_value = * max_element ( arr , arr + n ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; } int main ( ) { int arr [ ] = { 3 , 6 , 8 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxOR ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; } bool checkAbundant ( int n ) { return ( getSum ( n ) - n > n ) ; } bool isDeficient ( int n ) { return ( getSum ( n ) < ( 2 * n ) ) ; } bool checkPrimitiveAbundant ( int num ) { if ( ! checkAbundant ( num ) ) { return false ; } for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 && i != num ) { if ( i * i == num ) { if ( ! isDeficient ( i ) ) { return false ; } } else if ( ! isDeficient ( i ) || ! isDeficient ( num / i ) ) { return false ; } } } return true ; } int main ( ) { int n = 20 ; if ( checkPrimitiveAbundant ( n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divSum ( int num ) { int result = 0 ; for ( int i = 1 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result - 1 - num ) ; } int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; n = n / 10 ; } return sum ; } bool isCanada ( int n ) { return divSum ( n ) == getSum ( n ) ; } int main ( ) { int n = 125 ; if ( isCanada ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countEle ( int a [ ] , int n ) { int len = 0 ; unordered_map < int , int > hmap ; for ( int i = 0 ; i < n ; i ++ ) { len = max ( len , a [ i ] ) ; hmap [ a [ i ] ] ++ ; } bool v [ len + 1 ] ; for ( int i = 0 ; i <= len ; i ++ ) { v [ i ] = true ; } for ( int i = 0 ; i < n ; i ++ ) { if ( v [ a [ i ] ] == false ) continue ; for ( int j = 2 * a [ i ] ; j <= len ; j += a [ i ] ) { v [ j ] = false ; } } int count = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { if ( v [ i ] == true && hmap . count ( i ) == 1 && hmap [ i ] == 1 ) { count += 1 ; } } return count ; } int main ( ) { int arr [ ] = { 86 , 45 , 18 , 4 , 8 , 28 , 19 , 33 , 2 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << countEle ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } int main ( ) { int N = 6 ; int K = 11 ; cout << maxAdjacentDifference ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPal ( int a [ 3 ] [ 3 ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; } int main ( ) { int n = 3 , m = 3 ; int a [ 3 ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( isPal ( a , n , m ) ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } bool isUntouchable ( int n ) { for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( divSum ( i ) == n ) return false ; } return true ; } int main ( ) { int N = 52 ; if ( isUntouchable ( n ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gonNum120 ( int n ) { return ( 118 * n * n - 116 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << gonNum120 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void constructArray ( int N ) { int arr [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " , ▁ " ; } } int main ( ) { int N = 6 ; constructArray ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPair ( int x ) { int lim = 120 ; for ( int i = - lim ; i <= lim ; i ++ ) { for ( int j = - lim ; j <= lim ; j ++ ) { if ( pow ( i , 5 ) - pow ( j , 5 ) == x ) { cout << i << ' ▁ ' << j << endl ; return ; } } } cout << " - 1" ; } signed main ( ) { int X = 33 ; findPair ( X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; } bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; } bool checkDigits ( int n ) { while ( n ) { int dig = n % 10 ; if ( dig == 4 && dig == 6 && dig == 7 && dig == 9 ) return false ; n /= 10 ; } return true ; } int isFullfibonacci ( int n ) { return ( checkDigits ( n ) && isFibonacci ( n ) ) ; } int main ( ) { int n = 13 ; if ( isFullfibonacci ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestEvenOddSubarray ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return max ( cnt , longest ) ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << longestEvenOddSubarray ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinDivisor ( int arr [ ] , int n , int limit ) { int low = 0 , high = 1e9 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += ceil ( ( double ) arr [ i ] / ( double ) mid ) ; } if ( sum <= limit ) high = mid ; else low = mid + 1 ; } return low ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 6 ; cout << findMinDivisor ( arr , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int sz = 1e3 ; bool isEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( x & 1 ) parity ++ ; x = x >> 1 ; } if ( parity % 2 == 0 ) return true ; else return false ; } void printArray ( int arr [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { cout << arr [ i ] << ' ▁ ' ; } } void findPairEvenParity ( int arr [ ] , int len ) { int firstMaximum = INT_MIN ; int secondMaximum = INT_MIN ; for ( int i = 0 ; i < len ; i ++ ) { if ( isEvenParity ( arr [ i ] ) ) { if ( arr [ i ] >= firstMaximum ) { secondMaximum = firstMaximum ; firstMaximum = arr [ i ] ; } else if ( arr [ i ] >= secondMaximum ) { secondMaximum = arr [ i ] ; } } } cout << firstMaximum << " ▁ " << secondMaximum ; } int main ( ) { int arr [ ] = { 18 , 15 , 8 , 9 , 14 } ; int len = sizeof ( arr ) / sizeof ( int ) ; findPairEvenParity ( arr , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isHexagonal ( int N ) { float val = 8 * N + 1 ; float x = 1 + sqrt ( val ) ; float n = ( x ) / 4 ; if ( ( n - ( int ) n ) == 0 ) return true ; else return false ; } int main ( ) { int N = 14 ; if ( isHexagonal ( N ) == true ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Solve ( int arr [ ] , int n ) { int temp = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << Solve ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prodSquare ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; } int main ( ) { int n = 25 ; if ( prodSquare ( n ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int N ) { for ( int i = 1 ; i <= N / 2 ; i ++ ) { cout << i << " , ▁ " << - i << " , ▁ " ; } if ( N % 2 == 1 ) cout << 0 ; } int main ( ) { int N = 10 ; findNumbers ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countValues ( int N ) { vector < int > div ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . push_back ( i ) ; if ( N != i * i ) { div . push_back ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( auto d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; } int main ( ) { int N = 6 ; cout << countValues ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Solve ( int arr [ ] , int size , int n ) { vector < int > v ( n + 1 ) ; for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; int max1 = ( max_element ( v . begin ( ) , v . end ( ) ) - v . begin ( ) ) ; int diff1 = n + 1 - count ( v . begin ( ) , v . end ( ) , 0 ) ; int max_size = max ( min ( v [ max1 ] - 1 , diff1 ) , min ( v [ max1 ] , diff1 - 1 ) ) ; cout << " Maximum ▁ size ▁ is ▁ : " << max_size << " STRNEWLINE " ; cout << " The ▁ First ▁ Array ▁ Is ▁ : ▁ STRNEWLINE " ; for ( int i = 0 ; i < max_size ; i ++ ) { cout << max1 << " ▁ " ; v [ max1 ] -= 1 ; } cout << " STRNEWLINE " ; cout << " The ▁ Second ▁ Array ▁ Is ▁ : ▁ STRNEWLINE " ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { cout << i << " ▁ " ; max_size -- ; } if ( max_size < 1 ) break ; } cout << " STRNEWLINE " ; } int main ( ) { int n = 7 ; int arr [ ] = { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Solve ( arr , size , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findunique ( vector < int > & a , int k ) { int res = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int p = 0 ; for ( int j = 0 ; j < a . size ( ) ; j ++ ) { p += ( abs ( a [ j ] ) & ( 1 << i ) ) != 0 ? 1 : 0 ; } p %= k ; res += pow ( 2 , i ) * p ; } int c = 0 ; for ( auto x : a ) if ( x == res ) { c = 1 ; break ; } return c == 1 ? res : - res ; } int main ( ) { vector < int > a = { 12 , 12 , 2 , 2 , 3 } ; int k = 2 ; cout << findunique ( a , k ) << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float Volume_of_cone ( float R ) { float V = ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ; return V ; } int main ( ) { float R = 10.0 ; cout << Volume_of_cone ( R ) ; }
#include <iostream> NEW_LINE using namespace std ; void find_volume ( float area , float h ) { float Volume = ( area * h ) ; cout << " Volume : ▁ " << Volume << endl ; } void find_Surface_area ( float area , float a , float h ) { float Surface_area = ( 2 * area ) + ( 8 * a * h ) ; cout << " Surface ▁ area : ▁ " << Surface_area << endl ; } int main ( ) { float h = 1 ; float a = 6 ; float d = 2 ; float area = 2 * a * d ; find_Surface_area ( area , a , h ) ; find_volume ( area , h ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE double nthRoot ( ll A , ll N ) { double xPre = 7 ; double eps = 1e-3 ; double delX = INT_MAX ; double xK ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / pow ( xPre , N - 1 ) ) / ( double ) N ; delX = abs ( xK - xPre ) ; xPre = xK ; } return xK ; } bool check ( ll no , int k ) { double kth_root = nthRoot ( no , k ) ; ll num = kth_root ; if ( abs ( num - kth_root ) < 1e-4 ) return true ; return false ; } void printExpo ( ll arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( check ( arr [ i ] , k ) ) cout << arr [ i ] << " ▁ " ; } } int main ( ) { int K = 6 ; ll arr [ ] = { 46656 , 64 , 256 , 729 , 16 , 1000 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printExpo ( arr , n , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CntcontSubs ( int a [ ] , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; } int main ( ) { int arr [ ] = { 5 , 4 , 2 , 9 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CntcontSubs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  int NEW_LINE using namespace std ; long long pref [ 100010 ] ; int isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return n ; return 0 ; } void precomputation ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfect ( i ) ; } } int main ( ) { int L = 6 , R = 28 ; precomputation ( ) ; cout << pref [ R ] - pref [ L - 1 ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int EulerTotientFunction ( int limit ) { int copy = limit ; vector < int > primes ; for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( limit % i == 0 ) { while ( limit % i == 0 ) { limit /= i ; } primes . push_back ( i ) ; } } if ( limit >= 2 ) { primes . push_back ( limit ) ; } int ans = copy ; for ( auto it : primes ) { ans = ( ans / it ) * ( it - 1 ) ; } return ans ; } void CountGCD ( int m , int k ) { if ( m % k != 0 ) { cout << 0 << endl ; return ; } if ( m == k ) { cout << 2 << endl ; return ; } int limit = m / k ; int ans = EulerTotientFunction ( limit ) ; cout << ans << endl ; } int main ( ) { int M = 9 ; int K = 1 ; CountGCD ( M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE int fib ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2 ; return round ( pow ( phi , n ) / sqrt ( 5 ) ) ; } int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } int sumFibonacci ( int k ) { int l = ( k * ( k - 1 ) ) / 2 ; int r = l + k ; int sum = calculateSum ( l , r - 1 ) ; return sum ; } int main ( ) { int k = 3 ; cout << sumFibonacci ( k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void sumOfPrevK ( int N , int K ) { int arr [ N ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int j = i - 1 , count = 0 , sum = 0 ; while ( j >= 0 && count < K ) { sum += arr [ j ] ; j -- ; count ++ ; } arr [ i ] = sum ; } for ( int i = 0 ; i < N ; i ++ ) { cout << arr [ i ] << " ▁ " ; } } int main ( ) { int N = 10 , K = 4 ; sumOfPrevK ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRealAndImag ( string s ) { int l = s . length ( ) ; int i ; if ( s . find ( ' + ' ) < l ) { i = s . find ( ' + ' ) ; } else { i = s . find ( ' - ' ) ; } string real = s . substr ( 0 , i ) ; string imaginary = s . substr ( i + 1 , l - i - 2 ) ; cout << " Real ▁ part : ▁ " << real << " STRNEWLINE " ; cout << " Imaginary ▁ part : ▁ " << imaginary << " STRNEWLINE " ; } int main ( ) { string s = "3 + 4i " ; findRealAndImag ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } int countReverse ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( reverse ( arr [ i ] ) == arr [ j ] ) { res ++ ; } return res ; } int main ( ) { int a [ ] = { 16 , 61 , 12 , 21 , 25 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countReverse ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSeriesSum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i & 1 ) { sum += ( double ) i / ( i + 1 ) ; } else { sum -= ( double ) i / ( i + 1 ) ; } } cout << sum << endl ; } int main ( ) { int N = 10 ; printSeriesSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string sumBaseB ( string a , string b , int base ) { int len_a , len_b ; len_a = a . size ( ) ; len_b = b . size ( ) ; string sum , s ; s = " " ; sum = " " ; int diff ; diff = abs ( len_a - len_b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len_a < len_b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = max ( len_a , len_b ) - 1 ; i > -1 ; i -- ) { curr = carry + ( a [ i ] - '0' ) + ( b [ i ] - '0' ) ; carry = curr / base ; curr = curr % base ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; } int main ( ) { string a , b , sum ; int base ; a = "123" ; b = "234" ; base = 6 ; sum = sumBaseB ( a , b , base ) ; cout << sum << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void createHash ( set < int > & hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . insert ( prev ) ; hash . insert ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . insert ( temp ) ; prev = curr ; curr = temp ; } } int countFibonacciDivisors ( int n ) { set < int > hash ; createHash ( hash , n ) ; int cnt = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i == i ) && ( hash . find ( n / i ) != hash . end ( ) ) ) cnt ++ ; else { if ( hash . find ( n / i ) != hash . end ( ) ) cnt ++ ; if ( hash . find ( n / ( n / i ) ) != hash . end ( ) ) cnt ++ ; } } } return cnt ; } int main ( ) { int n = 12 ; cout << countFibonacciDivisors ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectCube ( int x ) { long double cr = round ( cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; } void checkCube ( int a , int b ) { string s1 = to_string ( a ) ; string s2 = to_string ( b ) ; int c = stoi ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { cout << " Yes " ; } else { cout << " No " ; } } int main ( ) { int a = 6 ; int b = 4 ; checkCube ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; } bool isFibonacci ( int N ) { return isPerfectSquare ( 5 * N * N + 4 ) || isPerfectSquare ( 5 * N * N - 4 ) ; } int nextNonFibonacci ( int N ) { if ( N <= 3 ) return 4 ; if ( isFibonacci ( N + 1 ) ) return N + 2 ; else return N + 1 ; } int main ( ) { int N = 3 ; cout << nextNonFibonacci ( N ) << endl ; N = 5 ; cout << nextNonFibonacci ( N ) << endl ; N = 7 ; cout << nextNonFibonacci ( N ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigit ( int n ) { bool prime [ 10 ] ; memset ( prime , false , sizeof ( prime ) ) ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] ) count ++ ; } return count ; } int main ( ) { int n = 1032 ; cout << countDigit ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRoots ( int b , int c ) { int a = 1 ; int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { double x = - b + sqrt_val ; double y = - b - sqrt_val ; int root1 = ( x ) / ( 2 * a ) ; int root2 = ( y ) / ( 2 * a ) ; if ( root1 + root2 == -1 * b && root1 * root2 == c ) cout << root1 << " , ▁ " << root2 ; else cout << -1 ; } else if ( d == 0 ) { int root = - b / ( 2 * a ) ; if ( root + root == -1 * b && root * root == c ) cout << root << " , ▁ " << root ; else cout << -1 ; } else { cout << -1 ; } cout << endl ; } int main ( ) { int S = 5 , P = 6 ; findRoots ( - S , P ) ; S = 5 , P = 9 ; findRoots ( - S , P ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { cout << ( i * i * i ) << " ▁ " ; i ++ ; } } int main ( ) { int N = 4 ; findNumbers ( N ) ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; void getnumbers ( int n ) { vector < int > divisor ; for ( int i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { divisor . push_back ( i ) ; n /= i ; } } if ( n != 1 ) { divisor . push_back ( n ) ; } int a , b , c , size ; a = b = c = 1 ; size = divisor . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( a == 1 ) { a = a * divisor [ i ] ; } else if ( b == 1 b == a ) { b = b * divisor [ i ] ; } else { c = c * divisor [ i ] ; } } if ( a == 1 b == 1 c == 1 a == b b == c a == c ) { cout << " - 1" << endl ; } else { cout << a << ' ▁ ' << b << ' ▁ ' << c << endl ; } } int main ( ) { int n = 64 ; getnumbers ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > primeFactors ( int n ) { int i , j ; vector < int > Prime ; if ( n % 2 == 0 ) { Prime . push_back ( 2 ) ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { Prime . push_back ( i ) ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { Prime . push_back ( n ) ; } return Prime ; } void checkDistinctPrime ( int n ) { vector < int > Prime = primeFactors ( n ) ; int product = 1 ; for ( auto i : Prime ) { product *= i ; } if ( product == n ) cout << " YES " ; else cout << " NO " ; } int main ( ) { int N = 30 ; checkDistinctPrime ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = log2 ( N ) + 1 ; int expSum = pow ( 2 , r ) - 1 ; cout << sum - expSum << endl ; } int main ( ) { int N = 2 ; findSum ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int remainingArea ( int N , int M , int K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; } int main ( ) { int N = 5 , M = 3 , K = 2 ; cout << remainingArea ( N , M , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( int a [ ] , int n ) { int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; } int main ( ) { int a [ ] = { 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isPossible ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < int , int > findFourthVertex ( int n , int m , string s [ ] ) { map < int , int > row , col ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( s [ i ] [ j ] == ' * ' ) { row [ i ] ++ ; col [ j ] ++ ; } int x , y ; for ( auto tm : row ) if ( tm . second == 1 ) x = tm . first ; for ( auto tm : col ) if ( tm . second == 1 ) y = tm . first ; return make_pair ( x + 1 , y + 1 ) ; } int main ( ) { string s [ ] = { " * . * " , " * . . " , " . . . " } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; int m = s [ 0 ] . length ( ) ; auto rs = findFourthVertex ( n , m , s ) ; cout << rs . first << " ▁ " << rs . second ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float cone ( float a ) { if ( a < 0 ) return -1 ; float r = ( a * sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = 3.14 * pow ( r , 2 ) * h ; return V ; } int main ( ) { float a = 5 ; cout << cone ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float squareArea ( float a ) { if ( a < 0 ) return -1 ; float area = pow ( 1.268 , 2 ) * pow ( a , 2 ) ; return area ; } int main ( ) { float a = 6 ; cout << squareArea ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define PI  3.14159265 NEW_LINE float length_rope ( float r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } int main ( ) { float r = 7 ; cout << ceil ( length_rope ( r ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float sph ( float r , float h ) { if ( r < 0 && h < 0 ) return -1 ; float R = r ; return R ; } int main ( ) { float r = 4 , h = 8 ; cout << sph ( r , h ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; } int main ( ) { int M = 4 , N = 4 ; int Cuts = numberOfCuts ( M , N ) ; cout << " Maximum ▁ cuts ▁ = ▁ " << Cuts ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iomanip> NEW_LINE #include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void equation_parabola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( -2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( -2 * t * y1 ) - ( 2 * c * b ) ; float e1 = -2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << " equation ▁ of ▁ parabola ▁ is ▁ " << a1 << " ▁ x ^ 2 ▁ + ▁ " << b1 << " ▁ y ^ 2 ▁ + ▁ " << c1 << " ▁ x ▁ + ▁ " << d1 << " ▁ y ▁ + ▁ " << e1 << " ▁ xy ▁ + ▁ " << f1 << " ▁ = ▁ 0 . " ; } int main ( ) { float x1 = 0 ; float y1 = 0 ; float a = 3 ; float b = -4 ; float c = 2 ; equation_parabola ( x1 , y1 , a , b , c ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; float area ( float r ) { return ( 0.5 ) * ( 3.14 ) * ( r * r ) ; } float perimeter ( float r ) { return ( 3.14 ) * ( r ) ; } int main ( ) { int r = 10 ; cout << " The ▁ Area ▁ of ▁ Semicircle : ▁ " << area ( r ) << endl ; cout << " The ▁ Perimeter ▁ of ▁ Semicircle : ▁ " << perimeter ( r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool Arrive ( int a , int b , int n ) { if ( n >= abs ( a ) + abs ( b ) and ( n - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 ) return true ; return false ; } int main ( ) { int a = 5 , b = 5 , n = 11 ; if ( Arrive ( a , b , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return -1 ; float area = ( l * b ) / 2 ; return area ; } int main ( ) { float l = 5 , b = 4 ; cout << trianglearea ( l , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return -1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; } int main ( ) { float l = 5 , b = 12 , h = 13 ; cout << squareArea ( l , b , h ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = max ( x1 , x3 ) ; int y5 = max ( y1 , y3 ) ; int x6 = min ( x2 , x4 ) ; int y6 = min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { cout << " No ▁ intersection " ; return ; } cout << " ( " << x5 << " , ▁ " << y5 << " ) ▁ " ; cout << " ( " << x6 << " , ▁ " << y6 << " ) ▁ " ; int x7 = x5 ; int y7 = y6 ; cout << " ( " << x7 << " , ▁ " << y7 << " ) ▁ " ; int x8 = x6 ; int y8 = y5 ; cout << " ( " << x8 << " , ▁ " << y8 << " ) ▁ " ; } int main ( ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE #include <iostream> NEW_LINE #include <iomanip> NEW_LINE using namespace std ; void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " equation ▁ of ▁ plane ▁ is ▁ " << a << " ▁ x ▁ + ▁ " << b << " ▁ y ▁ + ▁ " << c << " ▁ z ▁ + ▁ " << d << " ▁ = ▁ 0 . " ; } int main ( ) { float x1 = -1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = -3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = -4 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE " ; else if ( x < 0 && y >= 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE " ; else if ( x < 0 && y < 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE " ; else if ( x >= 0 && y < 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE " ; else if ( x >= 0 && y >= 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE " ; else if ( x < 0 && y >= 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE " ; else if ( x < 0 && y < 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE " ; else if ( x >= 0 && y < 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE " ; } int main ( ) { float x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = -4 , y = 2 , z = -8 ; octant ( x , y , z ) ; x = -6 , y = -2 , z = 8 ; octant ( x , y , z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; } int main ( ) { int n = 4 ; cout << pentagon_pyramidal ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; cout << " x2 ▁ = ▁ " << x2 << " , ▁ " << " y2 ▁ = ▁ " << y2 ; } int main ( ) { int x1 = -4 , y1 = -1 , m1 = 3 , m2 = 5 ; otherEndPoint ( x1 , y1 , m1 , m2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findTriangle ( int a [ ] , int n ) { int b [ n + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; sort ( a , a + n ) ; sort ( b , b + n ) ; int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += max ( p - j , 0 ) ; z += q - p ; } } } cout << " Acute ▁ Triangle : ▁ " << x << endl ; cout << " Right ▁ Triangle : ▁ " << y << endl ; cout << " Obtuse ▁ Triangle : ▁ " << z << endl ; } int main ( ) { int arr [ ] = { 2 , 3 , 9 , 10 , 12 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTriangle ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; } int main ( ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << polygonArea ( X , Y , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; } return abs ( area / 2.0 ) ; } int main ( ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << polygonArea ( X , Y , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int maxn = 100001 ; int gpf [ maxn ] ; void modifiedSieve ( ) { memset ( gpf , 0 , sizeof ( gpf ) ) ; gpf [ 0 ] = 0 ; gpf [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; i ++ ) { if ( gpf [ i ] > 0 ) continue ; for ( int j = i ; j < maxn ; j += i ) { gpf [ j ] = max ( i , gpf [ j ] ) ; } } } int greatestValidInt ( int N ) { modifiedSieve ( ) ; for ( int i = N ; i > 0 ; i -- ) { if ( gpf [ i ] > sqrt ( i ) ) { return i ; } } return -1 ; } int main ( ) { int N = 25 ; cout << greatestValidInt ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; double subfactorial ( int N ) { double res = 0 , fact = 1 ; int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - ( 1 / fact ) ; else res = res + ( 1 / fact ) ; count ++ ; } return fact * ( 1 + res ) ; } int main ( ) { int N = 4 ; cout << subfactorial ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int maxP = min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; int cnt = maxP - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; } int main ( ) { int N = 3 ; cout << countPairs ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lastPositiveElement ( vector < int > arr ) { int N = arr . size ( ) ; if ( N == 1 ) return arr [ 0 ] ; int greatest = -1 , secondGreatest = -1 ; for ( int x : arr ) { if ( x >= greatest ) { secondGreatest = greatest ; greatest = x ; } else if ( x >= secondGreatest ) { secondGreatest = x ; } } return greatest - secondGreatest ; } int main ( ) { vector < int > arr = { 3 , 5 , 4 , 7 } ; cout << lastPositiveElement ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSumOfAllSubsets ( int arr [ ] , int n , int k ) { int factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( int i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( int i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; int freq = factorial_N / ( factorial_d * factorial_D ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; cout << " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " << k << " ▁ is ▁ = > ▁ " << sum << endl ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = 4 , k = 2 ; findSumOfAllSubsets ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumTripletXOR ( int A , int B , int C ) { int ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int cur = 1 << i ; if ( A >= cur ) { ans += cur ; A -= cur ; } else if ( B >= cur ) { ans += cur ; B -= cur ; } else if ( C >= cur ) { ans += cur ; C -= cur ; } } return ans ; } int main ( ) { int A = 6 ; int B = 2 ; int C = 10 ; cout << maximumTripletXOR ( A , B , C ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxUniqueElements ( int A [ ] , int N ) { unordered_map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ A [ i ] ] ++ ; } int cnt = 0 ; for ( auto x : mp ) { if ( x . second % 2 == 0 ) { cnt ++ ; } } int ans = mp . size ( ) ; if ( cnt % 2 == 1 ) { ans -- ; } return ans ; } int main ( ) { int N = 5 ; int A [ ] = { 1 , 2 , 1 , 3 , 7 } ; cout << maxUniqueElements ( A , N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int m = 1000000007 ; int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % m ; y = y >> 1 ; x = ( x * x ) % m ; } return res ; } int countNDigitNumber ( int N ) { int ne = N / 2 + N % 2 ; int no = floor ( N / 2 ) ; return power ( 4 , ne ) * power ( 5 , no ) ; } int main ( ) { int N = 5 ; cout << countNDigitNumber ( N ) % m << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPairs ( int p , int q , int r ) { vector < int > v ; for ( int i = p ; i <= q ; i ++ ) { if ( i % r == 0 ) { v . push_back ( i ) ; } } vector < pair < int , int > > ans ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < v . size ( ) ; j ++ ) { if ( v [ i ] * v [ j ] >= p * q / 4 && v [ i ] * v [ j ] <= p * q ) { ans . push_back ( { v [ i ] , v [ j ] } ) ; } } } if ( ans . size ( ) == 0 ) { cout << -1 << endl ; } else { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { cout << ans [ i ] . first << " ▁ " << ans [ i ] . second << endl ; } } } int main ( ) { int p = 14 , q = 30 , r = 5 ; findPairs ( p , q , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Kadane ( int arr [ ] , int n ) { int largestSum = 0 , currMax = 0 ; int currSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currSum += arr [ i ] ; currMax = max ( currMax , arr [ i ] ) ; largestSum = max ( largestSum , currMax * currSum ) ; if ( currSum < 0 ) { currMax = 0 ; currSum = 0 ; } } return largestSum ; } int maximumWeight ( int arr [ ] , int n ) { int largestSum = Kadane ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = - arr [ i ] ; } largestSum = max ( largestSum , Kadane ( arr , n ) ) ; return largestSum ; } int main ( ) { int arr [ ] = { 2 , -3 , 8 , -2 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumWeight ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximumTurns ( int arr [ ] , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; } int main ( ) { int arr [ ] = { 5 , 2 , 4 } ; int M = 3 , K = 2 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumTurns ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void isPossible ( int W , int B , int D ) { if ( W > B ) swap ( W , B ) ; if ( B > W * ( D + 1 ) ) cout << " NO " << endl ; else cout << " YES " << endl ; } int main ( ) { int W = 2 ; int B = 5 ; int D = 2 ; isPossible ( W , B , D ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } int maxGCDInRange ( int L , int R ) { int ans = 1 ; for ( int Z = R ; Z >= 1 ; Z -- ) { if ( ( R / Z ) - ( L - 1 ) / Z > 1 ) { ans = Z ; break ; } } return ans ; } int main ( ) { int L = 102 ; int R = 139 ; cout << maxGCDInRange ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) return false ; return true ; } void printPrimes ( int A [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] - 1 ; ; j -- ) { if ( isPrime ( j ) ) { cout << j << " ▁ " ; break ; } } for ( int j = A [ i ] + 1 ; ; j ++ ) { if ( isPrime ( j ) ) { cout << j << " ▁ " ; break ; } } cout << endl ; } } int main ( ) { int A [ ] = { 17 , 28 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; printPrimes ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; } int findSmallest ( int M , int N ) { int x = findNum ( M , N ) ; return x - M ; } int main ( ) { int M = 100 , N = 28 ; cout << findSmallest ( M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minTime ( int A [ ] , int n , int K ) { int max_ability = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { max_ability = max ( max_ability , A [ i ] ) ; } int tmp [ max_ability + 1 ] = { 0 } ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tmp [ A [ i ] ] ++ ; } for ( int i = max_ability ; i >= 0 ; i -- ) { if ( tmp [ i ] != 0 ) { if ( tmp [ i ] * i < K ) { K -= ( i * tmp [ i ] ) ; tmp [ i / 2 ] += tmp [ i ] ; count += tmp [ i ] ; if ( K <= 0 ) { return count ; } } else { if ( K % i != 0 ) { count += ( K / i ) + 1 ; } else { count += ( K / i ) ; } return count ; } } } return -1 ; } int main ( ) { int arr [ ] = { 3 , 1 , 7 , 2 , 4 } ; int N = 5 ; int K = 15 ; cout << minTime ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOperations ( int N ) { int arr [ N ] ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = ( 2 * i ) + 1 ; sum = sum + arr [ i ] ; } int mid = 0 ; if ( N % 2 == 0 ) { mid = sum / N ; } else { mid = arr [ N / 2 ] ; } int ans = 0 ; for ( int i = 0 ; i < N / 2 ; i ++ ) { ans += mid - arr [ i ] ; } return ans ; } int main ( ) { int N = 6 ; cout << minOperations ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Query ( int arr [ ] , int N , vector < vector < int > > Q ) { int mul = 1 ; int add = 0 ; for ( int i = 0 ; i < Q . size ( ) ; i ++ ) { if ( Q [ i ] [ 0 ] == 0 ) { add = add + Q [ i ] [ 1 ] ; } else if ( Q [ i ] [ 0 ] == 1 ) { mul = mul * Q [ i ] [ 1 ] ; add = add * Q [ i ] [ 1 ] ; } else { int ans = arr [ Q [ i ] [ 1 ] ] * mul + add ; cout << ans << " ▁ " ; } } } int main ( ) { int arr [ ] = { 3 , 1 , 23 , 45 , 100 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; vector < vector < int > > Q = { { 1 , 2 } , { 0 , 10 } , { 2 , 3 } , { 1 , 5 } , { 2 , 4 } } ; Query ( arr , N , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMaxPairSum ( int arr [ ] , int N , int K ) { int preMax [ N ] ; preMax [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { preMax [ i ] = max ( preMax [ i - 1 ] , arr [ i ] ) ; } int res = INT_MIN ; for ( int i = K ; i < N ; i ++ ) { res = max ( res , arr [ i ] + preMax [ i - K ] ) ; } return res ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 6 , 3 } ; int K = 3 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMaxPairSum ( arr , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int CountPairs ( int arr [ ] , int N ) { int res = 0 ; map < int , int > mp ; for ( int i = 0 ; i < N ; i ++ ) { mp [ arr [ i ] ] ++ ; } for ( auto p : mp ) { int x = p . first ; int y = p . second ; if ( x == 1 ) { res += N - 1 ; continue ; } res += ( y * ( y - 1 ) ) / 2 ; for ( int j = 2 ; j <= sqrt ( x ) ; j ++ ) { if ( x % j == 0 ) { res += mp [ j ] ; if ( j != x / j ) res += mp [ x / j ] ; } } } return res ; } int main ( ) { int arr [ ] = { 2 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CountPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSum ( vector < vector < int > > mat , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; } int main ( ) { vector < vector < int > > mat = { { -1 , 2 , 3 } , { 9 , -1 , 7 } , { 4 , 5 , -1 } } ; int N = mat . size ( ) ; cout << findMinSum ( mat , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxAdjacentDifference ( vector < int > A ) { int diff = 0 ; for ( int i = 1 ; i < ( int ) A . size ( ) ; i ++ ) { diff = max ( diff , A [ i ] - A [ i - 1 ] ) ; } return diff ; } int MinimumValue ( int arr [ ] , int N ) { int MinValue = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) { vector < int > new_arr ; for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; new_arr . push_back ( arr [ j ] ) ; } MinValue = min ( MinValue , maxAdjacentDifference ( new_arr ) ) ; } return MinValue ; } int main ( ) { int arr [ ] = { 1 , 3 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << MinimumValue ( arr , N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int mod = 1000000007 ; int power ( long long x , unsigned int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } int antisymmetricRelation ( int N ) { return ( power ( 2 , N ) * 1LL * power ( 3 , ( N * N - N ) / 2 ) ) % mod ; } int main ( ) { int N = 2 ; cout << antisymmetricRelation ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void countPairs ( int arr [ ] , int N ) { int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; } if ( N - even >= 1 ) { cout << even ; return ; } cout << 0 ; } int main ( ) { int arr [ ] = { 5 , 4 , 7 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countPairs ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPermutation ( int ans [ ] , int a [ ] , int n ) { int Max = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { Max = max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; } void findPermutation ( int a [ ] , int n ) { int ans [ n ] = { 0 } ; unordered_map < int , int > um ; for ( int i = 0 ; i < n ; i ++ ) { if ( um . find ( a [ i ] ) == um . end ( ) ) { ans [ i ] = a [ i ] ; um [ a [ i ] ] = i ; } } vector < int > v ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( um . find ( i ) == um . end ( ) ) { v . push_back ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v [ j ] ; j ++ ; } } if ( checkPermutation ( ans , a , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { cout << ans [ i ] << " ▁ " ; } } else cout << " - 1" ; } int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPermutation ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void ValidPairs ( int X , int K ) { long long int count = 0 ; for ( int A = -1000 ; A <= 1000 ; A ++ ) { for ( int B = -1000 ; B <= 1000 ; B ++ ) { if ( pow ( A , K ) - pow ( B , K ) == X ) { count ++ ; cout << A << " ▁ " << B << endl ; } } } if ( count == 0 ) { cout << " - 1" ; } } int main ( ) { long long int X = 33 ; int K = 5 ; ValidPairs ( X , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findXOR ( vector < vector < vector < int > > > & mat , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } cout << XOR << " STRNEWLINE " ; } int main ( ) { vector < vector < vector < int > > > mat = { { { 1 , 2 } , { 3 , 4 } } , { { 5 , 6 } , { 7 , 8 } } } ; int N = mat . size ( ) ; findXOR ( mat , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkWinner ( int arr [ ] , int N ) { int diff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { diff -= arr [ i ] ; } if ( diff % 2 == 0 ) { cout << " A " ; } else { cout << " B " ; } } int main ( ) { int arr [ ] = { 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkWinner ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkEvenPower ( long long int N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; } int main ( ) { int N = 4 ; cout << checkEvenPower ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distinct ( int arr [ ] , int n ) { map < int , int > mpp ; for ( int i = 0 ; i < n ; i ++ ) { mpp [ arr [ i ] ] = 1 ; } return mpp . size ( ) ; } int maxSubSum ( int arr [ ] , int n , int k , int totalDistinct ) { if ( k > n ) return 0 ; int maxm = 0 , sum = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { sum = 0 ; set < int > st ; for ( int j = i ; j < i + k ; j ++ ) { sum += arr [ j ] ; st . insert ( arr [ j ] ) ; } if ( ( int ) st . size ( ) == totalDistinct ) maxm = max ( sum , maxm ) ; } return maxm ; } int main ( ) { int arr [ ] = { 7 , 7 , 2 , 4 , 2 , 7 , 4 , 6 , 6 , 6 } ; int K = 6 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int totalDistinct = distinct ( arr , N ) ; cout << ( maxSubSum ( arr , N , K , totalDistinct ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void partitionArray ( int * a , int n ) { int * Min = new int [ n ] ; int Mini = INT_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { Mini = min ( Mini , a [ i ] ) ; Min [ i ] = Mini ; } int Maxi = INT_MIN ; int ind = -1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { Maxi = max ( Maxi , a [ i ] ) ; if ( Maxi < Min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != -1 ) { for ( int i = 0 ; i <= ind ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; for ( int i = ind + 1 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; } else cout << " Impossible " ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = 5 ; partitionArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int gcd ( long long int a , long long int b ) { while ( b > 0 ) { long long int rem = a % b ; a = b ; b = rem ; } return a ; } int countNumberOfWays ( long long int n ) { if ( n == 1 ) return -1 ; long long int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; } int main ( ) { int N = 64 ; cout << countNumberOfWays ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * pow ( 8 , i - 1 ) ; } return sum ; } int main ( ) { int N = 4 ; cout << count ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxValue ( int n ) { return n ; } int main ( ) { int n = 1 ; cout << maxValue ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int usingBinarySearch ( int start , int end , int N , int S ) { if ( start >= end ) return start ; int mid = start + ( end - start ) / 2 ; int totalSum = ( N * ( N + 1 ) ) / 2 ; int midSum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( totalSum - midSum ) <= S ) { return usingBinarySearch ( start , mid , N , S ) ; } return usingBinarySearch ( mid + 1 , end , N , S ) ; } int main ( ) { int N , S ; N = 5 ; S = 11 ; cout << ( N - usingBinarySearch ( 1 , N , N , S ) + 1 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int equal_xor_sum ( int arr [ ] , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) cout << " YES " ; else cout << " NO " ; return 0 ; } int main ( ) { int arr [ ] = { 6 , 3 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; equal_xor_sum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int set_bits ( int n ) { int count = 0 ; while ( n ) { count += n % 2 ; n /= 2 ; } return count ; } int minSteps ( int n ) { int ans = 0 ; while ( n != 1 ) { if ( n % 2 == 0 ) n /= 2 ; else if ( n == 3 or set_bits ( n - 1 ) < set_bits ( n + 1 ) ) n -- ; else n ++ ; ans ++ ; } return ans ; } int main ( ) { int n = 15 ; cout << minSteps ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int lcm ( int a , int b ) { return ( a / __gcd ( a , b ) * b ) ; } void findNums ( int x ) { int ans ; for ( int i = 1 ; i <= sqrt ( x ) ; i ++ ) { if ( x % i == 0 && lcm ( i , x / i ) == x ) { ans = i ; } } cout << ans << " ▁ " << ( x / ans ) ; } int main ( ) { int x = 12 ; findNums ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minOR ( int * arr , int n ) { if ( n == 1 ) return 0 ; int pre [ n ] , suf [ n ] ; pre [ 0 ] = arr [ 0 ] , suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << minOR ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findCnt ( int * arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n and arr [ j ] > = arr [ j - 1 ] ) j ++ ; int x = max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; } int main ( ) { int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 2 ; cout << findCnt ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int two_sets ( int a [ ] , int n ) { sort ( a , a + n ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; } int main ( ) { int a [ ] = { 1 , 4 , 4 , 6 , 7 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << two_sets ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int kthNum ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; } int main ( ) { int n = 7 , k = 7 ; cout << kthNum ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; } int main ( ) { int n = 3 ; cout << count ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMissing ( int arr [ ] , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return -1 ; return ( num / den ) ; } int main ( ) { int k = 3 , avg = 4 ; int arr [ ] = { 2 , 7 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findMissing ( arr , n , k , avg ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * pow ( 2 , n - 1 ) ; return sum ; } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << sum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int prevPowerof2 ( int n ) { int p = ( int ) log2 ( n ) ; return ( int ) pow ( 2 , p ) ; } int nextPowerOf2 ( int n ) { int p = 1 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } int minDiff ( int n ) { int low = prevPowerof2 ( n ) ; int high = nextPowerOf2 ( n ) ; return min ( n - low , high - n ) ; } int main ( ) { int n = 6 ; cout << minDiff ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10 NEW_LINE bool isFactorion ( int n ) { int fact [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; } int main ( ) { int n = 40585 ; if ( isFactorion ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } int main ( ) { int n = 3 , m = 2 ; cout << modFact ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxCommonFactors ( int a , int b ) { int gcd = __gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= gcd ; i ++ ) { if ( gcd % i == 0 ) { ans ++ ; while ( gcd % i == 0 ) gcd /= i ; } } if ( gcd != 1 ) ans ++ ; return ans ; } int main ( ) { int a = 12 , b = 18 ; cout << maxCommonFactors ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countUnsetBits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp ) { if ( temp % 2 == 0 ) cnt ++ ; temp = temp / 2 ; } } return cnt ; } int main ( ) { int n = 5 ; cout << countUnsetBits ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isDivisible ( long long int n ) { long long int temp = n ; int sum = 0 ; while ( n ) { int digit = n % 10 ; sum += digit ; n /= 10 ; } n = temp ; while ( n ) { int digit = n % 10 ; if ( sum % digit != 0 ) return false ; n /= 10 ; } return true ; } int main ( ) { long long int n = 123 ; if ( isDivisible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int COST = 3 ; int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = min ( x , min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; } int main ( ) { int x = 4 , y = 5 , z = 6 ; cout << maxItems ( x , y , z ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; pair < int , int > countSum ( int arr [ ] , int n ) { int NumberOfOdds = 0 , NumberOfEvens = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) NumberOfOdds ++ ; NumberOfEvens = n - NumberOfOdds ; int NumberOfOddSubsequences = ( 1 << NumberOfEvens ) * ( 1 << ( NumberOfOdds - 1 ) ) ; int NumberOfEvenSubsequences = ( 1 << n ) - 1 - NumberOfOddSubsequences ; return { NumberOfEvenSubsequences , NumberOfOddSubsequences } ; } int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pair < int , int > ans = countSum ( arr , n ) ; cout << " EvenSum ▁ = ▁ " << ans . first ; cout << " ▁ OddSum ▁ = ▁ " << ans . second ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } void prime_range ( int start , int end , int * a ) { for ( int i = start ; i < end ; i ++ ) { if ( prime ( a [ i ] ) ) cout << a [ i ] << " ▁ " ; } } void Print ( int arr [ ] , int n ) { cout << " Prime ▁ numbers ▁ in ▁ the ▁ first ▁ half ▁ are ▁ " ; prime_range ( 0 , n / 2 , arr ) ; cout << endl ; cout << " Prime ▁ numbers ▁ in ▁ the ▁ second ▁ half ▁ are ▁ " ; prime_range ( n / 2 , n , arr ) ; cout << endl ; } int main ( ) { int arr [ ] = { 2 , 5 , 10 , 15 , 17 , 21 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Print ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int FindElement ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { int m = sum / n ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return -1 ; } int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << FindElement ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int Count_number ( int N ) { return ( N * fact ( N ) ) ; } int main ( ) { int N = 2 ; cout << Count_number ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findHours ( int a , int b , int k ) { if ( a >= b ) return -1 ; int time = k / ( b - a ) ; time = time + 1 ; return time ; } int main ( ) { int a = 4 , b = 5 , k = 1 ; cout << findHours ( a , b , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; } int NoOfDistributions ( int N , int R ) { return ncr ( N - 1 , R - 1 ) ; } int main ( ) { int N = 4 ; int R = 3 ; cout << NoOfDistributions ( N , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinRemove ( int a [ ] , int n , int k ) { vector < int > cnt ( k , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; } int main ( ) { int a [ ] = { 0 , 1 , 2 , 3 , 4 , 0 , 1 , 0 , 1 , 2 , 3 , 4 } , k = 5 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinRemove ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void LowerHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) cout << '0' << " ▁ " ; else cout << rand ( ) % 10 << " ▁ " ; } cout << " STRNEWLINE " ; } } int main ( ) { int n = 4 ; LowerHessenbergMatrix ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } int main ( ) { int N = 4 ; cout << count ( N ) ; }
#include <iostream> NEW_LINE using namespace std ; int isMersenne ( int n ) { while ( n != 0 ) { int r = n % 2 ; if ( r == 0 ) return false ; n /= 2 ; } return true ; } int sumOfMersenne ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && isMersenne ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; } int main ( ) { int arr [ ] = { 17 , 6 , 7 , 63 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << ( sumOfMersenne ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } int main ( ) { int a = 10 , b = 20 , n = 5 ; cout << numberOfDays ( a , b , n ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; long squareSeries ( long n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } long maxPeople ( long n ) { long low = 0 ; long high = 1000000L ; long ans = 0L ; while ( low <= high ) { long mid = low + ( ( high - low ) / 2 ) ; long value = squareSeries ( mid ) ; if ( value <= n ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; } int main ( ) { long p = 14 ; cout << maxPeople ( p ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void solve ( long long int a , long long int b ) { if ( a > 0 && b > 0 ) { cout << " Positive " ; } else if ( a <= 0 && b >= 0 ) { cout << " Zero " << endl ; } else { long long int n = abs ( a - b ) + 1 ; if ( n % 2 == 0 ) { cout << " Positive " << endl ; } else { cout << " Negative " << endl ; } } } int main ( ) { int a = -10 , b = -2 ; solve ( a , b ) ; return 0 ; }
#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; } int sumFactorial ( int * arr , int n ) { int s = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; } int main ( ) { int arr [ ] = { 7 , 3 , 5 , 4 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumFactorial ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) cout << " The ▁ given ▁ straight " << " ▁ lines ▁ are ▁ identical " << endl ; else cout << " The ▁ given ▁ straight " << " ▁ lines ▁ are ▁ not ▁ identical " << endl ; } int main ( ) { double a1 = -2 , b1 = 4 , c1 = 3 , a2 = -6 , b2 = 12 , c2 = 9 ; idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return pow ( 10 , n - 1 ) ; } int main ( ) { int n = 4 ; cout << smallestMultiple ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxlen  100 NEW_LINE void generateSubStrings ( string s , unordered_map < string , int > & mpp ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { string temp = " " ; for ( int j = i ; j < l ; j ++ ) { temp += s [ j ] ; mpp [ temp ] += 1 ; } } } void binomialCoeff ( int C [ maxlen ] [ maxlen ] ) { int i , j ; for ( i = 0 ; i < 100 ; i ++ ) { for ( j = 0 ; j < 100 ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } int answerQuery ( unordered_map < string , int > & mpp , int C [ maxlen ] [ maxlen ] , int k ) { int ans = 0 ; for ( auto it : mpp ) { if ( it . second >= k ) ans += C [ it . second ] [ k ] ; } return ans ; } int main ( ) { string s = " aabaab " ; unordered_map < string , int > mpp ; generateSubStrings ( s , mpp ) ; int C [ maxlen ] [ maxlen ] ; memset ( C , 0 , sizeof C ) ; binomialCoeff ( C ) ; int queries [ ] = { 2 , 3 , 4 } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) cout << answerQuery ( mpp , C , queries [ i ] ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long computeXOR ( const int n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } } int main ( ) { int l = 1 , r = 4 ; cout << ( computeXOR ( r ) ^ computeXOR ( l - 1 ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE int fib ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2 ; return round ( pow ( phi , n ) / sqrt ( 5 ) ) ; } ll calculateSum ( int l , int r ) { ll sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; } int main ( ) { int l = 4 , r = 8 ; cout << calculateSum ( l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * pow ( 10 , n / 2 - 1 ) ) ; } int main ( ) { int n = 2 ; cout << countNumbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; } int main ( ) { int a = 1 , b = 2 , c = 10 , d = 11 ; cout << getProbability ( a , b , c , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * pow ( 2 , occ ) ; occ -- ; } return sum ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSum ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE #define n  3 NEW_LINE using namespace std ; int matrixSum ( int arr [ ] [ n ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; } int main ( ) { int arr [ ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; cout << matrixSum ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005 NEW_LINE bool isprime [ N ] ; bool can [ N ] ; vector < int > SieveOfEratosthenes ( ) { memset ( isprime , true , sizeof ( isprime ) ) ; for ( int p = 2 ; p * p < N ; p ++ ) { if ( isprime [ p ] == true ) { for ( int i = p * p ; i < N ; i += p ) isprime [ i ] = false ; } } vector < int > primes ; for ( int i = 2 ; i < N ; i ++ ) if ( isprime [ i ] ) primes . push_back ( i ) ; return primes ; } int Prime_Numbers ( int n ) { vector < int > primes = SieveOfEratosthenes ( ) ; for ( int i = 0 ; i < ( int ) ( primes . size ( ) ) - 1 ; i ++ ) if ( primes [ i ] + primes [ i + 1 ] + 1 < N ) can [ primes [ i ] + primes [ i + 1 ] + 1 ] = true ; int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( can [ i ] and isprime [ i ] ) { ans ++ ; } } return ans ; } int main ( ) { int n = 50 ; cout << Prime_Numbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void midptellipse ( int rx , int ry , int xc , int yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ; d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ; while ( dx < dy ) { cout << x + xc << " ▁ , ▁ " << y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << y + yc << endl ; cout << x + xc << " ▁ , ▁ " << - y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << - y + yc << endl ; if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } } d2 = ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ; while ( y >= 0 ) { cout << x + xc << " ▁ , ▁ " << y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << y + yc << endl ; cout << x + xc << " ▁ , ▁ " << - y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << - y + yc << endl ; if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } } int main ( ) { midptellipse ( 10 , 15 , 50 , 50 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void alter ( long long int x , long long int y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } cout << " X = " << x << " , ▁ " << " Y = " << y ; } int main ( ) { long long int x = 12 , y = 5 ; alter ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } int countWays ( string str ) { int freq [ 26 ] = { 0 } ; int nvowels = 0 , nconsonants = 0 ; int vplaces , cways , vways ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ freq [ str [ i ] - ' a ' ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) nvowels += freq [ i ] ; else nconsonants += freq [ i ] ; } vplaces = nconsonants + 1 ; cways = factorial ( nconsonants ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { cways = cways / factorial ( freq [ i ] ) ; } } vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { vways = vways / factorial ( freq [ i ] ) ; } } return cways * vways ; } int main ( ) { string str = " permutation " ; cout << countWays ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } int sumOfElements ( int arr [ ] , int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , n + 1 ) ; int i , j ; unordered_map < int , int > m ; for ( i = 0 ; i < n ; i ++ ) m [ arr [ i ] ] ++ ; int sum = 0 ; for ( auto it = m . begin ( ) ; it != m . end ( ) ; it ++ ) { if ( prime [ it -> second ] ) { sum += ( it -> first ) ; } } return sum ; } int main ( ) { int arr [ ] = { 5 , 4 , 6 , 5 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumOfElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalPairs ( int arr1 [ ] , int arr2 [ ] , int K , int n , int m ) { set < pair < int , int > > s ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] > arr2 [ j ] ) { if ( arr1 [ i ] % arr2 [ j ] == K ) s . insert ( make_pair ( arr1 [ i ] , arr2 [ j ] ) ) ; } else { if ( arr2 [ j ] % arr1 [ i ] == K ) s . insert ( make_pair ( arr2 [ j ] , arr1 [ i ] ) ) ; } } } return s . size ( ) ; } int main ( ) { int arr1 [ ] = { 8 , 3 , 7 , 50 } ; int arr2 [ ] = { 5 , 1 , 10 , 4 } ; int K = 3 ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << totalPairs ( arr1 , arr2 , K , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE vector < ll > findPrime ( int MAX ) { bool pm [ MAX + 1 ] ; memset ( pm , true , sizeof ( pm ) ) ; pm [ 0 ] = pm [ 1 ] = false ; for ( int i = 2 ; i <= MAX ; i ++ ) if ( pm [ i ] ) for ( int j = 2 * i ; j <= MAX ; j += i ) pm [ j ] = false ; vector < ll > prime ; for ( int i = 0 ; i <= MAX ; i ++ ) if ( pm [ i ] ) prime . push_back ( i ) ; return prime ; } int findSmallest ( int arr [ ] , int n ) { int MAX = * max_element ( arr , arr + n ) ; vector < ll > prime = findPrime ( MAX ) ; unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) s . insert ( arr [ i ] ) ; int ans = -1 ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) if ( s . find ( prime [ i ] ) == s . end ( ) ) { ans = prime [ i ] ; break ; } return ans ; } int main ( ) { int arr [ ] = { 3 , 0 , 1 , 2 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( findSmallest ( arr , n ) == -1 ) cout << " No ▁ prime ▁ number ▁ missing " ; else cout << findSmallest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void profitLoss ( int N , int M ) { if ( N == M ) cout << " No ▁ Profit ▁ nor ▁ Loss " ; else { float result = 0.0 ; result = float ( abs ( N - M ) ) / M ; if ( N - M < 0 ) cout << " Loss ▁ = ▁ - " << result * 100 << " % " ; else cout << " Profit ▁ = ▁ " << result * 100 << " % " ; } } int main ( ) { int N = 8 , M = 9 ; profitLoss ( N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; } int main ( ) { int n = 592452 ; int k = 3 ; if ( SumDivisible ( n , k ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool sumDivisible ( int n , int k ) { int sum = 0 ; string num = to_string ( n ) ; int i ; for ( i = 0 ; i < num . size ( ) ; i ++ ) { if ( i % 2 != 0 ) { sum = sum + ( num [ i ] - '0' ) ; } } if ( sum % k == 0 ) { return true ; } else { return false ; } } int main ( ) { int n = 592452 ; int k = 3 ; if ( sumDivisible ( n , k ) ) { cout << ( " YES " ) ; } else { cout << ( " NO " ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int EqualNumbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; } int main ( ) { int a [ ] = { 1 , 4 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << EqualNumbers ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void PossibleValues ( int b , int x , int n ) { int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { cout << leastdivisible - b << " ▁ " ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag ) cout << -1 ; } int main ( ) { int b = 10 , x = 6 , n = 40 ; PossibleValues ( b , x , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE unordered_set < long long int > s ; void SieveOfEratosthenes ( ) { bool prime [ MAX ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } long long int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . insert ( product + 1 ) ; } } } bool isEuclid ( long n ) { if ( s . find ( n ) != s . end ( ) ) return true ; else return false ; } int main ( ) { SieveOfEratosthenes ( ) ; long n = 31 ; if ( isEuclid ( n ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; n = 42 ; if ( isEuclid ( n ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= max ( c , i + 1 ) ) ans += d - max ( c , i + 1 ) + 1 ; return ans ; } int main ( ) { int a = 2 , b = 3 , c = 3 , d = 4 ; cout << NumberOfSolutions ( a , b , c , d ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 4 * n - 2 ; } int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; } int main ( ) { int l = 4 , b = 3 ; cout << calculateAreaSum ( l , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } int main ( ) { int n = 25 ; ( check ( n ) == 1 ) ? cout << " YES " : cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int binomialCoeff ( int x , int n , int k ) { int sum = 0 , term = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; if ( sum > k ) return sum ; } return sum ; } int minTrials ( int n , int k ) { int low = 1 , high = k ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( binomialCoeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; } int main ( ) { cout << minTrials ( 2 , 10 ) ; return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; bool isPrime ( int num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( int i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; } int primePalindrome ( int N ) { if ( 8 <= N && N <= 11 ) return 11 ; for ( int x = 1 ; x < 100000 ; ++ x ) { string s = to_string ( x ) , r ( s . rbegin ( ) , s . rend ( ) ) ; int y = stoi ( s + r . substr ( 1 ) ) ; if ( y >= N && isPrime ( y ) ) return y ; } return -1 ; } int main ( ) { cout << primePalindrome ( 112 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <boost/multiprecision/cpp_int.hpp> NEW_LINE using namespace boost :: multiprecision ; using namespace std ; int1024_t boost_hyperfactorial ( int num ) { int1024_t val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; } int main ( ) { int num = 5 ; cout << boost_hyperfactorial ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOddSum ( int ar [ ] , int n ) { int temp [ 2 ] = { 1 , 0 } ; int result = 0 , val = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = ( temp [ 0 ] * temp [ 1 ] ) ; return ( result ) ; } int main ( ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << " The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ odd " " ▁ sum ▁ is ▁ " << countOddSum ( ar , n ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int center_hexadecagonal_num ( long int n ) { return 8 * n * n - 8 * n + 1 ; } int main ( ) { long int n = 2 ; cout << n << " th ▁ centered ▁ hexadecagonal ▁ number ▁ : ▁ " << center_hexadecagonal_num ( n ) ; cout << endl ; n = 12 ; cout << n << " th ▁ centered ▁ hexadecagonal ▁ numbe ▁ : ▁ " << center_hexadecagonal_num ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( unsigned long long m , unsigned long long int n ) { double RHS = m * ( double ) log ( n ) ; double LHS = n * ( double ) log ( m ) ; if ( LHS > RHS ) cout << " m ^ n ▁ > ▁ n ^ m " ; else if ( LHS < RHS ) cout << " m ^ n ▁ < ▁ n ^ m " ; else cout << " m ^ n ▁ = ▁ n ^ m " ; } int main ( ) { unsigned long long m = 987654321 , n = 123456987 ; check ( m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } int calculateSeries ( int n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; } int main ( ) { int n = 3 ; cout << calculateSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; } int main ( ) { int n = 3 ; cout << findSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < long long int > gen ( long long int n , vector < long long int > r ) { long long int a = r [ r . size ( ) - 1 ] ; a ++ ; for ( int i = 1 ; i <= n ; a += 2 , i ++ ) r . push_back ( a ) ; return r ; } vector < long long int > conell ( long long int n ) { vector < long long int > res ; long long int k = 1 ; res . push_back ( 0 ) ; while ( 1 ) { res = gen ( k , res ) ; k ++ ; int j = res . size ( ) - 1 ; while ( j != n && j + k > n ) k -- ; if ( j >= n ) break ; } res . erase ( res . begin ( ) ) ; return res ; } int main ( ) { long long int n = 10 ; cout << " The ▁ first ▁ " << n << " ▁ terms ▁ are " << endl ; vector < long long int > res = conell ( n ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; cout << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) cout << " Yes " ; else cout << " No " ; } int main ( ) { int n = 5 ; NicomachuTheorum_sum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } int LCMOfNeighbourFact ( int n ) { return factorial ( n + 1 ) ; } int main ( ) { int N = 5 ; cout << LCMOfNeighbourFact ( N ) << " STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; bool isPrime ( int n ) { if ( n == 0 n == 1 ) return false ; int root = sqrt ( n ) ; for ( int i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; } bool isSandwitched ( int n ) { return ( isPrime ( n - 1 ) && isPrime ( n + 1 ) ) ; } int main ( ) { int n = 642 ; cout << n << " ▁ : ▁ " ; if ( isSandwitched ( n ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; n = 9 ; cout << n << " ▁ : ▁ " ; if ( isSandwitched ( n ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
# include <bits/stdc++.h> NEW_LINE using namespace std ; bool isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; } int main ( ) { int n = 10 ; if ( isSquareFree ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } int main ( ) { int n = 30 ; cout << sumofoddFactors ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; } int main ( ) { int n = 5 ; int val = 20 ; cout << countSolutions ( n , val ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigit ( int n ) { if ( n == 0 ) return 0 ; return 1 + countDigit ( n / 10 ) ; } bool check ( int n ) { int l = countDigit ( n ) ; int dup = n ; int sum = 0 ; while ( dup ) { sum += pow ( dup % 10 , l ) ; dup /= 10 ; } return ( n == sum ) ; } int main ( ) { int n = 1634 ; if ( check ( n ) ) cout << " yes " ; else cout << " no " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int sameRemainder ( int a , int b , int c ) { int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; } int main ( ) { int a = 62 , b = 132 , c = 237 ; cout << sameRemainder ( a , b , c ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char * PrimeDigitNumber ( char N [ ] , int size ) { char * ans = ( char * ) malloc ( size * sizeof ( char ) ) ; int ns = 0 ; int small = 0 ; int i ; int p [ ] = { 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 } ; int prevprime [ ] = { 0 , 0 , 0 , 2 , 3 , 3 , 5 , 5 , 7 , 7 } ; if ( size == 1 ) { ans [ 0 ] = prevprime [ N [ 0 ] - '0' ] + '0' ; ans [ 1 ] = ' \0' ; return ans ; } if ( N [ 0 ] == '1' ) { for ( int i = 0 ; i < size - 1 ; i ++ ) ans [ i ] = '7' ; ans [ size - 1 ] = ' \0' ; return ans ; } for ( i = 0 ; i < size && small == 0 ; i ++ ) { if ( p [ N [ i ] - '0' ] == 1 ) { ans [ ns ++ ] = N [ i ] ; } else { if ( p [ N [ i ] - '0' ] == 0 && prevprime [ N [ i ] - '0' ] != 0 ) { ans [ ns ++ ] = prevprime [ N [ i ] - '0' ] + '0' ; small = 1 ; } else if ( p [ N [ i ] - '0' ] == 0 && prevprime [ N [ i ] - '0' ] == 0 ) { int j = i ; while ( j > 0 && p [ N [ j ] - '0' ] == 0 && prevprime [ N [ j ] - '0' ] == 0 ) { ans [ j ] = N [ j ] = '7' ; N [ j - 1 ] = prevprime [ N [ j - 1 ] - '0' ] + '0' ; ans [ j - 1 ] = N [ j - 1 ] ; small = 1 ; j -- ; } i = ns ; } } } if ( small == 0 ) { if ( prevprime [ N [ size - 1 ] - '0' ] + '0' != '0' ) ans [ size - 1 ] = prevprime [ N [ size - 1 ] - '0' ] + '0' ; else { int j = size - 1 ; while ( j > 0 && prevprime [ N [ j ] - '0' ] == 0 ) { ans [ j ] = N [ j ] = '7' ; N [ j - 1 ] = prevprime [ N [ j - 1 ] - '0' ] + '0' ; ans [ j - 1 ] = N [ j - 1 ] ; small = 1 ; j -- ; } } } for ( ; ns < size ; ns ++ ) ans [ ns ] = '7' ; ans [ ns ] = ' \0' ; int k = 0 ; while ( ans [ k ] == '0' ) k ++ ; return ans + k ; } int main ( ) { char N [ ] = "1000" ; int size = strlen ( N ) ; cout << PrimeDigitNumber ( N , size ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; bool isPowerOfK ( unsigned int n , unsigned int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; } int main ( ) { int n = 64 , k = 4 ; if ( isPowerOfK ( n , k ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calcScr ( vector < int > arr ) { int ans = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) ans += ( i ^ arr [ i ] ) ; return ans ; } int getMax ( vector < int > arr , int ans , vector < bool > chosen , int N ) { if ( arr . size ( ) == N ) { ans = max ( ans , calcScr ( arr ) ) ; return ans ; } for ( int i = 0 ; i < N ; i ++ ) { if ( chosen [ i ] ) continue ; chosen [ i ] = true ; arr . push_back ( i ) ; ans = getMax ( arr , ans , chosen , N ) ; chosen [ i ] = false ; arr . pop_back ( ) ; } return ans ; } int main ( ) { int N = 2 ; vector < int > arr ; int ans = -1 ; vector < bool > chosen ( N , false ) ; ans = getMax ( arr , ans , chosen , N ) ; cout << ans << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPrimeNos ( int L , int R , unordered_map < int , int > & M ) { for ( int i = L ; i <= R ; i ++ ) { M [ i ] ++ ; } if ( M . find ( 1 ) != M . end ( ) ) { M . erase ( 1 ) ; } for ( int i = 2 ; i <= sqrt ( R ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= R ) { if ( M . find ( i * multiple ) != M . end ( ) ) { M . erase ( i * multiple ) ; } multiple ++ ; } } } void getPrimePairs ( int L , int R , int K ) { unordered_map < int , int > M ; findPrimeNos ( L , R , M ) ; for ( auto & it : M ) { if ( M . find ( it . first + K ) != M . end ( ) ) { cout << " ( " << it . first << " , ▁ " << it . first + K << " ) ▁ " ; } } } int main ( ) { int L = 1 , R = 19 ; int K = 6 ; getPrimePairs ( L , R , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gonNum65537 ( int n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; } int main ( ) { int n = 3 ; cout << gonNum65537 ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << count ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maximumFactor ( vector < int > arr ) { int n = arr . size ( ) ; vector < int > rank ; vector < int > factors ; int max = * max_element ( arr . begin ( ) , arr . end ( ) ) ; for ( int i = 2 ; i <= max ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % i == 0 ) count += 1 ; rank . push_back ( count ) ; factors . push_back ( i ) ; } } int m = * max_element ( rank . begin ( ) , rank . end ( ) ) ; for ( int i = 0 ; i < rank . size ( ) ; i ++ ) { if ( rank [ i ] == m ) cout << factors [ i ] << " ▁ " ; } } int main ( ) { vector < int > arr = { 120 , 15 , 24 , 63 , 18 } ; maximumFactor ( arr ) ; }
#include <iostream> NEW_LINE using namespace std ; int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } int main ( ) { int n = 10 , a = 3 , b = 5 ; cout << findSum ( n , a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double findMedian ( int a [ ] , int n ) { sort ( a , a + n ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } int main ( ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " Median ▁ = ▁ " << findMedian ( a , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; } int main ( ) { int n = 10 ; cout << centeredIcosahedralNum ( n ) << endl ; n = 12 ; cout << centeredIcosahedralNum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; } int main ( ) { int n = 7 ; cout << Dodecagonal_number ( n ) << endl ; n = 12 ; cout << Dodecagonal_number ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int averageEven ( int n ) { if ( n % 2 != 0 ) { cout << " Invalid ▁ Input " ; return -1 ; } return ( n + 2 ) / 2 ; } int main ( ) { int n = 16 ; cout << averageEven ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; } int main ( ) { int a = 5 , b = 15 ; double HM = compute ( a , b ) ; cout << " Harmonic ▁ Mean ▁ between ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << HM ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define EPS  1e-9 NEW_LINE void productPuzzle ( int a [ ] , int n ) { long double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( long double ) log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) cout << ( int ) ( EPS + pow ( ( long double ) 10.00 , sum - log10 ( a [ i ] ) ) ) << " ▁ " ; } int main ( ) { int a [ ] = { 10 , 3 , 5 , 6 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " The ▁ product ▁ array ▁ is : ▁ STRNEWLINE " ; productPuzzle ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; } int main ( ) { int n = 4 ; cout << " ▁ " << pell ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE #define ld  long double NEW_LINE using namespace std ; ll findMinValue ( ll arr [ ] , ll n ) { sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; i ++ ) val += ( ld ) ( log ( ( ld ) ( arr [ i ] ) ) ) ; ll left = arr [ 0 ] , right = arr [ n - 1 ] + 1 ; ll ans ; while ( left <= right ) { ll mid = ( left + right ) / 2 ; ld temp = ( ld ) n * ( ld ) ( log ( ( ld ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else left = mid + 1 ; } return ans ; } int main ( ) { ll arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; ll n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinValue ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printOtherSides ( int n ) { if ( n & 1 ) { if ( n == 1 ) cout << -1 << endl ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; cout << " b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; } } else { if ( n == 2 ) cout << -1 << endl ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; cout << " b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; } } } int main ( ) { int a = 3 ; printOtherSides ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; } int main ( ) { int n = 4 ; cout << sumFactDiv ( n ) ; }
#include <bits/stdc++.h> NEW_LINE #include <math.h> NEW_LINE using namespace std ; vector < int > allPrimes ; void sieve ( int n ) { vector < bool > prime ( n + 1 , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push_back ( p ) ; } int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) { int p = allPrimes [ i ] ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes [ i ] ; } result = result * ( pow ( allPrimes [ i ] , exp + 1 ) - 1 ) / ( allPrimes [ i ] - 1 ) ; } return result ; } int main ( ) { cout << factorialDivisors ( 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkPandigital ( int b , char n [ ] ) { if ( strlen ( n ) < b ) return false ; bool hash [ b ] ; memset ( hash , false , sizeof ( hash ) ) ; for ( int i = 0 ; i < strlen ( n ) ; i ++ ) { if ( n [ i ] >= '0' && n [ i ] <= '9' ) hash [ n [ i ] - '0' ] = true ; else if ( n [ i ] - ' A ' <= b - 11 ) hash [ n [ i ] - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } int main ( ) { int b = 13 ; char n [ ] = "1298450376ABC " ; ( checkPandigital ( b , n ) ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOf2sinRange ( int n ) { string s = " " ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += to_string ( i ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] == '2' ) { count ++ ; } } return count ; } int main ( ) { int n = 30 ; cout << numberOf2sinRange ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int power ( int num , unsigned int n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , n / 2 ) * power ( num , n / 2 ) ; else return num * power ( num , n / 2 ) * power ( num , n / 2 ) ; } int checkRecursive ( int x , int n , int curr_num = 1 , int curr_sum = 0 ) { int results = 0 ; int p = power ( curr_num , n ) ; while ( p + curr_sum < x ) { results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) ; curr_num ++ ; p = power ( curr_num , n ) ; } if ( p + curr_sum == x ) results ++ ; return results ; } int main ( ) { int x = 10 , n = 2 ; cout << checkRecursive ( x , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int printGenerators ( unsigned int n ) { cout << "1 ▁ " ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) cout << i << " ▁ " ; } int main ( ) { int n = 10 ; printGenerators ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumDivisorsOfDivisors ( int n ) { map < int , int > mp ; for ( int j = 2 ; j <= sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count ) mp [ j ] = count ; } if ( n != 1 ) mp [ n ] = 1 ; int ans = 1 ; for ( auto it : mp ) { int pw = 1 ; int sum = 0 ; for ( int i = it . second + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw *= it . first ; } ans *= sum ; } return ans ; } int main ( ) { int n = 10 ; cout << sumDivisorsOfDivisors ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; } int main ( ) { int N = 10 , K = 2 ; cout << findSum ( N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int pow ( int base , int exponent , int modulus ) { int result = 1 ; base = base % modulus ; while ( exponent > 0 ) { if ( exponent % 2 == 1 ) result = ( result * base ) % modulus ; exponent = exponent >> 1 ; base = ( base * base ) % modulus ; } return result ; } int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } int order ( int p , int b ) { if ( gcd ( p , b ) != 1 ) { printf ( " p ▁ and ▁ b ▁ are ▁ not ▁ co - prime . STRNEWLINE " ) ; return -1 ; } int k = 3 ; while ( 1 ) { if ( pow ( b , k , p ) == 1 ) return k ; k ++ ; } } int convertx2e ( int x , int & e ) { e = 0 ; while ( x % 2 == 0 ) { x /= 2 ; e ++ ; } return x ; } int STonelli ( int n , int p ) { if ( gcd ( n , p ) != 1 ) { printf ( " a ▁ and ▁ p ▁ are ▁ not ▁ coprime STRNEWLINE " ) ; return -1 ; } if ( pow ( n , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) { printf ( " no ▁ sqrt ▁ possible STRNEWLINE " ) ; return -1 ; } int s , e ; s = convertx2e ( p - 1 , e ) ; int q ; for ( q = 2 ; ; q ++ ) { if ( pow ( q , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) break ; } int x = pow ( n , ( s + 1 ) / 2 , p ) ; int b = pow ( n , s , p ) ; int g = pow ( q , s , p ) ; int r = e ; while ( 1 ) { int m ; for ( m = 0 ; m < r ; m ++ ) { if ( order ( p , b ) == -1 ) return -1 ; if ( order ( p , b ) == pow ( 2 , m ) ) break ; } if ( m == 0 ) return x ; x = ( x * pow ( g , pow ( 2 , r - m - 1 ) , p ) ) % p ; g = pow ( g , pow ( 2 , r - m ) , p ) ; b = ( b * g ) % p ; if ( b == 1 ) return x ; r = m ; } } int main ( ) { int n = 2 ; int p = 113 ; int x = STonelli ( n , p ) ; if ( x == -1 ) printf ( " Modular ▁ square ▁ root ▁ is ▁ not ▁ exist STRNEWLINE " ) ; else printf ( " Modular ▁ square ▁ root ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d STRNEWLINE " , n , p , x ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findRoots ( int a , int b , int c ) { if ( a == 0 ) { cout << " Invalid " ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { cout << " Roots ▁ are ▁ real ▁ and ▁ different ▁ STRNEWLINE " ; cout << ( double ) ( - b + sqrt_val ) / ( 2 * a ) << " STRNEWLINE " << ( double ) ( - b - sqrt_val ) / ( 2 * a ) ; } else if ( d == 0 ) { cout << " Roots ▁ are ▁ real ▁ and ▁ same ▁ STRNEWLINE " ; cout << - ( double ) b / ( 2 * a ) ; } { cout << " Roots ▁ are ▁ complex ▁ STRNEWLINE " ; cout << - ( double ) b / ( 2 * a ) << " ▁ + ▁ i " << sqrt_val << " STRNEWLINE " << - ( double ) b / ( 2 * a ) << " ▁ - ▁ i " << sqrt_val ; } } int main ( ) { int a = 1 , b = -7 , c = 12 ; findRoots ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { vector < int > v ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) printf ( " % d ▁ " , i ) ; else { printf ( " % d ▁ " , i ) ; v . push_back ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) printf ( " % d ▁ " , v [ i ] ) ; } int main ( ) { printf ( " The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ n " ) ; printDivisors ( 100 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) cout << " ▁ " << i ; } int main ( ) { cout << " The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE " ; printDivisors ( 100 ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; void printDivisors ( int n ) { for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cout << " ▁ " << i ; cout << " ▁ " << i << " ▁ " << n / i ; } } } int main ( ) { cout << " The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ STRNEWLINE " ; printDivisors ( 100 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; } int main ( ) { int N = 5 ; cout << seriesSum ( 1 , 1 , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nCrModpDP ( int n , int r , int p ) { int C [ r + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; } int nCrModpLucas ( int n , int r , int p ) { if ( r == 0 ) return 1 ; int ni = n % p , ri = r % p ; } int main ( ) { int n = 1000 , r = 900 , p = 13 ; cout << " Value ▁ of ▁ nCr ▁ % ▁ p ▁ is ▁ " << nCrModpLucas ( n , r , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m , a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } int main ( ) { int a = 3 , m = 11 ; cout << " Modular ▁ multiplicative ▁ inverse ▁ is ▁ " << modInverse ( a , m ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int phi ( unsigned int n ) { unsigned int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; } int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) cout << " phi ( " << n << " ) ▁ = ▁ " << phi ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; cout << f1 << " ▁ " ; for ( i = 1 ; i < n ; i ++ ) { cout << f2 << " ▁ " ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } } int main ( ) { printFibonacciNumbers ( 7 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; long long gcd ( long long int a , long long int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } long long lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; } int main ( ) { int a = 15 , b = 20 ; cout << " LCM ▁ of ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << lcm ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; # define MAX  11 NEW_LINE bool isMultipleof5 ( int n ) { char str [ MAX ] ; int len = strlen ( str ) ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; } int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) cout << n << " ▁ is ▁ multiple ▁ of ▁ 5" << endl ; else cout << n << " ▁ is ▁ not ▁ multiple ▁ of ▁ 5" << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reversDigits ( int num ) { static int rev_num = 0 ; static int base_pos = 1 ; if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } int main ( ) { int num = 4562 ; cout << " Reverse ▁ of ▁ no . ▁ is ▁ " << reversDigits ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 3 ; const int N = 3 ; int findXOR ( int X ) { int ans = 0 ; while ( X ) { ans ^= ( X % 10 ) ; X /= 10 ; } return ans ; } void printXORmatrix ( int arr [ M ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { cout << arr [ i ] [ j ] << " ▁ " ; } cout << " STRNEWLINE " ; } } void convertXOR ( int arr [ M ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i ] [ j ] ; int temp = findXOR ( X ) ; arr [ i ] [ j ] = temp ; } } printXORmatrix ( arr ) ; } int main ( ) { int arr [ ] [ 3 ] = { { 27 , 173 , 5 } , { 21 , 6 , 624 } , { 5 , 321 , 49 } } ; convertXOR ( arr ) ; return 0 ; }
int setBit ( int num , int i ) { return num | ( 1 << i ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printORSumforEachElement ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int req_sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { req_sum += ( arr [ i ] arr [ j ] ) ; } cout << req_sum << " ▁ " ; } } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printORSumforEachElement ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findLargestNumber ( vector < int > & arr ) { for ( auto n : arr ) { n &= 0xFFFF ; if ( n <= arr . size ( ) ) { arr [ n - 1 ] += 0x10000 ; } } for ( auto i = arr . size ( ) ; i > 0 ; -- i ) { if ( ( arr [ i - 1 ] >> 16 ) == i ) return i ; } return -1 ; } int main ( ) { vector < int > arr = { 3 , 2 , 5 , 5 , 2 , 4 , 5 } ; cout << findLargestNumber ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int RecursiveFunction ( vector < int > ref , int bit ) { if ( ref . size ( ) == 0 bit < 0 ) return 0 ; vector < int > curr_on , curr_off ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) { if ( ( ( ref [ i ] >> bit ) & 1 ) == 0 ) curr_off . push_back ( ref [ i ] ) ; else curr_on . push_back ( ref [ i ] ) ; } if ( curr_off . size ( ) == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . size ( ) == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; } void PrintMinimum ( int a [ ] , int n ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) v . push_back ( a [ i ] ) ; cout << RecursiveFunction ( v , 30 ) << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; PrintMinimum ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000005 NEW_LINE void SieveOfEratosthenes ( vector < bool > & prime ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } } void prime_xor ( int arr [ ] , int n , int k ) { vector < bool > prime ( MAX , true ) ; SieveOfEratosthenes ( prime ) ; long long int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { if ( ( i + 1 ) % k == 0 ) { ans ^= arr [ i ] ; } } } cout << ans << endl ; } int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 , 11 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; prime_xor ( arr , n , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPowerOfTwo ( int x ) { if ( x == 0 ) return false ; if ( ! ( x & ( x - 1 ) ) ) return true ; else return false ; } int countNum ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) || isPowerOfTwo ( a [ i ] + 1 ) ) count ++ ; } return count ; } int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countNum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorGivenSetBits ( int arr [ ] , int n , int k ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) { if ( __builtin_popcount ( arr [ i ] ) == k ) { v . push_back ( arr [ i ] ) ; } } int result = v [ 0 ] ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) result = result ^ v [ i ] ; return result ; } int main ( ) { int arr [ ] = { 2 , 13 , 1 , 19 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << xorGivenSetBits ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countZeros ( int x ) { unsigned y ; int n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; } int main ( ) { int x = 101 ; cout << countZeros ( x ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; } int main ( ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << findEvenPair ( A , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000 NEW_LINE int lastElement ( int a [ ] , int n ) { int steps = 1 ; vector < int > v [ N ] ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . push_back ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps & 1 ) v [ steps ] . push_back ( v [ steps - 1 ] [ i ] v [ steps - 1 ] [ i + 1 ] ) ; v [ steps ] . push_back ( v [ steps - 1 ] [ i ] ^ v [ steps - 1 ] [ i + 1 ] ) ; } } return v [ steps ] [ 0 ] ; } int main ( ) { int a [ ] = { 1 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int index = 0 ; int value = 2 ; a [ 0 ] = 2 ; cout << lastElement ( a , n ) << endl ; index = 3 ; value = 5 ; a [ index ] = value ; cout << lastElement ( a , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int xnor ( int a , int b ) { if ( a < b ) swap ( a , b ) ; if ( a == 0 && b == 0 ) return 1 ; int a_rem = 0 ; int b_rem = 0 ; int count = 0 ; int xnornum = 0 ; while ( a ) { a_rem = a & 1 ; b_rem = b & 1 ; if ( a_rem == b_rem ) xnornum |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; } return xnornum ; } int main ( ) { int a = 10 , b = 50 ; cout << xnor ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void divide ( int n , int m ) { cout << " Remainder ▁ = ▁ " << ( ( n ) & ( m - 1 ) ) ; cout << " Quotient = " } int main ( ) { int n = 43 , m = 8 ; divide ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool areAllBitsSet ( unsigned int n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } bool isOnesComplementOfOther ( unsigned int a , unsigned int b ) { return areAllBitsSet ( a ^ b ) ; } int main ( ) { unsigned int a = 10 , b = 5 ; if ( isOnesComplementOfOther ( a , b ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE unsigned countBits ( unsigned int number ) { return ( int ) log2 ( number ) + 1 ; } int main ( ) { unsigned int num = 65 ; std :: cout << countBits ( num ) << ' ' ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } int main ( ) { int number = 171 , k = 5 , p = 2 ; cout << " The ▁ extracted ▁ number ▁ is ▁ " << bitExtracted ( number , k , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void multiply ( int F [ 2 ] [ 2 ] , int M [ 2 ] [ 2 ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; } void power ( int F [ 2 ] [ 2 ] , int n ) { if ( n == 0 n == 1 ) return ; int M [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; } int countWays ( int n ) { int F [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n ) ; return F [ 0 ] [ 0 ] ; } int main ( ) { int n = 5 ; cout << countWays ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n ) { ( n % 2 == 0 ) ? count0 ++ : count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; } int main ( ) { int n = 31 ; cout << countXOR ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; } int main ( ) { int n = 12 ; cout << countValues ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; } int main ( ) { int n = 9 ; cout << multiplyBySevenByEight ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPalindrome ( string S , int i , int j ) { while ( i < j ) { if ( S [ i ] != S [ j ] ) return false ; i ++ ; j -- ; } return true ; } void printLongestPalindrome ( string S , int N ) { int palLength [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int maxlength = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( S [ j ] == S [ i ] ) { if ( isPalindrome ( S , j , i ) ) { maxlength = i - j + 1 ; break ; } } } for ( int j = N - 1 ; j > i ; j -- ) { if ( S [ j ] == S [ i ] ) { if ( isPalindrome ( S , i , j ) ) { maxlength = max ( j - i + 1 , maxlength ) ; break ; } } } palLength [ i ] = maxlength ; } for ( int i = 0 ; i < N ; i ++ ) { cout << palLength [ i ] << " ▁ " ; } } int main ( ) { string S = " bababa " ; int N = S . length ( ) ; printLongestPalindrome ( S , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkSorted ( int n , int arr [ ] ) { int b [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; sort ( b , b + n ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; } int main ( ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkSorted ( n , arr ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; } int main ( ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; } int main ( ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int validPermutations ( string str ) { unordered_map < char , int > m ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m [ str [ i ] ] ++ ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m [ str [ i ] ] ; m [ str [ i ] ] -- ; count -- ; } return ans + 1 ; } int main ( ) { string str = " sstt " ; cout << validPermutations ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool ifPossible ( int arr [ ] , int n ) { int cp [ n ] ; copy ( arr , arr + n , cp ) ; sort ( cp , cp + n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false ; } return true ; } int main ( ) { int arr [ ] = { 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( ifPossible ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 20 ; int dp [ M ] [ 165 ] [ M ] [ 2 ] ; int n , m ; int count ( int pos , int sum , int rem , int tight , int nonz , vector < int > num ) { if ( pos == num . size ( ) ) { if ( rem == 0 && sum == n ) return 1 ; return 0 ; } if ( dp [ pos ] [ sum ] [ rem ] [ tight ] != -1 ) return dp [ pos ] [ sum ] [ rem ] [ tight ] ; int ans = 0 ; int limit = ( tight ? 9 : num [ pos ] ) ; for ( int d = 0 ; d <= limit ; d ++ ) { if ( d == 0 && nonz ) continue ; int currSum = sum + d ; int currRem = ( rem * 10 + d ) % m ; int currF = tight || ( d < num [ pos ] ) ; ans += count ( pos + 1 , currSum , currRem , currF , nonz d , num ) ; } return dp [ pos ] [ sum ] [ rem ] [ tight ] = ans ; } int solve ( int x ) { vector < int > num ; while ( x ) { num . push_back ( x % 10 ) ; x /= 10 ; } reverse ( num . begin ( ) , num . end ( ) ) ; memset ( dp , -1 , sizeof ( dp ) ) ; return count ( 0 , 0 , 0 , 0 , 0 , num ) ; } int main ( ) { int L = 1 , R = 100 ; n = 8 , m = 2 ; cout << solve ( R ) - solve ( L ) ; return 0 ; }
#include <iostream> NEW_LINE #include <limits> NEW_LINE using namespace std ; int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = numeric_limits < int > :: min ( ) ; int prefix_sum [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; } int main ( ) { int arr1 [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << maximumSumSubarray ( arr1 , n1 ) << endl ; int arr2 [ ] = { 4 , -8 , 9 , -4 , 1 , -8 , -1 , 6 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << maximumSumSubarray ( arr2 , n2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPaths ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; } int main ( ) { int n = 3 , m = 2 ; cout << " ▁ Number ▁ of ▁ Paths ▁ " << countPaths ( n , m ) ; return 0 ; }
int dp [ MAXN ] ; int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string printShortestSuperSeq ( string X , string Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } string str ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { str . push_back ( X [ i - 1 ] ) ; i -- , j -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str . push_back ( Y [ j - 1 ] ) ; j -- ; } else { str . push_back ( X [ i - 1 ] ) ; i -- ; } } while ( i > 0 ) { str . push_back ( X [ i - 1 ] ) ; i -- ; } while ( j > 0 ) { str . push_back ( Y [ j - 1 ] ) ; j -- ; } reverse ( str . begin ( ) , str . end ( ) ) ; return str ; } int main ( ) { string X = " AGGTAB " ; string Y = " GXTXAYB " ; cout << printShortestSuperSeq ( X , Y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MatrixChainOrder ( int p [ ] , int n ) { int m [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; m [ i ] [ j ] = INT_MAX ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " << MatrixChainOrder ( arr , size ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } int main ( ) { int i , j ; int arr [ ] = { 1 , 2 , 3 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " ▁ " << count ( arr , m , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubstringCount ( string str ) { int result = 0 ; int n = str . size ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] + 1 == str [ i + 1 ] ) { result ++ ; while ( str [ i ] + 1 == str [ i + 1 ] ) { i ++ ; } } } return result ; } int main ( ) { string str = " alphabet " ; cout << findSubstringCount ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; } int main ( ) { int n = 4722 ; cout << round ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } string encryptString ( string s , int n , int k ) { int countVowels = 0 ; int countConsonants = 0 ; string ans = " " ; for ( int l = 0 ; l <= n - k ; l ++ ) { countVowels = 0 ; countConsonants = 0 ; for ( int r = l ; r <= l + k - 1 ; r ++ ) { if ( isVowel ( s [ r ] ) == true ) countVowels ++ ; else countConsonants ++ ; } ans += to_string ( countVowels * countConsonants ) ; } return ans ; } int main ( ) { string s = " hello " ; int n = s . length ( ) ; int k = 2 ; cout << encryptString ( s , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int hammingDist ( char * str1 , char * str2 ) { int i = 0 , count = 0 ; while ( str1 [ i ] != ' \0' ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; } int main ( ) { char str1 [ ] = " geekspractice " ; char str2 [ ] = " nerdspractise " ; cout << hammingDist ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float surfaceArea ( float a , float b , float h ) { return 5 * a * b + 5 * b * h ; } float volume ( float b , float h ) { return ( 5 * b * h ) / 2 ; } int main ( ) { float a = 5 ; float b = 3 ; float h = 7 ; cout << " surface ▁ area = ▁ " << surfaceArea ( a , b , h ) << " , ▁ " ; cout << " volume = ▁ " << volume ( b , h ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int formQuadruplets ( int arr [ ] , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; sort ( arr , arr + n , greater < int > ( ) ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; } int main ( ) { int arr [ ] = { 2 , 1 , 7 , 5 , 5 , 4 , 1 , 1 , 3 , 3 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << formQuadruplets ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; } int main ( ) { int N = 6 , K = 14 ; cout << Count ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxItems ( int n , int m , int a [ ] , int b [ ] , int K ) { int count = 0 ; int A [ n + 1 ] ; int B [ m + 1 ] ; A [ 0 ] = 0 ; B [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { A [ i ] = a [ i - 1 ] + A [ i - 1 ] ; } for ( int i = 1 ; i <= m ; i ++ ) { B [ i ] = b [ i - 1 ] + B [ i - 1 ] ; } for ( int i = 0 ; i <= n ; i ++ ) { if ( A [ i ] > K ) break ; int rem = K - A [ i ] ; int j = 0 ; int lo = 0 , hi = m ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; if ( B [ mid ] <= rem ) { j = mid ; lo = mid + 1 ; } else { hi = mid - 1 ; } } count = max ( j + i , count ) ; } cout << count ; } int main ( ) { int n = 4 , m = 5 , K = 7 ; int A [ n ] = { 2 , 4 , 7 , 3 } ; int B [ m ] = { 1 , 9 , 3 , 4 , 5 } ; maxItems ( n , m , A , B , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int N ) { if ( N == 1 ) return false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; } int findCoPrime ( int L , int R ) { int coPrime ; for ( int i = R + 1 ; ; i ++ ) { if ( isPrime ( i ) ) { coPrime = i ; break ; } } return coPrime ; } int main ( ) { int L = 16 , R = 17 ; cout << findCoPrime ( L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void KthCharacter ( string S , int N , int K ) { char strarray [ N + 1 ] ; strcpy ( strarray , S . c_str ( ) ) ; sort ( strarray , strarray + N ) ; char ch = strarray [ K - 1 ] ; int count = 0 ; for ( auto c : strarray ) { if ( c == ch ) count ++ ; } cout << count ; } int main ( ) { string S = " geeksforgeeks " ; int N = S . length ( ) ; int K = 3 ; KthCharacter ( S , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubstring ( string S ) { string T = " " ; string ans = " " ; int l = 0 ; T += S [ 0 ] ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( abs ( S [ i ] - S [ i - 1 ] ) == 1 ) { l = T . length ( ) ; if ( l > ans . length ( ) ) { ans = T ; } T = " " ; T += S [ i ] ; } else { T += S [ i ] ; } } l = ( int ) T . length ( ) ; if ( l > ( int ) ans . length ( ) ) { ans = T ; } cout << ans << endl ; } int main ( ) { string S = " aabdml " ; findSubstring ( S ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; static int noOfValidKbers ( int K , vector < int > arr ) { map < int , int > set ; while ( K != 0 ) { set [ K % 10 ] = 1 ; K = K / 10 ; } int count = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int no = arr [ i ] ; bool flag = true ; while ( no != 0 ) { int digit = no % 10 ; if ( set . find ( digit ) == set . end ( ) ) { flag = false ; break ; } no = no / 10 ; } if ( flag == true ) { count ++ ; } } return count ; } int main ( ) { int K = 12 ; vector < int > arr = { 1 , 12 , 1222 , 13 , 2 } ; cout << ( noOfValidKbers ( K , arr ) ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000 NEW_LINE vector < vector < int > > divisors ( MAX + 1 ) ; void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { divisors [ j ] . push_back ( i ) ; } } } int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } int findClosest ( vector < int > & arr , int n , int target ) { if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } void printClosest ( int N , int X ) { computeDivisors ( ) ; int ans = findClosest ( divisors [ N ] , divisors [ N ] . size ( ) , X ) ; cout << ans ; } int main ( ) { int N = 16 , X = 5 ; printClosest ( N , X ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDiv ( int arr [ ] , int n ) { int rem0 = 0 ; int rem1 = 0 ; int rem2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int digitSum = 0 ; digitSum += arr [ i ] ; if ( digitSum % 3 == 0 ) { rem0 += 1 ; } else if ( digitSum % 3 == 1 ) { rem1 += 1 ; } else { rem2 += 1 ; } } return ( rem0 / 2 + min ( rem1 , rem2 ) ) ; } int main ( ) { int arr [ ] = { 5 , 3 , 2 , 8 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( countDiv ( arr , n ) ) ; }
#include <bits/stdc++.h> NEW_LINE #include <set> NEW_LINE using namespace std ; #define N  100005 NEW_LINE void SieveOfEratosthenes ( bool prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } long long int digitProduct ( int number ) { long long int res = 1 ; while ( number > 0 ) { res *= ( number % 10 ) ; number /= 10 ; } return res ; } void DistinctCompositeDigitProduct ( int arr [ ] , int n ) { set < int > output ; bool prime [ N + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { long long int ans = digitProduct ( arr [ i ] ) ; if ( ans <= 1 ) { continue ; } if ( ! prime [ ans ] ) { output . insert ( ans ) ; } } cout << output . size ( ) << endl ; } int main ( ) { int arr [ ] = { 13 , 55 , 7 , 13 , 11 , 71 , 233 , 233 , 144 , 89 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; DistinctCompositeDigitProduct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void simpleSieve ( int lmt , vector < int > & prime ) { bool Sieve [ lmt + 1 ] ; memset ( Sieve , true , sizeof ( Sieve ) ) ; Sieve [ 0 ] = Sieve [ 1 ] = false ; for ( int i = 2 ; i <= lmt ; ++ i ) { if ( Sieve [ i ] == true ) { prime . push_back ( i ) ; for ( int j = i * i ; j <= lmt ; j += i ) { Sieve [ j ] = false ; } } } } vector < bool > SegmentedSieveFn ( int low , int high ) { int lmt = floor ( sqrt ( high ) ) + 1 ; vector < int > prime ; simpleSieve ( lmt , prime ) ; int n = high - low + 1 ; vector < bool > segmentedSieve ( n + 1 , true ) ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { int lowLim = floor ( low / prime [ i ] ) * prime [ i ] ; if ( lowLim < low ) { lowLim += prime [ i ] ; } for ( int j = lowLim ; j <= high ; j += prime [ i ] ) { if ( j != prime [ i ] ) { segmentedSieve [ j - low ] = false ; } } } return segmentedSieve ; } int countPairsWhoseSumPrimeL_R ( int L , int R ) { vector < bool > segmentedSieve = SegmentedSieveFn ( L , R ) ; int cntPairs = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( segmentedSieve [ i - L ] ) { cntPairs += i / 2 ; } } return cntPairs ; } int main ( ) { int L = 1 , R = 5 ; cout << countPairsWhoseSumPrimeL_R ( L , R ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int maxN = 2002 ; int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; } int main ( ) { int a [ 7 ] = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; cout << countSubsequece ( a , 7 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10000000 NEW_LINE bool isPrime [ MAX ] ; vector < int > primes ; void SieveOfEratosthenes ( ) { memset ( isPrime , true , sizeof ( isPrime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . push_back ( p ) ; } int prime_search ( vector < int > primes , int diff ) { int low = 0 ; int high = primes . size ( ) - 1 ; int res ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( primes [ mid ] == diff ) { return primes [ mid ] ; } else if ( primes [ mid ] < diff ) { low = mid + 1 ; } else { res = primes [ mid ] ; high = mid - 1 ; } } return res ; } int minCost ( int arr [ ] , int n ) { SieveOfEratosthenes ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; } int main ( ) { int arr [ ] = { 2 , 1 , 5 , 4 , 3 } ; int n = 5 ; cout << minCost ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char minDistChar ( string s ) { int n = s . length ( ) ; int * first = new int [ 26 ] ; int * last = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = -1 ; last [ i ] = -1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( first [ s [ i ] - ' a ' ] == -1 ) { first [ s [ i ] - ' a ' ] = i ; } last [ s [ i ] - ' a ' ] = i ; } int min = INT_MAX ; char ans = '1' ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( last [ i ] == first [ i ] ) continue ; if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = i + ' a ' ; } } return ans ; } int main ( ) { string str = " geeksforgeeks " ; cout << minDistChar ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void uniqueElement ( int arr [ ] , int n ) { unordered_set < int > set ; for ( int i = 0 ; i < n ; i ++ ) { set . insert ( arr [ i ] ) ; } if ( set . size ( ) == 1 ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } } int main ( ) { int arr [ ] = { 9 , 9 , 9 , 9 , 9 , 9 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; uniqueElement ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > adj [ 100005 ] ; int visited [ 100005 ] = { 0 } ; int ans = 0 ; void dfs ( int node , int count , int m , int arr [ ] , int k ) { visited [ node ] = 1 ; if ( arr [ node - 1 ] == k ) { count ++ ; } else { count = 0 ; } if ( count > m ) { return ; } if ( adj [ node ] . size ( ) == 1 && node != 1 ) { ans ++ ; } for ( auto x : adj [ node ] ) { if ( ! visited [ x ] ) { dfs ( x , count , m , arr , k ) ; } } } int main ( ) { int arr [ ] = { 2 , 1 , 3 , 2 , 1 , 2 , 1 } ; int N = 7 , K = 2 , M = 2 ; adj [ 1 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 1 ) ; adj [ 1 ] . push_back ( 3 ) ; adj [ 3 ] . push_back ( 1 ) ; adj [ 2 ] . push_back ( 4 ) ; adj [ 4 ] . push_back ( 2 ) ; adj [ 2 ] . push_back ( 5 ) ; adj [ 5 ] . push_back ( 2 ) ; adj [ 3 ] . push_back ( 6 ) ; adj [ 6 ] . push_back ( 3 ) ; adj [ 3 ] . push_back ( 7 ) ; adj [ 7 ] . push_back ( 3 ) ; int counter = 0 ; dfs ( 1 , counter , M , arr , K ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int calc_distance ( int A [ ] , int B [ ] , int n ) { int distance_traveled_A = 0 ; int distance_traveled_B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; } int main ( ) { int A [ 5 ] = { 1 , 2 , 3 , 2 , 4 } ; int B [ 5 ] = { 2 , 1 , 3 , 1 , 4 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << calc_distance ( A , B , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxProduct ( int arr [ ] , int N ) { if ( N < 3 ) { return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; int c = 0 , d = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) { c = a , d = b ; a = arr [ i ] , b = arr [ j ] ; } if ( arr [ i ] * arr [ j ] < a * b && arr [ i ] * arr [ j ] > c * d ) c = arr [ i ] , d = arr [ j ] ; } cout << c << " ▁ " << d ; } int main ( ) { int arr [ ] = { 5 , 2 , 67 , 45 , 160 , 78 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; maxProduct ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findMaxValue ( int N , int K ) { int packages ; int maxi = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = max ( maxi , i ) ; } packages = N / maxi ; cout << packages << endl ; } int main ( ) { int N = 8 , K = 7 ; findMaxValue ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void makeGroups ( int a [ ] , int n ) { vector < int > v ( n + 1 , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { v [ a [ i ] ] ++ ; } int no_of_groups = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { no_of_groups += v [ i ] / i ; v [ i ] = v [ i ] % i ; } int i = 1 ; int total = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( v [ i ] != 0 ) { total = v [ i ] ; break ; } } i ++ ; while ( i <= n ) { if ( v [ i ] != 0 ) { total += v [ i ] ; if ( total >= i ) { int rem = total - i ; no_of_groups ++ ; total = rem ; } } i ++ ; } cout << no_of_groups << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 2 , 3 , 1 , 2 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; makeGroups ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4 NEW_LINE #define M  5 NEW_LINE void preProcess ( int mat [ N ] [ M ] , int aux [ N ] [ M ] ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; } int sumQuery ( int aux [ N ] [ M ] , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; } bool check ( int mid , int aux [ N ] [ M ] , int K ) { bool satisfies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + mid - 1 <= N - 1 && y + mid - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + mid - 1 , y + mid - 1 ) > K ) satisfies = false ; } } } return ( satisfies == true ) ; } int maximumSquareSize ( int mat [ N ] [ M ] , int K ) { int aux [ N ] [ M ] ; preProcess ( mat , aux ) ; int low = 1 , high = min ( N , M ) ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , aux , K ) ) { low = mid ; } else high = mid ; } if ( check ( high , aux , K ) ) return high ; return low ; } int main ( ) { int K = 30 ; int mat [ N ] [ M ] = { { 1 , 2 , 3 , 4 , 6 } , { 5 , 3 , 8 , 1 , 2 } , { 4 , 6 , 7 , 5 , 5 } , { 2 , 4 , 8 , 9 , 4 } } ; cout << maximumSquareSize ( mat , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = -1 , startindex ; for ( int i = 0 ; i < n ; i ++ ) { if ( isalpha ( arr [ i ] ) ) { arr [ i ] = 0 ; } else { arr [ i ] = 1 ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? -1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { ( arr [ j ] == 0 ) ? ( sum += -1 ) : ( sum += 1 ) ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == -1 ) cout << maxsize ; else cout << startindex << " ▁ " << ( startindex + maxsize - 1 ) ; } int main ( ) { int arr [ ] = { ' A ' , ' B ' , ' X ' , 4 , 6 , ' X ' , ' a ' } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubArray ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ; int minSteps ( int arr [ ] [ n ] ) { bool v [ n ] [ n ] = { 0 } ; queue < pair < int , int > > q ; q . push ( { 0 , 0 } ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- ) { pair < int , int > y = q . front ( ) ; int i = y . first , j = y . second ; q . pop ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = 1 ; if ( i + arr [ i ] [ j ] < n ) q . push ( { i + arr [ i ] [ j ] , j } ) ; if ( j + arr [ i ] [ j ] < n ) q . push ( { i , j + arr [ i ] [ j ] } ) ; } depth ++ ; } return -1 ; } int main ( ) { int arr [ n ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; cout << minSteps ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkDistinct ( int x ) { int last = x % 10 ; while ( x ) { if ( x % 10 != last ) return false ; x = x / 10 ; } return true ; } int findCount ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( checkDistinct ( i ) ) count += 1 ; } return count ; } int main ( ) { int L = 10 , R = 50 ; cout << findCount ( L , R ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; } int main ( ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int X = 4 ; cout << LowerInsertionPoint ( arr , n , X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( string s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; } int main ( ) { string s = " xzyyz " ; if ( check ( s ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countAnomalies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; } int main ( ) { int arr [ ] = { 7 , 1 , 8 } , k = 5 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countAnomalies ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int colMaxDiff ( int mat [ N ] [ N ] ) { int max_diff = INT_MIN ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = max ( max_val , mat [ j ] [ i ] ) ; min_val = min ( min_val , mat [ j ] [ i ] ) ; } max_diff = max ( max_diff , max_val - min_val ) ; } return max_diff ; } int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , 3 , 4 , 5 } , { 5 , 3 , 5 , 4 , 0 } , { 5 , 6 , 7 , 8 , 9 } , { 0 , 6 , 3 , 4 , 12 } , { 9 , 7 , 12 , 4 , 3 } , } ; cout << " Max ▁ difference ▁ : ▁ " << colMaxDiff ( mat ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findmissing ( int ar [ ] , int N ) { int l = 0 , r = N - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return mid + 1 ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return -1 ; } int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findmissing ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int a [ ] , int n ) { int max1 = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; } int main ( ) { int arr [ ] = { -1 , 2 , 3 , -4 , -10 , 22 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Largest ▁ gap ▁ is ▁ : ▁ " << solve ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) return -1 ; int maxA = INT_MIN , maxB = INT_MIN , maxC = INT_MIN , maxD = INT_MIN ; int minA = INT_MAX , minB = INT_MAX , minC = INT_MAX , minD = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxD = maxC ; maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxD = maxC ; maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) { maxD = maxC ; maxC = arr [ i ] ; } else if ( arr [ i ] > maxD ) maxD = arr [ i ] ; if ( arr [ i ] < minA ) { minD = minC ; minC = minB ; minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) { minD = minC ; minC = minB ; minB = arr [ i ] ; } else if ( arr [ i ] < minC ) { minD = minC ; minC = arr [ i ] ; } else if ( arr [ i ] < minD ) minD = arr [ i ] ; } int x = maxA * maxB * maxC * maxD ; int y = minA * minB * minC * minD ; int z = minA * minB * maxA * maxB ; return max ( x , max ( y , z ) ) ; } int main ( ) { int arr [ ] = { 1 , -4 , 3 , -6 , 7 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Quadruple ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMatrix ( vector < vector < int > > a ) { for ( auto x : a ) { for ( auto y : x ) { cout << y << " ▁ " ; } cout << " STRNEWLINE " ; } } void sortBoundaryWise ( vector < vector < int > > a ) { int i , k = 0 , l = 0 ; int m = a . size ( ) , n = a [ 0 ] . size ( ) ; int n_i , n_k = 0 , n_l = 0 , n_m = m , n_n = n ; while ( k < m && l < n ) { vector < int > boundary ; for ( i = l ; i < n ; ++ i ) { boundary . push_back ( a [ k ] [ i ] ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { boundary . push_back ( a [ i ] [ n - 1 ] ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { boundary . push_back ( a [ m - 1 ] [ i ] ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { boundary . push_back ( a [ i ] [ l ] ) ; } l ++ ; } sort ( boundary . begin ( ) , boundary . end ( ) ) ; int ind = 0 ; for ( i = n_l ; i < n_n ; ++ i ) { a [ n_k ] [ i ] = boundary [ ind ++ ] ; } n_k ++ ; for ( i = n_k ; i < n_m ; ++ i ) { a [ i ] [ n_n - 1 ] = boundary [ ind ++ ] ; } n_n -- ; if ( n_k < n_m ) { for ( i = n_n - 1 ; i >= n_l ; -- i ) { a [ n_m - 1 ] [ i ] = boundary [ ind ++ ] ; } n_m -- ; } if ( n_l < n_n ) { for ( i = n_m - 1 ; i >= n_k ; -- i ) { a [ i ] [ n_l ] = boundary [ ind ++ ] ; } n_l ++ ; } } printMatrix ( a ) ; } int main ( ) { vector < vector < int > > matrix = { { 9 , 7 , 4 , 5 } , { 1 , 6 , 2 , -6 } , { 12 , 20 , 2 , 0 } , { -5 , -6 , 7 , -2 } } ; sortBoundaryWise ( matrix ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxScore ( int i , int A [ ] , int K , int N , int dp [ ] ) { if ( i >= N - 1 ) return A [ N - 1 ] ; if ( dp [ i ] != -1 ) return dp [ i ] ; int score = INT_MIN ; for ( int j = 1 ; j <= K ; j ++ ) { score = max ( score , maxScore ( i + j , A , K , N , dp ) ) ; } return dp [ i ] = score + A [ i ] ; } int getScore ( int A [ ] , int N , int K ) { int dp [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] = -1 ; cout << maxScore ( 0 , A , K , N , dp ) ; } int main ( ) { int A [ ] = { 100 , -30 , -50 , -15 , -20 , -30 } ; int K = 3 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; getScore ( A , N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkifSorted ( int A [ ] , int B [ ] , int N ) { bool flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } int main ( ) { int A [ ] = { 3 , 1 , 2 } ; int B [ ] = { 0 , 1 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; bool check = checkifSorted ( A , B , N ) ; if ( check ) { cout << " YES " << endl ; } else { cout << " NO " << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isIncreasing ( vector < int > arr ) { for ( int i = 0 ; i < arr . size ( ) - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) return false ; } return true ; } vector < int > sortArr ( vector < int > arr ) { int prev = -1 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) { int optEle = arr [ i ] ; string strEle = to_string ( arr [ i ] ) ; for ( int idx = 0 ; idx < strEle . size ( ) ; idx ++ ) { string strEle2 = strEle . substr ( idx ) + strEle . substr ( 0 , idx ) ; int temp = stoi ( strEle2 ) ; if ( temp >= prev && temp < optEle ) optEle = temp ; } arr [ i ] = optEle ; prev = arr [ i ] ; } if ( isIncreasing ( arr ) ) return arr ; else { arr = { -1 } ; return arr ; } } int main ( ) { vector < int > arr = { 511 , 321 , 323 , 432 , 433 } ; vector < int > res = sortArr ( arr ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100 NEW_LINE #define INF  1000000 NEW_LINE int dp [ N ] [ N ] ; bool vis [ N ] [ N ] ; int findSum ( int * arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; return dp [ l ] [ r ] = min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; } int32_t main ( ) { int arr [ ] = { 1 , 2 , 100 , 120 , 140 } ; int k = 2 ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << findSum ( arr , n , k , 0 , n - 1 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string getSortedString ( string s , int n ) { vector < char > v1 , v2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] >= ' a ' && s [ i ] <= ' z ' ) v1 . push_back ( s [ i ] ) ; if ( s [ i ] >= ' A ' && s [ i ] <= ' Z ' ) v2 . push_back ( s [ i ] ) ; } sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ; int i = 0 , j = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( s [ k ] >= ' a ' && s [ k ] <= ' z ' ) { s [ k ] = v1 [ i ] ; ++ i ; } else if ( s [ k ] >= ' A ' && s [ k ] <= ' Z ' ) { s [ k ] = v2 [ j ] ; ++ j ; } } return s ; } int main ( ) { string s = " gEeksfOrgEEkS " ; int n = s . length ( ) ; cout << getSortedString ( s , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void removeElements ( int arr [ ] , int n ) { int brr [ n ] , l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) cout << brr [ i ] << " ▁ " ; } int main ( ) { int arr [ ] = { 10 , 12 , 9 , 10 , 2 , 13 , 14 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; removeElements ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findX ( int a [ ] , int n ) { sort ( a , a + n ) ; int x = a [ 0 ] * a [ n - 1 ] ; vector < int > vec ; for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { vec . push_back ( i ) ; if ( ( x / i ) != i ) vec . push_back ( x / i ) ; } } sort ( vec . begin ( ) , vec . end ( ) ) ; if ( vec . size ( ) != n ) return -1 ; else { int i = 0 ; for ( auto it : vec ) { if ( a [ i ++ ] != it ) return -1 ; } } return x ; } int main ( ) { int a [ ] = { 2 , 5 , 4 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findX ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007 NEW_LINE #define ll  long long NEW_LINE #define max  101 NEW_LINE ll C [ max - 1 ] [ max - 1 ] ; ll power ( ll x , unsigned ll y ) { unsigned ll res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y & 1 ) { res = ( res * x ) % MOD ; } y = y >> 1 ; x = ( x * x ) % MOD ; } return res % MOD ; } void combi ( int n , int k ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] % MOD + C [ i - 1 ] [ j ] % MOD ) % MOD ; } } } unsigned ll product ( ll a [ ] , int n , int k ) { unsigned ll ans = 1 ; sort ( a , a + n ) ; ll powa = C [ n - 1 ] [ k - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { ll powla = C [ i ] [ k - 1 ] ; ll powfa = C [ n - i - 1 ] [ k - 1 ] ; ll powe = ( ( powa % MOD ) - ( powla + powfa ) % MOD + MOD ) % MOD ; unsigned ll mul = power ( a [ i ] , powe ) % MOD ; ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD ; } return ans % MOD ; } int main ( ) { combi ( 100 , 100 ) ; ll arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof arr [ 0 ] ; int k = 3 ; unsigned ll ans = product ( arr , n , k ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int distribution ( int arr [ ] , int n ) { set < int , greater < int > > resources ; for ( int i = 0 ; i < n ; i ++ ) resources . insert ( arr [ i ] ) ; int m = resources . size ( ) ; return min ( m , n / 2 ) ; } int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << distribution ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSorted ( string s , int l ) { stack < char > Stack ; stack < char > tempstack ; Stack . push ( s [ 0 ] ) ; for ( int i = 1 ; i < l ; i ++ ) { int a = s [ i ] ; int b = Stack . top ( ) ; if ( ( a - b ) >= 1 or ( a == b ) ) Stack . push ( s [ i ] ) ; else if ( ( b - a ) >= 1 ) { while ( ( b - a ) >= 1 ) { tempstack . push ( Stack . top ( ) ) ; Stack . pop ( ) ; if ( Stack . size ( ) > 0 ) b = Stack . top ( ) ; else break ; } Stack . push ( s [ i ] ) ; while ( tempstack . size ( ) > 0 ) { Stack . push ( tempstack . top ( ) ) ; tempstack . pop ( ) ; } } } string answer ; while ( Stack . size ( ) > 0 ) { answer = Stack . top ( ) + answer ; Stack . pop ( ) ; } cout << answer << endl ; } int main ( ) { string s = " geeksforgeeks " ; int l = s . length ( ) ; printSorted ( s , l ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maximum_toys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ; sort ( cost , cost + N ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; } int main ( ) { int K = 50 ; int cost [ ] = { 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 } ; int N = sizeof ( cost ) / sizeof ( cost [ 0 ] ) ; cout << maximum_toys ( cost , N , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool almostSort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { swap ( A [ i ] , A [ i + 1 ] ) ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; } int main ( ) { int A [ ] = { 1 , 3 , 2 , 4 , 6 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( almostSort ( A , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mergeTwoHalf ( int A [ ] , int n ) { int temp [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { half_i = i + 1 ; break ; } } if ( half_i == 0 ) return ; int i = 0 , j = half_i , k = 0 ; while ( i < half_i && j < n ) { if ( A [ i ] < A [ j ] ) temp [ k ++ ] = A [ i ++ ] ; else temp [ k ++ ] = A [ j ++ ] ; } while ( i < half_i ) temp [ k ++ ] = A [ i ++ ] ; while ( j < n ) temp [ k ++ ] = A [ j ++ ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = temp [ i ] ; } int main ( ) { int A [ ] = { 2 , 3 , 8 , -1 , 7 , 10 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; mergeTwoHalf ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << A [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const double Pi = 3.141592 ; int MaxBuildingsCovered ( int arr [ ] , int N , int L ) { double curr_sum = 0 ; int start = 0 , curr_count = 0 , max_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum = curr_sum + ( ( double ) arr [ i ] * Pi ) ; if ( i != 0 ) curr_sum += 1 ; if ( curr_sum <= L ) { curr_count ++ ; } else if ( curr_sum > L ) { curr_sum = curr_sum - ( ( double ) arr [ start ] * Pi ) ; curr_sum -= 1 ; start ++ ; curr_count -- ; } max_count = max ( curr_count , max_count ) ; } return max_count ; } int main ( ) { int arr [ ] = { 4 , 1 , 6 , 2 } ; int L = 24 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MaxBuildingsCovered ( arr , N , L ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossible ( string s ) { int n = s . size ( ) ; int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } if ( count_0 != ( 2 * count_1 ) ) return false ; count_0 = 0 , count_1 = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s [ i ] == '0' ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } return true ; } int main ( ) { string s = "010100" ; if ( isPossible ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaxValByRearrArr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; } int main ( ) { int arr [ ] = { 3 , 2 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxValByRearrArr ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float pairProductMean ( int arr [ ] , int N ) { int suffixSumArray [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } float mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; } int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << fixed << setprecision ( 2 ) << pairProductMean ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void values_of_Q ( int X ) { vector < int > val_Q ; for ( int i = 1 ; i <= X ; i ++ ) { if ( ( ( ( X + i ) * X ) ) % i == 0 ) { val_Q . push_back ( X + i ) ; } } cout << val_Q . size ( ) << endl ; for ( int i = 0 ; i < val_Q . size ( ) ; i ++ ) { cout << val_Q [ i ] << " ▁ " ; } } int main ( ) { int X = 3 ; values_of_Q ( X ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long sumOfFactors ( int N ) { long long ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { long long first = i ; long long last = ( N / i ) * i ; long long factors = ( last - first ) / i + 1 ; long long totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; } int main ( ) { int N = 3 ; cout << sumOfFactors ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProfit ( vector < int > value , int N , int K ) { sort ( value . begin ( ) , value . end ( ) ) ; int maxval = value [ N - 1 ] ; int maxProfit = 0 ; int curr_val ; do { curr_val = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_val += value [ i ] ; if ( curr_val <= K ) { maxProfit = max ( curr_val + maxval * ( i + 1 ) , maxProfit ) ; } } } while ( next_permutation ( value . begin ( ) , value . end ( ) ) ) ; return maxProfit ; } int main ( ) { int N = 4 , K = 6 ; vector < int > values { 5 , 2 , 7 , 3 } ; cout << maxProfit ( values , N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minValue ( int n ) { while ( int ( sqrt ( n ) ) == sqrt ( n ) && n > 1 ) { n = sqrt ( n ) ; } for ( int i = sqrt ( n ) ; i > 1 ; i -- ) { while ( n % ( i * i ) == 0 ) n /= i ; } cout << n ; } int main ( ) { int N = 20 ; minValue ( N ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findDirection ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) printf ( " Up STRNEWLINE " ) ; else printf ( " Down STRNEWLINE " ) ; } else { if ( n % 2 == 0 ) printf ( " Left STRNEWLINE " ) ; else printf ( " Right STRNEWLINE " ) ; } } int main ( ) { int n = 3 , m = 3 ; findDirection ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1e5 + 5 ; vector < vector < int > > v ( N ) ; vector < int > val ( N ) ; vector < int > answer ( N ) ; int n ; int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } void DFS ( int node , int parent ) { answer [ node ] = val [ node ] ; for ( int child : v [ node ] ) { if ( child == parent ) continue ; DFS ( child , node ) ; answer [ node ] = gcd ( answer [ node ] , answer [ child ] ) ; } } void preprocess ( ) { DFS ( 1 , -1 ) ; } void findGCD ( int queries [ ] , int q ) { preprocess ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int GCD = answer [ queries [ i ] ] ; cout << " For ▁ subtree ▁ of ▁ " << queries [ i ] << " , ▁ GCD ▁ = ▁ " << GCD << endl ; } } int main ( ) { n = 5 ; v [ 1 ] . push_back ( 2 ) ; v [ 2 ] . push_back ( 1 ) ; v [ 1 ] . push_back ( 3 ) ; v [ 3 ] . push_back ( 1 ) ; v [ 3 ] . push_back ( 4 ) ; v [ 4 ] . push_back ( 3 ) ; v [ 3 ] . push_back ( 5 ) ; v [ 5 ] . push_back ( 3 ) ; val [ 1 ] = 2 ; val [ 2 ] = 3 ; val [ 3 ] = 4 ; val [ 4 ] = 8 ; val [ 5 ] = 16 ; int queries [ ] = { 2 , 3 , 1 } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; findGCD ( queries , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int * arr , int n ) { bool flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < n - i ) { flag = false ; } } if ( flag ) { return true ; } else { return false ; } } int main ( ) { int arr1 [ ] = { 11 , 11 , 11 , 11 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; if ( check ( arr1 , n1 ) ) { cout << " Yes " << endl ; } else { cout << " No " << endl ; } }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getLargestSum ( int N ) { for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = max ( max_sum , a + b ) ; } } return max_sum ; } int main ( ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; cout << max_sum << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } int lcm ( int n , int m ) { return ( n * m ) / gcd ( n , m ) ; } int main ( ) { int n = 2 , m = 3 , k = 5 ; cout << k / lcm ( n , m ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool CheckForSequence ( int arr [ ] , int n , int k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; } int main ( ) { int A [ ] = { 1 , 3 , 7 , 15 , 31 } ; int n = sizeof ( A ) / sizeof ( int ) ; cout << ( CheckForSequence ( A , n , 18 ) ? " True " : " False " ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int SubarraySum ( int a [ ] , int n , int x ) { int ans = -10000 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int curans = 0 ; priority_queue < int , vector < int > > pq ; priority_queue < int , vector < int > , greater < int > > pq2 ; for ( int k = 0 ; k < n ; k ++ ) { if ( k >= i && k <= j ) { curans += a [ k ] ; pq2 . push ( a [ k ] ) ; } else pq . push ( a [ k ] ) ; } ans = max ( ans , curans ) ; for ( int k = 1 ; k <= x ; k ++ ) { if ( pq . empty ( ) || pq2 . empty ( ) || pq2 . top ( ) >= pq . top ( ) ) break ; curans -= pq2 . top ( ) ; pq2 . pop ( ) ; curans += pq . top ( ) ; pq . pop ( ) ; ans = max ( ans , curans ) ; } } } return ans ; } int main ( ) { int a [ ] = { 5 , -1 , 2 , 3 , 4 , -2 , 5 } , x = 2 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << SubarraySum ( a , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void generateArray ( int n , int k ) { vector < int > array ( k , 0 ) ; int remaining = n - int ( k * ( k + 1 ) / 2 ) ; if ( remaining < 0 ) cout << ( " NO " ) ; int right_most = remaining % k ; int high = ceil ( remaining / ( k * 1.0 ) ) ; int low = floor ( remaining / ( k * 1.0 ) ) ; for ( int i = k - right_most ; i < k ; i ++ ) array [ i ] = high ; for ( int i = 0 ; i < ( k - right_most ) ; i ++ ) array [ i ] = low ; for ( int i = 0 ; i < k ; i ++ ) array [ i ] += i + 1 ; if ( k - 1 != remaining or k == 1 ) { for ( int u : array ) cout << u << " ▁ " ; } else if ( k == 2 or k == 3 ) printf ( " - 1 STRNEWLINE " ) ; else { array [ 1 ] -= 1 ; array [ k - 1 ] += 1 ; for ( int u : array ) cout << u << " ▁ " ; } } int main ( ) { int n = 26 , k = 6 ; generateArray ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubStrings ( string s , int k ) { int maxSubStr = 0 , n = s . size ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ' a ' + c ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s [ i ] != ch ) continue ; int cnt = 0 ; while ( i < n && s [ i ] == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = max ( maxSubStr , curr ) ; } return maxSubStr ; } int main ( ) { string s = " aaacaabbaa " ; int k = 2 ; cout << maxSubStrings ( s , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( N & 1 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; } int main ( ) { int N = 9 , P = 5 , Q = 1 ; cout << minCost ( N , P , Q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int a [ ] , int b [ ] , int n ) { int i ; long long int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return -1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return -1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = b [ i + 1 ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return -1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return -1 ; return x ; } int main ( ) { int a [ ] = { 6 , 14 , 21 , 1 } ; int b [ ] = { 15 , 7 , 10 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << solve ( a , b , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) cout << " No STRNEWLINE " ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; cout << " Yes ▁ " << days << endl ; } } int main ( ) { int S = 10 , N = 16 , M = 2 ; survival ( S , N , M ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int LongestOddEvenSubarray ( int A [ ] , int N ) { int dp [ N ] ; dp [ 0 ] = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) ans = max ( ans , dp [ i ] ) ; return ans ; } int main ( ) { int A [ ] = { 2 , 5 , 7 , 2 , 4 , 6 , 8 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << LongestOddEvenSubarray ( A , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getValue ( int arr [ ] , int N ) { int dp [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int minn = arr [ i ] ; int maxx = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { minn = min ( arr [ j ] , minn ) ; maxx = max ( arr [ j ] , maxx ) ; dp [ i ] = max ( dp [ i ] , maxx - minn + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; } int main ( ) { int arr [ ] = { 8 , 1 , 7 , 9 , 2 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getValue ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int reduceZero ( int N ) { vector < int > dp ( N + 1 , 1e9 ) ; dp [ 0 ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( char c : to_string ( i ) ) { dp [ i ] = min ( dp [ i ] , dp [ i - ( c - '0' ) ] + 1 ) ; } } return dp [ N ] ; } int main ( ) { int N = 25 ; cout << reduceZero ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool prime [ 100001 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= 100000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 100000 ; i += p ) prime [ i ] = false ; } } } int distinctPrimeSubSeq ( int a [ ] , int n , int k ) { SieveOfEratosthenes ( ) ; vector < int > primes ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ a [ i ] ] ) primes . push_back ( a [ i ] ) ; } int l = primes . size ( ) ; sort ( primes . begin ( ) , primes . end ( ) ) ; vector < int > b ; vector < int > dp ; int sum = 0 ; for ( int i = 0 ; i < l ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < l && a [ i ] == x ) { count ++ ; i ++ ; } b . push_back ( count ) ; dp . push_back ( count ) ; sum += count ; } int of_length = 2 ; int len = dp . size ( ) ; int ans = 0 ; while ( of_length <= k ) { int freq = 0 ; int prev = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { freq += dp [ i ] ; int j = sum - freq ; int subseq = b [ i ] * j ; ans += subseq ; dp [ i ] = subseq ; prev += dp [ i ] ; } len -- ; sum = prev ; of_length ++ ; } ans += ( l + 1 ) ; return ans ; } int main ( ) { int a [ ] = { 1 , 2 , 2 , 3 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( int ) ; int k = 3 ; cout << distinctPrimeSubSeq ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int mod = 1000000007 ; int dp [ 1000 ] [ 1000 ] ; int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ left ] != -1 ) return dp [ pos ] [ left ] ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return dp [ pos ] [ left ] = answer ; } int countWaystoDivide ( int n , int k , int L , int R ) { memset ( dp , -1 , sizeof ( dp ) ) ; return calculate ( 0 , n , k , L , R ) ; } int main ( ) { int N = 12 ; int K = 3 ; int L = 1 ; int R = 5 ; cout << countWaystoDivide ( N , K , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void largestSquare ( int matrix [ ] [ MAX ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ R ] [ C ] ; memset ( countDP , 0 , sizeof ( countDP ) ) ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = min ( min ( i , j ) , min ( R - i - 1 , C - j - 1 ) ) ; int ans = -1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } cout << ans << " STRNEWLINE " ; } } int main ( ) { int matrix [ ] [ MAX ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; return 0 ; }
