class Test { static int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; static void printMaxOfMin ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = Integer . MIN_VALUE ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } System . out . print ( maxOfMin + " ▁ " ) ; } } public static void main ( String [ ] args ) { printMaxOfMin ( arr . length ) ; } }
import java . util . Stack ; class Test { static int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; static void printMaxOfMin ( int n ) { Stack < Integer > s = new Stack < > ( ) ; int left [ ] = new int [ n + 1 ] ; int right [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) left [ i ] = s . peek ( ) ; s . push ( i ) ; } while ( ! s . empty ( ) ) s . pop ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( ! s . empty ( ) && arr [ s . peek ( ) ] >= arr [ i ] ) s . pop ( ) ; if ( ! s . empty ( ) ) right [ i ] = s . peek ( ) ; s . push ( i ) ; } int ans [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) ans [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = Math . max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( ans [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { printMaxOfMin ( arr . length ) ; } }
import java . util . Arrays ; class GFG { static int sumBetweenTwoKth ( int arr [ ] , int k1 , int k2 ) { Arrays . sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; int k1 = 3 , k2 = 6 ; int n = arr . length ; System . out . print ( sumBetweenTwoKth ( arr , k1 , k2 ) ) ; } }
class Node { int key ; Node left , right ; public Node ( int key ) { this . key = key ; left = right = null ; } } class Res { boolean res = false ; } class BinaryTree { Node root ; int count ( Node node ) { if ( node == null ) return 0 ; return count ( node . left ) + count ( node . right ) + 1 ; } int checkRec ( Node root , int n , Res res ) { if ( root == null ) return 0 ; int c = checkRec ( root . left , n , res ) + 1 + checkRec ( root . right , n , res ) ; if ( c == n - c ) res . res = true ; return c ; } boolean check ( Node root ) { int n = count ( root ) ; Res res = new Res ( ) ; checkRec ( root , n , res ) ; return res . res ; } public static void main ( String [ ] args ) { BinaryTree tree = new BinaryTree ( ) ; tree . root = new Node ( 5 ) ; tree . root . left = new Node ( 1 ) ; tree . root . right = new Node ( 6 ) ; tree . root . left . left = new Node ( 3 ) ; tree . root . right . left = new Node ( 7 ) ; tree . root . right . right = new Node ( 4 ) ; if ( tree . check ( tree . root ) == true ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . HashMap ; class SymmetricPairs { static void findSymPairs ( int arr [ ] [ ] ) { HashMap < Integer , Integer > hM = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { int first = arr [ i ] [ 0 ] ; int sec = arr [ i ] [ 1 ] ; Integer val = hM . get ( sec ) ; if ( val != null && val == first ) System . out . println ( " ( " + sec + " , ▁ " + first + " ) " ) ; else hM . put ( first , sec ) ; } } public static void main ( String arg [ ] ) { int arr [ ] [ ] = new int [ 5 ] [ 2 ] ; arr [ 0 ] [ 0 ] = 11 ; arr [ 0 ] [ 1 ] = 20 ; arr [ 1 ] [ 0 ] = 30 ; arr [ 1 ] [ 1 ] = 40 ; arr [ 2 ] [ 0 ] = 5 ; arr [ 2 ] [ 1 ] = 10 ; arr [ 3 ] [ 0 ] = 40 ; arr [ 3 ] [ 1 ] = 30 ; arr [ 4 ] [ 0 ] = 10 ; arr [ 4 ] [ 1 ] = 5 ; findSymPairs ( arr ) ; } }
class GFG { static class item { String name ; int price ; public item ( String name , int price ) { this . name = name ; this . price = price ; } } ; static int countItems ( item list1 [ ] , int m , item list2 [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( list1 [ i ] . name . compareTo ( list2 [ j ] . name ) == 0 ) && ( list1 [ i ] . price != list2 [ j ] . price ) ) count ++ ; return count ; } public static void main ( String [ ] args ) { item list1 [ ] = { new item ( " apple " , 60 ) , new item ( " bread " , 20 ) , new item ( " wheat " , 50 ) , new item ( " oil " , 30 ) } ; item list2 [ ] = { new item ( " milk " , 20 ) , new item ( " bread " , 15 ) , new item ( " wheat " , 40 ) , new item ( " apple " , 60 ) } ; int m = list1 . length ; int n = list2 . length ; System . out . print ( " Count ▁ = ▁ " + countItems ( list1 , m , list2 , n ) ) ; } }
import java . util . HashMap ; import java . util . Map ; public class GfG { static int findSubarraySum ( int arr [ ] , int n , int sum ) { HashMap < Integer , Integer > prevSum = new HashMap < > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == sum ) res ++ ; if ( prevSum . containsKey ( currsum - sum ) ) res += prevSum . get ( currsum - sum ) ; Integer count = prevSum . get ( currsum ) ; if ( count == null ) prevSum . put ( currsum , 1 ) ; else prevSum . put ( currsum , count + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 2 , - 2 , - 20 , 10 } ; int sum = - 10 ; int n = arr . length ; System . out . println ( findSubarraySum ( arr , n , sum ) ) ; } }
class GFG { static int countPairs ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
import java . util . ArrayList ; class Graph { static final int MAX_PATH_SIZE = 1000 ; static class Node { char data ; Node left , right ; } ; static Node newNode ( char data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = temp . right = null ; return temp ; } static class PATH { int Hd ; char key ; public PATH ( int Hd , char key ) { this . Hd = Hd ; this . key = key ; } public PATH ( ) { } } ; static void printPath ( ArrayList < PATH > path , int size ) { int minimum_Hd = Integer . MAX_VALUE ; PATH p ; for ( int it = 0 ; it < size ; it ++ ) { p = path . get ( it ) ; minimum_Hd = Math . min ( minimum_Hd , p . Hd ) ; } for ( int it = 0 ; it < size ; it ++ ) { p = path . get ( it ) ; int noOfUnderScores = Math . abs ( p . Hd - minimum_Hd ) ; for ( int i = 0 ; i < noOfUnderScores ; i ++ ) System . out . print ( " _ " ) ; System . out . println ( p . key ) ; } System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " ) ; } static void printAllPathsUtil ( Node root , ArrayList < PATH > AllPath , int HD , int order ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { AllPath . set ( order , new PATH ( HD , root . data ) ) ; printPath ( AllPath , order + 1 ) ; return ; } AllPath . set ( order , new PATH ( HD , root . data ) ) ; printAllPathsUtil ( root . left , AllPath , HD - 1 , order + 1 ) ; printAllPathsUtil ( root . right , AllPath , HD + 1 , order + 1 ) ; } static void printAllPaths ( Node root ) { if ( root == null ) return ; ArrayList < PATH > Allpaths = new ArrayList < > ( ) ; for ( int i = 0 ; i < MAX_PATH_SIZE ; i ++ ) { Allpaths . add ( new PATH ( ) ) ; } printAllPathsUtil ( root , Allpaths , 0 , 0 ) ; } public static void main ( String [ ] args ) { Node root = newNode ( ' A ' ) ; root . left = newNode ( ' B ' ) ; root . right = newNode ( ' C ' ) ; root . left . left = newNode ( ' D ' ) ; root . left . right = newNode ( ' E ' ) ; root . right . left = newNode ( ' F ' ) ; root . right . right = newNode ( ' G ' ) ; printAllPaths ( root ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static int findMin ( int arr [ ] , int low , int high ) { while ( low < high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == arr [ high ] ) high -- ; else if ( arr [ mid ] > arr [ high ] ) low = mid + 1 ; else high = mid ; } return arr [ high ] ; } public static void main ( String args [ ] ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = arr1 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr1 , 0 , n1 - 1 ) ) ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = arr2 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr2 , 0 , n2 - 1 ) ) ; int arr3 [ ] = { 1 } ; int n3 = arr3 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr3 , 0 , n3 - 1 ) ) ; int arr4 [ ] = { 1 , 2 } ; int n4 = arr4 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr4 , 0 , n4 - 1 ) ) ; int arr5 [ ] = { 2 , 1 } ; int n5 = arr5 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr5 , 0 , n5 - 1 ) ) ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = arr6 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr6 , 0 , n6 - 1 ) ) ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = arr7 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr7 , 0 , n7 - 1 ) ) ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = arr8 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr8 , 0 , n8 - 1 ) ) ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = arr9 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr9 , 0 , n9 - 1 ) ) ; } }
import java . io . * ; class GFG { static void printArray ( int [ ] array , int length ) { System . out . print ( " [ " ) ; for ( int i = 0 ; i < length ; i ++ ) { System . out . print ( array [ i ] ) ; if ( i < ( length - 1 ) ) System . out . print ( " , " ) ; else System . out . print ( "]NEW_LINE"); } } static void reverse ( int [ ] array , int start , int end ) { while ( start < end ) { int temp = array [ start ] ; array [ start ] = array [ end ] ; array [ end ] = temp ; start ++ ; end -- ; } } static void rearrange ( int [ ] array , int start , int end ) { if ( start == end ) return ; rearrange ( array , ( start + 1 ) , end ) ; if ( array [ start ] >= 0 ) { reverse ( array , ( start + 1 ) , end ) ; reverse ( array , start , end ) ; } } public static void main ( String [ ] args ) { int [ ] array = { - 12 , - 11 , - 13 , - 5 , - 6 , 7 , 5 , 3 , 6 } ; int length = array . length ; int countNegative = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( array [ i ] < 0 ) countNegative ++ ; } System . out . print ( " array : ▁ " ) ; printArray ( array , length ) ; rearrange ( array , 0 , ( length - 1 ) ) ; reverse ( array , countNegative , ( length - 1 ) ) ; System . out . print ( " rearranged ▁ array : ▁ " ) ; printArray ( array , length ) ; } }
import java . io . * ; class GFG { static void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , - 3 , 5 , 6 , - 3 , 6 , 7 , - 4 , 9 , 10 } ; int n = arr . length ; rearrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { void find3largest ( int [ ] arr ) { Arrays . sort ( arr ) ; int n = arr . length ; int check = 0 , count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( count < 4 ) { if ( check != arr [ n - i ] ) { System . out . print ( arr [ n - i ] + " ▁ " ) ; check = arr [ n - i ] ; count ++ ; } } else break ; } } public static void main ( String [ ] args ) { GFG obj = new GFG ( ) ; int [ ] arr = { 12 , 45 , 1 , - 1 , 45 , 54 , 23 , 5 , 0 , - 10 } ; obj . find3largest ( arr ) ; } }
import java . io . * ; class SecondSmallest { static void print2Smallest ( int arr [ ] ) { int first , second , arr_size = arr . length ; if ( arr_size < 2 ) { System . out . println ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } first = second = Integer . MAX_VALUE ; for ( int i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] < first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] < second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Integer . MAX_VALUE ) System . out . println ( " There ▁ is ▁ no ▁ second " + " smallest ▁ element " ) ; else System . out . println ( " The ▁ smallest ▁ element ▁ is ▁ " + first + " ▁ and ▁ second ▁ Smallest " + " ▁ element ▁ is ▁ " + second ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 1 } ; print2Smallest ( arr ) ; } }
class SmallestMissing { int findFirstMissing ( int array [ ] , int start , int end ) { if ( start > end ) return end + 1 ; if ( start != array [ start ] ) return start ; int mid = ( start + end ) / 2 ; if ( array [ mid ] == mid ) return findFirstMissing ( array , mid + 1 , end ) ; return findFirstMissing ( array , start , mid ) ; } public static void main ( String [ ] args ) { SmallestMissing small = new SmallestMissing ( ) ; int arr [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 10 } ; int n = arr . length ; System . out . println ( " First ▁ Missing ▁ element ▁ is ▁ : ▁ " + small . findFirstMissing ( arr , 0 , n - 1 ) ) ; } }
class GFG { static final int MAX = 1000 ; static int tree [ ] = new int [ 4 * MAX ] ; static int arr [ ] = new int [ MAX ] ; static int gcd ( int a , int b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return a * b / gcd ( a , b ) ; } static void build ( int node , int start , int end ) { if ( start == end ) { tree [ node ] = arr [ start ] ; return ; } int mid = ( start + end ) / 2 ; build ( 2 * node , start , mid ) ; build ( 2 * node + 1 , mid + 1 , end ) ; int left_lcm = tree [ 2 * node ] ; int right_lcm = tree [ 2 * node + 1 ] ; tree [ node ] = lcm ( left_lcm , right_lcm ) ; } static int query ( int node , int start , int end , int l , int r ) { if ( end < l start > r ) { return 1 ; } if ( l <= start && r >= end ) { return tree [ node ] ; } int mid = ( start + end ) / 2 ; int left_lcm = query ( 2 * node , start , mid , l , r ) ; int right_lcm = query ( 2 * node + 1 , mid + 1 , end , l , r ) ; return lcm ( left_lcm , right_lcm ) ; } public static void main ( String [ ] args ) { arr [ 0 ] = 5 ; arr [ 1 ] = 7 ; arr [ 2 ] = 5 ; arr [ 3 ] = 2 ; arr [ 4 ] = 10 ; arr [ 5 ] = 12 ; arr [ 6 ] = 11 ; arr [ 7 ] = 17 ; arr [ 8 ] = 14 ; arr [ 9 ] = 1 ; arr [ 10 ] = 44 ; build ( 1 , 0 , 10 ) ; System . out . println ( query ( 1 , 0 , 10 , 2 , 5 ) ) ; System . out . println ( query ( 1 , 0 , 10 , 5 , 10 ) ) ; System . out . println ( query ( 1 , 0 , 10 , 0 , 10 ) ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int lowerIndex ( int arr [ ] , int n , int x ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; } static int upperIndex ( int arr [ ] , int n , int y ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; } static int countInRange ( int arr [ ] , int n , int x , int y ) { int count = 0 ; count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 4 , 9 , 10 , 3 } ; int n = arr . length ; Arrays . sort ( arr ) ; int i = 1 , j = 4 ; System . out . println ( countInRange ( arr , n , i , j ) ) ; ; i = 9 ; j = 12 ; System . out . println ( countInRange ( arr , n , i , j ) ) ; } }
import java . util . * ; class GFG { static void type1 ( int [ ] arr , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) arr [ i ] ++ ; } static void type2 ( int [ ] arr , int [ ] [ ] query , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; } } public static void main ( String [ ] args ) { int n = 5 , m = 5 ; int [ ] arr = new int [ n + 1 ] ; int [ ] temp = { 1 , 1 , 2 , 1 , 4 , 5 , 2 , 1 , 2 , 2 , 1 , 3 , 2 , 3 , 4 } ; int [ ] [ ] query = new int [ 6 ] [ 4 ] ; int j = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { query [ i ] [ 0 ] = temp [ j ++ ] ; query [ i ] [ 1 ] = temp [ j ++ ] ; query [ i ] [ 2 ] = temp [ j ++ ] ; } for ( int i = 1 ; i <= m ; i ++ ) if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } }
import java . util . * ; class SortWave { void swap ( int arr [ ] , int a , int b ) { int temp = arr [ a ] ; arr [ a ] = arr [ b ] ; arr [ b ] = temp ; } void sortInWave ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i += 2 ) swap ( arr , i , i + 1 ) ; } public static void main ( String args [ ] ) { SortWave ob = new SortWave ( ) ; int arr [ ] = { 10 , 90 , 49 , 2 , 1 , 5 , 23 } ; int n = arr . length ; ob . sortInWave ( arr , n ) ; for ( int i : arr ) System . out . print ( i + " ▁ " ) ; } }
class MergeArrays { void moveToEnd ( int mPlusN [ ] , int size ) { int i , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) { if ( mPlusN [ i ] != - 1 ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } } void merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) || ( j == n ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { MergeArrays mergearray = new MergeArrays ( ) ; int mPlusN [ ] = { 2 , 8 , - 1 , - 1 , - 1 , 13 , - 1 , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = N . length ; int m = mPlusN . length - n ; mergearray . moveToEnd ( mPlusN , m + n ) ; mergearray . merge ( mPlusN , N , m , n ) ; mergearray . printArray ( mPlusN , m + n ) ; } }
class Test { static int arr [ ] = new int [ ] { 1 , 20 , 6 , 4 , 5 } ; static int getInvCount ( int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; } public static void main ( String [ ] args ) { System . out . println ( " Number ▁ of ▁ inversions ▁ are ▁ " + getInvCount ( arr . length ) ) ; } }
import java . util . * ; import java . lang . * ; class Main { static void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { System . out . println ( " Invalid ▁ Input " ) ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } System . out . println ( " ▁ The ▁ two ▁ elements ▁ whose ▁ " + " sum ▁ is ▁ minimum ▁ are ▁ " + arr [ min_l ] + " ▁ and ▁ " + arr [ min_r ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 60 , - 10 , 70 , - 80 , 85 } ; minAbsSumPair ( arr , 6 ) ; } }
import java . io . * ; class countzot { static void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; break ; } } } } static void printArray ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int arr_size = arr . length ; sort012 ( arr , arr_size ) ; System . out . println ( " Array ▁ after ▁ seggregation ▁ " ) ; printArray ( arr , arr_size ) ; } }
class Main { static void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { System . out . println ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } System . out . println ( " ▁ The ▁ unsorted ▁ subarray ▁ which " + " ▁ makes ▁ the ▁ given ▁ array ▁ sorted ▁ lies " + " ▁ between ▁ the ▁ indices ▁ " + s + " ▁ and ▁ " + e ) ; return ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = arr . length ; printUnsorted ( arr , arr_size ) ; } }
class Main { static int findElement ( int arr [ ] , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = arr . length ; int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) System . out . println ( " Element ▁ not ▁ found " ) ; else System . out . println ( " Element ▁ Found ▁ at ▁ Position : ▁ " + ( position + 1 ) ) ; } }
class Main { static int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return - 1 ; int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = arr . length - 1 ; key = 10 ; System . out . println ( " Index : ▁ " + binarySearch ( arr , 0 , n , key ) ) ; } }
class EquilibriumIndex { int equilibrium ( int arr [ ] , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; } public static void main ( String [ ] args ) { EquilibriumIndex equi = new EquilibriumIndex ( ) ; int arr [ ] = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; int arr_size = arr . length ; System . out . println ( " First ▁ equilibrium ▁ index ▁ is ▁ " + equi . equilibrium ( arr , arr_size ) ) ; } }
class Main { static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = arr . length ; int x = 8 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) System . out . println ( " Ceiling ▁ of ▁ " + x + " ▁ doesn ' t ▁ exist ▁ in ▁ array " ) ; else System . out . println ( " ceiling ▁ of ▁ " + x + " ▁ is ▁ " + arr [ index ] ) ; } }
class GfG { static class Node { int data ; Node left ; Node right ; } static int getHeight ( Node Node ) { if ( Node == null ) return 0 ; else { int lHeight = getHeight ( Node . left ) ; int rHeight = getHeight ( Node . right ) ; if ( lHeight > rHeight ) return ( lHeight + 1 ) ; else return ( rHeight + 1 ) ; } } static Node newNode ( int data ) { Node Node = new Node ( ) ; Node . data = data ; Node . left = null ; Node . right = null ; return ( Node ) ; } static int getTotalHeight ( Node root ) { if ( root == null ) return 0 ; return getTotalHeight ( root . left ) + getHeight ( root ) + getTotalHeight ( root . right ) ; } public static void main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; System . out . println ( " Sum ▁ of ▁ heights ▁ of ▁ all ▁ Nodes ▁ = ▁ " + getTotalHeight ( root ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static int majorityElement ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; int count = 1 , max_ele = - 1 , temp = arr [ 0 ] , ele = 0 , f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( temp == arr [ i ] ) { count ++ ; } else { count = 1 ; temp = arr [ i ] ; } if ( max_ele < count ) { max_ele = count ; ele = arr [ i ] ; if ( max_ele > ( n / 2 ) ) { f = 1 ; break ; } } } return ( f == 1 ? ele : - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 5 , 1 } ; int n = 7 ; System . out . println ( majorityElement ( arr , n ) ) ; } }
import java . io . * ; class Majority { static boolean isMajority ( int arr [ ] , int n , int x ) { int i , last_index = 0 ; last_index = ( n % 2 == 0 ) ? n / 2 : n / 2 + 1 ; for ( i = 0 ; i < last_index ; i ++ ) { if ( arr [ i ] == x && arr [ i + n / 2 ] == x ) return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 4 , 4 } ; int n = arr . length ; int x = 4 ; if ( isMajority ( arr , n , x ) == true ) System . out . println ( x + " ▁ appears ▁ more ▁ than ▁ " + n / 2 + " ▁ times ▁ in ▁ arr [ ] " ) ; else System . out . println ( x + " ▁ does ▁ not ▁ appear ▁ more ▁ than ▁ " + n / 2 + " ▁ times ▁ in ▁ arr [ ] " ) ; } }
class GFG { static class Node { int data ; Node left ; Node right ; } ; static int sum ; static Node newNode ( int data ) { Node Node = new Node ( ) ; Node . data = data ; Node . left = null ; Node . right = null ; return ( Node ) ; } static int getTotalHeightUtil ( Node root ) { if ( root == null ) { return 0 ; } int lh = getTotalHeightUtil ( root . left ) ; int rh = getTotalHeightUtil ( root . right ) ; int h = Math . max ( lh , rh ) + 1 ; sum = sum + h ; return h ; } static int getTotalHeight ( Node root ) { sum = 0 ; getTotalHeightUtil ( root ) ; return sum ; } public static void main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; System . out . printf ( " Sum ▁ of ▁ heights ▁ of ▁ all ▁ Nodes ▁ = ▁ % d " , getTotalHeight ( root ) ) ; } }
import java . util . * ; class Main { public static void bfs ( int n , int m , int num ) { Queue < Integer > q = new LinkedList < Integer > ( ) ; q . add ( num ) ; while ( ! q . isEmpty ( ) ) { int stepNum = q . poll ( ) ; if ( stepNum <= m && stepNum >= n ) { System . out . print ( stepNum + " ▁ " ) ; } if ( stepNum == 0 stepNum > m ) continue ; int lastDigit = stepNum % 10 ; int stepNumA = stepNum * 10 + ( lastDigit - 1 ) ; int stepNumB = stepNum * 10 + ( lastDigit + 1 ) ; if ( lastDigit == 0 ) q . add ( stepNumB ) ; else if ( lastDigit == 9 ) q . add ( stepNumA ) ; else { q . add ( stepNumA ) ; q . add ( stepNumB ) ; } } } public static void displaySteppingNumbers ( int n , int m ) { for ( int i = 0 ; i <= 9 ; i ++ ) bfs ( n , m , i ) ; } public static void main ( String args [ ] ) { int n = 0 , m = 21 ; displaySteppingNumbers ( n , m ) ; } }
import java . util . LinkedList ; import java . util . Queue ; public class GFG { static class Node { int data ; Node left ; Node right ; Node ( int data ) { this . data = data ; left = null ; right = null ; } } static void levelOrder ( Node root ) { if ( root == null ) return ; Queue < Node > q = new LinkedList < > ( ) ; q . add ( root ) ; q . add ( null ) ; while ( ! q . isEmpty ( ) ) { Node curr = q . poll ( ) ; if ( curr == null ) { if ( ! q . isEmpty ( ) ) { q . add ( null ) ; System . out . println ( ) ; } } else { if ( curr . left != null ) q . add ( curr . left ) ; if ( curr . right != null ) q . add ( curr . right ) ; System . out . print ( curr . data + " ▁ " ) ; } } } public static void main ( String [ ] args ) { Node root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . left . left = new Node ( 4 ) ; root . left . right = new Node ( 5 ) ; root . right . right = new Node ( 6 ) ; levelOrder ( root ) ; } }
import java . util . * ; class GFG { static int shortestChainLen ( String start , String target , Set < String > D ) { if ( start == target ) return 0 ; if ( ! D . contains ( target ) ) return 0 ; int level = 0 , wordlength = start . length ( ) ; Queue < String > Q = new LinkedList < > ( ) ; Q . add ( start ) ; while ( ! Q . isEmpty ( ) ) { ++ level ; int sizeofQ = Q . size ( ) ; for ( int i = 0 ; i < sizeofQ ; ++ i ) { char [ ] word = Q . peek ( ) . toCharArray ( ) ; Q . remove ( ) ; for ( int pos = 0 ; pos < wordlength ; ++ pos ) { char orig_char = word [ pos ] ; for ( char c = ' a ' ; c <= ' z ' ; ++ c ) { word [ pos ] = c ; if ( String . valueOf ( word ) . equals ( target ) ) return level + 1 ; if ( ! D . contains ( String . valueOf ( word ) ) ) continue ; D . remove ( String . valueOf ( word ) ) ; Q . add ( String . valueOf ( word ) ) ; } word [ pos ] = orig_char ; } } } return 0 ; } public static void main ( String [ ] args ) { Set < String > D = new HashSet < String > ( ) ; D . add ( " poon " ) ; D . add ( " plee " ) ; D . add ( " same " ) ; D . add ( " poie " ) ; D . add ( " plie " ) ; D . add ( " poin " ) ; D . add ( " plea " ) ; String start = " toon " ; String target = " plea " ; System . out . print ( " Length ▁ of ▁ shortest ▁ chain ▁ is : ▁ " + shortestChainLen ( start , target , D ) ) ; } }
class Node { int data ; Node next ; Node ( int d ) { data = d ; next = null ; } } class LinkedList { Node head ; void push ( int new_data ) { Node new_node = new Node ( new_data ) ; new_node . next = head ; head = new_node ; } void printList ( ) { Node node = head ; while ( node != null ) { System . out . print ( node . data + " ▁ " ) ; node = node . next ; } System . out . println ( " " ) ; } int countNodes ( ) { int count = 0 ; Node s = head ; while ( s != null ) { count ++ ; s = s . next ; } return count ; } void swapKth ( int k ) { int n = countNodes ( ) ; if ( n < k ) return ; if ( 2 * k - 1 == n ) return ; Node x = head ; Node x_prev = null ; for ( int i = 1 ; i < k ; i ++ ) { x_prev = x ; x = x . next ; } Node y = head ; Node y_prev = null ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { y_prev = y ; y = y . next ; } if ( x_prev != null ) x_prev . next = y ; if ( y_prev != null ) y_prev . next = x ; Node temp = x . next ; x . next = y . next ; y . next = temp ; if ( k == 1 ) head = y ; if ( k == n ) head = x ; } public static void main ( String [ ] args ) { LinkedList llist = new LinkedList ( ) ; for ( int i = 8 ; i >= 1 ; i -- ) llist . push ( i ) ; System . out . print ( " Original ▁ linked ▁ list : ▁ " ) ; llist . printList ( ) ; System . out . println ( " " ) ; for ( int i = 1 ; i < 9 ; i ++ ) { llist . swapKth ( i ) ; System . out . println ( " Modified ▁ List ▁ for ▁ k ▁ = ▁ " + i ) ; llist . printList ( ) ; System . out . println ( " " ) ; } } }
import java . util . * ; class GFG { static class Node { int data ; Node next , prev ; } ; static int countPairs ( Node first , Node second , int value ) { int count = 0 ; while ( first != null && second != null && first != second && second . next != first ) { if ( ( first . data + second . data ) == value ) { count ++ ; first = first . next ; second = second . prev ; } else if ( ( first . data + second . data ) > value ) second = second . prev ; else first = first . next ; } return count ; } static int countTriplets ( Node head , int x ) { if ( head == null ) return 0 ; Node current , first , last ; int count = 0 ; last = head ; while ( last . next != null ) last = last . next ; for ( current = head ; current != null ; current = current . next ) { first = current . next ; count += countPairs ( first , last , x - current . data ) ; } return count ; } static Node insert ( Node head , int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . next = temp . prev = null ; if ( ( head ) == null ) ( head ) = temp ; else { temp . next = head ; ( head ) . prev = temp ; ( head ) = temp ; } return head ; } public static void main ( String [ ] args ) { Node head = null ; head = insert ( head , 9 ) ; head = insert ( head , 8 ) ; head = insert ( head , 6 ) ; head = insert ( head , 5 ) ; head = insert ( head , 4 ) ; head = insert ( head , 2 ) ; head = insert ( head , 1 ) ; int x = 17 ; System . out . print ( " Count ▁ = ▁ " + countTriplets ( head , x ) ) ; } }
class GfG { static class Node { char data ; Node next ; } static Node newNode ( char key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } static void printlist ( Node head ) { if ( head == null ) { System . out . println ( " Empty ▁ List " ) ; return ; } while ( head != null ) { System . out . print ( head . data + " ▁ " ) ; if ( head . next != null ) System . out . print ( " - > ▁ " ) ; head = head . next ; } System . out . println ( ) ; } static boolean isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } static Node arrange ( Node head ) { Node newHead = head ; Node latestVowel ; Node curr = head ; if ( head == null ) return null ; if ( isVowel ( head . data ) == true ) latestVowel = head ; else { while ( curr . next != null && ! isVowel ( curr . next . data ) ) curr = curr . next ; if ( curr . next == null ) return head ; latestVowel = newHead = curr . next ; curr . next = curr . next . next ; latestVowel . next = head ; } while ( curr != null && curr . next != null ) { if ( isVowel ( curr . next . data ) == true ) { if ( curr == latestVowel ) { latestVowel = curr = curr . next ; } else { Node temp = latestVowel . next ; latestVowel . next = curr . next ; latestVowel = latestVowel . next ; curr . next = curr . next . next ; latestVowel . next = temp ; } } else { curr = curr . next ; } } return newHead ; } public static void main ( String [ ] args ) { Node head = newNode ( ' a ' ) ; head . next = newNode ( ' b ' ) ; head . next . next = newNode ( ' c ' ) ; head . next . next . next = newNode ( ' e ' ) ; head . next . next . next . next = newNode ( ' d ' ) ; head . next . next . next . next . next = newNode ( ' o ' ) ; head . next . next . next . next . next . next = newNode ( ' x ' ) ; head . next . next . next . next . next . next . next = newNode ( ' i ' ) ; System . out . println ( " Linked ▁ list ▁ before ▁ : ▁ " ) ; printlist ( head ) ; head = arrange ( head ) ; System . out . println ( " Linked ▁ list ▁ after ▁ : " ) ; printlist ( head ) ; } }
import java . io . * ; class Node { int data ; Node left , right ; Node ( int x ) { data = x ; left = right = null ; } } class GFG { static int count = 0 ; public static Node insert ( Node root , int x ) { if ( root == null ) return new Node ( x ) ; if ( x < root . data ) root . left = insert ( root . left , x ) ; else if ( x > root . data ) root . right = insert ( root . right , x ) ; return root ; } public static Node kthSmallest ( Node root , int k ) { if ( root == null ) return null ; Node left = kthSmallest ( root . left , k ) ; if ( left != null ) return left ; count ++ ; if ( count == k ) return root ; return kthSmallest ( root . right , k ) ; } public static void printKthSmallest ( Node root , int k ) { count = 0 ; Node res = kthSmallest ( root , k ) ; if ( res == null ) System . out . println ( " There ▁ are ▁ less ▁ " + " than ▁ k ▁ nodes ▁ in ▁ the ▁ BST " ) ; else System . out . println ( " K - th ▁ Smallest " + " ▁ Element ▁ is ▁ " + res . data ) ; } public static void main ( String [ ] args ) { Node root = null ; int keys [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; for ( int x : keys ) root = insert ( root , x ) ; int k = 3 ; printKthSmallest ( root , k ) ; } }
class GfG { static class Node { Node left , right ; int key ; } static Node newNode ( int key ) { Node ptr = new Node ( ) ; ptr . key = key ; ptr . left = null ; ptr . right = null ; return ptr ; } static Node insert ( Node root , int key ) { if ( root == null ) root = newNode ( key ) ; else if ( root . key > key ) root . left = insert ( root . left , key ) ; else if ( root . key < key ) root . right = insert ( root . right , key ) ; return root ; } static int distanceFromRoot ( Node root , int x ) { if ( root . key == x ) return 0 ; else if ( root . key > x ) return 1 + distanceFromRoot ( root . left , x ) ; return 1 + distanceFromRoot ( root . right , x ) ; } static int distanceBetween2 ( Node root , int a , int b ) { if ( root == null ) return 0 ; if ( root . key > a && root . key > b ) return distanceBetween2 ( root . left , a , b ) ; if ( root . key < a && root . key < b ) return distanceBetween2 ( root . right , a , b ) ; if ( root . key >= a && root . key <= b ) return distanceFromRoot ( root , a ) + distanceFromRoot ( root , b ) ; return 0 ; } static int findDistWrapper ( Node root , int a , int b ) { int temp = 0 ; if ( a > b ) { temp = a ; a = b ; b = temp ; } return distanceBetween2 ( root , a , b ) ; } public static void main ( String [ ] args ) { Node root = null ; root = insert ( root , 20 ) ; insert ( root , 10 ) ; insert ( root , 5 ) ; insert ( root , 15 ) ; insert ( root , 30 ) ; insert ( root , 25 ) ; insert ( root , 35 ) ; System . out . println ( findDistWrapper ( root , 5 , 35 ) ) ; } }
class GfG { static class node { int data ; node left , right ; } ; static class INT { int a ; } static boolean inRange ( node root , int low , int high ) { return root . data >= low && root . data <= high ; } static boolean getCountUtil ( node root , int low , int high , INT count ) { if ( root == null ) return true ; boolean l = getCountUtil ( root . left , low , high , count ) ; boolean r = getCountUtil ( root . right , low , high , count ) ; if ( l && r && inRange ( root , low , high ) ) { ++ count . a ; return true ; } return false ; } static INT getCount ( node root , int low , int high ) { INT count = new INT ( ) ; count . a = 0 ; getCountUtil ( root , low , high , count ) ; return count ; } static node newNode ( int data ) { node temp = new node ( ) ; temp . data = data ; temp . left = temp . right = null ; return ( temp ) ; } public static void main ( String args [ ] ) { node root = newNode ( 10 ) ; root . left = newNode ( 5 ) ; root . right = newNode ( 50 ) ; root . left . left = newNode ( 1 ) ; root . right . left = newNode ( 40 ) ; root . right . right = newNode ( 100 ) ; int l = 5 ; int h = 45 ; System . out . println ( " Count ▁ of ▁ subtrees ▁ in ▁ [ " + l + " , ▁ " + h + " ] ▁ is ▁ " + getCount ( root , l , h ) . a ) ; } }
class GFG { private static void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; System . out . print ( arr [ start ] + " ▁ " ) ; printSorted ( arr , start * 2 + 2 , end ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; printSorted ( arr , 0 , arr . length - 1 ) ; } }
import java . io . * ; class GFG { static int findMinOpeartion ( int matrix [ ] [ ] , int n ) { int [ ] sumRow = new int [ n ] ; int [ ] sumCol = new int [ n ] ; for ( int i = 0 ; i < n ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) { sumRow [ i ] += matrix [ i ] [ j ] ; sumCol [ j ] += matrix [ i ] [ j ] ; } int maxSum = 0 ; for ( int i = 0 ; i < n ; ++ i ) { maxSum = Math . max ( maxSum , sumRow [ i ] ) ; maxSum = Math . max ( maxSum , sumCol [ i ] ) ; } int count = 0 ; for ( int i = 0 , j = 0 ; i < n && j < n ; ) { int diff = Math . min ( maxSum - sumRow [ i ] , maxSum - sumCol [ j ] ) ; matrix [ i ] [ j ] += diff ; sumRow [ i ] += diff ; sumCol [ j ] += diff ; count += diff ; if ( sumRow [ i ] == maxSum ) ++ i ; if ( sumCol [ j ] == maxSum ) ++ j ; } return count ; } static void printMatrix ( int matrix [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) System . out . print ( matrix [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int matrix [ ] [ ] = { { 1 , 2 } , { 3 , 4 } } ; System . out . println ( findMinOpeartion ( matrix , 2 ) ) ; printMatrix ( matrix , 2 ) ; } }
class GFG { private static void search ( int [ ] [ ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { System . out . print ( " n ▁ Found ▁ at ▁ " + i + " ▁ " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } System . out . print ( " n ▁ Element ▁ not ▁ found " ) ; return ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; search ( mat , 4 , 29 ) ; } }
public class GFG { static boolean areSumSame ( int a [ ] [ ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; } public static void main ( String args [ ] ) { int n = 4 ; int m = 4 ; int M [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 9 , 5 , 3 , 1 } , { 0 , 3 , 5 , 6 } , { 0 , 4 , 5 , 6 } } ; if ( areSumSame ( M , n , m ) == true ) System . out . print ( "1NEW_LINE"); else System . out . print ( "0NEW_LINE"); } }
class GFG { static final int N = 5 ; static final int M = 5 ; static int minOperation ( boolean arr [ ] [ ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; } public static void main ( String [ ] args ) { boolean mat [ ] [ ] = { { false , false , true , true , true } , { false , false , false , true , true } , { false , false , false , true , true } , { true , true , true , true , true } , { true , true , true , true , true } } ; System . out . println ( minOperation ( mat ) ) ; } }
class GFG { static int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( spiralDiaSum ( n ) ) ; } }
class GFG { static final int MAX = 100 ; static void printMatrixDiagonal ( int mat [ ] [ ] , int n ) { int i = 0 , j = 0 ; boolean isUp = true ; for ( int k = 0 ; k < n * n ; ) { if ( isUp ) { for ( ; i >= 0 && j < n ; j ++ , i -- ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; k ++ ; } if ( i < 0 && j <= n - 1 ) i = 0 ; if ( j == n ) { i = i + 2 ; j -- ; } } else { for ( ; j >= 0 && i < n ; i ++ , j -- ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; k ++ ; } if ( j < 0 && i <= n - 1 ) j = 0 ; if ( i == n ) { j = j + 2 ; i -- ; } } isUp = ! isUp ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int n = 3 ; printMatrixDiagonal ( mat , n ) ; } }
import java . io . * ; class GFG { static int R = 3 ; static int C = 4 ; static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static void replacematrix ( int [ ] [ ] mat , int n , int m ) { int [ ] rgcd = new int [ R ] ; int [ ] cgcd = new int [ C ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { rgcd [ i ] = gcd ( rgcd [ i ] , mat [ i ] [ j ] ) ; cgcd [ j ] = gcd ( cgcd [ j ] , mat [ i ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) mat [ i ] [ j ] = Math . max ( rgcd [ i ] , cgcd [ j ] ) ; } static public void main ( String [ ] args ) { int [ ] [ ] m = { { 1 , 2 , 3 , 3 } , { 4 , 5 , 6 , 6 } , { 7 , 8 , 9 , 9 } , } ; replacematrix ( m , R , C ) ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) System . out . print ( m [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } }
class GFG { static int MAX = 100 ; static int sortedCount ( int mat [ ] [ ] , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; } public static void main ( String arg [ ] ) { int m = 4 , n = 5 ; int mat [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 4 , 3 , 1 , 2 , 6 } , { 8 , 7 , 6 , 5 , 4 } , { 5 , 7 , 8 , 9 , 10 } } ; System . out . print ( sortedCount ( mat , m , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int findMaxValue ( int N , int mat [ ] [ ] ) { int maxValue = Integer . MIN_VALUE ; int maxArr [ ] [ ] = new int [ N ] [ N ] ; maxArr [ N - 1 ] [ N - 1 ] = mat [ N - 1 ] [ N - 1 ] ; int maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( mat [ N - 1 ] [ j ] > maxv ) maxv = mat [ N - 1 ] [ j ] ; maxArr [ N - 1 ] [ j ] = maxv ; } maxv = mat [ N - 1 ] [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( mat [ i ] [ N - 1 ] > maxv ) maxv = mat [ i ] [ N - 1 ] ; maxArr [ i ] [ N - 1 ] = maxv ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = N - 2 ; j >= 0 ; j -- ) { if ( maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] > maxValue ) maxValue = maxArr [ i + 1 ] [ j + 1 ] - mat [ i ] [ j ] ; maxArr [ i ] [ j ] = Math . max ( mat [ i ] [ j ] , Math . max ( maxArr [ i ] [ j + 1 ] , maxArr [ i + 1 ] [ j ] ) ) ; } } return maxValue ; } public static void main ( String [ ] args ) { int N = 5 ; int mat [ ] [ ] = { { 1 , 2 , - 1 , - 4 , - 20 } , { - 8 , - 3 , 4 , 2 , 1 } , { 3 , 8 , 6 , 1 , 3 } , { - 4 , - 1 , 1 , 7 , - 6 } , { 0 , - 4 , 10 , - 5 , 1 } } ; System . out . print ( " Maximum ▁ Value ▁ is ▁ " + findMaxValue ( N , mat ) ) ; } }
class GFG { static int ROW = 4 ; static int COL = 5 ; static void findUniqueRows ( int M [ ] [ ] ) { for ( int i = 0 ; i < ROW ; i ++ ) { int flag = 0 ; for ( int j = 0 ; j < i ; j ++ ) { flag = 1 ; for ( int k = 0 ; k < COL ; k ++ ) if ( M [ i ] [ k ] != M [ j ] [ k ] ) flag = 0 ; if ( flag == 1 ) break ; } if ( flag == 0 ) { for ( int j = 0 ; j < COL ; j ++ ) System . out . print ( M [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } } public static void main ( String [ ] args ) { int M [ ] [ ] = { { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 0 , 0 } } ; findUniqueRows ( M ) ; } }
class GFG { static int R = 3 ; static int C = 3 ; static class Cell { int r ; int c ; public Cell ( int r , int c ) { this . r = r ; this . c = c ; } } ; static void printSums ( int mat [ ] [ ] , Cell arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 , r = arr [ i ] . r , c = arr [ i ] . c ; for ( int j = 0 ; j < R ; j ++ ) { for ( int k = 0 ; k < C ; k ++ ) { if ( j != r && k != c ) { sum += mat [ j ] [ k ] ; } } } System . out . println ( sum ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 2 } , { 3 , 4 , 6 } , { 5 , 3 , 2 } } ; Cell arr [ ] = { new Cell ( 0 , 0 ) , new Cell ( 1 , 1 ) , new Cell ( 0 , 1 ) } ; int n = arr . length ; printSums ( mat , arr , n ) ; } }
import java . io . * ; class GFG { static int n = 5 ; static void printSumTricky ( int mat [ ] [ ] , int k ) { if ( k > n ) return ; int stripSum [ ] [ ] = new int [ n ] [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += mat [ i ] [ j ] ; stripSum [ 0 ] [ j ] = sum ; for ( int i = 1 ; i < n - k + 1 ; i ++ ) { sum += ( mat [ i + k - 1 ] [ j ] - mat [ i - 1 ] [ j ] ) ; stripSum [ i ] [ j ] = sum ; } } for ( int i = 0 ; i < n - k + 1 ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < k ; j ++ ) sum += stripSum [ i ] [ j ] ; System . out . print ( sum + " ▁ " ) ; for ( int j = 1 ; j < n - k + 1 ; j ++ ) { sum += ( stripSum [ i ] [ j + k - 1 ] - stripSum [ i ] [ j - 1 ] ) ; System . out . print ( sum + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 , 4 } , { 5 , 5 , 5 , 5 , 5 } , } ; int k = 3 ; printSumTricky ( mat , k ) ; } }
class GFG { static final int R = 3 ; static final int C = 3 ; static final int MAX_K = 100 ; static int [ ] [ ] [ ] dp = new int [ R ] [ C ] [ MAX_K ] ; static int pathCountDPRecDP ( int [ ] [ ] mat , int m , int n , int k ) { if ( m < 0 n < 0 ) return 0 ; if ( m == 0 && n == 0 ) return ( k == mat [ m ] [ n ] ? 1 : 0 ) ; if ( dp [ m ] [ n ] [ k ] != - 1 ) return dp [ m ] [ n ] [ k ] ; dp [ m ] [ n ] [ k ] = pathCountDPRecDP ( mat , m - 1 , n , k - mat [ m ] [ n ] ) + pathCountDPRecDP ( mat , m , n - 1 , k - mat [ m ] [ n ] ) ; return dp [ m ] [ n ] [ k ] ; } static int pathCountDP ( int [ ] [ ] mat , int k ) { for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) for ( int l = 0 ; l < MAX_K ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; return pathCountDPRecDP ( mat , R - 1 , C - 1 , k ) ; } public static void main ( String [ ] args ) { int k = 12 ; int [ ] [ ] mat = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 } , new int [ ] { 4 , 6 , 5 } , new int [ ] { 3 , 2 , 1 } } ; System . out . println ( pathCountDP ( mat , k ) ) ; } }
class path { static int x [ ] = { 0 , 1 , 1 , - 1 , 1 , 0 , - 1 , - 1 } ; static int y [ ] = { 1 , 0 , 1 , 1 , - 1 , - 1 , 0 , - 1 } ; static int R = 3 ; static int C = 3 ; static int dp [ ] [ ] = new int [ R ] [ C ] ; static boolean isvalid ( int i , int j ) { if ( i < 0 j < 0 i >= R j >= C ) return false ; return true ; } static boolean isadjacent ( char prev , char curr ) { return ( ( curr - prev ) == 1 ) ; } static int getLenUtil ( char mat [ ] [ ] , int i , int j , char prev ) { if ( ! isvalid ( i , j ) || ! isadjacent ( prev , mat [ i ] [ j ] ) ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; int ans = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) ; return dp [ i ] [ j ] = ans ; } static int getLen ( char mat [ ] [ ] , char s ) { for ( int i = 0 ; i < R ; ++ i ) for ( int j = 0 ; j < C ; ++ j ) dp [ i ] [ j ] = - 1 ; int ans = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == s ) { for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; } public static void main ( String args [ ] ) { char mat [ ] [ ] = { { ' a ' , ' c ' , ' d ' } , { ' h ' , ' b ' , ' a ' } , { ' i ' , ' g ' , ' f ' } } ; System . out . println ( getLen ( mat , ' a ' ) ) ; System . out . println ( getLen ( mat , ' e ' ) ) ; System . out . println ( getLen ( mat , ' b ' ) ) ; System . out . println ( getLen ( mat , ' f ' ) ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int count [ ] = new int [ size ] ; int i ; System . out . println ( " Repeated ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) System . out . print ( arr [ i ] + " ▁ " ) ; else count [ arr [ i ] ] ++ ; } } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int i ; System . out . println ( " The ▁ repeating ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else System . out . print ( Math . abs ( arr [ i ] ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
class Main { static int binarySearch ( int arr [ ] , int low , int high ) { if ( high >= low ) { int mid = ( low + high ) / 2 ; if ( mid == arr [ mid ] ) return mid ; if ( mid > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high ) ; else return binarySearch ( arr , low , ( mid - 1 ) ) ; } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = arr . length ; System . out . println ( " Fixed ▁ Point ▁ is ▁ " + binarySearch ( arr , 0 , n - 1 ) ) ; } }
class SubarraySum { int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + i + " ▁ and ▁ " + p ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } System . out . println ( " No ▁ subarray ▁ found " ) ; return 0 ; } public static void main ( String [ ] args ) { SubarraySum arraysum = new SubarraySum ( ) ; int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = arr . length ; int sum = 23 ; arraysum . subArraySum ( arr , n , sum ) ; } }
public class GFG { static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } static int minCost ( int cost [ ] [ ] , int m , int n ) { if ( n < 0 m < 0 ) return Integer . MAX_VALUE ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . print ( minCost ( cost , 2 , 2 ) ) ; } }
import java . util . * ; class MinimumCostPath { private static int minCost ( int cost [ ] [ ] , int m , int n ) { int i , j ; int tc [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; } private static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . println ( minCost ( cost , 2 , 2 ) ) ; } }
class MatrixChainMultiplication { static int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; int size = arr . length ; System . out . println ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " + MatrixChainOrder ( arr , size ) ) ; } }
class Knapsack { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } public static void main ( String args [ ] ) { int val [ ] = new int [ ] { 60 , 100 , 120 } ; int wt [ ] = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }
class Knapsack { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; } public static void main ( String args [ ] ) { int val [ ] = new int [ ] { 60 , 100 , 120 } ; int wt [ ] = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }
class GFG { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( char seq [ ] , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } public static void main ( String [ ] args ) { String seq = " GEEKSFORGEEKS " ; int n = seq . length ( ) ; System . out . printf ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d " , lps ( seq . toCharArray ( ) , 0 , n - 1 ) ) ; } }
class RodCutting { static int cutRod ( int price [ ] , int n ) { int val [ ] = new int [ n + 1 ] ; val [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int max_val = Integer . MIN_VALUE ; for ( int j = 0 ; j < i ; j ++ ) max_val = Math . max ( max_val , price [ j ] + val [ i - j - 1 ] ) ; val [ i ] = max_val ; } return val [ n ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 5 , 8 , 9 , 10 , 17 , 17 , 20 } ; int size = arr . length ; System . out . println ( " Maximum ▁ Obtainable ▁ Value ▁ is ▁ " + cutRod ( arr , size ) ) ; } }
import java . util . Arrays ; class GFG { static int count ( int n ) { int table [ ] = new int [ n + 1 ] , i ; Arrays . fill ( table , 0 ) ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( " Count ▁ for ▁ " + n + " ▁ is ▁ " + count ( n ) ) ; n = 13 ; System . out . println ( " Count ▁ for ▁ " + n + " ▁ is ▁ " + count ( n ) ) ; } }
public class NaiveSearch { public static void search ( String txt , String pat ) { int M = pat . length ( ) ; int N = txt . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } } public static void main ( String [ ] args ) { String txt = " AABAACAADAABAAABAA " ; String pat = " AABA " ; search ( txt , pat ) ; } }
public class Main { public final static int d = 256 ; static void search ( String pat , String txt , int q ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i , j ; int p = 0 ; int t = 0 ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat . charAt ( i ) ) % q ; t = ( d * t + txt . charAt ( i ) ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; } if ( j == M ) System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } if ( i < N - M ) { t = ( d * ( t - txt . charAt ( i ) * h ) + txt . charAt ( i + M ) ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } public static void main ( String [ ] args ) { String txt = " GEEKS ▁ FOR ▁ GEEKS " ; String pat = " GEEK " ; int q = 101 ; search ( pat , txt , q ) ; } }
class GFG { static int power ( int x , int y ) { if ( y == 0 ) return 1 ; else if ( y % 2 == 0 ) return power ( x , y / 2 ) * power ( x , y / 2 ) ; else return x * power ( x , y / 2 ) * power ( x , y / 2 ) ; } public static void main ( String [ ] args ) { int x = 2 ; int y = 3 ; System . out . printf ( " % d " , power ( x , y ) ) ; } }
import java . util . * ; class GFG { static double area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } static boolean isInside ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x , int y ) { double A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; double A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; double A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; double A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; } public static void main ( String [ ] args ) { if ( isInside ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) System . out . println ( " Inside " ) ; else System . out . println ( " Not ▁ Inside " ) ; } }
import java . io . * ; class GFG { public static int counter = 2 ; static boolean isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; } public static void main ( String [ ] args ) { int x = 5 ; if ( isLucky ( x ) ) System . out . println ( x + " ▁ is ▁ a ▁ lucky ▁ no . " ) ; else System . out . println ( x + " ▁ is ▁ not ▁ a ▁ lucky ▁ no . " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } static int findSmallerInRight ( String str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str . charAt ( i ) < str . charAt ( low ) ) ++ countRight ; return countRight ; } static int findRank ( String str ) { int len = str . length ( ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; for ( int i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; } public static void main ( String [ ] args ) { String str = " string " ; System . out . println ( findRank ( str ) ) ; } }
class BinomialCoefficient { static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void main ( String [ ] args ) { int n = 8 ; int k = 2 ; System . out . println ( " Value ▁ of ▁ C ( " + n + " , ▁ " + k + " ) ▁ " + " is " + " ▁ " + binomialCoeff ( n , k ) ) ; } }
import java . io . * ; class GFG { public static void printPascal ( int n ) { int [ ] [ ] arr = new int [ n ] [ n ] ; for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) { if ( line == i i == 0 ) arr [ line ] [ i ] = 1 ; else arr [ line ] [ i ] = arr [ line - 1 ] [ i - 1 ] + arr [ line - 1 ] [ i ] ; System . out . print ( arr [ line ] [ i ] ) ; } System . out . println ( " " ) ; } } } public static void main ( String [ ] args ) { int n = 5 ; printPascal ( n ) ; }
import java . io . * ; class GFG { static float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; } public static void main ( String [ ] args ) { int n = 10 ; float x = 1 ; System . out . println ( " e ^ x ▁ = ▁ " + exponential ( n , x ) ) ; } }
import java . io . * ; import java . lang . Math ; class GFG { public static void primeFactors ( int n ) { while ( n % 2 == 0 ) { System . out . print ( 2 + " ▁ " ) ; n /= 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { System . out . print ( i + " ▁ " ) ; n /= i ; } } if ( n > 2 ) System . out . print ( n ) ; } public static void main ( String [ ] args ) { int n = 315 ; primeFactors ( n ) ; } }
import java . io . * ; class Combination { static void printCombination ( int arr [ ] , int n , int r ) { int data [ ] = new int [ r ] ; combinationUtil ( arr , n , r , 0 , data , 0 ) ; } static void combinationUtil ( int arr [ ] , int n , int r , int index , int data [ ] , int i ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + " ▁ " ) ; System . out . println ( " " ) ; return ; } if ( i >= n ) return ; data [ index ] = arr [ i ] ; combinationUtil ( arr , n , r , index + 1 , data , i + 1 ) ; combinationUtil ( arr , n , r , index , data , i + 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; printCombination ( arr , n , r ) ; } }
class GFG { static int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = arr . length ; System . out . println ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " + getSingle ( arr , n ) ) ; } }
class GFG { static final int INT_SIZE = 32 ; static int getSingle ( int arr [ ] , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = arr . length ; System . out . println ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " + getSingle ( arr , n ) ) ; } }
public class GFG { static int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { boolean k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; } public static void main ( String [ ] args ) { int n = 17 ; System . out . println ( countSetBits ( n ) ) ; } }
import java . io . * ; class GFG { static int Add ( int x , int y ) { while ( y != 0 ) { int carry = x & y ; x = x ^ y ; y = carry << 1 ; } return x ; } public static void main ( String arg [ ] ) { System . out . println ( Add ( 15 , 32 ) ) ; } }
class GFG { static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } public static void main ( String [ ] args ) { int x = 12 , y = 15 , z = 5 ; System . out . printf ( " Minimum ▁ of ▁ 3" + " ▁ numbers ▁ is ▁ % d " , smallest ( x , y , z ) ) ; } }
class GFG { static int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) >= 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } public static void main ( String [ ] args ) { System . out . println ( addOne ( 13 ) ) ; } }
class GFG { static int addOne ( int x ) { return ( - ( ~ x ) ) ; } public static void main ( String [ ] args ) { System . out . printf ( " % d " , addOne ( 13 ) ) ; } }
class GFG { static int isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } public static void main ( String [ ] args ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) == 1 ) System . out . println ( test_no + " ▁ is ▁ a ▁ power ▁ of ▁ 4" ) ; else System . out . println ( test_no + " is ▁ not ▁ a ▁ power ▁ of ▁ 4" ) ; } }
import java . io . * ; class GFG { public static int absbit32 ( int x , int y ) { int sub = x - y ; int mask = ( sub >> 31 ) ; return ( sub ^ mask ) - mask ; } public static int max ( int x , int y ) { int abs = absbit32 ( x , y ) ; return ( x + y + abs ) / 2 ; } public static int min ( int x , int y ) { int abs = absbit32 ( x , y ) ; return ( x + y - abs ) / 2 ; } public static void main ( String [ ] args ) { System . out . println ( max ( 2 , 3 ) ) ; System . out . println ( max ( 2 , - 3 ) ) ; System . out . println ( max ( - 2 , - 3 ) ) ; System . out . println ( min ( 2 , 3 ) ) ; System . out . println ( min ( 2 , - 3 ) ) ; System . out . println ( min ( - 2 , - 3 ) ) ; } }
import java . io . * ; class countSetBits { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } public static void main ( String args [ ] ) { int i = 9 ; System . out . println ( countSetBits ( i ) ) ; } }
class GFG { static int [ ] BitsSetTable256 = new int [ 256 ] ; public static void initialize ( ) { BitsSetTable256 [ 0 ] = 0 ; for ( int i = 0 ; i < 256 ; i ++ ) { BitsSetTable256 [ i ] = ( i & 1 ) + BitsSetTable256 [ i / 2 ] ; } } public static int countSetBits ( int n ) { return ( BitsSetTable256 [ n & 0xff ] + BitsSetTable256 [ ( n >> 8 ) & 0xff ] + BitsSetTable256 [ ( n >> 16 ) & 0xff ] + BitsSetTable256 [ n >> 24 ] ) ; } public static void main ( String [ ] args ) { initialize ( ) ; int n = 9 ; System . out . print ( countSetBits ( n ) ) ; } }
import java . io . * ; class GFG { static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } public static void main ( String args [ ] ) { int n = 0 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }
import java . io . * ; class GFG { static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . BigInteger ; class GFG { static boolean getParity ( int n ) { boolean parity = false ; while ( n != 0 ) { parity = ! parity ; n = n & ( n - 1 ) ; } return parity ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( " Parity ▁ of ▁ no ▁ " + n + " ▁ = ▁ " + ( getParity ( n ) ? " odd " : " even " ) ) ; } }
class Test { static boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } public static void main ( String [ ] args ) { System . out . println ( isPowerOfTwo ( 31 ) ? " Yes " : " No " ) ; System . out . println ( isPowerOfTwo ( 64 ) ? " Yes " : " No " ) ; } }
import java . io . * ; class GFG { public static int Last_set_bit ( int n ) { int p = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) { return p ; } p ++ ; n = n >> 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int n = 18 ; int pos = Last_set_bit ( n ) ; if ( pos != - 1 ) System . out . println ( pos ) ; else System . out . println ( "0" ) ; } }
class GFG { static boolean isPowerOfTwo ( int n ) { return ( n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ) ? true : false ; } static int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int i = 1 , pos = 1 ; while ( ( i & n ) == 0 ) { i = i << 1 ; ++ pos ; } return pos ; } public static void main ( String [ ] args ) { int n = 16 ; int pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 12 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 128 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { int x = 10 ; int y = 5 ; x = x * y ; y = x / y ; x = x / y ; System . out . println ( " After ▁ swaping : " + " ▁ x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; } }
import java . io . * ; public class GFG { public static void main ( String a [ ] ) { int x = 10 ; int y = 5 ; x = x ^ y ; y = x ^ y ; x = x ^ y ; System . out . println ( " After ▁ swap : ▁ x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; } }
class GFG { static void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; } public static void main ( String [ ] args ) { int [ ] x = { 10 } ; swap ( x , x ) ; System . out . println ( " After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ " + x [ 0 ] ) ; } }
import java . io . * ; class GFG { public static void swap ( int a , int b ) { a = ( a & b ) + ( a b ) ; b = a + ( ~ b ) + 1 ; a = a + ( ~ b ) + 1 ; System . out . print ( " After ▁ swapping : ▁ a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b ) ; } public static void main ( String [ ] args ) { int a = 5 , b = 10 ; swap ( a , b ) ; } }
class Segregate { void segregate0and1 ( int arr [ ] , int size ) { int left = 0 , right = size - 1 ; while ( left < right ) { while ( arr [ left ] == 0 && left < right ) left ++ ; while ( arr [ right ] == 1 && left < right ) right -- ; if ( left < right ) { arr [ left ] = 0 ; arr [ right ] = 1 ; left ++ ; right -- ; } } } public static void main ( String [ ] args ) { Segregate seg = new Segregate ( ) ; int arr [ ] = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 } ; int i , arr_size = arr . length ; seg . segregate0and1 ( arr , arr_size ) ; System . out . print ( " Array ▁ after ▁ segregation ▁ is ▁ " ) ; for ( i = 0 ; i < 6 ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class FindMaximum { int maxIndexDiff ( int arr [ ] , int n ) { int maxDiff = - 1 ; int i , j ; for ( i = 0 ; i < n ; ++ i ) { for ( j = n - 1 ; j > i ; -- j ) { if ( arr [ j ] > arr [ i ] && maxDiff < ( j - i ) ) maxDiff = j - i ; } } return maxDiff ; } public static void main ( String [ ] args ) { FindMaximum max = new FindMaximum ( ) ; int arr [ ] = { 9 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 18 , 0 } ; int n = arr . length ; int maxDiff = max . maxIndexDiff ( arr , n ) ; System . out . println ( maxDiff ) ; } }
import java . util . * ; class GFG { public static void main ( String [ ] args ) { int [ ] v = { 34 , 8 , 10 , 3 , 2 , 80 , 30 , 33 , 1 } ; int n = v . length ; int [ ] maxFromEnd = new int [ n + 1 ] ; Arrays . fill ( maxFromEnd , Integer . MIN_VALUE ) ; for ( int i = v . length - 1 ; i >= 0 ; i -- ) { maxFromEnd [ i ] = Math . max ( maxFromEnd [ i + 1 ] , v [ i ] ) ; } int result = 0 ; for ( int i = 0 ; i < v . length ; i ++ ) { int low = i + 1 , high = v . length - 1 , ans = i ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( v [ i ] <= maxFromEnd [ mid ] ) { ans = Math . max ( ans , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } result = Math . max ( result , ans - i ) ; } System . out . print ( result + "NEW_LINE"); } }
class Main { static int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = arr . length ; System . out . println ( " The ▁ maximum ▁ element ▁ is ▁ " + findMaximum ( arr , 0 , n - 1 ) ) ; } }
import java . io . * ; class GFG { static int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; } static int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( ( x %= 2 ) != 0 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } static void allQueries ( int q , int l [ ] , int r [ ] ) { for ( int i = 0 ; i < q ; i ++ ) System . out . println ( ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) ) ; } public static void main ( String [ ] args ) { int q = 3 ; int [ ] l = { 2 , 2 , 5 } ; int [ ] r = { 4 , 8 , 9 } ; allQueries ( q , l , r ) ; } }
import java . io . * ; class GFG { static double probability ( int a [ ] , int b [ ] , int size1 , int size2 ) { int max1 = Integer . MIN_VALUE , count1 = 0 ; for ( int i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max1 ) { max1 = a [ i ] ; count1 = 1 ; } else if ( a [ i ] == max1 ) { count1 ++ ; } } int max2 = Integer . MIN_VALUE , count2 = 0 ; for ( int i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max2 ) { max2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max2 ) { count2 ++ ; } } return ( double ) ( count1 * count2 ) / ( size1 * size2 ) ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 } ; int b [ ] = { 1 , 3 , 3 } ; int size1 = a . length ; int size2 = b . length ; System . out . println ( probability ( a , b , size1 , size2 ) ) ; } }
import java . io . * ; class GFG { public static int minswaps ( int arr [ ] , int n ) { int count = 0 ; int num_unplaced_zeros = 0 ; for ( int index = n - 1 ; index >= 0 ; index -- ) { if ( arr [ index ] == 0 ) num_unplaced_zeros += 1 ; else count += num_unplaced_zeros ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; System . out . println ( minswaps ( arr , 9 ) ) ; } }
import java . util . * ; class GFG { public static void sortedMerge ( int a [ ] , int b [ ] , int res [ ] , int n , int m ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; int i = 0 , j = 0 , k = 0 ; while ( i < n && j < m ) { if ( a [ i ] <= b [ j ] ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } else { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } while ( i < n ) { res [ k ] = a [ i ] ; i += 1 ; k += 1 ; } while ( j < m ) { res [ k ] = b [ j ] ; j += 1 ; k += 1 ; } } public static void main ( String [ ] args ) { int a [ ] = { 10 , 5 , 15 } ; int b [ ] = { 20 , 3 , 2 , 12 } ; int n = a . length ; int m = b . length ; int res [ ] = new int [ n + m ] ; sortedMerge ( a , b , res , n , m ) ; System . out . print ( " Sorted ▁ merged ▁ list ▁ : " ) ; for ( int i = 0 ; i < n + m ; i ++ ) System . out . print ( " ▁ " + res [ i ] ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int singleelement ( int arr [ ] , int n ) { int low = 0 , high = n - 2 ; int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( arr [ mid ] == arr [ mid ^ 1 ] ) { low = mid + 1 ; } else { high = mid - 1 ; } } return arr [ low ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 4 , 5 , 3 , 4 } ; int size = 7 ; Arrays . sort ( arr ) ; System . out . println ( singleelement ( arr , size ) ) ; } }
import java . util . * ; import java . util . Arrays ; class GFG { public static List < Integer > findDisappearedNumbers ( int [ ] nums ) { for ( int i = 0 ; i < nums . length ; i ++ ) { int index = Math . abs ( nums [ i ] ) ; if ( nums [ index - 1 ] > 0 ) { nums [ index - 1 ] *= - 1 ; } } List < Integer > res = new ArrayList < > ( ) ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( nums [ i ] > 0 ) { res . add ( i + 1 ) ; } } return res ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 4 , 5 , 6 } ; System . out . println ( findDisappearedNumbers ( a ) ) ; } }
class GFG { static int getMissingNo ( int a [ ] , int n ) { int total = 1 ; for ( int i = 2 ; i <= ( n + 1 ) ; i ++ ) { total += i ; total -= a [ i - 2 ] ; } return total ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 5 } ; System . out . println ( getMissingNo ( arr , arr . length ) ) ; } }
class GFG { static int getMissingNo ( int a [ ] , int n ) { int n_elements_sum = n * ( n + 1 ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += a [ i ] ; return n_elements_sum - sum ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 4 , 5 , 6 } ; int n = a . length + 1 ; int miss = getMissingNo ( a , n ) ; System . out . print ( miss ) ; } }
class FindFourElements { void findFourElements ( int A [ ] , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) { if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) System . out . print ( A [ i ] + " ▁ " + A [ j ] + " ▁ " + A [ k ] + " ▁ " + A [ l ] ) ; } } } } } public static void main ( String [ ] args ) { FindFourElements findfour = new FindFourElements ( ) ; int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = A . length ; int X = 91 ; findfour . findFourElements ( A , n , X ) ; } }
public class Test { public static int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; System . out . println ( findMajority ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int leastFrequent ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int min_count = n + 1 , res = - 1 ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 } ; int n = arr . length ; System . out . print ( leastFrequent ( arr , n ) ) ; } }
import java . io . * ; import java . util . HashMap ; class GFG { static void printmissingk ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > d = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) d . put ( arr [ i ] , arr [ i ] ) ; int cnt = 1 ; int fl = 0 ; for ( int i = 0 ; i < ( n + k ) ; i ++ ) { if ( ! d . containsKey ( cnt ) ) { fl += 1 ; System . out . print ( cnt + " ▁ " ) ; if ( fl == k ) break ; } cnt += 1 ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 3 } ; int n = arr . length ; int k = 3 ; printmissingk ( arr , n , k ) ; } }
class GFG { static int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int negmax = Integer . MIN_VALUE ; int posmin = Integer . MAX_VALUE ; int count_neg = 0 , count_zero = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; negmax = Math . max ( negmax , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < posmin ) posmin = a [ i ] ; product *= a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return posmin ; if ( count_neg % 2 == 0 && count_neg != 0 ) { product = product / negmax ; } return product ; } public static void main ( String [ ] args ) { int a [ ] = { - 1 , - 1 , - 2 , 4 , 3 } ; int n = 5 ; System . out . println ( minProductSubset ( a , n ) ) ; } }
class GfG { static class Node { int data ; Node next ; } static int countCommon ( Node a , Node b ) { int count = 0 ; for ( ; a != null && b != null ; a = a . next , b = b . next ) if ( a . data == b . data ) ++ count ; else break ; return count ; } static int maxPalindrome ( Node head ) { int result = 0 ; Node prev = null , curr = head ; while ( curr != null ) { Node next = curr . next ; curr . next = prev ; result = Math . max ( result , 2 * countCommon ( prev , next ) + 1 ) ; result = Math . max ( result , 2 * countCommon ( curr , next ) ) ; prev = curr ; curr = next ; } return result ; } static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } public static void main ( String [ ] args ) { Node head = newNode ( 2 ) ; head . next = newNode ( 4 ) ; head . next . next = newNode ( 3 ) ; head . next . next . next = newNode ( 4 ) ; head . next . next . next . next = newNode ( 2 ) ; head . next . next . next . next . next = newNode ( 15 ) ; System . out . println ( maxPalindrome ( head ) ) ; } }
class GFG { static class Node { int data ; Node next ; } static Node freeList ( Node node ) { while ( node != null ) { Node next = node . next ; node = next ; } return node ; } static Node deleteKthNode ( Node head , int k ) { if ( head == null ) return null ; if ( k == 1 ) { head = freeList ( head ) ; return null ; } Node ptr = head , prev = null ; int count = 0 ; while ( ptr != null ) { count ++ ; if ( k == count ) { prev . next = ptr . next ; count = 0 ; } if ( count != 0 ) prev = ptr ; ptr = prev . next ; } return head ; } static void displayList ( Node head ) { Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . next ; } } static Node newNode ( int x ) { Node temp = new Node ( ) ; temp . data = x ; temp . next = null ; return temp ; } public static void main ( String args [ ] ) { Node head = newNode ( 1 ) ; head . next = newNode ( 2 ) ; head . next . next = newNode ( 3 ) ; head . next . next . next = newNode ( 4 ) ; head . next . next . next . next = newNode ( 5 ) ; head . next . next . next . next . next = newNode ( 6 ) ; head . next . next . next . next . next . next = newNode ( 7 ) ; head . next . next . next . next . next . next . next = newNode ( 8 ) ; int k = 3 ; head = deleteKthNode ( head , k ) ; displayList ( head ) ; } }
import java . util . * ; class GFG { static class Node { int data ; Node next ; } ; static Node head ; static int n , sum ; static void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; head = head_ref ; } static void sumOfLastN_Nodes ( Node head ) { if ( head == null ) return ; sumOfLastN_Nodes ( head . next ) ; if ( n > 0 ) { sum = sum + head . data ; -- n ; } } static int sumOfLastN_NodesUtil ( Node head , int n ) { if ( n <= 0 ) return 0 ; sum = 0 ; sumOfLastN_Nodes ( head ) ; return sum ; } public static void main ( String [ ] args ) { head = null ; push ( head , 12 ) ; push ( head , 4 ) ; push ( head , 8 ) ; push ( head , 6 ) ; push ( head , 10 ) ; n = 2 ; System . out . print ( " Sum ▁ of ▁ last ▁ " + n + " ▁ nodes ▁ = ▁ " + sumOfLastN_NodesUtil ( head , n ) ) ; } }
class GFG { static class Node { char data ; Node next ; Node prev ; } ; static Node push ( Node head_ref , char new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; new_node . prev = null ; if ( head_ref != null ) head_ref . prev = new_node ; head_ref = new_node ; return head_ref ; } static boolean isPalindrome ( Node left ) { if ( left == null ) return true ; Node right = left ; while ( right . next != null ) right = right . next ; while ( left != right ) { if ( left . data != right . data ) return false ; left = left . next ; right = right . prev ; } return true ; } public static void main ( String [ ] args ) { Node head = null ; head = push ( head , ' l ' ) ; head = push ( head , ' e ' ) ; head = push ( head , ' v ' ) ; head = push ( head , ' e ' ) ; head = push ( head , ' l ' ) ; if ( isPalindrome ( head ) ) System . out . printf ( " It ▁ is ▁ Palindrome " ) ; else System . out . printf ( " Not ▁ Palindrome " ) ; } }
import java . util . * ; class GFG { static class Node { public int data ; public Node left , right ; } ; static void printLeafNodes ( Node root ) { if ( root == null ) return ; if ( root . left == null && root . right == null ) { System . out . print ( root . data + " ▁ " ) ; return ; } if ( root . left != null ) printLeafNodes ( root . left ) ; if ( root . right != null ) printLeafNodes ( root . right ) ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = null ; temp . right = null ; return temp ; } public static void main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . right . left = newNode ( 5 ) ; root . right . right = newNode ( 8 ) ; root . right . left . left = newNode ( 6 ) ; root . right . left . right = newNode ( 7 ) ; root . right . right . left = newNode ( 9 ) ; root . right . right . right = newNode ( 10 ) ; printLeafNodes ( root ) ; } }
class Node { int data ; Node left , right ; Node ( int item ) { data = item ; left = right = null ; } } class BinaryTree { Node root ; void printkdistanceNodeDown ( Node node , int k ) { if ( node == null k < 0 ) return ; if ( k == 0 ) { System . out . print ( node . data ) ; System . out . println ( " " ) ; return ; } printkdistanceNodeDown ( node . left , k - 1 ) ; printkdistanceNodeDown ( node . right , k - 1 ) ; } int printkdistanceNode ( Node node , Node target , int k ) { if ( node == null ) return - 1 ; if ( node == target ) { printkdistanceNodeDown ( node , k ) ; return 0 ; } int dl = printkdistanceNode ( node . left , target , k ) ; if ( dl != - 1 ) { if ( dl + 1 == k ) { System . out . print ( node . data ) ; System . out . println ( " " ) ; } else printkdistanceNodeDown ( node . right , k - dl - 2 ) ; return 1 + dl ; } int dr = printkdistanceNode ( node . right , target , k ) ; if ( dr != - 1 ) { if ( dr + 1 == k ) { System . out . print ( node . data ) ; System . out . println ( " " ) ; } else printkdistanceNodeDown ( node . left , k - dr - 2 ) ; return 1 + dr ; } return - 1 ; } public static void main ( String args [ ] ) { BinaryTree tree = new BinaryTree ( ) ; tree . root = new Node ( 20 ) ; tree . root . left = new Node ( 8 ) ; tree . root . right = new Node ( 22 ) ; tree . root . left . left = new Node ( 4 ) ; tree . root . left . right = new Node ( 12 ) ; tree . root . left . right . left = new Node ( 10 ) ; tree . root . left . right . right = new Node ( 14 ) ; Node target = tree . root . left . right ; tree . printkdistanceNode ( tree . root , target , 2 ) ; } }
import java . util . * ; class GFG { static int N = 3 ; static int findMaximumDiagonalSumOMatrixf ( int A [ ] [ ] ) { int maxDiagonalSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ j ] [ ( i + j ) % N ] ; } maxDiagonalSum = Math . max ( maxDiagonalSum , curr ) ; } for ( int i = 0 ; i < N ; i ++ ) { int curr = 0 ; for ( int j = 0 ; j < N ; j ++ ) { curr += A [ ( i + j ) % N ] [ j ] ; } maxDiagonalSum = Math . max ( maxDiagonalSum , curr ) ; } return maxDiagonalSum ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 1 , 2 } , { 2 , 1 , 2 } , { 1 , 2 , 2 } } ; System . out . println ( findMaximumDiagonalSumOMatrixf ( mat ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static void left_rotate ( int [ ] arr ) { int last = arr [ 1 ] ; for ( int i = 3 ; i < arr . length ; i = i + 2 ) { arr [ i - 2 ] = arr [ i ] ; } arr [ arr . length - 1 ] = last ; } static void right_rotate ( int [ ] arr ) { int start = arr [ arr . length - 2 ] ; for ( int i = arr . length - 4 ; i >= 0 ; i = i - 2 ) { arr [ i + 2 ] = arr [ i ] ; } arr [ 0 ] = start ; } public static void rotate ( int arr [ ] ) { left_rotate ( arr ) ; right_rotate ( arr ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; rotate ( arr ) ; } }
public class GFG { public static int countRotation ( int [ ] arr , int low , int high ) { if ( low > high ) { return 0 ; } int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) { return mid ; } if ( arr [ mid ] > arr [ low ] ) { return countRotation ( arr , mid + 1 , high ) ; } if ( arr [ mid ] < arr [ high ] ) { return countRotation ( arr , low , mid - 1 ) ; } else { int rightIndex = countRotation ( arr , mid + 1 , high ) ; int leftIndex = countRotation ( arr , low , mid - 1 ) ; if ( rightIndex == 0 ) { return leftIndex ; } return rightIndex ; } } public static void main ( String [ ] args ) { int [ ] arr1 = { 4 , 5 , 1 , 2 , 3 } ; System . out . println ( countRotation ( arr1 , 0 , arr1 . length - 1 ) ) ; } }
import java . util . * ; class GFG { static int MAX = 100005 ; static int [ ] seg = new int [ 4 * MAX ] ; static void build ( int node , int l , int r , int a [ ] ) { if ( l == r ) seg [ node ] = a [ l ] ; else { int mid = ( l + r ) / 2 ; build ( 2 * node , l , mid , a ) ; build ( 2 * node + 1 , mid + 1 , r , a ) ; seg [ node ] = ( seg [ 2 * node ] seg [ 2 * node + 1 ] ) ; } } static int query ( int node , int l , int r , int start , int end , int a [ ] ) { if ( l > end r < start ) return 0 ; if ( start <= l && r <= end ) return seg [ node ] ; int mid = ( l + r ) / 2 ; return ( ( query ( 2 * node , l , mid , start , end , a ) ) | ( query ( 2 * node + 1 , mid + 1 , r , start , end , a ) ) ) ; } static void orsum ( int a [ ] , int n , int q , int k [ ] ) { build ( 1 , 0 , n - 1 , a ) ; for ( int j = 0 ; j < q ; j ++ ) { int i = k [ j ] % ( n / 2 ) ; int sec = query ( 1 , 0 , n - 1 , n / 2 - i , n - i - 1 , a ) ; int first = ( query ( 1 , 0 , n - 1 , 0 , n / 2 - 1 - i , a ) | query ( 1 , 0 , n - 1 , n - i , n - 1 , a ) ) ; int temp = sec + first ; System . out . print ( temp + "NEW_LINE"); } } public static void main ( String [ ] args ) { int a [ ] = { 7 , 44 , 19 , 86 , 65 , 39 , 75 , 101 } ; int n = a . length ; int q = 2 ; int k [ ] = { 4 , 2 } ; orsum ( a , n , q , k ) ; } }
import java . util . * ; class GFG { static void maximumEqual ( int a [ ] , int b [ ] , int n ) { int store [ ] = new int [ ( int ) 1e5 ] ; for ( int i = 0 ; i < n ; i ++ ) { store [ b [ i ] ] = i + 1 ; } int ans [ ] = new int [ ( int ) 1e5 ] ; for ( int i = 0 ; i < n ; i ++ ) { int d = Math . abs ( store [ a [ i ] ] - ( i + 1 ) ) ; if ( store [ a [ i ] ] < i + 1 ) { d = n - d ; } ans [ d ] ++ ; } int finalans = 0 ; for ( int i = 0 ; i < 1e5 ; i ++ ) finalans = Math . max ( finalans , ans [ i ] ) ; System . out . print ( finalans + "NEW_LINE"); } public static void main ( String [ ] args ) { int A [ ] = { 6 , 7 , 3 , 9 , 5 } ; int B [ ] = { 7 , 3 , 9 , 5 , 6 } ; int size = A . length ; maximumEqual ( A , B , size ) ; } }
class GFG { static int countRotation ( int n ) { int count = 0 ; do { int digit = n % 10 ; if ( digit == 0 ) count ++ ; n = n / 10 ; } while ( n != 0 ) ; return count ; } public static void main ( String [ ] args ) { int n = 10203 ; System . out . println ( countRotation ( n ) ) ; } }
class GFG { static boolean isPossible ( int a [ ] , int n ) { if ( n <= 2 ) return true ; int flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] > a [ i + 1 ] && a [ i + 1 ] > a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; flag = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ! ( a [ i ] < a [ i + 1 ] && a [ i + 1 ] < a [ i + 2 ] ) ) { flag = 1 ; break ; } } if ( flag == 0 ) return true ; int val1 = Integer . MAX_VALUE , mini = - 1 , val2 = Integer . MIN_VALUE , maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < val1 ) { mini = i ; val1 = a [ i ] ; } if ( a [ i ] > val2 ) { maxi = i ; val2 = a [ i ] ; } } flag = 1 ; for ( int i = 0 ; i < maxi ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 && maxi + 1 == mini ) { flag = 1 ; for ( int i = mini ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } flag = 1 ; for ( int i = 0 ; i < mini ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 && maxi - 1 == mini ) { flag = 1 ; for ( int i = maxi ; i < n - 1 ; i ++ ) { if ( a [ i ] < a [ i + 1 ] ) { flag = 0 ; break ; } } if ( flag == 1 ) return true ; } return false ; } public static void main ( String args [ ] ) { int a [ ] = { 4 , 5 , 6 , 2 , 3 } ; int n = a . length ; if ( isPossible ( a , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int numberOfDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } static void cal ( int num ) { int digits = numberOfDigits ( num ) ; int powTen = ( int ) Math . pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int firstDigit = num / powTen ; int left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; System . out . print ( left + " ▁ " ) ; num = left ; } } public static void main ( String [ ] args ) { int num = 1445 ; cal ( num ) ; } }
class GFG { static void CheckKCycles ( int n , String s ) { boolean ff = true ; int x = 0 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( s . substring ( i ) + s . substring ( 0 , i ) ) . length ( ) ; if ( x >= s . length ( ) ) { continue ; } ff = false ; break ; } if ( ff ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int n = 3 ; String s = "123" ; CheckKCycles ( n , s ) ; } }
import java . util . * ; import java . io . * ; class GFG { static void generateNumbers ( int m ) { ArrayList < Integer > numbers = new ArrayList < > ( ) ; int k_max , x ; for ( int y = 0 ; y < 10 ; y ++ ) { k_max = ( int ) ( Math . pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / ( int ) ( Math . pow ( 10 , m - 1 ) + y ) ; for ( int k = 1 ; k <= k_max ; k ++ ) { x = ( int ) ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ; if ( ( int ) ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) numbers . add ( 10 * x + y ) ; } } Collections . sort ( numbers ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) System . out . println ( numbers . get ( i ) ) ; } public static void main ( String args [ ] ) { int m = 3 ; generateNumbers ( m ) ; } }
import java . io . * ; class GFG { static int N = 4 ; static void rotate90Clockwise ( int arr [ ] [ ] ) { for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; rotate90Clockwise ( arr ) ; } }
import java . util . * ; class GFG { static int findStartIndexOfArray ( int arr [ ] , int low , int high ) { if ( low > high ) { return - 1 ; } if ( low == high ) { return low ; } int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] ) { return mid + 1 ; } if ( arr [ mid - 1 ] > arr [ mid ] ) { return mid ; } if ( arr [ low ] > arr [ mid ] ) { return findStartIndexOfArray ( arr , low , mid - 1 ) ; } else { return findStartIndexOfArray ( arr , mid + 1 , high ) ; } } static void restoreSortedArray ( int arr [ ] , int n ) { if ( arr [ 0 ] < arr [ n - 1 ] ) { return ; } int start = findStartIndexOfArray ( arr , 0 , n - 1 ) ; Arrays . sort ( arr , 0 , start ) ; Arrays . sort ( arr , start , n ) ; Arrays . sort ( arr ) ; } static void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; restoreSortedArray ( arr , n ) ; printArray ( arr , n ) ; } }
static class Node { int data ; Node next ; } ;
class GFG { static class Node { int data ; Node next ; } ; static Node push ( Node head_ref , int data ) { Node ptr1 = new Node ( ) ; Node temp = head_ref ; ptr1 . data = data ; ptr1 . next = head_ref ; if ( head_ref != null ) { while ( temp . next != head_ref ) temp = temp . next ; temp . next = ptr1 ; } else ptr1 . next = ptr1 ; head_ref = ptr1 ; return head_ref ; } static void deleteNode ( Node head_ref , Node del ) { if ( head_ref == del ) head_ref = del . next ; Node temp = head_ref ; while ( temp . next != del ) { temp = temp . next ; } temp . next = del . next ; System . gc ( ) ; return ; } static boolean isEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( ( x & 1 ) != 0 ) parity ++ ; x = x >> 1 ; } if ( parity % 2 == 0 ) return true ; else return false ; } static void deleteEvenParityNodes ( Node head ) { if ( head == null ) return ; if ( head == head . next ) { if ( isEvenParity ( head . data ) ) head = null ; return ; } Node ptr = head ; Node next ; do { next = ptr . next ; if ( isEvenParity ( ptr . data ) ) deleteNode ( head , ptr ) ; ptr = next ; } while ( ptr != head ) ; if ( head == head . next ) { if ( isEvenParity ( head . data ) ) head = null ; return ; } } static void printList ( Node head ) { if ( head == null ) { System . out . print ( "Empty ListNEW_LINE"); return ; } Node temp = head ; if ( head != null ) { do { System . out . printf ( " % d ▁ " , temp . data ) ; temp = temp . next ; } while ( temp != head ) ; } } public static void main ( String [ ] args ) { Node head = null ; head = push ( head , 21 ) ; head = push ( head , 13 ) ; head = push ( head , 6 ) ; head = push ( head , 34 ) ; head = push ( head , 9 ) ; head = push ( head , 11 ) ; deleteEvenParityNodes ( head ) ; printList ( head ) ; } }
import java . util . * ; class GFG { static class Node { int data ; Node next ; } ; static Node push ( Node head_ref , int data ) { Node ptr1 = new Node ( ) ; Node temp = head_ref ; ptr1 . data = data ; ptr1 . next = head_ref ; if ( head_ref != null ) { while ( temp . next != head_ref ) temp = temp . next ; temp . next = ptr1 ; } else ptr1 . next = ptr1 ; head_ref = ptr1 ; return head_ref ; } static void deleteNode ( Node head_ref , Node del ) { Node temp = head_ref ; if ( head_ref == del ) head_ref = del . next ; while ( temp . next != del ) { temp = temp . next ; } temp . next = del . next ; del = null ; return ; } static int digitSum ( int num ) { int sum = 0 ; while ( num > 0 ) { sum += ( num % 10 ) ; num /= 10 ; } return sum ; } static void deleteEvenDigitSumNodes ( Node head ) { Node ptr = head ; Node next ; do { if ( ! ( digitSum ( ptr . data ) % 2 == 1 ) ) deleteNode ( head , ptr ) ; next = ptr . next ; ptr = next ; } while ( ptr != head ) ; } static void printList ( Node head ) { Node temp = head ; if ( head != null ) { do { System . out . printf ( " % d ▁ " , temp . data ) ; temp = temp . next ; } while ( temp != head ) ; } } public static void main ( String [ ] args ) { Node head = null ; head = push ( head , 21 ) ; head = push ( head , 13 ) ; head = push ( head , 6 ) ; head = push ( head , 34 ) ; head = push ( head , 11 ) ; head = push ( head , 9 ) ; deleteEvenDigitSumNodes ( head ) ; printList ( head ) ; } }
class GFG { static class Node { int data ; Node next ; Node prev ; } ; static Node insertNode ( Node start , int value ) { if ( start == null ) { Node new_node = new Node ( ) ; new_node . data = value ; new_node . next = new_node . prev = new_node ; start = new_node ; return new_node ; } Node last = ( start ) . prev ; Node new_node = new Node ( ) ; new_node . data = value ; new_node . next = start ; ( start ) . prev = new_node ; new_node . prev = last ; last . next = new_node ; return start ; } static void displayList ( Node start ) { Node temp = start ; while ( temp . next != start ) { System . out . printf ( " % d ▁ " , temp . data ) ; temp = temp . next ; } System . out . printf ( " % d ▁ " , temp . data ) ; } static int searchList ( Node start , int search ) { Node temp = start ; int count = 0 , flag = 0 , value ; if ( temp == null ) return - 1 ; else { while ( temp . next != start ) { count ++ ; if ( temp . data == search ) { flag = 1 ; count -- ; break ; } temp = temp . next ; } if ( temp . data == search ) { count ++ ; flag = 1 ; } if ( flag == 1 ) System . out . println ( " " + search ▁ + " found at location "+ count); else System . out . println ( " " + search ▁ + " not found "); } return - 1 ; } public static void main ( String args [ ] ) { Node start = null ; start = insertNode ( start , 4 ) ; start = insertNode ( start , 5 ) ; start = insertNode ( start , 7 ) ; start = insertNode ( start , 8 ) ; start = insertNode ( start , 6 ) ; System . out . printf ( " Created ▁ circular ▁ doubly ▁ linked ▁ list ▁ is : ▁ " ) ; displayList ( start ) ; searchList ( start , 5 ) ; } }
import java . util . * ; class GFG { static final int MAX = 1000 ; static int [ ] weight = new int [ MAX ] ; static int [ ] level = new int [ MAX ] ; static int [ ] par = new int [ MAX ] ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static Vector < Integer > [ ] graph = new Vector [ MAX ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static void dfs ( int node , int parent , int h ) { par [ node ] = parent ; level [ node ] = h ; for ( int child : graph [ node ] ) { if ( child == parent ) continue ; dfs ( child , node , h + 1 ) ; } } static int findPrimeOnPath ( int u , int v ) { int count = 0 ; if ( level [ u ] > level [ v ] ) { int temp = v ; v = u ; u = temp ; } int d = level [ v ] - level [ u ] ; while ( d -- > 0 ) { if ( prime [ weight [ v ] ] ) count ++ ; v = par [ v ] ; } if ( v == u ) { if ( prime [ weight [ v ] ] ) count ++ ; return count ; } while ( v != u ) { if ( prime [ weight [ v ] ] ) count ++ ; if ( prime [ weight [ u ] ] ) count ++ ; u = par [ u ] ; v = par [ v ] ; } if ( prime [ weight [ v ] ] ) count ++ ; return count ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < graph . length ; i ++ ) graph [ i ] = new Vector < Integer > ( ) ; SieveOfEratosthenes ( ) ; weight [ 1 ] = 5 ; weight [ 2 ] = 10 ; weight [ 3 ] = 11 ; weight [ 4 ] = 8 ; weight [ 5 ] = 6 ; graph [ 1 ] . add ( 2 ) ; graph [ 2 ] . add ( 3 ) ; graph [ 2 ] . add ( 4 ) ; graph [ 1 ] . add ( 5 ) ; dfs ( 1 , - 1 , 0 ) ; int u = 3 , v = 5 ; System . out . print ( findPrimeOnPath ( u , v ) ) ; } }
import java . util . * ; class GFG { static class Node { Node left ; Node right ; int data ; } ; static Node newNode ( int key ) { Node node = new Node ( ) ; node . left = node . right = null ; node . data = key ; return node ; } static Vector < Integer > path ; static boolean FindPath ( Node root , int key ) { if ( root == null ) return false ; path . add ( root . data ) ; if ( root . data == key ) return true ; if ( FindPath ( root . left , key ) || FindPath ( root . right , key ) ) return true ; path . remove ( path . size ( ) - 1 ) ; return false ; } static int minMaxNodeInPath ( Node root , int a , int b ) { path = new Vector < Integer > ( ) ; boolean flag = true ; Vector < Integer > Path2 = new Vector < Integer > ( ) , Path1 = new Vector < Integer > ( ) ; int min1 = Integer . MAX_VALUE ; int max1 = Integer . MIN_VALUE ; int min2 = Integer . MAX_VALUE ; int max2 = Integer . MIN_VALUE ; int i = 0 ; int j = 0 ; flag = FindPath ( root , a ) ; Path1 = path ; path = new Vector < Integer > ( ) ; flag &= FindPath ( root , b ) ; Path2 = path ; if ( flag ) { for ( i = 0 ; i < Path1 . size ( ) && i < Path2 . size ( ) ; i ++ ) if ( Path1 . get ( i ) != Path2 . get ( i ) ) break ; i -- ; j = i ; for ( ; i < Path1 . size ( ) ; i ++ ) { if ( min1 > Path1 . get ( i ) ) min1 = Path1 . get ( i ) ; if ( max1 < Path1 . get ( i ) ) max1 = Path1 . get ( i ) ; } for ( ; j < Path2 . size ( ) ; j ++ ) { if ( min2 > Path2 . get ( j ) ) min2 = Path2 . get ( j ) ; if ( max2 < Path2 . get ( j ) ) max2 = Path2 . get ( j ) ; } System . out . println ( " Min ▁ = ▁ " + Math . min ( min1 , min2 ) ) ; System . out . println ( " Max ▁ = ▁ " + Math . max ( max1 , max2 ) ) ; } else System . out . println ( "Min = -1 Max = - 1 "); return 0 ; } public static void main ( String args [ ] ) { Node root = newNode ( 20 ) ; root . left = newNode ( 8 ) ; root . right = newNode ( 22 ) ; root . left . left = newNode ( 5 ) ; root . left . right = newNode ( 3 ) ; root . right . left = newNode ( 4 ) ; root . right . right = newNode ( 25 ) ; root . left . right . left = newNode ( 10 ) ; root . left . right . right = newNode ( 14 ) ; int a = 5 ; int b = 14 ; minMaxNodeInPath ( root , a , b ) ; } }
import java . util . * ; class GFG { static final int MAXN = 100001 ; static Vector < Integer > [ ] tree = new Vector [ MAXN ] ; static int [ ] [ ] path = new int [ 3 ] [ MAXN ] ; static boolean flag ; static void dfs ( int cur , int prev , int pathNumber , int ptr , int node ) { for ( int i = 0 ; i < tree [ cur ] . size ( ) ; i ++ ) { if ( tree [ cur ] . get ( i ) != prev && ! flag ) { path [ pathNumber ] [ ptr ] = tree [ cur ] . get ( i ) ; if ( tree [ cur ] . get ( i ) == node ) { flag = true ; path [ pathNumber ] [ ptr + 1 ] = - 1 ; return ; } dfs ( tree [ cur ] . get ( i ) , cur , pathNumber , ptr + 1 , node ) ; } } } static int LCA ( int a , int b ) { if ( a == b ) return a ; path [ 1 ] [ 0 ] = path [ 2 ] [ 0 ] = 1 ; flag = false ; dfs ( 1 , 0 , 1 , 1 , a ) ; flag = false ; dfs ( 1 , 0 , 2 , 1 , b ) ; int i = 0 ; while ( i < MAXN && path [ 1 ] [ i ] == path [ 2 ] [ i ] ) i ++ ; return path [ 1 ] [ i - 1 ] ; } static void addEdge ( int a , int b ) { tree [ a ] . add ( b ) ; tree [ b ] . add ( a ) ; } public static void main ( String [ ] args ) { for ( int i = 0 ; i < MAXN ; i ++ ) tree [ i ] = new Vector < Integer > ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 3 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 5 ) ; addEdge ( 2 , 6 ) ; addEdge ( 3 , 7 ) ; addEdge ( 3 , 8 ) ; System . out . print ( " LCA ( 4 , ▁ 7 ) ▁ = ▁ " + LCA ( 4 , 7 ) + "NEW_LINE"); System . out . print ( " LCA ( 4 , ▁ 6 ) ▁ = ▁ " + LCA ( 4 , 6 ) + "NEW_LINE"); } }
class GFG { static boolean checkIfDivisible ( String str , long num ) { long powerOf2 = ( int ) ( Math . log ( num ) / Math . log ( 2 ) ) ; if ( str . length ( ) < powerOf2 ) return false ; if ( powerOf2 == 0 ) return true ; long i , number = 0 ; int len = str . length ( ) ; for ( i = len - powerOf2 ; i < len ; i ++ ) { number += ( str . charAt ( ( int ) i ) - '0' ) * Math . pow ( 10 , powerOf2 - 1 ) ; powerOf2 -- ; } if ( number % num != 0 ) return false ; else return true ; } public static void main ( String [ ] args ) { String str = "213467756564" ; long num = 4 ; if ( checkIfDivisible ( str , num ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class GFG { static int longest_subarray ( int arr [ ] , int d ) { int i = 0 , j = 1 , e = 0 ; for ( i = 0 ; i < d - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { j = j + 1 ; } else { j = 1 ; } if ( e < j ) { e = j ; } } return e ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = arr . length ; System . out . print ( longest_subarray ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int n = 10005 ; static boolean [ ] Prime = new boolean [ n + 1 ] ; static void SieveOfEratosthenes ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= 10005 ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < 10005 ; j += i ) { Prime [ j ] = false ; } } } } static void primeDegreeNodes ( int N , int M , int edges [ ] [ ] ) { Vector < Integer > [ ] Adj = new Vector [ N + 1 ] ; for ( int i = 0 ; i < Adj . length ; i ++ ) Adj [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { int x = edges [ i ] [ 0 ] ; int y = edges [ i ] [ 1 ] ; Adj [ x ] . add ( y ) ; Adj [ y ] . add ( x ) ; } SieveOfEratosthenes ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { int x = Adj [ i ] . size ( ) ; if ( Prime [ x ] ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 4 , M = 6 ; int edges [ ] [ ] = { { 1 , 2 } , { 1 , 3 } , { 1 , 4 } , { 2 , 3 } , { 2 , 4 } , { 3 , 4 } } ; Arrays . fill ( Prime , true ) ; primeDegreeNodes ( N , M , edges ) ; } }
import java . util . * ; class GFG { static int mod = 1000000007 ; static int countWays ( int colored [ ] , int count , int n ) { if ( count == n ) { return 1 ; } int answer = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { if ( colored [ i ] == 0 ) { if ( colored [ i - 1 ] == 1 colored [ i + 1 ] == 1 ) { colored [ i ] = 1 ; answer = ( answer + countWays ( colored , count + 1 , n ) ) % mod ; colored [ i ] = 0 ; } } } return answer ; } static int waysToColor ( int arr [ ] , int n , int k ) { int colored [ ] = new int [ n + 2 ] ; for ( int i = 0 ; i < k ; i ++ ) { colored [ arr [ i ] ] = 1 ; } return countWays ( colored , k , n ) ; } public static void main ( String [ ] args ) { int N = 6 ; int K = 3 ; int arr [ ] = { 1 , 2 , 6 } ; System . out . print ( waysToColor ( arr , N , K ) ) ; } }
import java . util . * ; class GFG { static boolean checkPermutation ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int [ ] prefix = new int [ n + 1 ] ; Arrays . fill ( prefix , 0 ) ; prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int lsum = prefix [ i ] ; int rsum = sum - prefix [ i ] ; int l_len = i + 1 , r_len = n - i - 1 ; if ( ( ( 2 * lsum ) == ( l_len * ( l_len + 1 ) ) ) && ( ( 2 * rsum ) == ( r_len * ( r_len + 1 ) ) ) ) return true ; } return false ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 2 , 5 , 3 , 4 , 1 , 2 } ; int n = arr . length ; if ( checkPermutation ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static void findNextNumber ( int n ) { int h [ ] = new int [ 10 ] ; int i = 0 , msb = n , rem = 0 ; int next_num = - 1 , count = 0 ; while ( msb > 9 ) { rem = msb % 10 ; h [ rem ] = 1 ; msb /= 10 ; count ++ ; } h [ msb ] = 1 ; count ++ ; for ( i = msb + 1 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; break ; } } if ( next_num == - 1 ) { for ( i = 1 ; i < msb ; i ++ ) { if ( h [ i ] == 0 ) { next_num = i ; count ++ ; break ; } } } if ( next_num > 0 ) { for ( i = 0 ; i < 10 ; i ++ ) { if ( h [ i ] == 0 ) { msb = i ; break ; } } for ( i = 1 ; i < count ; i ++ ) { next_num = ( ( next_num * 10 ) + msb ) ; } if ( next_num > n ) System . out . print ( next_num + "NEW_LINE"); else System . out . print ( "Not Possible NEW_LINE"); } else { System . out . print ( "Not Possible NEW_LINE"); } } public static void main ( String [ ] args ) { int n = 2019 ; findNextNumber ( n ) ; } }
class GFG { static void findTheNumber ( int n ) { if ( n == 1 ) { System . out . print ( " Impossible " + "NEW_LINE"); return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { System . out . print ( "5" ) ; } System . out . print ( "4" ) ; } public static void main ( String [ ] args ) { int n = 12 ; findTheNumber ( n ) ; } }
class GFG { static final int MAXN = 1000005 ; static int even [ ] = new int [ MAXN ] ; static int odd [ ] = new int [ MAXN ] ; static void precompute ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd [ i ] = 1 ; if ( arr [ i ] % 2 == 0 ) even [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { even [ i ] = even [ i ] + even [ i - 1 ] ; odd [ i ] = odd [ i ] + odd [ i - 1 ] ; } } static boolean isOdd ( int L , int R ) { int cnt = odd [ R ] ; if ( L > 0 ) cnt -= odd [ L - 1 ] ; if ( cnt == R - L + 1 ) return true ; return false ; } static void performQueries ( int a [ ] , int n , int q [ ] [ ] , int m ) { precompute ( a , n ) ; for ( int i = 0 ; i < m ; i ++ ) { int L = q [ i ] [ 0 ] , R = q [ i ] [ 1 ] ; if ( isOdd ( L , R ) ) System . out . println ( " Odd " ) ; else System . out . println ( " Even " ) ; } } public static void main ( String args [ ] ) { int [ ] a = { 2 , 1 , 5 , 7 , 6 , 8 , 9 } ; int n = a . length ; int q [ ] [ ] = { { 0 , 2 } , { 1 , 2 } , { 2 , 3 } , { 3 , 6 } } ; int m = q . length ; performQueries ( a , n , q , m ) ; } }
import java . util . * ; class GFG { static String getWinner ( String str , int len ) { int total = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' S ' ) { total ++ ; } } if ( ( total % 2 ) == 1 ) return " First " ; return " Second " ; } public static void main ( String [ ] args ) { String str = " GSSS " ; int len = str . length ( ) ; System . out . println ( getWinner ( str , len ) ) ; } }
import java . util . * ; class GFG { static void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void findArrangement ( int arr [ ] , int n ) { if ( n < 2 ) { System . out . print ( " - 1" ) ; return ; } int minVal = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == minVal ) { swap ( arr , i , n - 1 ) ; break ; } } int andVal = arr [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { andVal &= arr [ i ] ; } if ( andVal == arr [ n - 1 ] ) printArr ( arr , n ) ; else System . out . print ( " - 1" ) ; } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 3 , 3 } ; int n = arr . length ; findArrangement ( arr , n ) ; } }
class GFG { static int maxOperations ( int X , int Y ) { if ( X > Y ) return - 1 ; int diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; } public static void main ( String [ ] args ) { int X = 5 , Y = 16 ; System . out . println ( maxOperations ( X , Y ) ) ; } }
class GFG { static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void randomList ( int m , int n ) { int arr [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ ( int ) ( Math . random ( ) * m ) ] ++ ; } printArr ( arr , m ) ; } public static void main ( String args [ ] ) { int m = 4 , n = 8 ; randomList ( m , n ) ; } }
import java . io . * ; class GFG { static int find_maximum_value ( int a [ ] , int n ) { int sum = 0 ; int minimum = Integer . MAX_VALUE ; int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { minimum = Math . min ( minimum , Math . abs ( a [ i ] ) ) ; sum += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) pos += 1 ; else neg += 1 ; } if ( pos > 0 && neg > 0 ) return sum ; return ( sum - 2 * minimum ) ; } public static void main ( String [ ] args ) { int [ ] a = { 5 , 4 , 6 , 2 } ; int n = a . length ; System . out . println ( find_maximum_value ( a , n ) ) ; } }
import java . io . * ; class GFG { static int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; } public static void main ( String [ ] args ) { int p = 24 , q = 48 ; System . out . println ( getMinVal ( p , q ) ) ; } }
import java . util . Arrays ; class GFG { static boolean is_prefix ( String temp , String str ) { if ( temp . length ( ) < str . length ( ) ) return false ; else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) != temp . charAt ( i ) ) return false ; } return true ; } } static String lexicographicallyString ( String [ ] input , int n , String str ) { Arrays . sort ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { String temp = input [ i ] ; if ( is_prefix ( temp , str ) ) { return temp ; } } return " - 1" ; } public static void main ( String args [ ] ) { String [ ] arr = { " apple " , " appe " , " apl " , " aapl " , " appax " } ; String S = " app " ; int N = 5 ; System . out . println ( lexicographicallyString ( arr , N , S ) ) ; } }
class GFG { static int minSumPair ( int arr [ ] , int N ) { if ( N < 5 ) { return - 1 ; } int [ ] prefixMin = new int [ N ] ; prefixMin [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N - 1 ; i ++ ) { prefixMin [ i ] = Math . min ( arr [ i ] , prefixMin [ i - 1 ] ) ; } int ans = Integer . MAX_VALUE ; for ( int i = 3 ; i < N - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] + prefixMin [ i - 2 ] ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 4 , 6 , 3 , 7 } ; int N = arr . length ; System . out . print ( minSumPair ( arr , N ) + "NEW_LINE"); } }
import java . io . * ; import java . util . * ; class GFG { public static void findCount ( String number ) { int sum = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { sum += number . charAt ( i ) - 48 ; } int count = 0 ; for ( int i = 0 ; i < number . length ( ) ; ++ i ) { int remaining_sum = sum - ( number . charAt ( i ) - 48 ) ; for ( int j = 0 ; j <= 9 ; ++ j ) { if ( ( remaining_sum + j ) % 3 == 0 && j != number . charAt ( i ) - 48 ) { ++ count ; } } } System . out . println ( count ) ; } public static void main ( String [ ] args ) { String number = "235" ; findCount ( number ) ; } }
class GFG { static long n , m , k , l , r , i ; static boolean check ( long v , long [ ] a ) { long tec = 0 , ans = 0 ; long [ ] b = new long [ ( int ) ( n + k + 1 ) ] ; for ( int i = 0 ; i < n ; i ++ ) { tec -= b [ i ] ; if ( a [ i ] + tec < v ) { long mov = v - a [ i ] - tec ; ans = ans + mov ; tec += mov ; b [ i + ( int ) k ] = mov ; } } return ans <= m ; } static long FindLargest ( long [ ] a ) { l = 1 ; r = ( long ) Math . pow ( 10 , 10 ) ; while ( r - l > 0 ) { long tm = ( l + r + 1 ) / 2 ; if ( check ( tm , a ) ) l = tm ; else r = tm - 1 ; } return l ; } public static void main ( String [ ] args ) { long [ ] a = { 2 , 2 , 2 , 2 , 1 , 1 } ; m = 2 ; k = 3 ; n = a . length ; System . out . println ( FindLargest ( a ) ) ; } }
import java . util . * ; class GFG { static void numberofBoxes ( int W , int B , int O ) { int low = 0 , high = Math . min ( W , B ) ; int ans = 0 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( ( ( W >= mid ) && ( B >= mid ) ) && ( ( W - mid ) + ( B - mid ) + O ) >= mid ) { ans = mid ; low = mid + 1 ; } else high = mid - 1 ; } System . out . println ( ans ) ; } public static void main ( String args [ ] ) { int W = 3 , B = 3 , O = 1 ; numberofBoxes ( W , B , O ) ; } }
import java . util . * ; class GFG { static void findPairs ( int A , int B ) { for ( int i = 1 ; i <= B ; i ++ ) { int y = A ^ i ; if ( y > 0 && ( i y ) == B ) { System . out . println ( i + " ▁ " + y ) ; } } } public static void main ( String [ ] args ) { int A = 8 , B = 10 ; findPairs ( A , B ) ; } }
import java . util . * ; class GFG { static boolean ischar ( char x ) { if ( ( x >= ' A ' && x <= ' Z ' ) || ( x >= ' a ' && x <= ' z ' ) ) { return true ; } return false ; } static boolean isnum ( char x ) { if ( x >= '0' && x <= '9' ) return true ; return false ; } static void findIdandDomain ( String S , int N ) { String ID = " " , Domain = " " ; Vector < String > words = new Vector < String > ( ) ; String curr = " " ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == ' ▁ ' ) { words . add ( curr ) ; curr = " " ; } else { if ( S . charAt ( i ) == ' . ' ) { if ( i + 1 == N || ( i + 1 < N && S . charAt ( i + 1 ) == ' ▁ ' ) ) continue ; } curr += S . charAt ( i ) ; } } if ( curr . length ( ) > 0 ) words . add ( curr ) ; for ( String ss : words ) { if ( ss . length ( ) == 10 ) { boolean flag = false ; for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j >= 5 && j < 9 ) { if ( isnum ( ss . charAt ( j ) ) == false ) flag = true ; } else { if ( ischar ( ss . charAt ( j ) ) == false ) flag = true ; } } if ( ! flag ) { ID = ss ; } } if ( ss . length ( ) > 2 && ss . substring ( 0 , 3 ) . equals ( " www " ) && ss . substring ( ss . length ( ) - 3 ) . equals ( " com " ) ) { Domain = ss . substring ( 4 , ss . length ( ) ) ; } } System . out . print ( " ID ▁ = ▁ " + ID + "NEW_LINE"); System . out . print ( " Domain ▁ = ▁ " + Domain ) ; } public static void main ( String [ ] args ) { String S = " We ▁ thank ▁ ABCDE1234F ▁ for ▁ visiting ▁ " + " us ▁ and ▁ buying ▁ products ▁ item ▁ AMZrr @ ! k . ▁ " + " For ▁ more ▁ offers , ▁ visit ▁ us ▁ at ▁ www . amazon . com " ; int N = S . length ( ) ; findIdandDomain ( S , N ) ; } }
import java . util . * ; class GFG { static int countTriplets ( int D , int [ ] arr ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; int ans = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( freq . containsKey ( arr [ i ] - D ) && freq . containsKey ( arr [ i ] - 2 * D ) ) { ans += freq . get ( arr [ i ] - D ) * freq . get ( arr [ i ] - 2 * D ) ; } if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 5 , 7 , 8 , 10 } ; int D = 1 ; System . out . print ( countTriplets ( D , arr ) ) ; } }
class GFG { static boolean bound ( int w , int h , int N , int x ) { int val = ( x / w ) * ( x / h ) ; if ( val >= N ) return true ; else return false ; } static int FindSquare ( int N , int W , int H ) { int i = 1 ; int j = W * H * N ; while ( i < j ) { int mid = i + ( j - i ) / 2 ; if ( bound ( W , H , N , mid ) ) j = mid ; else i = mid + 1 ; } return j ; } public static void main ( String [ ] args ) { int W = 2 ; int H = 3 ; int N = 10 ; System . out . print ( FindSquare ( N , W , H ) ) ; } }
import java . util . * ; class GFG { static void SieveOfEratosthenes ( boolean prime [ ] , int n ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } } static void sumOfPrimeSquare ( int n ) { boolean flag = false ; boolean [ ] prime = new boolean [ n + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , n ) ; for ( int i = 0 ; i <= n ; i ++ ) { if ( ! prime [ i ] ) continue ; int dif = n - i ; if ( Math . ceil ( ( double ) Math . sqrt ( dif ) ) == Math . floor ( ( double ) Math . sqrt ( dif ) ) ) { flag = true ; break ; } } if ( flag ) { System . out . print ( " Yes " ) ; } else System . out . print ( " No " ) ; } public static void main ( String [ ] args ) { int N = 27 ; sumOfPrimeSquare ( N ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static boolean check ( int arr [ ] , int M , int K , int ind ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 1 ; j < K ; j ++ ) { if ( arr [ ind + i ] != arr [ ind + i + j * M ] ) { return false ; } } } return true ; } static boolean SubarrayRepeatsKorMore ( int arr [ ] , int N , int M , int K ) { for ( int ind = 0 ; ind <= N - M * K ; ind ++ ) { if ( check ( arr , M , K , ind ) ) { return true ; } } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 2 , 1 , 1 , 1 , 3 } ; int M = 2 , K = 2 ; int N = arr . length ; if ( SubarrayRepeatsKorMore ( arr , N , M , K ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static void minimumNumber ( int K , int X ) { if ( K > X ) { System . out . println ( " - 1" ) ; return ; } int ans = 0 ; int sum = 0 ; for ( int i = K ; i <= X ; i ++ ) { sum += i ; if ( sum >= X ) { ans = i ; break ; } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int K = 5 , X = 13 ; minimumNumber ( K , X ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static int peakIndex ( int [ ] arr ) { int N = arr . length ; if ( arr . length < 3 ) return - 1 ; int i = 0 ; while ( i + 1 < N ) { if ( arr [ i + 1 ] < arr [ i ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == 0 i == N - 1 ) return - 1 ; int ans = i ; while ( i < N - 1 ) { if ( arr [ i ] < arr [ i + 1 ] arr [ i ] == arr [ i + 1 ] ) break ; i ++ ; } if ( i == N - 1 ) return ans ; return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 1 , 0 } ; System . out . println ( peakIndex ( arr ) ) ; } }
import java . util . Arrays ; class GFG { static void findPairs ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = Math . abs ( arr [ i ] ) ; Arrays . sort ( arr ) ; int left = 0 ; int ans = 0 ; for ( int right = 0 ; right < N ; right ++ ) { while ( 2 * arr [ left ] < arr [ right ] ) left ++ ; ans += ( right - left ) ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 } ; int N = arr . length ; findPairs ( arr , N ) ; } }
import java . io . * ; class GFG { static void evenproduct ( int arr [ ] , int length ) { int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int product = 1 ; for ( int j = i ; j < arr . length ; j ++ ) { product *= arr [ j ] ; if ( product % 2 == 0 ) ++ count ; } } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 5 , 4 , 9 } ; int length = arr . length - 1 ; evenproduct ( arr , length ) ; } }
import java . util . * ; class GFG { static int totalWays ( int n , String str ) { ArrayList < Integer > IdxOf0s = new ArrayList < Integer > ( ) ; int cntWays = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '0' ) { IdxOf0s . add ( i ) ; } } int M = IdxOf0s . size ( ) ; if ( ( M == 0 ) || ( ( M % 2 ) != 0 ) ) { return 0 ; } for ( int i = 2 ; i < M ; i += 2 ) { cntWays = cntWays * ( IdxOf0s . get ( i ) - IdxOf0s . get ( i - 1 ) ) ; } return cntWays ; } public static void main ( String [ ] args ) { String str = "00100" ; int n = str . length ( ) ; System . out . print ( totalWays ( n , str ) ) ; } }
import java . util . * ; class GFG { static int CountSubarray ( int arr [ ] , int n , int k ) { int temp = k , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == temp ) { if ( temp == 1 ) { count ++ ; temp = k ; } else temp -- ; } else { temp = k ; if ( arr [ i ] == k ) i -- ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 7 , 9 , 3 , 2 , 1 , 8 , 3 , 2 , 1 } ; int N = arr . length ; int K = 3 ; System . out . println ( CountSubarray ( arr , N , K ) ) ; } }
class GFG { static void countDivisors ( int n ) { int count = 0 ; int j = 0 ; int divisor [ ] = new int [ n ] ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisor [ j ] = i ; j += 1 ; } else { divisor [ j ] = i ; divisor [ j + 1 ] = n / i ; j += 2 ; } } } divisor [ j ] = n ; for ( int i = 0 ; i <= j ; i ++ ) { int x = divisor [ i ] ; x -= 1 ; if ( ( n / x ) == ( n % x ) ) count ++ ; } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int N = 10000000 ; countDivisors ( N ) ; } }
import java . util . * ; class GFG { static int findMaxLength ( int N , int [ ] arr ) { int [ ] dp = new int [ N + 1 ] ; Arrays . fill ( dp , 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 2 * i ; j <= N ; j += i ) { if ( arr [ i - 1 ] < arr [ j - 1 ] ) { dp [ j ] = Math . max ( dp [ j ] , dp [ i ] + 1 ) ; } } } return Arrays . stream ( dp ) . max ( ) . getAsInt ( ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int N = arr . length ; System . out . print ( findMaxLength ( N , arr ) ) ; } }
import java . util . * ; class GFG { static int power ( int x , int N ) { int res = 1 ; while ( N > 0 ) { if ( ( N & 1 ) != 0 ) { res = ( res * x ) ; } x = ( x * x ) ; N = N >> 1 ; } return res ; } static void findValX_Y ( int N ) { if ( N <= 1 ) { System . out . println ( - 1 ) ; return ; } int xMax ; xMax = ( int ) Math . log ( N ) ; int yMax ; yMax = ( int ) ( Math . log ( N ) / Math . log ( 5.0 ) ) ; for ( int i = 1 ; i <= xMax ; i ++ ) { for ( int j = 1 ; j <= yMax ; j ++ ) { int a = power ( 2 , i ) ; int b = power ( 5 , j ) ; if ( a + b == N ) { System . out . print ( i + " ▁ " + j ) ; return ; } } } System . out . println ( " - 1" ) ; } public static void main ( String args [ ] ) { int N = 129 ; findValX_Y ( N ) ; } }
import java . util . * ; class GFG { static String toggleQuery ( char [ ] str , int Q [ ] [ ] , int M ) { int N = str . length ; int prefixCnt [ ] = new int [ N + 1 ] ; for ( int i = 0 ; i < M ; i ++ ) { prefixCnt [ Q [ i ] [ 0 ] ] += 1 ; prefixCnt [ Q [ i ] [ 1 ] + 1 ] -= 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { prefixCnt [ i ] += prefixCnt [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( prefixCnt [ i ] % 2 == 1 ) { str [ i ] = ( char ) ( '1' - str [ i ] + '0' ) ; } } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = "101010" ; int Q [ ] [ ] = { { 0 , 1 } , { 2 , 5 } , { 2 , 3 } , { 1 , 4 } , { 0 , 5 } } ; int M = Q . length ; System . out . print ( toggleQuery ( str . toCharArray ( ) , Q , M ) ) ; } }
import java . util . * ; class GFG { public static int maxiConsecutiveSubarray ( int arr [ ] , int N ) { int maxi = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { int cnt = 1 , j ; for ( j = i ; j < N - 1 ; j ++ ) { if ( arr [ j + 1 ] == arr [ j ] + 1 ) { cnt ++ ; } else { break ; } } maxi = Math . max ( maxi , cnt ) ; i = j ; } return maxi ; } public static void main ( String args [ ] ) { int N = 11 ; int arr [ ] = { 1 , 3 , 4 , 2 , 3 , 4 , 2 , 3 , 5 , 6 , 7 } ; System . out . println ( maxiConsecutiveSubarray ( arr , N ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void countRemovableElem ( int [ ] arr , int N ) { int [ ] hash = new int [ N + 1 ] ; Arrays . fill ( hash , 0 ) ; int mex = N + 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= N ) hash [ arr [ i ] ] = 1 ; } for ( int i = 1 ; i <= N ; i ++ ) { if ( hash [ i ] == 0 ) { mex = i ; break ; } } System . out . println ( N - ( mex - 1 ) ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 1 , 6 } ; int N = arr . length ; countRemovableElem ( arr , N ) ; } }
import java . util . * ; class GFG { static void printIndexes ( char [ ] str ) { int N = str . length ; int [ ] cntFreq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ str [ i ] ] ++ ; } int [ ] cntLeftFreq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { int cntLeft = 0 ; int cntRight = 0 ; for ( int j = str [ i ] - 1 ; j >= 0 ; j -- ) { cntLeft += cntLeftFreq [ j ] ; cntRight += cntFreq [ j ] - cntLeftFreq [ j ] ; } cntLeftFreq [ str [ i ] ] ++ ; if ( cntLeft == cntRight && cntLeft != 0 ) { System . out . print ( i + " ▁ " ) ; } } } public static void main ( String [ ] args ) { String str = " aabacdabbb " ; printIndexes ( str . toCharArray ( ) ) ; } }
import java . util . * ; class GFG { static boolean checkConcat ( String str1 , String str2 ) { int N = str1 . length ( ) ; int M = str2 . length ( ) ; if ( N % M != 0 ) { return false ; } for ( int i = 0 ; i < N ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i % M ) ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String str1 = " abcabcabc " ; String str2 = " abc " ; if ( checkConcat ( str1 , str2 ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
import java . util . * ; import java . lang . * ; class GFG { static int countPosition ( int [ ] [ ] mat ) { int n = mat . length ; int m = mat [ 0 ] . length ; int [ ] row = new int [ n ] ; int [ ] col = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { col [ j ] ++ ; row [ i ] ++ ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( row [ i ] == col [ j ] ) { count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 1 } , { 1 , 1 } } ; System . out . println ( countPosition ( mat ) ) ; } }
import java . util . * ; class GFG { static void position ( int arr [ ] [ ] , int N ) { int pos = - 1 ; int count ; for ( int i = 0 ; i < N ; i ++ ) { count = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ i ] [ 0 ] <= arr [ j ] [ 0 ] && arr [ i ] [ 1 ] >= arr [ j ] [ 1 ] ) { count ++ ; } } if ( count == N ) { pos = i ; } } if ( pos == - 1 ) { System . out . print ( pos ) ; } else { System . out . print ( pos + 1 ) ; } } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 3 , 3 } , { 1 , 3 } , { 2 , 2 } , { 2 , 3 } , { 1 , 2 } } ; int N = arr . length ; position ( arr , N ) ; } }
import java . util . * ; class GFG { static int mini = 105 , ans , n ; static Vector < Integer > [ ] g = new Vector [ 100 ] ; static int [ ] size = new int [ 100 ] ; static void create_graph ( ) { g [ 1 ] . add ( 2 ) ; g [ 2 ] . add ( 1 ) ; g [ 1 ] . add ( 3 ) ; g [ 3 ] . add ( 1 ) ; g [ 1 ] . add ( 4 ) ; g [ 4 ] . add ( 1 ) ; g [ 2 ] . add ( 5 ) ; g [ 5 ] . add ( 2 ) ; g [ 2 ] . add ( 6 ) ; g [ 6 ] . add ( 2 ) ; } static void dfs ( int node , int parent ) { size [ node ] = 1 ; int mx = 0 ; for ( int y : g [ node ] ) { if ( y == parent ) continue ; dfs ( y , node ) ; size [ node ] += size [ y ] ; mx = Math . max ( mx , size [ y ] ) ; } mx = Math . max ( mx , n - size [ node ] ) ; if ( mx < mini ) { mini = mx ; ans = node ; } } public static void main ( String [ ] args ) { n = 6 ; for ( int i = 0 ; i < g . length ; i ++ ) g [ i ] = new Vector < Integer > ( ) ; create_graph ( ) ; dfs ( 1 , - 1 ) ; System . out . print ( ans + "NEW_LINE"); } }
import java . util . * ; class GFG { static void isPossible ( int arr [ ] , int N ) { int mn = Integer . MAX_VALUE ; int [ ] B = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { mn = Math . min ( mn , arr [ i ] ) ; B [ i ] = arr [ i ] ; } Arrays . sort ( arr ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != B [ i ] ) { if ( B [ i ] % mn != 0 ) { System . out . print ( " No " ) ; return ; } } } System . out . print ( " Yes " ) ; return ; } public static void main ( String [ ] args ) { int N = 6 ; int arr [ ] = { 4 , 3 , 6 , 6 , 2 , 9 } ; isPossible ( arr , N ) ; } }
import java . util . * ; class GFG { static boolean checkArrInStack ( Stack < Integer > s , int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( freq . containsKey ( arr [ i ] ) ) freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; else freq . put ( arr [ i ] , 1 ) ; while ( ! s . isEmpty ( ) ) { int poppedEle = s . peek ( ) ; s . pop ( ) ; if ( freq . containsKey ( poppedEle ) ) freq . put ( poppedEle , freq . get ( poppedEle ) - 1 ) ; } if ( freq . size ( ) == 0 ) return false ; return true ; } public static void main ( String [ ] args ) { Stack < Integer > s = new Stack < Integer > ( ) ; s . add ( 10 ) ; s . add ( 20 ) ; s . add ( 30 ) ; s . add ( 40 ) ; s . add ( 50 ) ; int arr [ ] = { 20 , 30 } ; int n = arr . length ; if ( checkArrInStack ( s , arr , n ) ) System . out . print ( "YESNEW_LINE"); else System . out . print ( "NONEW_LINE"); } }
import java . util . * ; class GFG { static String palindromePrefix ( String S ) { int n = S . length ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { String curr = S . substring ( 0 , i + 1 ) ; int l = 0 , r = curr . length ( ) - 1 ; boolean is_palindrome = true ; while ( l < r ) { if ( curr . charAt ( l ) != curr . charAt ( r ) ) { is_palindrome = false ; break ; } l ++ ; r -- ; } if ( is_palindrome ) return curr ; } return " " ; } static String maxPalindrome ( String S ) { int n = S . length ( ) ; if ( n <= 1 ) { return S ; } String pre = " " , suff = " " ; int i = 0 , j = n - 1 ; while ( S . charAt ( i ) == S . charAt ( j ) && i < j ) { i ++ ; j -- ; } i -- ; j ++ ; pre = S . substring ( 0 , i + 1 ) ; suff = S . substring ( j ) ; if ( j - i == 1 ) { return pre + suff ; } if ( j - i == 2 ) { String mid_char = S . substring ( i + 1 , i + 2 ) ; return pre + mid_char + suff ; } String rem_str = S . substring ( i + 1 , j ) ; String pre_of_rem_str = palindromePrefix ( rem_str ) ; rem_str = reverse ( rem_str ) ; String suff_of_rem_str = palindromePrefix ( rem_str ) ; if ( pre_of_rem_str . length ( ) >= suff_of_rem_str . length ( ) ) { return pre + pre_of_rem_str + suff ; } else { return pre + suff_of_rem_str + suff ; } } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; } public static void main ( String [ ] args ) { String S = " geeksforskeeg " ; System . out . print ( maxPalindrome ( S ) ) ; } }
import java . util . * ; class GFG { static int findSum ( String s ) { int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { sum += ( j - i ) ; } } } return sum ; } public static void main ( String [ ] args ) { String s = " ttt " ; System . out . print ( findSum ( s ) + "NEW_LINE"); } }
class GFG { static int min_flips ( String str , int k ) { if ( str . length ( ) == 0 ) return 0 ; int ans = 0 ; int cnt_zeros = 0 ; for ( char ch : str . toCharArray ( ) ) { if ( ch == '0' ) { ++ cnt_zeros ; } else { cnt_zeros = 0 ; } if ( cnt_zeros == k ) { ++ ans ; cnt_zeros = 0 ; } } return ans ; } public static void main ( String [ ] args ) { String str = "11100000011" ; int k = 3 ; System . out . print ( min_flips ( str , k ) ) ; } }
import java . util . * ; class GFG { public static void count ( int N ) { if ( N == 1 ) { System . out . println ( 10 ) ; return ; } int dp [ ] [ ] = new int [ N ] [ 10 ] ; for ( int i = 1 ; i < 10 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int temp = 0 ; for ( int j = 0 ; j < 10 ; j ++ ) temp += dp [ i - 1 ] [ j ] ; for ( int j = 0 ; j < 10 ; j ++ ) dp [ i ] [ j ] = temp - dp [ i - 1 ] [ j ] ; } int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) ans += dp [ N - 1 ] [ i ] ; System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int N = 2 ; count ( N ) ; } }
import java . util . * ; class GFG { static int ctr = 0 ; static int find ( int [ ] parent , int x ) { if ( parent [ x ] == x ) return x ; parent [ x ] = find ( parent , parent [ x ] ) ; return parent [ x ] ; } static void setUnion ( int [ ] parent , int [ ] rank , int x , int y ) { int parentx = find ( parent , x ) ; int parenty = find ( parent , y ) ; if ( parenty == parentx ) return ; ctr -- ; if ( rank [ parentx ] < rank [ parenty ] ) { parent [ parentx ] = parenty ; } else if ( rank [ parentx ] > rank [ parenty ] ) { parent [ parenty ] = parentx ; } else { parent [ parentx ] = parenty ; rank [ parenty ] ++ ; } } static int [ ] solve ( int n , int m , int [ ] [ ] query ) { int [ ] result = new int [ query . length ] ; int [ ] parent = new int [ n * m ] ; for ( int i = 0 ; i < n * m ; i ++ ) parent [ i ] = i ; int [ ] rank = new int [ n * m ] ; Arrays . fill ( rank , 1 ) ; boolean [ ] grid = new boolean [ n * m ] ; for ( int i = 0 ; i < query . length ; i ++ ) { int x = query [ i ] [ 0 ] ; int y = query [ i ] [ 1 ] ; if ( grid [ m * x + y ] == true ) { result [ i ] = ctr ; continue ; } grid [ m * x + y ] = true ; ctr ++ ; if ( x > 0 && grid [ m * ( x - 1 ) + y ] == true ) setUnion ( parent , rank , m * x + y , m * ( x - 1 ) + y ) ; if ( y > 0 && grid [ m * ( x ) + y - 1 ] == true ) setUnion ( parent , rank , m * x + y , m * ( x ) + y - 1 ) ; if ( x < n - 1 && grid [ m * ( x + 1 ) + y ] == true ) setUnion ( parent , rank , m * x + y , m * ( x + 1 ) + y ) ; if ( y < m - 1 && grid [ m * ( x ) + y + 1 ] == true ) setUnion ( parent , rank , m * x + y , m * ( x ) + y + 1 ) ; result [ i ] = ctr ; } return result ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 , K = 4 ; int [ ] [ ] query = { { 0 , 0 } , { 1 , 1 } , { 1 , 0 } , { 1 , 2 } } ; int [ ] result = solve ( N , M , query ) ; for ( int i = 0 ; i < K ; i ++ ) System . out . print ( result [ i ] + " ▁ " ) ; } }
import java . util . * ; class GFG { static int cnt = 0 ; static void dfs ( int [ ] val , int [ ] cost , Vector < Integer > [ ] tr , int u , int s ) { s = s + cost [ u ] ; if ( s < 0 ) s = 0 ; if ( s > val [ u ] ) return ; cnt ++ ; for ( int i = 0 ; i < tr [ u ] . size ( ) ; i ++ ) { dfs ( val , cost , tr , tr [ u ] . get ( i ) , s ) ; } } public static void main ( String [ ] args ) { int n = 9 ; int val [ ] = { 88 , 22 , 83 , 14 , 95 , 91 , 98 , 53 , 11 } ; int cost [ ] = { - 1 , 24 , - 8 , 67 , 64 , 65 , 12 , - 80 , 8 } ; @ SuppressWarnings ( " unchecked " ) Vector < Integer > [ ] tr = new Vector [ n + 1 ] ; for ( int i = 0 ; i < tr . length ; i ++ ) tr [ i ] = new Vector < Integer > ( ) ; tr [ 0 ] . add ( 3 ) ; tr [ 0 ] . add ( 4 ) ; tr [ 4 ] . add ( 6 ) ; tr [ 6 ] . add ( 2 ) ; tr [ 2 ] . add ( 1 ) ; tr [ 2 ] . add ( 8 ) ; tr [ 8 ] . add ( 5 ) ; tr [ 5 ] . add ( 7 ) ; dfs ( val , cost , tr , 0 , 0 ) ; System . out . print ( n - cnt ) ; } }
import java . util . * ; class GFG { static int [ ] findLargest ( int beg , int end , int [ ] arr , int n ) { if ( beg == end ) { int [ ] compared = new int [ n ] ; compared [ 0 ] = 1 ; compared [ 1 ] = arr [ beg ] ; return compared ; } int [ ] compared1 = findLargest ( beg , ( beg + end ) / 2 , arr , n ) ; int [ ] compared2 = findLargest ( ( beg + end ) / 2 + 1 , end , arr , n ) ; if ( compared1 [ 1 ] > compared2 [ 1 ] ) { int k = compared1 [ 0 ] + 1 ; compared1 [ 0 ] = k ; compared1 [ k ] = compared2 [ 1 ] ; return compared1 ; } else { int k = compared2 [ 0 ] + 1 ; compared2 [ 0 ] = k ; compared2 [ k ] = compared1 [ 1 ] ; return compared2 ; } } static void findSecondLargest ( int end , int [ ] arr ) { int [ ] compared1 = findLargest ( 0 , end - 1 , arr , end ) ; int [ ] compared2 = findLargest ( 2 , compared1 [ 0 ] + 2 , compared1 , compared1 [ 0 ] ) ; System . out . print ( compared2 [ 1 ] ) ; } public static void main ( String [ ] args ) { int N = 10 ; int [ ] arr = { 20 , 1990 , 12 , 1110 , 1 , 59 , 12 , 15 , 120 , 1110 } ; findSecondLargest ( N , arr ) ; } }
class GFG { public static int CountsubString ( char [ ] str , int n ) { int c = 0 ; for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; char temp = str [ i ] , f = 0 ; if ( j == i ) { c ++ ; continue ; } int k = i + 1 ; while ( temp > str [ k ] && k <= j ) { temp = str [ k ] ; k ++ ; } if ( k > j ) { c ++ ; f = 2 ; } while ( k <= j && temp < str [ k ] && f != 2 ) { temp = str [ k ] ; k ++ ; } if ( k > j && f != 2 ) { c ++ ; f = 0 ; } } } return c ; } public static void main ( String [ ] args ) { char str [ ] = { ' b ' , ' a ' , ' d ' , ' e ' } ; System . out . println ( CountsubString ( str , str . length ) ) ; } }
import java . util . * ; class GFG { static Vector < Integer > generateSequence ( int [ ] freq , int n ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; int total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { m . put ( i , freq [ i ] ) ; total += freq [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( i ) ) { Vector < Integer > sequence = new Vector < Integer > ( ) ; @ SuppressWarnings ( " unchecked " ) HashMap < Integer , Integer > mcopy = ( HashMap < Integer , Integer > ) m . clone ( ) ; if ( mcopy . containsKey ( i ) && mcopy . get ( i ) > 0 ) mcopy . put ( i , mcopy . get ( i ) - 1 ) ; sequence . add ( i ) ; int last = i ; for ( int i1 = 0 ; i1 < total - 1 ; i1 ++ ) { if ( mcopy . containsKey ( last - 1 ) && mcopy . get ( last - 1 ) > 0 ) { mcopy . put ( last - 1 , mcopy . get ( last - 1 ) - 1 ) ; sequence . add ( last - 1 ) ; last -- ; } else if ( mcopy . containsKey ( last + 1 ) ) { mcopy . put ( last + 1 , mcopy . get ( last + 1 ) - 1 ) ; sequence . add ( last + 1 ) ; last ++ ; } else break ; } if ( sequence . size ( ) == total ) { return sequence ; } } } Vector < Integer > empty = new Vector < Integer > ( ) ; return empty ; } static void PrintSequence ( int freq [ ] , int n ) { Vector < Integer > sequence = generateSequence ( freq , n ) ; if ( sequence . size ( ) == 0 ) { System . out . print ( " - 1" ) ; } else { for ( int i = 0 ; i < sequence . size ( ) ; i ++ ) { System . out . print ( sequence . get ( i ) + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int freq [ ] = { 2 , 2 , 2 , 3 , 1 } ; int N = 5 ; PrintSequence ( freq , N ) ; } }
import java . util . * ; class GFG { public static void medianChange ( List < Integer > arr1 , List < Integer > arr2 ) { int N = arr1 . size ( ) ; List < Integer > median = new ArrayList < > ( ) ; if ( ( N & 1 ) != 0 ) median . add ( arr1 . get ( N / 2 ) * 1 ) ; else median . add ( ( arr1 . get ( N / 2 ) + arr1 . get ( ( N - 1 ) / 2 ) ) / 2 ) ; for ( int x = 0 ; x < arr2 . size ( ) ; x ++ ) { int it = arr1 . indexOf ( arr2 . get ( x ) ) ; arr1 . remove ( it ) ; N -- ; if ( ( N & 1 ) != 0 ) { median . add ( arr1 . get ( N / 2 ) * 1 ) ; } else { median . add ( ( arr1 . get ( N / 2 ) + arr1 . get ( ( N - 1 ) / 2 ) ) / 2 ) ; } } for ( int i = 0 ; i < median . size ( ) - 1 ; i ++ ) { System . out . print ( median . get ( i + 1 ) - median . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { List < Integer > arr1 = new ArrayList < Integer > ( ) { { add ( 2 ) ; add ( 4 ) ; add ( 6 ) ; add ( 8 ) ; add ( 10 ) ; } } ; List < Integer > arr2 = new ArrayList < Integer > ( ) { { add ( 4 ) ; add ( 6 ) ; } } ; medianChange ( arr1 , arr2 ) ; } }
import java . util . * ; class GFG { static int countFac ( int n ) { int m = n ; int count = 0 ; for ( int i = 2 ; ( i * i ) <= m ; ++ i ) { int total = 0 ; while ( n % i == 0 ) { n /= i ; ++ total ; } int temp = 0 ; for ( int j = 1 ; ( temp + j ) <= total ; ++ j ) { temp += j ; ++ count ; } } if ( n != 1 ) ++ count ; return count ; } public static void main ( String [ ] args ) { int N = 24 ; System . out . println ( countFac ( N ) ) ; } }
import java . util . Arrays ; class GFG { static int findMissing ( int arr [ ] , int left , int right , int diff ) { if ( right <= left ) return 0 ; int mid = left + ( right - left ) / 2 ; if ( arr [ mid + 1 ] - arr [ mid ] != diff ) return ( arr [ mid ] + diff ) ; if ( mid > 0 && arr [ mid ] - arr [ mid - 1 ] != diff ) return ( arr [ mid - 1 ] + diff ) ; if ( arr [ mid ] == arr [ 0 ] + mid * diff ) return findMissing ( arr , mid + 1 , right , diff ) ; return findMissing ( arr , left , mid - 1 , diff ) ; } static int missingElement ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff = ( arr [ n - 1 ] - arr [ 0 ] ) / n ; return findMissing ( arr , 0 , n - 1 , diff ) ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 2 , 8 , 6 , 10 } ; int n = arr . length ; System . out . println ( missingElement ( arr , n ) ) ; } }
class GFG { static int naive_find_x ( int N ) { int c = 0 , i ; for ( i = 1 ; i < N ; i ++ ) { c += i * i * i ; if ( c >= N ) break ; } return i ; } public static void main ( String [ ] args ) { int N = 100 ; System . out . println ( naive_find_x ( N ) ) ; } }
class GFG { static int xorOfSum ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) answer ^= ( a [ i ] + a [ j ] ) ; } return answer ; } public static void main ( String [ ] args ) { int n = 3 ; int A [ ] = { 1 , 2 , 3 } ; System . out . print ( xorOfSum ( A , n ) ) ; } }
import java . util . * ; class GFG { static void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } } static void fibonacci ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , max_val ) ; int minimum = Integer . MAX_VALUE ; int maximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . contains ( arr [ i ] ) ) { minimum = Math . min ( minimum , arr [ i ] ) ; maximum = Math . max ( maximum , arr [ i ] ) ; } } System . out . print ( minimum + " , ▁ " + maximum + "NEW_LINE"); } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; fibonacci ( arr , n ) ; } }
import java . util . * ; class GFG { static boolean permutation ( int [ ] arr , int n ) { Set < Integer > hash = new HashSet < Integer > ( ) ; int maxEle = 0 ; for ( int i = 0 ; i < n ; i ++ ) { hash . add ( arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } if ( maxEle != n ) return false ; if ( hash . size ( ) == n ) return true ; return false ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 5 , 3 , 2 } ; int n = arr . length ; if ( permutation ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Arrays ; class GFG { static boolean check ( int m , int n , int arr [ ] ) { int [ ] desired = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = m ; m -- ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > desired [ i ] desired [ i ] < 1 ) { return false ; } } return true ; } static int minOperations ( int arr [ ] , int n ) { int start = ( int ) arr [ n - 1 ] ; int end = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) + n ; int max_arr = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( check ( mid , n , arr ) ) { max_arr = mid ; end = mid - 1 ; } else { start = mid + 1 ; } } int [ ] desired = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { desired [ i ] = max_arr ; max_arr -- ; } int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { operations += ( desired [ i ] - arr [ i ] ) ; } return operations ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 4 , 5 , 5 , 7 } ; int n = arr . length ; System . out . println ( minOperations ( arr , n ) ) ; } }
public class GFG { static int costToPanagram ( String str , int cost [ ] ) { int i , n = str . length ( ) ; int occurrences [ ] = new int [ 26 ] ; for ( i = 0 ; i < n ; i ++ ) occurrences [ str . charAt ( i ) - ' a ' ] ++ ; int gain = 0 ; for ( i = 0 ; i < 26 ; i ++ ) { if ( occurrences [ i ] == 0 ) gain -= ( 2 * cost [ i ] ) ; else if ( occurrences [ i ] > 1 ) gain += ( cost [ i ] * ( occurrences [ i ] - 1 ) ) ; } if ( gain >= 0 ) return 0 ; return ( gain * - 1 ) ; } public static void main ( String [ ] args ) { int cost [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; String str = " geeksforgeeks " ; System . out . println ( costToPanagram ( str , cost ) ) ; } }
import java . util . HashMap ; import java . util . Map ; class GfG { static int strScore ( String str [ ] , String s , int n ) { HashMap < String , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) m . put ( str [ i ] , i + 1 ) ; if ( ! m . containsKey ( s ) ) return 0 ; int score = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) score += s . charAt ( i ) - ' a ' + 1 ; score = score * m . get ( s ) ; return score ; } public static void main ( String [ ] args ) { String str [ ] = { " geeksforgeeks " , " algorithms " , " stack " } ; String s = " algorithms " ; int n = str . length ; System . out . println ( strScore ( str , s , n ) ) ; } }
class GFG { public String replacePi ( String input ) { String output = " " ; int size = input . length ( ) ; for ( int i = 0 ; i < size ; ++ i ) { if ( i + 1 < size && input . charAt ( i ) == ' p ' && input . charAt ( i + 1 ) == ' i ' ) { output += "3.14" ; i ++ ; } else { output += input . charAt ( i ) ; } } return output ; } public static void main ( String args [ ] ) { GFG g = new GFG ( ) ; String input = "2 ▁ * ▁ pi ▁ + ▁ 3 ▁ * ▁ pi ▁ = ▁ 5 ▁ * ▁ pi " ; System . out . println ( g . replacePi ( input ) ) ; } }
import java . util . * ; class Solution { static int numberOfElements ( int height [ ] , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; } public static void main ( String args [ ] ) { int n = 6 ; int height [ ] = { 4 , 8 , 2 , 0 , 0 , 5 } ; System . out . println ( numberOfElements ( height , n ) ) ; } }
import java . io . * ; class GFG { static int getMin ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . min ( res , arr [ i ] ) ; return res ; } static int getMax ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; } static int findSum ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min + max ; } static int findProduct ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min * max ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = arr . length ; System . out . println ( " Sum ▁ = ▁ " + findSum ( arr , n ) ) ; System . out . println ( " Product ▁ = ▁ " + findProduct ( arr , n ) ) ; } }
class GFG { static String sortString ( String str , int n ) { String new_str = " " ; for ( int i = ' a ' ; i <= ' z ' ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( str . charAt ( j ) == i ) new_str += str . charAt ( j ) ; return new_str ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; System . out . print ( sortString ( str , n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static void occurrenceDays ( int n , String firstday ) { String [ ] days = new String [ ] { " Monday " , " Tuesday " , " Wednesday " , " Thursday " , " Friday " , " Saturday " , " Sunday " } ; int [ ] count = new int [ 7 ] ; for ( int i = 0 ; i < 7 ; i ++ ) count [ i ] = 4 ; int pos = 0 ; for ( int i = 0 ; i < 7 ; i ++ ) { if ( firstday == days [ i ] ) { pos = i ; break ; } } int inc = n - 28 ; for ( int i = pos ; i < pos + inc ; i ++ ) { if ( i > 6 ) count [ i % 7 ] = 5 ; else count [ i ] = 5 ; } for ( int i = 0 ; i < 7 ; i ++ ) { System . out . println ( days [ i ] + " ▁ " + count [ i ] ) ; } } public static void main ( String argc [ ] ) { int n = 31 ; String firstday = " Tuesday " ; occurrenceDays ( n , firstday ) ; } }
class GFG { static int getRandom ( int x , int y ) { return ( int ) ( x + Math . random ( ) * 10 % ( y - x + 1 ) ) ; } static int randomizedBinarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = getRandom ( l , r ) ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = arr . length ; int x = 10 ; int result = randomizedBinarySearch ( arr , 0 , n - 1 , x ) ; if ( result == - 1 ) System . out . printf ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; else System . out . printf ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " , result ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static boolean isSorted ( int [ ] [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 0 ] > arr [ i - 1 ] [ 0 ] ) { return false ; } } return true ; } static String isPossibleToSort ( int [ ] [ ] arr , int N ) { int group = arr [ 0 ] [ 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] [ 1 ] != group ) { return " Yes " ; } } if ( isSorted ( arr , N ) ) { return " Yes " ; } else { return " No " ; } } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 340000 , 2 } , { 45000 , 1 } , { 30000 , 2 } , { 50000 , 4 } } ; int N = arr . length ; System . out . print ( isPossibleToSort ( arr , N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static void maxLenSubset ( int a [ ] , int n ) { Arrays . sort ( a ) ; int index = 0 , maxlen = - 1 ; int i = 0 ; while ( i < n ) { int j = i ; int len = 1 ; while ( j < n - 1 ) { if ( 2 * a [ j ] >= a [ j + 1 ] ) { len ++ ; } else break ; j ++ ; } if ( maxlen < len ) { maxlen = len ; index = i ; } j ++ ; i = j ; } i = index ; while ( maxlen > 0 ) { System . out . print ( a [ i ] + " ▁ " ) ; maxlen -- ; i ++ ; } } public static void main ( String [ ] args ) { int a [ ] = { 3 , 1 , 5 , 11 } ; int n = a . length ; maxLenSubset ( a , n ) ; } }
import java . util . * ; class GFG { static void maximumSum ( int [ ] arr , int N ) { int sum ; Arrays . sort ( arr ) ; sum = ( arr [ N - 1 ] - arr [ 0 ] ) + ( arr [ N - 2 ] - arr [ 0 ] ) + ( arr [ N - 1 ] - arr [ N - 2 ] ) ; System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 4 , 2 } ; int N = arr . length ; maximumSum ( arr , N ) ; } }
import java . io . * ; class GFG { static void minOperation ( int a [ ] , int N ) { int totOps = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { totOps += Math . abs ( a [ i ] - a [ i + 1 ] ) ; } int maxOps = Math . max ( Math . abs ( a [ 0 ] - a [ 1 ] ) , Math . abs ( a [ N - 1 ] - a [ N - 2 ] ) ) ; for ( int i = 1 ; i < N - 1 ; i ++ ) { maxOps = Math . max ( maxOps , Math . abs ( a [ i ] - a [ i - 1 ] ) + Math . abs ( a [ i ] - a [ i + 1 ] ) - Math . abs ( a [ i - 1 ] - a [ i + 1 ] ) ) ; } System . out . println ( totOps - maxOps ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , - 1 , 0 , 1 , 1 } ; int N = arr . length ; minOperation ( arr , N ) ; } }
import java . util . * ; class GFG { static void numOperation ( int arr [ ] , int N , int D ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( ( arr [ i + 1 ] - arr [ i ] ) % D != 0 ) { System . out . println ( " - 1" ) ; return ; } } int count = 0 ; int mid = arr [ N / 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { count += Math . abs ( mid - arr [ i ] ) / D ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int N = 4 , D = 2 ; int arr [ ] = { 2 , 4 , 6 , 8 } ; numOperation ( arr , N , D ) ; } }
import java . util . * ; class GFG { static void findSum ( int A [ ] , int N , int K ) { Arrays . sort ( A ) ; int sum = 0 ; for ( int i = N / K ; i < N ; i += K - 1 ) { sum += A [ i ] ; } System . out . print ( sum ) ; } public static void main ( String [ ] args ) { int K = 4 ; int A [ ] = { 2 , 3 , 1 , 4 , 7 , 5 , 6 , 1 } ; int N = A . length ; findSum ( A , N , K ) ; } }
class GFG { static int merge ( int arr [ ] , int temp [ ] , int l , int m , int r , int K ) { int i = l ; int j = m + 1 ; int cnt = 0 ; for ( i = l ; i <= m ; i ++ ) { boolean found = false ; while ( j <= r ) { if ( arr [ i ] >= K * arr [ j ] ) { found = true ; } else break ; j ++ ; } if ( found == true ) { cnt += j - ( m + 1 ) ; j -- ; } } int k = l ; i = l ; j = m + 1 ; while ( i <= m && j <= r ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else temp [ k ++ ] = arr [ j ++ ] ; } while ( i <= m ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= r ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = l ; i <= r ; i ++ ) arr [ i ] = temp [ i ] ; return cnt ; } static int mergeSortUtil ( int arr [ ] , int temp [ ] , int l , int r , int K ) { int cnt = 0 ; if ( l < r ) { int m = ( l + r ) / 2 ; cnt += mergeSortUtil ( arr , temp , l , m , K ) ; cnt += mergeSortUtil ( arr , temp , m + 1 , r , K ) ; cnt += merge ( arr , temp , l , m , r , K ) ; } return cnt ; } static void mergeSort ( int arr [ ] , int N , int K ) { int temp [ ] = new int [ N ] ; System . out . print ( mergeSortUtil ( arr , temp , 0 , N - 1 , K ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 2 , 5 } ; int N = arr . length ; int K = 2 ; mergeSort ( arr , N , K ) ; } }
import java . io . * ; class GFG { static void Bubble_Sort ( int [ ] arr , int n ) { boolean flag ; for ( int i = 1 ; i < n ; ++ i ) { flag = false ; for ( int j = 0 ; j <= ( n - i - 1 ) ; ++ j ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; flag = true ; } } if ( flag == false ) break ; } } public static void main ( String [ ] args ) { int n = 5 ; int [ ] arr = { 2 , 0 , 1 , 4 , 3 } ; Bubble_Sort ( arr , n ) ; System . out . print ( " The ▁ Sorted ▁ Array ▁ by ▁ " + " using ▁ Bubble ▁ Sort ▁ is ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . util . Arrays ; class GFG { static void minRemovals ( int [ ] A , int N ) { Arrays . sort ( A ) ; int mx = A [ N - 1 ] ; int sum = 1 ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; } if ( sum - mx >= mx ) { System . out . println ( 0 ) ; } else { System . out . println ( 2 * mx - sum ) ; } } public static void main ( String [ ] args ) { int [ ] A = { 3 , 3 , 2 } ; int N = A . length ; minRemovals ( A , N ) ; } }
import java . util . * ; class GFG { static int maxRectangle ( int [ ] [ ] sequence , int size ) { int [ ] X_Cord = new int [ size ] ; int [ ] Y_Cord = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) { X_Cord [ i ] = sequence [ i ] [ 0 ] ; Y_Cord [ i ] = sequence [ i ] [ 1 ] ; } Arrays . sort ( X_Cord ) ; Arrays . sort ( Y_Cord ) ; int X_Max = 0 , Y_Max = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { X_Max = Math . max ( X_Max , X_Cord [ i + 1 ] - X_Cord [ i ] ) ; Y_Max = Math . max ( Y_Max , Y_Cord [ i + 1 ] - Y_Cord [ i ] ) ; } return X_Max * Y_Max ; } public static void main ( String [ ] args ) { int [ ] [ ] point = { { - 2 , 0 } , { 2 , 0 } , { 4 , 0 } , { 4 , 2 } } ; int n = point . length ; System . out . print ( maxRectangle ( point , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void checkArrangement ( Integer [ ] A1 , Integer [ ] A2 , int n , int k ) { Arrays . sort ( A1 ) ; Arrays . sort ( A2 , Collections . reverseOrder ( ) ) ; int flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( A1 [ i ] + A2 [ i ] > k ) || ( A1 [ i ] + A2 [ i ] < k / 2 ) ) { flag = 1 ; break ; } } if ( flag == 1 ) System . out . println ( " No " ) ; else System . out . println ( " Yes " ) ; } public static void main ( String [ ] args ) { Integer [ ] arr1 = { 1 , 3 , 4 , 5 } ; Integer [ ] arr2 = { 2 , 0 , 1 , 1 } ; int K = 6 ; int N = arr1 . length ; checkArrangement ( arr1 , arr2 , N , K ) ; } }
class GFG { static void sortarray ( int arr [ ] , int N ) { if ( N == 3 ) System . out . println ( " NO " ) ; else if ( N % 4 == 0 N % 4 == 1 ) { System . out . println ( " YES " ) ; System . out . println ( N / 2 ) ; int k = 1 , l ; for ( l = 0 ; l < ( N / 4 ) ; l ++ ) { System . out . println ( k + " ▁ " + ( k + 1 ) + " ▁ " + N ) ; System . out . println ( k + 1 + " ▁ " + N + " ▁ " + ( N - 1 ) ) ; k = k + 2 ; N = N - 2 ; } } else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; sortarray ( arr , N ) ; } }
import java . util . Arrays ; class GFG { static int findMinSum ( int [ ] arr , int K , int L , int size ) { if ( K * L > size ) return - 1 ; int minsum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < K ; i ++ ) minsum += arr [ i ] ; return minsum ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 15 , 5 , 1 , 35 , 16 , 67 , 10 } ; int K = 3 ; int L = 2 ; int length = arr . length ; System . out . print ( findMinSum ( arr , K , L , length ) ) ; } }
import java . io . * ; class GFG { static int findKthSmallest ( int [ ] arr , int n , int k ) { int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } int [ ] counter = new int [ max + 1 ] ; int smallest = 0 ; for ( int i = 0 ; i < n ; i ++ ) { counter [ arr [ i ] ] ++ ; } for ( int num = 1 ; num <= max ; num ++ ) { if ( counter [ num ] > 0 ) { smallest += counter [ num ] ; } if ( smallest >= k ) { return num ; } } return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 7 , 1 , 4 , 4 , 20 , 15 , 8 } ; int N = arr . length ; int K = 5 ; System . out . print ( findKthSmallest ( arr , N , K ) ) ; } }
class GFG { static int N = 4 ; static void func ( int a [ ] [ ] ) { int i , j , k ; for ( i = 0 ; i < N ; i ++ ) { if ( i % 2 == 0 ) { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] > a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } else { for ( j = 0 ; j < N ; j ++ ) { for ( k = j + 1 ; k < N ; ++ k ) { if ( a [ i ] [ j ] < a [ i ] [ k ] ) { int temp = a [ i ] [ j ] ; a [ i ] [ j ] = a [ i ] [ k ] ; a [ i ] [ k ] = temp ; } } } } } for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { System . out . print ( a [ i ] [ j ] + " ▁ " ) ; } System . out . print ( "NEW_LINE"); } } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 5 , 7 , 3 , 4 } , { 9 , 5 , 8 , 2 } , { 6 , 3 , 8 , 1 } , { 5 , 8 , 9 , 3 } } ; func ( a ) ; } }
import java . util . * ; class GFG { static HashMap < Integer , Integer > [ ] g = new HashMap [ 200005 ] ; static HashSet < Integer > s = new HashSet < > ( ) ; static HashSet < Integer > ns = new HashSet < > ( ) ; static void dfs ( int x ) { Vector < Integer > v = new Vector < > ( ) ; v . clear ( ) ; ns . clear ( ) ; for ( int it : s ) { if ( g [ x ] . get ( it ) != null ) { v . add ( it ) ; } else { ns . add ( it ) ; } } s = ns ; for ( int i : v ) { dfs ( i ) ; } } static void weightOfMST ( int N ) { int cnt = 0 ; for ( int i = 1 ; i <= N ; ++ i ) { s . add ( i ) ; } Vector < Integer > qt = new Vector < > ( ) ; for ( int t : s ) qt . add ( t ) ; while ( ! qt . isEmpty ( ) ) { ++ cnt ; int t = qt . get ( 0 ) ; qt . remove ( 0 ) ; dfs ( t ) ; } System . out . print ( cnt - 4 ) ; } public static void main ( String [ ] args ) { int N = 6 , M = 11 ; int edges [ ] [ ] = { { 1 , 3 } , { 1 , 4 } , { 1 , 5 } , { 1 , 6 } , { 2 , 3 } , { 2 , 4 } , { 2 , 5 } , { 2 , 6 } , { 3 , 4 } , { 3 , 5 } , { 3 , 6 } } ; for ( int i = 0 ; i < g . length ; i ++ ) g [ i ] = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < M ; ++ i ) { int u = edges [ i ] [ 0 ] ; int v = edges [ i ] [ 1 ] ; g [ u ] . put ( v , 1 ) ; g [ v ] . put ( u , 1 ) ; } weightOfMST ( N ) ; } }
import java . util . * ; class GFG { static void sortDiff ( Vector < Integer > arr , int n ) { Collections . sort ( arr ) ; Vector < Integer > out = new Vector < Integer > ( ) ; while ( n > 0 ) { out . add ( arr . get ( n / 2 ) ) ; arr . remove ( n / 2 ) ; n = n - 1 ; } for ( int i : out ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { Integer [ ] a = { 8 , 1 , 2 , 3 , 0 } ; Vector < Integer > arr = new Vector < Integer > ( Arrays . asList ( a ) ) ; int n = 5 ; sortDiff ( arr , n ) ; } }
import java . util . * ; class GFG { static int countPairs ( int [ ] A , int [ ] B ) { int n = A . length ; int ans = 0 ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] > B [ ans ] ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] A = { 30 , 28 , 45 , 22 } ; int [ ] B = { 35 , 25 , 22 , 48 } ; System . out . print ( countPairs ( A , B ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static void sortArr ( int arr [ ] , int n ) { ArrayList < int [ ] > vp = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { vp . add ( new int [ ] { reversDigits ( arr [ i ] ) , arr [ i ] } ) ; } Collections . sort ( vp , ( a , b ) -> a [ 0 ] - b [ 0 ] ) ; for ( int i = 0 ; i < vp . size ( ) ; i ++ ) System . out . print ( vp . get ( i ) [ 1 ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 10 , 102 , 31 , 15 } ; int n = arr . length ; sortArr ( arr , n ) ; } }
import java . util . * ; class GFG { static int [ ] orgazineInOrder ( int [ ] vec , int [ ] op , int n ) { int [ ] result = new int [ n ] ; Arrays . sort ( vec ) ; int i = 0 , j = n - 1 , k = 0 ; while ( i <= j && k <= n - 2 ) { if ( op [ k ] == ' < ' ) { result [ k ] = vec [ i ++ ] ; } else { result [ k ] = vec [ j -- ] ; } k ++ ; } result [ n - 1 ] = vec [ i ] ; return result ; } public static void main ( String [ ] args ) { int [ ] vec = { 8 , 2 , 7 , 1 , 5 , 9 } ; int [ ] op = { ' > ' , ' > ' , ' < ' , ' > ' , ' < ' } ; int [ ] result = orgazineInOrder ( vec , op , vec . length ) ; for ( int i = 0 ; i < result . length ; i ++ ) { System . out . print ( result [ i ] + " ▁ " ) ; } } }
class GFG { static int MAX = 1000 ; static boolean lineExists ( int x [ ] , int y [ ] , int v [ ] , int n ) { int size = ( 2 * MAX ) + 1 ; long [ ] arr = new long [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ x [ i ] + MAX ] += v [ i ] ; } for ( int i = 1 ; i < size ; i ++ ) arr [ i ] += arr [ i - 1 ] ; if ( arr [ size - 1 ] == 0 ) return true ; if ( arr [ size - 1 ] - arr [ 0 ] == 0 ) return true ; for ( int i = 1 ; i < size - 1 ; i ++ ) { if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i - 1 ] ) return true ; if ( arr [ i - 1 ] == arr [ size - 1 ] - arr [ i ] ) return true ; if ( arr [ i ] == arr [ size - 1 ] - arr [ i ] ) return true ; } if ( arr [ size - 2 ] == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int x [ ] = { - 3 , 5 , 8 } ; int y [ ] = { 8 , 7 , 9 } ; int v [ ] = { 8 , 2 , 10 } ; int n = x . length ; if ( lineExists ( x , y , v , n ) ) System . out . printf ( " Yes " ) ; else System . out . printf ( " No " ) ; } }
import java . util . Arrays ; class GFG { static int maxSum ( int a [ ] , int n ) { Arrays . sort ( a ) ; int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i += 2 ) { sum += a [ i ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 1 , 4 , 5 } ; int n = arr . length ; System . out . println ( maxSum ( arr , n ) ) ; } }
import java . util . Arrays ; class geeksforgeeks { static int minOperations ( int ar [ ] , int k ) { Arrays . sort ( ar ) ; int opsNeeded = 0 ; for ( int i = 0 ; i < k ; i ++ ) { opsNeeded += ar [ k - 1 ] - ar [ i ] ; } int ans = opsNeeded ; for ( int i = k ; i < ar . length ; i ++ ) { opsNeeded = opsNeeded - ( ar [ i - 1 ] - ar [ i - k ] ) ; opsNeeded += ( k - 1 ) * ( ar [ i ] - ar [ i - 1 ] ) ; ans = Math . min ( ans , opsNeeded ) ; } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 1 , 9 , 100 } ; int n = arr . length ; int k = 3 ; System . out . printf ( " % d " , minOperations ( arr , k ) ) ; } }
class GFG { static float knapSack ( int W , float wt [ ] , float val [ ] , int n ) { float maxratio = Integer . MIN_VALUE ; int maxindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( val [ i ] / wt [ i ] ) > maxratio ) { maxratio = ( val [ i ] / wt [ i ] ) ; maxindex = i ; } } return ( W * maxratio ) ; } public static void main ( String [ ] args ) { float val [ ] = { 14 , 27 , 44 , 19 } ; float wt [ ] = { 6 , 7 , 9 , 8 } ; int n = val . length ; int W = 50 ; System . out . println ( knapSack ( W , wt , val , n ) ) ; } }
import java . util . * ; class GFG { static class Node { int data ; Node left ; Node right ; } ; static Node newNode ( int num ) { Node temp = new Node ( ) ; temp . data = num ; temp . left = temp . right = null ; return temp ; } static void inorder ( Node root ) { if ( root != null ) { inorder ( root . left ) ; System . out . print ( root . data + " ▁ " ) ; inorder ( root . right ) ; } } static void merge ( Node root1 , Node root2 ) { if ( root1 == null && root2 == null ) return ; if ( root1 == null ) { inorder ( root2 ) ; return ; } if ( root2 == null ) { inorder ( root1 ) ; return ; } Node temp1 = root1 ; Node prev1 = null ; while ( temp1 . left != null ) { prev1 = temp1 ; temp1 = temp1 . left ; } Node temp2 = root2 ; Node prev2 = null ; while ( temp2 . left != null ) { prev2 = temp2 ; temp2 = temp2 . left ; } if ( temp1 . data <= temp2 . data ) { System . out . print ( temp1 . data + " ▁ " ) ; if ( prev1 == null ) { merge ( root1 . right , root2 ) ; } else { prev1 . left = temp1 . right ; merge ( root1 , root2 ) ; } } else { System . out . print ( temp2 . data + " ▁ " ) ; if ( prev2 == null ) { merge ( root1 , root2 . right ) ; } else { prev2 . left = temp2 . right ; merge ( root1 , root2 ) ; } } } public static void main ( String args [ ] ) { Node root1 = null , root2 = null ; root1 = newNode ( 3 ) ; root1 . left = newNode ( 1 ) ; root1 . right = newNode ( 5 ) ; root2 = newNode ( 4 ) ; root2 . left = newNode ( 2 ) ; root2 . right = newNode ( 6 ) ; merge ( root1 , root2 ) ; } }
import java . util . Arrays ; class GFG { static long mod = 1000000007 ; static long [ ] [ ] arr = new long [ 1001 ] [ 1001 ] ; static void Preprocess ( ) { arr [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= 1000 ; ++ i ) { arr [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) { arr [ i ] [ j ] = ( arr [ i - 1 ] [ j - 1 ] + arr [ i - 1 ] [ j ] ) % mod ; } arr [ i ] [ i ] = 1 ; } } static long powmod ( long a , long n ) { if ( n == 0 ) { return 1 ; } long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) { return ( pt * a ) % mod ; } else { return pt ; } } static long CountSubset ( int [ ] val , int n ) { long ans = powmod ( 2 , n - 1 ) ; Arrays . sort ( val ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && val [ j ] == val [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + arr [ l + r ] [ l ] ) % mod ; j ++ ; } } return ans ; } public static void main ( String [ ] args ) { Preprocess ( ) ; int val [ ] = { 2 , 3 , 2 } ; int n = val . length ; System . out . println ( CountSubset ( val , n ) ) ; } }
import java . util . * ; class GFG { static void reArrange ( String words [ ] , int n ) { HashMap < String , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . put ( words [ i ] , ( i + 1 ) ) ; } Arrays . sort ( words ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( freq . get ( words [ i ] ) + " ▁ " ) ; } public static void main ( String [ ] args ) { String words [ ] = { " live " , " place " , " travel " , " word " , " sky " } ; int n = words . length ; reArrange ( words , n ) ; } }
import java . util . * ; class GFG { static int MinimizeleftOverSum ( int a [ ] , int n ) { Vector < Integer > v1 = new Vector < Integer > ( ) , v2 = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) v1 . add ( a [ i ] ) ; else v2 . add ( a [ i ] ) ; } if ( v1 . size ( ) > v2 . size ( ) ) { Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int x = v1 . size ( ) - v2 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v1 . get ( i ++ ) ; } return sum ; } else if ( v2 . size ( ) > v1 . size ( ) ) { Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int x = v2 . size ( ) - v1 . size ( ) - 1 ; int sum = 0 ; int i = 0 ; while ( i < x ) { sum += v2 . get ( i ++ ) ; } return sum ; } else return 0 ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 2 , 2 , 2 } ; int n = a . length ; System . out . println ( MinimizeleftOverSum ( a , n ) ) ; } }
import java . util . * ; class GfG { static void printNumbers ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int A = arr [ n - 1 ] , B = - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } System . out . print ( " A ▁ = ▁ " + A + " , ▁ B ▁ = ▁ " + B ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 } ; int n = arr . length ; printNumbers ( arr , n ) ; } }
class GFG { static void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void removeMin ( int arr [ ] , int n ) { int i , minVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minVal = Math . min ( minVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; } static void removeFromMax ( int arr [ ] , int n ) { int i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = Math . max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; } static void modifyArray ( int arr [ ] , int n , int k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = arr . length ; int k = 2 ; modifyArray ( arr , n , k ) ; } }
import java . util . Arrays ; class GFG { static int findProduct ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int prod = 1 * arr [ 0 ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) { prod = prod * arr [ i + 1 ] ; } } return prod ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 } ; int n = arr . length ; System . out . println ( findProduct ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static void main ( String [ ] args ) { int a [ ] = { 10 , 12 , 5 } ; Arrays . sort ( a ) ; for ( int i = 0 ; i < 3 ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } }
import java . util . * ; class GFG { static void operations ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int i = 0 , sum = 0 ; while ( k -- > 0 ) { while ( i < n && arr [ i ] - sum == 0 ) i ++ ; if ( i < n && arr [ i ] - sum > 0 ) { System . out . print ( arr [ i ] - sum + " ▁ " ) ; sum = arr [ i ] ; } else System . out . println ( "0" ) ; } } public static void main ( String args [ ] ) { int k = 5 ; int arr [ ] = { 3 , 6 , 4 , 2 } ; int n = arr . length ; operations ( arr , n , k ) ; } }
import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . Vector ; class GFG { static int minSum ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < > ( ) ; Vector < Integer > oddArr = new Vector < > ( ) ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n / 2 ) { oddArr . add ( arr [ i ] ) ; } else { evenArr . add ( arr [ i ] ) ; } } Comparator comparator = Collections . reverseOrder ( ) ; Collections . sort ( evenArr , comparator ) ; int i = 0 , sum = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; arr [ i ++ ] = oddArr . get ( j ) ; sum += evenArr . get ( j ) * oddArr . get ( j ) ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; System . out . println ( " Minimum ▁ required ▁ sum ▁ = ▁ " + minSum ( arr , n ) ) ; System . out . println ( " Sorted ▁ array ▁ in ▁ required ▁ format ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
import java . util . * ; class GFG { static void bitonicGenerator ( int arr [ ] , int n ) { Vector < Integer > evenArr = new Vector < Integer > ( ) ; Vector < Integer > oddArr = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 1 ) { evenArr . add ( arr [ i ] ) ; } else { oddArr . add ( arr [ i ] ) ; } } Collections . sort ( evenArr ) ; Collections . sort ( oddArr , Collections . reverseOrder ( ) ) ; int i = 0 ; for ( int j = 0 ; j < evenArr . size ( ) ; j ++ ) { arr [ i ++ ] = evenArr . get ( j ) ; } for ( int j = 0 ; j < oddArr . size ( ) ; j ++ ) { arr [ i ++ ] = oddArr . get ( j ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = arr . length ; bitonicGenerator ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
import java . util . * ; class GFG { static int countBits ( int a ) { int count = 0 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) count += 1 ; a = a >> 1 ; } return count ; } static void sortBySetBitCount ( int arr [ ] , int n ) { Vector < Integer > [ ] count = new Vector [ 32 ] ; for ( int i = 0 ; i < count . length ; i ++ ) count [ i ] = new Vector < Integer > ( ) ; int setbitcount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { setbitcount = countBits ( arr [ i ] ) ; count [ setbitcount ] . add ( arr [ i ] ) ; } int j = 0 ; for ( int i = 31 ; i >= 0 ; i -- ) { Vector < Integer > v1 = count [ i ] ; for ( int p = 0 ; p < v1 . size ( ) ; p ++ ) arr [ j ++ ] = v1 . get ( p ) ; } } static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; sortBySetBitCount ( arr , n ) ; printArr ( arr , n ) ; } }
import java . util . Arrays ; class GFG { static int solve ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 8 , 4 , 5 , 2 , 3 } ; int n = arr . length ; System . out . print ( " Sum ▁ is ▁ " + solve ( arr , n ) ) ; } }
import java . util . * ; class GFG { static long KthSolution ( long X , long K ) { long ans = 0 ; for ( int i = 0 ; i < 64 ; i ++ ) { if ( ( X & ( 1 << i ) ) == 0 ) { if ( ( K & 1 ) > 0 ) { ans |= ( 1 << i ) ; } K >>= 1 ; if ( K == 0 ) { break ; } } } return ans ; } public static void main ( String [ ] args ) { long X = 5 , K = 5 ; System . out . println ( KthSolution ( X , K ) ) ; } }
import java . io . * ; class GFG { static void findAnagram ( String s ) { String check = s ; int i = 0 , j = s . length ( ) - 1 ; while ( i < s . length ( ) && j >= 0 ) { if ( s . charAt ( i ) != s . charAt ( j ) && check . charAt ( i ) != s . charAt ( j ) && check . charAt ( j ) != s . charAt ( i ) ) { char temp = s . charAt ( i ) ; s = s . substring ( 0 , i ) + s . charAt ( j ) + s . substring ( i + 1 ) ; s = s . substring ( 0 , j ) + temp + s . substring ( j + 1 ) ; i ++ ; j = s . length ( ) - 1 ; } else { j -- ; } } if ( s . length ( ) % 2 != 0 ) { int mid = s . length ( ) / 2 ; if ( check . charAt ( mid ) == s . charAt ( mid ) ) { for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( check . charAt ( i ) != s . charAt ( mid ) && s . charAt ( i ) != s . charAt ( mid ) ) { char temp = s . charAt ( i ) ; s = s . substring ( 0 , i ) + s . charAt ( mid ) + s . substring ( i + 1 ) ; s = s . substring ( 0 , mid ) + temp + s . substring ( mid + 1 ) ; break ; } } } } boolean ok = true ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( check . charAt ( i ) == s . charAt ( i ) ) { ok = false ; break ; } } if ( ok ) System . out . println ( s ) ; else System . out . println ( - 1 ) ; } public static void main ( String [ ] args ) { String S = " geek " ; findAnagram ( S ) ; } }
class GFG { static void minTime ( String word ) { int ans = 0 ; int curr = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { int k = ( int ) word . charAt ( i ) - 97 ; int a = Math . abs ( curr - k ) ; int b = 26 - Math . abs ( curr - k ) ; ans += Math . min ( a , b ) ; ans ++ ; curr = ( int ) word . charAt ( i ) - 97 ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { String str = " zjpc " ; minTime ( str ) ; } }
import java . io . * ; class GFG { static void maximumSumArray ( int arr [ ] , int N ) { int [ ] arrA = new int [ ( N ) ] ; int [ ] ans = new int [ ( N ) ] ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arrA [ i ] = arr [ i ] ; for ( int i = 0 ; i < N ; i ++ ) { int [ ] arrB = new int [ ( N ) ] ; int maximum = arrA [ i ] ; arrB [ i ] = maximum ; for ( int j = i - 1 ; j >= 0 ; j -- ) { arrB [ j ] = Math . min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } maximum = arrA [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { arrB [ j ] = Math . min ( maximum , arrA [ j ] ) ; maximum = arrB [ j ] ; } int sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) sum += arrB [ j ] ; if ( sum > maxSum ) { maxSum = sum ; ans = arrB ; } } for ( int val : ans ) { System . out . print ( val + " ▁ " ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 10 , 6 , 8 } ; int N = A . length ; maximumSumArray ( A , N ) ; } }
import java . io . * ; class GFG { static String largestMerge ( String word1 , String word2 ) { String merge = " " ; while ( word1 . length ( ) != 0 || word2 . length ( ) != 0 ) { if ( word1 . compareTo ( word2 ) == 0 || ( word1 . compareTo ( word2 ) > 0 ) ) { merge = merge + word1 . charAt ( 0 ) ; word1 = word1 . substring ( 1 ) ; } else { merge = merge + word2 . charAt ( 0 ) ; word2 = word2 . substring ( 1 ) ; } } return merge ; } public static void main ( String [ ] args ) { String S1 = " xyzxyz " ; String S2 = " xywzxyx " ; System . out . println ( largestMerge ( S1 , S2 ) ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static void sumOfCombinationOf4OR5 ( int [ ] arr , int N ) { int [ ] ans = new int [ N ] ; Arrays . fill ( ans , - 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] < 4 ) { continue ; } int sum = Integer . MAX_VALUE ; int cnt = 0 ; for ( int j = 0 ; j <= arr [ i ] ; j += 4 ) { if ( ( arr [ i ] - j ) % 5 == 0 ) { sum = Math . min ( sum , cnt + ( arr [ i ] - j ) / 5 ) ; } cnt ++ ; } if ( sum != Integer . MAX_VALUE ) ans [ i ] = sum ; } for ( int num : ans ) System . out . printf ( num + " ▁ " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 7 , 15 , 17 , 22 } ; int N = arr . length ; sumOfCombinationOf4OR5 ( arr , N ) ; } }
class GFG { static String largestString ( String s , int k ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != ' z ' && k > 0 ) { s = s . replace ( s . charAt ( i ) , ' z ' ) ; k -- ; } } return s ; } public static void main ( String args [ ] ) { String s = " dbza " ; int k = 1 ; System . out . println ( largestString ( s , k ) ) ; } }
class GFG { static void RemoveOneChar ( String A , String B , int N , int M ) { int X = 0 ; int Y = N - 1 ; for ( int i = 0 ; i < M ; i ++ ) { if ( A . charAt ( X ) != B . charAt ( i ) ) break ; X ++ ; } for ( int i = M - 1 ; i >= 0 ; i -- ) { if ( A . charAt ( Y ) != B . charAt ( i ) ) break ; Y -- ; } if ( N - M == 1 && Y < X ) { System . out . println ( X - Y + 1 ) ; for ( int i = Y ; i <= X ; i ++ ) System . out . print ( i + 1 + " ▁ " ) ; System . out . println ( ) ; } else System . out . println ( - 1 ) ; } static public void main ( String [ ] args ) { String A = " abaac " ; String B = " abac " ; int N = A . length ( ) ; int M = B . length ( ) ; RemoveOneChar ( A , B , N , M ) ; } }
import java . io . * ; class GFG { static void countOfPairs ( int x , int y ) { int count = 0 ; for ( int k = 1 ; k * k <= x ; ++ k ) { count += Math . max ( 0 , Math . min ( y , x / k - 1 ) - k ) ; } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int x = 4 ; int y = 5 ; countOfPairs ( x , y ) ; } }
class GFG { public static void getDate ( int d , String m ) { int [ ] days = { 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; String [ ] month = { " January " , " February " , " March " , " April " , " May " , " June " , " July " , " August " , " September " , " October " , " November " , " December " } ; int cnt = 183 ; int cur_month = 0 ; for ( int i = 0 ; i < 12 ; i ++ ) if ( m == month [ i ] ) cur_month = i ; int cur_date = d ; while ( true ) { while ( cnt > 0 && cur_date <= days [ cur_month ] ) { cnt -= 1 ; cur_date += 1 ; } if ( cnt == 0 ) break ; cur_month = ( cur_month + 1 ) % 12 ; cur_date = 1 ; } System . out . println ( cur_date + " ▁ " + month [ cur_month ] ) ; } public static void main ( String args [ ] ) { int D = 15 ; String M = " January " ; getDate ( D , M ) ; } }
import java . lang . * ; class GFG { public static void printLastElement ( int arr [ ] , int N ) { boolean leftTurn = true ; int remainElements = N ; int step = 1 ; int head = 1 ; while ( remainElements > 1 ) { if ( leftTurn ) { head = head + step ; } else { if ( remainElements % 2 == 1 ) head = head + step ; } remainElements = remainElements / 2 ; step = step * 2 ; leftTurn = ! leftTurn ; } System . out . print ( arr [ head - 1 ] ) ; } public static void main ( String args [ ] ) { int [ ] arr = { 2 , 3 , 5 , 6 } ; int N = arr . length ; printLastElement ( arr , N ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static String freqCheck ( String S , int N ) { int hash [ ] = new int [ 26 ] ; for ( int i = 0 ; i < N ; i ++ ) { hash [ S . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hash [ i ] > 2 ) { return " Yes " ; } } return " No " ; } public static void main ( String [ ] args ) { String S = " geekseekforgeeks " ; int N = S . length ( ) ; System . out . println ( freqCheck ( S , N ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static void minsteps ( int [ ] A ) { int n = A . length ; int [ ] left = new int [ n ] ; Arrays . fill ( left , 0 ) ; int [ ] right = new int [ n ] ; Arrays . fill ( right , 0 ) ; int [ ] res = new int [ n ] ; Arrays . fill ( res , 0 ) ; int count = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { left [ i ] = left [ i - 1 ] + count ; count += A [ i ] ; } count = A [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] + count ; count += A [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { res [ i ] = left [ i ] + right [ i ] ; System . out . print ( res [ i ] + " ▁ " ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int [ ] A = { 1 , 0 , 1 , 0 } ; minsteps ( A ) ; } }
class GFG { static void minimumOperations ( int [ ] A , int K ) { int [ ] isflipped = new int [ A . length + 1 ] ; int ans = 0 ; for ( int i = 0 ; i < A . length ; i ++ ) { if ( i > 0 ) { isflipped [ i ] += isflipped [ i - 1 ] ; isflipped [ i ] %= 2 ; } if ( A [ i ] == 0 && isflipped [ i ] == 0 ) { if ( ( A . length - i + 1 ) <= K ) { System . out . println ( - 1 ) ; return ; } ans ++ ; isflipped [ i ] ++ ; isflipped [ i + K ] -- ; } else if ( A [ i ] == 1 && isflipped [ i ] != 0 ) { if ( ( A . length - i + 1 ) <= K ) { System . out . println ( - 1 ) ; return ; } ans ++ ; isflipped [ i ] ++ ; isflipped [ i + K ] -- ; } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 0 , 1 , 0 } ; int K = 1 ; minimumOperations ( arr , K ) ; } }
import java . util . * ; class GFG { static void ConvertArray ( int arr [ ] , int N ) { if ( N == 1 ) { System . out . println ( " Operation ▁ 1 ▁ : ▁ " + 1 + " ▁ " + 1 ) ; System . out . println ( " Added ▁ elements : ▁ " + - 1 * arr [ 0 ] ) ; System . out . println ( ) ; System . out . println ( " Operation ▁ 2 ▁ : ▁ " + 1 + " ▁ " + 1 ) ; System . out . println ( " Added ▁ elements : ▁ " + 1 * arr [ 0 ] ) ; System . out . println ( ) ; System . out . println ( " Operation ▁ 3 ▁ : ▁ " + 1 + " ▁ " + 1 ) ; System . out . println ( " Added ▁ elements : ▁ " + - 1 * arr [ 0 ] ) ; } else { System . out . println ( " Operation ▁ 1 ▁ : ▁ " + 1 + " ▁ " + N ) ; System . out . print ( " Added ▁ elements : ▁ " ) ; for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( - 1 * arr [ i ] * N + " ▁ " ) ; } System . out . println ( ) ; System . out . println ( ) ; System . out . println ( " Operation ▁ 2 ▁ : ▁ " + 1 + " ▁ " + ( N - 1 ) ) ; System . out . print ( " Added ▁ elements : ▁ " ) ; for ( int i = 0 ; i < N - 1 ; i ++ ) { System . out . print ( arr [ i ] * ( N - 1 ) + " ▁ " ) ; } System . out . println ( ) ; System . out . println ( ) ; System . out . println ( " Operation ▁ 3 ▁ : ▁ " + N + " ▁ " + N ) ; System . out . print ( " Added ▁ elements : ▁ " ) ; System . out . println ( arr [ N - 1 ] * ( N - 1 ) ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 2 , 4 } ; int N = arr . length ; ConvertArray ( arr , N ) ; } }
import java . util . * ; class GFG { static int MAX = 1000000 ; static void countOfPrimefactors ( int [ ] CountDistinct ) { boolean [ ] prime = new boolean [ MAX + 1 ] ; for ( int i = 0 ; i <= MAX ; i ++ ) { CountDistinct [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= MAX ; i ++ ) { if ( prime [ i ] == true ) { CountDistinct [ i ] = 1 ; for ( int j = i * 2 ; j <= MAX ; j += i ) { CountDistinct [ j ] ++ ; prime [ j ] = false ; } } } } static int CountEvenPair ( int A [ ] , int B [ ] , int N , int M ) { int [ ] countDistinct = new int [ ( MAX + 1 ) ] ; countOfPrimefactors ( countDistinct ) ; int evenCount = 0 ; int oddCount = 0 ; int evenPairs = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( countDistinct [ B [ i ] ] == 0 ) continue ; if ( ( countDistinct [ B [ i ] ] & 1 ) != 0 ) { oddCount ++ ; } else { evenCount ++ ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( countDistinct [ A [ i ] ] == 0 ) continue ; if ( ( countDistinct [ A [ i ] ] & 1 ) != 0 ) { evenPairs += ( evenCount ) ; } else { evenPairs += evenCount + oddCount ; } } return evenPairs ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 4 , 5 , 6 } ; int N = A . length ; int M = B . length ; System . out . println ( CountEvenPair ( A , B , N , M ) ) ; } }
import java . util . * ; class GFG { static int longestSubarray ( int [ ] arr , int N , int K ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( sum == K ) maxLen = i + 1 ; if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - K ) ) { if ( maxLen < ( i - um . get ( sum - K ) ) ) maxLen = i - um . get ( sum - K ) ; } } return maxLen ; } static void minRequiredOperation ( int [ ] arr , int N , int K ) { int TotalSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) TotalSum += arr [ i ] ; int maxLen = longestSubarray ( arr , N , TotalSum - K ) ; if ( maxLen == - 1 ) { System . out . println ( - 1 ) ; } else System . out . println ( N - maxLen ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 1 , 1 , 2 } ; int K = 4 ; int N = arr . length ; minRequiredOperation ( arr , N , K ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void countEvenOdd ( int L , int R ) { int range = R - L + 1 ; int even = ( range / 4 ) * 2 ; if ( ( L & 1 ) != 0 && ( range % 4 == 3 ) ) { even ++ ; } else if ( ( L & 1 ) == 0 && ( range % 4 != 0 ) ) { even ++ ; } System . out . print ( " Even ▁ = ▁ " + even + " , ▁ Odd ▁ = ▁ " + ( range - even ) ) ; } public static void main ( String [ ] args ) { int L = 2 , R = 7 ; countEvenOdd ( L , R ) ; } }
public class GFG { static int maximumCandy ( int [ ] candies , int [ ] safety , int N , int M ) { int total = 0 ; int ans = Integer . MAX_VALUE ; boolean all_safe = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( candies [ i ] + M > safety [ i ] ) { all_safe = false ; ans = Math . min ( ans , safety [ i ] ) ; } else { ans = Math . min ( ans , candies [ i ] + M ) ; } total += candies [ i ] ; } if ( all_safe ) return total ; else return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 5 , 2 , 3 } ; int B [ ] = { 8 , 13 , 6 , 4 } ; int M = 5 ; int N = A . length ; System . out . println ( maximumCandy ( A , B , N , M ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void construct_Array ( int N , int K ) { for ( int i = 1 ; i <= N ; i ++ ) { System . out . print ( K * i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 3 , K = 3 ; construct_Array ( N , K ) ; } }
import java . io . * ; class GFG { static void Print ( int N ) { if ( ( N / 2 ) % 2 == 1 || ( N % 2 == 1 ) ) { System . out . print ( - 1 ) ; return ; } int CurEven = 2 , CurOdd = 1 ; int SumOdd = 0 , SumEven = 0 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { System . out . print ( CurEven + " ▁ " ) ; SumEven += CurEven ; CurEven += 2 ; } for ( int i = 0 ; i < N / 2 - 1 ; i ++ ) { System . out . print ( CurOdd + " ▁ " ) ; SumOdd += CurOdd ; CurOdd += 2 ; } CurOdd = SumEven - SumOdd ; System . out . println ( CurOdd ) ; } public static void main ( String [ ] args ) { int N = 12 ; Print ( N ) ; } }
import java . util . * ; class GFG { static int MinimumMoves ( int A [ ] , int B [ ] , int N ) { int totalOperations = 0 ; int carry = 0 ; int K = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { int nearestMultiple = ( int ) ( Math . ceil ( ( double ) ( A [ i ] + carry ) / ( double ) ( B [ i ] ) ) * B [ i ] ) ; K = nearestMultiple - ( A [ i ] + carry ) ; totalOperations += K ; carry += K ; } return totalOperations ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 4 , 5 , 2 , 5 , 5 , 9 } ; int B [ ] = { 1 , 1 , 9 , 6 , 3 , 8 , 7 } ; int N = A . length ; System . out . print ( MinimumMoves ( A , B , N ) + "NEW_LINE"); } }
import java . io . * ; import java . util . * ; class GFG { static void minimumDeviation ( int A [ ] , int N ) { TreeSet < Integer > s = new TreeSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) s . add ( A [ i ] ) ; else s . add ( 2 * A [ i ] ) ; } int diff = s . last ( ) - s . first ( ) ; while ( ( s . last ( ) % 2 == 0 ) ) { int maxEl = s . last ( ) ; s . remove ( maxEl ) ; s . add ( maxEl / 2 ) ; diff = Math . min ( diff , s . last ( ) - s . first ( ) ) ; } System . out . print ( diff ) ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 1 , 5 , 20 , 3 } ; int N = A . length ; minimumDeviation ( A , N ) ; } }
class GFG { public static void FindwinnerOfGame ( String S ) { int cntZero = 0 ; int cntConOne = 0 ; int nimSum = 0 ; int N = S . length ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == '1' ) { cntConOne += 1 ; } else { nimSum ^= cntConOne ; cntConOne = 0 ; cntZero ++ ; } } nimSum ^= cntConOne ; if ( cntZero % 2 == 0 ) { System . out . print ( " Tie " ) ; } else if ( nimSum != 0 ) { System . out . print ( " player ▁ 1" ) ; } else { System . out . print ( " player ▁ 2" ) ; } } public static void main ( String [ ] args ) { String S = "0110011" ; FindwinnerOfGame ( S ) ; } }
import java . util . * ; class GFG { static int minMoves ( int [ ] arr ) { int N = arr . length ; if ( N <= 2 ) return 0 ; int ans = Integer . MAX_VALUE ; for ( int i = - 1 ; i <= 1 ; i ++ ) { for ( int j = - 1 ; j <= 1 ; j ++ ) { int num1 = arr [ 0 ] + i ; int num2 = arr [ 1 ] + j ; int flag = 1 ; int moves = Math . abs ( i ) + Math . abs ( j ) ; for ( int idx = 2 ; idx < N ; idx ++ ) { int num = num1 + num2 ; if ( Math . abs ( arr [ idx ] - num ) > 1 ) flag = 0 ; else moves += Math . abs ( arr [ idx ] - num ) ; num1 = num2 ; num2 = num ; } if ( flag > 0 ) ans = Math . min ( ans , moves ) ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 4 , 8 , 9 , 17 , 27 } ; System . out . print ( minMoves ( arr ) ) ; } }
import java . util . * ; class GFG { static void maxksum ( int L , int R , int K ) { int N = ( R / 10 - L / 10 ) + 1 ; if ( K > N ) { System . out . print ( " - 1" ) ; return ; } R = R / 10 ; int X = R - K ; int sum = 10 * ( ( R * ( R + 1 ) ) / 2 - ( X * ( X + 1 ) ) / 2 ) ; System . out . print ( sum ) ; } public static void main ( String [ ] args ) { int L = 16 , R = 60 , K = 4 ; maxksum ( L , R , K ) ; } }
import java . util . * ; class GFG { static int findLongestNonDecreasing ( int A [ ] , int N ) { int res = 0 ; int start = 0 ; int end = N - 1 ; int prev = - 1 ; while ( start <= end ) { if ( A [ start ] <= A [ end ] ) { if ( prev == - 1 ) { prev = A [ start ] ; res ++ ; start ++ ; } else { if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else { break ; } } } else { if ( prev == - 1 ) { prev = A [ end ] ; res ++ ; end -- ; } else { if ( A [ end ] >= prev ) { res ++ ; prev = A [ end ] ; end -- ; } else if ( A [ start ] >= prev ) { res ++ ; prev = A [ start ] ; start ++ ; } else { break ; } } } } return res ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 1 , 3 , 5 , 4 , 3 , 6 , 2 , 1 } ; int N = A . length ; System . out . print ( findLongestNonDecreasing ( A , N ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static void findPairs ( int N ) { for ( int i = 0 ; i <= N ; i ++ ) { System . out . print ( " ( " + i + " , ▁ " + ( N - i ) + " ) , ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 5 ; findPairs ( N ) ; } }
class GFG { public static int MinOperation ( int arr [ ] , int N , int K ) { int cntOpe = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( K > arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 2 ; } else { cntOpe += 1 ; } } else if ( K < arr [ i ] ) { if ( ( K - arr [ i ] ) % 2 == 0 ) { cntOpe += 1 ; } else { cntOpe += 2 ; } } } return cntOpe ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 7 , 2 , 1 , 3 } ; int K = 5 ; int N = arr . length ; System . out . println ( MinOperation ( arr , N , K ) ) ; } }
import java . io . * ; class GFG { static int clstNum ( int N ) { return ( N - 1 ) ; } public static void main ( String [ ] args ) { int N = 11 ; System . out . println ( clstNum ( N ) ) ; } }
import java . util . * ; class GFG { static double pairProductMean ( int arr [ ] , int N ) { Vector < Integer > pairArray = new Vector < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int pairProduct = arr [ i ] * arr [ j ] ; pairArray . add ( pairProduct ) ; } } int length = pairArray . size ( ) ; float sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) sum += pairArray . get ( i ) ; float mean ; if ( length != 0 ) mean = sum / length ; else mean = 0 ; return mean ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = arr . length ; System . out . format ( " % .2f " , pairProductMean ( arr , N ) ) ; } }
import java . io . * ; class GFG { static int minProd ( int X , int Y , int N ) { if ( X <= Y ) { if ( N < X ) return ( X - N ) * Y ; else { return Math . max ( Y - ( N - X + 1 ) , 1 ) ; } } if ( Y >= N ) return ( Y - N ) * X ; return Math . max ( X - ( N - Y + 1 ) , 1 ) ; } public static void main ( String [ ] args ) { int X = 47 , Y = 42 , N = 167 ; System . out . println ( minProd ( X , Y , N ) ) ; } }
class GFG { static void factorsOf3 ( int arr [ ] , int N ) { int a = 0 , b = 0 , c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 3 == 0 ) a ++ ; else if ( arr [ i ] % 3 == 1 ) b ++ ; else if ( arr [ i ] % 3 == 2 ) c ++ ; } if ( a >= 1 && a <= b + c + 1 ) System . out . print ( " Yes " + "NEW_LINE"); else if ( a == 0 && b == 0 && c > 0 ) System . out . print ( " Yes " + "NEW_LINE"); else if ( a == 0 && c == 0 && b > 0 ) System . out . print ( " Yes " + "NEW_LINE"); else System . out . print ( " No " + "NEW_LINE"); } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 3 } ; int N = arr . length ; factorsOf3 ( arr , N ) ; } }
import java . util . * ; class GFG { static int maxBottles ( int n , int e ) { int s = 0 , b = 0 ; int a = n ; while ( a != 0 ) { s = s + a ; a = ( a + b ) / e ; b = n - ( a * e ) ; n = a + b ; } return s ; } public static void main ( String [ ] args ) { int n = 9 , e = 3 ; int s = maxBottles ( n , e ) ; System . out . print ( s + "NEW_LINE"); } }
class GFG { static int power ( int x , int n ) { int temp ; if ( n == 0 ) return 1 ; temp = power ( x , n / 2 ) ; if ( n % 2 == 0 ) return temp * temp ; else return x * temp * temp ; } static int count_Total_Numbers ( int n , int x ) { int total , multiples = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i % x == 0 ) multiples ++ ; } if ( n == 1 ) return multiples ; total = ( multiples - 1 ) * power ( multiples , n - 1 ) ; return total ; } public static void main ( String [ ] args ) { int N = 1 , X = 3 ; System . out . printf ( " % d ▁ " , count_Total_Numbers ( N , X ) ) ; } }
class GFG { static int minLength ( int A [ ] , int N ) { int elem = A [ 0 ] , count = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] == elem ) { count ++ ; } else { break ; } } if ( count == N ) return N ; else return 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 3 , 1 } ; int N = arr . length ; System . out . print ( minLength ( arr , N ) + "NEW_LINE"); } }
import java . util . * ; class GFG { static int minSubarrays ( int arr [ ] , int n ) { int right = n - 1 ; int left = 0 ; int subarrays = 0 ; while ( right >= 0 ) { for ( left = 0 ; left <= right ; left += 1 ) { if ( __gcd ( arr [ left ] , arr [ right ] ) > 1 ) { subarrays += 1 ; right = left - 1 ; break ; } if ( left == right && __gcd ( arr [ left ] , arr [ right ] ) == 1 ) { return 0 ; } } } return subarrays ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int N = 6 ; int arr [ ] = { 2 , 3 , 4 , 4 , 4 , 3 } ; System . out . print ( minSubarrays ( arr , N ) ) ; } }
import java . util . * ; class GFG { static void printMissingElements ( int arr [ ] , int N ) { int diff = arr [ 0 ] - 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] - i != diff ) { while ( diff < arr [ i ] - i ) { System . out . print ( ( i + diff ) + " ▁ " ) ; diff ++ ; } } } } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 10 , 11 , 13 } ; int N = arr . length ; printMissingElements ( arr , N ) ; } }
import java . util . * ; class GFG { static void printMissingElements ( int arr [ ] , int N ) { int [ ] b = new int [ arr [ N - 1 ] + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int i = arr [ 0 ] ; i <= arr [ N - 1 ] ; i ++ ) { if ( b [ i ] == 0 ) { System . out . print ( i + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 10 , 11 , 13 } ; int N = arr . length ; printMissingElements ( arr , N ) ; } }
import java . util . * ; class GFG { static int mod = ( int ) 1e9 + 7 ; static int power ( int x , int y ) { if ( y == 0 ) return 1 ; int p = power ( x , y / 2 ) % mod ; p = ( p * p ) % mod ; if ( ( y & 1 ) != 0 ) p = ( x * p ) % mod ; return p ; } static int NumberOfTrees ( int arr [ ] , int N ) { int maxElement = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int [ ] level = new int [ maxElement + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { level [ arr [ i ] ] ++ ; } if ( arr [ 0 ] != 0 level [ 0 ] != 1 ) { return 0 ; } int ans = 1 ; for ( int i = 0 ; i < maxElement ; i ++ ) { ans = ( ans * power ( level [ i ] , level [ i + 1 ] ) ) % mod ; } return ans ; } public static void main ( String [ ] args ) { int N = 7 ; int arr [ ] = { 0 , 3 , 2 , 1 , 2 , 2 , 1 } ; System . out . print ( NumberOfTrees ( arr , N ) ) ; } }
class GFG { static int carryCount ( int num1 , int num2 ) { int count = 0 ; while ( num2 != 0 ) { int carry = num1 & num2 ; num1 = num1 ^ num2 ; num2 = carry << 1 ; count += Integer . bitCount ( num2 ) ; } return count ; } public static void main ( String [ ] args ) { int A = 15 , B = 10 ; System . out . print ( carryCount ( A , B ) ) ; } }
import java . util . * ; class GFG { static void calculateProfit ( int n , int [ ] earnings , int [ ] cost , int e ) { int profit = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int earning_per_day = 0 ; int daily_spent_food = 0 ; if ( i == ( n - 1 ) ) { earning_per_day = earnings [ i ] * e ; profit = profit + earning_per_day ; break ; } if ( cost [ i ] < earnings [ i ] ) { earning_per_day = earnings [ i ] * e ; daily_spent_food = cost [ i ] * e ; profit = profit + earning_per_day - daily_spent_food ; } } System . out . print ( profit + "NEW_LINE"); } public static void main ( String [ ] args ) { int n = 4 ; int earnings [ ] = { 1 , 8 , 6 , 7 } ; int cost [ ] = { 1 , 3 , 4 , 1 } ; int e = 5 ; calculateProfit ( n , earnings , cost , e ) ; } }
import java . util . * ; class GFG { static void findPair ( int A , int B , int N ) { int X , Y ; X = N - B + A ; if ( X % 2 != 0 ) { System . out . print ( " - 1" ) ; } else { X = X / 2 ; Y = N - X ; System . out . print ( X + " ▁ " + Y ) ; } } public static void main ( String [ ] args ) { int A = 1 ; int B = 3 ; int N = 4 ; findPair ( A , B , N ) ; } }
import java . util . * ; class GFG { static boolean check ( int a [ ] , int n ) { int ma = a [ 1 ] - a [ 0 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] > a [ i - 1 ] && a [ i + 1 ] < a [ i ] ) || ( a [ i ] < a [ i - 1 ] && a [ i + 1 ] > a [ i ] ) ) ma = Math . max ( ma , Math . abs ( a [ i ] - a [ i + 1 ] ) ) ; else return false ; } System . out . print ( " Amplitude ▁ = ▁ " + ma ) ; System . out . println ( ) ; return true ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 5 , 0 , 7 , - 6 } ; int n = a . length ; int wave = ( n - 1 ) / 2 ; if ( check ( a , n ) ) System . out . print ( " Waves ▁ = ▁ " + wave ) ; else System . out . print ( " - 1" ) ; } }
class GFG { static String ConstructBinaryString ( int N , int M , int K ) { if ( M < ( N - 1 ) || M > K * ( N + 1 ) ) return " - 1" ; String ans = " " ; int l = Math . min ( K , M / ( N - 1 ) ) ; int temp = N ; while ( temp != 0 ) { temp -- ; ans += '0' ; if ( temp == 0 ) break ; for ( int i = 0 ; i < l ; i ++ ) { ans += '1' ; } } M -= ( N - 1 ) * l ; if ( M == 0 ) return ans ; l = Math . min ( M , K ) ; for ( int i = 0 ; i < l ; i ++ ) ans += '1' ; M -= l ; while ( M > 0 ) { ans = '1' + ans ; M -- ; } return ans ; } public static void main ( String [ ] args ) { int N = 5 , M = 9 , K = 2 ; System . out . println ( ConstructBinaryString ( N , M , K ) ) ; } }
import java . util . * ; class GFG { static int noOfFactors ( int N ) { if ( N == 1 ) return 1 ; int count = 0 ; int ans = 1 ; while ( N % 2 == 0 ) { count ++ ; N = N / 2 ; } ans *= ( count / 2 + 1 ) ; for ( int i = 3 ; i * i <= N ; i = i + 2 ) { count = 0 ; while ( N % i == 0 ) { count ++ ; N = N / i ; } ans *= ( count / 2 + 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int N = 100 ; System . out . print ( noOfFactors ( N ) ) ; } }
import java . io . * ; class GFG { static void print_path ( int N , int jump , int coin ) { if ( jump > coin || jump * ( N - 1 ) < coin ) { System . out . println ( " - 1" ) ; } else { int pos = 1 ; while ( jump > 0 ) { int tmp = Math . min ( N - 1 , coin - ( jump - 1 ) ) ; if ( pos + tmp <= N ) { pos += tmp ; } else { pos -= tmp ; } System . out . print ( pos + " ▁ " ) ; ; coin -= tmp ; jump -= 1 ; } } } public static void main ( String [ ] args ) { int N = 5 , K = 4 , M = 12 ; print_path ( N , K , M ) ; } }
import java . io . * ; class GFG { static int minChanges ( String str , int N ) { int res ; int count0 = 0 , count1 = 0 ; for ( char x : str . toCharArray ( ) ) { if ( x == '0' ) count0 ++ ; } res = count0 ; for ( char x : str . toCharArray ( ) ) { if ( x == '0' ) count0 -- ; if ( x == '1' ) count1 ++ ; res = Math . min ( res , count1 + count0 ) ; } return res ; } public static void main ( String [ ] args ) { int N = 9 ; String str = "000101001" ; System . out . println ( minChanges ( str , N ) ) ; } }
import java . util . Scanner ; import java . util . Arrays ; class GFG { public static int count_triangles ( int a , int b , int c , int d ) { int ans = 0 ; for ( int x = a ; x <= b ; ++ x ) { int num_greater_than_d = Math . max ( d , c + x ) - Math . max ( d , b + x - 1 ) ; ans += num_greater_than_d * ( d - c + 1 ) ; int r = Math . min ( Math . max ( c , c + x ) , d ) - c ; int l = Math . min ( Math . max ( c , b + x - 1 ) , d ) - c ; int x1 = ( r * ( r + 1 ) ) / 2 ; int x2 = ( l * ( l + 1 ) ) / 2 ; ans += x1 - x2 ; } return ans ; } public static void main ( String args [ ] ) { int a = 2 , b = 3 , c = 4 , d = 5 ; System . out . println ( count_triangles ( a , b , c , d ) ) ; } }
class GFG { static void printKParts ( int N , int K ) { if ( N % K == 0 ) { for ( int i = 1 ; i < K ; i ++ ) System . out . print ( "1 , ▁ " ) ; System . out . print ( N - ( K - 1 ) + "NEW_LINE"); } else { if ( K == 2 ) { System . out . print ( " Not ▁ Possible " + "NEW_LINE"); return ; } for ( int i = 1 ; i < K - 1 ; i ++ ) System . out . print ( 1 + " , ▁ " ) ; System . out . print ( 2 + " , ▁ " + ( N - K ) + "NEW_LINE"); } } public static void main ( String [ ] args ) { int N = 18 , K = 5 ; printKParts ( N , K ) ; } }
import java . util . * ; class GFG { static int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = i + 1 ; j <= N ; j ++ ) { if ( i * j % ( i + j ) == 0 ) max_sum = Math . max ( max_sum , i + j ) ; } } return max_sum ; } public static void main ( String [ ] args ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; System . out . print ( max_sum ) ; } }
import java . util . * ; class GFG { static long getPairs ( Vector < Integer > A , Vector < Integer > B , int n ) { int [ ] D = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { D [ i ] = A . get ( i ) - B . get ( i ) ; } Arrays . sort ( D ) ; long total = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( D [ i ] > 0 ) { total += n - i - 1 ; } else { int k = upper_bound ( D , 0 , D . length , - D [ i ] ) ; total += n - k ; } } return total ; } static int upper_bound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( a [ middle ] > element ) high = middle ; else low = middle + 1 ; } return low ; } public static void main ( String [ ] args ) { int n = 5 ; Vector < Integer > A = new Vector < Integer > ( ) ; Vector < Integer > B = new Vector < Integer > ( ) ; A . add ( 4 ) ; A . add ( 8 ) ; A . add ( 2 ) ; A . add ( 6 ) ; A . add ( 2 ) ; B . add ( 4 ) ; B . add ( 5 ) ; B . add ( 4 ) ; B . add ( 1 ) ; B . add ( 3 ) ; System . out . print ( getPairs ( A , B , n ) ) ; } }
import java . util . * ; class GFG { static int [ ] fact = new int [ 14 ] ; static int size = 1 ; static void preCompute ( int N ) { fact [ 0 ] = 1 ; for ( int i = 1 ; fact [ i - 1 ] <= N ; i ++ ) { fact [ i ] = ( fact [ i - 1 ] * i ) ; size ++ ; } } static void findMin ( int N ) { preCompute ( N ) ; int originalN = N ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = size - 1 ; i >= 0 ; i -- ) { while ( N >= fact [ i ] ) { N -= fact [ i ] ; ans . add ( fact [ i ] ) ; } } System . out . print ( ans . size ( ) + "NEW_LINE"); for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 27 ; findMin ( n ) ; } }
class GFG { static int k_sum ( int a [ ] , int n , int k ) { int r = 0 , sum = 0 ; int ans = 0 ; for ( int l = 0 ; l < n ; l ++ ) { while ( sum < k ) { if ( r == n ) break ; else { sum += a [ r ] ; r ++ ; } } if ( sum < k ) break ; ans += n - r + 1 ; sum -= a [ l ] ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 6 , 1 , 2 , 7 } , k = 10 ; int n = a . length ; System . out . println ( k_sum ( a , n , k ) ) ; } }
class GFG { static int maxSum ( int arr1 [ ] , int arr2 [ ] , int n ) { int initialParity = 0 , finalParity = 0 ; int sum = 0 , minPositive = Integer . MAX_VALUE , maxNegative = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { initialParity += arr2 [ i ] ; if ( arr1 [ i ] >= 0 ) { finalParity += 1 ; sum += arr1 [ i ] ; minPositive = Math . min ( minPositive , arr1 [ i ] ) ; } else { maxNegative = Math . max ( maxNegative , arr1 [ i ] ) ; } } if ( initialParity % 2 == finalParity % 2 ) { return sum ; } else { if ( minPositive + maxNegative >= 0 ) { return sum + maxNegative ; } else { return sum - minPositive ; } } } public static void main ( String [ ] args ) { int arr1 [ ] = { 2 , - 4 , 5 , 3 } ; int arr2 [ ] = { 0 , 1 , 0 , 1 } ; int n = arr1 . length ; System . out . println ( maxSum ( arr1 , arr2 , n ) ) ; } }
import java . util . * ; class GFG { static int minCapacity ( int enter [ ] , int exit [ ] , int n ) { int minCap = 0 ; int currCap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currCap = currCap + enter [ i ] - exit [ i ] ; minCap = Math . max ( minCap , currCap ) ; } return minCap ; } public static void main ( String [ ] args ) { int enter [ ] = { 3 , 5 , 2 , 0 } ; int exit [ ] = { 0 , 2 , 4 , 4 } ; int n = enter . length ; System . out . println ( minCapacity ( enter , exit , n ) ) ; } }
import java . util . * ; class GFG { static int getMin ( int arr [ ] , int n ) { int minVal = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; return minVal ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 1 , 6 , 9 } ; int n = arr . length ; System . out . println ( getMin ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int longestSubarray ( int arr [ ] , int n ) { int maxMean = 0 ; for ( int i = 1 ; i < n ; i ++ ) maxMean = Math . max ( maxMean , ( arr [ i ] + arr [ i - 1 ] ) / 2 ) ; int ans = 0 ; int subarrayLength = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= maxMean ) ans = Math . max ( ans , ++ subarrayLength ) ; else subarrayLength = 0 ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 3 , 3 , 2 , 1 , 4 } ; int n = arr . length ; System . out . println ( longestSubarray ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int MAX = 24 ; static int countOp ( int x ) { int arr [ ] = new int [ MAX ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) arr [ i ] = arr [ i - 1 ] * 2 ; int temp = x ; boolean flag = true ; int ans = 0 ; int operations = 0 ; boolean flag2 = false ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( arr [ i ] - 1 == x ) flag2 = true ; if ( arr [ i ] > x ) { ans = i ; break ; } } if ( flag2 ) return 0 ; while ( flag ) { if ( arr [ ans ] < x ) ans ++ ; operations ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { int take = x ^ ( arr [ i ] - 1 ) ; if ( take <= arr [ ans ] - 1 ) { if ( take > temp ) temp = take ; } } if ( temp == arr [ ans ] - 1 ) { flag = false ; break ; } temp ++ ; operations ++ ; x = temp ; if ( x == arr [ ans ] - 1 ) flag = false ; } return operations ; } public static void main ( String [ ] args ) { int x = 39 ; System . out . println ( countOp ( x ) ) ; } }
import java . util . * ; class GFG { static int maxCoins ( int X , int Y ) { if ( X < Y ) { swap ( X , Y ) ; } int coins = X ; X -- ; coins += Math . max ( X , Y ) ; return coins ; } static void swap ( int X , int Y ) { int temp = X ; X = Y ; Y = temp ; } public static void main ( String [ ] args ) { int X = 7 , Y = 5 ; System . out . println ( maxCoins ( X , Y ) ) ; } }
class GFG { static void printArray ( int N , int [ ] arr ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } static void replacedArray ( int N , int [ ] arr ) { int pos_sum , neg_sum , i , j , diff ; for ( i = 0 ; i < N ; i ++ ) { pos_sum = 0 ; neg_sum = 0 ; for ( j = i + 1 ; j < N ; j ++ ) { if ( arr [ j ] > 0 ) pos_sum += arr [ j ] ; else neg_sum += arr [ j ] ; } diff = Math . abs ( pos_sum ) - Math . abs ( neg_sum ) ; arr [ i ] = Math . abs ( diff ) ; } } public static void main ( String args [ ] ) { int N = 5 ; int [ ] arr = { 1 , - 1 , 2 , 3 , - 2 } ; replacedArray ( N , arr ) ; printArray ( N , arr ) ; N = 6 ; int [ ] arr1 = { - 3 , - 4 , - 2 , 5 , 1 , - 2 } ; replacedArray ( N , arr1 ) ; printArray ( N , arr1 ) ; } }
import java . util . Arrays ; class GFG { static long max ( long a , long b ) { if ( a > b ) return a ; else return b ; } static long smallestSide ( long a [ ] ) { Arrays . sort ( a ) ; long side1 , side2 , side3 , side4 , side11 , side12 , sideOfSquare ; side1 = a [ 0 ] + a [ 3 ] ; side2 = a [ 1 ] + a [ 2 ] ; side3 = a [ 0 ] + a [ 1 ] ; side4 = a [ 2 ] + a [ 3 ] ; side11 = max ( side1 , side2 ) ; side12 = max ( side3 , side4 ) ; sideOfSquare = max ( side11 , side12 ) ; return sideOfSquare ; } public static void main ( String [ ] args ) { long side [ ] = new long [ 4 ] ; System . out . println ( " Test ▁ Case ▁ 1" ) ; side [ 0 ] = 2 ; side [ 1 ] = 2 ; side [ 2 ] = 2 ; side [ 3 ] = 2 ; System . out . println ( smallestSide ( side ) ) ; System . out . println ( " Test Case 2 "); side [ 0 ] = 100000000000000L ; side [ 1 ] = 123450000000000L ; side [ 2 ] = 987650000000000L ; side [ 3 ] = 987654321000000L ; System . out . println ( smallestSide ( side ) ) ; } }
import java . io . * ; class GFG { static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } static int maxSum ( int a [ ] , int n ) { int S = 0 ; int S1 = maxSubArraySum ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; } public static void main ( String [ ] args ) { int a [ ] = { - 35 , 32 , - 24 , 0 , 27 , - 10 , 0 , - 19 } ; int n = a . length ; System . out . println ( maxSum ( a , n ) ) ; } }
import java . util . * ; class GFG { static int n = 3 ; static int m = 4 ; static int maxMatrixScore ( int A [ ] [ ] , int K ) { HashMap < Integer , Integer > update = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] [ 0 ] == 0 ) { int ans = 0 ; for ( int j = 1 ; j < m ; ++ j ) ans = ( int ) ( ans + A [ i ] [ j ] * Math . pow ( 2 , m - j - 1 ) ) ; update . put ( ans , i ) ; } } for ( Map . Entry < Integer , Integer > it : update . entrySet ( ) ) if ( K > 0 ) { int idx = it . getValue ( ) ; for ( int j = 0 ; j < m ; ++ j ) A [ idx ] [ j ] = ( A [ idx ] [ j ] + 1 ) % 2 ; K -- ; } int ans = 0 ; for ( int j = 0 ; j < m ; ++ j ) { int zero = 0 , one = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] [ j ] == 0 ) zero ++ ; else one ++ ; } if ( K > 0 && zero > one ) { ans += zero * Math . pow ( 2 , m - j - 1 ) ; K -- ; } else ans += one * Math . pow ( 2 , m - j - 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 0 , 0 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 0 } } ; int K = 2 ; System . out . print ( maxMatrixScore ( A , K ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static int maximizeAnd ( int i , int mask , int A [ ] , int B [ ] , int N , int [ ] [ ] dp ) { if ( i == N ) return 0 ; if ( dp [ i ] [ mask ] != - 1 ) return dp [ i ] [ mask ] ; for ( int j = 0 ; j < N ; ++ j ) { if ( ( mask & ( 1 << j ) ) == 0 ) { dp [ i ] [ mask ] = Math . max ( dp [ i ] [ mask ] , ( A [ i ] & B [ j ] ) + maximizeAnd ( i + 1 , mask | ( 1 << j ) , A , B , N , dp ) ) ; } } return dp [ i ] [ mask ] ; } static int maximizeAndUtil ( int A [ ] , int B [ ] , int N ) { int dp [ ] [ ] = new int [ N ] [ ( 1 << N ) + 1 ] ; for ( int dd [ ] : dp ) Arrays . fill ( dd , - 1 ) ; return maximizeAnd ( 0 , 0 , A , B , N , dp ) ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 5 , 7 , 11 } ; int B [ ] = { 2 , 6 , 10 , 12 } ; int N = A . length ; System . out . print ( maximizeAndUtil ( A , B , N ) ) ; } }
import java . util . * ; class GFG { static int mn = - 2147483648 ; static int lisOtimised ( String s ) { int [ ] dp = new int [ 30 ] ; Arrays . fill ( dp , 0 ) ; int N = s . length ( ) ; int lis = mn ; for ( int i = 0 ; i < N ; i ++ ) { int val = ( int ) s . charAt ( i ) - 97 ; int curr = 0 ; for ( int j = 0 ; j < val ; j ++ ) { curr = Math . max ( curr , dp [ j ] ) ; } curr ++ ; lis = Math . max ( lis , curr ) ; dp [ val ] = Math . max ( dp [ val ] , curr ) ; } return lis ; } public static void main ( String [ ] args ) { String s = " fdryutiaghfse " ; System . out . print ( lisOtimised ( s ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int MAX = ( int ) ( 1e9 ) ; static int MinimumLength ( int A [ ] , int N , int K ) { Arrays . sort ( A ) ; int suffix [ ] = new int [ N + 1 ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) suffix [ i ] = suffix [ i + 1 ] + A [ i ] ; int dp [ ] [ ] = new int [ N + 1 ] [ K + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= K ; j ++ ) dp [ i ] [ j ] = MAX ; dp [ N ] [ 0 ] = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = K ; j >= 0 ; j -- ) { if ( j <= A [ i ] ) { dp [ i ] [ j ] = A [ i ] ; continue ; } if ( dp [ i + 1 ] [ j - A [ i ] ] == MAX ) dp [ i ] [ j ] = MAX ; else dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ j ] , dp [ i + 1 ] [ j - A [ i ] ] + A [ i ] ) ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( suffix [ i ] - dp [ i ] [ K ] >= K ) { return N - i ; } } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 4 , 5 , 6 , 8 } ; int K = 13 ; int N = arr . length ; System . out . println ( MinimumLength ( arr , N , K ) ) ; } }
class GFG { static float [ ] [ ] dp = new float [ 105 ] [ 605 ] ; static float find ( int N , int sum ) { if ( N < 0 sum < 0 ) return 0 ; if ( dp [ N ] [ sum ] > 0 ) return dp [ N ] [ sum ] ; if ( sum > 6 * N sum < N ) return 0 ; if ( N == 1 ) { if ( sum >= 1 && sum <= 6 ) return ( float ) ( 1.0 / 6 ) ; else return 0 ; } for ( int i = 1 ; i <= 6 ; i ++ ) dp [ N ] [ sum ] = dp [ N ] [ sum ] + find ( N - 1 , sum - i ) / 6 ; return dp [ N ] [ sum ] ; } public static void main ( String [ ] args ) { int N = 4 , a = 13 , b = 17 ; float probability = 0.0f ; for ( int sum = a ; sum <= b ; sum ++ ) probability = probability + find ( N , sum ) ; System . out . printf ( " % .6f " , probability ) ; } }
import java . util . * ; class GFG { static double findMedXOR ( int mat [ ] [ ] , int N , int M ) { int dp [ ] [ ] = new int [ N ] [ M ] ; int med [ ] = new int [ N * M ] ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; med [ 0 ] = dp [ 0 ] [ 0 ] ; int len = 1 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ^ mat [ i ] [ 0 ] ; med [ len ++ ] = dp [ i ] [ 0 ] ; } for ( int i = 1 ; i < M ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ^ mat [ 0 ] [ i ] ; med [ len ++ ] = dp [ 0 ] [ i ] ; } for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ^ dp [ i ] [ j - 1 ] ^ dp [ i - 1 ] [ j - 1 ] ^ mat [ i ] [ j ] ; med [ len ++ ] = dp [ i ] [ j ] ; } } Arrays . sort ( med ) ; if ( len % 2 == 0 ) { return ( med [ ( len / 2 ) ] + med [ ( len / 2 ) - 1 ] ) / 2.0 ; } return med [ len / 2 ] ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 } , { 2 , 3 } } ; int N = mat . length ; int M = 2 ; System . out . println ( findMedXOR ( mat , N , M ) ) ; } }
import java . util . * ; class GFG { static HashMap < String , Integer > dp = new HashMap < String , Integer > ( ) ; static int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { String s = String . valueOf ( sm1 ) + " _ " + String . valueOf ( sm2 ) + String . valueOf ( j ) ; if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } if ( dp . containsKey ( s ) ) return dp . get ( s ) ; else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; dp . put ( s , Math . max ( Math . max ( l , m ) , r ) ) ; return dp . get ( s ) ; } } static void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . length ; checkEqualSum ( arr , N ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static void manipulation ( int [ ] [ ] matrix , int [ ] q ) { int x1 = q [ 0 ] , y1 = q [ 1 ] , x2 = q [ 2 ] , y2 = q [ 3 ] ; for ( int i = x1 - 1 ; i < x2 ; i ++ ) { for ( int j = y1 - 1 ; j < y2 ; j ++ ) { if ( matrix [ i ] [ j ] == 1 ) matrix [ i ] [ j ] = 0 ; else matrix [ i ] [ j ] = 1 ; } } } static void queries_fxn ( int [ ] [ ] matrix , int [ ] [ ] queries ) { for ( int [ ] q : queries ) manipulation ( matrix , q ) ; } public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 0 , 1 , 0 } , { 1 , 1 , 0 } } ; int [ ] [ ] queries = { { 1 , 1 , 2 , 3 } , { 1 , 1 , 1 , 1 } , { 1 , 2 , 2 , 3 } } ; queries_fxn ( matrix , queries ) ; System . out . print ( " [ " ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { System . out . print ( " [ " ) ; for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ) System . out . print ( matrix [ i ] [ j ] + " ▁ " ) ; if ( i == matrix . length - 1 ) System . out . print ( " ] " ) ; else System . out . print ( " ] , ▁ " ) ; } System . out . print ( " ] " ) ; } }
import java . util . * ; class GFG { static long [ ] fib = new long [ 101 ] ; static long [ ] dp1 = new long [ 101 ] ; static long [ ] dp2 = new long [ 101 ] ; static long [ ] v = new long [ 101 ] ; static void fibonacci ( ) { fib [ 1 ] = 1 ; fib [ 2 ] = 2 ; for ( int i = 3 ; i <= 87 ; i ++ ) { fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } } static long find ( int num ) { int cnt = 0 ; for ( int i = 87 ; i > 0 ; i -- ) { if ( num >= fib [ i ] ) { v [ cnt ++ ] = i ; num -= fib [ i ] ; } } for ( int i = 0 ; i < cnt / 2 ; i ++ ) { long t = v [ i ] ; v [ i ] = v [ cnt - i - 1 ] ; v [ cnt - i - 1 ] = t ; } dp1 [ 0 ] = 1 ; dp2 [ 0 ] = ( v [ 0 ] - 1 ) / 2 ; for ( int i = 1 ; i < cnt ; i ++ ) { dp1 [ i ] = dp1 [ i - 1 ] + dp2 [ i - 1 ] ; dp2 [ i ] = ( ( v [ i ] - v [ i - 1 ] ) / 2 ) * dp2 [ i - 1 ] + ( ( v [ i ] - v [ i - 1 ] - 1 ) / 2 ) * dp1 [ i - 1 ] ; } return ( dp1 [ cnt - 1 ] + dp2 [ cnt - 1 ] ) ; } public static void main ( String [ ] args ) { fibonacci ( ) ; int num = 13 ; System . out . print ( find ( num ) ) ; } }
class GFG { public static void countNums ( int N ) { int l = ( int ) Math . pow ( 10 , N - 1 ) , r = ( int ) Math . pow ( 10 , N ) - 1 ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int xor = 0 , temp = i ; while ( temp > 0 ) { xor = xor ^ ( temp % 10 ) ; temp /= 10 ; } if ( xor <= 9 ) count ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int N = 2 ; countNums ( N ) ; } }
import java . util . * ; class GFG { public static long getCount ( int n , int k ) { if ( n == 1 ) return 10 ; long dp [ ] [ ] = new long [ n + 1 ] [ 11 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { int l = Math . max ( 0 , j - k ) ; int r = Math . min ( 9 , j + k ) ; dp [ i ] [ l ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ r + 1 ] -= dp [ i - 1 ] [ j ] ; } for ( int j = 1 ; j <= 9 ; j ++ ) dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } long count = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) count += dp [ n ] [ i ] ; return count ; } public static void main ( String [ ] args ) { int n = 2 , k = 1 ; System . out . println ( getCount ( n , k ) ) ; } }
import java . util . * ; class GFG { static final int X = 6 ; static final int Z = 2 ; static boolean existPath ( int V , int edges [ ] [ ] , int u , int v ) { boolean [ ] [ ] mat = new boolean [ V ] [ V ] ; for ( int i = 0 ; i < X ; i ++ ) mat [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = true ; for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { mat [ i ] [ j ] = mat [ i ] [ j ] || mat [ i ] [ k ] && mat [ k ] [ j ] ; } } } if ( u >= V v >= V ) { return false ; } if ( mat [ u ] [ v ] ) return true ; return false ; } public static void main ( String [ ] args ) { int V = 4 ; int edges [ ] [ ] = { { 0 , 2 } , { 0 , 1 } , { 1 , 2 } , { 2 , 3 } , { 2 , 0 } , { 3 , 3 } } ; int u = 1 , v = 3 ; if ( existPath ( V , edges , u , v ) ) System . out . print ( "YesNEW_LINE"); else System . out . print ( "NoNEW_LINE"); } }
import java . util . * ; class GFG { static int calculate_maximum_splits ( int arr [ ] , int N ) { int pre [ ] = { 0 , - 1 , - 1 } ; int [ ] dp = new int [ N ] ; Arrays . fill ( dp , 0 ) ; int C = 0 ; for ( int i = 0 ; i < N ; i ++ ) { C = C + arr [ i ] ; C = C % 3 ; if ( pre [ C ] == - 1 ) { if ( 1 <= i ) dp [ i ] = dp [ i - 1 ] ; } else { dp [ i ] = Math . max ( dp [ i - 1 ] , dp [ pre [ C ] ] + 1 ) ; } pre [ C ] = i ; } return dp [ N - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 36 , 1 , 9 , 2 , 0 , 1 , 8 , 1 } ; int N = arr . length ; System . out . println ( calculate_maximum_splits ( arr , N ) ) ; } }
class GFG { static void precompute ( int nextpos [ ] , int arr [ ] , int N ) { nextpos [ N - 1 ] = N ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) nextpos [ i ] = nextpos [ i + 1 ] ; else nextpos [ i ] = i + 1 ; } } static void findIndex ( int query [ ] [ ] , int arr [ ] , int N , int Q ) { int [ ] nextpos = new int [ N ] ; precompute ( nextpos , arr , N ) ; for ( int i = 0 ; i < Q ; i ++ ) { int l , r , x ; l = query [ i ] [ 0 ] ; r = query [ i ] [ 1 ] ; x = query [ i ] [ 2 ] ; int ans = - 1 ; if ( arr [ l ] != x ) ans = l ; else { int d = nextpos [ l ] ; if ( d <= r ) ans = d ; } System . out . print ( ans + "NEW_LINE"); } } public static void main ( String [ ] args ) { int N , Q ; N = 6 ; Q = 3 ; int arr [ ] = { 1 , 2 , 1 , 1 , 3 , 5 } ; int query [ ] [ ] = { { 0 , 3 , 1 } , { 1 , 5 , 2 } , { 2 , 3 , 1 } } ; findIndex ( query , arr , N , Q ) ; } }
import java . util . * ; class GFG { static void twoStringsEquality ( String s , String t ) { int n = s . length ( ) ; int [ ] [ ] dp = new int [ n ] [ n + 1 ] ; if ( s . charAt ( n - 1 ) == t . charAt ( 0 ) ) dp [ n - 1 ] [ 1 ] = 1 ; if ( s . charAt ( n - 1 ) == t . charAt ( n - 1 ) ) dp [ n - 1 ] [ 0 ] = 1 ; for ( int i = n - 1 ; i > 0 ; i -- ) { for ( int j = 0 ; j <= n - i ; j ++ ) { if ( dp [ i ] [ j ] > 0 ) { if ( s . charAt ( i - 1 ) == t . charAt ( j ) ) dp [ i - 1 ] [ j + 1 ] = 1 ; if ( s . charAt ( i - 1 ) == t . charAt ( i + j - 1 ) ) dp [ i - 1 ] [ j ] = 1 ; } } } boolean ans = false ; for ( int i = 0 ; i <= n ; i ++ ) { if ( dp [ 0 ] [ i ] == 1 ) { ans = true ; break ; } } if ( ans == true ) System . out . print ( " Yes " + "NEW_LINE"); else System . out . print ( " No " + "NEW_LINE"); } public static void main ( String [ ] args ) { String S = " abab " ; String T = " baab " ; twoStringsEquality ( S , T ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int squareOfZeroes ( int [ ] [ ] matrix ) { int lastIdx = matrix . length - 1 ; Map < String , Boolean > cache = new HashMap < String , Boolean > ( ) ; return ( hasSquareOfZeroes ( matrix , 0 , 0 , lastIdx , lastIdx , cache ) ) ? 1 : 0 ; } static boolean hasSquareOfZeroes ( int [ ] [ ] matrix , int r1 , int c1 , int r2 , int c2 , Map < String , Boolean > cache ) { if ( r1 >= r2 c1 >= c2 ) return false ; String key = r1 + " - " + c1 + " - " + r2 + " - " + c2 ; if ( cache . containsKey ( key ) ) return cache . get ( key ) ; cache . put ( key , isSquareOfZeroes ( matrix , r1 , c1 , r2 , c2 ) || hasSquareOfZeroes ( matrix , r1 + 1 , c1 + 1 , r2 - 1 , c2 - 1 , cache ) || hasSquareOfZeroes ( matrix , r1 , c1 + 1 , r2 - 1 , c2 , cache ) || hasSquareOfZeroes ( matrix , r1 + 1 , c1 , r2 , c2 - 1 , cache ) || hasSquareOfZeroes ( matrix , r1 + 1 , c1 + 1 , r2 , c2 , cache ) || hasSquareOfZeroes ( matrix , r1 , c1 , r2 - 1 , c2 - 1 , cache ) ) ; return cache . get ( key ) ; } static boolean isSquareOfZeroes ( int [ ] [ ] matrix , int r1 , int c1 , int r2 , int c2 ) { for ( int row = r1 ; row < r2 + 1 ; row ++ ) { if ( matrix [ row ] [ c1 ] != 0 matrix [ row ] [ c2 ] != 0 ) return false ; } for ( int col = c1 ; col < c2 + 1 ; col ++ ) { if ( matrix [ r1 ] [ col ] != 0 matrix [ r2 ] [ col ] != 0 ) return false ; } return true ; } public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 1 , 1 , 1 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 } , { 0 , 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 1 , 0 , 1 } , { 0 , 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 0 , 1 } } ; int ans ; ans = squareOfZeroes ( matrix ) ; if ( ans == 1 ) { System . out . println ( " True " ) ; } else { System . out . println ( " False " ) ; } } }
class GFG { static void canMakePaliQueries ( String str , int [ ] [ ] Q ) { int n = str . length ( ) ; int [ ] [ ] dp = new int [ 26 ] [ n ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char currentChar = ( char ) ( i + ' a ' ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = ( str . charAt ( j ) == currentChar ) ? 1 : 0 ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + ( ( str . charAt ( j ) == currentChar ) ? 1 : 0 ) ; } } } for ( int [ ] query : Q ) { int left = query [ 0 ] ; int right = query [ 1 ] ; int k = query [ 2 ] ; int unMatchedCount = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int occurrence = dp [ i ] [ right ] - dp [ i ] [ left ] + ( str . charAt ( left ) == ( i + ' a ' ) ? 1 : 0 ) ; if ( occurrence % 2 == 1 ) unMatchedCount ++ ; } int ans = unMatchedCount / 2 ; if ( ans <= k ) { System . out . print ( "YESNEW_LINE"); } else { System . out . print ( "NONEW_LINE"); } } } public static void main ( String [ ] args ) { String str = " GeeksforGeeks " ; int [ ] [ ] Q = { { 1 , 5 , 3 } , { 5 , 7 , 0 } , { 8 , 11 , 3 } , { 3 , 10 , 5 } , { 0 , 9 , 5 } } ; canMakePaliQueries ( str , Q ) ; } }
class GFG { static int MaximumSum ( int a [ ] , int n ) { int [ ] [ ] dp = new int [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) dp [ i ] [ j ] = Integer . MIN_VALUE ; } for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int val = Integer . MIN_VALUE ; if ( ( i - 2 >= 0 && dp [ i - 2 ] [ j - 1 ] != Integer . MIN_VALUE ) i - 2 < 0 ) { val = a [ i - 1 ] + ( i - 2 >= 0 ? dp [ i - 2 ] [ j - 1 ] : 0 ) ; } if ( i - 1 >= j ) { val = Math . max ( val , dp [ i - 1 ] [ j ] ) ; } dp [ i ] [ j ] = val ; } } return dp [ n ] [ n / 2 ] ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int N = A . length ; System . out . print ( MaximumSum ( A , N ) ) ; } }
import java . util . * ; class GFG { static int [ ] [ ] [ ] dp = new int [ 500 ] [ 500 ] [ 500 ] ; static int calculate ( int pos , int prev , int left , int k ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ prev ] [ left ] != - 1 ) return dp [ pos ] [ prev ] [ left ] ; int answer = 0 ; for ( int i = prev ; i <= left ; i ++ ) { answer += calculate ( pos + 1 , i , left - i , k ) ; } return dp [ pos ] [ prev ] [ left ] = answer ; } static int countWaystoDivide ( int n , int k ) { for ( int i = 0 ; i < 500 ; i ++ ) { for ( int j = 0 ; j < 500 ; j ++ ) { for ( int l = 0 ; l < 500 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } return calculate ( 0 , 1 , n , k ) ; } public static void main ( String [ ] args ) { int N = 8 ; int K = 4 ; System . out . print ( countWaystoDivide ( N , K ) ) ; } }
import java . util . * ; class GFG { static int MAX = 100000 ; static int [ ] divisors = new int [ MAX ] ; static void generateDivisors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { divisors [ i ] ++ ; } else { divisors [ i ] ++ ; divisors [ n / i ] ++ ; } } } } static int findMaxMultiples ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( divisors [ arr [ i ] ] , ans ) ; generateDivisors ( arr [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 1 , 28 , 4 , 2 , 6 , 7 } ; int n = arr . length ; System . out . print ( findMaxMultiples ( arr , n ) ) ; } }
class GFG { static int eggDrop ( int n , int k ) { int dp [ ] [ ] = new int [ k + 1 ] [ n + 1 ] ; int x = 0 ; while ( dp [ x ] [ n ] < k ) { x ++ ; for ( int i = 1 ; i <= n ; i ++ ) dp [ x ] [ i ] = dp [ x - 1 ] [ i - 1 ] + dp [ x - 1 ] [ i ] + 1 ; } return x ; } public static void main ( String args [ ] ) { int n = 2 , k = 36 ; System . out . println ( eggDrop ( n , k ) ) ; } }
class GFG { final static int n = 3 ; final static int m = 3 ; static int countSquareMatrices ( int a [ ] [ ] , int N , int M ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] == 0 ) continue ; a [ i ] [ j ] = Math . min ( Math . min ( a [ i - 1 ] [ j ] , a [ i ] [ j - 1 ] ) , a [ i - 1 ] [ j - 1 ] ) + 1 ; } } for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) count += a [ i ] [ j ] ; return count ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 0 , 1 } , { 1 , 1 , 0 } , { 1 , 1 , 0 } } ; System . out . println ( countSquareMatrices ( arr , n , m ) ) ; } }
class GFG { static final int V_SUM_MAX = 1000 ; static final int N_MAX = 100 ; static final int W_MAX = 10000000 ; static int dp [ ] [ ] = new int [ V_SUM_MAX + 1 ] [ N_MAX ] ; static boolean v [ ] [ ] = new boolean [ V_SUM_MAX + 1 ] [ N_MAX ] ; static int solveDp ( int r , int i , int w [ ] , int val [ ] , int n ) { if ( r <= 0 ) return 0 ; if ( i == n ) return W_MAX ; if ( v [ r ] [ i ] ) return dp [ r ] [ i ] ; v [ r ] [ i ] = true ; dp [ r ] [ i ] = Math . min ( solveDp ( r , i + 1 , w , val , n ) , w [ i ] + solveDp ( r - val [ i ] , i + 1 , w , val , n ) ) ; return dp [ r ] [ i ] ; } static int maxWeight ( int w [ ] , int val [ ] , int n , int c ) { for ( int i = V_SUM_MAX ; i >= 0 ; i -- ) { if ( solveDp ( i , 0 , w , val , n ) <= c ) { return i ; } } return 0 ; } public static void main ( String [ ] args ) { int w [ ] = { 3 , 4 , 5 } ; int val [ ] = { 30 , 50 , 60 } ; int n = w . length ; int C = 8 ; System . out . println ( maxWeight ( w , val , n , C ) ) ; } }
class GFG { static int maxN = 20 ; static int maxM = 64 ; static int [ ] [ ] dp1 = new int [ maxN ] [ maxM ] ; static boolean [ ] [ ] v1 = new boolean [ maxN ] [ maxM ] ; static int findCnt ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { return ( curr == m ? 1 : 0 ) ; } if ( v1 [ i ] [ curr ] ) return dp1 [ i ] [ curr ] ; v1 [ i ] [ curr ] = true ; dp1 [ i ] [ curr ] = findCnt ( arr , i + 1 , curr , n , m ) + findCnt ( arr , i + 1 , ( curr & arr [ i ] ) , n , m ) ; return dp1 [ i ] [ curr ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 0 , 0 } ; int n = arr . length ; int m = 0 ; System . out . println ( findCnt ( arr , 0 , ( ( 1 << 6 ) - 1 ) , n , m ) ) ; } }
class GFG { static int mod = 1000000007 ; static int [ ] [ ] dp = new int [ 55 ] [ 55 ] ; static int NoofWays ( int face , int throwsVal , int sum ) { if ( sum == 0 && throwsVal == 0 ) { return 1 ; } if ( sum < 0 throwsVal == 0 ) { return 0 ; } if ( dp [ throwsVal ] [ sum ] != - 1 ) { return dp [ throwsVal ] [ sum ] ; } int ans = 0 ; for ( int i = 1 ; i <= face ; i ++ ) { ans += NoofWays ( face , throwsVal - 1 , sum - i ) ; } return dp [ throwsVal ] [ sum ] = ans ; } public static void main ( String [ ] args ) { int faces = 6 , throwsVal = 3 , sum = 12 ; for ( int i = 0 ; i < 55 ; i ++ ) { for ( int j = 0 ; j < 55 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . println ( NoofWays ( faces , throwsVal , sum ) ) ; } }
class GFG { final static int bitscount = 32 ; final static int n = 3 ; static int prefix_count [ ] [ ] [ ] = new int [ bitscount ] [ n ] [ n ] ; static void findPrefixCount ( int arr [ ] [ ] ) { for ( int i = 0 ; i < bitscount ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] [ 0 ] = ( ( arr [ j ] [ 0 ] >> i ) & 1 ) ; for ( int k = 1 ; k < n ; k ++ ) { prefix_count [ i ] [ j ] [ k ] = ( ( arr [ j ] [ k ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j ] [ k - 1 ] ; } } } for ( int i = 0 ; i < bitscount ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) prefix_count [ i ] [ j ] [ k ] += prefix_count [ i ] [ j - 1 ] [ k ] ; } static int rangeAnd ( int x1 , int y1 , int x2 , int y2 ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int p ; if ( x1 == 0 && y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] ; else if ( x1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] ; else if ( y1 == 0 ) p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] ; else p = prefix_count [ i ] [ x2 ] [ y2 ] - prefix_count [ i ] [ x1 - 1 ] [ y2 ] - prefix_count [ i ] [ x2 ] [ y1 - 1 ] + prefix_count [ i ] [ x1 - 1 ] [ y1 - 1 ] ; if ( p == ( x2 - x1 + 1 ) * ( y2 - y1 + 1 ) ) ans = ( ans | ( 1 << i ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; findPrefixCount ( arr ) ; int queries [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 1 , 2 , 2 , 2 } } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( rangeAnd ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , queries [ i ] [ 2 ] , queries [ i ] [ 3 ] ) ) ; } }
import java . util . * ; class GFG { static int n ; static int solve ( int i , int x , int dp [ ] [ ] ) { if ( i < 0 ) { return x == 3 ? 1 : 0 ; } if ( dp [ i ] [ x ] != - 1 ) { return dp [ i ] [ x ] ; } dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) ; dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) ; return dp [ i ] [ x ] ; } public static void main ( String [ ] args ) { n = 4 ; int dp [ ] [ ] = new int [ n ] [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 3 ] = ( 1 << ( i + 1 ) ) ; } System . out . print ( solve ( n - 1 , 0 , dp ) ) ; } }
import java . util . * ; class GFG { static int maxSubArraySum ( int arr [ ] , int size ) { int max_so_far = arr [ 0 ] ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( arr [ i ] , curr_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; } static int lenOfLongSubarrWithGivenSum ( int arr [ ] , int n , int k ) { HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum == k ) maxLen = i + 1 ; if ( um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - k ) ) { if ( maxLen < ( i - um . get ( sum - k ) ) ) maxLen = i - um . get ( sum - k ) ; } } return maxLen ; } static int lenLongSubarrWithMaxSum ( int arr [ ] , int n ) { int maxSum = maxSubArraySum ( arr , n ) ; return lenOfLongSubarrWithGivenSum ( arr , n , maxSum ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , - 2 , - 1 , 3 , - 4 } ; int n = arr . length ; System . out . println ( " Length ▁ of ▁ longest ▁ subarray ▁ " + " having ▁ maximum ▁ sum ▁ = ▁ " + lenLongSubarrWithMaxSum ( arr , n ) ) ; } }
import java . util . * ; class GFG { static class data { int element ; int position ; } ; static data findMinElement ( int arr [ ] , int n ) { data result = new data ( ) ; int [ ] prefixSum = new int [ n ] ; int [ ] suffixSum = new int [ n ] ; prefixSum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefixSum [ i ] = prefixSum [ i - 1 ] + arr [ i ] ; } suffixSum [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { suffixSum [ i ] = suffixSum [ i + 1 ] + arr [ i ] ; } int min = suffixSum [ 0 ] ; int pos = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( Math . abs ( suffixSum [ i + 1 ] - prefixSum [ i ] ) < min ) { min = Math . abs ( suffixSum [ i + 1 ] - prefixSum [ i ] ) ; if ( suffixSum [ i + 1 ] < prefixSum [ i ] ) pos = i + 1 ; else pos = i ; } } result . element = min ; result . position = pos ; return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 1 , 2 , 3 , 4 } ; int n = arr . length ; data values ; values = findMinElement ( arr , n ) ; System . out . println ( " Minimum ▁ element ▁ : ▁ " + values . element + " Position : " + values.position); } }
import java . util . * ; class GFG { static int findInd ( int key , int i , int n , int k , int arr [ ] ) { int start , end , mid , ind = - 1 ; start = i + 1 ; end = n - 1 ; while ( start < end ) { mid = start + ( end - start ) / 2 ; if ( arr [ mid ] - key <= k ) { ind = mid ; start = mid + 1 ; } else { end = mid ; } } return ind ; } static int removals ( int arr [ ] , int n , int k ) { int i , j , ans = n - 1 ; Arrays . sort ( arr ) ; for ( i = 0 ; i < n ; i ++ ) { j = findInd ( arr [ i ] , i , n , k , arr ) ; if ( j != - 1 ) { ans = Math . min ( ans , n - ( j - i + 1 ) ) ; } } return ans ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = a . length ; int k = 4 ; System . out . println ( removals ( a , n , k ) ) ; } }
import java . io . * ; class GFG { static int maxLength ( String s , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; } public static void main ( String [ ] args ) { String s = " ( ) ( ( ( ( ( ( ) " ; int n = s . length ( ) ; System . out . println ( maxLength ( s , n ) ) ; } }
class GFG { static int MAX = 10 ; static int lcs ( int [ ] [ ] [ ] dp , int [ ] arr1 , int n , int [ ] arr2 , int m , int k ) { if ( k < 0 ) return - 10000000 ; if ( n < 0 m < 0 ) return 0 ; int ans = dp [ n ] [ m ] [ k ] ; if ( ans != - 1 ) return ans ; try { ans = Math . max ( lcs ( dp , arr1 , n - 1 , arr2 , m , k ) , lcs ( dp , arr1 , n , arr2 , m - 1 , k ) ) ; if ( arr1 [ n - 1 ] == arr2 [ m - 1 ] ) ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k ) ) ; ans = Math . max ( ans , 1 + lcs ( dp , arr1 , n - 1 , arr2 , m - 1 , k - 1 ) ) ; } catch ( Exception e ) { } return ans ; } public static void main ( String [ ] args ) { int k = 1 ; int [ ] arr1 = { 1 , 2 , 3 , 4 , 5 } ; int [ ] arr2 = { 5 , 3 , 1 , 4 , 2 } ; int n = arr1 . length ; int m = arr2 . length ; int [ ] [ ] [ ] dp = new int [ MAX ] [ MAX ] [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) for ( int l = 0 ; l < MAX ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; System . out . println ( lcs ( dp , arr1 , n , arr2 , m , k ) ) ; } }
import java . util . * ; class GFG { public static int maxLenSub ( int arr [ ] , int n ) { int mls [ ] = new int [ n ] , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 } ; int n = arr . length ; System . out . println ( " Maximum ▁ length ▁ subsequence ▁ = ▁ " + maxLenSub ( arr , n ) ) ; } }
class GFG { static final int max = 100000 ; static int baseconversion ( int arr [ ] , int num , int base ) { int i = 0 , rem , j ; if ( num == 0 ) { return 0 ; } while ( num > 0 ) { rem = num % base ; arr [ i ++ ] = rem ; num /= base ; } return i ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ max ] ; int n = 10 ; int size = baseconversion ( arr , n - 1 , 6 ) ; if ( size == 0 ) System . out . print ( size ) ; for ( int i = size - 1 ; i >= 0 ; i -- ) { System . out . print ( arr [ i ] ) ; } } }
import java . util . * ; class GFG { static int MAX = 1000 ; static int numofArray ( int n , int m ) { int [ ] [ ] dp = new int [ MAX ] [ MAX ] ; Vector < Integer > [ ] di = new Vector [ MAX ] ; Vector < Integer > [ ] mu = new Vector [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < MAX ; i ++ ) { di [ i ] = new Vector < > ( ) ; mu [ i ] = new Vector < > ( ) ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 2 * i ; j <= m ; j += i ) { di [ j ] . add ( i ) ; mu [ i ] . add ( j ) ; } di [ i ] . add ( i ) ; } for ( int i = 1 ; i <= m ; i ++ ) dp [ 1 ] [ i ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; for ( Integer x : di [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; for ( Integer x : mu [ j ] ) dp [ i ] [ j ] += dp [ i - 1 ] [ x ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { ans += dp [ n ] [ i ] ; di [ i ] . clear ( ) ; mu [ i ] . clear ( ) ; } return ans ; } public static void main ( String [ ] args ) { int n = 3 , m = 3 ; System . out . println ( numofArray ( n , m ) ) ; } }
class GFG { static int Row = 6 , Col = 6 ; static int largestKSubmatrix ( int [ ] [ ] a ) { int [ ] [ ] dp = new int [ Row ] [ Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; } public static void main ( String [ ] args ) { int [ ] [ ] a = { { 2 , 2 , 3 , 3 , 4 , 4 } , { 5 , 5 , 7 , 7 , 7 , 4 } , { 1 , 2 , 7 , 7 , 7 , 4 } , { 4 , 4 , 7 , 7 , 7 , 4 } , { 5 , 5 , 5 , 1 , 2 , 7 } , { 8 , 7 , 9 , 4 , 4 , 4 } } ; System . out . println ( largestKSubmatrix ( a ) ) ; } }
class GFG { static int countDivisibleSubseq ( String str , int n ) { int len = str . length ( ) ; int dp [ ] [ ] = new int [ len ] [ n ] ; dp [ 0 ] [ ( str . charAt ( 0 ) - '0' ) % n ] ++ ; for ( int i = 1 ; i < len ; i ++ ) { dp [ i ] [ ( str . charAt ( i ) - '0' ) % n ] ++ ; for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] ; dp [ i ] [ ( j * 10 + ( str . charAt ( i ) - '0' ) ) % n ] += dp [ i - 1 ] [ j ] ; } } return dp [ len - 1 ] [ 0 ] ; } public static void main ( String [ ] args ) { String str = "1234" ; int n = 4 ; System . out . print ( countDivisibleSubseq ( str , n ) ) ; } }
import java . util . * ; class GFG { static int N = 100 ; static int [ ] [ ] L = new int [ N ] [ N ] ; static Set < String > findLCS ( String X , String Y , int m , int n ) { Set < String > s = new HashSet < > ( ) ; if ( m == 0 n == 0 ) { s . add ( " " ) ; return s ; } if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) { Set < String > tmp = findLCS ( X , Y , m - 1 , n - 1 ) ; for ( String str : tmp ) s . add ( str + X . charAt ( m - 1 ) ) ; } else { if ( L [ m - 1 ] [ n ] >= L [ m ] [ n - 1 ] ) s = findLCS ( X , Y , m - 1 , n ) ; if ( L [ m ] [ n - 1 ] >= L [ m - 1 ] [ n ] ) { Set < String > tmp = findLCS ( X , Y , m , n - 1 ) ; s . addAll ( tmp ) ; } } return s ; } static int LCS ( String X , String Y , int m , int n ) { for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } public static void main ( String [ ] args ) { String X = " AGTGATG " ; String Y = " GTTAG " ; int m = X . length ( ) ; int n = Y . length ( ) ; System . out . println ( " LCS ▁ length ▁ is ▁ " + LCS ( X , Y , m , n ) ) ; Set < String > s = findLCS ( X , Y , m , n ) ; for ( String str : s ) System . out . println ( str ) ; } }
import java . io . * ; class GFG { static int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntegralSolutions ( n ) ) ; } }
import java . io . * ; class Partition { static boolean isSubsetSum ( int arr [ ] , int n , int sum ) { if ( sum == 0 ) return true ; if ( n == 0 && sum != 0 ) return false ; if ( arr [ n - 1 ] > sum ) return isSubsetSum ( arr , n - 1 , sum ) ; return isSubsetSum ( arr , n - 1 , sum ) || isSubsetSum ( arr , n - 1 , sum - arr [ n - 1 ] ) ; } static boolean findPartition ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; return isSubsetSum ( arr , n , sum / 2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 5 , 9 , 12 } ; int n = arr . length ; if ( findPartition ( arr , n ) == true ) System . out . println ( " Can ▁ be ▁ divided ▁ into ▁ two ▁ " + " subsets ▁ of ▁ equal ▁ sum " ) ; else System . out . println ( " Can ▁ not ▁ be ▁ divided ▁ into ▁ " + " two ▁ subsets ▁ of ▁ equal ▁ sum " ) ; } }
import java . util . * ; class GFG { static void find ( int N , int [ ] [ ] Arr ) { int amount = 0 ; ArrayList < Integer > mid_odd = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int siz = Arr [ i ] . length ; for ( int j = 0 ; j < siz / 2 ; j ++ ) amount = amount + Arr [ i ] [ j ] ; if ( siz % 2 == 1 ) mid_odd . add ( Arr [ i ] [ siz / 2 ] ) ; } Collections . sort ( mid_odd ) ; for ( int i = 0 ; i < mid_odd . size ( ) ; i ++ ) { if ( i % 2 == 0 ) amount = amount + mid_odd . get ( i ) ; } System . out . println ( amount ) ; } public static void main ( String [ ] args ) { int N = 2 ; int [ ] [ ] Arr = { { 5 , 2 , 3 , 4 } , { 1 , 6 } } ; find ( N , Arr ) ; } }
import java . util . * ; class GFG { static void printDiagonalTraversal ( int [ ] [ ] nums ) { int max_size = nums [ 0 ] . length ; ArrayList < ArrayList < Integer > > v = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < 2 * max_size - 1 ; i ++ ) { v . add ( new ArrayList < Integer > ( ) ) ; } for ( int i = 0 ; i < nums [ 0 ] . length ; i ++ ) { for ( int j = 0 ; j < nums [ 0 ] . length ; j ++ ) { v . get ( i + j ) . add ( nums [ i ] [ j ] ) ; } } for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = v . get ( i ) . size ( ) - 1 ; j >= 0 ; j -- ) { System . out . print ( v . get ( i ) . get ( j ) + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int [ ] [ ] arr = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; printDiagonalTraversal ( arr ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int OddLengthSum ( int [ ] arr ) { int sum = 0 ; int l = arr . length ; for ( int i = 0 ; i < l ; i ++ ) { for ( int j = i ; j < l ; j += 2 ) { for ( int k = i ; k <= j ; k ++ ) { sum += arr [ k ] ; } } } return sum ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 5 , 3 , 1 , 2 } ; System . out . print ( OddLengthSum ( arr ) ) ; } }
import java . util . * ; class GFG { public static long [ ] N_bonacci = new long [ 100 ] ; @ SuppressWarnings ( " unchecked " ) public static void N_bonacci_nums ( int n , int k ) { N_bonacci [ 0 ] = 1 ; for ( int i = 1 ; i <= 50 ; ++ i ) { for ( int j = i - 1 ; j >= i - k && j >= 0 ; -- j ) N_bonacci [ i ] += N_bonacci [ j ] ; } Vector ans = new Vector ( ) ; for ( int i = 50 ; i >= 0 ; -- i ) if ( n - N_bonacci [ i ] >= 0 ) { ans . add ( N_bonacci [ i ] ) ; n -= N_bonacci [ i ] ; } if ( ans . size ( ) == 1 ) ans . add ( 0 ) ; System . out . println ( ans . size ( ) ) ; for ( int i = 0 ; i < ans . size ( ) ; ++ i ) System . out . print ( ans . get ( i ) + " , ▁ " ) ; } public static void main ( String args [ ] ) { int n = 21 , k = 5 ; N_bonacci_nums ( n , k ) ; } }
import java . util . * ; class GFG { static int checkBitonic ( char [ ] s ) { int i , j ; for ( i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] > s [ i - 1 ] ) continue ; if ( s [ i ] <= s [ i - 1 ] ) break ; } if ( i == s . length - 1 ) return 1 ; for ( j = i + 1 ; j < s . length ; j ++ ) { if ( s [ j ] < s [ j - 1 ] ) continue ; if ( s [ j ] >= s [ j - 1 ] ) break ; } i = j ; if ( i != s . length ) return 0 ; return 1 ; } public static void main ( String [ ] args ) { String s = " abcdfgcba " ; System . out . print ( ( checkBitonic ( s . toCharArray ( ) ) == 1 ) ? " YES " : " NO " ) ; } }
class GFG { static void makeArray ( int a [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( i * n + " ▁ " ) ; } public static void main ( String [ ] args ) { int N = 6 ; int arr [ ] = new int [ N ] ; makeArray ( arr , N ) ; } }
import java . util . * ; class GFG { static int checkQwertyRow ( char x ) { Character [ ] first_row1 = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '0' , ' - ' , ' = ' } ; Set < Character > first_row = new HashSet < > ( Arrays . asList ( first_row1 ) ) ; Character [ ] second_row1 = { ' Q ' , ' W ' , ' E ' , ' R ' , ' T ' , ' Y ' , ' U ' , ' I ' , ' O ' , ' P ' , ' [ ' , ' ] ' , ' q ' , ' w ' , ' e ' , ' r ' , ' t ' , ' y ' , ' u ' , ' i ' , ' o ' , ' p ' } ; Set < Character > second_row = new HashSet < > ( Arrays . asList ( second_row1 ) ) ; Character [ ] third_row1 = { ' A ' , ' S ' , ' D ' , ' F ' , ' G ' , ' H ' , ' J ' , ' K ' , ' L ' , ' ; ' , ' : ' , ' a ' , ' s ' , ' d ' , ' f ' , ' g ' , ' h ' , ' j ' , ' k ' , ' l ' } ; Set < Character > third_row = new HashSet < > ( Arrays . asList ( third_row1 ) ) ; Character [ ] fourth_row1 = { ' Z ' , ' X ' , ' C ' , ' V ' , ' B ' , ' N ' , ' M ' , ' , ' , ' . ' , ' / ' , ' z ' , ' x ' , ' c ' , ' v ' , ' b ' , ' n ' , ' m ' } ; Set < Character > fourth_row = new HashSet < > ( Arrays . asList ( fourth_row1 ) ) ; if ( first_row . contains ( x ) ) { return 1 ; } else if ( second_row . contains ( x ) ) { return 2 ; } else if ( third_row . contains ( x ) ) { return 3 ; } else if ( fourth_row . contains ( x ) ) { return 4 ; } return 0 ; } static boolean checkValidity ( String str ) { char x = str . charAt ( 0 ) ; int row = checkQwertyRow ( x ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { x = str . charAt ( i ) ; if ( row != checkQwertyRow ( x ) ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String str = " GeeksforGeeks " ; if ( checkValidity ( str ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int fib ( long n ) { int f0 = 0 ; int f1 = 1 ; if ( n == 0 ) return 0 ; if ( n == 1 ) return 1 ; else { int rem = ( int ) ( n % 60 ) ; if ( rem == 0 ) return 0 ; for ( int i = 2 ; i < rem + 3 ; i ++ ) { int f = ( f0 + f1 ) % 60 ; f0 = f1 ; f1 = f ; } int s = f1 - 1 ; return s ; } } public static void main ( String args [ ] ) { int m = 10087887 ; long n = 2983097899L ; int Final = ( int ) Math . abs ( fib ( n ) - fib ( m - 1 ) ) ; System . out . println ( Final % 10 ) ; } }
class GFG { static int printPattern ( int i , int j , int n ) { if ( j >= n ) { return 0 ; } if ( i >= n ) { return 1 ; } if ( j == i j == n - 1 - i ) { if ( i == n - 1 - j ) { System . out . print ( " / " ) ; } else { System . out . print ( " \ \" ) ; } } else { System . out . print ( " * " ) ; } if ( printPattern ( i , j + 1 , n ) == 1 ) { return 1 ; } System . out . println ( ) ; return printPattern ( i + 1 , 0 , n ) ; } public static void main ( String [ ] args ) { int N = 9 ; printPattern ( 0 , 0 , N ) ; } }
class GFG { static String s ; static void reverseStr ( int l , int h ) { int n = h - l ; for ( int i = 0 ; i < n / 2 ; i ++ ) { s = swap ( i + l , n - i - 1 + l ) ; } } static void reverseString ( int A [ ] , int n ) { reverseStr ( 0 , A [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) reverseStr ( A [ i - 1 ] , A [ i ] ) ; reverseStr ( A [ n - 1 ] , s . length ( ) ) ; } static String swap ( int i , int j ) { char ch [ ] = s . toCharArray ( ) ; char temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; return String . valueOf ( ch ) ; } public static void main ( String [ ] args ) { s = " abcdefgh " ; int A [ ] = { 2 , 4 , 6 } ; int n = A . length ; reverseString ( A , n ) ; System . out . print ( s ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int getElement ( int N , int r , int c ) { if ( r > c ) return 0 ; if ( r == 1 ) { return c ; } int a = ( r + 1 ) * ( int ) ( Math . pow ( 2 , ( r - 2 ) ) ) ; int d = ( int ) ( Math . pow ( 2 , ( r - 1 ) ) ) ; c = c - r ; int element = a + d * c ; return element ; } public static void main ( String [ ] args ) { int N = 4 , R = 3 , C = 4 ; System . out . println ( getElement ( N , R , C ) ) ; } }
import java . util . * ; class GFG { static boolean check ( String S1 , String S2 ) { int n1 = S1 . length ( ) ; int n2 = S2 . length ( ) ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( mp . containsKey ( ( int ) S1 . charAt ( i ) ) ) { mp . put ( ( int ) S1 . charAt ( i ) , mp . get ( ( int ) S1 . charAt ( i ) ) + 1 ) ; } else { mp . put ( ( int ) S1 . charAt ( i ) , 1 ) ; } } for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp . containsKey ( ( int ) S2 . charAt ( i ) ) ) { mp . put ( ( int ) S2 . charAt ( i ) , mp . get ( ( int ) S2 . charAt ( i ) ) - 1 ) ; } else if ( mp . containsKey ( S2 . charAt ( i ) - 1 ) && mp . containsKey ( S2 . charAt ( i ) - 2 ) ) { mp . put ( ( S2 . charAt ( i ) - 1 ) , mp . get ( S2 . charAt ( i ) - 1 ) - 1 ) ; mp . put ( ( S2 . charAt ( i ) - 2 ) , mp . get ( S2 . charAt ( i ) - 2 ) - 1 ) ; } else { return false ; } } return true ; } public static void main ( String [ ] args ) { String S1 = " abbat " ; String S2 = " cat " ; if ( check ( S1 , S2 ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . io . * ; class GFG { static int lengthNPalindrome ( int N , int K ) { int half = N / 2 ; if ( N % 2 == 1 ) { half += 1 ; } int ans = 1 ; for ( int i = 1 ; i <= half ; i ++ ) { ans *= K ; K -- ; } return ans ; } static int palindromicStrings ( int N , int K ) { if ( N == 1 ) { return K ; } if ( N == 2 ) { return 2 * K ; } int ans = 0 ; ans += ( 2 * K ) ; for ( int i = 3 ; i <= N ; i ++ ) { ans += lengthNPalindrome ( i , K ) ; } return ans ; } public static void main ( String [ ] args ) { int N = 4 , K = 3 ; System . out . println ( palindromicStrings ( N , K ) ) ; } }
import java . io . * ; class GFG { static int LCS ( String S , int N , String T , int M , int dp [ ] [ ] ) { if ( N == 0 M == 0 ) return 0 ; if ( dp [ N ] [ M ] != 0 ) return dp [ N ] [ M ] ; if ( S . charAt ( N - 1 ) == T . charAt ( M - 1 ) ) { return dp [ N ] [ M ] = 1 + LCS ( S , N - 1 , T , M - 1 , dp ) ; } return dp [ N ] [ M ] = Math . max ( LCS ( S , N - 1 , T , M , dp ) , LCS ( S , N , T , M - 1 , dp ) ) ; } static int minimumCharacter ( String S ) { String T = " abcdefghijklmnopqrstuvwxyz " ; int N = S . length ( ) , M = T . length ( ) ; int dp [ ] [ ] = new int [ N + 1 ] [ M + 1 ] ; return ( 26 - LCS ( S , N , T , M , dp ) ) ; } public static void main ( String [ ] args ) { String S = " abcdadc " ; System . out . println ( minimumCharacter ( S ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static String MinValue ( String number , int x ) { int length = number . length ( ) ; int position = length + 1 ; if ( number . charAt ( 0 ) == ' - ' ) { for ( int i = number . length ( ) - 1 ; i >= 1 ; -- i ) { if ( ( number . charAt ( i ) - 48 ) < x ) { position = i ; } } } else { for ( int i = number . length ( ) - 1 ; i >= 0 ; -- i ) { if ( ( number . charAt ( i ) - 48 ) > x ) { position = i ; } } } number = number . substring ( 0 , position ) + x + number . substring ( position , number . length ( ) ) ; return number . toString ( ) ; } public static void main ( String [ ] args ) { String number = "89" ; int x = 1 ; System . out . print ( MinValue ( number , x ) ) ; } }
import java . io . * ; class GFG { public static void countOperations ( String S ) { int n = S . length ( ) ; int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( S . charAt ( i ) == '0' ) { cnt ++ ; } else { if ( cnt > 0 ) { cnt -- ; ans ++ ; } } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { String S = "110011010" ; countOperations ( S ) ; } }
public class GFG { private static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; else if ( n == 2 ) return true ; else if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { if ( n % i == 0 ) return false ; } return true ; } private static void checkPermutation ( String s1 , String s2 ) { int freq [ ] = new int [ 26 ] ; for ( char ch : s1 . toCharArray ( ) ) { freq [ ch - ' a ' ] -- ; } for ( char ch : s2 . toCharArray ( ) ) { freq [ ch - ' a ' ] ++ ; } boolean isAllChangesPrime = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == 0 ) { continue ; } else if ( ! isPrime ( Math . abs ( freq [ i ] ) ) ) { isAllChangesPrime = false ; break ; } } if ( isAllChangesPrime ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { String S1 = " gekforgk " ; String S2 = " geeksforgeeks " ; checkPermutation ( S1 , S2 ) ; } }
import java . io . * ; class GFG { public static void minimumOperations ( String S , int N ) { int ans = 0 ; int cntOne = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( S . charAt ( i ) == '0' ) { ans += cntOne ; cntOne *= 2 ; } else cntOne ++ ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { String S = "001" ; int N = S . length ( ) ; minimumOperations ( S , N ) ; } }
import java . io . * ; class GFG { static boolean isPrime ( int num ) { boolean flag = false ; if ( num > 1 ) { for ( int i = 2 ; i < num ; i ++ ) { if ( ( num % i ) == 0 ) { flag = true ; break ; } } } if ( flag ) return false ; else return true ; } static int order ( int x ) { int n = 0 ; while ( x != 0 ) { n = n + 1 ; x = x / 10 ; } return n ; } static boolean isArmstrong ( int x ) { int n = order ( x ) ; int temp = x ; int sum1 = 0 ; while ( temp != 0 ) { int r = temp % 10 ; sum1 = sum1 + ( int ) ( Math . pow ( r , n ) ) ; temp = temp / 10 ; } return ( sum1 == x ) ; } static int count_armstrong ( String [ ] li ) { int c = 0 ; for ( String ele : li ) { int val = 0 ; for ( char che : ele . toCharArray ( ) ) val += che ; if ( isArmstrong ( val ) ) c += 1 ; } return c ; } static int count_prime ( String [ ] li ) { int c = 0 ; for ( String ele : li ) { int val = 0 ; for ( char che : ele . toCharArray ( ) ) val += che ; if ( isPrime ( val ) ) c += 1 ; } return c ; } public static void main ( String [ ] args ) { String [ ] arr = { " geeksforgeeks " , " a " , " computer " , " science " , " portal " , " for " , " geeks " } ; System . out . println ( " Number ▁ of ▁ Armstrong ▁ Strings ▁ are : ▁ " + count_armstrong ( arr ) ) ; System . out . println ( " Number ▁ of ▁ Prime ▁ Strings ▁ are : ▁ " + count_prime ( arr ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int count ( String S , int X , int Y ) { int N = S . length ( ) ; int temp_x = 0 , temp_y = 0 ; int count = 0 ; HashSet < String > s = new HashSet < > ( ) ; s . add ( ( X + " # " + Y ) ) ; for ( int i = 0 ; i < N ; i ++ ) { temp_x = X ; temp_y = Y ; if ( S . charAt ( i ) == ' U ' ) { X ++ ; } else if ( S . charAt ( i ) == ' D ' ) { X -- ; } else if ( S . charAt ( i ) == ' R ' ) { Y ++ ; } else { Y -- ; } if ( s . contains ( ( temp_x + X ) + " # " + ( temp_y + Y ) ) ) { count ++ ; } else { s . add ( ( temp_x + X ) + " # " + ( temp_y + Y ) ) ; } } return count ; } public static void main ( String [ ] args ) { String S = " RDDUDL " ; int X = 0 , Y = 0 ; System . out . print ( count ( S , X , Y ) ) ; } }
class GFG { static void countMinMoves ( String str ) { int n = str . length ( ) ; int a [ ] = new int [ n ] ; int j , ans = 0 , i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ) ' ) { a [ i ] += sum - 1 ; } else { a [ i ] += sum + 1 ; } sum = a [ i ] ; } if ( sum == 0 ) { i = 1 ; while ( i < n ) { j = i - 1 ; while ( i < n && a [ i ] != 0 ) i ++ ; if ( i < n && a [ i - 1 ] < 0 ) { ans += i - j ; if ( j == 0 ) ans ++ ; } i ++ ; } System . out . println ( ans ) ; } else System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { String str = " ) ( ( ) " ; countMinMoves ( str ) ; } }
import java . util . * ; class GFG { static void PrintStack ( Stack < Character > s ) { if ( s . isEmpty ( ) ) return ; char x = s . peek ( ) ; s . pop ( ) ; PrintStack ( s ) ; System . out . print ( x ) ; s . add ( x ) ; } static void minString ( String s ) { Stack < Character > Stack = new Stack < Character > ( ) ; Stack . add ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( Stack . isEmpty ( ) ) { Stack . add ( s . charAt ( i ) ) ; } else { if ( Stack . peek ( ) == s . charAt ( i ) ) { Stack . pop ( ) ; } else { Stack . push ( s . charAt ( i ) ) ; } } } PrintStack ( Stack ) ; } public static void main ( String [ ] args ) { String str = "101001" ; minString ( str ) ; } }
import java . util . * ; class GFG { static String ShortenString ( String str1 ) { Stack < Character > st = new Stack < Character > ( ) ; int i = 0 ; while ( i < str1 . length ( ) ) { if ( st . isEmpty ( ) || str1 . charAt ( i ) != st . peek ( ) ) { st . add ( str1 . charAt ( i ) ) ; i ++ ; } else { st . pop ( ) ; i ++ ; } } if ( st . isEmpty ( ) ) { return ( " Empty ▁ String " ) ; } else { String short_String = " " ; while ( ! st . isEmpty ( ) ) { short_String = st . peek ( ) + short_String ; st . pop ( ) ; } return ( short_String ) ; } } public static void main ( String [ ] args ) { String str1 = " azzxzy " ; System . out . print ( ShortenString ( str1 ) ) ; } }
import java . util . * ; class GFG { static void printRev ( String str ) { Stack < String > st = new Stack < String > ( ) ; String [ ] ss = str . split ( " ▁ " ) ; for ( String temp : ss ) { st . add ( temp ) ; } while ( ! st . isEmpty ( ) ) { System . out . print ( st . peek ( ) + " ▁ " ) ; st . pop ( ) ; } } public static void main ( String [ ] args ) { String str ; str = " geeks ▁ quiz ▁ practice ▁ code " ; printRev ( str ) ; } }
import java . util . * ; class GFG { static int maxSetBitCount ( String s , int k ) { int maxCount = 0 , n = s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s . charAt ( i ) == '1' ) count ++ ; } maxCount = count ; for ( int i = k ; i < n ; i ++ ) { if ( s . charAt ( i - k ) == '1' ) count -- ; if ( s . charAt ( i ) == '1' ) count ++ ; maxCount = Math . max ( maxCount , count ) ; } return maxCount ; } public static void main ( String [ ] args ) { String s = "100111010" ; int k = 3 ; System . out . println ( maxSetBitCount ( s , k ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean check ( String s ) { boolean ok = true ; for ( int i = 0 ; i + 1 < s . length ( ) ; ++ i ) ok &= ( Math . abs ( s . charAt ( i ) - s . charAt ( i + 1 ) ) != 1 ) ; return ok ; } static String monotonousString ( String s ) { String odd = " " , even = " " ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( s . charAt ( i ) % 2 == 0 ) odd += s . charAt ( i ) ; else even += s . charAt ( i ) ; } char oddArray [ ] = odd . toCharArray ( ) ; Arrays . sort ( oddArray ) ; odd = new String ( oddArray ) ; char evenArray [ ] = even . toCharArray ( ) ; Arrays . sort ( evenArray ) ; even = new String ( evenArray ) ; if ( check ( odd + even ) ) return " Yes " ; else if ( check ( even + odd ) ) return " Yes " ; return " No " ; } public static void main ( String [ ] args ) { String str = " abcd " ; String ans ; ans = monotonousString ( str ) ; System . out . println ( ans ) ; } }
import java . util . * ; class GFG { static String findStr ( String S ) { StringBuilder sb = new StringBuilder ( S ) ; int n = sb . length ( ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { if ( sb . charAt ( i ) != ' a ' ) { sb . setCharAt ( i , ' a ' ) ; return sb . toString ( ) ; } } sb . setCharAt ( n - 1 , ' b ' ) ; return n < 2 ? " ▁ - 1 ▁ " : sb . toString ( ) ; } public static void main ( String [ ] args ) { String str = " a " ; System . out . println ( findStr ( str ) ) ; String str1 = " abccba " ; System . out . println ( findStr ( str1 ) ) ; } }
import java . util . * ; class GFG { static void convertString ( String str1 , String str2 , String str3 ) { HashMap < Character , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < str3 . length ( ) ; i ++ ) { if ( freq . containsKey ( str3 . charAt ( i ) ) ) freq . put ( str3 . charAt ( i ) , freq . get ( str3 . charAt ( i ) ) + 1 ) ; else freq . put ( str3 . charAt ( i ) , 1 ) ; } int ptr1 = 0 ; int ptr2 = 0 ; boolean flag = true ; while ( ptr1 < str1 . length ( ) && ptr2 < str2 . length ( ) ) { if ( str1 . charAt ( ptr1 ) == str2 . charAt ( ptr2 ) ) { ptr1 ++ ; ptr2 ++ ; } else { if ( freq . containsKey ( str3 . charAt ( ptr2 ) ) ) if ( freq . get ( str3 . charAt ( ptr2 ) ) > 0 ) { freq . put ( str3 . charAt ( ptr2 ) , freq . get ( str3 . charAt ( ptr2 ) ) - 1 ) ; ptr2 ++ ; } else { flag = false ; break ; } } } if ( flag && ptr1 == str1 . length ( ) && ptr2 == str2 . length ( ) ) { System . out . print ( " YES " + "NEW_LINE"); } else { System . out . print ( " NO " + "NEW_LINE"); } } public static void main ( String [ ] args ) { String str1 = " abyzfe " ; String str2 = " abcdeyzf " ; String str3 = " popode " ; convertString ( str1 , str2 , str3 ) ; } }
import java . util . * ; class GFG { public static void distinct ( String [ ] S , int M ) { int count = 0 ; for ( int i = 0 ; i < S . length ; i ++ ) { Set < Character > set = new HashSet < > ( ) ; for ( int j = 0 ; j < S [ i ] . length ( ) ; j ++ ) { if ( ! set . contains ( S [ i ] . charAt ( j ) ) ) set . add ( S [ i ] . charAt ( j ) ) ; } int c = set . size ( ) ; if ( c <= M ) count += 1 ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { String S [ ] = { " HERBIVORES " , " AEROPLANE " , " GEEKSFORGEEKS " } ; int M = 7 ; distinct ( S , M ) ; } }
public class GFG { static void string ( int l , int x , int y ) { int p = 97 ; for ( int j = 0 ; j < l ; j ++ ) { char ans = ( char ) ( p + ( j % y ) ) ; System . out . print ( ans ) ; } } public static void main ( String [ ] args ) { int l = 6 ; int x = 5 ; int y = 3 ; string ( l , x , y ) ; } }
class GFG { static void findPeriodicString ( String S ) { int l = 2 * S . length ( ) ; int count = 0 ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == '1' ) count ++ ; } if ( count == S . length ( ) count == 0 ) System . out . println ( S ) ; else { char arr [ ] = new char [ l ] ; for ( int i = 0 ; i < l ; i += 2 ) { arr [ i ] = '1' ; arr [ i + 1 ] = '0' ; } for ( int i = 0 ; i < l ; i ++ ) System . out . print ( arr [ i ] ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { String S = "1111001" ; findPeriodicString ( S ) ; } }
class GFG { static void group_formed ( String S ) { int count = 1 ; for ( int i = 0 ; i < S . length ( ) - 1 ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i + 1 ) ) count += 1 ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { String S = " TTWWW " ; group_formed ( S ) ; } }
class GFG { static String ReverseComplement ( char [ ] s , int n , int k ) { int rev = ( k + 1 ) / 2 ; int complement = k - rev ; if ( rev % 2 == 1 ) s = reverse ( s ) ; if ( complement % 2 == 1 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' ) s [ i ] = '1' ; else s [ i ] = '0' ; } } return String . valueOf ( s ) ; } static char [ ] reverse ( char a [ ] ) { int i , n = a . length ; char t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } public static void main ( String [ ] args ) { String str = "10011" ; int k = 5 ; int n = str . length ( ) ; System . out . print ( ReverseComplement ( str . toCharArray ( ) , n , k ) ) ; } }
class GFG { static boolean repeatingString ( String s , int n , int k ) { if ( n % k != 0 ) { return false ; } int [ ] frequency = new int [ 123 ] ; for ( int i = 0 ; i < 123 ; i ++ ) { frequency [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { frequency [ s . charAt ( i ) ] ++ ; } int repeat = n / k ; for ( int i = 0 ; i < 123 ; i ++ ) { if ( frequency [ i ] % repeat != 0 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String s = " abcdcba " ; int n = s . length ( ) ; int k = 3 ; if ( repeatingString ( s , n , k ) ) { System . out . print ( " Yes " + "NEW_LINE"); } else { System . out . print ( " No " + "NEW_LINE"); } } }
class GFG { static void printValue ( char digit ) { switch ( digit ) { case '0' : System . out . print ( " Zero ▁ " ) ; break ; case '1' : System . out . print ( " One ▁ " ) ; break ; case '2' : System . out . print ( " Two ▁ " ) ; break ; case '3' : System . out . print ( " Three ▁ " ) ; break ; case '4' : System . out . print ( " Four ▁ " ) ; break ; case '5' : System . out . print ( " Five ▁ " ) ; break ; case '6' : System . out . print ( " Six ▁ " ) ; break ; case '7' : System . out . print ( " Seven ▁ " ) ; break ; case '8' : System . out . print ( " Eight ▁ " ) ; break ; case '9' : System . out . print ( " Nine ▁ " ) ; break ; } } static void printWord ( String N ) { int i , length = N . length ( ) ; for ( i = 0 ; i < length ; i ++ ) { printValue ( N . charAt ( i ) ) ; } } public static void main ( String [ ] args ) { String N = "123" ; printWord ( N ) ; } }
class GFG { static double jaro_distance ( String s1 , String s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . length ( ) , len2 = s2 . length ( ) ; int max_dist = ( int ) ( Math . floor ( Math . max ( len1 , len2 ) / 2 ) - 1 ) ; int match = 0 ; int hash_s1 [ ] = new int [ s1 . length ( ) ] ; int hash_s2 [ ] = new int [ s2 . length ( ) ] ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = Math . max ( 0 , i - max_dist ) ; j < Math . min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 . charAt ( i ) == s2 . charAt ( j ) && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] == 1 ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 . charAt ( i ) != s2 . charAt ( point ++ ) ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; } public static void main ( String [ ] args ) { String s1 = " CRATE " , s2 = " TRACE " ; System . out . print ( jaro_distance ( s1 , s2 ) + "NEW_LINE"); } }
class GFG { static int findMinSwaps ( String s , int k ) { int ans = 0 ; int c_one = 0 , c_zero = 0 ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == '1' ) c_one ++ ; if ( s . charAt ( i ) == '0' ) { c_zero ++ ; ans += c_one ; } if ( c_zero == k ) break ; } if ( c_zero < k ) return - 1 ; return ans ; } public static void main ( String [ ] args ) { String s = "100111" ; int k = 2 ; System . out . println ( findMinSwaps ( s , k ) ) ; } }
import java . util . * ; class GFG { static class Node { char data ; Node left , right ; Node ( char _val ) { data = _val ; left = right = null ; } } ; static Node addinBT ( Node root , char data ) { if ( root == null ) { root = new Node ( data ) ; } else { Queue < Node > Q = new LinkedList < Node > ( ) ; Q . add ( root ) ; while ( ! Q . isEmpty ( ) ) { Node temp = Q . peek ( ) ; Q . remove ( ) ; if ( temp . left == null ) { temp . left = new Node ( data ) ; break ; } else Q . add ( temp . left ) ; if ( temp . right == null ) { temp . right = new Node ( data ) ; break ; } else Q . add ( temp . right ) ; } } return root ; } static void print ( Node root ) { Queue < Node > Q = new LinkedList < Node > ( ) ; Q . add ( root ) ; while ( Q . size ( ) > 0 ) { Node temp = Q . peek ( ) ; Q . remove ( ) ; System . out . print ( temp . data ) ; if ( temp . left != null ) Q . add ( temp . left ) ; if ( temp . right != null ) Q . add ( temp . right ) ; } } static boolean checkvowel ( char ch ) { ch = Character . toLowerCase ( ch ) ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) { return true ; } else { return false ; } } static Node removevowels ( Node root ) { Queue < Node > Q = new LinkedList < Node > ( ) ; Q . add ( root ) ; Node root1 = null ; while ( ! Q . isEmpty ( ) ) { Node temp = Q . peek ( ) ; Q . remove ( ) ; if ( ! checkvowel ( temp . data ) ) { root1 = addinBT ( root1 , temp . data ) ; } if ( temp . left != null ) { Q . add ( temp . left ) ; } if ( temp . right != null ) { Q . add ( temp . right ) ; } } return root1 ; } public static void main ( String [ ] args ) { String s = " geeks " ; Node root = null ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { root = addinBT ( root , s . charAt ( i ) ) ; } root = removevowels ( root ) ; print ( root ) ; } }
class GFG { static final int N = 2 ; static Boolean isVowel ( char ch ) { return ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) ; } static void performQueries ( String str , int len , int queries [ ] [ ] , int q ) { int [ ] pre = new int [ len ] ; if ( isVowel ( str . charAt ( 0 ) ) ) pre [ 0 ] = 1 ; else pre [ 0 ] = 0 ; for ( int i = 1 ; i < len ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) ) pre [ i ] = 1 + pre [ i - 1 ] ; else pre [ i ] = pre [ i - 1 ] ; } for ( int i = 0 ; i < q ; i ++ ) { if ( queries [ i ] [ 0 ] == 0 ) { System . out . println ( pre [ queries [ i ] [ 1 ] ] ) ; } else { System . out . println ( ( pre [ queries [ i ] [ 1 ] ] - pre [ queries [ i ] [ 0 ] - 1 ] ) ) ; } } } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int len = str . length ( ) ; int queries [ ] [ ] = { { 1 , 3 } , { 2 , 4 } , { 1 , 9 } } ; int q = queries . length ; performQueries ( str , len , queries , q ) ; } }
class GFG { static int maxN = 20 ; static int maxM = 64 ; static int cntSplits ( String s ) { if ( s . charAt ( s . length ( ) - 1 ) == '1' ) return 0 ; int c_zero = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) c_zero += ( s . charAt ( i ) == '0' ) ? 1 : 0 ; return ( int ) Math . pow ( 2 , c_zero - 1 ) ; } public static void main ( String [ ] args ) { String s = "10010" ; System . out . println ( cntSplits ( s ) ) ; } }
import java . util . * ; class GFG { static String decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } String binary = " " ; for ( int j = i - 1 ; j >= 0 ; j -- ) { binary += String . valueOf ( binaryNum [ j ] ) ; } return binary ; } static int countFreq ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; } static void findOccurrence ( int arr [ ] , int n , String pattern ) { for ( int i = 0 ; i < n ; i ++ ) { String binary = decToBinary ( arr [ i ] ) ; System . out . print ( countFreq ( pattern , binary ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 106 , 7 , 8 } ; String pattern = "10" ; int n = arr . length ; findOccurrence ( arr , n , pattern ) ; } }
import java . util . Arrays ; class GFG { static void find_winner ( String str , int n ) { String str1 = " " , str2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { str1 += str . charAt ( i ) ; } else { str2 += str . charAt ( i ) ; } } char a [ ] = str1 . toCharArray ( ) ; Arrays . sort ( a ) ; char b [ ] = str2 . toCharArray ( ) ; Arrays . sort ( b ) ; str1 = new String ( a ) ; str2 = new String ( b ) ; if ( str1 . compareTo ( str2 ) < 0 ) System . out . print ( " A " ) ; else if ( str1 . compareTo ( str2 ) > 0 ) System . out . print ( " B " ) ; else System . out . print ( " Tie " ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; find_winner ( str , n ) ; } }
import java . util . * ; class GFG { static boolean isVowel ( char ch ) { ch = Character . toUpperCase ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } static String duplicateVowels ( String str ) { int t = str . length ( ) ; String res = " " ; for ( int i = 0 ; i < t ; i ++ ) { if ( isVowel ( str . charAt ( i ) ) ) res += str . charAt ( i ) ; res += str . charAt ( i ) ; } return res ; } public static void main ( String [ ] args ) { String str = " helloworld " ; System . out . println ( " Original ▁ String : ▁ " + str ) ; String res = duplicateVowels ( str ) ; System . out . println ( " String ▁ with ▁ Vowels ▁ duplicated : ▁ " + res ) ; } }
class GFG { public static String replacePi ( String s ) { if ( s . length ( ) == 0 || s . length ( ) == 1 ) return s ; if ( s . charAt ( 0 ) == ' p ' && s . charAt ( 1 ) == ' i ' ) { String smallOutput = replacePi ( s . substring ( 2 ) ) ; return "3.14" + smallOutput ; } else { String smallOutput = replacePi ( s . substring ( 1 ) ) ; return s . charAt ( 0 ) + smallOutput ; } } public static void main ( String [ ] args ) { String s = " pipppiiipi " ; String result = replacePi ( s ) ; System . out . println ( result ) ; } }
class GFG { static int MAX = 26 ; static int largestSubSeq ( String arr [ ] , int n ) { int [ ] count = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { String str = arr [ i ] ; boolean [ ] hash = new boolean [ MAX ] ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { hash [ str . charAt ( j ) - ' a ' ] = true ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( hash [ j ] ) count [ j ] ++ ; } } int max = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( max < count [ i ] ) max = count [ i ] ; } return max ; } public static void main ( String [ ] args ) { String arr [ ] = { " ab " , " bc " , " de " } ; int n = arr . length ; System . out . println ( largestSubSeq ( arr , n ) ) ; } }
import java . util . HashSet ; class GFG { static HashSet < String > stringSet = new HashSet < > ( ) ; public static void find_permutation ( String str1 , String str2 , int len1 , int len2 , int i , int j , String res ) { if ( res . length ( ) == len1 + len2 ) { stringSet . add ( res ) ; return ; } if ( i < len1 ) find_permutation ( str1 , str2 , len1 , len2 , i + 1 , j , res + str1 . charAt ( i ) ) ; if ( j < len2 ) find_permutation ( str1 , str2 , len1 , len2 , i , j + 1 , res + str2 . charAt ( j ) ) ; } public static void print_set ( ) { for ( String s : stringSet ) System . out . println ( s ) ; } public static void main ( String [ ] args ) { String str1 = " aa " , str2 = " ab " ; int len1 = str1 . length ( ) ; int len2 = str2 . length ( ) ; find_permutation ( str1 , str2 , len1 , len2 , 0 , 0 , " " ) ; print_set ( ) ; } }
class GFG { static int countSubStr ( char [ ] s , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 2 { if ( s [ i ] == '0' && s [ i + 1 ] == '1' && s [ i + 2 ] == '0' ) { count ++ ; i += 3 ; } else if ( s [ i ] == '1' && s [ i + 1 ] == '0' && s [ i + 2 ] == '1' ) { count ++ ; i += 3 ; } else { i ++ ; } } return count ; } public static void main ( String [ ] args ) { char [ ] s = "10101010101" . toCharArray ( ) ; int n = s . length ; System . out . println ( countSubStr ( s , n ) ) ; } }
import java . util . HashSet ; class geeks { public static int countTotalDistinct ( String str ) { int cnt = 0 ; HashSet < String > items = new HashSet < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { String temp = " " ; HashSet < Character > ans = new HashSet < > ( ) ; for ( int j = i ; j < str . length ( ) ; ++ j ) { temp = temp + str . charAt ( j ) ; ans . add ( str . charAt ( j ) ) ; if ( ! items . contains ( temp ) ) { items . add ( temp ) ; cnt += ans . size ( ) ; } } } return cnt ; } public static void main ( String [ ] args ) { String str = " ABCA " ; System . out . println ( countTotalDistinct ( str ) ) ; } }
import java . util . Arrays ; import java . util . Stack ; class GFG { static void reverse ( String k ) { Stack < String > s = new Stack < > ( ) ; String [ ] token = k . split ( " ▁ " ) ; for ( int i = 0 ; i < token . length ; i ++ ) { s . push ( token [ i ] ) ; } while ( ! s . empty ( ) ) { System . out . print ( s . peek ( ) + " ▁ " ) ; s . pop ( ) ; } } public static void main ( String [ ] args ) { String k = " geeks ▁ for ▁ geeks " ; reverse ( k ) ; } }
class GFG { static boolean isPalin ( int i , int j , int k , int l , int p , int q , String s ) { int start = i , end = q ; while ( start < end ) { if ( s . charAt ( start ) != s . charAt ( end ) ) { return false ; } start ++ ; if ( start == j + 1 ) { start = k ; } end -- ; if ( end == p - 1 ) { end = l ; } } return true ; } static int countSubStr ( String s ) { int count = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k ; l < n - 1 ; l ++ ) { for ( int p = l + 1 ; p < n ; p ++ ) { for ( int q = p ; q < n ; q ++ ) { if ( isPalin ( i , j , k , l , p , q , s ) ) { count ++ ; } } } } } } } return count ; } public static void main ( String [ ] args ) { String s = " abca " ; System . out . println ( countSubStr ( s ) ) ; } }
public class GFG { static final int MAX = 256 ; static String lastNonRepeating ( String str , int n ) { int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) ] ++ ; for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = str . charAt ( i ) ; if ( freq [ ch ] == 1 ) return ( " " + ch ) ; } return " - 1" ; } public static void main ( String [ ] args ) { String str = " GeeksForGeeks " ; int n = str . length ( ) ; System . out . println ( lastNonRepeating ( str , n ) ) ; } }
class GFG { static int N = 4 ; static int performQueries ( int l , int r , int prefix [ ] [ ] ) { l -- ; r -- ; boolean flag = false ; int count = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { int cnt = prefix [ r ] [ i ] ; if ( l > 0 ) cnt -= prefix [ l - 1 ] [ i ] ; if ( cnt % 2 == 1 ) { flag = true ; count += cnt - 1 ; } else count += cnt ; } if ( flag ) count += 1 ; return count ; } static void preCalculate ( String s , int prefix [ ] [ ] ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] [ s . charAt ( i ) - ' a ' ] ++ ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) prefix [ i ] [ j ] += prefix [ i - 1 ] [ j ] ; } } public static void main ( String args [ ] ) { String s = " amim " ; int prefix [ ] [ ] = new int [ N ] [ 26 ] ; preCalculate ( s , prefix ) ; int queries [ ] [ ] = { { 1 , 4 } , { 3 , 4 } } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( performQueries ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , prefix ) ) ; } } }
class GFG { static String FirstAndLast ( String str ) { char [ ] ch = str . toCharArray ( ) ; for ( int i = 0 ; i < ch . length ; i ++ ) { int k = i ; while ( i < ch . length && ch [ i ] != ' ▁ ' ) i ++ ; ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return new String ( ch ) ; } public static void main ( String args [ ] ) { String str = " Geeks ▁ for ▁ Geeks " ; System . out . println ( str ) ; System . out . println ( FirstAndLast ( str ) ) ; } }
class GFG { static int [ ] compute_lps ( String s ) { int n = s . length ( ) ; int [ ] lps = new int [ n ] ; int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } static void Longestsubstring ( String s ) { int [ ] lps = compute_lps ( s ) ; int n = s . length ( ) ; if ( lps [ n - 1 ] == 0 ) { System . out . println ( - 1 ) ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { System . out . println ( s . substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) System . out . println ( - 1 ) ; else System . out . println ( s . substring ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ) ; } public static void main ( String [ ] args ) { String s = " fixprefixsuffix " ; Longestsubstring ( s ) ; } }
class GFG { static String findMaxLenEven ( String str ) { int n = str . length ( ) ; int i = 0 ; int currlen = 0 ; int maxlen = 0 ; int st = - 1 ; while ( i < n ) { if ( str . charAt ( i ) == ' ▁ ' ) { if ( currlen % 2 == 0 ) { if ( maxlen < currlen ) { maxlen = currlen ; st = i - currlen ; } } currlen = 0 ; } else { currlen ++ ; } i ++ ; } if ( currlen % 2 == 0 ) { if ( maxlen < currlen ) { maxlen = currlen ; st = i - currlen ; } } if ( st == - 1 ) return " - 1" ; return str . substring ( st , st + maxlen ) ; } public static void main ( String args [ ] ) { String str = " this ▁ is ▁ a ▁ test ▁ string " ; System . out . println ( findMaxLenEven ( str ) ) ; } }
class GFG { static String findMinLenStr ( String str , int k ) { int n = str . length ( ) ; int st = 0 ; int end = 0 ; int cnt [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) cnt [ i ] = 0 ; int distEle = 0 ; int currlen ; int minlen = n ; int startInd = - 1 ; while ( end < n ) { cnt [ str . charAt ( end ) - ' a ' ] ++ ; if ( cnt [ str . charAt ( end ) - ' a ' ] == 1 ) distEle ++ ; if ( distEle > k ) { while ( st < end && distEle > k ) { if ( cnt [ str . charAt ( st ) - ' a ' ] == 1 ) distEle -- ; cnt [ str . charAt ( st ) - ' a ' ] -- ; st ++ ; } } if ( distEle == k ) { while ( st < end && cnt [ str . charAt ( st ) - ' a ' ] > 1 ) { cnt [ str . charAt ( st ) - ' a ' ] -- ; st ++ ; } currlen = end - st + 1 ; if ( currlen < minlen ) { minlen = currlen ; startInd = st ; } } end ++ ; } return str . substring ( startInd , startInd + minlen ) ; } public static void main ( String args [ ] ) { String str = " efecfefd " ; int k = 4 ; System . out . println ( findMinLenStr ( str , k ) ) ; } }
class GfG { static int totalPairs ( String s1 , String s2 ) { int a1 = 0 , b1 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( ( int ) s1 . charAt ( i ) % 2 != 0 ) a1 ++ ; else b1 ++ ; } int a2 = 0 , b2 = 0 ; for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { if ( ( int ) s2 . charAt ( i ) % 2 != 0 ) a2 ++ ; else b2 ++ ; } return ( ( a1 * a2 ) + ( b1 * b2 ) ) ; } public static void main ( String [ ] args ) { String s1 = " geeks " , s2 = " for " ; System . out . println ( totalPairs ( s1 , s2 ) ) ; } }
import java . util . * ; class GFG { static int Preprocess ( String A , String B ) { int n = A . length ( ) ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { HashMap < Character , Integer > mp = new HashMap < > ( ) ; if ( mp . containsKey ( A . charAt ( i ) ) ) mp . put ( A . charAt ( i ) , mp . get ( A . charAt ( i ) ) + 1 ) ; else mp . put ( A . charAt ( i ) , 1 ) ; if ( mp . containsKey ( A . charAt ( n - i - 1 ) ) ) mp . put ( A . charAt ( n - i - 1 ) , mp . get ( A . charAt ( n - i - 1 ) ) + 1 ) ; else mp . put ( A . charAt ( n - i - 1 ) , 1 ) ; if ( mp . containsKey ( B . charAt ( i ) ) ) mp . put ( B . charAt ( i ) , mp . get ( B . charAt ( i ) ) + 1 ) ; else mp . put ( B . charAt ( i ) , 1 ) ; if ( mp . containsKey ( B . charAt ( n - i - 1 ) ) ) mp . put ( B . charAt ( n - i - 1 ) , mp . get ( B . charAt ( n - i - 1 ) ) + 1 ) ; else mp . put ( B . charAt ( n - i - 1 ) , 1 ) ; int sz = mp . size ( ) ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A . charAt ( i ) == A . charAt ( n - i - 1 ) ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp . get ( A . charAt ( i ) ) != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A . charAt ( n / 2 ) != B . charAt ( n / 2 ) ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { String A = " abacaba " , B = " bacabaa " ; System . out . println ( Preprocess ( A , B ) ) ; } }
class GFG { static void printPattern ( char [ ] s , int n ) { System . out . println ( s ) ; int i = 0 , j = n - 1 ; while ( i < j ) { char c = s [ i ] ; s [ i ] = s [ j ] ; s [ j ] = c ; i ++ ; j -- ; } i = 0 ; j = n - 1 ; while ( j - i > 1 ) { s [ i ] = s [ j ] = ' * ' ; System . out . println ( s ) ; i ++ ; j -- ; } } public static void main ( String [ ] args ) { char [ ] s = " geeks " . toCharArray ( ) ; int n = s . length ; printPattern ( s , n ) ; } }
class GfG { static char bitToBeFlipped ( String s ) { char last = s . charAt ( s . length ( ) - 1 ) ; char first = s . charAt ( 0 ) ; if ( last == first ) { if ( last == '0' ) { return '1' ; } else { return '0' ; } } else if ( last != first ) { return last ; } return last ; } public static void main ( String [ ] args ) { String s = "1101011000" ; System . out . println ( bitToBeFlipped ( s ) ) ; } }
class GFG { static boolean check ( String s ) { int [ ] freq = new int [ 26 ] ; int n = s . length ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { freq [ ( s . charAt ( i ) ) - 97 ] += 1 ; } for ( int i = 0 ; i < freq . length ; i ++ ) { if ( freq [ i ] % 2 == 1 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String s = " abaccaba " ; if ( check ( s ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; class GFG { static void solve ( String s ) { HashMap < Character , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . containsKey ( s . charAt ( i ) ) ) m . put ( s . charAt ( i ) , m . get ( s . charAt ( i ) ) + 1 ) ; else m . put ( s . charAt ( i ) , 1 ) ; } String new_string = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( m . get ( s . charAt ( i ) ) % 2 == 0 ) continue ; new_string = new_string + s . charAt ( i ) ; } System . out . println ( new_string ) ; } public static void main ( String [ ] args ) { String s = " aabbbddeeecc " ; solve ( s ) ; } }
import java . io . * ; class GFG { static int minimumLength ( String s ) { int maxOcc = 0 , n = s . length ( ) ; int arr [ ] = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( arr [ i ] > maxOcc ) maxOcc = arr [ i ] ; return ( n - maxOcc ) ; } public static void main ( String [ ] args ) { String str = " afddewqd " ; System . out . println ( minimumLength ( str ) ) ; } }
import java . util . * ; class GFG { static final int MAX = Integer . MAX_VALUE ; static int minOperation ( String s , int i , int j , int count ) { if ( ( i >= s . length ( ) && j < 0 ) || ( i == j ) ) return MAX ; if ( s . charAt ( i ) == s . charAt ( j ) ) return count ; if ( i >= s . length ( ) ) return minOperation ( s , i , j - 1 , count + 1 ) ; else if ( j < 0 ) return minOperation ( s , i + 1 , j , count + 1 ) ; else return Math . min ( minOperation ( s , i , j - 1 , count + 1 ) , minOperation ( s , i + 1 , j , count + 1 ) ) ; } public static void main ( String [ ] args ) { String s = " bacdefghipalop " ; int ans = minOperation ( s , 0 , s . length ( ) - 1 , 0 ) ; if ( ans == MAX ) System . out . println ( - 1 ) ; else System . out . println ( ans ) ; } }
class GFG { final int MAX_CHAR = 26 ; static void frequency ( int fre [ ] [ ] , String s [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { String str = s [ i ] ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) fre [ i ] [ str . charAt ( j ) - ' a ' ] ++ ; } } static void LongestSequence ( int fre [ ] [ ] , int n ) { for ( int i = 24 ; i >= 0 ; i -- ) { int mi = fre [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; j ++ ) mi = Math . min ( fre [ j ] [ i ] , mi ) ; while ( mi -- != 0 ) System . out . print ( ( char ) ( ' a ' + i ) ) ; } } public static void main ( String args [ ] ) { String s [ ] = { " loo " , " lol " , " olive " } ; int n = s . length ; int fre [ ] [ ] = new int [ n ] [ 26 ] ; frequency ( fre , s , n ) ; LongestSequence ( fre , n ) ; } }
class GFG { static void minimumFlip ( String s , int x , int y ) { s = s + s ; boolean isOpposite = false ; if ( x > y ) { swap ( x , y ) ; isOpposite = true ; } int valClockwise = 0 ; char cur = s . charAt ( x ) ; for ( int i = x ; i <= y ; i ++ ) { if ( s . charAt ( i ) != cur ) { cur = s . charAt ( i ) ; valClockwise ++ ; } } int valAnticlockwise = 0 ; cur = s . charAt ( y ) ; x += s . length ( ) ; for ( int i = y ; i < x ; i ++ ) { if ( s . charAt ( i ) != cur ) { cur = s . charAt ( i ) ; valAnticlockwise ++ ; } } if ( valClockwise <= valAnticlockwise ) { if ( ! isOpposite ) { System . out . println ( " Clockwise ▁ " + valClockwise ) ; } else { System . out . println ( " Anti - clockwise ▁ " + valAnticlockwise ) ; } } else if ( ! isOpposite ) { System . out . println ( " Anti - clockwise ▁ " + valAnticlockwise ) ; } else { System . out . println ( " Clockwise ▁ " + valClockwise ) ; } } static void swap ( int a , int b ) { int c = a ; a = b ; b = c ; } public static void main ( String [ ] args ) { int x = 0 , y = 8 ; String s = "000110" ; minimumFlip ( s , x , y ) ; } }
import java . io . * ; import java . util . * ; class GFG { static String LexicographicalMaxString ( String str ) { char maxchar = ' a ' ; ArrayList < Integer > index = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) >= maxchar ) { maxchar = str . charAt ( i ) ; index . add ( i ) ; } } String maxstring = " " ; for ( int i = 0 ; i < index . size ( ) ; i ++ ) { if ( str . substring ( index . get ( i ) , str . length ( ) ) . compareTo ( maxstring ) > 0 ) { maxstring = str . substring ( index . get ( i ) , str . length ( ) ) ; } } return maxstring ; } public static void main ( String [ ] args ) { String str = " acbacbc " ; System . out . println ( LexicographicalMaxString ( str ) ) ; } }
class GFG { static class Node { String c ; Node next ; } ; static Node newNode ( String c ) { Node temp = new Node ( ) ; temp . c = c ; temp . next = null ; return temp ; } ; static String reverse_word ( String str ) { String s = " " ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) s = str . charAt ( i ) + s ; return s ; } static Node reverse ( Node head ) { Node ptr = head ; while ( ptr != null ) { ptr . c = reverse_word ( ptr . c ) ; ptr = ptr . next ; } return head ; } static void printList ( Node head ) { while ( head != null ) { System . out . print ( head . c + " ▁ " ) ; head = head . next ; } } public static void main ( String args [ ] ) { Node head = newNode ( " Geeksforgeeks " ) ; head . next = newNode ( " a " ) ; head . next . next = newNode ( " computer " ) ; head . next . next . next = newNode ( " science " ) ; head . next . next . next . next = newNode ( " portal " ) ; head . next . next . next . next . next = newNode ( " for " ) ; head . next . next . next . next . next . next = newNode ( " geeks " ) ; System . out . print ( "List before reverse: NEW_LINE"); printList ( head ) ; head = reverse ( head ) ; System . out . print ( " List after reverse : "); printList ( head ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static String s = " " ; static String ReverseString ( String s ) { char [ ] arr = s . toCharArray ( ) ; for ( int i = 0 ; i < arr . length / 2 ; i ++ ) { char temp = arr [ i ] ; arr [ i ] = arr [ arr . length - i - 1 ] ; arr [ arr . length - i - 1 ] = temp ; } return new String ( arr ) ; } static void binary_conversion ( int m ) { while ( m != 0 ) { int tmp = m % 2 ; s += Integer . toString ( tmp ) ; m = ( int ) ( m / 2 ) ; } s = ReverseString ( s ) ; } static int find_character ( int n , int m , int i ) { binary_conversion ( m ) ; String s1 = " " ; for ( int x = 0 ; x < n ; x ++ ) { for ( int y = 0 ; y < s . length ( ) ; y ++ ) { if ( s . charAt ( y ) == '1' ) s1 += "10" ; else s1 += "01" ; } s = s1 ; s1 = " " ; } return s . charAt ( i ) - '0' ; } public static void main ( String args [ ] ) { int m = 5 , n = 2 , i = 8 ; System . out . print ( find_character ( n , m , i ) ) ; } }
import java . io . * ; class GFG { static int findSubSequence ( String s , int num ) { int res = 0 ; int i = 0 ; while ( num > 0 ) { if ( ( num & 1 ) == 1 ) res += s . charAt ( i ) - '0' ; i ++ ; num = num >> 1 ; } return res ; } static int combinedSum ( String s ) { int n = s . length ( ) ; int c_sum = 0 ; int range = ( 1 << n ) - 1 ; for ( int i = 0 ; i <= range ; i ++ ) c_sum += findSubSequence ( s , i ) ; return c_sum ; } public static void main ( String [ ] args ) { String s = "123" ; System . out . println ( combinedSum ( s ) ) ; } }
import java . io . * ; class GFG { public static void solve ( String s ) { int l = s . length ( ) ; int x = l / 2 ; int y = l ; String p = " " ; while ( x > 0 && y > l / 2 ) { char ch = s . charAt ( x - 1 ) ; p += ch ; x -- ; ch = s . charAt ( y - 1 ) ; p += ch ; y -- ; } if ( y > l / 2 ) { char ch = s . charAt ( x - 1 ) ; p += ch ; y -- ; } System . out . println ( p ) ; } public static void main ( String args [ ] ) { String s = " sunshine " ; solve ( s ) ; } }
class GFG { static final int MAX = 26 ; static void printAnagramAndChanges ( char [ ] X , char [ ] Y ) { int countx [ ] = new int [ MAX ] , county [ ] = new int [ MAX ] , ctrx [ ] = new int [ MAX ] , ctry [ ] = new int [ MAX ] ; int change = 0 ; int l = X . length ; for ( int i = 0 ; i < l ; i ++ ) { countx [ X [ i ] - ' A ' ] ++ ; county [ Y [ i ] - ' A ' ] ++ ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( countx [ i ] > county [ i ] ) { ctrx [ i ] += ( countx [ i ] - county [ i ] ) ; } else if ( countx [ i ] < county [ i ] ) { ctry [ i ] += ( county [ i ] - countx [ i ] ) ; } change += Math . abs ( county [ i ] - countx [ i ] ) ; } for ( int i = 0 ; i < l ; i ++ ) { if ( ctrx [ X [ i ] - ' A ' ] == 0 ) { continue ; } int j ; for ( j = 0 ; j < MAX ; j ++ ) { if ( ( ctry [ j ] ) > 0 ) { break ; } } if ( countx [ X [ i ] - ' A ' ] == ctrx [ X [ i ] - ' A ' ] X [ i ] - ' A ' > j ) { countx [ X [ i ] - ' A ' ] -- ; ctrx [ X [ i ] - ' A ' ] -- ; ctry [ j ] -- ; X [ i ] = ( char ) ( ' A ' + j ) ; } else { countx [ X [ i ] - ' A ' ] -- ; } } System . out . println ( " Anagram ▁ : ▁ " + String . valueOf ( X ) ) ; System . out . println ( " Number ▁ of ▁ changes ▁ made ▁ : ▁ " + change / 2 ) ; } public static void main ( String [ ] args ) { String x = " CDBABC " , y = " ADCABD " ; printAnagramAndChanges ( x . toCharArray ( ) , y . toCharArray ( ) ) ; } }
import java . io . * ; class GFG { static int countOccurrences ( String str , String word ) { String a [ ] = str . split ( " ▁ " ) ; int count = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { if ( word . equals ( a [ i ] ) ) count ++ ; } return count ; } public static void main ( String args [ ] ) { String str = " GeeksforGeeks ▁ A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks ▁ " ; String word = " portal " ; System . out . println ( countOccurrences ( str , word ) ) ; } }
import java . util . * ; class GFG { static Vector < String > splitStrings ( String str , char dl ) { String word = " " ; int num = 0 ; str = str + dl ; int l = str . length ( ) ; Vector < String > substr_list = new Vector < String > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( str . charAt ( i ) != dl ) { word = word + str . charAt ( i ) ; } else { if ( ( int ) word . length ( ) != 0 ) { substr_list . add ( word ) ; } word = " " ; } } return substr_list ; } public static void main ( String [ ] args ) { String str = " geeks ; for ; geeks " ; char dl = ' ; ' ; Vector < String > res = splitStrings ( str , dl ) ; for ( String x : res ) { System . out . println ( x ) ; } } }
class GFG { public static int longestSubseq ( String s ) { int n = s . length ( ) ; int [ ] pre_count_0 = new int [ n + 2 ] ; int [ ] pre_count_1 = new int [ n + 1 ] ; int [ ] post_count_0 = new int [ n + 2 ] ; pre_count_0 [ 0 ] = 0 ; post_count_0 [ n + 1 ] = 0 ; pre_count_1 [ 0 ] = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { pre_count_0 [ j ] = pre_count_0 [ j - 1 ] ; pre_count_1 [ j ] = pre_count_1 [ j - 1 ] ; post_count_0 [ n - j + 1 ] = post_count_0 [ n - j + 2 ] ; if ( s . charAt ( j - 1 ) == '0' ) pre_count_0 [ j ] ++ ; else pre_count_1 [ j ] ++ ; if ( s . charAt ( n - j ) == '0' ) post_count_0 [ n - j + 1 ] ++ ; } if ( pre_count_0 [ n ] == n pre_count_0 [ n ] == 0 ) return n ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) ans = Math . max ( pre_count_0 [ i - 1 ] + pre_count_1 [ j ] - pre_count_1 [ i - 1 ] + post_count_0 [ j + 1 ] , ans ) ; return ans ; } public static void main ( String [ ] args ) { String s = "000011100000" ; System . out . println ( longestSubseq ( s ) ) ; } }
public class GFG { static boolean shouldSwap ( char str [ ] , int start , int curr ) { for ( int i = start ; i < curr ; i ++ ) { if ( str [ i ] == str [ curr ] ) { return false ; } } return true ; } static void findPermutations ( char str [ ] , int index , int n ) { if ( index >= n ) { System . out . println ( str ) ; return ; } for ( int i = index ; i < n ; i ++ ) { boolean check = shouldSwap ( str , index , i ) ; if ( check ) { swap ( str , index , i ) ; findPermutations ( str , index + 1 , n ) ; swap ( str , index , i ) ; } } } static void swap ( char [ ] str , int i , int j ) { char c = str [ i ] ; str [ i ] = str [ j ] ; str [ j ] = c ; } public static void main ( String [ ] args ) { char str [ ] = { ' A ' , ' B ' , ' C ' , ' A ' } ; int n = str . length ; findPermutations ( str , 0 , n ) ; } }
import java . io . * ; public class GFG { static int MAX_CHAR = 256 ; static int maximumChars ( String str ) { int n = str . length ( ) ; int res = - 1 ; int [ ] firstInd = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) firstInd [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int first_ind = firstInd [ str . charAt ( i ) ] ; if ( first_ind == - 1 ) firstInd [ str . charAt ( i ) ] = i ; else res = Math . max ( res , Math . abs ( i - first_ind - 1 ) ) ; } return res ; } static public void main ( String [ ] args ) { String str = " abba " ; System . out . println ( maximumChars ( str ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static boolean isValid ( String p ) { int n = p . length ( ) ; int c1 = 0 , c0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p . charAt ( i ) == '0' ) { c0 ++ ; } if ( p . charAt ( i ) == '1' ) { c1 ++ ; } } if ( c0 == c1 ) { return true ; } else { return false ; } } public static int longestSub ( String s ) { int max_len = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( isValid ( s . substring ( i , j + 1 ) ) && max_len < j - i + 1 ) { max_len = j - i + 1 ; } } } return max_len ; } public static void main ( String [ ] args ) { String s = "101001000" ; System . out . println ( longestSub ( s ) ) ; } }
class GFG { final static int MAX_CHAR = 256 ; static void printDuo ( String str ) { int countChar [ ] = new int [ MAX_CHAR ] ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { countChar [ str . charAt ( i ) - ' a ' ] ++ ; } String str1 = " " , str2 = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( countChar [ i ] > 1 ) { str2 = str2 + ( char ) ( i + ' a ' ) ; } else if ( countChar [ i ] == 1 ) { str1 = str1 + ( char ) ( i + ' a ' ) ; } } System . out . print ( " String ▁ with ▁ characters ▁ occurring ▁ " + "once:NEW_LINE"); System . out . print ( str1 + "NEW_LINE"); System . out . print ( " String ▁ with ▁ characters ▁ occurring ▁ " + "multiple times:NEW_LINE"); System . out . print ( str2 + "NEW_LINE"); System . out . print ( " " ) ; } public static void main ( String [ ] args ) { String str = " lovetocode " ; printDuo ( str ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int findRepeatFirstN2 ( String s ) { int p = - 1 , i , j ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { for ( j = i + 1 ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( i ) == s . charAt ( j ) ) { p = i ; break ; } } if ( p != - 1 ) break ; } return p ; } static public void main ( String [ ] args ) { String str = " geeksforgeeks " ; int pos = findRepeatFirstN2 ( str ) ; if ( pos == - 1 ) System . out . println ( " Not ▁ found " ) ; else System . out . println ( str . charAt ( pos ) ) ; } }
public class First_Palin { static final int MAX_CHAR = 26 ; static char stringPalindrome ( String A , String B ) { int [ ] countA = new int [ MAX_CHAR ] ; int [ ] countB = new int [ MAX_CHAR ] ; int l1 = A . length ( ) ; int l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' A ' ; return ' B ' ; } public static void main ( String args [ ] ) { String a = " abcdea " ; String b = " bcdesg " ; System . out . println ( stringPalindrome ( a , b ) ) ; } }
public class GFG { static int findLen ( String A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ; while ( r < n ) { if ( A . charAt ( r ) != ch ) ++ cnt ; while ( cnt > k ) { if ( A . charAt ( l ) != ch ) -- cnt ; ++ l ; } maxlen = Math . max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; } static int answer ( String A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = Math . max ( maxlen , findLen ( A , n , k , ( char ) ( i + ' A ' ) ) ) ; maxlen = Math . max ( maxlen , findLen ( A , n , k , ( char ) ( i + ' a ' ) ) ) ; } return maxlen ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; String A = " ABABA " ; System . out . println ( " Maximum ▁ length ▁ = ▁ " + answer ( A , n , k ) ) ; n = 6 ; k = 4 ; String B = " HHHHHH " ; System . out . println ( " Maximum ▁ length ▁ = ▁ " + answer ( B , n , k ) ) ; } }
class GFG { static int replaceDig ( int x , int from , int to ) { int result = 0 ; int multiply = 1 ; while ( x > 0 ) { int reminder = x % 10 ; if ( reminder == from ) result = result + to * multiply ; else result = result + reminder * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; } static void calculateMinMaxSum ( int x1 , int x2 ) { int minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) ; int maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) ; System . out . print ( " Minimum ▁ sum ▁ = ▁ " + minSum ) ; System . out . print ( " Maximum sum = " + maxSum); } public static void main ( String [ ] args ) { int x1 = 5466 , x2 = 4555 ; calculateMinMaxSum ( x1 , x2 ) ; } }
class Test { static String findTwoscomplement ( StringBuffer str ) { int n = str . length ( ) ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == '1' ) break ; if ( i == - 1 ) return "1" + str ; for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == '1' ) str . replace ( k , k + 1 , "0" ) ; else str . replace ( k , k + 1 , "1" ) ; } return str . toString ( ) ; } public static void main ( String [ ] args ) { StringBuffer str = new StringBuffer ( "00000101" ) ; System . out . println ( findTwoscomplement ( str ) ) ; } }
import java . util . * ; class GFG { static int isPerfect ( int x ) { int sum_div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; } static void subsetSum ( int arr [ ] , int n ) { long total = 1 << n ; for ( long i = 0 ; i < total ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( i & ( 1 << j ) ) != 0 ) sum += arr [ j ] ; if ( isPerfect ( sum ) != 0 ) { System . out . print ( sum + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 4 , 6 } ; int N = arr . length ; subsetSum ( arr , N ) ; } }
import java . util . * ; class GFG { static void checkUntil ( int num , int K , int N , Vector < Integer > ans ) { if ( N == 1 ) { ans . add ( num ) ; return ; } if ( ( num % 10 + K ) <= 9 ) checkUntil ( 10 * num + ( num % 10 + K ) , K , N - 1 , ans ) ; if ( K > 0 ) { if ( ( num % 10 - K ) >= 0 ) checkUntil ( 10 * num + num % 10 - K , K , N - 1 , ans ) ; } } static void check ( int K , int N , Vector < Integer > ans ) { for ( int i = 1 ; i <= 9 ; i ++ ) { checkUntil ( i , K , N , ans ) ; } } static void print ( Vector < Integer > ans ) { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " , ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 4 , K = 8 ; Vector < Integer > ans = new Vector < Integer > ( ) ; ; check ( K , N , ans ) ; print ( ans ) ; } }
class GFG { static int N = 4 ; static void printSolution ( int sol [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { System . out . printf ( " ▁ % d ▁ " , sol [ i ] [ j ] ) ; } System . out . printf ( "NEW_LINE"); } } static boolean isSafe ( int maze [ ] [ ] , int x , int y ) { if ( x >= 0 && x < N && y >= 0 && y < N && maze [ x ] [ y ] != 0 ) { return true ; } return false ; } static boolean solveMaze ( int maze [ ] [ ] ) { int sol [ ] [ ] = { { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; if ( solveMazeUtil ( maze , 0 , 0 , sol ) == false ) { System . out . printf ( " Solution ▁ doesn ' t ▁ exist " ) ; return false ; } printSolution ( sol ) ; return true ; } static boolean solveMazeUtil ( int maze [ ] [ ] , int x , int y , int sol [ ] [ ] ) { if ( x == N - 1 && y == N - 1 ) { sol [ x ] [ y ] = 1 ; return true ; } if ( isSafe ( maze , x , y ) == true ) { sol [ x ] [ y ] = 1 ; for ( int i = 1 ; i <= maze [ x ] [ y ] && i < N ; i ++ ) { if ( solveMazeUtil ( maze , x + i , y , sol ) == true ) { return true ; } if ( solveMazeUtil ( maze , x , y + i , sol ) == true ) { return true ; } } sol [ x ] [ y ] = 0 ; return false ; } return false ; } public static void main ( String [ ] args ) { int maze [ ] [ ] = { { 2 , 1 , 0 , 0 } , { 3 , 0 , 0 , 1 } , { 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 1 } } ; solveMaze ( maze ) ; } }
class GFG { static final int maxSize = 50 ; static double [ ] [ ] matrix_product ( double [ ] [ ] a , double [ ] [ ] b ) { double [ ] [ ] c = new double [ 7 ] [ 7 ] ; for ( int i = 0 ; i < 7 ; i ++ ) for ( int j = 0 ; j < 7 ; j ++ ) for ( int k = 0 ; k < 7 ; k ++ ) c [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; return c ; } static double [ ] [ ] mul_expo ( double [ ] [ ] mul , int p ) { double [ ] [ ] s = { { 1 , 0 , 0 , 0 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } } ; while ( p != 1 ) { if ( p % 2 == 1 ) s = matrix_product ( s , mul ) ; mul = matrix_product ( mul , mul ) ; p /= 2 ; } return matrix_product ( mul , s ) ; } static double expectedSteps ( int x ) { if ( x == 0 ) return 0 ; if ( x <= 6 ) return 6 ; double [ ] [ ] mul = { { ( double ) 7 / 6 , 1 , 0 , 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 , 0 , 0 , 0 } , { 0 , 0 , 0 , 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { ( double ) - 1 / 6 , 0 , 0 , 0 , 0 , 0 , 0 } } ; mul = mul_expo ( mul , x - 6 ) ; return ( mul [ 0 ] [ 0 ] + mul [ 1 ] [ 0 ] + mul [ 2 ] [ 0 ] + mul [ 3 ] [ 0 ] + mul [ 4 ] [ 0 ] + mul [ 5 ] [ 0 ] ) * 6 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . printf ( " % .5f " , expectedSteps ( n - 1 ) ) ; } }
class GFG { static long F ( long A , long B ) { if ( A == 1 ) return ( 4 % B ) ; else { long temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } } public static void main ( String args [ ] ) { long A = 25 , B = 50 ; System . out . println ( F ( A , B ) ) ; } }
import java . io . * ; class GFG { static int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 } ; int n = arr . length ; int index = binarySearch ( arr , 1 , n - 2 ) ; if ( index != - 1 ) System . out . println ( arr [ index ] ) ; } }
import java . io . * ; class GFG { static int isPossibleToReach ( int [ ] A , int N , int X , int Y ) { double distance = Math . sqrt ( ( X * X + Y * Y ) ) ; double mx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { mx += ( A [ i ] ) ; } if ( mx < distance ) { System . out . print ( " NO " ) ; return 0 ; } if ( ( mx - distance ) < 0.000001 ) { System . out . print ( " YES " ) ; return 0 ; } for ( int i = 0 ; i < N ; i ++ ) { if ( distance + mx < 2 * A [ i ] ) { System . out . print ( " No " ) ; return 0 ; } } System . out . print ( " Yes " ) ; return 0 ; } public static void main ( String [ ] args ) { int [ ] A = { 2 , 5 } ; int X = 5 , Y = 4 ; int N = A . length ; isPossibleToReach ( A , N , X , Y ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static double point_distance ( int x1 , int y1 , int x2 , int y2 ) { int p = ( x2 - x1 ) ; int q = ( y2 - y1 ) ; double distance = Math . sqrt ( p * p + q * q ) ; return distance ; } static void tangentAngle ( int x1 , int y1 , int x2 , int y2 , double radius ) { double distance = point_distance ( x1 , y1 , x2 , y2 ) ; if ( radius / distance > 1 radius / distance < - 1 ) { System . out . println ( - 1 ) ; } double result = 2 * Math . asin ( radius / distance ) * 180 / 3.1415 ; System . out . println ( String . format ( " % .4f " , result ) + " ▁ degrees " ) ; } public static void main ( String [ ] args ) { int radius = 4 ; int x1 = 7 , y1 = 12 ; int x2 = 3 , y2 = 4 ; tangentAngle ( x1 , y1 , x2 , y2 , radius ) ; } }
class GFG { static final double RADIAN = 0.01745329252 ; static double Area_of_Rhombus ( int a , int theta ) { double area = ( a * a ) * Math . sin ( ( RADIAN * theta ) ) ; return area ; } public static void main ( String [ ] args ) { int a = 4 ; int theta = 60 ; double ans = Area_of_Rhombus ( a , theta ) ; System . out . printf ( " % .2f " , ans ) ; } }
class GFG { static double Length_Diagonal ( int a , int b , double theta ) { double diagonal = Math . sqrt ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) - 2 * a * b * Math . cos ( theta * ( Math . PI / 180 ) ) ) ; return diagonal ; } public static void main ( String [ ] args ) { int a = 3 ; int b = 5 ; double theta = 45 ; double ans = Length_Diagonal ( a , b , theta ) ; System . out . printf ( " % .2f " , ans ) ; } }
import java . util . * ; class GFG { static void maximumTiles ( int n , int m ) { System . out . println ( ( m * n ) / 2 ) ; } public static void main ( String [ ] args ) { int M = 3 ; int N = 4 ; maximumTiles ( N , M ) ; } }
class GFG { static double find ( double x , double y , int [ ] [ ] p ) { double mind = 0 ; for ( int i = 0 ; i < p . length ; i ++ ) { double a = p [ i ] [ 0 ] , b = p [ i ] [ 1 ] ; mind += Math . sqrt ( ( x - a ) * ( x - a ) + ( y - b ) * ( y - b ) ) ; } return mind ; } static double getMinDistSum ( int [ ] [ ] p ) { double x = 0 , y = 0 ; for ( int i = 0 ; i < p . length ; i ++ ) { x += p [ i ] [ 0 ] ; y += p [ i ] [ 1 ] ; } x = x / p . length ; y = y / p . length ; double mind = find ( x , y , p ) ; return mind ; } public static void main ( String [ ] args ) { int [ ] [ ] vec = { { 0 , 1 } , { 1 , 0 } , { 1 , 2 } , { 2 , 1 } } ; double d = getMinDistSum ( vec ) ; System . out . print ( d + "NEW_LINE"); } }
class GFG { static int nCr ( int n , int r ) { return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; } static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i < n + 1 ; i ++ ) res = res * i ; return res ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( nCr ( n , 4 ) ) ; } }
import java . io . * ; class GFG { static int areaSquare ( int L , int B ) { int large = Math . max ( L , B ) ; int small = Math . min ( L , B ) ; if ( large >= 2 * small ) { return large * large ; } else { return ( 2 * small ) * ( 2 * small ) ; } } public static void main ( String [ ] args ) { int L = 7 ; int B = 4 ; System . out . println ( areaSquare ( L , B ) ) ; } }
class GFG { static double pie = 3.1415926535897 ; static double findsolution ( double d , double h , double m , double n ) { double k = ( 4 * m ) / ( pie * d * d ) ; if ( n > k ) return - 1 ; double ans = ( h / ( k - n ) ) ; return ans ; } public static void main ( String [ ] args ) { double d = 1 , h = 1 , m = 1 , n = 1 ; System . out . printf ( " % .5f " , findsolution ( d , h , m , n ) ) ; } }
import java . io . * ; class GFG { static int angle ( int n ) { return 2 * n ; } public static void main ( String [ ] args ) { int n = 30 ; System . out . println ( angle ( n ) ) ; } }
class GFG { public static int Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; } public static void main ( String [ ] args ) { int a = 80 , b = 70 , c = 100 , d = 110 ; if ( Valid ( a , b , c , d ) == 1 ) System . out . println ( " Valid ▁ quadrilateral " ) ; else System . out . println ( " Invalid ▁ quadrilateral " ) ; } }
import java . io . * ; class GFG { static void lengchord ( int z ) { System . out . println ( " The ▁ length ▁ is ▁ " + z ) ; } public static void main ( String [ ] args ) { int z = 48 ; lengchord ( z ) ; } }
import java . util . * ; class GFG { static int countPairs ( int a [ ] , int n ) { int count = 0 ; HashMap < Double , Integer > mp = new HashMap < Double , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { double y = a [ i ] ; if ( y != 0 && y != 1 ) { double x = ( ( y * 1.0 ) / ( 1 - y ) ) * y ; if ( mp . containsKey ( x ) ) count += mp . get ( x ) ; } if ( mp . containsKey ( y ) ) { mp . put ( y , mp . get ( y ) + 1 ) ; } else { mp . put ( y , 1 ) ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { - 4 , - 3 , 0 , 2 , 1 } ; int N = arr . length ; System . out . print ( countPairs ( arr , N ) ) ; } }
import java . util . * ; public class GFG { static boolean contains ( int num , int K , int Base ) { boolean isThere = false ; while ( num > 0 ) { int remainder = num % Base ; if ( remainder == K ) { isThere = true ; } num /= Base ; } return isThere ; } static void count ( int n , int k , Vector < Vector < Integer > > v ) { int [ ] pref = new int [ 1000005 ] ; for ( int i = 1 ; i < 1e6 + 5 ; i ++ ) { boolean present = contains ( i , k , 10 ) || contains ( i , k , 8 ) ; if ( present ) { pref [ i ] += pref [ i - 1 ] + 1 ; } } System . out . print ( ( v . get ( 0 ) . get ( 1 ) - v . get ( 0 ) . get ( 0 ) + 1 - ( pref [ v . get ( 0 ) . get ( 1 ) ] - pref [ v . get ( 0 ) . get ( 0 ) - 1 ] ) ) + " ▁ " ) ; System . out . print ( ( v . get ( 1 ) . get ( 1 ) - v . get ( 1 ) . get ( 0 ) - ( pref [ v . get ( 1 ) . get ( 1 ) ] - pref [ v . get ( 1 ) . get ( 0 ) - 1 ] ) ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int K = 7 ; Vector < Vector < Integer > > Q = new Vector < Vector < Integer > > ( ) ; Q . add ( new Vector < Integer > ( ) ) ; Q . get ( 0 ) . add ( 2 ) ; Q . get ( 0 ) . add ( 5 ) ; Q . add ( new Vector < Integer > ( ) ) ; Q . get ( 1 ) . add ( 1 ) ; Q . get ( 1 ) . add ( 15 ) ; int N = Q . size ( ) ; count ( N , K , Q ) ; } }
import java . util . * ; class GFG { static int pronic ( int num ) { int N = ( int ) Math . sqrt ( num ) ; if ( N * ( N + 1 ) <= num ) { return N ; } return N - 1 ; } static int countPronic ( int A , int B ) { return pronic ( B ) - pronic ( A - 1 ) ; } public static void main ( String [ ] args ) { int A = 3 ; int B = 20 ; System . out . print ( countPronic ( A , B ) ) ; } }
import java . util . * ; class GFG { static int minimumMoves ( int [ ] a , int n ) { int min_element = Integer . MAX_VALUE ; int max_element = Integer . MIN_VALUE ; int min_ind = - 1 ; int max_ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] <= min_element ) { min_element = a [ i ] ; min_ind = i ; } if ( a [ i ] > max_element ) { max_element = a [ i ] ; max_ind = i ; } } if ( max_ind == min_ind ) { return 0 ; } else if ( max_ind > min_ind ) { return max_ind + ( n - min_ind - 2 ) ; } else { return max_ind + n - min_ind - 1 ; } } public static void main ( String [ ] args ) { int arr [ ] = { 35 , 46 , 17 , 23 } ; int N = arr . length ; System . out . print ( minimumMoves ( arr , N ) + "NEW_LINE"); } }
import java . util . * ; class GFG { static int findIndex ( int arr [ ] , int n , int K ) { int sum = 0 ; int res = - 1 ; int mini = ( int ) 1e9 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { int temp = sum - arr [ i ] ; if ( temp % K == 0 ) { if ( res == - 1 mini > arr [ i ] ) { res = i + 1 ; mini = arr [ i ] ; } } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 14 , 7 , 8 , 2 , 4 } ; int K = 7 ; int N = arr . length ; System . out . print ( findIndex ( arr , N , K ) ) ; } }
import java . util . * ; class GFG { static int countSetBits ( int N ) { int count = 0 ; while ( N != 0 ) { N = N & ( N - 1 ) ; count ++ ; } return count ; } public static void main ( String [ ] args ) { int N = 4 ; int bits = countSetBits ( N ) ; System . out . println ( " Odd ▁ " + " : ▁ " + ( int ) ( Math . pow ( 2 , bits ) ) ) ; System . out . println ( " Even ▁ " + " : ▁ " + ( N + 1 - ( int ) ( Math . pow ( 2 , bits ) ) ) ) ; } }
class GFG { static double find_Variance ( int n ) { long numerator = n * n - 1 ; double ans = ( numerator * 1.0 ) / 12 ; return ans ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( find_Variance ( N ) ) ; } }
import java . util . * ; import java . io . * ; import java . math . * ; class GFG { static int findSum ( int arr [ ] , int N ) { Map < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! map . containsKey ( arr [ i ] ) ) map . put ( arr [ i ] , 1 ) ; else map . replace ( arr [ i ] , map . get ( arr [ i ] ) + 1 ) ; } int sum_odd = 0 , sum_even = 0 ; Set < Map . Entry < Integer , Integer > > hmap = map . entrySet ( ) ; for ( Map . Entry < Integer , Integer > data : hmap ) { int key = data . getKey ( ) ; int val = data . getValue ( ) ; if ( val % 2 != 0 ) sum_odd += ( key ) * ( val ) ; if ( val % 2 == 0 ) sum_even += ( key ) * ( val ) ; } int diff = sum_even - sum_odd ; return diff ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 5 , 5 , 2 , 4 , 3 , 3 } ; int N = arr . length ; System . out . println ( findSum ( arr , N ) ) ; } }
import java . util . * ; class GFG { static void findSum ( int a , int b , int n ) { if ( n == 1 ) { System . out . println ( a ) ; return ; } int s = a + b ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int x = a ^ b ; s += x ; a = b ; b = x ; } System . out . println ( s ) ; } public static void main ( String [ ] args ) { int a = 2 , b = 5 , N = 8 ; findSum ( a , b , N ) ; } }
import java . util . * ; import java . io . * ; import java . lang . * ; class GFG { static int onesComplement ( int n , int maxElement ) { int bits = ( int ) Math . floor ( ( Math . log ( maxElement ) / Math . log ( 2 ) ) ) + 1 ; return ( ( 1 << bits ) - 1 ) ^ n ; } static int findNumber ( int arr [ ] , int n ) { int res = 0 ; int maxElement = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res = res ^ arr [ i ] ; if ( maxElement < arr [ i ] ) maxElement = arr [ i ] ; } res = onesComplement ( res , maxElement ) ; return ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int N = arr . length ; System . out . print ( findNumber ( arr , N ) ) ; } }
import java . util . * ; class GFG { static void findTheGreatestX ( int P , int Q ) { HashMap < Integer , Integer > divisiors = new HashMap < > ( ) ; for ( int i = 2 ; i * i <= Q ; i ++ ) { while ( Q % i == 0 && Q > 1 ) { Q /= i ; if ( divisiors . containsKey ( i ) ) { divisiors . put ( i , divisiors . get ( i ) + 1 ) ; } else { divisiors . put ( i , 1 ) ; } } } if ( Q > 1 ) if ( divisiors . containsKey ( Q ) ) { divisiors . put ( Q , divisiors . get ( Q ) + 1 ) ; } else { divisiors . put ( Q , 1 ) ; } int ans = 0 ; for ( Map . Entry < Integer , Integer > i : divisiors . entrySet ( ) ) { int frequency = i . getValue ( ) ; int temp = P ; int cur = 0 ; while ( temp % i . getKey ( ) == 0 ) { temp /= i . getKey ( ) ; cur ++ ; } if ( cur < frequency ) { ans = P ; break ; } temp = P ; for ( int j = cur ; j >= frequency ; j -- ) { temp /= i . getKey ( ) ; } ans = Math . max ( temp , ans ) ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int P = 10 , Q = 4 ; findTheGreatestX ( P , Q ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int countXORSetBitsAdjElemRange1_N ( int N ) { int total_set_bits = 0 ; int bit_Position = 1 ; while ( N != 0 ) { total_set_bits += ( ( N + 1 ) / 2 * bit_Position ) ; N -= ( N + 1 ) / 2 ; bit_Position ++ ; } return total_set_bits ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( countXORSetBitsAdjElemRange1_N ( N ) ) ; } }
import java . util . * ; class GFG { static final int size_int = 32 ; static int functionMax ( int arr [ ] , int n ) { Vector < Integer > [ ] setBit = new Vector [ 32 + 1 ] ; for ( int i = 0 ; i < setBit . length ; i ++ ) setBit [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < size_int ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) setBit [ j ] . add ( i ) ; } } for ( int i = size_int ; i >= 0 ; i -- ) { if ( setBit [ i ] . size ( ) == 1 ) { swap ( arr , 0 , setBit [ i ] . get ( 0 ) ) ; break ; } } int maxAnd = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { maxAnd = maxAnd & ( ~ arr [ i ] ) ; } return maxAnd ; } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 } ; int n = arr . length ; System . out . print ( functionMax ( arr , n ) ) ; } }
class GFG { static int highestPower ( int n ) { return ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( highestPower ( n ) ) ; } }
import java . util . * ; class GFG { static void print ( int N ) { for ( int i = 0 ; i < 100000 ; i ++ ) { if ( Math . pow ( i + 1 , 3 ) - Math . pow ( i , 3 ) == N ) { int j = i + 1 ; System . out . println ( i + " ▁ " + j ) ; return ; } } } static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static boolean diffCube ( int N ) { return isPerfectSquare ( 12 * N - 3 ) ; } public static void main ( String [ ] args ) { int N = 19 ; if ( diffCube ( N ) ) { System . out . println ( " Yes " ) ; print ( N ) ; } else { System . out . println ( " No " ) ; } } }
class GFG { static boolean is_possible ( int x , int y ) { if ( x < 2 && y != 0 ) return false ; y = y - x + 1 ; if ( y % 2 == 0 && y >= 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int x = 5 , y = 2 ; if ( is_possible ( x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class Node { int data ; Node left , right ; public Node ( int data , Node left , Node right ) { this . data = data ; this . left = left ; this . right = right ; } static Node newNode ( int data ) { return new Node ( data , null , null ) ; } static void inorder ( Node node ) { if ( node == null ) return ; inorder ( node . left ) ; System . out . printf ( " % d ▁ " , node . data ) ; inorder ( node . right ) ; } static Node MaximumBinaryTree ( Node t1 , Node t2 ) { if ( t1 == null ) return t2 ; if ( t2 == null ) return t1 ; t1 . data = Math . max ( t1 . data , t2 . data ) ; t1 . left = MaximumBinaryTree ( t1 . left , t2 . left ) ; t1 . right = MaximumBinaryTree ( t1 . right , t2 . right ) ; return t1 ; } public static void main ( String [ ] args ) { Node root1 = newNode ( 3 ) ; root1 . left = newNode ( 2 ) ; root1 . right = newNode ( 6 ) ; root1 . left . left = newNode ( 20 ) ; Node root2 = newNode ( 5 ) ; root2 . left = newNode ( 1 ) ; root2 . right = newNode ( 8 ) ; root2 . left . right = newNode ( 2 ) ; root2 . right . right = newNode ( 8 ) ; Node root3 = MaximumBinaryTree ( root1 , root2 ) ; inorder ( root3 ) ; } }
class GFG { static int powerOptimised ( int a , int n ) { int ans = 1 ; while ( n > 0 ) { int last_bit = ( n & 1 ) ; if ( last_bit > 0 ) { ans = ans * a ; } a = a * a ; n = n >> 1 ; } return ans ; } public static void main ( String [ ] args ) { int a = 3 , n = 5 ; System . out . print ( powerOptimised ( a , n ) ) ; } }
import java . util . * ; class GFG { static int gcd ( int x , int y ) { if ( x == 0 ) return y ; return gcd ( y % x , x ) ; } static int findDistinct ( int arr [ ] , int n ) { int maximum = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; if ( n == 1 ) return 1 ; if ( n == 2 ) { return ( maximum / gcd ( arr [ 0 ] , arr [ 1 ] ) ) ; } int k = gcd ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { k = gcd ( k , arr [ i ] ) ; } return ( maximum / k ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 5 } ; int n = arr . length ; System . out . println ( findDistinct ( arr , n ) ) ; } }
class GFG { static void isEqualFactors ( int N ) { int ev_count = 0 , od_count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( N ) + 1 ; i ++ ) { if ( N % i == 0 ) { if ( i == N / i ) { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } else { if ( i % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; if ( ( N / i ) % 2 == 0 ) ev_count += 1 ; else od_count += 1 ; } } } if ( ev_count == od_count ) System . out . print ( " YES " + "NEW_LINE"); else System . out . print ( " NO " + "NEW_LINE"); } public static void main ( String [ ] args ) { int N = 10 ; isEqualFactors ( N ) ; } }
import java . util . Arrays ; class GFG { static int maxOR ( int [ ] arr , int n ) { int max_value = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , ( max_value arr [ i ] ) ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 3 , 6 , 8 , 16 } ; int n = 4 ; System . out . print ( maxOR ( arr , n ) ) ; } }
class GFG { static int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; } static boolean checkAbundant ( int n ) { return ( getSum ( n ) - n > n ) ; } static boolean isDeficient ( int n ) { return ( getSum ( n ) < ( 2 * n ) ) ; } static boolean checkPrimitiveAbundant ( int num ) { if ( ! checkAbundant ( num ) ) { return false ; } for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 && i != num ) { if ( i * i == num ) { if ( ! isDeficient ( i ) ) { return false ; } } else if ( ! isDeficient ( i ) || ! isDeficient ( num / i ) ) { return false ; } } } return true ; } public static void main ( String [ ] args ) { int n = 20 ; if ( checkPrimitiveAbundant ( n ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
import java . io . * ; class GFG { static int divSum ( int num ) { int result = 0 ; for ( int i = 1 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result - 1 - num ) ; } static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { int r = n % 10 ; sum = sum + r * r ; n = n / 10 ; } return sum ; } static boolean isCanada ( int n ) { return divSum ( n ) == getSum ( n ) ; } public static void main ( String [ ] args ) { int n = 125 ; if ( isCanada ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int countEle ( int a [ ] , int n ) { int len = 0 ; HashMap < Integer , Integer > hmap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { len = Math . max ( len , a [ i ] ) ; if ( hmap . containsKey ( a [ i ] ) ) { hmap . put ( a [ i ] , hmap . get ( a [ i ] ) + 1 ) ; } else { hmap . put ( a [ i ] , 1 ) ; } } boolean [ ] v = new boolean [ len + 1 ] ; for ( int i = 0 ; i <= len ; i ++ ) { v [ i ] = true ; } for ( int i = 0 ; i < n ; i ++ ) { if ( v [ a [ i ] ] == false ) continue ; for ( int j = 2 * a [ i ] ; j <= len ; j += a [ i ] ) { v [ j ] = false ; } } int count = 0 ; for ( int i = 1 ; i <= len ; i ++ ) { if ( v [ i ] == true && hmap . containsKey ( i ) && hmap . get ( i ) == 1 && hmap . get ( i ) == 1 ) { count += 1 ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 86 , 45 , 18 , 4 , 8 , 28 , 19 , 33 , 2 } ; int n = arr . length ; System . out . print ( countEle ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int maxAdjacentDifference ( int N , int K ) { if ( N == 1 ) { return 0 ; } if ( N == 2 ) { return K ; } return 2 * K ; } public static void main ( String [ ] args ) { int N = 6 ; int K = 11 ; System . out . print ( maxAdjacentDifference ( N , K ) ) ; } }
import java . util . * ; class GFG { static boolean isPal ( int a [ ] [ ] , int n , int m ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { for ( int j = 0 ; j < m - 1 ; j ++ ) { if ( a [ i ] [ j ] != a [ n - 1 - i ] [ m - 1 - j ] ) return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 3 , m = 3 ; int a [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 4 } , { 3 , 2 , 1 } } ; if ( isPal ( a , n , m ) ) { System . out . print ( " YES " + "NEW_LINE"); } else { System . out . print ( " NO " + "NEW_LINE"); } } }
class GFG { static int divSum ( int num ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( num ) ; i ++ ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return ( result + 1 ) ; } static boolean isUntouchable ( int n ) { for ( int i = 1 ; i <= 2 * n ; i ++ ) { if ( divSum ( i ) == n ) return false ; } return true ; } public static void main ( String [ ] args ) { int n = 52 ; if ( isUntouchable ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int gonNum120 ( int n ) { return ( 118 * n * n - 116 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( gonNum120 ( n ) ) ; } }
import java . util . * ; class GFG { static void constructArray ( int N ) { int arr [ ] = new int [ N ] ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i - 1 ] = i ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " , ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 6 ; constructArray ( N ) ; } }
class GFG { static void findPair ( int x ) { int lim = 120 ; for ( int i = - lim ; i <= lim ; i ++ ) { for ( int j = - lim ; j <= lim ; j ++ ) { if ( Math . pow ( i , 5 ) - Math . pow ( j , 5 ) == x ) { System . out . print ( i + " ▁ " + j + "NEW_LINE"); return ; } } } System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int X = 33 ; findPair ( X ) ; } }
import java . util . * ; class GFG { static boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; } static boolean isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; } static boolean checkDigits ( int n ) { while ( n != 0 ) { int dig = n % 10 ; if ( dig == 4 && dig == 6 && dig == 7 && dig == 9 ) return false ; n /= 10 ; } return true ; } static boolean isFullfibonacci ( int n ) { return ( checkDigits ( n ) && isFibonacci ( n ) ) ; } public static void main ( String [ ] args ) { int n = 13 ; if ( isFullfibonacci ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int longestEvenOddSubarray ( int a [ ] , int n ) { int longest = 1 ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] + a [ i + 1 ] ) % 2 == 1 ) { cnt ++ ; } else { longest = Math . max ( longest , cnt ) ; cnt = 1 ; } } if ( longest == 1 ) return 0 ; return Math . max ( cnt , longest ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int n = a . length ; System . out . println ( longestEvenOddSubarray ( a , n ) ) ; } }
import java . util . * ; class GFG { static int findMinDivisor ( int arr [ ] , int n , int limit ) { int low = 0 , high = 1000000000 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += Math . ceil ( ( double ) arr [ i ] / ( double ) mid ) ; } if ( sum <= limit ) high = mid ; else low = mid + 1 ; } return low ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 9 } ; int N = arr . length ; int K = 6 ; System . out . println ( findMinDivisor ( arr , N , K ) ) ; } }
import java . util . * ; class GFG { static int sz = ( int ) 1e3 ; static boolean isEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { if ( x % 2 == 1 ) parity ++ ; x = x >> 1 ; } if ( parity % 2 == 0 ) return true ; else return false ; } static void printArray ( int arr [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } static void findPairEvenParity ( int arr [ ] , int len ) { int firstMaximum = Integer . MIN_VALUE ; int secondMaximum = Integer . MIN_VALUE ; for ( int i = 0 ; i < len ; i ++ ) { if ( isEvenParity ( arr [ i ] ) ) { if ( arr [ i ] >= firstMaximum ) { secondMaximum = firstMaximum ; firstMaximum = arr [ i ] ; } else if ( arr [ i ] >= secondMaximum ) { secondMaximum = arr [ i ] ; } } } System . out . print ( firstMaximum + " ▁ " + secondMaximum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 18 , 15 , 8 , 9 , 14 } ; int len = arr . length ; findPairEvenParity ( arr , len ) ; } }
import java . util . * ; class GFG { static boolean isHexagonal ( int N ) { float val = 8 * N + 1 ; float x = 1 + ( float ) Math . sqrt ( val ) ; float n = ( x ) / 4 ; if ( ( n - ( int ) n ) == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int N = 14 ; if ( isHexagonal ( N ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int Solve ( int arr [ ] , int n ) { int temp = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp = 0 ; for ( int j = i ; j < n ; j ++ ) { temp += arr [ j ] ; if ( ( temp + 2 ) % 4 != 0 ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int N = arr . length ; System . out . println ( Solve ( arr , N ) ) ; } }
class GFG { static boolean prodSquare ( int n ) { for ( long i = 2 ; i * i <= n ; i ++ ) for ( long j = 2 ; j <= n ; j ++ ) if ( i * i * j * j == n ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 25 ; if ( prodSquare ( n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static void findNumbers ( int N ) { for ( int i = 1 ; i <= N / 2 ; i ++ ) { System . out . print ( i + " , ▁ " + - i + " , ▁ " ) ; } if ( N % 2 == 1 ) System . out . print ( 0 ) ; } public static void main ( String [ ] args ) { int N = 10 ; findNumbers ( N ) ; } }
import java . util . * ; class GFG { static int countValues ( int N ) { Vector < Integer > div = new Vector < > ( ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { div . add ( i ) ; if ( N != i * i ) { div . add ( N / i ) ; } } } int answer = 0 ; for ( int i = 1 ; i * i <= N - 1 ; i ++ ) { if ( ( N - 1 ) % i == 0 ) { if ( i * i == N - 1 ) answer ++ ; else answer += 2 ; } } for ( int d : div ) { int K = N ; while ( K % d == 0 ) K /= d ; if ( ( K - 1 ) % d == 0 ) answer ++ ; } return answer ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . print ( countValues ( N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static void Solve ( int arr [ ] , int size , int n ) { int [ ] v = new int [ n + 1 ] ; for ( int i = 0 ; i < size ; i ++ ) v [ arr [ i ] ] ++ ; int max1 = - 1 , mx = - 1 ; for ( int i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] > mx ) { mx = v [ i ] ; max1 = i ; } } int cnt = 0 ; for ( int i : v ) { if ( i == 0 ) ++ cnt ; } int diff1 = n + 1 - cnt ; int max_size = Math . max ( Math . min ( v [ max1 ] - 1 , diff1 ) , Math . min ( v [ max1 ] , diff1 - 1 ) ) ; System . out . println ( " Maximum ▁ size ▁ is : ▁ " + max_size ) ; System . out . println ( " First ▁ Array ▁ is " ) ; for ( int i = 0 ; i < max_size ; i ++ ) { System . out . print ( max1 + " ▁ " ) ; v [ max1 ] -= 1 ; } System . out . println ( ) ; System . out . println ( " The ▁ Second ▁ Array ▁ Is ▁ : " ) ; for ( int i = 0 ; i < ( n + 1 ) ; i ++ ) { if ( v [ i ] > 0 ) { System . out . print ( i + " ▁ " ) ; max_size -- ; } if ( max_size < 1 ) break ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int n = 7 ; int arr [ ] = new int [ ] { 1 , 2 , 1 , 5 , 1 , 6 , 7 , 2 } ; int size = arr . length ; Solve ( arr , size , n ) ; } }
import java . util . Arrays ; class Main { public static int findunique ( int a [ ] , int k ) { int res = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { int p = 0 ; for ( int j = 0 ; j < a . length ; j ++ ) { p += ( Math . abs ( a [ j ] ) & ( 1 << i ) ) != 0 ? 1 : 0 ; } p %= k ; res += Math . pow ( 2 , i ) * p ; } int c = 0 ; for ( int x = 0 ; x < a . length ; x ++ ) if ( a [ x ] == res ) { c = 1 ; break ; } return c == 1 ? res : - res ; } public static void main ( String [ ] args ) { int a [ ] = { 12 , 12 , 2 , 2 , 3 } ; int k = 2 ; System . out . println ( findunique ( a , k ) ) ; } }
import java . util . * ; class GFG { static double Volume_of_cone ( double R ) { double V = ( double ) ( ( 1 / 3.0 ) * ( 3.14 ) * ( 2 * ( R * R ) ) * ( 4 * R ) ) ; return V ; } public static void main ( String [ ] args ) { double R = 10.0 ; System . out . print ( Volume_of_cone ( R ) ) ; } }
public class GFG { static void find_volume ( double area , double h ) { double Volume = ( area * h ) ; System . out . println ( " Volume : ▁ " + Volume ) ; } static void find_Surface_area ( double area , double a , double h ) { double Surface_area = ( 2 * area ) + ( 8 * a * h ) ; System . out . println ( " Surface ▁ area : ▁ " + Surface_area ) ; } public static void main ( String [ ] args ) { double h = 1 ; double a = 6 ; double d = 2 ; double area = 2 * a * d ; find_Surface_area ( area , a , h ) ; find_volume ( area , h ) ; } }
class GFG { static double nthRoot ( long A , long N ) { double xPre = 7 ; double eps = 1e-3 ; double delX = Integer . MAX_VALUE ; double xK = 0 ; while ( delX > eps ) { xK = ( ( N - 1.0 ) * xPre + ( double ) A / Math . pow ( xPre , N - 1 ) ) / ( double ) N ; delX = Math . abs ( xK - xPre ) ; xPre = xK ; } return xK ; } static boolean check ( long no , int k ) { double kth_root = nthRoot ( no , k ) ; long num = ( long ) kth_root ; if ( Math . abs ( num - kth_root ) < 1e-4 ) return true ; return false ; } static void printExpo ( long arr [ ] , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( check ( arr [ i ] , k ) ) System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int K = 6 ; long arr [ ] = { 46656 , 64 , 256 , 729 , 16 , 1000 } ; int n = arr . length ; printExpo ( arr , n , K ) ; } }
class GFG { static int CntcontSubs ( int a [ ] , int n ) { int c = 0 , d = 0 , i , sum = 1 , j ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 != 0 a [ i ] % 4 == 0 ) d ++ ; sum = a [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { sum = sum * a [ j ] ; if ( sum % 2 != 0 sum % 4 == 0 ) c ++ ; } sum = 1 ; } return c + d ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 4 , 2 , 9 , 8 } ; int n = arr . length ; System . out . print ( CntcontSubs ( arr , n ) ) ; } }
class GFG { static int pref [ ] = new int [ 10000 ] ; static int isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return n ; return 0 ; } static void precomputation ( ) { for ( int i = 1 ; i < 10000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfect ( i ) ; } } public static void main ( String [ ] args ) { int L = 6 , R = 28 ; precomputation ( ) ; System . out . println ( pref [ R ] - pref [ L - 1 ] ) ; } }
import java . util . * ; class GFG { static int EulerTotientFunction ( int limit ) { int copy = limit ; Vector < Integer > primes = new Vector < Integer > ( ) ; for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( limit % i == 0 ) { while ( limit % i == 0 ) { limit /= i ; } primes . add ( i ) ; } } if ( limit >= 2 ) { primes . add ( limit ) ; } int ans = copy ; for ( int it : primes ) { ans = ( ans / it ) * ( it - 1 ) ; } return ans ; } static void CountGCD ( int m , int k ) { if ( m % k != 0 ) { System . out . print ( 0 + "NEW_LINE"); return ; } if ( m == k ) { System . out . print ( 2 + "NEW_LINE"); return ; } int limit = m / k ; int ans = EulerTotientFunction ( limit ) ; System . out . print ( ans + "NEW_LINE"); } public static void main ( String [ ] args ) { int M = 9 ; int K = 1 ; CountGCD ( M , K ) ; } }
import java . util . * ; class GFG { static int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } static int sumFibonacci ( int k ) { int l = ( k * ( k - 1 ) ) / 2 ; int r = l + k ; int sum = calculateSum ( l , r - 1 ) ; return sum ; } public static void main ( String args [ ] ) { int k = 3 ; System . out . println ( sumFibonacci ( k ) ) ; } }
class Sum { void sumOfPrevK ( int N , int K ) { int arr [ ] = new int [ N ] ; arr [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { int j = i - 1 , count = 0 , sum = 0 ; while ( j >= 0 && count < K ) { sum += arr [ j ] ; j -- ; count ++ ; } arr [ i ] = sum ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } public static void main ( String args [ ] ) { Sum s = new Sum ( ) ; int N = 10 , K = 4 ; s . sumOfPrevK ( N , K ) ; } }
class GFG { static void findRealAndImag ( String s ) { int l = s . length ( ) ; int i ; if ( s . indexOf ( ' + ' ) != - 1 ) { i = s . indexOf ( ' + ' ) ; } else { i = s . indexOf ( ' - ' ) ; } String real = s . substring ( 0 , i ) ; String imaginary = s . substring ( i + 1 , l - 1 ) ; System . out . println ( " Real ▁ part : ▁ " + real ) ; System . out . println ( " Imaginary ▁ part : ▁ " + imaginary ) ; } public static void main ( String [ ] args ) { String s = "3 + 4i " ; findRealAndImag ( s ) ; } }
class Geeks { static int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static int countReverse ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( reverse ( arr [ i ] ) == arr [ j ] ) { res ++ ; } return res ; } public static void main ( String [ ] args ) { int a [ ] = { 16 , 61 , 12 , 21 , 25 } ; int n = a . length ; System . out . print ( countReverse ( a , n ) ) ; } }
class GFG { static void printSeriesSum ( int N ) { double sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) { sum += ( double ) i / ( i + 1 ) ; } else { sum -= ( double ) i / ( i + 1 ) ; } } System . out . print ( sum + "NEW_LINE"); } public static void main ( String [ ] args ) { int N = 10 ; printSeriesSum ( N ) ; } }
class GFG { static String sumBaseB ( String a , String b , int base ) { int len_a , len_b ; len_a = a . length ( ) ; len_b = b . length ( ) ; String sum , s ; s = " " ; sum = " " ; int diff ; diff = Math . abs ( len_a - len_b ) ; for ( int i = 1 ; i <= diff ; i ++ ) s += "0" ; if ( len_a < len_b ) a = s + a ; else b = s + b ; int curr , carry = 0 ; for ( int i = Math . max ( len_a , len_b ) - 1 ; i > - 1 ; i -- ) { curr = carry + ( a . charAt ( i ) - '0' ) + ( b . charAt ( i ) - '0' ) ; carry = curr / base ; curr = curr % base ; sum = ( char ) ( curr + '0' ) + sum ; } if ( carry > 0 ) sum = ( char ) ( carry + '0' ) + sum ; return sum ; } public static void main ( String [ ] args ) { String a , b , sum ; int base ; a = "123" ; b = "234" ; base = 6 ; sum = sumBaseB ( a , b , base ) ; System . out . println ( sum ) ; } }
import java . util . * ; class GFG { static void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } } static int countFibonacciDivisors ( int n ) { HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , n ) ; int cnt = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( ( n / i == i ) && ( hash . contains ( n / i ) ) ) cnt ++ ; else { if ( hash . contains ( n / i ) ) cnt ++ ; if ( hash . contains ( n / ( n / i ) ) ) cnt ++ ; } } } return cnt ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . print ( countFibonacciDivisors ( n ) ) ; } }
class GFG { static boolean isPerfectCube ( int x ) { long cr = Math . round ( Math . cbrt ( x ) ) ; return ( cr * cr * cr == x ) ; } static void checkCube ( int a , int b ) { String s1 = Integer . toString ( a ) ; String s2 = Integer . toString ( b ) ; int c = Integer . parseInt ( s1 + s2 ) ; if ( isPerfectCube ( c ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int a = 6 ; int b = 4 ; checkCube ( a , b ) ; } }
import java . util . * ; class GFG { static boolean isPerfectSquare ( int x ) { int s = ( int ) Math . sqrt ( x ) ; return ( s * s == x ) ; } static boolean isFibonacci ( int N ) { return isPerfectSquare ( 5 * N * N + 4 ) || isPerfectSquare ( 5 * N * N - 4 ) ; } static int nextNonFibonacci ( int N ) { if ( N <= 3 ) return 4 ; if ( isFibonacci ( N + 1 ) ) return N + 2 ; else return N + 1 ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( nextNonFibonacci ( N ) + "NEW_LINE"); N = 5 ; System . out . print ( nextNonFibonacci ( N ) + "NEW_LINE"); N = 7 ; System . out . print ( nextNonFibonacci ( N ) + "NEW_LINE"); } }
class GFG { static int countDigit ( int n ) { boolean prime [ ] = new boolean [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) prime [ i ] = false ; prime [ 2 ] = prime [ 3 ] = true ; prime [ 5 ] = prime [ 7 ] = true ; int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 && prime [ d ] == true ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int n = 1032 ; System . out . println ( countDigit ( n ) ) ; } }
import java . util . * ; class GFG { static void findRoots ( int b , int c ) { int a = 1 ; int d = b * b - 4 * a * c ; double sqrt_val = Math . sqrt ( Math . abs ( d ) ) ; if ( d > 0 ) { double x = - b + sqrt_val ; double y = - b - sqrt_val ; int root1 = ( int ) ( x ) / ( 2 * a ) ; int root2 = ( int ) ( y ) / ( 2 * a ) ; if ( root1 + root2 == - 1 * b && root1 * root2 == c ) System . out . print ( root1 + " , ▁ " + root2 ) ; else System . out . print ( - 1 ) ; } else if ( d == 0 ) { int root = - b / ( 2 * a ) ; if ( root + root == - 1 * b && root * root == c ) System . out . print ( root + " , ▁ " + root ) ; else System . out . print ( - 1 ) ; } else { System . out . print ( - 1 ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int S = 5 , P = 6 ; findRoots ( - S , P ) ; S = 5 ; P = 9 ; findRoots ( - S , P ) ; } }
import java . util . * ; class GFG { static void findNumbers ( int N ) { int i = 1 ; while ( i <= N ) { System . out . print ( ( i * i * i ) + " ▁ " ) ; i ++ ; } } public static void main ( String [ ] args ) { int N = 4 ; findNumbers ( N ) ; } }
import java . util . * ; class GFG { static void getnumbers ( int n ) { Vector < Integer > divisor = new Vector < Integer > ( ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { divisor . add ( i ) ; n /= i ; } } if ( n != 1 ) { divisor . add ( n ) ; } int a , b , c , size ; a = b = c = 1 ; size = divisor . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( a == 1 ) { a = a * divisor . get ( i ) ; } else if ( b == 1 b == a ) { b = b * divisor . get ( i ) ; } else { c = c * divisor . get ( i ) ; } } if ( a == 1 b == 1 c == 1 a == b b == c a == c ) { System . out . print ( " - 1" + "NEW_LINE"); } else { System . out . print ( a + " ▁ " + b + " ▁ " + c + "NEW_LINE"); } } public static void main ( String [ ] args ) { int n = 64 ; getnumbers ( n ) ; } }
import java . util . * ; class GFG { static Vector < Integer > primeFactors ( int n ) { int i , j ; Vector < Integer > Prime = new Vector < Integer > ( ) ; if ( n % 2 == 0 ) { Prime . add ( 2 ) ; } while ( n % 2 == 0 ) { n = n / 2 ; } for ( i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { Prime . add ( i ) ; } while ( n % i == 0 ) { n = n / i ; } } if ( n > 2 ) { Prime . add ( n ) ; } return Prime ; } static void checkDistinctPrime ( int n ) { Vector < Integer > Prime = primeFactors ( n ) ; int product = 1 ; for ( int i : Prime ) { product *= i ; } if ( product == n ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } public static void main ( String [ ] args ) { int N = 30 ; checkDistinctPrime ( N ) ; } }
import java . lang . Math ; class GFG { public static void findSum ( int N ) { int sum = ( N ) * ( N + 1 ) / 2 ; int r = ( int ) ( Math . log ( N ) / Math . log ( 2 ) ) + 1 ; int expSum = ( int ) ( Math . pow ( 2 , r ) ) - 1 ; System . out . println ( sum - expSum ) ; } public static void main ( String [ ] args ) { int N = 2 ; findSum ( N ) ; } }
class GFG { static int remainingArea ( int N , int M , int K ) { while ( K -- > 0 && N > 0 && M > 0 ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; } public static void main ( String [ ] args ) { int N = 5 , M = 3 , K = 2 ; System . out . println ( remainingArea ( N , M , K ) ) ; } }
class GFG { static boolean isPossible ( int a [ ] , int n ) { int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 3 , 4 } ; int n = a . length ; if ( isPossible ( a , n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . HashMap ; import java . util . Map ; class GfG { static Pair < Integer , Integer > findFourthVertex ( int n , int m , String s [ ] ) { HashMap < Integer , Integer > row = new HashMap < > ( ) ; HashMap < Integer , Integer > col = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( s [ i ] . charAt ( j ) == ' * ' ) { if ( row . containsKey ( i ) ) { row . put ( i , row . get ( i ) + 1 ) ; } else { row . put ( i , 1 ) ; } if ( col . containsKey ( j ) ) { col . put ( j , col . get ( j ) + 1 ) ; } else { col . put ( j , 1 ) ; } } } } int x = 0 , y = 0 ; for ( Map . Entry < Integer , Integer > entry : row . entrySet ( ) ) { if ( entry . getValue ( ) == 1 ) x = entry . getKey ( ) ; } for ( Map . Entry < Integer , Integer > entry : col . entrySet ( ) ) { if ( entry . getValue ( ) == 1 ) y = entry . getKey ( ) ; } Pair < Integer , Integer > ans = new Pair < > ( x + 1 , y + 1 ) ; return ans ; } public static void main ( String [ ] args ) { String s [ ] = { " * . * " , " * . . " , " . . . " } ; int n = s . length ; int m = s [ 0 ] . length ( ) ; Pair < Integer , Integer > rs = findFourthVertex ( n , m , s ) ; System . out . println ( rs . first + " ▁ " + rs . second ) ; } } class Pair < A , B > { A first ; B second ; public Pair ( A first , B second ) { this . first = first ; this . second = second ; } }
import java . io . * ; class GFG { static float cone ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a * Math . sqrt ( 2 ) ) / 3 ; float h = ( 2 * a ) / 3 ; float V = ( float ) ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( cone ( a ) ) ; } }
class Solution { static float squareArea ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; } public static void main ( String args [ ] ) { float a = 6 ; System . out . println ( squareArea ( a ) ) ; } }
import java . lang . * ; class GFG { static double PI = 3.14159265 ; public static double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } public static void main ( String [ ] args ) { double r = 7 ; System . out . println ( length_rope ( r ) ) ; } }
import java . io . * ; class GFG { static float sph ( float r , float h ) { if ( r < 0 && h < 0 ) return - 1 ; float R = r ; return R ; } public static void main ( String [ ] args ) { float r = 4 , h = 8 ; System . out . println ( sph ( r , h ) ) ; } }
class GFG { static int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; } public static void main ( String args [ ] ) { int M = 4 , N = 4 ; int Cuts = numberOfCuts ( M , N ) ; System . out . println ( " Maximum ▁ cuts ▁ = ▁ " + Cuts ) ; } }
import java . util . * ; class solution { static void equation_parabola ( float x1 , float y1 , float a , float b , float c ) { float t = a * a + b * b ; float a1 = t - ( a * a ) ; float b1 = t - ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * c * b ) ; float e1 = - 2 * a * b ; float f1 = ( - c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; System . out . println ( " equation ▁ of ▁ parabola ▁ is ▁ " + a1 + " ▁ x ^ 2 ▁ + ▁ " + b1 + " ▁ y ^ 2 ▁ + ▁ " + c1 + " ▁ x ▁ + ▁ " + d1 + " ▁ y ▁ + ▁ " + e1 + " ▁ xy ▁ + ▁ " + f1 + " ▁ = ▁ 0 . " ) ; } public static void main ( String arr [ ] ) { float x1 = 0 ; float y1 = 0 ; float a = 3 ; float b = - 4 ; float c = 2 ; equation_parabola ( x1 , y1 , a , b , c ) ; } }
import java . io . * ; class GFG { static float area ( float r ) { return ( float ) ( ( 0.5 ) * ( 3.14 ) * ( r * r ) ) ; } static float perimeter ( float r ) { return ( float ) ( ( 3.14 ) * ( r ) ) ; } public static void main ( String [ ] args ) { float r = 10 ; System . out . println ( " The ▁ Area ▁ of ▁ Semicircle : ▁ " + area ( r ) ) ; System . out . println ( " The ▁ Perimeter ▁ of ▁ Semicircle : " + + perimeter ( r ) ) ; } }
import java . io . * ; public class GFG { static boolean Arrive ( int a , int b , int n ) { if ( n >= Math . abs ( a ) + Math . abs ( b ) && ( n - ( Math . abs ( a ) + Math . abs ( b ) ) ) % 2 == 0 ) return true ; return false ; } int main ( ) { return 0 ; } public static void main ( String [ ] args ) { int a = 5 , b = 5 , n = 11 ; if ( Arrive ( a , b , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float area = ( l * b ) / 2 ; return area ; } public static void main ( String args [ ] ) { float l = 5 , b = 4 ; System . out . println ( trianglearea ( l , b ) ) ; } }
public class GFG { static float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; } public static void main ( String [ ] args ) { float l = 5 , b = 12 , h = 13 ; System . out . println ( squareArea ( l , b , h ) ) ; } }
class GFG { static void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ; int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 y5 > y6 ) { System . out . println ( " No ▁ intersection " ) ; return ; } System . out . print ( " ( " + x5 + " , ▁ " + y5 + " ) ▁ " ) ; System . out . print ( " ( " + x6 + " , ▁ " + y6 + " ) ▁ " ) ; int x7 = x5 ; int y7 = y6 ; System . out . print ( " ( " + x7 + " , ▁ " + y7 + " ) ▁ " ) ; int x8 = x6 ; int y8 = y5 ; System . out . print ( " ( " + x8 + " , ▁ " + y8 + " ) ▁ " ) ; } public static void main ( String args [ ] ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; } }
import java . io . * ; class GFG { static void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; System . out . println ( " equation ▁ of ▁ plane ▁ is ▁ " + a + " ▁ x ▁ + ▁ " + b + " ▁ y ▁ + ▁ " + c + " ▁ z ▁ + ▁ " + d + " ▁ = ▁ 0 . " ) ; } public static void main ( String [ ] args ) { float x1 = - 1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = - 3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = - 4 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; } }
import java . util . * ; class solution { static void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 1st ▁ octant " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 2nd ▁ octant " ) ; else if ( x < 0 && y < 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 3rd ▁ octant " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 4th ▁ octant " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 5th ▁ octant " ) ; else if ( x < 0 && y >= 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 6th ▁ octant " ) ; else if ( x < 0 && y < 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 7th ▁ octant " ) ; else if ( x >= 0 && y < 0 && z < 0 ) System . out . println ( " Point ▁ lies ▁ in ▁ 8th ▁ octant " ) ; } public static void main ( String args [ ] ) { float x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = - 4 ; y = 2 ; z = - 8 ; octant ( x , y , z ) ; x = - 6 ; y = - 2 ; z = 8 ; octant ( x , y , z ) ; } }
import java . io . * ; class GFG { static int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( pentagon_pyramidal ( n ) ) ; } }
class GFG { static void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; System . out . println ( " x2 ▁ = ▁ " + x2 + " , ▁ " + " y2 ▁ = ▁ " + y2 ) ; } public static void main ( String args [ ] ) { int x1 = - 4 , y1 = - 1 , m1 = 3 , m2 = 5 ; otherEndPoint ( x1 , y1 , m1 , m2 ) ; } }
import java . util . * ; class GFG { static void findTriangle ( int a [ ] , int n ) { int b [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; Arrays . sort ( a ) ; Arrays . sort ( b ) ; int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . max ( p - j , 0 ) ; z += q - p ; } } } System . out . println ( " Acute ▁ Triangle : ▁ " + x ) ; System . out . println ( " Right ▁ Triangle : ▁ " + y ) ; System . out . println ( " Obtuse ▁ Triangle : ▁ " + z ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 9 , 10 , 12 , 15 } ; int n = arr . length ; findTriangle ( arr , n ) ; } }
import java . io . * ; class GFG { public static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; } public static void main ( String [ ] args ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = 3 ; System . out . println ( polygonArea ( X , Y , n ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static double polygonArea ( double X [ ] , double Y [ ] , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; } public static void main ( String [ ] args ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = X . length ; System . out . println ( polygonArea ( X , Y , n ) ) ; } }
public class GFG { final static int maxn = 100001 ; static int gpf [ ] = new int [ maxn ] ; static void modifiedSieve ( ) { for ( int i = 0 ; i < maxn ; i ++ ) gpf [ i ] = 0 ; gpf [ 0 ] = 0 ; gpf [ 1 ] = 1 ; for ( int i = 2 ; i < maxn ; i ++ ) { if ( gpf [ i ] > 0 ) continue ; for ( int j = i ; j < maxn ; j += i ) { gpf [ j ] = Math . max ( i , gpf [ j ] ) ; } } } static int greatestValidInt ( int N ) { modifiedSieve ( ) ; for ( int i = N ; i > 0 ; i -- ) { if ( gpf [ i ] > Math . sqrt ( i ) ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) { int N = 25 ; System . out . println ( greatestValidInt ( N ) ) ; } }
import java . util . * ; class GFG { static double subfactorial ( int N ) { double res = 0 , fact = 1 ; int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { fact = fact * i ; if ( count % 2 == 0 ) res = res - ( 1 / fact ) ; else res = res + ( 1 / fact ) ; count ++ ; } return fact * ( 1 + res ) ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( ( int ) ( subfactorial ( N ) ) ) ; } }
import java . util . * ; class GFG { static int countPairs ( int N ) { int res = 0 ; for ( int q = 1 ; q * q <= N ; q ++ ) { int maxP = Math . min ( 2 * N - q , N / q ) ; if ( maxP < q ) continue ; int cnt = maxP - q + 1 ; res += ( cnt / 2 + ( cnt & 1 ) ) ; } return res ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( countPairs ( N ) ) ; } }
import java . util . * ; class GFG { static int lastPositiveElement ( int [ ] arr ) { int N = arr . length ; if ( N == 1 ) return arr [ 0 ] ; int greatest = - 1 , secondGreatest = - 1 ; for ( int x : arr ) { if ( x >= greatest ) { secondGreatest = greatest ; greatest = x ; } else if ( x >= secondGreatest ) { secondGreatest = x ; } } return greatest - secondGreatest ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 5 , 4 , 7 } ; System . out . print ( lastPositiveElement ( arr ) ) ; } }
import java . io . * ; class GFG { static void findSumOfAllSubsets ( int [ ] arr , int n , int k ) { int factorial_N = 1 , factorial_d = 1 , factorial_D = 1 ; for ( int i = 1 ; i <= n - 1 ; i ++ ) factorial_N *= i ; for ( int i = 1 ; i <= k - 1 ; i ++ ) factorial_d *= i ; for ( int i = 1 ; i <= n - k ; i ++ ) factorial_D *= i ; int freq = factorial_N / ( factorial_d * factorial_D ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; sum = sum * freq ; System . out . println ( " Sum ▁ of ▁ all ▁ subsets ▁ of ▁ size ▁ = ▁ " + k + " ▁ is ▁ = > ▁ " + sum ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 5 } ; int n = 4 , k = 2 ; findSumOfAllSubsets ( arr , n , k ) ; } }
import java . util . * ; class GFG { static int maximumTripletXOR ( int A , int B , int C ) { int ans = 0 ; for ( int i = 30 ; i >= 0 ; i -- ) { int cur = 1 << i ; if ( A >= cur ) { ans += cur ; A -= cur ; } else if ( B >= cur ) { ans += cur ; B -= cur ; } else if ( C >= cur ) { ans += cur ; C -= cur ; } } return ans ; } public static void main ( String [ ] args ) { int A = 6 ; int B = 2 ; int C = 10 ; System . out . print ( maximumTripletXOR ( A , B , C ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int maxUniqueElements ( int [ ] Arr , int N ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . containsKey ( Arr [ i ] ) ) { mp . put ( Arr [ i ] , mp . get ( Arr [ i ] ) + 1 ) ; } else { mp . put ( Arr [ i ] , 1 ) ; } } int cnt = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( ( entry . getValue ( ) ) % 2 == 0 ) { cnt ++ ; } } int ans = mp . size ( ) ; if ( cnt % 2 == 1 ) { ans -- ; } return ans ; } public static void main ( String [ ] args ) { int N = 5 ; int A [ ] = { 1 , 2 , 1 , 3 , 7 } ; System . out . println ( maxUniqueElements ( A , N ) ) ; } }
import java . io . * ; class GFG { static int m = 1000000007 ; static int power ( int x , int y ) { int res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % m ; y = y >> 1 ; x = ( x * x ) % m ; } return res ; } static int countNDigitNumber ( int N ) { int ne = N / 2 + N % 2 ; int no = ( int ) Math . floor ( N / 2 ) ; return power ( 4 , ne ) * power ( 5 , no ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( countNDigitNumber ( N ) % m ) ; } }
import java . awt . * ; import java . util . * ; class GFG { static class pair < T , V > { T first ; V second ; } static void findPairs ( int p , int q , int r ) { ArrayList < Integer > v = new ArrayList < > ( ) ; for ( int i = p ; i <= q ; i ++ ) { if ( i % r == 0 ) { v . add ( i ) ; } } ArrayList < pair < Integer , Integer > > ans = new ArrayList < > ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { for ( int j = i + 1 ; j < v . size ( ) ; j ++ ) { if ( v . get ( i ) * v . get ( j ) >= p * q / 4 && v . get ( i ) * v . get ( j ) <= p * q ) { pair < Integer , Integer > x = new pair < > ( ) ; x . first = v . get ( i ) ; x . second = v . get ( j ) ; ans . add ( x ) ; } } } if ( ans . size ( ) == 0 ) { System . out . println ( - 1 ) ; } else { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . println ( ans . get ( i ) . first + " ▁ " + ans . get ( i ) . second ) ; } } } public static void main ( String [ ] args ) { int p = 14 , q = 30 , r = 5 ; findPairs ( p , q , r ) ; } }
import java . io . * ; class GFG { static int Kadane ( int arr [ ] , int n ) { int largestSum = 0 , currMax = 0 ; int currSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currSum += arr [ i ] ; currMax = Math . max ( currMax , arr [ i ] ) ; largestSum = Math . max ( largestSum , currMax * currSum ) ; if ( currSum < 0 ) { currMax = 0 ; currSum = 0 ; } } return largestSum ; } static int maximumWeight ( int arr [ ] , int n ) { int largestSum = Kadane ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = - arr [ i ] ; } largestSum = Math . max ( largestSum , Kadane ( arr , n ) ) ; return largestSum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , - 3 , 8 , - 2 , 5 } ; int N = arr . length ; System . out . println ( maximumWeight ( arr , N ) ) ; } }
public class GFG { static int maximumTurns ( int arr [ ] , int N ) { int Count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { while ( arr [ i ] % 2 == 0 ) { Count ++ ; arr [ i ] = arr [ i ] / 2 ; } } return Count ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 4 } ; int M = 3 , K = 2 ; int N = arr . length ; System . out . println ( maximumTurns ( arr , N ) ) ; } }
import java . io . * ; class GFG { public static void isPossible ( int W , int B , int D ) { if ( W > B ) { int temp = W ; W = B ; B = temp ; } if ( B > W * ( D + 1 ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } public static void main ( String [ ] args ) { int W = 2 ; int B = 5 ; int D = 2 ; isPossible ( W , B , D ) ; } }
import java . io . * ; class GFG { public static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } public static int maxGCDInRange ( int L , int R ) { int ans = 1 ; for ( int Z = R ; Z >= 1 ; Z -- ) { if ( ( R / Z ) - ( L - 1 ) / Z > 1 ) { ans = Z ; break ; } } return ans ; } public static void main ( String [ ] args ) { int L = 102 ; int R = 139 ; System . out . println ( maxGCDInRange ( L , R ) ) ; }
import java . io . * ; class GFG { static boolean isPrime ( int X ) { for ( int i = 2 ; i * i <= X ; i ++ ) if ( X % i == 0 ) return false ; return true ; } static void printPrimes ( int A [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = A [ i ] - 1 ; ; j -- ) { if ( isPrime ( j ) ) { System . out . print ( j + " ▁ " ) ; break ; } } for ( int j = A [ i ] + 1 ; ; j ++ ) { if ( isPrime ( j ) ) { System . out . print ( j + " ▁ " ) ; break ; } } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 17 , 28 } ; int N = A . length ; printPrimes ( A , N ) ; } }
class GFG { public static int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; } public static int findSmallest ( int M , int N ) { int x = findNum ( M , N ) ; return x - M ; } public static void main ( String args [ ] ) { int M = 100 , N = 28 ; System . out . println ( findSmallest ( M , N ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static int minTime ( int [ ] A , int n , int K ) { int max_ability = A [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { max_ability = Math . max ( max_ability , A [ i ] ) ; } int tmp [ ] = new int [ max_ability + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { tmp [ A [ i ] ] ++ ; } for ( int i = max_ability ; i >= 0 ; i -- ) { if ( tmp [ i ] != 0 ) { if ( tmp [ i ] * i < K ) { K -= ( i * tmp [ i ] ) ; tmp [ i / 2 ] += tmp [ i ] ; count += tmp [ i ] ; if ( K <= 0 ) { return count ; } } else { if ( K % i != 0 ) { count += ( K / i ) + 1 ; } else { count += ( K / i ) ; } return count ; } } } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 7 , 2 , 4 } ; int N = arr . length ; int K = 15 ; System . out . println ( minTime ( arr , N , K ) ) ; } }
class GFG { public static int minOperations ( int N ) { int [ ] arr = new int [ N ] ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = ( 2 * i ) + 1 ; sum = sum + arr [ i ] ; } int mid = 0 ; if ( N % 2 == 0 ) { mid = sum / N ; } else { mid = arr [ N / 2 ] ; } int ans = 0 ; for ( int i = 0 ; i < N / 2 ; i ++ ) { ans += mid - arr [ i ] ; } return ans ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . println ( minOperations ( N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static void Query ( int arr [ ] , int N , int Q [ ] [ ] ) { int mul = 1 ; int add = 0 ; for ( int i = 0 ; i < Q . length ; i ++ ) { if ( Q [ i ] [ 0 ] == 0 ) { add = add + Q [ i ] [ 1 ] ; } else if ( Q [ i ] [ 0 ] == 1 ) { mul = mul * Q [ i ] [ 1 ] ; add = add * Q [ i ] [ 1 ] ; } else { int ans = arr [ Q [ i ] [ 1 ] ] * mul + add ; System . out . print ( ans + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 1 , 23 , 45 , 100 } ; int N = arr . length ; int Q [ ] [ ] = { { 1 , 2 } , { 0 , 10 } , { 2 , 3 } , { 1 , 5 } , { 2 , 4 } } ; Query ( arr , N , Q ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static int getMaxPairSum ( int [ ] arr , int N , int K ) { int [ ] preMax = new int [ N ] ; preMax [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { preMax [ i ] = Math . max ( preMax [ i - 1 ] , arr [ i ] ) ; } int res = Integer . MIN_VALUE ; for ( int i = K ; i < N ; i ++ ) { res = Math . max ( res , arr [ i ] + preMax [ i - K ] ) ; } return res ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 8 , 6 , 3 } ; int K = 3 ; int N = arr . length ; System . out . print ( getMaxPairSum ( arr , N , K ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int CountPairs ( int arr [ ] , int N ) { int res = 0 ; Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Integer c = mp . get ( arr [ i ] ) ; mp . put ( arr [ i ] , ( c == null ) ? 1 : c + 1 ) ; } Iterator < Map . Entry < Integer , Integer > > itr = mp . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = itr . next ( ) ; int x = ( int ) entry . getKey ( ) ; int y = ( int ) entry . getValue ( ) ; if ( x == 1 ) { res += N - 1 ; continue ; } res += ( y * ( y - 1 ) ) / 2 ; for ( int j = 2 ; j <= Math . sqrt ( x ) ; j ++ ) { if ( x % j == 0 ) { res += mp . get ( j ) ; if ( j != x / j ) res += mp . get ( ( int ) x / j ) ; } } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 1 , 2 } ; int N = arr . length ; System . out . println ( CountPairs ( arr , N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int findMinSum ( int mat [ ] [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int res = 0 ; for ( int j = 0 ; j < N ; j ++ ) { if ( i != j ) { res |= mat [ i ] [ j ] ; } } sum += res ; } return sum ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { - 1 , 2 , 3 } , { 9 , - 1 , 7 } , { 4 , 5 , - 1 } } ; int N = mat . length ; System . out . println ( findMinSum ( mat , N ) ) ; } }
import java . util . * ; class GFG { static int maxAdjacentDifference ( ArrayList < Integer > A ) { int diff = 0 ; for ( int i = 1 ; i < ( int ) A . size ( ) ; i ++ ) { diff = Math . max ( diff , A . get ( i ) - A . get ( i - 1 ) ) ; } return diff ; } static int MinimumValue ( int arr [ ] , int N ) { int MinValue = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { ArrayList < Integer > new_arr = new ArrayList < > ( ) ; for ( int j = 0 ; j < N ; j ++ ) { if ( i == j ) continue ; new_arr . add ( arr [ j ] ) ; } MinValue = Math . min ( MinValue , maxAdjacentDifference ( new_arr ) ) ; } return MinValue ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 7 , 8 } ; int N = arr . length ; System . out . print ( MinimumValue ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int mod = 1000000007 ; static int power ( int x , int y ) { int res = 1 ; x = x % mod ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % mod ; y = y >> 1 ; x = ( x * x ) % mod ; } return res ; } static int antisymmetricRelation ( int N ) { return ( power ( 2 , N ) * power ( 3 , ( N * N - N ) / 2 ) ) % mod ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . print ( antisymmetricRelation ( N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static void countPairs ( int arr [ ] , int N ) { int even = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; } if ( N - even >= 1 ) { System . out . println ( even ) ; return ; } System . out . println ( 0 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 4 , 7 , 2 } ; int N = arr . length ; countPairs ( arr , N ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static boolean checkPermutation ( int ans [ ] , int a [ ] , int n ) { int Max = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { Max = Math . max ( Max , ans [ i ] ) ; if ( Max != a [ i ] ) return false ; } return true ; } static void findPermutation ( int a [ ] , int n ) { int ans [ ] = new int [ n ] ; HashMap < Integer , Integer > um = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! um . containsKey ( a [ i ] ) ) { ans [ i ] = a [ i ] ; um . put ( a [ i ] , i ) ; } } ArrayList < Integer > v = new ArrayList < > ( ) ; int j = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! um . containsKey ( i ) ) { v . add ( i ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans [ i ] == 0 ) { ans [ i ] = v . get ( j ) ; j ++ ; } } if ( checkPermutation ( ans , a , n ) ) { for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } } else System . out . println ( " - 1" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int N = arr . length ; findPermutation ( arr , N ) ; } }
import java . util . * ; class GFG { static void ValidPairs ( int X , int K ) { int count = 0 ; for ( int A = - 1000 ; A <= 1000 ; A ++ ) { for ( int B = - 1000 ; B <= 1000 ; B ++ ) { if ( Math . pow ( A , K ) - Math . pow ( B , K ) == X ) { count ++ ; System . out . println ( A + " ▁ " + B ) ; } } } if ( count == 0 ) { System . out . println ( " - 1" ) ; } } public static void main ( String args [ ] ) { int X = 33 ; int K = 5 ; ValidPairs ( X , K ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static void findXOR ( int mat [ ] [ ] [ ] , int N ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XOR ^= mat [ i ] [ i ] [ i ] ; XOR ^= mat [ i ] [ i ] [ N - i - 1 ] ; } System . out . println ( XOR ) ; } public static void main ( String [ ] args ) { int mat [ ] [ ] [ ] = { { { 1 , 2 } , { 3 , 4 } } , { { 5 , 6 } , { 7 , 8 } } } ; int N = mat . length ; findXOR ( mat , N ) ; } }
import java . util . * ; class GFG { static void checkWinner ( int arr [ ] , int N ) { int diff = 0 ; for ( int i = 0 ; i < N ; i ++ ) { diff -= arr [ i ] ; } if ( diff % 2 == 0 ) { System . out . println ( " A " ) ; } else { System . out . println ( " B " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 } ; int N = arr . length ; checkWinner ( arr , N ) ; } }
import java . io . * ; class GFG { static boolean checkEvenPower ( long N ) { if ( ( N & ( N - 1 ) ) != 0 ) return false ; N = N & 0x55555555 ; return ( N > 0 ) ; } public static void main ( String [ ] args ) { long N = 4 ; System . out . println ( checkEvenPower ( N ) ? 1 : 0 ) ; } }
import java . util . * ; class GFG { static int distinct ( int arr [ ] , int n ) { Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { set . add ( arr [ i ] ) ; } return set . size ( ) ; } static int maxSubSum ( int arr [ ] , int n , int k , int totalDistinct ) { if ( k > n ) return 0 ; int max = 0 , sum = 0 ; for ( int i = 0 ; i < n - k + 1 ; i ++ ) { sum = 0 ; Set < Integer > set = new HashSet < > ( ) ; for ( int j = i ; j < i + k ; j ++ ) { sum += arr [ j ] ; set . add ( arr [ j ] ) ; } if ( set . size ( ) == totalDistinct ) max = Math . max ( sum , max ) ; } return max ; } public static void main ( String args [ ] ) { int arr [ ] = { 7 , 7 , 2 , 4 , 2 , 7 , 4 , 6 , 6 , 6 } ; int K = 6 ; int N = arr . length ; int totalDistinct = distinct ( arr , N ) ; System . out . println ( maxSubSum ( arr , N , K , totalDistinct ) ) ; } }
import java . util . * ; class GFG { static void partitionArray ( int a [ ] , int n ) { int min [ ] = new int [ n ] ; int mini = Integer . MAX_VALUE ; for ( int i = n - 1 ; i >= 0 ; i -- ) { mini = Math . min ( mini , a [ i ] ) ; min [ i ] = mini ; } int maxi = Integer . MIN_VALUE ; int ind = - 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { maxi = Math . max ( maxi , a [ i ] ) ; if ( maxi < min [ i + 1 ] ) { ind = i ; break ; } } if ( ind != - 1 ) { for ( int i = 0 ; i <= ind ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; System . out . println ( ) ; for ( int i = ind + 1 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } else System . out . println ( " Impossible " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 3 , 2 , 7 , 9 } ; int N = arr . length ; partitionArray ( arr , N ) ; } }
import java . util . * ; class GFG { static int gcd ( int a , int b ) { while ( b > 0 ) { int rem = a % b ; a = b ; b = rem ; } return a ; } static int countNumberOfWays ( int n ) { if ( n == 1 ) return - 1 ; int g = 0 ; int power = 0 ; while ( n % 2 == 0 ) { power ++ ; n /= 2 ; } g = gcd ( g , power ) ; for ( int i = 3 ; i <= ( int ) Math . sqrt ( n ) ; i += 2 ) { power = 0 ; while ( n % i == 0 ) { power ++ ; n /= i ; } g = gcd ( g , power ) ; } if ( n > 2 ) g = gcd ( g , 1 ) ; int ways = 1 ; power = 0 ; while ( g % 2 == 0 ) { g /= 2 ; power ++ ; } ways *= ( power + 1 ) ; for ( int i = 3 ; i <= ( int ) Math . sqrt ( g ) ; i += 2 ) { power = 0 ; while ( g % i == 0 ) { power ++ ; g /= i ; } ways *= ( power + 1 ) ; } if ( g > 2 ) ways *= 2 ; return ways ; } public static void main ( String [ ] args ) { int N = 64 ; System . out . print ( countNumberOfWays ( N ) ) ; } }
public class GFG { static int count ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 7 * Math . pow ( 8 , i - 1 ) ; } return sum ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( count ( N ) ) ; } }
class GFG { static int maxValue ( int n ) { return n ; } public static void main ( String [ ] args ) { int n = 1 ; System . out . print ( maxValue ( n ) ) ; } }
class GFG { static int usingBinarySearch ( int start , int end , int N , int S ) { if ( start >= end ) return start ; int mid = start + ( end - start ) / 2 ; int totalSum = ( N * ( N + 1 ) ) / 2 ; int midSum = ( mid * ( mid + 1 ) ) / 2 ; if ( ( totalSum - midSum ) <= S ) { return usingBinarySearch ( start , mid , N , S ) ; } return usingBinarySearch ( mid + 1 , end , N , S ) ; } public static void main ( String [ ] args ) { int N , S ; N = 5 ; S = 11 ; System . out . println ( N - usingBinarySearch ( 1 , N , N , S ) + 1 ) ; } }
class GFG { static void equal_xor_sum ( int arr [ ] , int n ) { int Sum = 0 ; int Xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { Sum = Sum + arr [ i ] ; Xor = Xor ^ arr [ i ] ; } if ( Sum == Xor ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 3 , 7 , 10 } ; int n = arr . length ; equal_xor_sum ( arr , n ) ; } }
class GFG { static int set_bits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n % 2 ; n /= 2 ; } return count ; } static int minSteps ( int n ) { int ans = 0 ; while ( n != 1 ) { if ( n % 2 == 0 ) n /= 2 ; else if ( n == 3 || set_bits ( n - 1 ) < set_bits ( n + 1 ) ) n -- ; else n ++ ; ans ++ ; } return ans ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . print ( minSteps ( n ) ) ; } }
class GFG { static int lcm ( int a , int b ) { return ( a / __gcd ( a , b ) * b ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static void findNums ( int x ) { int ans = - 1 ; for ( int i = 1 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 && lcm ( i , x / i ) == x ) { ans = i ; } } System . out . print ( ans + " ▁ " + ( x / ans ) ) ; } public static void main ( String [ ] args ) { int x = 12 ; findNums ( x ) ; } }
class GFG { static int minOR ( int [ ] arr , int n ) { if ( n == 1 ) return 0 ; int [ ] pre = new int [ n ] ; int [ ] suf = new int [ n ] ; pre [ 0 ] = arr [ 0 ] ; suf [ n - 1 ] = arr [ n - 1 ] ; for ( int i = 1 ; i < n ; i ++ ) pre [ i ] = ( pre [ i - 1 ] arr [ i ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) suf [ i ] = ( suf [ i + 1 ] arr [ i ] ) ; int ans = Math . min ( pre [ n - 2 ] , suf [ 1 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) ans = Math . min ( ans , ( pre [ i - 1 ] suf [ i + 1 ] ) ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( minOR ( arr , n ) ) ; } }
class GFG { static int findCnt ( int [ ] arr , int n , int k ) { int ret = 0 ; int i = 0 ; while ( i < n ) { int j = i + 1 ; while ( j < n && arr [ j ] >= arr [ j - 1 ] ) j ++ ; int x = Math . max ( 0 , j - i - k + 1 ) ; ret += ( x * ( x + 1 ) ) / 2 ; i = j ; } return ret ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 4 , 3 , 2 , 1 } ; int n = arr . length ; int k = 2 ; System . out . println ( findCnt ( arr , n , k ) ) ; } }
import java . util . * ; class GFG { static int two_sets ( int a [ ] , int n ) { Arrays . sort ( a ) ; return a [ n / 2 ] - a [ ( n / 2 ) - 1 ] ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 4 , 6 , 7 , 9 } ; int n = a . length ; System . out . println ( two_sets ( a , n ) ) ; } }
class GFG { static int kthNum ( int n , int k ) { int a = ( n + 1 ) / 2 ; if ( k > a ) return ( 2 * ( k - a ) ) ; return ( 2 * k - 1 ) ; } public static void main ( String [ ] args ) { int n = 7 , k = 7 ; System . out . println ( kthNum ( n , k ) ) ; } }
class GFG { static int count ( int n ) { return n * ( 3 * n - 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( count ( n ) ) ; } }
class GFG { static int findMissing ( int arr [ ] , int n , int k , int avg ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } int num = ( avg * ( n + k ) ) - sum ; int den = k ; if ( num % den != 0 ) return - 1 ; return ( int ) ( num / den ) ; } public static void main ( String [ ] args ) { int k = 3 , avg = 4 ; int arr [ ] = { 2 , 7 , 3 } ; int n = arr . length ; System . out . println ( findMissing ( arr , n , k , avg ) ) ; } }
class GFG { static int sum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } sum = sum * ( int ) Math . pow ( 2 , n - 1 ) ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 5 , 6 } ; int n = arr . length ; System . out . println ( sum ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int prevPowerof2 ( int n ) { int p = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; return ( int ) Math . pow ( 2 , p ) ; } static int nextPowerOf2 ( int n ) { int p = 1 ; if ( ( n == 0 ) && ! ( ( n & ( n - 1 ) ) == 0 ) ) return n ; while ( p < n ) p <<= 1 ; return p ; } static int minDiff ( int n ) { int low = prevPowerof2 ( n ) ; int high = nextPowerOf2 ( n ) ; return Math . min ( n - low , high - n ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( minDiff ( n ) ) ; } }
class GFG { static int MAX = 10 ; static boolean isFactorion ( int n ) { int fact [ ] = new int [ MAX ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < MAX ; i ++ ) fact [ i ] = i * fact [ i - 1 ] ; int org = n ; int sum = 0 ; while ( n > 0 ) { int d = n % 10 ; sum += fact [ d ] ; n /= 10 ; } if ( sum == org ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 40585 ; if ( isFactorion ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static final int MOD = 1000000007 ; static int modFact ( int n , int m ) { int result = 1 ; for ( int i = 1 ; i <= m ; i ++ ) result = ( result * i ) % MOD ; return result ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( modFact ( n , m ) ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int maxCommonFactors ( int a , int b ) { int __gcd = gcd ( a , b ) ; int ans = 1 ; for ( int i = 2 ; i * i <= __gcd ; i ++ ) { if ( __gcd % i == 0 ) { ans ++ ; while ( __gcd % i == 0 ) __gcd /= i ; } } if ( __gcd != 1 ) ans ++ ; return ans ; } public static void main ( String [ ] args ) { int a = 12 , b = 18 ; System . out . println ( maxCommonFactors ( a , b ) ) ; } }
class GFG { static int countUnsetBits ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int temp = i ; while ( temp > 0 ) { if ( temp % 2 == 0 ) { cnt = cnt + 1 ; } temp = temp / 2 ; } } return cnt ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countUnsetBits ( n ) ) ; } }
class GFG { static boolean isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int digit = ( int ) n % 10 ; sum += digit ; n /= 10 ; } n = temp ; while ( n != 0 ) { int digit = ( int ) n % 10 ; if ( sum % digit != 0 ) return false ; n /= 10 ; } return true ; } public static void main ( String [ ] args ) { long n = 123 ; if ( isDivisible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int COST = 3 ; static int maxItems ( int x , int y , int z ) { int type1 = x / COST ; x %= COST ; int type2 = y / COST ; y %= COST ; int type3 = z / COST ; z %= COST ; int type4 = Math . min ( x , Math . min ( y , z ) ) ; int maxItems = type1 + type2 + type3 + type4 ; return maxItems ; } public static void main ( String [ ] args ) { int x = 4 , y = 5 , z = 6 ; System . out . println ( maxItems ( x , y , z ) ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static pair countSum ( int arr [ ] , int n ) { int NumberOfOdds = 0 , NumberOfEvens = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) NumberOfOdds ++ ; NumberOfEvens = n - NumberOfOdds ; int NumberOfOddSubsequences = ( 1 << NumberOfEvens ) * ( 1 << ( NumberOfOdds - 1 ) ) ; int NumberOfEvenSubsequences = ( 1 << n ) - 1 - NumberOfOddSubsequences ; return new pair ( NumberOfEvenSubsequences , NumberOfOddSubsequences ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = arr . length ; pair ans = countSum ( arr , n ) ; System . out . print ( " EvenSum ▁ = ▁ " + ans . first ) ; System . out . print ( " ▁ OddSum ▁ = ▁ " + ans . second ) ; } }
import java . util . * ; class GFG { static boolean prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static void prime_range ( int start , int end , int [ ] a ) { for ( int i = start ; i < end ; i ++ ) { if ( prime ( a [ i ] ) ) System . out . print ( a [ i ] + " ▁ " ) ; } } static void Print ( int arr [ ] , int n ) { System . out . print ( " Prime ▁ numbers ▁ in ▁ the ▁ first ▁ half ▁ are ▁ " ) ; prime_range ( 0 , n / 2 , arr ) ; System . out . println ( ) ; System . out . print ( " Prime ▁ numbers ▁ in ▁ the ▁ second ▁ half ▁ are ▁ " ) ; prime_range ( n / 2 , n , arr ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 10 , 15 , 17 , 21 , 23 } ; int n = arr . length ; Print ( arr , n ) ; } }
import java . io . * ; class GFG { static int FindElement ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + a [ i ] ; if ( sum % n == 0 ) { int m = sum / n ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == m ) return m ; } return - 1 ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = a . length ; System . out . print ( FindElement ( a , n ) ) ; } }
import java . io . * ; class GFG { static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int Count_number ( int N ) { return ( N * fact ( N ) ) ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . print ( Count_number ( N ) ) ; } }
import java . io . * ; class GFG { static int findHours ( int a , int b , int k ) { if ( a >= b ) return - 1 ; int time = k / ( b - a ) ; time = time + 1 ; return time ; } public static void main ( String [ ] args ) { int a = 4 , b = 5 , k = 1 ; System . out . println ( findHours ( a , b , k ) ) ; } }
import java . io . * ; class GFG { static int ncr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; } static int NoOfDistributions ( int N , int R ) { return ncr ( N - 1 , R - 1 ) ; } public static void main ( String [ ] args ) { int N = 4 ; int R = 3 ; System . out . println ( NoOfDistributions ( N , R ) ) ; } }
import java . util . Collections ; import java . util . Vector ; class GFG { static int MinRemove ( int [ ] a , int n , int k ) { int [ ] cnt = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) cnt [ 0 ] ++ ; else if ( cnt [ a [ i ] - 1 ] > 0 ) { cnt [ a [ i ] - 1 ] -- ; cnt [ a [ i ] ] ++ ; } } return n - ( k * cnt [ k - 1 ] ) ; } public static void main ( String [ ] args ) { int a [ ] = { 0 , 1 , 2 , 3 , 4 , 0 , 1 , 0 , 1 , 2 , 3 , 4 } ; int k = 5 ; int n = a . length ; System . out . println ( MinRemove ( a , n , k ) ) ; } }
class GFG { static void LowerHessenbergMatrix ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j > i + 1 ) System . out . print ( '0' + " ▁ " ) ; else { System . out . printf ( " % .0f " , Math . random ( ) * 10 ) ; System . out . print ( " ▁ " ) ; } } System . out . println ( "NEW_LINE"); } } public static void main ( String [ ] args ) { int n = 4 ; LowerHessenbergMatrix ( n ) ; } }
class Rectangle { static int count ( int N ) { int a = 0 ; a = ( N * ( N + 1 ) ) / 2 ; return a ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . print ( count ( n ) ) ; } }
class GFG { static boolean isMersenne ( int n ) { while ( n != 0 ) { int r = n % 2 ; if ( r == 0 ) return false ; n /= 2 ; } return true ; } static int sumOfMersenne ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 && isMersenne ( arr [ i ] ) ) { sum += arr [ i ] ; } } return sum ; } public static void main ( String [ ] args ) { int [ ] arr = { 17 , 6 , 7 , 63 , 3 } ; int n = arr . length ; System . out . print ( sumOfMersenne ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int numberOfDays ( int a , int b , int n ) { int Days = b * ( n + a ) / ( a + b ) ; return Days ; } public static void main ( String [ ] args ) { int a = 10 , b = 20 , n = 5 ; System . out . println ( numberOfDays ( a , b , n ) ) ; } }
class GFG { static long squareSeries ( long n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } static long maxPeople ( long n ) { long low = 0 ; long high = 1000000L ; long ans = 0L ; while ( low <= high ) { long mid = low + ( ( high - low ) / 2 ) ; long value = squareSeries ( mid ) ; if ( value <= n ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; } public static void main ( String [ ] args ) { long p = 14 ; System . out . println ( maxPeople ( p ) ) ; } }
import java . io . * ; class GFG { static void solve ( long a , long b ) { if ( a > 0 && b > 0 ) { System . out . println ( " Positive " ) ; } else if ( a <= 0 && b >= 0 ) { System . out . println ( " Zero " ) ; } else { long n = Math . abs ( a - b ) + 1 ; if ( n % 2 == 0 ) { System . out . println ( " Positive " ) ; } else { System . out . println ( " Negative " ) ; } } } public static void main ( String [ ] args ) { int a = - 10 , b = - 2 ; solve ( a , b ) ; } }
class GFG { static int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; } static int sumFactorial ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; } public static void main ( String [ ] args ) { int [ ] arr = { 7 , 3 , 5 , 4 , 8 } ; int n = arr . length ; System . out . println ( sumFactorial ( arr , n ) ) ; } }
class GFG { static void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) System . out . println ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ identical " ) ; else System . out . println ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ not ▁ identical " ) ; } public static void main ( String [ ] args ) { double a1 = - 2 , b1 = 4 , c1 = 3 , a2 = - 6 , b2 = 12 , c2 = 9 ; idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) ; } }
class GFG { static int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . pow ( 10 , n - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( smallestMultiple ( n ) ) ; } }
import java . util . HashMap ; class GFG { static int maxlen = 100 ; public static void generateSubStrings ( String s , HashMap < String , Integer > mpp ) { int l = s . length ( ) ; for ( int i = 0 ; i < l ; i ++ ) { String temp = " " ; for ( int j = i ; j < l ; j ++ ) { temp += s . charAt ( j ) ; if ( mpp . containsKey ( temp ) ) { int x = mpp . get ( temp ) ; mpp . put ( temp , ++ x ) ; } else mpp . put ( temp , 1 ) ; } } } public static void binomialCoeff ( int [ ] [ ] C ) { int i , j ; for ( i = 1 ; i < 100 ; i ++ ) { for ( j = 0 ; j < 100 ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } } public static int answerQuery ( HashMap < String , Integer > mpp , int [ ] [ ] C , int k ) { int ans = 0 ; for ( HashMap . Entry < String , Integer > entry : mpp . entrySet ( ) ) { if ( entry . getValue ( ) >= k ) ans += C [ entry . getValue ( ) ] [ k ] ; } return ans ; } public static void main ( String [ ] args ) { String s = " aabaab " ; HashMap < String , Integer > mpp = new HashMap < > ( ) ; generateSubStrings ( s , mpp ) ; int [ ] [ ] C = new int [ maxlen ] [ maxlen ] ; binomialCoeff ( C ) ; int [ ] queries = { 2 , 3 , 4 } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( answerQuery ( mpp , C , queries [ i ] ) ) ; } }
class GFG { static long computeXOR ( int n ) { int x = n & 3 ; switch ( x ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } return 0 ; } public static void main ( String args [ ] ) { int l = 1 , r = 4 ; System . out . println ( computeXOR ( r ) ^ computeXOR ( l - 1 ) ) ; } }
import java . lang . Math ; class GFG { static int fib ( int n ) { double phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return ( int ) Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; } public static void main ( String [ ] args ) { int l = 4 , r = 8 ; System . out . println ( calculateSum ( l , r ) ) ; } }
class GFG { static int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * ( int ) Math . pow ( 10 , n / 2 - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . print ( countNumbers ( n ) ) ; } }
class GFG { static double getProbability ( int a , int b , int c , int d ) { double p = ( double ) a / ( double ) b ; double q = ( double ) c / ( double ) d ; double ans = p * ( 1 / ( 1 - ( 1 - q ) * ( 1 - p ) ) ) ; return ans ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 10 , d = 11 ; System . out . printf ( " % .5f " , getProbability ( a , b , c , d ) ) ; } }
class GfG { static int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * ( int ) Math . pow ( 2 , occ ) ; occ -- ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = arr . length ; System . out . println ( findMinSum ( arr , n ) ) ; } }
class GFG { static final int n = 3 ; static int matrixSum ( int arr [ ] [ ] ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; System . out . println ( matrixSum ( arr ) ) ; } }
import java . util . * ; class GfG { static int N = 100005 ; static boolean isprime [ ] = new boolean [ N ] ; static boolean can [ ] = new boolean [ N ] ; static ArrayList < Integer > SieveOfEratosthenes ( ) { for ( int a = 0 ; a < isprime . length ; a ++ ) { isprime [ a ] = true ; } for ( int p = 2 ; p * p < N ; p ++ ) { if ( isprime [ p ] == true ) { for ( int i = p * p ; i < N ; i += p ) isprime [ i ] = false ; } } ArrayList < Integer > primes = new ArrayList < Integer > ( ) ; for ( int i = 2 ; i < N ; i ++ ) if ( isprime [ i ] ) primes . add ( i ) ; return primes ; } static int Prime_Numbers ( int n ) { ArrayList < Integer > primes = SieveOfEratosthenes ( ) ; for ( int i = 0 ; i < ( int ) ( primes . size ( ) ) - 1 ; i ++ ) if ( primes . get ( i ) + primes . get ( i + 1 ) + 1 < N ) can [ primes . get ( i ) + primes . get ( i + 1 ) + 1 ] = true ; int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( can [ i ] && isprime [ i ] == true ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int n = 50 ; System . out . println ( Prime_Numbers ( n ) ) ; } }
import java . util . * ; import java . text . DecimalFormat ; class GFG { static void midptellipse ( float rx , float ry , float xc , float yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ; d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25f * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ; DecimalFormat df = new DecimalFormat ( " # , # # # , # #0.00000" ) ; while ( dx < dy ) { System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } } d2 = ( ( ry * ry ) * ( ( x + 0.5f ) * ( x + 0.5f ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ; while ( y >= 0 ) { System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( y + yc ) ) ) ; System . out . println ( df . format ( ( x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; System . out . println ( df . format ( ( - x + xc ) ) + " , ▁ " + df . format ( ( - y + yc ) ) ) ; if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } } public static void main ( String args [ ] ) { midptellipse ( 10 , 15 , 50 , 50 ) ; } }
import java . io . * ; class GFG { static void alter ( long x , long y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } System . out . println ( " X ▁ = ▁ " + x + " , ▁ " + " Y ▁ = ▁ " + y ) ; } public static void main ( String [ ] args ) { long x = 12 , y = 5 ; alter ( x , y ) ; } }
class GFG { static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } static int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } static int countWays ( String str ) { int freq [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; } int nvowels = 0 , nconsonants = 0 ; int vplaces , cways , vways ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ freq [ str . charAt ( i ) - ' a ' ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) nvowels += freq [ i ] ; else nconsonants += freq [ i ] ; } vplaces = nconsonants + 1 ; cways = factorial ( nconsonants ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { cways = cways / factorial ( freq [ i ] ) ; } } vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { vways = vways / factorial ( freq [ i ] ) ; } } return cways * vways ; } public static void main ( String [ ] args ) { String str = " permutation " ; System . out . println ( countWays ( str ) ) ; } }
import java . util . * ; class GFG { static void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } static int sumOfElements ( int arr [ ] , int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , n + 1 ) ; int i , j ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; else m . put ( arr [ i ] , 1 ) ; } int sum = 0 ; for ( Map . Entry < Integer , Integer > entry : m . entrySet ( ) ) { int key = entry . getKey ( ) ; int value = entry . getValue ( ) ; if ( prime [ value ] ) { sum += ( key ) ; } } return sum ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 4 , 6 , 5 , 4 , 6 } ; int n = arr . length ; System . out . println ( sumOfElements ( arr , n ) ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int totalPairs ( int [ ] arr1 , int [ ] arr2 , int K , int n , int m ) { HashSet < pair > s = new HashSet < pair > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( arr1 [ i ] > arr2 [ j ] ) { if ( arr1 [ i ] % arr2 [ j ] == K ) s . add ( new pair ( arr1 [ i ] , arr2 [ j ] ) ) ; } else { if ( arr2 [ j ] % arr1 [ i ] == K ) s . add ( new pair ( arr2 [ j ] , arr1 [ i ] ) ) ; } } } return s . size ( ) ; } public static void main ( String [ ] args ) { int [ ] arr1 = { 8 , 3 , 7 , 50 } ; int [ ] arr2 = { 5 , 1 , 10 , 4 } ; int K = 3 ; int n = arr1 . length ; int m = arr2 . length ; System . out . println ( totalPairs ( arr1 , arr2 , K , n , m ) ) ; } }
import java . util . * ; class GFG { static Vector < Integer > findPrime ( int MAX ) { boolean pm [ ] = new boolean [ MAX + 1 ] ; for ( int i = 0 ; i < pm . length ; i ++ ) pm [ i ] = true ; pm [ 0 ] = pm [ 1 ] = false ; for ( int i = 2 ; i <= MAX ; i ++ ) if ( pm [ i ] ) for ( int j = 2 * i ; j <= MAX ; j += i ) pm [ j ] = false ; Vector < Integer > prime = new Vector < Integer > ( ) ; for ( int i = 0 ; i <= MAX ; i ++ ) if ( pm [ i ] ) prime . add ( i ) ; return prime ; } static int max_element ( int arr [ ] ) { int max = arr [ 0 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) max = Math . max ( max , arr [ i ] ) ; return max ; } static int findSmallest ( int arr [ ] , int n ) { int MAX = max_element ( arr ) ; Vector < Integer > prime = findPrime ( MAX ) ; Set < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) s . add ( arr [ i ] ) ; long ans = - 1 ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { if ( ! s . contains ( prime . get ( i ) ) ) { ans = ( prime . get ( i ) ) ; break ; } } return ( int ) ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 0 , 1 , 2 , 7 } ; int n = arr . length ; if ( findSmallest ( arr , n ) == - 1 ) System . out . print ( " No ▁ prime ▁ number ▁ missing " ) ; else System . out . print ( findSmallest ( arr , n ) ) ; } }
public class GFG { static void profitLoss ( int N , int M ) { if ( N == M ) System . out . print ( " No ▁ Profit ▁ nor ▁ Loss " ) ; else { float result = 0 ; result = ( float ) ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) System . out . print ( " Loss ▁ = ▁ - " + result * 100 + " % " ) ; else System . out . print ( " Profit ▁ = ▁ " + result * 100 + " % " ) ; } } public static void main ( String [ ] args ) { int N = 8 , M = 9 ; profitLoss ( N , M ) ; } }
import java . util . * ; class solution { static boolean SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; } public static void main ( String arr [ ] ) { int n = 592452 ; int k = 3 ; if ( SumDivisible ( n , k ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; class GFG { static boolean sumDivisible ( int n , int k ) { int sum = 0 ; String num = Integer . toString ( n ) ; int i ; for ( i = 0 ; i < num . length ( ) ; i ++ ) { if ( i % 2 != 0 ) { sum = sum + ( num . charAt ( i ) - '0' ) ; } } if ( sum % k == 0 ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { int n = 592452 ; int k = 3 ; if ( sumDivisible ( n , k ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
public class GFG { static int EqualNumbers ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n != 0 ) return n - 1 ; return n ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 4 , 1 } ; int n = a . length ; System . out . println ( EqualNumbers ( a , n ) ) ; } }
import java . io . * ; class GFG { static void PossibleValues ( int b , int x , int n ) { int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { System . out . print ( leastdivisible - b + " ▁ " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) System . out . println ( - 1 ) ; } public static void main ( String [ ] args ) { int b = 10 , x = 6 , n = 40 ; PossibleValues ( b , x , n ) ; } }
import java . util . * ; class GFG { static int MAX = 10000 ; static HashSet < Integer > s = new HashSet < Integer > ( ) ; static void SieveOfEratosthenes ( ) { boolean [ ] prime = new boolean [ MAX ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } int product = 1 ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { product = product * p ; s . add ( product + 1 ) ; } } } static boolean isEuclid ( int n ) { if ( s . contains ( n ) ) return true ; else return false ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 31 ; if ( isEuclid ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; n = 42 ; if ( isEuclid ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , c = 3 , d = 4 ; System . out . println ( NumberOfSolutions ( a , b , c , d ) ) ; } }
import java . util . * ; class solution { static int nthTerm ( int n ) { return 2 * ( int ) Math . pow ( n , 2 ) + 4 * n - 2 ; } public static void main ( String arr [ ] ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
class GFG { static int calculateAreaSum ( int l , int b ) { int size = 1 ; int maxSize = Math . min ( l , b ) ; int totalArea = 0 ; for ( int i = 1 ; i <= maxSize ; i ++ ) { int totalSquares = ( l - size + 1 ) * ( b - size + 1 ) ; int area = totalSquares * size * size ; totalArea += area ; size ++ ; } return totalArea ; } public static void main ( String [ ] args ) { int l = 4 , b = 3 ; System . out . println ( calculateAreaSum ( l , b ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int check ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n = n / 10 ; } if ( sum % 7 == 0 ) return 1 ; else return 0 ; } public static void main ( String args [ ] ) { int n = 25 ; String s = ( check ( n ) == 1 ) ? " YES " : " NO " ; System . out . println ( s ) ; } }
class Geeks { static int binomialCoeff ( int x , int n , int k ) { int sum = 0 , term = 1 ; for ( int i = 1 ; i <= n && sum < k ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; } return sum ; } static int minTrials ( int n , int k ) { int low = 1 , high = k ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( binomialCoeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; } public static void main ( String args [ ] ) { System . out . println ( minTrials ( 2 , 10 ) ) ; } }
import java . lang . * ; class Geeks { static boolean isPrime ( int num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( int i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; } static int primePalindrome ( int N ) { if ( 8 <= N && N <= 11 ) return 11 ; for ( int x = 1 ; x < 100000 ; ++ x ) { String s = Integer . toString ( x ) ; StringBuffer buffer = new StringBuffer ( s ) ; buffer . reverse ( ) ; int y = Integer . parseInt ( s + buffer . substring ( 1 ) . toString ( ) ) ; if ( y >= N && isPrime ( y ) == true ) return y ; } return - 1 ; } public static void main ( String args [ ] ) { System . out . print ( primePalindrome ( 112 ) ) ; } }
import java . io . * ; class GFG { static int boost_hyperfactorial ( int num ) { int val = 1 ; for ( int i = 1 ; i <= num ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { val *= i ; } } return val ; } public static void main ( String [ ] args ) { int num = 5 ; System . out . println ( boost_hyperfactorial ( num ) ) ; } }
import java . io . * ; class GFG { static int countOddSum ( int ar [ ] , int n ) { int temp [ ] = { 1 , 0 } ; int result = 0 , val = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = temp [ 0 ] * temp [ 1 ] ; return ( result ) ; } public static void main ( String [ ] args ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = ar . length ; System . out . println ( " The ▁ Number ▁ of ▁ Subarrays " + " ▁ with ▁ odd ▁ sum ▁ is ▁ " + countOddSum ( ar , n ) ) ; } }
import java . io . * ; class GFG { static int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . print ( n + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " ) ; System . out . println ( center_hexadecagonal_num ( n ) ) ; n = 12 ; System . out . print ( n + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " ) ; System . out . println ( center_hexadecagonal_num ( n ) ) ; } }
import java . io . * ; class GFG { static void check ( long m , long n ) { double RHS = m * ( double ) Math . log ( n ) ; double LHS = n * ( double ) Math . log ( m ) ; if ( LHS > RHS ) System . out . print ( " m ^ n ▁ > ▁ n ^ m " ) ; else if ( LHS < RHS ) System . out . print ( " m ^ n ▁ < ▁ n ^ m " ) ; else System . out . print ( " m ^ n ▁ = ▁ n ^ m " ) ; } static public void main ( String [ ] args ) { long m = 987654321 , n = 123456987 ; check ( m , n ) ; } }
import java . io . * ; class GFG { static int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int calculateSeries ( int n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( calculateSeries ( n ) ) ; } }
class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . util . * ; class GFG { static Vector < Long > gen ( long n , Vector < Long > r ) { long a = r . get ( r . size ( ) - 1 ) ; a ++ ; for ( int i = 1 ; i <= n ; a += 2 , i ++ ) { r . add ( a ) ; } return r ; } static Vector < Long > conell ( long n ) { Vector < Long > res = new Vector < Long > ( ) ; long k = 1 ; res . add ( 0L ) ; while ( true ) { res = gen ( k , res ) ; k ++ ; int j = res . size ( ) - 1 ; while ( j != n && j + k > n ) { k -- ; } if ( j >= n ) { break ; } } res . remove ( 0 ) ; return res ; } public static void main ( String [ ] args ) { long n = 10 ; System . out . println ( " The ▁ first ▁ " + n + " ▁ terms ▁ are " ) ; Vector < Long > res = conell ( n ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) { System . out . print ( res . get ( i ) + " ▁ " ) ; } System . out . println ( ) ; } }
import java . io . * ; class GFG { static void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int n = 5 ; NicomachuTheorum_sum ( n ) ; } }
import java . io . * ; class GFG { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } static int LCMOfNeighbourFact ( int n ) { return factorial ( n + 1 ) ; } public static void main ( String args [ ] ) { int N = 5 ; System . out . println ( LCMOfNeighbourFact ( N ) ) ; } }
import java . io . * ; class GFG { static boolean isPrime ( int n ) { if ( n == 0 n == 1 ) return false ; int root = ( int ) Math . sqrt ( n ) ; for ( int i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static boolean isSandwitched ( int n ) { return ( isPrime ( n - 1 ) && isPrime ( n + 1 ) ) ; } public static void main ( String [ ] args ) { int n = 642 ; System . out . print ( n + " ▁ : ▁ " ) ; if ( isSandwitched ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; n = 9 ; System . out . print ( n + " ▁ : ▁ " ) ; if ( isSandwitched ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static boolean isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 10 ; if ( isSquareFree ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } public static void main ( String args [ ] ) throws IOException { int n = 30 ; System . out . println ( sumofoddFactors ( n ) ) ; } }
class GFG { static int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; } public static void main ( String [ ] args ) { int n = 5 ; int val = 20 ; System . out . print ( countSolutions ( n , val ) ) ; } }
import java . io . * ; import static java . lang . Math . * ; class narcissistic { int countDigit ( int n ) { if ( n == 0 ) return 0 ; return 1 + countDigit ( n / 10 ) ; } boolean check ( int n ) { int l = countDigit ( n ) ; int dup = n ; int sum = 0 ; while ( dup > 0 ) { sum += pow ( dup % 10 , l ) ; dup /= 10 ; } return ( n == sum ) ; } public static void main ( String args [ ] ) { narcissistic obj = new narcissistic ( ) ; int n = 1634 ; if ( obj . check ( n ) ) System . out . println ( " yes " ) ; else System . out . println ( " no " ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int sameRemainder ( int a , int b , int c ) { int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; } public static void main ( String [ ] args ) { int a = 62 , b = 132 , c = 237 ; System . out . println ( sameRemainder ( a , b , c ) ) ; } }
import java . io . * ; class GFG { static char [ ] PrimeDigitNumber ( char N [ ] , int size ) { char [ ] ans = new char [ size ] ; int ns = 0 ; int small = 0 ; int i ; int p [ ] = { 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 } ; int prevprime [ ] = { 0 , 0 , 0 , 2 , 3 , 3 , 5 , 5 , 7 , 7 } ; if ( size == 1 ) { ans [ 0 ] = ( char ) ( prevprime [ N [ 0 ] - '0' ] + '0' ) ; ans [ 1 ] = ' \0' ; return ans ; } if ( N [ 0 ] == '1' ) { for ( i = 0 ; i < size - 1 ; i ++ ) ans [ i ] = '7' ; ans [ size - 1 ] = ' \0' ; return ans ; } for ( i = 0 ; i < size && small == 0 ; i ++ ) { if ( p [ N [ i ] - '0' ] == 1 ) { ans [ ns ++ ] = N [ i ] ; } else { if ( p [ N [ i ] - '0' ] == 0 && prevprime [ N [ i ] - '0' ] != 0 ) { ans [ ns ++ ] = ( char ) ( prevprime [ N [ i ] - '0' ] + '0' ) ; small = 1 ; } else if ( p [ N [ i ] - '0' ] == 0 && prevprime [ N [ i ] - '0' ] == 0 ) { int j = i ; while ( j > 0 && p [ N [ j ] - '0' ] == 0 && prevprime [ N [ j ] - '0' ] == 0 ) { ans [ j ] = N [ j ] = '7' ; N [ j - 1 ] = ( char ) ( prevprime [ N [ j - 1 ] - '0' ] + '0' ) ; ans [ j - 1 ] = N [ j - 1 ] ; small = 1 ; j -- ; } i = ns ; } } } if ( small == 0 ) { if ( prevprime [ N [ size - 1 ] - '0' ] + '0' != '0' ) ans [ size - 1 ] = ( char ) ( prevprime [ N [ size - 1 ] - '0' ] + '0' ) ; else { int j = size - 1 ; while ( j > 0 && prevprime [ N [ j ] - '0' ] == 0 ) { ans [ j ] = N [ j ] = '7' ; N [ j - 1 ] = ( char ) ( prevprime [ N [ j - 1 ] - '0' ] + '0' ) ; ans [ j - 1 ] = N [ j - 1 ] ; small = 1 ; j -- ; } } } for ( ; ns < size ; ns ++ ) ans [ ns ] = '7' ; ans [ ns ] = ' \0' ; int k = 0 ; while ( ans [ k ] == '0' ) k ++ ; return ans ; } public static void main ( String [ ] args ) { char [ ] N = "1000" . toCharArray ( ) ; int size = N . length ; System . out . println ( PrimeDigitNumber ( N , size ) ) ; } }
class GFG { static boolean isPowerOfK ( int n , int k ) { boolean oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; } public static void main ( String [ ] args ) { int n = 64 , k = 4 ; if ( isPowerOfK ( n , k ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class GFG { static int calcScr ( ArrayList < Integer > arr ) { int ans = 0 ; for ( int i = 0 ; i < arr . size ( ) ; i ++ ) ans += ( i ^ arr . get ( i ) ) ; return ans ; } static int getMax ( ArrayList < Integer > arr , int ans , ArrayList < Boolean > chosen , int N ) { if ( arr . size ( ) == N ) { ans = Math . max ( ans , calcScr ( arr ) ) ; return ans ; } for ( int i = 0 ; i < N ; i ++ ) { if ( chosen . get ( i ) ) continue ; chosen . set ( i , true ) ; arr . add ( i ) ; ans = getMax ( arr , ans , chosen , N ) ; chosen . set ( i , false ) ; arr . remove ( arr . size ( ) - 1 ) ; } return ans ; } public static void main ( String [ ] args ) { int N = 2 ; ArrayList < Integer > arr = new ArrayList < Integer > ( ) ; int ans = - 1 ; ArrayList < Boolean > chosen = new ArrayList < Boolean > ( Collections . nCopies ( N , false ) ) ; ans = getMax ( arr , ans , chosen , N ) ; System . out . print ( ans + "NEW_LINE"); } }
import java . util . * ; class solution { static void findPrimeNos ( int L , int R , Map < Integer , Integer > M , int K ) { for ( int i = L ; i <= R ; i ++ ) { if ( M . get ( i ) != null ) M . put ( i , M . get ( i ) + 1 ) ; else M . put ( i , 1 ) ; } if ( M . get ( 1 ) != null ) { M . remove ( 1 ) ; } for ( int i = 2 ; i <= Math . sqrt ( R ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= R ) { if ( M . get ( i * multiple ) != null ) { M . remove ( i * multiple ) ; } multiple ++ ; } } for ( Map . Entry < Integer , Integer > entry : M . entrySet ( ) ) { if ( M . get ( entry . getKey ( ) + K ) != null ) { System . out . print ( " ( " + entry . getKey ( ) + " , ▁ " + ( entry . getKey ( ) + K ) + " ) ▁ " ) ; } } } static void getPrimePairs ( int L , int R , int K ) { Map < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; findPrimeNos ( L , R , M , K ) ; } public static void main ( String args [ ] ) { int L = 1 , R = 19 ; int K = 6 ; getPrimePairs ( L , R , K ) ; } }
class GFG { static int gonNum65537 ( int n ) { return ( 65535 * n * n - 65533 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( gonNum65537 ( n ) ) ; } }
import java . util . * ; class solution { static int count ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int cnt = 0 ; int i = 0 , j = 1 ; while ( i < n && j < n ) { j = ( j <= i ) ? ( i + 1 ) : j ; while ( j < n && ( arr [ j ] - arr [ i ] ) < k ) j ++ ; cnt += ( n - j ) ; i ++ ; } return cnt ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; int k = 2 ; System . out . println ( count ( arr , n , k ) ) ; } }
import java . util . * ; class GFG { static void maximumFactor ( int [ ] arr ) { int [ ] rank = new int [ Arrays . stream ( arr ) . max ( ) . getAsInt ( ) + 1 ] ; int [ ] factors = new int [ Arrays . stream ( arr ) . max ( ) . getAsInt ( ) + 1 ] ; int g = 0 ; for ( int i = 2 ; i <= Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . length ; j ++ ) if ( arr [ j ] % i == 0 ) count += 1 ; rank [ g ] = count ; factors [ g ] = i ; g ++ ; } int m = Arrays . stream ( rank ) . max ( ) . getAsInt ( ) ; for ( int i = 0 ; i < rank . length ; i ++ ) { if ( rank [ i ] == m ) System . out . print ( factors [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 120 , 15 , 24 , 63 , 18 } ; maximumFactor ( arr ) ; } }
import java . io . * ; class GFG { static int findSum ( int n , int a , int b ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( i % a == 0 i % b == 0 ) sum += i ; return sum ; } public static void main ( String [ ] args ) { int n = 10 , a = 3 , b = 5 ; System . out . println ( findSum ( n , a , b ) ) ; } }
import java . util . * ; class GFG { public static double findMedian ( int a [ ] , int n ) { Arrays . sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = a . length ; System . out . println ( " Median ▁ = ▁ " + findMedian ( a , n ) ) ; } }
import java . io . * ; class GFG { static int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( centeredIcosahedralNum ( n ) ) ; n = 12 ; System . out . println ( centeredIcosahedralNum ( n ) ) ; } }
import java . util . * ; class GFG { static int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( Dodecagonal_number ( n ) ) ; n = 12 ; System . out . println ( Dodecagonal_number ( n ) ) ; } }
import java . io . * ; class GFG { static int averageEven ( int n ) { if ( n % 2 != 0 ) { System . out . println ( " Invalid ▁ Input " ) ; return - 1 ; } return ( n + 2 ) / 2 ; } public static void main ( String args [ ] ) { int n = 16 ; System . out . println ( averageEven ( n ) ) ; } }
import java . io . * ; class GeeksforGeeks { static double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; } public static void main ( String args [ ] ) { int a = 5 , b = 15 ; double HM = compute ( a , b ) ; String str = " " ; str = str + HM ; System . out . print ( " Harmonic ▁ Mean ▁ between ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + str . substring ( 0 , 5 ) ) ; } }
public class Array_puzzle_2 { static final double EPS = 1e-9 ; static void productPuzzle ( int a [ ] , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ( int ) ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) + " ▁ " ) ; } public static void main ( String args [ ] ) { int a [ ] = { 10 , 3 , 5 , 6 , 2 } ; int n = a . length ; System . out . println ( " The ▁ product ▁ array ▁ is : ▁ " ) ; productPuzzle ( a , n ) ; } }
class PellNumber { public static int pell ( int n ) { if ( n <= 2 ) return n ; return 2 * pell ( n - 1 ) + pell ( n - 2 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( pell ( n ) ) ; } }
import java . util . Arrays ; class GFG1 { static long findMinValue ( long arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { val += ( double ) ( Math . log ( ( double ) ( arr [ i ] ) ) ) ; } long left = arr [ 0 ] , right = arr [ n - 1 ] ; long ans = 0 ; while ( left <= right ) { long mid = ( left + right ) / 2 ; double temp = ( double ) n * ( double ) ( Math . log ( ( double ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else { left = mid + 1 ; } } return ans ; } public static void main ( String [ ] args ) { long arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = arr . length ; System . out . println ( findMinValue ( arr , n ) ) ; } }
class GFG { static void printOtherSides ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) System . out . println ( " - 1" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } else { if ( n == 2 ) System . out . println ( " - 1" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; System . out . println ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } } public static void main ( String [ ] args ) { int a = 3 ; printOtherSides ( a ) ; } }
import java . io . * ; import java . util . * ; public class Division { static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } static int div ( int x ) { int ans = 0 ; for ( int i = 1 ; i <= x ; i ++ ) if ( x % i == 0 ) ans += i ; return ans ; } static int sumFactDiv ( int n ) { return div ( fact ( n ) ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( sumFactDiv ( n ) ) ; } }
import java . util . * ; class GFG { static ArrayList < Integer > allPrimes = new ArrayList < Integer > ( ) ; static void sieve ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) allPrimes . add ( p ) ; } static int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) { int p = allPrimes . get ( i ) ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes . get ( i ) ; } result = result * ( ( int ) Math . pow ( allPrimes . get ( i ) , exp + 1 ) - 1 ) / ( allPrimes . get ( i ) - 1 ) ; } return result ; } public static void main ( String [ ] args ) { System . out . println ( factorialDivisors ( 4 ) ) ; } }
import java . util . * ; class GFG { static boolean checkPandigital ( int b , String n ) { if ( n . length ( ) < b ) return false ; boolean hash [ ] = new boolean [ b ] ; Arrays . fill ( hash , false ) ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i ) >= '0' && n . charAt ( i ) <= '9' ) hash [ n . charAt ( i ) - '0' ] = true ; else if ( n . charAt ( i ) - ' A ' <= b - 11 ) hash [ n . charAt ( i ) - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } public static void main ( String [ ] args ) { int b = 13 ; String n = "1298450376ABC " ; if ( checkPandigital ( b , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int numberOf2sinRange ( int n ) { String s = " " ; for ( int i = 0 ; i < n + 1 ; i ++ ) s += String . valueOf ( i ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == '2' ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 30 ; System . out . println ( numberOf2sinRange ( n ) ) ; } }
class GFG { static int power ( int num , int n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , n / 2 ) * power ( num , n / 2 ) ; else return num * power ( num , n / 2 ) * power ( num , n / 2 ) ; } static int checkRecursive ( int x , int n , int curr_num , int curr_sum ) { int results = 0 ; int p = power ( curr_num , n ) ; while ( p + curr_sum < x ) { results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) ; curr_num ++ ; p = power ( curr_num , n ) ; } if ( p + curr_sum == x ) results ++ ; return results ; } public static void main ( String [ ] args ) { int x = 10 , n = 2 ; System . out . println ( checkRecursive ( x , n , 1 , 0 ) ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void printGenerators ( int n ) { System . out . println ( "1 ▁ " ) ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) System . out . println ( i + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 10 ; printGenerators ( n ) ; } }
import java . util . HashMap ; class GFG { public static int sumDivisorsOfDivisors ( int n ) { HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int j = 2 ; j <= Math . sqrt ( n ) ; j ++ ) { int count = 0 ; while ( n % j == 0 ) { n /= j ; count ++ ; } if ( count != 0 ) mp . put ( j , count ) ; } if ( n != 1 ) mp . put ( n , 1 ) ; int ans = 1 ; for ( HashMap . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { int pw = 1 ; int sum = 0 ; for ( int i = entry . getValue ( ) + 1 ; i >= 1 ; i -- ) { sum += ( i * pw ) ; pw = entry . getKey ( ) ; } ans *= sum ; } return ans ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( sumDivisorsOfDivisors ( n ) ) ; } }
import java . io . * ; class GFG { static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; } static public void main ( String [ ] args ) { int N = 10 , K = 2 ; System . out . println ( findSum ( N , K ) ) ; } }
class GFG { static int z = 0 ; static int pow1 ( int base1 , int exponent , int modulus ) { int result = 1 ; base1 = base1 % modulus ; while ( exponent > 0 ) { if ( exponent % 2 == 1 ) result = ( result * base1 ) % modulus ; exponent = exponent >> 1 ; base1 = ( base1 * base1 ) % modulus ; } return result ; } static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int order ( int p , int b ) { if ( gcd ( p , b ) != 1 ) { System . out . println ( " p ▁ and ▁ b ▁ are " + " not ▁ co - prime . " ) ; return - 1 ; } int k = 3 ; while ( true ) { if ( pow1 ( b , k , p ) == 1 ) return k ; k ++ ; } } static int convertx2e ( int x ) { z = 0 ; while ( x % 2 == 0 ) { x /= 2 ; z ++ ; } return x ; } static int STonelli ( int n , int p ) { if ( gcd ( n , p ) != 1 ) { System . out . println ( " a ▁ and ▁ p ▁ are ▁ not ▁ coprime " ) ; return - 1 ; } if ( pow1 ( n , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) { System . out . println ( " no ▁ sqrt ▁ possible " ) ; return - 1 ; } int s , e ; s = convertx2e ( p - 1 ) ; e = z ; int q ; for ( q = 2 ; ; q ++ ) { if ( pow1 ( q , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) break ; } int x = pow1 ( n , ( s + 1 ) / 2 , p ) ; int b = pow1 ( n , s , p ) ; int g = pow1 ( q , s , p ) ; int r = e ; while ( true ) { int m ; for ( m = 0 ; m < r ; m ++ ) { if ( order ( p , b ) == - 1 ) return - 1 ; if ( order ( p , b ) == Math . pow ( 2 , m ) ) break ; } if ( m == 0 ) return x ; x = ( x * pow1 ( g , ( int ) Math . pow ( 2 , r - m - 1 ) , p ) ) % p ; g = pow1 ( g , ( int ) Math . pow ( 2 , r - m ) , p ) ; b = ( b * g ) % p ; if ( b == 1 ) return x ; r = m ; } } public static void main ( String [ ] args ) { int n = 2 ; int p = 113 ; int x = STonelli ( n , p ) ; if ( x == - 1 ) System . out . println ( " Modular ▁ square " + "root is not existNEW_LINE"); else System . out . println ( " Modular ▁ square ▁ root ▁ of ▁ " + n + " ▁ and ▁ " + p + " ▁ is ▁ " + x + "NEW_LINE"); } }
import java . io . * ; import static java . lang . Math . * ; class Quadratic { static void findRoots ( int a , int b , int c ) { if ( a == 0 ) { System . out . println ( " Invalid " ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { System . out . println ( "Roots are real and different NEW_LINE"); System . out . println ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) + "NEW_LINE" + ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else if ( d == 0 ) { System . out . println ( "Roots are real and same NEW_LINE"); System . out . println ( - ( double ) b / ( 2 * a ) + "NEW_LINE" + - ( double ) b / ( 2 * a ) ) ; } { System . out . println ( "Roots are complex NEW_LINE"); System . out . println ( - ( double ) b / ( 2 * a ) + " ▁ + ▁ i " + sqrt_val + "NEW_LINE" + - ( double ) b / ( 2 * a ) + " ▁ - ▁ i " + sqrt_val ) ; } } public static void main ( String args [ ] ) { int a = 1 , b = - 7 , c = 12 ; findRoots ( a , b , c ) ; } }
import java . util . Vector ; class Test { static void printDivisors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . printf ( " % d ▁ " , i ) ; else { System . out . printf ( " % d ▁ " , i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( " % d ▁ " , v . get ( i ) ) ; } public static void main ( String args [ ] ) { System . out . println ( " The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ " ) ; printDivisors ( 100 ) ; } }
class Test { static void printDivisors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) if ( n % i == 0 ) System . out . print ( i + " ▁ " ) ; } public static void main ( String args [ ] ) { System . out . println ( " The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ " ) ; printDivisors ( 100 ) ; ; } }
class Test { static void printDivisors ( int n ) { for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . print ( " ▁ " + i ) ; System . out . print ( i + " ▁ " + n / i + " ▁ " ) ; } } } public static void main ( String args [ ] ) { System . out . println ( " The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ " ) ; printDivisors ( 100 ) ; ; } }
class GFG { static int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( seriesSum ( 1 , 1 , N ) ) ; } }
class GFG { static int nCrModpDP ( int n , int r , int p ) { int [ ] C = new int [ r + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; } static int nCrModpLucas ( int n , int r , int p ) { if ( r == 0 ) return 1 ; int ni = n % p ; int ri = r % p ; } public static void main ( String [ ] args ) { int n = 1000 , r = 900 , p = 13 ; System . out . println ( " Value ▁ of ▁ nCr ▁ % ▁ p ▁ is ▁ " + nCrModpLucas ( n , r , p ) ) ; } }
class GFG { static int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } public static void main ( String args [ ] ) { int a = 3 , m = 11 ; System . out . println ( " Modular ▁ multiplicative ▁ " + " inverse ▁ is ▁ " + modInverse ( a , m ) ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int phi ( int n ) { int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; } public static void main ( String [ ] args ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) System . out . println ( " phi ( " + n + " ) ▁ = ▁ " + phi ( n ) ) ; } }
class Test { static void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; System . out . print ( f1 + " ▁ " ) ; for ( i = 1 ; i < n ; i ++ ) { System . out . print ( f2 + " ▁ " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } } public static void main ( String [ ] args ) { printFibonacciNumbers ( 7 ) ; } }
class Test { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; } public static void main ( String [ ] args ) { int a = 15 , b = 20 ; System . out . println ( " LCM ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + lcm ( a , b ) ) ; } }
class GFG { static int MAX = 11 ; static boolean isMultipleof5 ( int n ) { char str [ ] = new char [ MAX ] ; int len = str . length ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) System . out . println ( n + " ▁ is ▁ multiple ▁ " + " of ▁ 5" ) ; else System . out . println ( n + " ▁ is ▁ not ▁ a ▁ " + " multiple ▁ of ▁ 5" ) ; } }
class GFG { static int rev_num = 0 ; static int base_pos = 1 ; static int reversDigits ( int num ) { if ( num > 0 ) { reversDigits ( num / 10 ) ; rev_num += ( num % 10 ) * base_pos ; base_pos *= 10 ; } return rev_num ; } public static void main ( String [ ] args ) { int num = 4562 ; System . out . println ( reversDigits ( num ) ) ; } }
import java . io . * ; class GFG { static int M = 3 ; static int N = 3 ; static int findXOR ( int X ) { int ans = 0 ; while ( X != 0 ) { ans ^= ( X % 10 ) ; X /= 10 ; } return ans ; } static void printXORmatrix ( int arr [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } static void convertXOR ( int arr [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int X = arr [ i ] [ j ] ; int temp = findXOR ( X ) ; arr [ i ] [ j ] = temp ; } } printXORmatrix ( arr ) ; } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 27 , 173 , 5 } , { 21 , 6 , 624 } , { 5 , 321 , 49 } } ; convertXOR ( arr ) ; } }
static int setBit ( int num , int i ) { return num | ( 1 << i ) ; }
import java . util . * ; class GFG { static void printORSumforEachElement ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int req_sum = 0 ; for ( int j = 0 ; j < N ; j ++ ) { req_sum += ( arr [ i ] arr [ j ] ) ; } System . out . print ( req_sum + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = arr . length ; printORSumforEachElement ( arr , N ) ; } }
class GFG { static int findLargestNumber ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] &= 0xFFFF ; if ( arr [ i ] <= n ) { arr [ i ] += 0x10000 ; } } for ( int i = n - 1 ; i > 0 ; -- i ) { if ( ( arr [ i ] >> 16 ) == i ) return i + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 5 , 5 , 2 , 4 , 5 } ; int n = arr . length ; System . out . print ( findLargestNumber ( arr , n ) + "NEW_LINE"); } }
import java . util . * ; class GFG { static int RecursiveFunction ( ArrayList < Integer > ref , int bit ) { if ( ref . size ( ) == 0 bit < 0 ) return 0 ; ArrayList < Integer > curr_on = new ArrayList < > ( ) ; ArrayList < Integer > curr_off = new ArrayList < > ( ) ; for ( int i = 0 ; i < ref . size ( ) ; i ++ ) { if ( ( ( ref . get ( i ) >> bit ) & 1 ) == 0 ) curr_off . add ( ref . get ( i ) ) ; else curr_on . add ( ref . get ( i ) ) ; } if ( curr_off . size ( ) == 0 ) return RecursiveFunction ( curr_on , bit - 1 ) ; if ( curr_on . size ( ) == 0 ) return RecursiveFunction ( curr_off , bit - 1 ) ; return Math . min ( RecursiveFunction ( curr_off , bit - 1 ) , RecursiveFunction ( curr_on , bit - 1 ) ) + ( 1 << bit ) ; } static void PrintMinimum ( int a [ ] , int n ) { ArrayList < Integer > v = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) v . add ( a [ i ] ) ; System . out . println ( RecursiveFunction ( v , 30 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int size = arr . length ; PrintMinimum ( arr , size ) ; } }
class GFG { static int MAX = 1000005 ; static boolean prime [ ] = new boolean [ MAX ] ; static void SieveOfEratosthenes ( boolean [ ] prime ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) prime [ i ] = false ; } } } static void prime_xor ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { if ( ( i + 1 ) % k == 0 ) { ans ^= arr [ i ] ; } } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 , 11 , 8 } ; int n = arr . length ; int K = 2 ; prime_xor ( arr , n , K ) ; } }
import java . util . * ; class GFG { static boolean isPowerOfTwo ( int x ) { if ( x == 0 ) return false ; if ( ( x & ( x - 1 ) ) == 0 ) return true ; else return false ; } static int countNum ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) || isPowerOfTwo ( a [ i ] + 1 ) ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 1 } ; int n = arr . length ; System . out . println ( countNum ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int xorGivenSetBits ( int arr [ ] , int n , int k ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Integer . bitCount ( arr [ i ] ) == k ) { v . add ( arr [ i ] ) ; } } int result = v . get ( 0 ) ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { result = result ^ v . get ( i ) ; } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 13 , 1 , 19 , 7 } ; int n = arr . length ; int k = 3 ; System . out . println ( xorGivenSetBits ( arr , n , k ) ) ; } }
import java . io . * ; class GFG { static int countZeros ( int x ) { int y ; int n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; } public static void main ( String [ ] args ) { int x = 101 ; System . out . println ( countZeros ( x ) ) ; } }
import java . io . * ; class GFG { static int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; } public static void main ( String [ ] args ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = A . length ; System . out . println ( findEvenPair ( A , N ) ) ; } }
import java . util . * ; class GFG { static int N = 1000 ; static int lastElement ( int a [ ] , int n ) { int steps = 1 ; Vector < Integer > [ ] v = new Vector [ N ] ; for ( int i = 0 ; i < N ; i ++ ) v [ i ] = new Vector < Integer > ( ) ; if ( n == 1 ) return a [ 0 ] ; for ( int i = 0 ; i < n ; i += 2 ) v [ steps ] . add ( a [ i ] a [ i + 1 ] ) ; while ( v [ steps ] . size ( ) > 1 ) { steps += 1 ; for ( int i = 0 ; i < v [ steps - 1 ] . size ( ) ; i += 2 ) { if ( steps % 2 == 1 ) v [ steps ] . add ( v [ steps - 1 ] . get ( i ) | v [ steps - 1 ] . get ( i + 1 ) ) ; v [ steps ] . add ( v [ steps - 1 ] . get ( i ) ^ v [ steps - 1 ] . get ( i + 1 ) ) ; } } return v [ steps ] . get ( 0 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 5 , 6 } ; int n = a . length ; int index = 0 ; int value = 2 ; a [ 0 ] = 2 ; System . out . println ( lastElement ( a , n ) ) ; index = 3 ; value = 5 ; a [ index ] = value ; System . out . println ( lastElement ( a , n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int xnor ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a == 0 && b == 0 ) return 1 ; int a_rem = 0 ; int b_rem = 0 ; int count = 0 ; int xnornum = 0 ; while ( true ) { a_rem = a & 1 ; b_rem = b & 1 ; if ( a_rem == b_rem ) xnornum |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; if ( a < 1 ) break ; } return xnornum ; } public static void main ( String argc [ ] ) { int a = 10 , b = 50 ; System . out . println ( xnor ( a , b ) ) ; } }
import java . io . * ; public class GFG { static void divide ( int n , int m ) { System . out . println ( " Remainder ▁ = ▁ " + ( ( n ) & ( m - 1 ) ) ) ; System . out . println ( " Quotient ▁ = ▁ " + ( n >> ( int ) ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; } static public void main ( String [ ] args ) { int n = 43 , m = 8 ; divide ( n , m ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static boolean areAllBitsSet ( long n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } public static boolean isOnesComplementOfOther ( long a , long b ) { return areAllBitsSet ( a ^ b ) ; } public static void main ( String argc [ ] ) { long a = 10 , b = 5 ; if ( isOnesComplementOfOther ( a , b ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int countBits ( int number ) { return ( int ) ( Math . log ( number ) / Math . log ( 2 ) + 1 ) ; } public static void main ( String [ ] args ) { int num = 65 ; System . out . println ( countBits ( num ) ) ; } }
class GFG { static int bitExtracted ( int number , int k , int p ) { return ( ( ( 1 << k ) - 1 ) & ( number >> ( p - 1 ) ) ) ; } public static void main ( String [ ] args ) { int number = 171 , k = 5 , p = 2 ; System . out . println ( " The ▁ extracted ▁ number ▁ is ▁ " + bitExtracted ( number , k , p ) ) ; } }
class GFG { static void multiply ( int F [ ] [ ] , int M [ ] [ ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; } static void power ( int F [ ] [ ] , int n ) { if ( n == 0 n == 1 ) { return ; } int M [ ] [ ] = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) { multiply ( F , M ) ; } } static int countWays ( int n ) { int F [ ] [ ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) { return 0 ; } power ( F , n ) ; return F [ 0 ] [ 0 ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countWays ( n ) ) ; } }
class GFG { static int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; } public static void main ( String [ ] args ) { int n = 31 ; System . out . println ( countXOR ( n ) ) ; } }
import java . util . * ; class GFG { public static int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( countValues ( n ) ) ; } }
import java . io . * ; class GFG { static int multiplyBySevenByEight ( int n ) { return ( n - ( n >> 3 ) ) ; } public static void main ( String args [ ] ) { int n = 9 ; System . out . println ( multiplyBySevenByEight ( n ) ) ; } }
class GFG { public static void printLongestPalindrome ( String S , int N ) { int palLength [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int maxlength = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( S . charAt ( j ) == S . charAt ( i ) ) { if ( isPalindrome ( S , j , i ) ) { maxlength = i - j + 1 ; break ; } } } for ( int j = N - 1 ; j > i ; j -- ) { if ( S . charAt ( j ) == S . charAt ( i ) ) { if ( isPalindrome ( S , i , j ) ) { maxlength = Math . max ( j - i + 1 , maxlength ) ; break ; } } } palLength [ i ] = maxlength ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( palLength [ i ] + " ▁ " ) ; } } public static boolean isPalindrome ( String S , int i , int j ) { while ( i < j ) { if ( S . charAt ( i ) != S . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; } public static void main ( String [ ] args ) { String S = " bababa " ; int N = S . length ( ) ; printLongestPalindrome ( S , N ) ; } }
import java . util . Arrays ; class GFG { static boolean checkSorted ( int n , int arr [ ] ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = arr [ i ] ; Arrays . sort ( b , 0 , n ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != b [ i ] ) ct ++ ; if ( ct == 0 ct == 2 ) return true ; else return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = arr . length ; if ( checkSorted ( n , arr ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = arr . length ; System . out . println ( minSum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = arr . length ; System . out . println ( minSum ( arr , n ) ) ; } }
import java . util . HashMap ; class GFG { static int validPermutations ( String str ) { HashMap < Character , Integer > m = new HashMap < Character , Integer > ( ) ; int count = str . length ( ) , ans = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { m . put ( str . charAt ( i ) , m . getOrDefault ( str . charAt ( i ) , 0 ) + 1 ) ; } for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ans += count - m . get ( str . charAt ( i ) ) ; m . put ( str . charAt ( i ) , m . get ( str . charAt ( i ) ) - 1 ) ; count -- ; } return ans + 1 ; } public static void main ( String [ ] args ) { String str = " sstt " ; System . out . println ( validPermutations ( str ) ) ; } }
import java . util . * ; class GFG { static boolean ifPossible ( int arr [ ] , int n ) { int copy [ ] = Arrays . copyOf ( arr , arr . length ) ; Arrays . sort ( copy ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 } ; int n = arr . length ; if ( ifPossible ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int M = 20 ; static int dp [ ] [ ] [ ] [ ] = new int [ M ] [ 165 ] [ M ] [ 2 ] ; static int n , m ; static int count ( int pos , int sum , int rem , int tight , int nonz , Vector < Integer > num ) { if ( pos == num . size ( ) ) { if ( rem == 0 && sum == n ) return 1 ; return 0 ; } if ( dp [ pos ] [ sum ] [ rem ] [ tight ] != - 1 ) return dp [ pos ] [ sum ] [ rem ] [ tight ] ; int ans = 0 ; int limit = ( tight != 0 ? 9 : num . get ( pos ) ) ; for ( int d = 0 ; d <= limit ; d ++ ) { if ( d == 0 && nonz != 0 ) continue ; int currSum = sum + d ; int currRem = ( rem * 10 + d ) % m ; int currF = ( tight != 0 || ( d < num . get ( pos ) ) ) ? 1 : 0 ; ans += count ( pos + 1 , currSum , currRem , currF , ( nonz != 0 d != 0 ) ? 1 : 0 , num ) ; } return dp [ pos ] [ sum ] [ rem ] [ tight ] = ans ; } static int solve ( int x ) { Vector < Integer > num = new Vector < Integer > ( ) ; while ( x != 0 ) { num . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( num ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < 165 ; j ++ ) for ( int k = 0 ; k < M ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ k ] [ l ] = - 1 ; return count ( 0 , 0 , 0 , 0 , 0 , num ) ; } public static void main ( String args [ ] ) { int L = 1 , R = 100 ; n = 8 ; m = 2 ; System . out . print ( solve ( R ) - solve ( L ) ) ; } }
class GFG { static int maximumSumSubarray ( int arr [ ] , int n ) { int min_prefix_sum = 0 ; int res = Integer . MIN_VALUE ; int prefix_sum [ ] = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; } public static void main ( String [ ] args ) { int arr1 [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n1 = arr1 . length ; System . out . println ( maximumSumSubarray ( arr1 , n1 ) ) ; int arr2 [ ] = { 4 , - 8 , 9 , - 4 , 1 , - 8 , - 1 , 6 } ; int n2 = arr2 . length ; System . out . println ( maximumSumSubarray ( arr2 , n2 ) ) ; } }
import java . io . * ; class GFG { static int countPaths ( int n , int m ) { int dp [ ] [ ] = new int [ n + 1 ] [ m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; return dp [ n ] [ m ] ; } public static void main ( String [ ] args ) { int n = 3 , m = 2 ; System . out . println ( " ▁ Number ▁ of ▁ Paths ▁ " + countPaths ( n , m ) ) ; } }
public static int [ ] dp = new int [ MAXN ] ; static int solve ( int n ) { if ( n < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = solve ( n - 1 ) + solve ( n - 3 ) + solve ( n - 5 ) ; }
class GFG { static String printShortestSuperSeq ( String X , String Y ) { int m = X . length ( ) ; int n = Y . length ( ) ; int dp [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) { dp [ i ] [ j ] = j ; } else if ( j == 0 ) { dp [ i ] [ j ] = i ; } else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } } String str = " " ; int i = m , j = n ; while ( i > 0 && j > 0 ) { if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { str += ( X . charAt ( i - 1 ) ) ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] ) { str += ( Y . charAt ( j - 1 ) ) ; j -- ; } else { str += ( X . charAt ( i - 1 ) ) ; i -- ; } } while ( i > 0 ) { str += ( X . charAt ( i - 1 ) ) ; i -- ; } while ( j > 0 ) { str += ( Y . charAt ( j - 1 ) ) ; j -- ; } str = reverse ( str ) ; return str ; } static String reverse ( String input ) { char [ ] temparray = input . toCharArray ( ) ; int left , right = 0 ; right = temparray . length - 1 ; for ( left = 0 ; left < right ; left ++ , right -- ) { char temp = temparray [ left ] ; temparray [ left ] = temparray [ right ] ; temparray [ right ] = temp ; } return String . valueOf ( temparray ) ; } public static void main ( String [ ] args ) { String X = " AGGTAB " ; String Y = " GXTXAYB " ; System . out . println ( printShortestSuperSeq ( X , Y ) ) ; } }
class MatrixChainMultiplication { static int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; int size = arr . length ; System . out . println ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " + MatrixChainOrder ( arr , size ) ) ; } }
import java . util . * ; class GFG { static int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 } ; int m = arr . length ; System . out . println ( count ( arr , m , 4 ) ) ; } }
import java . util . * ; class Solution { static int findSubstringCount ( String str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str . charAt ( i ) + 1 == str . charAt ( i + 1 ) ) { result ++ ; while ( str . charAt ( i ) + 1 == str . charAt ( i + 1 ) ) { i ++ ; } } } return result ; } public static void main ( String args [ ] ) { String str = " alphabet " ; System . out . println ( findSubstringCount ( str ) ) ; } }
import java . util . * ; class GFG { static int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; } public static void main ( String [ ] args ) { int n = 4722 ; System . out . println ( round ( n ) ) ; } }
class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } static String encryptString ( String s , int n , int k ) { int countVowels = 0 ; int countConsonants = 0 ; String ans = " " ; for ( int l = 0 ; l <= n - k ; l ++ ) { countVowels = 0 ; countConsonants = 0 ; for ( int r = l ; r <= l + k - 1 ; r ++ ) { if ( isVowel ( s . charAt ( r ) ) == true ) { countVowels ++ ; } else { countConsonants ++ ; } } ans += String . valueOf ( countVowels * countConsonants ) ; } return ans ; } static public void main ( String [ ] args ) { String s = " hello " ; int n = s . length ( ) ; int k = 2 ; System . out . println ( encryptString ( s , n , k ) ) ; } }
class GFG { static int hammingDist ( String str1 , String str2 ) { int i = 0 , count = 0 ; while ( i < str1 . length ( ) ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) count ++ ; i ++ ; } return count ; } public static void main ( String [ ] args ) { String str1 = " geekspractice " ; String str2 = " nerdspractise " ; System . out . println ( hammingDist ( str1 , str2 ) ) ; } }
import java . util . * ; class solution { static float surfaceArea ( float a , float b , float h ) { return 5 * a * b + 5 * b * h ; } static float volume ( float b , float h ) { return ( 5 * b * h ) / 2 ; } public static void main ( String arr [ ] ) { float a = 5 ; float b = 3 ; float h = 7 ; System . out . println ( " surface ▁ area = ▁ " + surfaceArea ( a , b , h ) + " , ▁ " ) ; System . out . println ( " volume = ▁ " + volume ( b , h ) ) ; } }
import java . util . * ; class GFG { static int formQuadruplets ( Integer arr [ ] , int n ) { int ans = 0 , pairs = 0 ; pairs = n / 4 ; Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < n - pairs ; i += 3 ) { ans += arr [ i + 2 ] ; } return ans ; } public static void main ( String [ ] args ) { Integer arr [ ] = { 2 , 1 , 7 , 5 , 5 , 4 , 1 , 1 , 3 , 3 , 2 , 2 } ; int n = arr . length ; System . out . print ( formQuadruplets ( arr , n ) + "NEW_LINE"); } }
import java . util . * ; class GFG { static int Count ( int N , int K ) { if ( K == 0 ) return 0 ; int res = 0 ; int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int sum = ( mid * mid + mid ) / 2 ; if ( sum <= K ) { res = Math . max ( res , mid ) ; low = mid + 1 ; } else { high = mid - 1 ; } } return res ; } public static void main ( String [ ] args ) { int N = 6 , K = 14 ; System . out . println ( Count ( N , K ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void maxItems ( int n , int m , int a [ ] , int b [ ] , int K ) { int count = 0 ; int A [ ] = new int [ n + 1 ] ; int B [ ] = new int [ m + 1 ] ; A [ 0 ] = 0 ; B [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { A [ i ] = a [ i - 1 ] + A [ i - 1 ] ; } for ( int i = 1 ; i <= m ; i ++ ) { B [ i ] = b [ i - 1 ] + B [ i - 1 ] ; } for ( int i = 0 ; i <= n ; i ++ ) { if ( A [ i ] > K ) break ; int rem = K - A [ i ] ; int j = 0 ; int lo = 0 , hi = m ; while ( lo <= hi ) { int mid = ( lo + hi ) / 2 ; if ( B [ mid ] <= rem ) { j = mid ; lo = mid + 1 ; } else { hi = mid - 1 ; } } count = Math . max ( j + i , count ) ; } System . out . print ( count ) ; } public static void main ( String [ ] args ) { int n = 4 , m = 5 , K = 7 ; int A [ ] = { 2 , 4 , 7 , 3 } ; int B [ ] = { 1 , 9 , 3 , 4 , 5 } ; maxItems ( n , m , A , B , K ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static boolean isPrime ( int N ) { if ( N == 1 ) return false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; } static int findCoPrime ( int L , int R ) { int coPrime ; for ( int i = R + 1 ; ; i ++ ) { if ( isPrime ( i ) ) { coPrime = i ; break ; } } return coPrime ; } public static void main ( String [ ] args ) { int L = 16 , R = 17 ; System . out . println ( findCoPrime ( L , R ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static void KthCharacter ( String S , int N , int K ) { char strarray [ ] = S . toCharArray ( ) ; Arrays . sort ( strarray ) ; char ch = strarray [ K - 1 ] ; int count = 0 ; for ( char c : strarray ) { if ( c == ch ) count ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { String S = " geeksforgeeks " ; int N = S . length ( ) ; int K = 3 ; KthCharacter ( S , N , K ) ; } }
import java . io . * ; class GFG { static void findSubstring ( String S ) { String T = " " ; String ans = " " ; int l = 0 ; T += S . charAt ( 0 ) ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( Math . abs ( S . charAt ( i ) - S . charAt ( i - 1 ) ) == 1 ) { l = T . length ( ) ; if ( l > ans . length ( ) ) { ans = T ; } T = " " ; T += S . charAt ( i ) ; } else { T += S . charAt ( i ) ; } } l = T . length ( ) ; if ( l > ans . length ( ) ) { ans = T ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { String S = " aabdml " ; findSubstring ( S ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int noOfValidKbers ( int K , int arr [ ] ) { HashSet < Integer > set = new HashSet < > ( ) ; while ( K != 0 ) { set . add ( K % 10 ) ; K = K / 10 ; } int count = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int no = arr [ i ] ; boolean flag = true ; while ( no != 0 ) { int digit = no % 10 ; if ( ! set . contains ( digit ) ) { flag = false ; break ; } no = no / 10 ; } if ( flag == true ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { int K = 12 ; int arr [ ] = { 1 , 12 , 1222 , 13 , 2 } ; System . out . println ( noOfValidKbers ( K , arr ) ) ; } }
import java . util . * ; class GFG { static final int MAX = 10000 ; static Vector < Integer > [ ] divisors = new Vector [ MAX + 1 ] ; static void computeDivisors ( ) { for ( int i = 1 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j += i ) { divisors [ j ] . add ( i ) ; } } } static int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } static int findClosest ( Vector < Integer > array , int n , int target ) { Integer [ ] arr = array . toArray ( new Integer [ array . size ( ) ] ) ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } static void printClosest ( int N , int X ) { computeDivisors ( ) ; int ans = findClosest ( divisors [ N ] , divisors [ N ] . size ( ) , X ) ; System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int N = 16 , X = 5 ; for ( int i = 0 ; i < divisors . length ; i ++ ) divisors [ i ] = new Vector < Integer > ( ) ; printClosest ( N , X ) ; } }
public class GFG { static int countDiv ( int [ ] arr ) { int rem0 = 0 ; int rem1 = 0 ; int rem2 = 0 ; for ( int i : arr ) { int digitSum = 0 ; digitSum += i ; if ( digitSum % 3 == 0 ) { rem0 += 1 ; } else if ( digitSum % 3 == 1 ) { rem1 += 1 ; } else { rem2 += 1 ; } } return ( rem0 / 2 + Math . min ( rem1 , rem2 ) ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 3 , 2 , 8 , 7 } ; System . out . println ( countDiv ( arr ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int N = 100005 ; static void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } static int digitProduct ( int number ) { int res = 1 ; while ( number > 0 ) { res *= ( number % 10 ) ; number /= 10 ; } return res ; } static void DistinctCompositeDigitProduct ( int arr [ ] , int n ) { TreeSet < Integer > output = new TreeSet < Integer > ( ) ; boolean prime [ ] = new boolean [ N + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , N ) ; for ( int i = 0 ; i < n ; i ++ ) { int ans = digitProduct ( arr [ i ] ) ; if ( ans <= 1 ) { continue ; } if ( ! prime [ ans ] ) { output . add ( ans ) ; } } System . out . print ( output . size ( ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 55 , 7 , 13 , 11 , 71 , 233 , 233 , 144 , 89 } ; int n = arr . length ; DistinctCompositeDigitProduct ( arr , n ) ; } }
import java . io . * ; import java . util . * ; class GFG { static ArrayList < Integer > simpleSieve ( int lmt , ArrayList < Integer > prime ) { boolean [ ] Sieve = new boolean [ lmt + 1 ] ; Arrays . fill ( Sieve , true ) ; Sieve [ 0 ] = Sieve [ 1 ] = false ; for ( int i = 2 ; i <= lmt ; ++ i ) { if ( Sieve [ i ] == true ) { prime . add ( i ) ; for ( int j = i * i ; j <= lmt ; j += i ) { Sieve [ j ] = false ; } } } return prime ; } static boolean [ ] SegmentedSieveFn ( int low , int high ) { int lmt = ( int ) ( Math . sqrt ( high ) ) + 1 ; ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; prime = simpleSieve ( lmt , prime ) ; int n = high - low + 1 ; boolean [ ] segmentedSieve = new boolean [ n + 1 ] ; Arrays . fill ( segmentedSieve , true ) ; for ( int i = 0 ; i < prime . size ( ) ; i ++ ) { int lowLim = ( int ) ( low / prime . get ( i ) ) * prime . get ( i ) ; if ( lowLim < low ) { lowLim += prime . get ( i ) ; } for ( int j = lowLim ; j <= high ; j += prime . get ( i ) ) { if ( j != prime . get ( i ) ) { segmentedSieve [ j - low ] = false ; } } } return segmentedSieve ; } static int countPairsWhoseSumPrimeL_R ( int L , int R ) { boolean [ ] segmentedSieve = SegmentedSieveFn ( L , R ) ; int cntPairs = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( segmentedSieve [ i - L ] ) { cntPairs += i / 2 ; } } return cntPairs ; } public static void main ( String [ ] args ) { int L = 1 , R = 5 ; System . out . println ( countPairsWhoseSumPrimeL_R ( L , R ) ) ; } }
import java . util . * ; class GFG { static int countSubsequece ( int a [ ] , int n ) { int i , j , k , l ; int answer = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { for ( l = k + 1 ; l < n ; l ++ ) { if ( a [ j ] == a [ l ] && a [ i ] == a [ k ] ) { answer ++ ; } } } } } return answer ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 2 , 3 , 2 , 1 , 3 , 2 } ; System . out . print ( countSubsequece ( a , 7 ) ) ; } }
import java . util . * ; class GFG { static final int MAX = 10000000 ; static boolean [ ] isPrime = new boolean [ MAX + 1 ] ; static Vector < Integer > primes = new Vector < Integer > ( ) ; static void SieveOfEratosthenes ( ) { Arrays . fill ( isPrime , true ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p <= MAX ; p ++ ) if ( isPrime [ p ] ) primes . add ( p ) ; } static int prime_search ( Vector < Integer > primes , int diff ) { int low = 0 ; int high = primes . size ( ) - 1 ; int res = - 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( primes . get ( mid ) == diff ) { return primes . get ( mid ) ; } else if ( primes . get ( mid ) < diff ) { low = mid + 1 ; } else { res = primes . get ( mid ) ; high = mid - 1 ; } } return res ; } static int minCost ( int arr [ ] , int n ) { SieveOfEratosthenes ( ) ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { int diff = arr [ i - 1 ] - arr [ i ] ; int closest_prime = prime_search ( primes , diff ) ; res += closest_prime ; arr [ i ] += closest_prime ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 5 , 4 , 3 } ; int n = 5 ; System . out . print ( minCost ( arr , n ) ) ; } }
import java . util . * ; class GFG { static char minDistChar ( char [ ] s ) { int n = s . length ; int [ ] first = new int [ 26 ] ; int [ ] last = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( first [ s [ i ] - ' a ' ] == - 1 ) { first [ s [ i ] - ' a ' ] = i ; } last [ s [ i ] - ' a ' ] = i ; } int min = Integer . MAX_VALUE ; char ans = '1' ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( last [ i ] == first [ i ] ) continue ; if ( min > last [ i ] - first [ i ] ) { min = last [ i ] - first [ i ] ; ans = ( char ) ( i + ' a ' ) ; } } return ans ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . print ( minDistChar ( str . toCharArray ( ) ) ) ; } }
import java . util . * ; public class Main { public static void uniqueElement ( int arr [ ] ) { Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { set . add ( arr [ i ] ) ; } if ( set . size ( ) == 1 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 9 , 9 , 9 , 9 , 9 , 9 , 9 } ; uniqueElement ( arr ) ; } }
import java . util . * ; class GFG { @ SuppressWarnings ( " unchecked " ) static Vector < Integer > [ ] adj = new Vector [ 100005 ] ; static int [ ] visited = new int [ 100005 ] ; static int ans = 0 ; static void dfs ( int node , int count , int m , int arr [ ] , int k ) { visited [ node ] = 1 ; if ( arr [ node - 1 ] == k ) { count ++ ; } else { count = 0 ; } if ( count > m ) { return ; } if ( adj [ node ] . size ( ) == 1 && node != 1 ) { ans ++ ; } for ( int x : adj [ node ] ) { if ( visited [ x ] == 0 ) { dfs ( x , count , m , arr , k ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 3 , 2 , 1 , 2 , 1 } ; int N = 7 , K = 2 , M = 2 ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; adj [ 1 ] . add ( 2 ) ; adj [ 2 ] . add ( 1 ) ; adj [ 1 ] . add ( 3 ) ; adj [ 3 ] . add ( 1 ) ; adj [ 2 ] . add ( 4 ) ; adj [ 4 ] . add ( 2 ) ; adj [ 2 ] . add ( 5 ) ; adj [ 5 ] . add ( 2 ) ; adj [ 3 ] . add ( 6 ) ; adj [ 6 ] . add ( 3 ) ; adj [ 3 ] . add ( 7 ) ; adj [ 7 ] . add ( 3 ) ; int counter = 0 ; dfs ( 1 , counter , M , arr , K ) ; System . out . print ( ans + "NEW_LINE"); } }
import java . util . * ; import java . lang . * ; class GFG { static int calc_distance ( int A [ ] , int B [ ] , int n ) { int distance_traveled_A = 0 ; int distance_traveled_B = 0 ; int answer = 0 ; for ( int i = 0 ; i < 5 ; i ++ ) { distance_traveled_A += A [ i ] ; distance_traveled_B += B [ i ] ; if ( ( distance_traveled_A == distance_traveled_B ) && ( A [ i ] == B [ i ] ) ) { answer += A [ i ] ; } } return answer ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 2 , 4 } ; int B [ ] = { 2 , 1 , 3 , 1 , 4 } ; int N = A . length ; System . out . println ( calc_distance ( A , B , N ) ) ; } }
class GFG { static void maxProduct ( int arr [ ] , int N ) { if ( N < 3 ) { return ; } int a = arr [ 0 ] , b = arr [ 1 ] ; int c = 0 , d = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i + 1 ; j < N - 1 ; j ++ ) { if ( arr [ i ] * arr [ j ] > a * b ) { c = a ; d = b ; a = arr [ i ] ; b = arr [ j ] ; } if ( arr [ i ] * arr [ j ] < a * b && arr [ i ] * arr [ j ] > c * d ) c = arr [ i ] ; d = arr [ j ] ; } System . out . println ( c + " ▁ " + d ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 67 , 45 , 160 , 78 } ; int N = arr . length ; maxProduct ( arr , N ) ; } }
import java . util . Arrays ; class GFG { static void findMaxValue ( int N , int K ) { int packages ; int maxi = 1 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( N % i == 0 ) maxi = Math . max ( maxi , i ) ; } packages = N / maxi ; System . out . println ( packages ) ; } public static void main ( String [ ] args ) { int N = 8 , K = 7 ; findMaxValue ( N , K ) ; } }
import java . util . * ; class GFG { static void makeGroups ( int a [ ] , int n ) { int [ ] v = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { v [ a [ i ] ] ++ ; } int no_of_groups = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { no_of_groups += v [ i ] / i ; v [ i ] = v [ i ] % i ; } int i = 1 ; int total = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( v [ i ] != 0 ) { total = v [ i ] ; break ; } } i ++ ; while ( i <= n ) { if ( v [ i ] != 0 ) { total += v [ i ] ; if ( total >= i ) { int rem = total - i ; no_of_groups ++ ; total = rem ; } } i ++ ; } System . out . print ( no_of_groups + "NEW_LINE"); } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 1 , 2 , 2 } ; int size = arr . length ; makeGroups ( arr , size ) ; } }
class GFG { static final int N = 4 ; static final int M = 5 ; static void preProcess ( int [ ] [ ] mat , int [ ] [ ] aux ) { for ( int i = 0 ; i < M ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 1 ; j < M ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; } static int sumQuery ( int [ ] [ ] aux , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi ] [ rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; } static boolean check ( int mid , int [ ] [ ] aux , int K ) { boolean satisfies = true ; for ( int x = 0 ; x < N ; x ++ ) { for ( int y = 0 ; y < M ; y ++ ) { if ( x + mid - 1 <= N - 1 && y + mid - 1 <= M - 1 ) { if ( sumQuery ( aux , x , y , x + mid - 1 , y + mid - 1 ) > K ) satisfies = false ; } } } return ( satisfies == true ) ; } static int maximumSquareSize ( int [ ] [ ] mat , int K ) { int [ ] [ ] aux = new int [ N ] [ M ] ; preProcess ( mat , aux ) ; int low = 1 , high = Math . min ( N , M ) ; int mid ; while ( high - low > 1 ) { mid = ( low + high ) / 2 ; if ( check ( mid , aux , K ) ) { low = mid ; } else high = mid ; } if ( check ( high , aux , K ) ) return high ; return low ; } public static void main ( String [ ] args ) { int K = 30 ; int [ ] [ ] mat = { { 1 , 2 , 3 , 4 , 6 } , { 5 , 3 , 8 , 1 , 2 } , { 4 , 6 , 7 , 5 , 5 } , { 2 , 4 , 8 , 9 , 4 } } ; System . out . print ( maximumSquareSize ( mat , K ) ) ; } }
class GFG { static boolean isalpha ( int input_char ) { if ( ( input_char >= 65 && input_char <= 90 ) || ( input_char >= 97 && input_char <= 122 ) ) return true ; return false ; } static void findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isalpha ( arr [ i ] ) ) { arr [ i ] = 0 ; } else { arr [ i ] = 1 ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } if ( maxsize == - 1 ) System . out . println ( maxsize ) ; else System . out . println ( startindex + " ▁ " + ( startindex + maxsize - 1 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { ' A ' , ' B ' , ' X ' , 4 , 6 , ' X ' , ' a ' } ; int size = arr . length ; findSubArray ( arr , size ) ; } }
import java . util . * ; class GFG { static int n = 3 ; static class Pair { int first , second ; Pair ( int a , int b ) { first = a ; second = b ; } } static int minSteps ( int arr [ ] [ ] ) { boolean v [ ] [ ] = new boolean [ n ] [ n ] ; Queue < Pair > q = new LinkedList < Pair > ( ) ; q . add ( new Pair ( 0 , 0 ) ) ; int depth = 0 ; while ( q . size ( ) != 0 ) { int x = q . size ( ) ; while ( x -- > 0 ) { Pair y = q . peek ( ) ; int i = y . first , j = y . second ; q . remove ( ) ; if ( v [ i ] [ j ] ) continue ; if ( i == n - 1 && j == n - 1 ) return depth ; v [ i ] [ j ] = true ; if ( i + arr [ i ] [ j ] < n ) q . add ( new Pair ( i + arr [ i ] [ j ] , j ) ) ; if ( j + arr [ i ] [ j ] < n ) q . add ( new Pair ( i , j + arr [ i ] [ j ] ) ) ; } depth ++ ; } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] [ ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; System . out . println ( minSteps ( arr ) ) ; } }
import java . io . * ; class GFG { static boolean checkDistinct ( int x ) { int last = x % 10 ; while ( x > 0 ) { if ( x % 10 != last ) return false ; x = x / 10 ; } return true ; } static int findCount ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( checkDistinct ( i ) ) count += 1 ; } return count ; } public static void main ( String [ ] args ) { int L = 10 , R = 50 ; System . out . println ( findCount ( L , R ) ) ; } }
public class AQES { static int LowerInsertionPoint ( int arr [ ] , int n , int X ) { if ( X < arr [ 0 ] ) return 0 ; else if ( X > arr [ n - 1 ] ) return n ; int lowerPnt = 0 ; int i = 1 ; while ( i < n && arr [ i ] < X ) { lowerPnt = i ; i = i * 2 ; } while ( lowerPnt < n && arr [ lowerPnt ] < X ) lowerPnt ++ ; return lowerPnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 4 , 4 , 5 , 6 , 7 , 9 } ; int n = arr . length ; int X = 4 ; System . out . println ( LowerInsertionPoint ( arr , n , X ) ) ; } }
class GFG { static boolean check ( String s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { String s = " xzyyz " ; if ( check ( s ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static int countAnomalies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; } public static void main ( String args [ ] ) { int arr [ ] = { 7 , 1 , 8 } , k = 5 ; int n = arr . length ; System . out . println ( countAnomalies ( arr , n , k ) ) ; } }
public class GOC1 { static int colMaxDiff ( int mat [ ] [ ] ) { int max_diff = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 } , { 5 , 3 , 5 , 4 , 0 } , { 5 , 6 , 7 , 8 , 9 } , { 0 , 6 , 3 , 4 , 12 } , { 9 , 7 , 12 , 4 , 3 } , } ; System . out . println ( " Max ▁ difference ▁ : ▁ " + colMaxDiff ( mat ) ) ; } }
class GFG { static int findmissing ( int [ ] ar , int N ) { int l = 0 , r = N - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return ( mid + 1 ) ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int N = arr . length ; System . out . println ( findmissing ( arr , N ) ) ; } }
import java . io . * ; class GFG { static int solve ( int [ ] a , int n ) { int max1 = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . abs ( a [ i ] - a [ j ] ) > max1 ) { max1 = Math . abs ( a [ i ] - a [ j ] ) ; } } } return max1 ; } static public void main ( String [ ] args ) { int [ ] arr = { - 1 , 2 , 3 , - 4 , - 10 , 22 } ; int size = arr . length ; System . out . println ( " Largest ▁ gap ▁ is ▁ : ▁ " + solve ( arr , size ) ) ; } }
class GFG { static int maxProduct ( int arr [ ] , int n ) { if ( n < 4 ) { return - 1 ; } int maxA = Integer . MIN_VALUE , maxB = Integer . MIN_VALUE , maxC = Integer . MIN_VALUE , maxD = Integer . MIN_VALUE ; int minA = Integer . MAX_VALUE , minB = Integer . MAX_VALUE , minC = Integer . MAX_VALUE , minD = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxD = maxC ; maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxD = maxC ; maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) { maxD = maxC ; maxC = arr [ i ] ; } else if ( arr [ i ] > maxD ) { maxD = arr [ i ] ; } if ( arr [ i ] < minA ) { minD = minC ; minC = minB ; minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) { minD = minC ; minC = minB ; minB = arr [ i ] ; } else if ( arr [ i ] < minC ) { minD = minC ; minC = arr [ i ] ; } else if ( arr [ i ] < minD ) { minD = arr [ i ] ; } } int x = maxA * maxB * maxC * maxD ; int y = minA * minB * minC * minD ; int z = minA * minB * maxA * maxB ; return Math . max ( x , Math . max ( y , z ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , - 4 , 3 , - 6 , 7 , 0 } ; int n = arr . length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) System . out . println ( " No ▁ Quadruple ▁ Exists " ) ; else System . out . println ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
import java . util . * ; class GFG { static void printMatrix ( ArrayList < ArrayList < Integer > > a ) { for ( int i = 0 ; i < a . size ( ) ; i ++ ) { for ( int j = 0 ; j < a . get ( i ) . size ( ) ; j ++ ) { System . out . print ( a . get ( i ) . get ( j ) + " ▁ " ) ; } System . out . println ( ) ; } } static void sortBoundaryWise ( ArrayList < ArrayList < Integer > > a ) { int i , k = 0 , l = 0 ; int m = a . size ( ) , n = a . get ( 0 ) . size ( ) ; int n_i , n_k = 0 , n_l = 0 , n_m = m , n_n = n ; while ( k < m && l < n ) { ArrayList < Integer > boundary = new ArrayList < Integer > ( ) ; for ( i = l ; i < n ; ++ i ) { boundary . add ( a . get ( k ) . get ( i ) ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { boundary . add ( a . get ( i ) . get ( n - 1 ) ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { boundary . add ( a . get ( m - 1 ) . get ( i ) ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { boundary . add ( a . get ( i ) . get ( l ) ) ; } l ++ ; } Collections . sort ( boundary ) ; int ind = 0 ; for ( i = n_l ; i < n_n ; ++ i ) { a . get ( n_k ) . set ( i , boundary . get ( ind ) ) ; ind ++ ; } n_k += 1 ; for ( i = n_k ; i < n_m ; ++ i ) { a . get ( i ) . set ( n_n - 1 , boundary . get ( ind ) ) ; ind ++ ; } n_n -- ; if ( n_k < n_m ) { for ( i = n_n - 1 ; i >= n_l ; -- i ) { a . get ( n_m - 1 ) . set ( i , boundary . get ( ind ) ) ; ind ++ ; } n_m -- ; } if ( n_l < n_n ) { for ( i = n_m - 1 ; i >= n_k ; -- i ) { a . get ( i ) . set ( n_l , boundary . get ( ind ) ) ; ind ++ ; } n_l ++ ; } } printMatrix ( a ) ; } public static void main ( String args [ ] ) { ArrayList < ArrayList < Integer > > matrix = new ArrayList < ArrayList < Integer > > ( ) ; ArrayList < Integer > list1 = new ArrayList < Integer > ( Arrays . asList ( 9 , 7 , 4 , 5 ) ) ; ArrayList < Integer > list2 = new ArrayList < Integer > ( Arrays . asList ( 1 , 6 , 2 , - 6 ) ) ; ArrayList < Integer > list3 = new ArrayList < Integer > ( Arrays . asList ( 12 , 20 , 2 , 0 ) ) ; ArrayList < Integer > list4 = new ArrayList < Integer > ( Arrays . asList ( - 5 , - 6 , 7 , - 2 ) ) ; matrix . add ( list1 ) ; matrix . add ( list2 ) ; matrix . add ( list3 ) ; matrix . add ( list4 ) ; sortBoundaryWise ( matrix ) ; } }
import java . io . * ; import java . math . * ; import java . util . * ; public class GFG { static int maxScore ( int i , int A [ ] , int K , int N , int dp [ ] ) { if ( i >= N - 1 ) return A [ N - 1 ] ; if ( dp [ i ] != - 1 ) return dp [ i ] ; int score = Integer . MIN_VALUE ; for ( int j = 1 ; j <= K ; j ++ ) { score = Math . max ( score , maxScore ( i + j , A , K , N , dp ) ) ; } return dp [ i ] = score + A [ i ] ; } static void getScore ( int A [ ] , int N , int K ) { int dp [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] = - 1 ; System . out . println ( maxScore ( 0 , A , K , N , dp ) ) ; } public static void main ( String args [ ] ) { int A [ ] = { 100 , - 30 , - 50 , - 15 , - 20 , - 30 } ; int K = 3 ; int N = A . length ; getScore ( A , N , K ) ; } }
import java . io . * ; class GFG { static boolean checkifSorted ( int A [ ] , int B [ ] , int N ) { boolean flag = false ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { flag = true ; break ; } } if ( ! flag ) { return true ; } int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 0 ) { count ++ ; break ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( B [ i ] == 1 ) { count ++ ; break ; } } if ( count == 2 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int A [ ] = { 3 , 1 , 2 } ; int B [ ] = { 0 , 1 , 1 } ; int N = A . length ; boolean check = checkifSorted ( A , B , N ) ; if ( check ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . util . * ; class GFG { static boolean isIncreasing ( int [ ] arr ) { for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) return false ; } return true ; } static int [ ] sortArr ( int [ ] arr ) { int prev = - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int optEle = arr [ i ] ; String strEle = String . valueOf ( arr [ i ] ) ; for ( int idx = 0 ; idx < strEle . length ( ) ; idx ++ ) { String strEle2 = strEle . substring ( idx ) + strEle . substring ( 0 , idx ) ; int temp = Integer . valueOf ( strEle2 ) ; if ( temp >= prev && temp < optEle ) optEle = temp ; } arr [ i ] = optEle ; prev = arr [ i ] ; } if ( isIncreasing ( arr ) ) return arr ; else { return new int [ ] { - 1 } ; } } public static void main ( String [ ] args ) { int [ ] arr = { 511 , 321 , 323 , 432 , 433 } ; int [ ] res = sortArr ( arr ) ; for ( int i = 0 ; i < res . length ; i ++ ) System . out . print ( res [ i ] + " ▁ " ) ; } }
class GFG { final static int N = 100 ; final static int INF = 1000000 ; static int dp [ ] [ ] = new int [ N ] [ N ] ; static int vis [ ] [ ] = new int [ N ] [ N ] ; static int findSum ( int [ ] arr , int n , int k , int l , int r ) { if ( ( l ) + ( n - 1 - r ) == k ) return arr [ r ] - arr [ l ] ; if ( vis [ l ] [ r ] == 1 ) return dp [ l ] [ r ] ; vis [ l ] [ r ] = 1 ; dp [ l ] [ r ] = Math . min ( findSum ( arr , n , k , l , r - 1 ) , findSum ( arr , n , k , l + 1 , r ) ) ; return dp [ l ] [ r ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 100 , 120 , 140 } ; int k = 2 ; int n = arr . length ; System . out . println ( findSum ( arr , n , k , 0 , n - 1 ) ) ; } }
import java . util . Collections ; import java . util . Vector ; class GFG { public static String getSortedString ( StringBuilder s , int n ) { Vector < Character > v1 = new Vector < > ( ) ; Vector < Character > v2 = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) >= ' a ' && s . charAt ( i ) <= ' z ' ) v1 . add ( s . charAt ( i ) ) ; if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' z ' ) v2 . add ( s . charAt ( i ) ) ; } Collections . sort ( v1 ) ; Collections . sort ( v2 ) ; int i = 0 , j = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( s . charAt ( k ) > = ' a ' && s . charAt ( k ) <= ' z ' ) { s . setCharAt ( k , v1 . elementAt ( i ) ) ; ++ i ; } else if ( s . charAt ( k ) > = ' A ' && s . charAt ( k ) <= ' Z ' ) { s . setCharAt ( k , v2 . elementAt ( j ) ) ; ++ j ; } } return s . toString ( ) ; } public static void main ( String [ ] args ) { StringBuilder s = new StringBuilder ( " gEeksfOrgEEkS " ) ; int n = s . length ( ) ; System . out . println ( getSortedString ( s , n ) ) ; } }
class GFG { static void removeElements ( int [ ] arr , int n ) { int [ ] brr = new int [ n ] ; int l = 1 ; brr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( brr [ l - 1 ] <= arr [ i ] ) { brr [ l ] = arr [ i ] ; l ++ ; } } for ( int i = 0 ; i < l ; i ++ ) System . out . print ( brr [ i ] + " ▁ " ) ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 12 , 9 , 10 , 2 , 13 , 14 } ; int n = arr . length ; removeElements ( arr , n ) ; } }
import java . util . * ; class GFG { static int findX ( int a [ ] , int n ) { Arrays . sort ( a ) ; int x = a [ 0 ] * a [ n - 1 ] ; Vector < Integer > vec = new Vector < Integer > ( ) ; for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) { vec . add ( i ) ; if ( ( x / i ) != i ) vec . add ( x / i ) ; } } Collections . sort ( vec ) ; if ( vec . size ( ) != n ) return - 1 ; else { int i = 0 ; for ( int it : vec ) { if ( a [ i ++ ] != it ) return - 1 ; } } return x ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 5 , 4 , 10 } ; int n = a . length ; System . out . print ( findX ( a , n ) ) ; } }
import java . util . Arrays ; class GFG { static int MOD = 1000000007 ; static int max = 101 ; static long C [ ] [ ] = new long [ max ] [ max ] ; static long power ( long x , long y ) { long res = 1 ; x = x % MOD ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % MOD ; } y = y >> 1 ; x = ( x * x ) % MOD ; } return res % MOD ; } static void combi ( int n , int k ) { int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] % MOD + C [ i - 1 ] [ j ] % MOD ) % MOD ; } } } static long product ( long a [ ] , int n , int k ) { long ans = 1 ; Arrays . sort ( a ) ; long powa = C [ n - 1 ] [ k - 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { long powla = C [ i ] [ k - 1 ] ; long powfa = C [ n - i - 1 ] [ k - 1 ] ; long powe = ( ( powa % MOD ) - ( powla + powfa ) % MOD + MOD ) % MOD ; long mul = power ( a [ i ] , powe ) % MOD ; ans = ( ( ans % MOD ) * ( mul % MOD ) ) % MOD ; } return ans % MOD ; } public static void main ( String [ ] args ) { combi ( 100 , 100 ) ; long arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; int k = 3 ; long ans = product ( arr , n , k ) ; System . out . println ( ans ) ; } }
import java . util . * ; class GFG { static int distribution ( int arr [ ] , int n ) { Set < Integer > resources = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) resources . add ( arr [ i ] ) ; return Math . min ( resources . size ( ) , n / 2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 4 } ; int n = arr . length ; System . out . print ( distribution ( arr , n ) + "NEW_LINE"); } }
import java . io . * ; import java . util . * ; class GFG { public static void printSorted ( String s , int l ) { Stack < Character > stack = new Stack < Character > ( ) ; Stack < Character > tempstack = new Stack < Character > ( ) ; stack . push ( s . charAt ( 0 ) ) ; for ( int i = 1 ; i < l ; i ++ ) { int a = s . charAt ( i ) ; int b = ( int ) ( ( char ) stack . peek ( ) ) ; if ( ( a - b ) >= 1 || ( a == b ) ) { stack . push ( s . charAt ( i ) ) ; } else if ( ( b - a ) >= 1 ) { while ( ( b - a ) >= 1 ) { tempstack . push ( stack . peek ( ) ) ; stack . pop ( ) ; if ( stack . size ( ) > 0 ) { b = ( int ) ( ( char ) stack . peek ( ) ) ; } else { break ; } } stack . push ( s . charAt ( i ) ) ; while ( tempstack . size ( ) > 0 ) { stack . push ( tempstack . peek ( ) ) ; tempstack . pop ( ) ; } } } String answer = " " ; while ( stack . size ( ) > 0 ) { answer = stack . peek ( ) + answer ; stack . pop ( ) ; } System . out . println ( answer ) ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; int l = s . length ( ) ; printSorted ( s , l ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int maximum_toys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ; Arrays . sort ( cost ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; } public static void main ( String [ ] args ) { int K = 50 ; int cost [ ] = { 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 } ; int N = cost . length ; System . out . print ( maximum_toys ( cost , N , K ) ) ; } }
import java . util . * ; class GFG { public static boolean almostSort ( int A [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 3 , 2 , 4 , 6 , 5 } ; int n = A . length ; if ( almostSort ( A , n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . io . * ; class GFG { static void mergeTwoHalf ( int [ ] A , int n ) { int i ; int [ ] temp = new int [ n ] ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { half_i = i + 1 ; break ; } } if ( half_i == 0 ) return ; i = 0 ; int j = half_i ; int k = 0 ; while ( i < half_i && j < n ) { if ( A [ i ] < A [ j ] ) temp [ k ++ ] = A [ i ++ ] ; else temp [ k ++ ] = A [ j ++ ] ; } while ( i < half_i ) temp [ k ++ ] = A [ i ++ ] ; while ( j < n ) temp [ k ++ ] = A [ j ++ ] ; for ( i = 0 ; i < n ; i ++ ) A [ i ] = temp [ i ] ; } static public void main ( String [ ] args ) { int [ ] A = { 2 , 3 , 8 , - 1 , 7 , 10 } ; int n = A . length ; mergeTwoHalf ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } }
import java . io . * ; class GFG { static final double Pi = 3.141592 ; static int MaxBuildingsCovered ( int arr [ ] , int N , int L ) { double curr_sum = 0 ; int start = 0 , curr_count = 0 , max_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_sum = curr_sum + ( ( double ) arr [ i ] * Pi ) ; if ( i != 0 ) curr_sum += 1 ; if ( curr_sum <= L ) { curr_count ++ ; } else if ( curr_sum > L ) { curr_sum = curr_sum - ( ( double ) arr [ start ] * Pi ) ; curr_sum -= 1 ; start ++ ; curr_count -- ; } max_count = Math . max ( curr_count , max_count ) ; } return max_count ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 1 , 6 , 2 } ; int L = 24 ; int N = arr . length ; System . out . println ( MaxBuildingsCovered ( arr , N , L ) ) ; } }
public class MyClass { static boolean isPossible ( String s ) { int n = s . length ( ) ; int count_0 = 0 , count_1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } if ( count_0 != ( 2 * count_1 ) ) return false ; count_0 = 0 ; count_1 = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( s . charAt ( i ) == '0' ) ++ count_0 ; else ++ count_1 ; if ( count_1 > count_0 ) return false ; } return true ; } public static void main ( String args [ ] ) { String s = "010100" ; if ( isPossible ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int findMaxValByRearrArr ( int arr [ ] , int N ) { int res = 0 ; res = ( N * ( N + 1 ) ) / 2 ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int N = arr . length ; System . out . print ( findMaxValByRearrArr ( arr , N ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static float pairProductMean ( int arr [ ] , int N ) { int suffixSumArray [ ] = new int [ N ] ; suffixSumArray [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffixSumArray [ i ] = suffixSumArray [ i + 1 ] + arr [ i ] ; } int length = ( N * ( N - 1 ) ) / 2 ; float res = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { res += arr [ i ] * suffixSumArray [ i + 1 ] ; } float mean ; if ( length != 0 ) mean = res / length ; else mean = 0 ; return mean ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 8 } ; int N = arr . length ; System . out . format ( " % .2f " , pairProductMean ( arr , N ) ) ; } }
import java . util . * ; class GFG { static void values_of_Q ( int X ) { ArrayList < Integer > val_Q = new ArrayList < Integer > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { if ( ( ( ( X + i ) * X ) ) % i == 0 ) { val_Q . add ( X + i ) ; } } System . out . println ( val_Q . size ( ) ) ; for ( int i = 0 ; i < val_Q . size ( ) ; i ++ ) { System . out . print ( val_Q . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { int X = 3 ; values_of_Q ( X ) ; } }
class GFG { static int sumOfFactors ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int first = i ; int last = ( N / i ) * i ; int factors = ( last - first ) / i + 1 ; int totalContribution = ( ( ( factors ) * ( factors + 1 ) ) / 2 ) * i ; ans += totalContribution ; } return ans ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( sumOfFactors ( N ) ) ; } }
import java . util . * ; class GFG { static int maxProfit ( int [ ] value , int N , int K ) { Arrays . sort ( value ) ; int maxval = value [ N - 1 ] ; int maxProfit = 0 ; int curr_val ; do { curr_val = 0 ; for ( int i = 0 ; i < N ; i ++ ) { curr_val += value [ i ] ; if ( curr_val <= K ) { maxProfit = Math . max ( curr_val + maxval * ( i + 1 ) , maxProfit ) ; } } } while ( next_permutation ( value ) ) ; return maxProfit ; } static boolean next_permutation ( int [ ] p ) { for ( int a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { int t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; } public static void main ( String [ ] args ) { int N = 4 , K = 6 ; int [ ] values = { 5 , 2 , 7 , 3 } ; System . out . print ( maxProfit ( values , N , K ) ) ; } }
import java . lang . Math ; class GFG { static void minValue ( int n ) { while ( ( int ) Math . sqrt ( n ) == Math . sqrt ( n ) && n > 1 ) { n = ( int ) ( Math . sqrt ( n ) ) ; } for ( int i = ( int ) ( Math . sqrt ( n ) ) ; i > 1 ; i -- ) { while ( n % ( i * i ) == 0 ) n /= i ; } System . out . println ( n ) ; } public static void main ( String args [ ] ) { int N = 20 ; minValue ( N ) ; } }
class GFG { static void findDirection ( int n , int m ) { if ( n > m ) { if ( m % 2 == 0 ) System . out . print ( "UpNEW_LINE"); else System . out . print ( "DownNEW_LINE"); } else { if ( n % 2 == 0 ) System . out . print ( "LeftNEW_LINE"); else System . out . print ( "RightNEW_LINE"); } } public static void main ( String [ ] args ) { int n = 3 , m = 3 ; findDirection ( n , m ) ; } }
import java . util . * ; class GFG { static int N = ( int ) ( 1e5 + 5 ) ; static Vector < Integer > [ ] v = new Vector [ N ] ; static int [ ] val = new int [ N ] ; static int [ ] answer = new int [ N ] ; static int n ; static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static void DFS ( int node , int parent ) { answer [ node ] = val [ node ] ; for ( int child : v [ node ] ) { if ( child == parent ) continue ; DFS ( child , node ) ; answer [ node ] = gcd ( answer [ node ] , answer [ child ] ) ; } } static void preprocess ( ) { DFS ( 1 , - 1 ) ; } static void findGCD ( int queries [ ] , int q ) { preprocess ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int GCD = answer [ queries [ i ] ] ; System . out . print ( " For ▁ subtree ▁ of ▁ " + queries [ i ] + " , ▁ GCD ▁ = ▁ " + GCD + "NEW_LINE"); } } public static void main ( String [ ] args ) { n = 5 ; for ( int i = 0 ; i < v . length ; i ++ ) v [ i ] = new Vector < Integer > ( ) ; v [ 1 ] . add ( 2 ) ; v [ 2 ] . add ( 1 ) ; v [ 1 ] . add ( 3 ) ; v [ 3 ] . add ( 1 ) ; v [ 3 ] . add ( 4 ) ; v [ 4 ] . add ( 3 ) ; v [ 3 ] . add ( 5 ) ; v [ 5 ] . add ( 3 ) ; val [ 1 ] = 2 ; val [ 2 ] = 3 ; val [ 3 ] = 4 ; val [ 4 ] = 8 ; val [ 5 ] = 16 ; int queries [ ] = { 2 , 3 , 1 } ; int q = queries . length ; findGCD ( queries , q ) ; } }
class GFG { static boolean check ( int [ ] arr , int n ) { boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < n - i ) { flag = false ; } } if ( flag ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { int arr1 [ ] = { 11 , 11 , 11 , 11 } ; int n1 = arr1 . length ; if ( check ( arr1 , n1 ) ) { System . out . print ( " Yes " + "NEW_LINE"); } else { System . out . print ( " No " + "NEW_LINE"); } } }
class GFG { static int getLargestSum ( int N ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { for ( int j = i + 1 ; j * j <= N ; j ++ ) { int k = N / j ; int a = k * i ; int b = k * j ; if ( a <= N && b <= N && a * b % ( a + b ) == 0 ) max_sum = Math . max ( max_sum , a + b ) ; } } return max_sum ; } public static void main ( String [ ] args ) { int N = 25 ; int max_sum = getLargestSum ( N ) ; System . out . print ( max_sum + "NEW_LINE"); } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int n , int m ) { return ( n * m ) / gcd ( n , m ) ; } public static void main ( String [ ] args ) { int n = 2 , m = 3 , k = 5 ; System . out . print ( k / lcm ( n , m ) ) ; } }
import java . io . * ; class GFG { static boolean CheckForSequence ( int arr [ ] , int n , int k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( k >= arr [ i ] ) k -= arr [ i ] ; } if ( k != 0 ) return false ; else return true ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 3 , 7 , 15 , 31 } ; int n = A . length ; System . out . println ( CheckForSequence ( A , n , 18 ) ? " True " : " False " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int SubarraySum ( int [ ] a , int n , int x ) { int ans = - 10000 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int curans = 0 ; ArrayList < Integer > pq = new ArrayList < Integer > ( ) ; ArrayList < Integer > pq2 = new ArrayList < Integer > ( ) ; for ( int k = 0 ; k < n ; k ++ ) { if ( k >= i && k <= j ) { curans += a [ k ] ; pq2 . add ( a [ k ] ) ; } else pq . add ( a [ k ] ) ; } Collections . sort ( pq ) ; Collections . reverse ( pq ) ; Collections . sort ( pq2 ) ; ans = Math . max ( ans , curans ) ; for ( int k = 1 ; k <= x ; k ++ ) { if ( pq . size ( ) == 0 || pq2 . size ( ) == 0 || pq2 . get ( 0 ) >= pq . get ( 0 ) ) break ; curans -= pq2 . get ( 0 ) ; pq2 . remove ( 0 ) ; curans += pq . get ( 0 ) ; pq . remove ( 0 ) ; ans = Math . max ( ans , curans ) ; } } } return ans ; } public static void main ( String [ ] args ) { int [ ] a = { 5 , - 1 , 2 , 3 , 4 , - 2 , 5 } ; int x = 2 ; int n = a . length ; System . out . println ( SubarraySum ( a , n , x ) ) ; } }
class GFG { static void generateArray ( int n , int k ) { int [ ] array = new int [ k ] ; int remaining = n - ( k * ( k + 1 ) / 2 ) ; if ( remaining < 0 ) System . out . print ( " NO " ) ; int right_most = remaining % k ; int high = ( int ) Math . ceil ( remaining / ( k * 1.0 ) ) ; int low = ( int ) Math . floor ( remaining / ( k * 1.0 ) ) ; for ( int i = k - right_most ; i < k ; i ++ ) array [ i ] = high ; for ( int i = 0 ; i < ( k - right_most ) ; i ++ ) array [ i ] = low ; for ( int i = 0 ; i < k ; i ++ ) array [ i ] += i + 1 ; if ( k - 1 != remaining k == 1 ) { for ( int u : array ) System . out . print ( u + " ▁ " ) ; } else if ( k == 2 k == 3 ) System . out . printf ( "-1NEW_LINE"); else { array [ 1 ] -= 1 ; array [ k - 1 ] += 1 ; for ( int u : array ) System . out . print ( u + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 26 , k = 6 ; generateArray ( n , k ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int maxSubStrings ( String s , int k ) { int maxSubStr = 0 , n = s . length ( ) ; for ( int c = 0 ; c < 26 ; c ++ ) { char ch = ( char ) ( ( int ) ' a ' + c ) ; int curr = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { if ( s . charAt ( i ) != ch ) continue ; int cnt = 0 ; while ( i < n && s . charAt ( i ) == ch && cnt != k ) { i ++ ; cnt ++ ; } i -- ; if ( cnt == k ) curr ++ ; } maxSubStr = Math . max ( maxSubStr , curr ) ; } return maxSubStr ; } public static void main ( String [ ] args ) { String s = " aaacaabbaa " ; int k = 2 ; System . out . println ( maxSubStrings ( s , k ) ) ; } }
class GFG { static int minCost ( int N , int P , int Q ) { int cost = 0 ; while ( N > 0 ) { if ( ( N & 1 ) > 0 ) { cost += P ; N -- ; } else { int temp = N / 2 ; if ( temp * P > Q ) cost += Q ; else cost += P * temp ; N /= 2 ; } } return cost ; } public static void main ( String [ ] args ) { int N = 9 , P = 5 , Q = 1 ; System . out . println ( minCost ( N , P , Q ) ) ; } }
class GFG { static int solve ( int a [ ] , int b [ ] , int n ) { int i ; int s = 0 ; for ( i = 0 ; i < n ; i ++ ) s += ( a [ i ] + b [ i ] ) ; if ( n == 1 ) return a [ 0 ] + b [ 0 ] ; if ( s % n != 0 ) return - 1 ; int x = s / n ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) return - 1 ; if ( i > 0 ) { a [ i ] += b [ i - 1 ] ; b [ i - 1 ] = 0 ; } if ( a [ i ] == x ) continue ; int y = a [ i ] + b [ i ] ; if ( i + 1 < n ) y += b [ i + 1 ] ; if ( y == x ) { a [ i ] = y ; b [ i ] = 0 ; continue ; } if ( a [ i ] + b [ i ] == x ) { a [ i ] += b [ i ] ; b [ i ] = 0 ; continue ; } if ( i + 1 < n && a [ i ] + b [ i + 1 ] == x ) { a [ i ] += b [ i + 1 ] ; b [ i + 1 ] = 0 ; continue ; } return - 1 ; } for ( i = 0 ; i < n ; i ++ ) if ( b [ i ] != 0 ) return - 1 ; return x ; } public static void main ( String [ ] args ) { int a [ ] = { 6 , 14 , 21 , 1 } ; int b [ ] = { 15 , 7 , 10 , 10 } ; int n = a . length ; System . out . println ( solve ( a , b , n ) ) ; } }
import java . io . * ; class GFG { static void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) System . out . println ( " No " ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; System . out . println ( " Yes ▁ " + days ) ; } } public static void main ( String [ ] args ) { int S = 10 , N = 16 , M = 2 ; survival ( S , N , M ) ; } }
import java . io . * ; class GFG { static int LongestOddEvenSubarray ( int A [ ] , int N ) { int dp [ ] = new int [ N ] ; dp [ 0 ] = 1 ; int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 0 && A [ i - 1 ] % 2 == 0 ) || ( A [ i ] % 2 != 0 && A [ i - 1 ] % 2 != 0 ) ) { dp [ i ] = dp [ i - 1 ] + 1 ; } else dp [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) ans = Math . max ( ans , dp [ i ] ) ; return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 5 , 7 , 2 , 4 , 6 , 8 , 3 } ; int N = A . length ; System . out . println ( LongestOddEvenSubarray ( A , N ) ) ; } }
import java . util . * ; public class Main { static int getValue ( int [ ] arr , int N ) { int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { int min = arr [ i ] ; int max = arr [ i ] ; for ( int j = i ; j >= 0 ; j -- ) { min = Math . min ( arr [ j ] , min ) ; max = Math . max ( arr [ j ] , max ) ; dp [ i ] = Math . max ( dp [ i ] , max - min + ( ( j >= 1 ) ? dp [ j - 1 ] : 0 ) ) ; } } return dp [ N - 1 ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 8 , 1 , 7 , 9 , 2 } ; int N = arr . length ; System . out . println ( getValue ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int reduceZero ( int N ) { int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) dp [ i ] = ( int ) 1e9 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( char c : String . valueOf ( i ) . toCharArray ( ) ) { dp [ i ] = Math . min ( dp [ i ] , dp [ i - ( c - '0' ) ] + 1 ) ; } } return dp [ N ] ; } public static void main ( String [ ] args ) { int N = 25 ; System . out . print ( reduceZero ( N ) ) ; } }
import java . util . * ; class GFG { static boolean [ ] prime = new boolean [ 100001 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p < 100000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= 100000 ; i += p ) prime [ i ] = false ; } } } static int distinctPrimeSubSeq ( int a [ ] , int n , int k ) { SieveOfEratosthenes ( ) ; Vector < Integer > primes = new Vector < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ a [ i ] ] ) primes . add ( a [ i ] ) ; } int l = primes . size ( ) ; Collections . sort ( primes ) ; Vector < Integer > b = new Vector < > ( ) ; Vector < Integer > dp = new Vector < > ( ) ; int sum = 0 ; for ( int i = 0 ; i < l ; ) { int count = 1 , x = a [ i ] ; i ++ ; while ( i < l && a [ i ] == x ) { count ++ ; i ++ ; } b . add ( count ) ; dp . add ( count ) ; sum += count ; } int of_length = 2 ; int len = dp . size ( ) ; int ans = 0 ; while ( of_length < k ) { int freq = 0 ; int prev = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { freq += dp . elementAt ( i ) ; int j = sum - freq ; int subseq = b . elementAt ( i ) * j ; ans += subseq ; dp . add ( i , subseq ) ; prev += dp . elementAt ( i ) ; } len -- ; sum = prev ; of_length ++ ; } ans += ( l + 3 ) ; return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 2 , 3 , 3 , 4 , 5 } ; int n = a . length ; int k = 3 ; System . out . print ( distinctPrimeSubSeq ( a , n , k ) ) ; } }
class GFG { static int mod = 1000000007 ; static int [ ] [ ] dp = new int [ 1000 ] [ 1000 ] ; static int calculate ( int pos , int left , int k , int L , int R ) { if ( pos == k ) { if ( left == 0 ) return 1 ; else return 0 ; } if ( left == 0 ) return 0 ; if ( dp [ pos ] [ left ] != - 1 ) return dp [ pos ] [ left ] ; int answer = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( i > left ) break ; answer = ( answer + calculate ( pos + 1 , left - i , k , L , R ) ) % mod ; } return dp [ pos ] [ left ] = answer ; } static int countWaystoDivide ( int n , int k , int L , int R ) { for ( int i = 0 ; i < 1000 ; i ++ ) { for ( int j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return calculate ( 0 , n , k , L , R ) ; } public static void main ( String [ ] args ) { int N = 12 ; int K = 3 ; int L = 1 ; int R = 5 ; System . out . print ( countWaystoDivide ( N , K , L , R ) ) ; } }
import java . util . * ; class GFG { static void largestSquare ( int matrix [ ] [ ] , int R , int C , int q_i [ ] , int q_j [ ] , int K , int Q ) { int countDP [ ] [ ] = new int [ R ] [ C ] ; for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) countDP [ i ] [ j ] = 0 ; countDP [ 0 ] [ 0 ] = matrix [ 0 ] [ 0 ] ; for ( int i = 1 ; i < R ; i ++ ) countDP [ i ] [ 0 ] = countDP [ i - 1 ] [ 0 ] + matrix [ i ] [ 0 ] ; for ( int j = 1 ; j < C ; j ++ ) countDP [ 0 ] [ j ] = countDP [ 0 ] [ j - 1 ] + matrix [ 0 ] [ j ] ; for ( int i = 1 ; i < R ; i ++ ) for ( int j = 1 ; j < C ; j ++ ) countDP [ i ] [ j ] = matrix [ i ] [ j ] + countDP [ i - 1 ] [ j ] + countDP [ i ] [ j - 1 ] - countDP [ i - 1 ] [ j - 1 ] ; for ( int q = 0 ; q < Q ; q ++ ) { int i = q_i [ q ] ; int j = q_j [ q ] ; int min_dist = Math . min ( Math . min ( i , j ) , Math . min ( R - i - 1 , C - j - 1 ) ) ; int ans = - 1 , l = 0 , u = min_dist ; while ( l <= u ) { int mid = ( l + u ) / 2 ; int x1 = i - mid , x2 = i + mid ; int y1 = j - mid , y2 = j + mid ; int count = countDP [ x2 ] [ y2 ] ; if ( x1 > 0 ) count -= countDP [ x1 - 1 ] [ y2 ] ; if ( y1 > 0 ) count -= countDP [ x2 ] [ y1 - 1 ] ; if ( x1 > 0 && y1 > 0 ) count += countDP [ x1 - 1 ] [ y1 - 1 ] ; if ( count <= K ) { ans = 2 * mid + 1 ; l = mid + 1 ; } else u = mid - 1 ; } System . out . println ( ans ) ; } } public static void main ( String args [ ] ) { int matrix [ ] [ ] = { { 1 , 0 , 1 , 0 , 0 } , { 1 , 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 1 , 0 } } ; int K = 9 , Q = 1 ; int q_i [ ] = { 1 } ; int q_j [ ] = { 2 } ; largestSquare ( matrix , 4 , 5 , q_i , q_j , K , Q ) ; } }
