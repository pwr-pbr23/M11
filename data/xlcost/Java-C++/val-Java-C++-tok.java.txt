import java . util . Arrays ; class GFG { static void calculateSpan ( int price [ ] , int n , int S [ ] ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } static void printArray ( int arr [ ] ) { System . out . print ( Arrays . toString ( arr ) ) ; } public static void main ( String [ ] args ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = price . length ; int S [ ] = new int [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S ) ; } }
class Main { static void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } System . out . println ( arr [ i ] + " ▁ - - ▁ " + next ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = arr . length ; printNGE ( arr , n ) ; } }
import java . util . Stack ; class GFG { static void PrintMinNumberForPattern ( String seq ) { String result = " " ; Stack < Integer > stk = new Stack < Integer > ( ) ; for ( int i = 0 ; i <= seq . length ( ) ; i ++ ) { stk . push ( i + 1 ) ; if ( i == seq . length ( ) || seq . charAt ( i ) == ' I ' ) { while ( ! stk . empty ( ) ) { result += String . valueOf ( stk . peek ( ) ) ; result += " ▁ " ; stk . pop ( ) ; } } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { PrintMinNumberForPattern ( " IDID " ) ; PrintMinNumberForPattern ( " I " ) ; PrintMinNumberForPattern ( " DD " ) ; PrintMinNumberForPattern ( " II " ) ; PrintMinNumberForPattern ( " DIDI " ) ; PrintMinNumberForPattern ( " IIDDD " ) ; PrintMinNumberForPattern ( " DDIDDIID " ) ; } }
import java . util . HashMap ; import java . util . Map ; import java . util . Map . Entry ; class GFG { static int mostFrequent ( int arr [ ] , int n ) { Map < Integer , Integer > hp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int key = arr [ i ] ; if ( hp . containsKey ( key ) ) { int freq = hp . get ( key ) ; freq ++ ; hp . put ( key , freq ) ; } else { hp . put ( key , 1 ) ; } } int max_count = 0 , res = - 1 ; for ( Entry < Integer , Integer > val : hp . entrySet ( ) ) { if ( max_count < val . getValue ( ) ) { res = val . getKey ( ) ; max_count = val . getValue ( ) ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = arr . length ; System . out . println ( mostFrequent ( arr , n ) ) ; } }
import java . util . HashSet ; import java . util . Set ; public class GfG { static void findMissing ( int a [ ] , int b [ ] , int n , int m ) { HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) s . add ( b [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ! s . contains ( a [ i ] ) ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 6 , 3 , 4 , 5 } ; int b [ ] = { 2 , 4 , 3 , 1 , 0 } ; int n = a . length ; int m = b . length ; findMissing ( a , b , n , m ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; } public static void main ( String argc [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = 7 ; System . out . println ( subset ( arr , n ) ) ; } }
import java . util . * ; class GFG { static void makePermutation ( int [ ] a , int n ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) ) { count . put ( a [ i ] , count . get ( a [ i ] ) + 1 ) ; } else { count . put ( a [ i ] , 1 ) ; } } int next_missing = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count . containsKey ( a [ i ] ) && count . get ( a [ i ] ) != 1 a [ i ] > n a [ i ] < 1 ) { count . put ( a [ i ] , count . get ( a [ i ] ) - 1 ) ; while ( count . containsKey ( next_missing ) ) next_missing ++ ; a [ i ] = next_missing ; count . put ( next_missing , 1 ) ; } } } public static void main ( String [ ] args ) { int A [ ] = { 2 , 2 , 3 , 3 } ; int n = A . length ; makePermutation ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } }
import java . util . * ; class Solution { public static void main ( String [ ] args ) { int arr [ ] = { 10 , 2 , - 2 , - 20 , 10 } ; int k = - 10 ; int n = arr . length ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += arr [ j ] ; if ( sum == k ) res ++ ; } } System . out . println ( res ) ; } }
import java . util . * ; class GFG { public static void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { HashMap < Integer , Integer > s = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) s . put ( arr1 [ i ] , 0 ) ; for ( int j = 0 ; j < m ; j ++ ) if ( s . containsKey ( x - arr2 [ j ] ) ) System . out . println ( x - arr2 [ j ] + " ▁ " + arr2 [ j ] ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 0 , - 4 , 7 , 6 , 4 } ; int arr2 [ ] = { 0 , 2 , 4 , - 3 , 2 , 1 } ; int x = 8 ; findPairs ( arr1 , arr2 , arr1 . length , arr2 . length , x ) ; } }
class GFG { static boolean findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; } public static void main ( String [ ] args ) { int a1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int a2 [ ] = { 2 , 3 , 6 , 1 , 2 } ; int a3 [ ] = { 3 , 2 , 4 , 5 , 6 } ; int sum = 9 ; int n1 = a1 . length ; int n2 = a2 . length ; int n3 = a3 . length ; if ( findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class GFG { static void longest ( int a [ ] , int n , int k ) { int [ ] freq = new int [ 7 ] ; int start = 0 , end = 0 , now = 0 , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ a [ i ] ] ++ ; if ( freq [ a [ i ] ] == 1 ) now ++ ; while ( now > k ) { freq [ a [ l ] ] -- ; if ( freq [ a [ l ] ] == 0 ) now -- ; l ++ ; } if ( i - l + 1 >= end - start + 1 ) { end = i ; start = l ; } } for ( int i = start ; i <= end ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int a [ ] = { 6 , 5 , 1 , 2 , 3 , 2 , 1 , 4 , 5 } ; int n = a . length ; int k = 3 ; longest ( a , n , k ) ; } }
class LargestSubArray { int findSubArray ( int arr [ ] , int n ) { int sum = 0 ; int maxsize = - 1 , startindex = 0 ; int endindex = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { sum = ( arr [ i ] == 0 ) ? - 1 : 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] == 0 ) sum += - 1 ; else sum += 1 ; if ( sum == 0 && maxsize < j - i + 1 ) { maxsize = j - i + 1 ; startindex = i ; } } } endindex = startindex + maxsize - 1 ; if ( maxsize == - 1 ) System . out . println ( " No ▁ such ▁ subarray " ) ; else System . out . println ( startindex + " ▁ to ▁ " + endindex ) ; return maxsize ; } public static void main ( String [ ] args ) { LargestSubArray sub ; sub = new LargestSubArray ( ) ; int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int size = arr . length ; sub . findSubArray ( arr , size ) ; } }
import java . io . * ; class GFG { static void findAllTriplets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { System . out . println ( arr [ j ] + " ▁ " + arr [ i ] + " ▁ " + arr [ k ] ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = arr . length ; findAllTriplets ( arr , n ) ; } }
import java . util . * ; public class Main { public static void findTriplets ( int a [ ] , int n , int sum ) { int i ; Arrays . sort ( a ) ; boolean flag = false ; for ( i = 0 ; i < n - 2 ; i ++ ) { if ( i == 0 a [ i ] > a [ i - 1 ] ) { int start = i + 1 ; int end = n - 1 ; int target = sum - a [ i ] ; while ( start < end ) { if ( start > i + 1 && a [ start ] == a [ start - 1 ] ) { start ++ ; continue ; } if ( end < n - 1 && a [ end ] == a [ end + 1 ] ) { end -- ; continue ; } if ( target == a [ start ] + a [ end ] ) { System . out . print ( " [ " + a [ i ] + " , " + a [ start ] + " , " + a [ end ] + " ] ▁ " ) ; flag = true ; start ++ ; end -- ; } else if ( target > ( a [ start ] + a [ end ] ) ) { start ++ ; } else { end -- ; } } } } if ( flag == false ) { System . out . print ( " No ▁ Such ▁ Triplets ▁ Exist " ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 12 , 3 , 6 , 1 , 6 , 9 } ; int n = a . length ; int sum = 24 ; findTriplets ( a , n , sum ) ; } }
class GFG { static int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] * arr [ j ] * arr [ k ] == m ) count ++ ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 , 8 } ; int m = 24 ; System . out . println ( countTriplets ( arr , arr . length , m ) ) ; } }
import java . util . * ; class geeks { public static int sumoflength ( int [ ] arr , int n ) { Set < Integer > s = new HashSet < > ( ) ; int j = 0 , ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && ! s . contains ( arr [ j ] ) ) { s . add ( arr [ i ] ) ; j ++ ; } ans += ( ( j - i ) * ( j - i + 1 ) ) / 2 ; s . remove ( arr [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( sumoflength ( arr , n ) ) ; } }
class RotateArray { void leftRotatebyOne ( int arr [ ] , int n ) { int i , temp ; temp = arr [ 0 ] ; for ( i = 0 ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; arr [ n - 1 ] = temp ; } void leftRotate ( int arr [ ] , int d , int n ) { for ( int i = 0 ; i < d ; i ++ ) leftRotatebyOne ( arr , n ) ; } void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { RotateArray rotate = new RotateArray ( ) ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; rotate . leftRotate ( arr , 2 , 7 ) ; rotate . printArray ( arr , 7 ) ; } }
class Main { static int search ( int arr [ ] , int l , int h , int key ) { if ( l > h ) return - 1 ; int mid = ( l + h ) / 2 ; if ( arr [ mid ] == key ) return mid ; if ( arr [ l ] <= arr [ mid ] ) { if ( key >= arr [ l ] && key <= arr [ mid ] ) return search ( arr , l , mid - 1 , key ) ; return search ( arr , mid + 1 , h , key ) ; } if ( key >= arr [ mid ] && key <= arr [ h ] ) return search ( arr , mid + 1 , h , key ) ; return search ( arr , l , mid - 1 , key ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 5 , 6 , 7 , 8 , 9 , 1 , 2 , 3 } ; int n = arr . length ; int key = 6 ; int i = search ( arr , 0 , n - 1 , key ) ; if ( i != - 1 ) System . out . println ( " Index : ▁ " + i ) ; else System . out . println ( " Key ▁ not ▁ found " ) ; } }
class PairInSortedRotated { static boolean pairInSortedRotated ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int sum = 16 ; int n = arr . length ; if ( pairInSortedRotated ( arr , n , sum ) ) System . out . print ( " Array ▁ has ▁ two ▁ elements " + " ▁ with ▁ sum ▁ 16" ) ; else System . out . print ( " Array ▁ doesn ' t ▁ have ▁ two " + " ▁ elements ▁ with ▁ sum ▁ 16 ▁ " ) ; } }
import java . io . * ; class GFG { static void leftRotate ( int arr [ ] , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) System . out . print ( arr [ i % n ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = arr . length ; int k = 2 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; k = 3 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; k = 4 ; leftRotate ( arr , n , k ) ; System . out . println ( ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class Minimum { static int findMin ( int arr [ ] , int low , int high ) { if ( high < low ) return arr [ 0 ] ; if ( high == low ) return arr [ low ] ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return arr [ mid + 1 ] ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ high ] > arr [ mid ] ) return findMin ( arr , low , mid - 1 ) ; return findMin ( arr , mid + 1 , high ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 5 , 6 , 1 , 2 , 3 , 4 } ; int n1 = arr1 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr1 , 0 , n1 - 1 ) ) ; int arr2 [ ] = { 1 , 2 , 3 , 4 } ; int n2 = arr2 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr2 , 0 , n2 - 1 ) ) ; int arr3 [ ] = { 1 } ; int n3 = arr3 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr3 , 0 , n3 - 1 ) ) ; int arr4 [ ] = { 1 , 2 } ; int n4 = arr4 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr4 , 0 , n4 - 1 ) ) ; int arr5 [ ] = { 2 , 1 } ; int n5 = arr5 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr5 , 0 , n5 - 1 ) ) ; int arr6 [ ] = { 5 , 6 , 7 , 1 , 2 , 3 , 4 } ; int n6 = arr6 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr6 , 0 , n6 - 1 ) ) ; int arr7 [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n7 = arr7 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr7 , 0 , n7 - 1 ) ) ; int arr8 [ ] = { 2 , 3 , 4 , 5 , 6 , 7 , 8 , 1 } ; int n8 = arr8 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr8 , 0 , n8 - 1 ) ) ; int arr9 [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n9 = arr9 . length ; System . out . println ( " The ▁ minimum ▁ element ▁ is ▁ " + findMin ( arr9 , 0 , n9 - 1 ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static void SplitAndAdd ( int [ ] A , int length , int rotation ) { int [ ] tmp = new int [ length * 2 ] ; System . arraycopy ( A , 0 , tmp , 0 , length ) ; System . arraycopy ( A , 0 , tmp , length , length ) ; for ( int i = rotation ; i < rotation + length ; i ++ ) A [ i - rotation ] = tmp [ i ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = arr . length ; int position = 2 ; SplitAndAdd ( arr , n , position ) ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class GFG { static void printArray ( int A [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; System . out . println ( " " ) ; ; } static void reverse ( int arr [ ] , int l , int r ) { if ( l < r ) { arr = swap ( arr , l , r ) ; reverse ( arr , ++ l , -- r ) ; } } static void merge ( int arr [ ] , int l , int m , int r ) { int i = l ; int j = m + 1 ; while ( i <= m && arr [ i ] < 0 ) i ++ ; while ( j <= r && arr [ j ] < 0 ) j ++ ; reverse ( arr , i , m ) ; reverse ( arr , m + 1 , j - 1 ) ; reverse ( arr , i , j - 1 ) ; } static void RearrangePosNeg ( int arr [ ] , int l , int r ) { if ( l < r ) { int m = l + ( r - l ) / 2 ; RearrangePosNeg ( arr , l , m ) ; RearrangePosNeg ( arr , m + 1 , r ) ; merge ( arr , l , m , r ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void main ( String [ ] args ) { int arr [ ] = { - 12 , 11 , - 13 , - 5 , 6 , - 7 , 5 , - 3 , - 6 } ; int arr_size = arr . length ; RearrangePosNeg ( arr , 0 , arr_size - 1 ) ; printArray ( arr , arr_size ) ; } }
import java . util . Arrays ; public class GFG { static void rearrange ( int [ ] arr , int n ) { int temp [ ] = arr . clone ( ) ; int small = 0 , large = n - 1 ; boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) arr [ i ] = temp [ large -- ] ; else arr [ i ] = temp [ small ++ ] ; flag = ! flag ; } } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 } ; System . out . println ( " Original ▁ Array ▁ " ) ; System . out . println ( Arrays . toString ( arr ) ) ; rearrange ( arr , arr . length ) ; System . out . println ( " Modified ▁ Array ▁ " ) ; System . out . println ( Arrays . toString ( arr ) ) ; } }
public class Main { public static void rearrange ( int arr [ ] , int n ) { int max_ele = arr [ n - 1 ] ; int min_ele = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] = max_ele ; max_ele -= 1 ; } else { arr [ i ] = min_ele ; min_ele += 1 ; } } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . length ; System . out . println ( " Original ▁ Array " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; rearrange ( arr , n ) ; System . out . print ( " Modified Array "); for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class Node { int data ; Node left , right ; Node ( int item ) { data = item ; left = right = null ; } } class BinaryTree { Node root ; boolean isLeaf ( Node node ) { if ( node == null ) return false ; if ( node . left == null && node . right == null ) return true ; return false ; } int leftLeavesSum ( Node node ) { int res = 0 ; if ( node != null ) { if ( isLeaf ( node . left ) ) res += node . left . data ; else res += leftLeavesSum ( node . left ) ; res += leftLeavesSum ( node . right ) ; } return res ; } public static void main ( String args [ ] ) { BinaryTree tree = new BinaryTree ( ) ; tree . root = new Node ( 20 ) ; tree . root . left = new Node ( 9 ) ; tree . root . right = new Node ( 49 ) ; tree . root . left . right = new Node ( 12 ) ; tree . root . left . left = new Node ( 5 ) ; tree . root . right . left = new Node ( 23 ) ; tree . root . right . right = new Node ( 52 ) ; tree . root . left . right . right = new Node ( 12 ) ; tree . root . right . right . left = new Node ( 50 ) ; System . out . println ( " The ▁ sum ▁ of ▁ leaves ▁ is ▁ " + tree . leftLeavesSum ( tree . root ) ) ; } }
import java . util . Arrays ; class GFG { static void segregateElements ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } public static void main ( String arg [ ] ) { int arr [ ] = { 1 , - 1 , - 3 , - 2 , 7 , 5 , 11 , 6 } ; int n = arr . length ; segregateElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void swap ( int [ ] a , int i , int j ) { int temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , - 3 , 5 , 6 , - 3 , 6 , 7 , - 4 , 9 , 10 } ; int n = arr . length ; printArray ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 && i % 2 == 1 ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] < 0 && j % 2 == 0 ) { swap ( arr , i , j ) ; break ; } } } else if ( arr [ i ] < 0 && i % 2 == 0 ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] >= 0 && j % 2 == 1 ) { swap ( arr , i , j ) ; break ; } } } } printArray ( arr , n ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int largest ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; return arr [ n - 1 ] ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 324 , 45 , 90 , 9808 } ; int n = arr . length ; System . out . println ( largest ( arr , n ) ) ; } }
import java . util . * ; class GFG { public static double findMean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; } public static double findMedian ( int a [ ] , int n ) { Arrays . sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = a . length ; System . out . println ( " Mean ▁ = ▁ " + findMean ( a , n ) ) ; System . out . println ( " Median ▁ = ▁ " + findMedian ( a , n ) ) ; } }
class GFG { static void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { System . out . printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int largest = second = Integer . MIN_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { largest = Math . max ( largest , arr [ i ] ) ; } for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] != largest ) second = Math . max ( second , arr [ i ] ) ; } if ( second == Integer . MIN_VALUE ) System . out . printf ( " There ▁ is ▁ no ▁ second ▁ " + "largest elementNEW_LINE"); else System . out . printf ( " The ▁ second ▁ largest ▁ " + "element is %dNEW_LINE", second); } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = arr . length ; print2largest ( arr , n ) ; } }
class GFG { public static void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { System . out . print ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } first = second = Integer . MIN_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == Integer . MIN_VALUE ) System . out . print ( " There ▁ is ▁ no ▁ second ▁ largest " + " elementNEW_LINE"); else System . out . print ( " The ▁ second ▁ largest ▁ element " + " ▁ is ▁ " + second ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = arr . length ; print2largest ( arr , n ) ; } }
class MaximumSum { int FindMaxSum ( int arr [ ] , int n ) { int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; int i ; for ( i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } public static void main ( String [ ] args ) { MaximumSum sum = new MaximumSum ( ) ; int arr [ ] = new int [ ] { 5 , 5 , 10 , 100 , 10 , 5 } ; System . out . println ( sum . FindMaxSum ( arr , arr . length ) ) ; } }
import java . io . * ; class GFG { static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; } public static void main ( String [ ] args ) { int a [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = a . length ; int max_sum = maxSubArraySum ( a , n ) ; System . out . println ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + max_sum ) ; } }
import java . util . * ; import java . io . * ; class GFG { static int minJumps ( int arr [ ] , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return Integer . MAX_VALUE ; int min = Integer . MAX_VALUE ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != Integer . MAX_VALUE && jumps + 1 < min ) min = jumps + 1 ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = arr . length ; System . out . print ( " Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ▁ end ▁ is ▁ " + minJumps ( arr , 0 , n - 1 ) ) ; } }
class GFG { static int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } return ( end - start + 1 ) ; } public static void main ( String [ ] args ) { int a [ ] = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = a . length ; System . out . println ( maxSubArraySum ( a , n ) ) ; } }
import java . util . Arrays ; class GFG { static boolean sortedAfterSwap ( int A [ ] , boolean B [ ] , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Arrays . sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; boolean B [ ] = { false , true , true , true , false } ; int n = A . length ; if ( sortedAfterSwap ( A , B , n ) ) { System . out . println ( " A ▁ can ▁ be ▁ sorted " ) ; } else { System . out . println ( " A ▁ can ▁ not ▁ be ▁ sorted " ) ; } } }
import java . io . * ; import java . util . * ; class GFG { static int findNumberOfTriangles ( int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] > arr [ k ] && arr [ i ] + arr [ k ] > arr [ j ] && arr [ k ] + arr [ j ] > arr [ i ] ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = arr . length ; System . out . println ( " Total ▁ number ▁ of ▁ triangles ▁ possible ▁ is ▁ " + findNumberOfTriangles ( arr , size ) ) ; } }
import java . io . * ; import java . util . * ; class CountTriangles { static int findNumberOfTriangles ( int arr [ ] ) { int n = arr . length ; Arrays . sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; System . out . println ( " Total ▁ number ▁ of ▁ triangles ▁ is ▁ " + findNumberOfTriangles ( arr ) ) ; } }
class EquilibriumIndex { int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { EquilibriumIndex equi = new EquilibriumIndex ( ) ; int arr [ ] = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; int arr_size = arr . length ; System . out . println ( equi . equilibrium ( arr , arr_size ) ) ; } }
class Main { static int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = arr . length ; int x = 3 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) System . out . println ( " Ceiling ▁ of ▁ " + x + " ▁ doesn ' t ▁ exist ▁ in ▁ array " ) ; else System . out . println ( " ceiling ▁ of ▁ " + x + " ▁ is ▁ " + arr [ index ] ) ; } }
class MajorityElement { int findCandidate ( int a [ ] , int size ) { int maj_index = 0 , count = 1 ; int i ; for ( i = 1 ; i < size ; i ++ ) { if ( a [ maj_index ] == a [ i ] ) count ++ ; else count -- ; if ( count == 0 ) { maj_index = i ; count = 1 ; } } return a [ maj_index ] ; } boolean isMajority ( int a [ ] , int size , int cand ) { int i , count = 0 ; for ( i = 0 ; i < size ; i ++ ) { if ( a [ i ] == cand ) count ++ ; } if ( count > size / 2 ) return true ; else return false ; } void printMajority ( int a [ ] , int size ) { int cand = findCandidate ( a , size ) ; if ( isMajority ( a , size , cand ) ) System . out . println ( " ▁ " + cand + " ▁ " ) ; else System . out . println ( " No ▁ Majority ▁ Element " ) ; } public static void main ( String [ ] args ) { MajorityElement majorelement = new MajorityElement ( ) ; int a [ ] = new int [ ] { 1 , 3 , 3 , 1 , 2 } ; int size = a . length ; majorelement . printMajority ( a , size ) ; } }
class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int findRoot ( pair arr [ ] , int n ) { int root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { root += ( arr [ i ] . first - arr [ i ] . second ) ; } return root ; } public static void main ( String [ ] args ) { pair arr [ ] = { new pair ( 1 , 5 ) , new pair ( 2 , 0 ) , new pair ( 3 , 0 ) , new pair ( 4 , 0 ) , new pair ( 5 , 5 ) , new pair ( 6 , 5 ) } ; int n = arr . length ; System . out . printf ( "%dNEW_LINE", findRoot(arr, n)); } }
class BinaryTree { void fillDepth ( int parent [ ] , int i , int depth [ ] ) { if ( depth [ i ] != 0 ) { return ; } if ( parent [ i ] == - 1 ) { depth [ i ] = 1 ; return ; } if ( depth [ parent [ i ] ] == 0 ) { fillDepth ( parent , parent [ i ] , depth ) ; } depth [ i ] = depth [ parent [ i ] ] + 1 ; } int findHeight ( int parent [ ] , int n ) { int depth [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { depth [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { fillDepth ( parent , i , depth ) ; } int ht = depth [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( ht < depth [ i ] ) { ht = depth [ i ] ; } } return ht ; } public static void main ( String args [ ] ) { BinaryTree tree = new BinaryTree ( ) ; int parent [ ] = new int [ ] { - 1 , 0 , 0 , 1 , 1 , 3 , 5 } ; int n = parent . length ; System . out . println ( " Height ▁ is ▁ " + tree . findHeight ( parent , n ) ) ; } }
import java . io . * ; class GFG { public void getPostOrderBST ( int pre [ ] ) { int pivotPoint = 0 ; for ( int i = 1 ; i < pre . length ; i ++ ) { if ( pre [ 0 ] <= pre [ i ] ) { pivotPoint = i ; break ; } } for ( int i = pivotPoint - 1 ; i > 0 ; i -- ) { System . out . print ( pre [ i ] + " ▁ " ) ; } for ( int i = pre . length - 1 ; i >= pivotPoint ; i -- ) { System . out . print ( pre [ i ] + " ▁ " ) ; } System . out . print ( pre [ 0 ] ) ; }
class Node { int data ; Node left , right ; public Node ( int item ) { data = item ; left = right = null ; } } public class BinaryTree { Node root ; int minimumDepth ( ) { return minimumDepth ( root ) ; } int minimumDepth ( Node root ) { if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return 1 ; if ( root . left == null ) return minimumDepth ( root . right ) + 1 ; if ( root . right == null ) return minimumDepth ( root . left ) + 1 ; return Math . min ( minimumDepth ( root . left ) , minimumDepth ( root . right ) ) + 1 ; } public static void main ( String args [ ] ) { BinaryTree tree = new BinaryTree ( ) ; tree . root = new Node ( 1 ) ; tree . root . left = new Node ( 2 ) ; tree . root . right = new Node ( 3 ) ; tree . root . left . left = new Node ( 4 ) ; tree . root . left . right = new Node ( 5 ) ; System . out . println ( " The ▁ minimum ▁ depth ▁ of ▁ " + " binary ▁ tree ▁ is ▁ : ▁ " + tree . minimumDepth ( ) ) ; } }
if ( inMST [ v ] == false && key [ v ] > weight ) { key [ v ] = weight ; pq . add ( new Pair < Integer , Integer > ( key [ v ] , v ) ) ; parent [ v ] = u ; }
import java . io . * ; class GFG { static int size = 4 ; static boolean checkStar ( int mat [ ] [ ] ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] == 1 ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } } ; if ( checkStar ( mat ) ) System . out . print ( " Star ▁ Graph " ) ; else System . out . print ( " Not ▁ a ▁ Star ▁ Graph " ) ; } }
class GfG { static class Node { int data ; Node left , right ; } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . right = null ; temp . left = null ; return temp ; } static Node KthLargestUsingMorrisTraversal ( Node root , int k ) { Node curr = root ; Node Klargest = null ; int count = 0 ; while ( curr != null ) { if ( curr . right == null ) { if ( ++ count == k ) Klargest = curr ; curr = curr . left ; } else { Node succ = curr . right ; while ( succ . left != null && succ . left != curr ) succ = succ . left ; if ( succ . left == null ) { succ . left = curr ; curr = curr . right ; } else { succ . left = null ; if ( ++ count == k ) Klargest = curr ; curr = curr . left ; } } } return Klargest ; } public static void main ( String [ ] args ) { Node root = newNode ( 4 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 7 ) ; root . left . left = newNode ( 1 ) ; root . left . right = newNode ( 3 ) ; root . right . left = newNode ( 6 ) ; root . right . right = newNode ( 10 ) ; System . out . println ( " Finding ▁ K - th ▁ largest ▁ Node ▁ in ▁ BST ▁ : ▁ " + KthLargestUsingMorrisTraversal ( root , 2 ) . data ) ; } }
import java . util . * ; public class TreeNode { int val ; TreeNode left ; TreeNode right ; TreeNode ( int x ) { val = x ; } } class BinaryTree { static Set < TreeNode > set = new HashSet < > ( ) ; static Stack < TreeNode > stack = new Stack < > ( ) ; public TreeNode buildTree ( int [ ] preorder , int [ ] inorder ) { TreeNode root = null ; for ( int pre = 0 , in = 0 ; pre < preorder . length ; ) { TreeNode node = null ; do { node = new TreeNode ( preorder [ pre ] ) ; if ( root == null ) { root = node ; } if ( ! stack . isEmpty ( ) ) { if ( set . contains ( stack . peek ( ) ) ) { set . remove ( stack . peek ( ) ) ; stack . pop ( ) . right = node ; } else { stack . peek ( ) . left = node ; } } stack . push ( node ) ; } while ( preorder [ pre ++ ] != inorder [ in ] && pre < preorder . length ) ; node = null ; while ( ! stack . isEmpty ( ) && in < inorder . length && stack . peek ( ) . val == inorder [ in ] ) { node = stack . pop ( ) ; in ++ ; } if ( node != null ) { set . add ( node ) ; stack . push ( node ) ; } } return root ; } void printInorder ( TreeNode node ) { if ( node == null ) return ; printInorder ( node . left ) ; System . out . print ( node . val + " ▁ " ) ; printInorder ( node . right ) ; } public static void main ( String args [ ] ) { BinaryTree tree = new BinaryTree ( ) ; int in [ ] = new int [ ] { 9 , 8 , 4 , 2 , 10 , 5 , 10 , 1 , 6 , 3 , 13 , 12 , 7 } ; int pre [ ] = new int [ ] { 1 , 2 , 4 , 8 , 9 , 5 , 10 , 10 , 3 , 6 , 7 , 12 , 13 } ; int len = in . length ; TreeNode root = tree . buildTree ( pre , in ) ; tree . printInorder ( root ) ; } }
class Solution { static class Node { Node left , right ; int data ; } static Node createNode ( int x ) { Node p = new Node ( ) ; p . data = x ; p . left = p . right = null ; return p ; } static void insertNode ( Node root , int x ) { Node p = root , q = null ; while ( p != null ) { q = p ; if ( p . data < x ) p = p . right ; else p = p . left ; } if ( q == null ) p = createNode ( x ) ; else { if ( q . data < x ) q . right = createNode ( x ) ; else q . left = createNode ( x ) ; } } static int maxelpath ( Node q , int x ) { Node p = q ; int mx = - 1 ; while ( p . data != x ) { if ( p . data > x ) { mx = Math . max ( mx , p . data ) ; p = p . left ; } else { mx = Math . max ( mx , p . data ) ; p = p . right ; } } return Math . max ( mx , x ) ; } static int maximumElement ( Node root , int x , int y ) { Node p = root ; while ( ( x < p . data && y < p . data ) || ( x > p . data && y > p . data ) ) { if ( x < p . data && y < p . data ) p = p . left ; else if ( x > p . data && y > p . data ) p = p . right ; } return Math . max ( maxelpath ( p , x ) , maxelpath ( p , y ) ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 18 , 36 , 9 , 6 , 12 , 10 , 1 , 8 } ; int a = 1 , b = 10 ; int n = arr . length ; Node root = createNode ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) insertNode ( root , arr [ i ] ) ; System . out . println ( maximumElement ( root , a , b ) ) ; } }
class GFG { static int i = 0 ; static boolean isLeaf ( int pre [ ] , int n , int min , int max ) { if ( i >= n ) { return false ; } if ( pre [ i ] > min && pre [ i ] < max ) { i ++ ; boolean left = isLeaf ( pre , n , min , pre [ i - 1 ] ) ; boolean right = isLeaf ( pre , n , pre [ i - 1 ] , max ) ; if ( ! left && ! right ) { System . out . print ( pre [ i - 1 ] + " ▁ " ) ; } return true ; } return false ; } static void printLeaves ( int preorder [ ] , int n ) { isLeaf ( preorder , n , Integer . MIN_VALUE , Integer . MAX_VALUE ) ; } public static void main ( String [ ] args ) { int preorder [ ] = { 890 , 325 , 290 , 530 , 965 } ; int n = preorder . length ; printLeaves ( preorder , n ) ; } }
import java . io . * ; public class Interchange { static void interchangeFirstLast ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } public static void main ( String args [ ] ) throws IOException { int m [ ] [ ] = { { 8 , 9 , 7 , 6 } , { 4 , 7 , 6 , 5 } , { 3 , 2 , 1 , 8 } , { 9 , 9 , 7 , 7 } } ; interchangeFirstLast ( m ) ; for ( int i = 0 ; i < m . length ; i ++ ) { for ( int j = 0 ; j < m [ 0 ] . length ; j ++ ) System . out . print ( m [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } }
class Node { int data ; Node left , right ; public Node ( int data ) { this . data = data ; left = right = null ; } } class BinaryTree { Node buildUtil ( int in [ ] , int post [ ] , int inStrt , int inEnd , int postStrt , int postEnd ) { if ( inStrt > inEnd ) return null ; Node node = new Node ( post [ postEnd ] ) ; if ( inStrt == inEnd ) return node ; int iIndex = search ( in , inStrt , inEnd , node . data ) ; node . left = buildUtil ( in , post , inStrt , iIndex - 1 , postStrt , postStrt - inStrt + iIndex - 1 ) ; node . right = buildUtil ( in , post , iIndex + 1 , inEnd , postEnd - inEnd + iIndex , postEnd - 1 ) ; return node ; } int search ( int arr [ ] , int strt , int end , int value ) { int i ; for ( i = strt ; i <= end ; i ++ ) { if ( arr [ i ] == value ) break ; } return i ; } void preOrder ( Node node ) { if ( node == null ) return ; System . out . print ( node . data + " ▁ " ) ; preOrder ( node . left ) ; preOrder ( node . right ) ; } public static void main ( String [ ] args ) { BinaryTree tree = new BinaryTree ( ) ; int in [ ] = new int [ ] { 4 , 8 , 2 , 5 , 1 , 6 , 3 , 7 } ; int post [ ] = new int [ ] { 8 , 4 , 5 , 2 , 6 , 7 , 3 , 1 } ; int n = in . length ; Node root = tree . buildUtil ( in , post , 0 , n - 1 , 0 , n - 1 ) ; System . out . println ( " Preorder ▁ of ▁ the ▁ constructed ▁ tree ▁ : ▁ " ) ; tree . preOrder ( root ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int cola = 2 , rowa = 3 , colb = 3 , rowb = 2 ; static void Kroneckerproduct ( int A [ ] [ ] , int B [ ] [ ] ) { int [ ] [ ] C = new int [ rowa * rowb ] [ cola * colb ] ; for ( int i = 0 ; i < rowa ; i ++ ) { for ( int k = 0 ; k < rowb ; k ++ ) { for ( int j = 0 ; j < cola ; j ++ ) { for ( int l = 0 ; l < colb ; l ++ ) { C [ i + l + 1 ] [ j + k + 1 ] = A [ i ] [ j ] * B [ k ] [ l ] ; System . out . print ( C [ i + l + 1 ] [ j + k + 1 ] + " ▁ " ) ; } } System . out . println ( ) ; } } } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 2 } , { 3 , 4 } , { 1 , 0 } } ; int B [ ] [ ] = { { 0 , 5 , 2 } , { 6 , 7 , 3 } } ; Kroneckerproduct ( A , B ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; } public static void main ( String argc [ ] ) { int n = 4 , k = 7 ; int freq = find ( n , k ) ; if ( freq < 0 ) System . out . print ( " ▁ element " + " not exist NEW_LINE "); else System . out . print ( " ▁ Frequency " + " ▁ of ▁ " + k + " ▁ is ▁ " + freq + "NEW_LINE"); } }
class GFG { static int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) System . out . print ( 1 + " ▁ " ) ; else System . out . print ( 0 + " ▁ " ) ; } System . out . println ( ) ; } return 0 ; } public static void main ( String args [ ] ) { int size = 5 ; identity ( size ) ; } }
import java . util . * ; class GFG { static int MAX = 100 ; static void imageSwap ( int mat [ ] [ ] , int n ) { int row = 0 ; for ( int j = 0 ; j < n ; j ++ ) { Stack < Integer > s = new Stack < > ( ) ; int i = row , k = j ; while ( i < n && k >= 0 ) { s . push ( mat [ i ++ ] [ k -- ] ) ; } i = row ; k = j ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . peek ( ) ; s . pop ( ) ; } } int column = n - 1 ; for ( int j = 1 ; j < n ; j ++ ) { Stack < Integer > s = new Stack < > ( ) ; int i = j , k = column ; while ( i < n && k >= 0 ) { s . push ( mat [ i ++ ] [ k -- ] ) ; } i = j ; k = column ; while ( i < n && k >= 0 ) { mat [ i ++ ] [ k -- ] = s . peek ( ) ; s . pop ( ) ; } } } static void printMatrix ( int mat [ ] [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } System . out . println ( " " ) ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int n = 4 ; imageSwap ( mat , n ) ; printMatrix ( mat , n ) ; } }
import java . io . * ; class GFG { static int R = 4 ; static int C = 4 ; static int getTotalCoverageOfMatrix ( int [ ] [ ] mat ) { int res = 0 ; for ( int i = 0 ; i < R ; i ++ ) { boolean isOne = false ; for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int j = C - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } for ( int j = 0 ; j < C ; j ++ ) { boolean isOne = false ; for ( int i = 0 ; i < R ; i ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int i = R - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } return res ; } static public void main ( String [ ] args ) { int [ ] [ ] mat = { { 0 , 0 , 0 , 0 } , { 1 , 0 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 } } ; System . out . println ( getTotalCoverageOfMatrix ( mat ) ) ; } }
import java . io . * ; class GFG { static int R = 3 ; static int C = 6 ; static void spiralPrint ( int m , int n , int [ ] [ ] a , int c ) { int i , k = 0 , l = 0 ; int count = 0 ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { count ++ ; if ( count == c ) System . out . println ( a [ k ] [ i ] + " ▁ " ) ; } k ++ ; for ( i = k ; i < m ; ++ i ) { count ++ ; if ( count == c ) System . out . println ( a [ i ] [ n - 1 ] + " ▁ " ) ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) { count ++ ; if ( count == c ) System . out . println ( a [ m - 1 ] [ i ] + " ▁ " ) ; } m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { count ++ ; if ( count == c ) System . out . println ( a [ i ] [ l ] + " ▁ " ) ; } l ++ ; } } } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 1 , 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 , 17 , 18 } } ; int k = 17 ; spiralPrint ( R , C , a , k ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int countNegative ( int M [ ] [ ] , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( M [ i ] [ j ] < 0 ) count += 1 ; else break ; } } return count ; } public static void main ( String [ ] args ) { int M [ ] [ ] = { { - 3 , - 2 , - 1 , 1 } , { - 2 , 2 , 3 , 4 } , { 4 , 5 , 7 , 8 } } ; System . out . println ( countNegative ( M , 3 , 4 ) ) ; } }
import java . io . * ; class GFG { static int N = 10 ; static int findLargestPlus ( int mat [ ] [ ] ) { int left [ ] [ ] = new int [ N ] [ N ] ; int right [ ] [ ] = new int [ N ] [ N ] ; int top [ ] [ ] = new int [ N ] [ N ] ; int bottom [ ] [ ] = new int [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . min ( Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 } , { 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 } , { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 } } ; System . out . println ( findLargestPlus ( mat ) ) ; } }
class GFG { static final int N = 4 ; static void add ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] + B [ i ] [ j ] ; } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ ] [ ] = new int [ N ] [ N ] ; int i , j ; add ( A , B , C ) ; System . out . print ( "Result matrix is NEW_LINE"); for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) System . out . print ( C [ i ] [ j ] + " ▁ " ) ; System . out . print ( "NEW_LINE"); } } }
class GFG { static final int N = 4 ; static void subtract ( int A [ ] [ ] , int B [ ] [ ] , int C [ ] [ ] ) { int i , j ; for ( i = 0 ; i < N ; i ++ ) for ( j = 0 ; j < N ; j ++ ) C [ i ] [ j ] = A [ i ] [ j ] - B [ i ] [ j ] ; } public static void main ( String [ ] args ) { int A [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int B [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int C [ ] [ ] = new int [ N ] [ N ] ; int i , j ; subtract ( A , B , C ) ; System . out . print ( "Result matrix is NEW_LINE"); for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) System . out . print ( C [ i ] [ j ] + " ▁ " ) ; System . out . print ( "NEW_LINE"); } } }
import java . util . * ; import java . lang . * ; import java . io . * ; class PeakElement { static int findPeakUtil ( int arr [ ] , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; } static int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = arr . length ; System . out . println ( " Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ " + findPeak ( arr , n ) ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int i , j ; System . out . println ( " Repeated ▁ Elements ▁ are ▁ : " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) System . out . print ( arr [ i ] + " ▁ " ) ; } } } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = ( int ) Math . sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; System . out . println ( " The ▁ two ▁ repeating ▁ elements ▁ are ▁ : " ) ; System . out . print ( x + " ▁ " + y ) ; } int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
class RepeatElement { void printRepeating ( int arr [ ] , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_bit_no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_bit_no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } System . out . println ( " The ▁ two ▁ reppeated ▁ elements ▁ are ▁ : " ) ; System . out . println ( x + " ▁ " + y ) ; } public static void main ( String [ ] args ) { RepeatElement repeat = new RepeatElement ( ) ; int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . length ; repeat . printRepeating ( arr , arr_size ) ; } }
class Main { static int linearSearch ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == i ) return i ; } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { - 10 , - 1 , 0 , 3 , 10 , 11 , 30 , 50 , 100 } ; int n = arr . length ; System . out . println ( " Fixed ▁ Point ▁ is ▁ " + linearSearch ( arr , n ) ) ; } }
class SubarraySum { int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { int p = i - 1 ; System . out . println ( " Sum ▁ found ▁ between ▁ indexes ▁ " + start + " ▁ and ▁ " + p ) ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } System . out . println ( " No ▁ subarray ▁ found " ) ; return 0 ; } public static void main ( String [ ] args ) { SubarraySum arraysum = new SubarraySum ( ) ; int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = arr . length ; int sum = 23 ; arraysum . subArraySum ( arr , n , sum ) ; } }
import java . util . Arrays ; class GFG { static int maximum ( int a , int b , int c ) { return Math . max ( Math . max ( a , b ) , c ) ; } static int minimum ( int a , int b , int c ) { return Math . min ( Math . min ( a , b ) , c ) ; } static void smallestDifferenceTriplet ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int n ) { Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; Arrays . sort ( arr3 ) ; int res_min = 0 , res_max = 0 , res_mid = 0 ; int i = 0 , j = 0 , k = 0 ; int diff = 2147483647 ; while ( i < n && j < n && k < n ) { int sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; int max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; int min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; if ( min == arr1 [ i ] ) i ++ ; else if ( min == arr2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_max = max ; res_mid = sum - ( max + min ) ; res_min = min ; } } System . out . print ( res_max + " , ▁ " + res_mid + " , ▁ " + res_min ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 5 , 2 , 8 } ; int arr2 [ ] = { 10 , 7 , 12 } ; int arr3 [ ] = { 9 , 14 , 6 } ; int n = arr1 . length ; smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) ; } }
class FindTriplet { boolean find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { System . out . print ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ j ] + " , ▁ " + A [ k ] ) ; return true ; } } } } return false ; } public static void main ( String [ ] args ) { FindTriplet triplet = new FindTriplet ( ) ; int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = A . length ; triplet . find3Numbers ( A , arr_size , sum ) ; } }
class Test { static int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; static void subArray ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) System . out . print ( arr [ k ] + " ▁ " ) ; } } } public static void main ( String [ ] args ) { System . out . println ( " All ▁ Non - empty ▁ Subarrays " ) ; subArray ( arr . length ) ; } }
class AreConsecutive { boolean areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { boolean visited [ ] = new boolean [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; } int getMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } public static void main ( String [ ] args ) { AreConsecutive consecutive = new AreConsecutive ( ) ; int arr [ ] = { 5 , 4 , 2 , 3 , 1 , 6 } ; int n = arr . length ; if ( consecutive . areConsecutive ( arr , n ) == true ) System . out . println ( " Array ▁ elements ▁ are ▁ consecutive " ) ; else System . out . println ( " Array ▁ elements ▁ are ▁ not ▁ consecutive " ) ; } }
class GFG { public static int search ( int arr [ ] , int x ) { int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int result = search ( arr , x ) ; if ( result == - 1 ) System . out . print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; else System . out . print ( " Element ▁ is ▁ present ▁ at ▁ index ▁ " + result ) ; } }
class BinarySearch { int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } public static void main ( String args [ ] ) { BinarySearch ob = new BinarySearch ( ) ; int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = arr . length ; int x = 10 ; int result = ob . binarySearch ( arr , 0 , n - 1 , x ) ; if ( result == - 1 ) System . out . println ( " Element ▁ not ▁ present " ) ; else System . out . println ( " Element ▁ found ▁ at ▁ index ▁ " + result ) ; } }
class CountingSort { void sort ( char arr [ ] ) { int n = arr . length ; char output [ ] = new char [ n ] ; int count [ ] = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; ++ i ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) ++ count [ arr [ i ] ] ; for ( int i = 1 ; i <= 255 ; ++ i ) count [ i ] += count [ i - 1 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] ] - 1 ] = arr [ i ] ; -- count [ arr [ i ] ] ; } for ( int i = 0 ; i < n ; ++ i ) arr [ i ] = output [ i ] ; } public static void main ( String args [ ] ) { CountingSort ob = new CountingSort ( ) ; char arr [ ] = { ' g ' , ' e ' , ' e ' , ' k ' , ' s ' , ' f ' , ' o ' , ' r ' , ' g ' , ' e ' , ' e ' , ' k ' , ' s ' } ; ob . sort ( arr ) ; System . out . print ( " Sorted ▁ character ▁ array ▁ is ▁ " ) ; for ( int i = 0 ; i < arr . length ; ++ i ) System . out . print ( arr [ i ] ) ; } }
import java . util . * ; class GFG { static void countSort ( int [ ] arr ) { int max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int min = Arrays . stream ( arr ) . min ( ) . getAsInt ( ) ; int range = max - min + 1 ; int count [ ] = new int [ range ] ; int output [ ] = new int [ arr . length ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { count [ arr [ i ] - min ] ++ ; } for ( int i = 1 ; i < count . length ; i ++ ) { count [ i ] += count [ i - 1 ] ; } for ( int i = arr . length - 1 ; i >= 0 ; i -- ) { output [ count [ arr [ i ] - min ] - 1 ] = arr [ i ] ; count [ arr [ i ] - min ] -- ; } for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = output [ i ] ; } } static void printArray ( int [ ] arr ) { for ( int i = 0 ; i < arr . length ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { - 5 , - 10 , 0 , - 3 , 8 , 5 , - 1 , 10 } ; countSort ( arr ) ; printArray ( arr ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static void cycleSort ( int arr [ ] , int n ) { int writes = 0 ; for ( int cycle_start = 0 ; cycle_start <= n - 2 ; cycle_start ++ ) { int item = arr [ cycle_start ] ; int pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos ++ ; if ( pos == cycle_start ) continue ; while ( item == arr [ pos ] ) pos += 1 ; if ( pos != cycle_start ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } while ( pos != cycle_start ) { pos = cycle_start ; for ( int i = cycle_start + 1 ; i < n ; i ++ ) if ( arr [ i ] < item ) pos += 1 ; while ( item == arr [ pos ] ) pos += 1 ; if ( item != arr [ pos ] ) { int temp = item ; item = arr [ pos ] ; arr [ pos ] = temp ; writes ++ ; } } } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 8 , 3 , 9 , 10 , 10 , 2 , 4 } ; int n = arr . length ; cycleSort ( arr , n ) ; System . out . println ( " After ▁ sort ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class ClosestPair { void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) { int diff = Integer . MAX_VALUE ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } System . out . print ( " The ▁ closest ▁ pair ▁ is ▁ [ " + ar1 [ res_l ] + " , ▁ " + ar2 [ res_r ] + " ] " ) ; } public static void main ( String args [ ] ) { ClosestPair ob = new ClosestPair ( ) ; int ar1 [ ] = { 1 , 4 , 5 , 7 } ; int ar2 [ ] = { 10 , 20 , 30 , 40 } ; int m = ar1 . length ; int n = ar2 . length ; int x = 38 ; ob . printClosest ( ar1 , ar2 , m , n , x ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class ActivitySelection { public static void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; System . out . print ( " Following ▁ activities ▁ are ▁ selected ▁ : ▁ n " ) ; i = 0 ; System . out . print ( i + " ▁ " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { System . out . print ( j + " ▁ " ) ; i = j ; } } } public static void main ( String [ ] args ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = s . length ; printMaxActivities ( s , f , n ) ; } }
import java . util . * ; class GFG { static int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; if ( k == 0 k == n ) return 1 ; return binomialCoeff ( n - 1 , k - 1 ) + binomialCoeff ( n - 1 , k ) ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . printf ( " Value ▁ of ▁ C ( % d , ▁ % d ) ▁ is ▁ % d ▁ " , n , k , binomialCoeff ( n , k ) ) ; } }
class GFG { static int getCount ( char keypad [ ] [ ] , int n ) { if ( keypad == null n <= 0 ) return 0 ; if ( n == 1 ) return 10 ; int row [ ] = { 0 , 0 , - 1 , 0 , 1 } ; int col [ ] = { 0 , - 1 , 0 , 1 , 0 } ; int [ ] [ ] count = new int [ 10 ] [ n + 1 ] ; int i = 0 , j = 0 , k = 0 , move = 0 , ro = 0 , co = 0 , num = 0 ; int nextNum = 0 , totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) { count [ i ] [ 0 ] = 0 ; count [ i ] [ 1 ] = 1 ; } for ( k = 2 ; k <= n ; k ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { if ( keypad [ i ] [ j ] != ' * ' && keypad [ i ] [ j ] != ' # ' ) { num = keypad [ i ] [ j ] - '0' ; count [ num ] [ k ] = 0 ; for ( move = 0 ; move < 5 ; move ++ ) { ro = i + row [ move ] ; co = j + col [ move ] ; if ( ro >= 0 && ro <= 3 && co >= 0 && co <= 2 && keypad [ ro ] [ co ] != ' * ' && keypad [ ro ] [ co ] != ' # ' ) { nextNum = keypad [ ro ] [ co ] - '0' ; count [ num ] [ k ] += count [ nextNum ] [ k - 1 ] ; } } } } } } totalCount = 0 ; for ( i = 0 ; i <= 9 ; i ++ ) totalCount += count [ i ] [ n ] ; return totalCount ; } public static void main ( String [ ] args ) { char keypad [ ] [ ] = { { '1' , '2' , '3' } , { '4' , '5' , '6' } , { '7' , '8' , '9' } , { ' * ' , '0' , ' # ' } } ; System . out . printf ( "Count for numbers of length %d: %dNEW_LINE", 1, getCount ( keypad , 1 ) ) ; System . out . printf ( "Count for numbers of length %d: %dNEW_LINE", 2, getCount ( keypad , 2 ) ) ; System . out . printf ( "Count for numbers of length %d: %dNEW_LINE", 3, getCount ( keypad , 3 ) ) ; System . out . printf ( "Count for numbers of length %d: %dNEW_LINE", 4, getCount ( keypad , 4 ) ) ; System . out . printf ( "Count for numbers of length %d: %dNEW_LINE", 5, getCount ( keypad , 5 ) ) ; } }
class sum_dig { static int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( sum == 0 ) return 1 ; int ans = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } static int finalCount ( int n , int sum ) { int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } public static void main ( String args [ ] ) { int n = 2 , sum = 5 ; System . out . println ( finalCount ( n , sum ) ) ; } }
public class GFG { private static void findCount ( int n , int sum ) { int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i < end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int n = 3 ; int sum = 5 ; findCount ( n , sum ) ; } }
class squares { static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; } public static void main ( String args [ ] ) { System . out . println ( getMinSquares ( 6 ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int sumOfDigitsFrom1ToNUtil ( int n , int a [ ] ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . log10 ( n ) ) ; int p = ( int ) ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToNUtil ( n % p , a ) ) ; } static int sumOfDigitsFrom1ToN ( int n ) { int d = ( int ) ( Math . log10 ( n ) ) ; int a [ ] = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; return sumOfDigitsFrom1ToNUtil ( n , a ) ; } public static void main ( String args [ ] ) { int n = 328 ; System . out . println ( " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ " + " from ▁ 1 ▁ to ▁ " + n + " ▁ is ▁ " + sumOfDigitsFrom1ToN ( n ) ) ; } }
import java . io . * ; class GFG { static int findoptimal ( int N ) { if ( N <= 6 ) return N ; int max = 0 ; int b ; for ( b = N - 3 ; b >= 1 ; b -- ) { int curr = ( N - b - 1 ) * findoptimal ( b ) ; if ( curr > max ) max = curr ; } return max ; } public static void main ( String [ ] args ) { int N ; for ( N = 1 ; N <= 20 ; N ++ ) System . out . println ( " Maximum ▁ Number ▁ of ▁ A ' s ▁ with ▁ keystrokes ▁ is ▁ " + N + findoptimal ( N ) ) ; } }
class GFG { static void search ( String pat , String txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt . charAt ( i + j ) != pat . charAt ( j ) ) break ; if ( j == M ) { System . out . println ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } public static void main ( String [ ] args ) { String txt = " ABCEABCDABCEABCD " ; String pat = " ABCD " ; search ( pat , txt ) ; } }
class GFG { static float power ( float x , int y ) { float temp ; if ( y == 0 ) return 1 ; temp = power ( x , y / 2 ) ; if ( y % 2 == 0 ) return temp * temp ; else { if ( y > 0 ) return x * temp * temp ; else return ( temp * temp ) / x ; } } public static void main ( String [ ] args ) { float x = 2 ; int y = - 3 ; System . out . printf ( " % f " , power ( x , y ) ) ; } }
class Main { static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } public static void main ( String [ ] args ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = ar1 . length ; int n2 = ar2 . length ; if ( n1 == n2 ) System . out . println ( " Median ▁ is ▁ " + getMedian ( ar1 , ar2 , n1 ) ) ; else System . out . println ( " arrays ▁ are ▁ of ▁ unequal ▁ size " ) ; } }
class GFG { static float squareRoot ( float n ) { float x = n ; float y = 1 ; double e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } public static void main ( String [ ] args ) { int n = 50 ; System . out . printf ( " Square ▁ root ▁ of ▁ " + n + " ▁ is ▁ " + squareRoot ( n ) ) ; } }
class GFG { static int multiply ( int x , int y ) { if ( y == 0 ) return 0 ; if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; if ( y < 0 ) return - multiply ( x , - y ) ; return - 1 ; } public static void main ( String [ ] args ) { System . out . print ( "NEW_LINE" + multiply(5, -11)); } }
import java . io . * ; class GFG { static int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; } public static void main ( String [ ] args ) { System . out . println ( pow ( 5 , 3 ) ) ; } }
import java . io . * ; class GFG { static int multiply ( int x , int y ) { if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; } static int pow ( int a , int b ) { if ( b > 0 ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; } public static void main ( String [ ] args ) { System . out . println ( pow ( 5 , 3 ) ) ; } }
class GFG { static int sum , n ; static float getAvg ( int x ) { sum += x ; return ( ( ( float ) sum ) / ++ n ) ; } static void streamAvg ( float [ ] arr , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( ( int ) arr [ i ] ) ; System . out . println ( " Average ▁ of ▁ " + ( i + 1 ) + " ▁ numbers ▁ is ▁ " + avg ) ; } return ; } public static void main ( String [ ] args ) { float [ ] arr = new float [ ] { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; streamAvg ( arr , n ) ; } }
import java . io . * ; class GFG { static int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; } public static void main ( String [ ] args ) { int n = 578 ; System . out . println ( count ( n ) ) ; } }
import java . io . * ; class GFG { public static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + " ▁ " ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 5 ; printPascal ( n ) ; } }
import java . io . * ; class Combination { static void printCombination ( int arr [ ] , int n , int r ) { int data [ ] = new int [ r ] ; combinationUtil ( arr , data , 0 , n - 1 , 0 , r ) ; } static void combinationUtil ( int arr [ ] , int data [ ] , int start , int end , int index , int r ) { if ( index == r ) { for ( int j = 0 ; j < r ; j ++ ) System . out . print ( data [ j ] + " ▁ " ) ; System . out . println ( " " ) ; return ; } for ( int i = start ; i <= end && end - i + 1 >= r - index ; i ++ ) { data [ index ] = arr [ i ] ; combinationUtil ( arr , data , i + 1 , end , index + 1 , r ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int r = 3 ; int n = arr . length ; printCombination ( arr , n , r ) ; } }
class FindGroups { int findgroups ( int arr [ ] , int n ) { int c [ ] = new int [ ] { 0 , 0 , 0 } ; int i ; int res = 0 ; for ( i = 0 ; i < n ; i ++ ) c [ arr [ i ] % 3 ] ++ ; res += ( ( c [ 0 ] * ( c [ 0 ] - 1 ) ) >> 1 ) ; res += c [ 1 ] * c [ 2 ] ; res += ( c [ 0 ] * ( c [ 0 ] - 1 ) * ( c [ 0 ] - 2 ) ) / 6 ; res += ( c [ 1 ] * ( c [ 1 ] - 1 ) * ( c [ 1 ] - 2 ) ) / 6 ; res += ( ( c [ 2 ] * ( c [ 2 ] - 1 ) * ( c [ 2 ] - 2 ) ) / 6 ) ; res += c [ 0 ] * c [ 1 ] * c [ 2 ] ; return res ; } public static void main ( String [ ] args ) { FindGroups groups = new FindGroups ( ) ; int arr [ ] = { 3 , 6 , 7 , 2 , 9 } ; int n = arr . length ; System . out . println ( " Required ▁ number ▁ of ▁ groups ▁ are ▁ " + groups . findgroups ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) System . out . println ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; } public static void main ( String [ ] args ) { System . out . println ( calcAngle ( 9 , 60 ) + " ▁ degree " ) ; System . out . println ( calcAngle ( 3 , 30 ) + " ▁ degree " ) ; } }
class GFG { static double find ( double p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; } public static void main ( String [ ] args ) { System . out . println ( find ( 0.70 ) ) ; } }
import java . io . * ; class GFG { static int MAX_ITER = 1000000 ; static double func ( double x ) { return ( x * x * x - x * x + 2 ) ; } static void regulaFalsi ( double a , double b ) { if ( func ( a ) * func ( b ) >= 0 ) { System . out . println ( " You ▁ have ▁ not ▁ assumed ▁ right ▁ a ▁ and ▁ b " ) ; } double c = a ; for ( int i = 0 ; i < MAX_ITER ; i ++ ) { c = ( a * func ( b ) - b * func ( a ) ) / ( func ( b ) - func ( a ) ) ; if ( func ( c ) == 0 ) break ; else if ( func ( c ) * func ( a ) < 0 ) b = c ; else a = c ; } System . out . println ( " The ▁ value ▁ of ▁ root ▁ is ▁ : ▁ " + ( int ) c ) ; } public static void main ( String [ ] args ) { double a = - 200 , b = 300 ; regulaFalsi ( a , b ) ; } }
class GFG { static int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; } public static void main ( String [ ] args ) { int res = swapBits ( 28 , 0 , 3 , 2 ) ; System . out . println ( " Result ▁ = ▁ " + res ) ; } }
class GFG { static int fun ( int n ) { return n & ( n - 1 ) ; } public static void main ( String arg [ ] ) { int n = 7 ; System . out . print ( " The ▁ number ▁ after ▁ unsetting ▁ " + " the ▁ rightmost ▁ set ▁ bit ▁ " + fun ( n ) ) ; } }
import java . io . * ; class GFG { static int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } public static void main ( String [ ] args ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) > 0 ) System . out . println ( test_no + " ▁ is ▁ a ▁ power ▁ of ▁ 4" ) ; else System . out . println ( test_no + " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4" ) ; } }
public class AWS { static int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x << y ) ) ; } static int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x << y ) ) ; } public static void main ( String [ ] args ) { int x = 15 ; int y = 6 ; System . out . print ( " Minimum ▁ of ▁ " + x + " ▁ and ▁ " + y + " ▁ is ▁ " ) ; System . out . println ( min ( x , y ) ) ; System . out . print ( " Maximum ▁ of ▁ " + x + " ▁ and ▁ " + y + " ▁ is ▁ " ) ; System . out . println ( max ( x , y ) ) ; } }
import java . io . * ; import java . util . HashMap ; class OddOccurrence { static int getOddOccurrence ( int arr [ ] , int n ) { HashMap < Integer , Integer > hmap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hmap . containsKey ( arr [ i ] ) ) { int val = hmap . get ( arr [ i ] ) ; hmap . put ( arr [ i ] , val + 1 ) ; } else hmap . put ( arr [ i ] , 1 ) ; } for ( Integer a : hmap . keySet ( ) ) { if ( hmap . get ( a ) % 2 != 0 ) return a ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; int n = arr . length ; System . out . println ( getOddOccurrence ( arr , n ) ) ; } }
class GFG { static int [ ] num_to_bits = new int [ ] { 0 , 1 , 1 , 2 , 1 , 2 , 2 , 3 , 1 , 2 , 2 , 3 , 2 , 3 , 3 , 4 } ; static int countSetBitsRec ( int num ) { int nibble = 0 ; if ( 0 == num ) return num_to_bits [ 0 ] ; nibble = num & 0xf ; return num_to_bits [ nibble ] + countSetBitsRec ( num >> 4 ) ; } public static void main ( String [ ] args ) { int num = 31 ; System . out . println ( countSetBitsRec ( num ) ) ; } }
import java . io . * ; class GFG { static int nextPowerOf2 ( int n ) { n -- ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; n ++ ; return n ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }
class GFG { static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; return ( int ) ( Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) == ( int ) ( Math . floor ( ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ) ) ; } public static void main ( String [ ] args ) { if ( isPowerOfTwo ( 31 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( isPowerOfTwo ( 64 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static boolean isPowerOfTwo ( int n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 2 != 0 ) return false ; n = n / 2 ; } return true ; } public static void main ( String args [ ] ) { if ( isPowerOfTwo ( 31 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( isPowerOfTwo ( 64 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { public static int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . log10 ( n & - n ) ) / Math . log10 ( 2 ) ) + 1 ; } public static void main ( String [ ] args ) { int n = 12 ; System . out . println ( getFirstSetBitPos ( n ) ) ; } }
class GFG { static int swapBits ( int x ) { int even_bits = x & 0xAAAAAAAA ; int odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; } public static void main ( String [ ] args ) { int x = 23 ; System . out . println ( swapBits ( x ) ) ; } }
class GFG { static boolean isPowerOfTwo ( int n ) { return n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int count = 0 ; while ( n > 0 ) { n = n >> 1 ; ++ count ; } return count ; } public static void main ( String [ ] args ) { int n = 0 ; int pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 12 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 128 ; pos = findPosition ( n ) ; if ( pos == - 1 ) System . out . println ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else System . out . println ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; } }
import java . io . * ; class NextGreatest { static void nextGreatest ( int arr [ ] ) { int size = arr . length ; int max_from_right = arr [ size - 1 ] ; arr [ size - 1 ] = - 1 ; for ( int i = size - 2 ; i >= 0 ; i -- ) { int temp = arr [ i ] ; arr [ i ] = max_from_right ; if ( max_from_right < temp ) max_from_right = temp ; } } static void printArray ( int arr [ ] ) { for ( int i = 0 ; i < arr . length ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; nextGreatest ( arr ) ; System . out . println ( " The ▁ modified ▁ array : " ) ; printArray ( arr ) ; } }
import java . io . * ; class GFG { public static int maxCircularSum ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int curr_max = a [ 0 ] , max_so_far = a [ 0 ] , curr_min = a [ 0 ] , min_so_far = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = Math . max ( curr_max + a [ i ] , a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; curr_min = Math . min ( curr_min + a [ i ] , a [ i ] ) ; min_so_far = Math . min ( min_so_far , curr_min ) ; } if ( min_so_far == sum ) { return max_so_far ; } return Math . max ( max_so_far , sum - min_so_far ) ; } public static void main ( String [ ] args ) { int a [ ] = { 11 , 10 , - 20 , 5 , - 3 , - 5 , 8 , - 13 , 10 } ; int n = 9 ; System . out . println ( " Maximum ▁ circular ▁ sum ▁ is ▁ " + maxCircularSum ( a , n ) ) ; } }
class MaximumDiffrence { int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; } public static void main ( String [ ] args ) { MaximumDifference maxdif = new MaximumDifference ( ) ; int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; System . out . println ( " Maximum ▁ difference ▁ is ▁ " + maxdif . maxDiff ( arr , 5 ) ) ; } }
class Main { static int findMaximum ( int arr [ ] , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = arr . length ; System . out . println ( " The ▁ maximum ▁ element ▁ is ▁ " + findMaximum ( arr , 0 , n - 1 ) ) ; } }
class gfg { static int findMinSwaps ( int arr [ ] , int n ) { int noOfZeroes [ ] = new int [ n ] ; int i , count = 0 ; noOfZeroes [ n - 1 ] = 1 - arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { noOfZeroes [ i ] = noOfZeroes [ i + 1 ] ; if ( arr [ i ] == 0 ) noOfZeroes [ i ] ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 1 ) count += noOfZeroes [ i ] ; } return count ; } public static void main ( String args [ ] ) { int ar [ ] = { 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; System . out . println ( findMinSwaps ( ar , ar . length ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int minSwapsToSort ( int arr [ ] , int n ) { ArrayList < ArrayList < Integer > > arrPos = new ArrayList < ArrayList < Integer > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { arrPos . add ( new ArrayList < Integer > ( Arrays . asList ( arr [ i ] , i ) ) ) ; } Collections . sort ( arrPos , new Comparator < ArrayList < Integer > > ( ) { @ Override public int compare ( ArrayList < Integer > o1 , ArrayList < Integer > o2 ) { return o1 . get ( 0 ) . compareTo ( o2 . get ( 0 ) ) ; } } ) ; boolean [ ] vis = new boolean [ n ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( vis [ i ] || arrPos . get ( i ) . get ( 1 ) == i ) continue ; int cycle_size = 0 ; int j = i ; while ( ! vis [ j ] ) { vis [ j ] = true ; j = arrPos . get ( j ) . get ( 1 ) ; cycle_size ++ ; } ans += ( cycle_size - 1 ) ; } return ans ; } static int minSwapToMakeArraySame ( int a [ ] , int b [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( b [ i ] , i ) ; } for ( int i = 0 ; i < n ; i ++ ) b [ i ] = mp . get ( a [ i ] ) ; return minSwapsToSort ( b , n ) ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 6 , 4 , 8 } ; int b [ ] = { 4 , 6 , 8 , 3 } ; int n = a . length ; System . out . println ( minSwapToMakeArraySame ( a , b , n ) ) ; } }
import java . util . Arrays ; class Test { static int arr [ ] = new int [ ] { 5 , 1 , 3 , 4 , 7 } ; static int countTriplets ( int n , int sum ) { Arrays . sort ( arr ) ; int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; } public static void main ( String [ ] args ) { int sum = 12 ; System . out . println ( countTriplets ( arr . length , sum ) ) ; } }
import java . io . * ; class GFG { static void printTwoElements ( int arr [ ] , int size ) { int i ; System . out . print ( " The ▁ repeating ▁ element ▁ is ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_val = Math . abs ( arr [ i ] ) ; if ( arr [ abs_val - 1 ] > 0 ) arr [ abs_val - 1 ] = - arr [ abs_val - 1 ] ; else System . out . println ( abs_val ) ; } System . out . print ( " And ▁ the ▁ missing ▁ element ▁ is ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) System . out . println ( i + 1 ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = arr . length ; printTwoElements ( arr , n ) ; } }
import java . util . * ; class Main { static void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " + x + " ▁ & ▁ " + y ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = arr . length ; printTwoOdd ( arr , arr_size ) ; } }
import java . io . * ; class PairDifference { static boolean findPair ( int arr [ ] , int n ) { int size = arr . length ; int i = 0 , j = 1 ; while ( i < size && j < size ) { if ( i != j && arr [ j ] - arr [ i ] == n ) { System . out . print ( " Pair ▁ Found : ▁ " + " ( ▁ " + arr [ i ] + " , ▁ " + arr [ j ] + " ▁ ) " ) ; return true ; } else if ( arr [ j ] - arr [ i ] < n ) j ++ ; else i ++ ; } System . out . print ( " No ▁ such ▁ pair " ) ; return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 8 , 30 , 40 , 100 } ; int n = 60 ; findPair ( arr , n ) ; } }
import java . util . * ; class fourElementWithSum { public static void fourSum ( int X , int [ ] arr , Map < Integer , pair > map ) { int [ ] temp = new int [ arr . length ] ; for ( int i = 0 ; i < temp . length ; i ++ ) temp [ i ] = 0 ; for ( int i = 0 ; i < arr . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < arr . length ; j ++ ) { int curr_sum = arr [ i ] + arr [ j ] ; if ( map . containsKey ( X - curr_sum ) ) { pair p = map . get ( X - curr_sum ) ; if ( p . first != i && p . sec != i && p . first != j && p . sec != j && temp [ p . first ] == 0 && temp [ p . sec ] == 0 && temp [ i ] == 0 && temp [ j ] == 0 ) { System . out . printf ( " % d , % d , % d , % d " , arr [ i ] , arr [ j ] , arr [ p . first ] , arr [ p . sec ] ) ; temp [ p . sec ] = 1 ; temp [ i ] = 1 ; temp [ j ] = 1 ; break ; } } } } } public static Map < Integer , pair > twoSum ( int [ ] nums ) { Map < Integer , pair > map = new HashMap < > ( ) ; for ( int i = 0 ; i < nums . length - 1 ; i ++ ) { for ( int j = i + 1 ; j < nums . length ; j ++ ) { map . put ( nums [ i ] + nums [ j ] , new pair ( i , j ) ) ; } } return map ; } public static class pair { int first , sec ; public pair ( int first , int sec ) { this . first = first ; this . sec = sec ; } } public static void main ( String args [ ] ) { int [ ] arr = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = arr . length ; int X = 91 ; Map < Integer , pair > map = twoSum ( arr ) ; fourSum ( X , arr , map ) ; } }
import java . io . * ; class Deletion { static int deleteElement ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == x ) break ; if ( i < n ) { n = n - 1 ; for ( int j = i ; j < n ; j ++ ) arr [ j ] = arr [ j + 1 ] ; } return n ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int n = arr . length ; int x = 6 ; n = deleteElement ( arr , n , x ) ; System . out . println ( " Modified ▁ array ▁ is " ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
public class MaximumAbsoluteDifference { private static int maxDistance ( int [ ] array ) { int max1 = Integer . MIN_VALUE ; int min1 = Integer . MAX_VALUE ; int max2 = Integer . MIN_VALUE ; int min2 = Integer . MAX_VALUE ; for ( int i = 0 ; i < array . length ; i ++ ) { max1 = Math . max ( max1 , array [ i ] + i ) ; min1 = Math . min ( min1 , array [ i ] + i ) ; max2 = Math . max ( max2 , array [ i ] - i ) ; min2 = Math . min ( min2 , array [ i ] - i ) ; } return Math . max ( max1 - min1 , max2 - min2 ) ; } public static void main ( String [ ] args ) { int [ ] array = { - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 } ; System . out . println ( maxDistance ( array ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class FindClosestNumber { public static int findClosest ( int arr [ ] , int target ) { int n = arr . length ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } public static int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 } ; int target = 11 ; System . out . println ( findClosest ( arr , target ) ) ; } }
class GFG { static class Node { int data ; Node next ; } ; static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " ▁ " ) ; node = node . next ; } System . out . println ( ) ; } static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } static Node insertBeg ( Node head , int val ) { Node temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; } static Node rearrange ( Node head ) { Node even ; Node temp , prev_temp ; Node i , j , k , l , ptr = null ; temp = ( head ) . next ; prev_temp = head ; while ( temp != null ) { Node x = temp . next ; if ( temp . data % 2 != 0 ) { prev_temp . next = x ; temp . next = ( head ) ; ( head ) = temp ; } else { prev_temp = temp ; } temp = x ; } temp = ( head ) . next ; prev_temp = ( head ) ; while ( temp != null && temp . data % 2 != 0 ) { prev_temp = temp ; temp = temp . next ; } even = temp ; prev_temp . next = null ; i = head ; j = even ; while ( j != null && i != null ) { k = i . next ; l = j . next ; i . next = j ; j . next = k ; ptr = j ; i = k ; j = l ; } if ( i == null ) { ptr . next = j ; } return head ; } public static void main ( String args [ ] ) { Node head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 1 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 10 ) ; System . out . println ( " Linked ▁ List : " ) ; printList ( head ) ; System . out . println ( " Rearranged ▁ List " ) ; head = rearrange ( head ) ; printList ( head ) ; } }
import java . util . * ; class GFG { static class Node { int data ; Node next ; } ; static Node head = null ; static void rotate ( int k ) { if ( k == 0 ) return ; Node current = head ; while ( current . next != null ) current = current . next ; current . next = head ; current = head ; for ( int i = 0 ; i < k - 1 ; i ++ ) current = current . next ; head = current . next ; current . next = null ; } static void push ( int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head ; head = new_node ; } static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " ▁ " ) ; node = node . next ; } } public static void main ( String [ ] args ) { for ( int i = 60 ; i > 0 ; i -= 10 ) push ( i ) ; System . out . print ( "Given linked list NEW_LINE"); printList ( head ) ; rotate ( 4 ) ; System . out . print ( " Rotated Linked list "); printList ( head ) ; } }
import java . util . * ; class GFG { public static void main ( String [ ] args ) { ArrayList < Integer > list = new ArrayList < > ( ) ; list . add ( 1 ) ; list . add ( 2 ) ; list . add ( 3 ) ; Iterator < Integer > it = list . iterator ( ) ; while ( it . hasNext ( ) ) { System . out . print ( it . next ( ) + " ▁ " ) ; } } }
import java . util . * ; class Node { int data ; Node next ; public Node ( int data ) { this . data = data ; this . next = null ; } } class gfg { static Node root ; public static Node keyToEnd ( Node head , int key ) { Node tail = head ; if ( head == null ) { return null ; } while ( tail . next != null ) { tail = tail . next ; } Node last = tail ; Node current = head ; Node prev = null ; Node prev2 = null ; while ( current != tail ) { if ( current . data == key && prev2 == null ) { prev = current ; current = current . next ; head = current ; last . next = prev ; last = last . next ; last . next = null ; prev = null ; } else { if ( current . data == key && prev2 != null ) { prev = current ; current = current . next ; prev2 . next = current ; last . next = prev ; last = last . next ; last . next = null ; } else if ( current != tail ) { prev2 = current ; current = current . next ; } } } return head ; } public static void display ( Node root ) { while ( root != null ) { System . out . print ( root . data + " ▁ " ) ; root = root . next ; } } public static void main ( String args [ ] ) { root = new Node ( 5 ) ; root . next = new Node ( 2 ) ; root . next . next = new Node ( 2 ) ; root . next . next . next = new Node ( 7 ) ; root . next . next . next . next = new Node ( 2 ) ; root . next . next . next . next . next = new Node ( 2 ) ; root . next . next . next . next . next . next = new Node ( 2 ) ; int key = 2 ; System . out . println ( " Linked ▁ List ▁ before ▁ operations ▁ : " ) ; display ( root ) ; System . out . println ( " Linked List after operations : "); root = keyToEnd ( root , key ) ; display ( root ) ; } }
import java . util . * ; class GFG { static class Node { int data ; Node next ; } ; static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; return head_ref ; } static int sumOfLastN_NodesUtil ( Node head , int n ) { if ( n <= 0 ) return 0 ; Stack < Integer > st = new Stack < Integer > ( ) ; int sum = 0 ; while ( head != null ) { st . push ( head . data ) ; head = head . next ; } while ( n -- > 0 ) { sum += st . peek ( ) ; st . pop ( ) ; } return sum ; } public static void main ( String [ ] args ) { Node head = null ; head = push ( head , 12 ) ; head = push ( head , 4 ) ; head = push ( head , 8 ) ; head = push ( head , 6 ) ; head = push ( head , 10 ) ; int n = 2 ; System . out . print ( " Sum ▁ of ▁ last ▁ " + n + " ▁ nodes ▁ = ▁ " + sumOfLastN_NodesUtil ( head , n ) ) ; } }
import java . util . * ; class GFG { static class Node { int data ; Node next ; } ; static Node head ; static void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; head = head_ref ; } static void reverseList ( Node head_ref ) { Node current , prev , next ; current = head_ref ; prev = null ; while ( current != null ) { next = current . next ; current . next = prev ; prev = current ; current = next ; } head_ref = prev ; head = head_ref ; } static int sumOfLastN_NodesUtil ( int n ) { if ( n <= 0 ) return 0 ; reverseList ( head ) ; int sum = 0 ; Node current = head ; while ( current != null && n -- > 0 ) { sum += current . data ; current = current . next ; } reverseList ( head ) ; return sum ; } public static void main ( String [ ] args ) { push ( head , 12 ) ; push ( head , 4 ) ; push ( head , 8 ) ; push ( head , 6 ) ; push ( head , 10 ) ; int n = 2 ; System . out . println ( " Sum ▁ of ▁ last ▁ " + n + " ▁ nodes ▁ = ▁ " + sumOfLastN_NodesUtil ( n ) ) ; } }
class GFG { static class Node { int data ; Node next ; } ; static Node swapNodes ( Node head_ref , Node currX , Node currY , Node prevY ) { head_ref = currY ; prevY . next = currX ; Node temp = currY . next ; currY . next = currX . next ; currX . next = temp ; return head_ref ; } static Node recurSelectionSort ( Node head ) { if ( head . next == null ) return head ; Node min = head ; Node beforeMin = null ; Node ptr ; for ( ptr = head ; ptr . next != null ; ptr = ptr . next ) { if ( ptr . next . data < min . data ) { min = ptr . next ; beforeMin = ptr ; } } if ( min != head ) head = swapNodes ( head , head , min , beforeMin ) ; head . next = recurSelectionSort ( head . next ) ; return head ; } static Node sort ( Node head_ref ) { if ( ( head_ref ) == null ) return null ; head_ref = recurSelectionSort ( head_ref ) ; return head_ref ; } static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = ( head_ref ) ; ( head_ref ) = new_node ; return head_ref ; } static void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " ▁ " ) ; head = head . next ; } } public static void main ( String args [ ] ) { Node head = null ; head = push ( head , 6 ) ; head = push ( head , 4 ) ; head = push ( head , 8 ) ; head = push ( head , 12 ) ; head = push ( head , 10 ) ; System . out . println ( " Linked ▁ list ▁ before ▁ sorting : " ) ; printList ( head ) ; head = sort ( head ) ; System . out . print ( " Linked list after sorting : "); printList ( head ) ; } }
class GFG { static class Node { int data ; Node next , prev ; } ; static Node insert ( Node head_ref , int data ) { Node new_node = new Node ( ) ; new_node . data = data ; if ( head_ref == null ) { new_node . next = new_node ; new_node . prev = new_node ; } else { Node last = ( head_ref ) . prev ; new_node . next = head_ref ; new_node . prev = last ; last . next = ( head_ref ) . prev = new_node ; } head_ref = new_node ; return head_ref ; } static Node merge ( Node first , Node second ) { if ( first == null ) return second ; if ( second == null ) return first ; if ( first . data < second . data ) { first . next = merge ( first . next , second ) ; first . next . prev = first ; first . prev = null ; return first ; } else { second . next = merge ( first , second . next ) ; second . next . prev = second ; second . prev = null ; return second ; } } static Node mergeUtil ( Node head1 , Node head2 ) { if ( head1 == null ) return head2 ; if ( head2 == null ) return head1 ; Node last_node ; if ( head1 . prev . data < head2 . prev . data ) last_node = head2 . prev ; else last_node = head1 . prev ; head1 . prev . next = head2 . prev . next = null ; Node finalHead = merge ( head1 , head2 ) ; finalHead . prev = last_node ; last_node . next = finalHead ; return finalHead ; } static void printList ( Node head ) { Node temp = head ; while ( temp . next != head ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . next ; } System . out . print ( temp . data + " ▁ " ) ; } public static void main ( String args [ ] ) { Node head1 = null , head2 = null ; head1 = insert ( head1 , 8 ) ; head1 = insert ( head1 , 5 ) ; head1 = insert ( head1 , 3 ) ; head1 = insert ( head1 , 1 ) ; head2 = insert ( head2 , 11 ) ; head2 = insert ( head2 , 9 ) ; head2 = insert ( head2 , 7 ) ; head2 = insert ( head2 , 2 ) ; Node newHead = mergeUtil ( head1 , head2 ) ; System . out . print ( " Final ▁ Sorted ▁ List : ▁ " ) ; printList ( newHead ) ; } }
import java . util . * ; class GFG { static String minLexRotation ( String str ) { int n = str . length ( ) ; String arr [ ] = new String [ n ] ; String concat = str + str ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = concat . substring ( i , i + n ) ; } Arrays . sort ( arr ) ; return arr [ 0 ] ; } public static void main ( String [ ] args ) { System . out . println ( minLexRotation ( " GEEKSFORGEEKS " ) ) ; System . out . println ( minLexRotation ( " GEEKSQUIZ " ) ) ; System . out . println ( minLexRotation ( " BCABDADAB " ) ) ; } }
import java . util . * ; class GFG { static final int MAX = 1000 ; static final int log = 10 ; static int [ ] level = new int [ MAX ] ; static int [ ] [ ] lca = new int [ MAX ] [ log ] ; static int [ ] [ ] minWeight = new int [ MAX ] [ log ] ; static int [ ] [ ] maxWeight = new int [ MAX ] [ log ] ; static Vector < Integer > [ ] graph = new Vector [ MAX ] ; static int [ ] weight = new int [ MAX ] ; private static void swap ( int x , int y ) { int temp = x ; x = y ; y = temp ; } static void addEdge ( int u , int v ) { graph [ u ] . add ( v ) ; graph [ v ] . add ( u ) ; } static void dfs ( int node , int parent , int h ) { lca [ node ] [ 0 ] = parent ; level [ node ] = h ; if ( parent != - 1 ) { minWeight [ node ] [ 0 ] = Math . min ( weight [ node ] , weight [ parent ] ) ; maxWeight [ node ] [ 0 ] = Math . max ( weight [ node ] , weight [ parent ] ) ; } for ( int i = 1 ; i < log ; i ++ ) { if ( lca [ node ] [ i - 1 ] != - 1 ) { lca [ node ] [ i ] = lca [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ; minWeight [ node ] [ i ] = Math . min ( minWeight [ node ] [ i - 1 ] , minWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; maxWeight [ node ] [ i ] = Math . max ( maxWeight [ node ] [ i - 1 ] , maxWeight [ lca [ node ] [ i - 1 ] ] [ i - 1 ] ) ; } } for ( int i : graph [ node ] ) { if ( i == parent ) continue ; dfs ( i , node , h + 1 ) ; } } static void findMinMaxWeight ( int u , int v ) { int minWei = Integer . MAX_VALUE ; int maxWei = Integer . MIN_VALUE ; if ( level [ u ] > level [ v ] ) swap ( u , v ) ; for ( int i = log - 1 ; i >= 0 ; i -- ) { if ( lca [ v ] [ i ] != - 1 && level [ lca [ v ] [ i ] ] >= level [ u ] ) { minWei = Math . min ( minWei , minWeight [ v ] [ i ] ) ; maxWei = Math . max ( maxWei , maxWeight [ v ] [ i ] ) ; v = lca [ v ] [ i ] ; } } if ( v == u ) { System . out . print ( minWei + " ▁ " + maxWei + "NEW_LINE"); } else { for ( int i = log - 1 ; i >= 0 ; i -- ) { if ( v == - 1 ) v ++ ; if ( lca [ v ] [ i ] != lca [ u ] [ i ] ) { minWei = Math . min ( minWei , Math . min ( minWeight [ v ] [ i ] , minWeight [ u ] [ i ] ) ) ; maxWei = Math . max ( maxWei , Math . max ( maxWeight [ v ] [ i ] , maxWeight [ u ] [ i ] ) ) ; v = lca [ v ] [ i ] ; u = lca [ u ] [ i ] ; } } if ( u == - 1 ) u ++ ; minWei = Math . min ( minWei , Math . min ( minWeight [ v ] [ 0 ] , minWeight [ u ] [ 0 ] ) ) ; maxWei = Math . max ( maxWei , Math . max ( maxWeight [ v ] [ 0 ] , maxWeight [ u ] [ 0 ] ) ) ; System . out . print ( minWei + " ▁ " + maxWei + "NEW_LINE"); } } public static void main ( String [ ] args ) { int n = 5 ; for ( int i = 0 ; i < graph . length ; i ++ ) graph [ i ] = new Vector < Integer > ( ) ; addEdge ( 1 , 2 ) ; addEdge ( 1 , 5 ) ; addEdge ( 2 , 4 ) ; addEdge ( 2 , 3 ) ; weight [ 1 ] = - 1 ; weight [ 2 ] = 5 ; weight [ 3 ] = - 1 ; weight [ 4 ] = 3 ; weight [ 5 ] = - 2 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j < log ; j ++ ) { lca [ i ] [ j ] = - 1 ; minWeight [ i ] [ j ] = Integer . MAX_VALUE ; maxWeight [ i ] [ j ] = Integer . MIN_VALUE ; } } dfs ( 1 , - 1 , 0 ) ; findMinMaxWeight ( 1 , 3 ) ; findMinMaxWeight ( 2 , 4 ) ; findMinMaxWeight ( 3 , 5 ) ; } }
import java . util . * ; class GFG { static int MAX = 1000 ; static int findLCA ( int n1 , int n2 , int parent [ ] ) { boolean [ ] visited = new boolean [ MAX ] ; visited [ n1 ] = true ; while ( parent [ n1 ] != - 1 ) { visited [ n1 ] = true ; n1 = parent [ n1 ] ; } visited [ n1 ] = true ; while ( ! visited [ n2 ] ) n2 = parent [ n2 ] ; return n2 ; } static void insertAdj ( int parent [ ] , int i , int j ) { parent [ i ] = j ; } public static void main ( String [ ] args ) { int [ ] parent = new int [ MAX ] ; parent [ 20 ] = - 1 ; insertAdj ( parent , 8 , 20 ) ; insertAdj ( parent , 22 , 20 ) ; insertAdj ( parent , 4 , 8 ) ; insertAdj ( parent , 12 , 8 ) ; insertAdj ( parent , 10 , 12 ) ; insertAdj ( parent , 14 , 12 ) ; System . out . println ( findLCA ( 10 , 14 , parent ) ) ; } }
class GFG { public static int solve ( int n , int m ) { int ans = n * ( m / 2 ) ; if ( m % 2 == 1 ) { ans += ( n + 1 ) / 2 ; } return ans ; } public static void main ( String args [ ] ) { int N = 5 ; int M = 3 ; System . out . println ( solve ( N , M ) ) ; } }
class GFG { static int max_len = 100005 ; static int cnt [ ] = new int [ max_len ] ; public static void precompute ( String s , String K ) { int n = s . length ( ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { cnt [ i + 1 ] = cnt [ i ] ; if ( s . substring ( i , i + K . length ( ) ) . equals ( K ) ) { cnt [ i + 1 ] += 1 ; } } cnt [ n - 2 + 1 ] = cnt [ n - 2 ] ; } public static void main ( String [ ] args ) { String s = " ABCABCABABC " ; String K = " ABC " ; precompute ( s , K ) ; int Q [ ] [ ] = { { 1 , 6 } , { 5 , 11 } } ; for ( int it = 0 ; it < Q . length ; it ++ ) { System . out . println ( cnt [ Q [ it ] [ 1 ] - 1 ] - cnt [ Q [ it ] [ 0 ] - 1 ] ) ; } } }
class GFG { static void countIntgralPoints ( int x1 , int y1 , int x2 , int y2 ) { System . out . println ( ( y2 - y1 - 1 ) * ( x2 - x1 - 1 ) ) ; } public static void main ( String args [ ] ) { int x1 = 1 , y1 = 1 ; int x2 = 4 , y2 = 4 ; countIntgralPoints ( x1 , y1 , x2 , y2 ) ; } }
class GFG { static int minSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } if ( sum == 1 ) return 10 ; return sum ; } public static void main ( String [ ] args ) { int n = 1884 ; System . out . print ( minSum ( n ) ) ; } }
import java . io . * ; class GFG { public static int repeatingElement ( int arr [ ] , int N ) { int M = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; M = Math . max ( M , arr [ i ] ) ; } int sum1 = M * ( M + 1 ) / 2 ; int ans = ( sum - sum1 ) / ( N - M ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 6 , 4 , 3 , 1 , 5 , 2 } ; int N = arr . length ; System . out . println ( repeatingElement ( arr , N ) ) ; } }
import java . io . * ; class GFG { public static int calculateMax ( int N , int M , int K ) { int ans = - 1 ; int low = 0 , high = M ; while ( low <= high ) { int mid = ( low + high ) / 2 ; int val = 0 ; int L = K - 1 ; int R = N - K ; val += mid ; if ( mid >= L ) { val += ( L ) * ( 2 * mid - L - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( L - mid ) ; } if ( mid >= R ) { val += ( R ) * ( 2 * mid - R - 1 ) / 2 ; } else { val += mid * ( mid - 1 ) / 2 + ( R - mid ) ; } if ( val <= M ) { ans = Math . max ( ans , mid ) ; low = mid + 1 ; } else high = mid - 1 ; } return ans ; } public static void main ( String [ ] args ) { int N = 7 , M = 100 , K = 6 ; System . out . println ( calculateMax ( N , M , K ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static int find_index ( int arr [ ] , int N ) { int max_value = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { max_value = Math . max ( max_value , arr [ i ] ) ; } Map < Integer , Integer > store = new HashMap < > ( ) ; for ( int i = 1 ; i <= max_value ; i ++ ) { store . put ( i , store . getOrDefault ( i , 0 ) + 1 ) ; } if ( store . containsKey ( 1 ) ) { store . remove ( 1 ) ; } for ( int i = 2 ; i <= Math . sqrt ( max_value ) ; i ++ ) { int multiple = 2 ; while ( ( i * multiple ) <= max_value ) { if ( store . containsKey ( i * multiple ) ) { store . remove ( i * multiple ) ; } multiple ++ ; } } int prime_sum_from_left = 0 ; int [ ] first_array = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { first_array [ i ] = prime_sum_from_left ; if ( store . containsKey ( arr [ i ] ) ) { prime_sum_from_left += arr [ i ] ; } } int prime_sum_from_right = 0 ; int [ ] second_array = new int [ N ] ; for ( int i = N - 1 ; i >= 0 ; i -- ) { second_array [ i ] = prime_sum_from_right ; if ( store . containsKey ( arr [ i ] ) ) { prime_sum_from_right += arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( first_array [ i ] == second_array [ i ] ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 4 , 7 , 6 , 13 , 1 , 5 } ; int N = arr . length ; System . out . println ( find_index ( arr , N ) ) ; } }
class GFG { static int findCost ( int [ ] A , int N ) { int totalCost = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] == 0 ) { A [ i ] = 1 ; totalCost += i ; } } return totalCost ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 0 } ; int N = arr . length ; System . out . println ( findCost ( arr , N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static boolean isGreaterEqual ( int N , int K , int X ) { return ( ( N * 1L * ( N + 1 ) / 2 ) - ( ( K - 1 ) * 1L * K / 2 ) ) >= X ; } static void minimumNumber ( int K , int X ) { if ( K > X ) { System . out . println ( " - 1" ) ; return ; } int low = K , high = X , res = - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( isGreaterEqual ( mid , K , X ) ) { res = mid ; high = mid - 1 ; } else low = mid + 1 ; } System . out . println ( res ) ; } public static void main ( String [ ] args ) { int K = 5 , X = 13 ; minimumNumber ( K , X ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int GetDiff ( int A [ ] , int N ) { int SuffMaxArr [ ] = new int [ N ] ; SuffMaxArr [ N - 1 ] = A [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; -- i ) { SuffMaxArr [ i ] = Math . max ( SuffMaxArr [ i + 1 ] , A [ i + 1 ] ) ; } int MaximumSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMaxArr [ i ] ) MaximumSum = Math . max ( MaximumSum , A [ i ] + SuffMaxArr [ i ] ) ; } int MinimumSum = Integer . MAX_VALUE ; int SuffMinArr [ ] = new int [ N ] ; SuffMinArr [ N - 1 ] = Integer . MAX_VALUE ; for ( int i = N - 2 ; i >= 0 ; -- i ) { SuffMinArr [ i ] = Math . min ( SuffMinArr [ i + 1 ] , A [ i + 1 ] ) ; } for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( A [ i ] < SuffMinArr [ i ] ) { MinimumSum = Math . min ( MinimumSum , A [ i ] + SuffMinArr [ i ] ) ; } } return Math . abs ( MaximumSum - MinimumSum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 1 , 3 , 7 , 5 , 6 } ; int N = arr . length ; System . out . println ( GetDiff ( arr , N ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int sumOfDigits ( String s ) { int curr = 0 ; int ret = 0 ; for ( char ch : s . toCharArray ( ) ) { if ( ch >= 48 && ch <= 57 ) { curr = curr * 10 + ch - '0' ; } else { ret += curr ; curr = 0 ; } } ret += curr ; return ret ; } public static void main ( String [ ] args ) { String S = "11aa32bbb5" ; System . out . print ( sumOfDigits ( S ) ) ; } }
public class GFG { static void minimumOperations ( int [ ] arr , int N ) { int oddCnt = 0 , evenCnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] % 2 == 0 ) { evenCnt ++ ; } else { oddCnt ++ ; } } System . out . print ( Math . min ( oddCnt , evenCnt ) ) ; } public static void main ( String args [ ] ) { int [ ] arr = { 4 , 1 , 2 } ; int N = arr . length ; minimumOperations ( arr , N ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean check ( int a [ ] , int n ) { boolean flag = false ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i + 1 ] > a [ i ] && a [ i ] < a [ i - 1 ] ) flag = true ; } if ( flag ) return false ; else return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 2 } ; int N = arr . length ; if ( check ( arr , N ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void minOperations ( String S ) { int count = 0 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( i - 1 ) ) { count += 1 ; } } System . out . print ( count ) ; } public static void main ( String [ ] args ) { String S = "0101010101" ; minOperations ( S ) ; } }
import java . util . * ; class GFG { static void numberOfPairs ( int arr [ ] , int N ) { int [ ] set_bits = new int [ 31 ] ; Arrays . fill ( set_bits , 0 ) ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; int bitpos = - 1 ; while ( x > 0 ) { bitpos ++ ; x /= 2 ; } for ( int j = 0 ; j <= bitpos ; j ++ ) { count += set_bits [ j ] ; } set_bits [ bitpos ] ++ ; } System . out . println ( count ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 16 , 8 , 64 } ; int N = arr . length ; numberOfPairs ( arr , N ) ; } }
class GFG { static void findMaximum ( int arr [ ] , int N , int Q , int queries [ ] [ ] ) { int prefix_max [ ] = new int [ N + 1 ] ; int suffix_max [ ] = new int [ N + 1 ] ; prefix_max [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < N ; i ++ ) { prefix_max [ i ] = Math . max ( prefix_max [ i - 1 ] , arr [ i ] ) ; } suffix_max [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { suffix_max [ i ] = Math . max ( suffix_max [ i + 1 ] , arr [ i ] ) ; } for ( int i = 0 ; i < Q ; i ++ ) { int l = queries [ i ] [ 0 ] ; int r = queries [ i ] [ 1 ] ; if ( l == 0 && r == ( N - 1 ) ) System . out . print ( "0NEW_LINE"); else if ( l == 0 ) System . out . print ( suffix_max [ r + 1 ] + "NEW_LINE"); else if ( r == ( N - 1 ) ) System . out . print ( prefix_max [ l - 1 ] + "NEW_LINE"); else System . out . print ( Math . max ( prefix_max [ l - 1 ] , suffix_max [ r + 1 ] ) + "NEW_LINE"); } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 8 , 10 , 15 } ; int N = arr . length ; int queries [ ] [ ] = { { 0 , 1 } , { 0 , 2 } , { 1 , 4 } } ; int Q = queries . length ; findMaximum ( arr , N , Q , queries ) ; } }
class GFG { static String minEmail ( String email ) { String ans = new String ( " " ) ; int len = email . length ( ) ; ans += email . charAt ( 0 ) ; int i = 1 ; boolean notAt = true ; while ( i < len ) { if ( i < len - 3 && notAt && email . charAt ( i ) == ' a ' && email . charAt ( i + 1 ) == ' t ' ) { ans += ' @ ' ; i += 1 ; notAt = false ; } else if ( i < len - 4 && email . charAt ( i ) == ' d ' && email . charAt ( i + 1 ) == ' o ' && email . charAt ( i + 2 ) == ' t ' ) { ans += ' . ' ; i += 2 ; } else { ans += email . charAt ( i ) ; } i += 1 ; } return ans ; } public static void main ( String [ ] args ) { String email = new String ( " geeksforgeeksatgmaildotcom " ) ; System . out . println ( minEmail ( email ) ) ; } }
import java . io . * ; class GFG { static void countRemainingElements ( int [ ] L1 , int [ ] L2 , int n ) { int one = 0 ; int zero = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( L1 [ i ] == 1 ) one ++ ; else zero ++ ; } int ans = n ; for ( int i = 0 ; i < n ; i ++ ) { if ( L2 [ i ] == 1 ) { one -- ; if ( one < 0 ) { ans = i ; break ; } } else { zero -- ; if ( zero < 0 ) { ans = i ; break ; } } } System . out . println ( n - ans ) ; } public static void main ( String [ ] args ) { int [ ] L1 = { 1 , 1 , 0 , 0 } ; int [ ] L2 = { 0 , 0 , 0 , 1 } ; int N = L1 . length ; countRemainingElements ( L1 , L2 , N ) ; } }
class GFG { static int LCM ( int A , int B ) { return ( A * B / __gcd ( A , B ) ) ; } static void findSmallestNumber ( int X ) { int lcm = 1 ; int temp = X ; while ( temp > 0 ) { int last = temp % 10 ; temp /= 10 ; if ( last == 0 ) continue ; lcm = LCM ( lcm , last ) ; } int answer = ( ( X + lcm - 1 ) / lcm ) * lcm ; System . out . print ( answer ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int X = 280 ; findSmallestNumber ( X ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static int findNonMultiples ( int [ ] arr , int n , int k ) { Set < Integer > multiples = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( ! multiples . contains ( arr [ i ] ) ) { for ( int j = 1 ; j <= k / arr [ i ] ; j ++ ) { multiples . add ( arr [ i ] * j ) ; } } } return k - multiples . size ( ) ; } public static int countValues ( int [ ] arr , int N , int L , int R ) { return findNonMultiples ( arr , N , R ) - findNonMultiples ( arr , N , L - 1 ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 } ; int N = arr . length ; int L = 1 ; int R = 20 ; System . out . println ( countValues ( arr , N , L , R ) ) ; } }
import java . util . * ; class GFG { static int findCntTriplet ( int N ) { int cntTriplet = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( N % i != 0 ) { cntTriplet += N / i ; } else { cntTriplet += ( N / i ) - 1 ; } } return cntTriplet ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( findCntTriplet ( N ) ) ; } }
import java . util . * ; class GFG { static void minCollectingSpeed ( int [ ] piles , int H ) { int ans = - 1 ; int low = 1 , high ; high = Arrays . stream ( piles ) . max ( ) . getAsInt ( ) ; while ( low <= high ) { int K = low + ( high - low ) / 2 ; int time = 0 ; for ( int ai : piles ) { time += ( ai + K - 1 ) / K ; } if ( time <= H ) { ans = K ; high = K - 1 ; } else { low = K + 1 ; } } System . out . print ( ans ) ; } static public void main ( String args [ ] ) { int [ ] arr = { 3 , 6 , 7 , 11 } ; int H = 8 ; minCollectingSpeed ( arr , H ) ; } }
import java . util . * ; class GFG { static int countSubArraySignChange ( int arr [ ] , int N ) { HashMap < Integer , Integer > prefixCount = new HashMap < Integer , Integer > ( ) ; HashMap < Integer , Integer > suffixCount = new HashMap < Integer , Integer > ( ) ; int total = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { total += arr [ i ] ; if ( suffixCount . containsKey ( arr [ i ] ) ) { suffixCount . put ( arr [ i ] , suffixCount . get ( arr [ i ] ) + 1 ) ; } else { suffixCount . put ( arr [ i ] , 1 ) ; } } int prefixSum = 0 ; int suffixSum = 0 ; int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { prefixSum += arr [ i ] ; if ( prefixCount . containsKey ( arr [ i ] ) ) { prefixCount . put ( arr [ i ] , prefixCount . get ( arr [ i ] ) + 1 ) ; } else { prefixCount . put ( arr [ i ] , 1 ) ; } suffixSum = total - prefixSum ; if ( suffixCount . containsKey ( arr [ i ] ) ) { suffixCount . put ( arr [ i ] , suffixCount . get ( arr [ i ] ) - 1 ) ; } int diff = prefixSum - suffixSum ; if ( diff % 2 == 0 ) { int x = ( prefixCount . containsKey ( diff / 2 ) ? prefixCount . get ( diff / 2 ) : 0 ) + ( suffixCount . containsKey ( - diff / 2 ) ? suffixCount . get ( - diff / 2 ) : 0 ) ; count = count + x ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , - 3 , 3 } ; int N = arr . length ; System . out . print ( countSubArraySignChange ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int countCommonChar ( int ind , String S ) { int cnt = 0 ; HashSet < Character > ls = new HashSet < Character > ( ) ; HashSet < Character > rs = new HashSet < Character > ( ) ; for ( int i = 0 ; i < ind ; ++ i ) { ls . add ( S . charAt ( i ) ) ; } for ( int i = ind ; i < S . length ( ) ; ++ i ) { rs . add ( S . charAt ( i ) ) ; } for ( char v : ls ) { if ( rs . contains ( v ) ) { ++ cnt ; } } return cnt ; } static void partitionStringWithMaxCom ( String S ) { int ans = 0 ; for ( int i = 1 ; i < S . length ( ) ; ++ i ) { ans = Math . max ( ans , countCommonChar ( i , S ) ) ; } System . out . print ( ans + "NEW_LINE"); } public static void main ( String [ ] args ) { String str = " aabbca " ; partitionStringWithMaxCom ( str ) ; } }
import java . util . * ; class GFG { static String SmallestString ( String s , char c ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) > c ) { String temp = s ; s = s . substring ( 0 , i ) ; s += c ; s += temp . substring ( i , temp . length ( ) ) ; return s ; } } s += c ; return s ; } public static void main ( String args [ ] ) { String S = " acd " ; char C = ' b ' ; System . out . println ( SmallestString ( S , C ) ) ; } }
import java . util . * ; class GFG { static int sumOfPathNodes ( int N ) { if ( N == 1 ) { return 1 ; } else if ( N == 2 N == 3 ) { return N + 1 ; } Vector < Integer > arr = new Vector < > ( ) ; arr . add ( 1 ) ; int k = 1 ; boolean flag = true ; while ( k < N ) { if ( flag == true ) { k *= 2 ; flag = false ; } else { k *= 4 ; flag = true ; } if ( k > N ) { break ; } arr . add ( k ) ; } int len = arr . size ( ) ; int [ ] prefix = new int [ len ] ; prefix [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) { prefix [ i ] = arr . get ( i ) + prefix [ i - 1 ] ; } int it = lowerBound ( prefix , 0 , len , N ) + 1 ; int ind = it - prefix [ 0 ] ; int final_ans = 0 ; int temp = N ; while ( ind > 1 ) { int val = temp - prefix [ ind - 1 ] ; if ( ind % 2 != 0 ) { temp = prefix [ ind - 2 ] + ( val + 1 ) / 2 ; } else { temp = prefix [ ind - 2 ] + ( val + 3 ) / 4 ; } -- ind ; final_ans += temp ; } final_ans += ( N + 1 ) ; return final_ans ; } static int lowerBound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) low = middle + 1 ; else high = middle ; } return low ; } public static void main ( String [ ] args ) { int N = 13 ; System . out . print ( sumOfPathNodes ( N ) + "NEW_LINE"); } }
import java . util . * ; import java . util . Arrays ; import java . util . Collections ; class GFG { static void rearrangeArray ( int a [ ] , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } if ( sum == 0 ) { System . out . print ( " - 1" ) ; return ; } sum = 0 ; int b = 0 ; Arrays . sort ( a ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( sum == 0 ) { if ( a [ i ] != a [ N - 1 ] ) { sum -= a [ i ] ; int temp = a [ i ] ; a [ i ] = a [ N - 1 ] ; a [ N - 1 ] = temp ; sum += a [ i ] ; } else { b = 1 ; break ; } } } if ( b == 1 ) { b = 0 ; sum = 0 ; Arrays . sort ( a ) ; for ( int i = N - 1 ; i >= 0 ; i -- ) { sum += a [ i ] ; if ( sum == 0 ) { if ( a [ i ] != a [ 0 ] ) { sum -= a [ i ] ; int temp = a [ i ] ; a [ i ] = a [ 0 ] ; a [ 0 ] = temp ; sum += a [ i ] ; } else { b = 1 ; break ; } } } } if ( b == 1 ) { System . out . print ( " - 1" + " ▁ " ) ; return ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( a [ i ] + " ▁ " ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , - 1 , 2 , 4 , 0 } ; int N = arr . length ; rearrangeArray ( arr , N ) ; } }
import java . util . * ; class GFG { static void findMinimumOperations ( char [ ] a , char [ ] b ) { int step = 0 ; int last_index = 0 ; while ( ! Arrays . equals ( a , b ) ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != b [ i ] ) { last_index = i ; } } for ( int i = 0 ; i <= last_index ; i ++ ) { a [ i ] = ( a [ i ] == '0' ) ? '1' : '0' ; } step ++ ; } System . out . print ( step ) ; } public static void main ( String [ ] args ) { String A = "101010" , B = "110011" ; findMinimumOperations ( A . toCharArray ( ) , B . toCharArray ( ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean isPrime ( int num ) { if ( num <= 1 ) return false ; for ( int i = 2 ; i * i <= num ; i ++ ) if ( num % i == 0 ) return false ; return true ; } static boolean isFulPrime ( int n ) { if ( ! isPrime ( n ) ) return false ; else { while ( n > 0 ) { int rem = n % 10 ; if ( ! ( rem == 2 rem == 3 rem == 5 rem == 7 ) ) return false ; n = n / 10 ; } } return true ; } static int countFulPrime ( int L , int R ) { int cnt = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( ( i % 2 ) != 0 && isFulPrime ( i ) ) { cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { int L = 1 , R = 100 ; int ans = 0 ; if ( L < 3 ) ans ++ ; System . out . println ( ans + countFulPrime ( L , R ) ) ; } }
class GFG { static boolean is_prime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void countSmallerPrimes ( int ar [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < N ; j ++ ) { if ( ar [ j ] <= ar [ i ] && is_prime ( ar [ j ] ) ) { count ++ ; } } System . out . print ( count + " ▁ " ) ; } } public static void main ( String [ ] args ) { int ar [ ] = { 43 , 3 , 5 , 7 , 2 , 41 } ; int N = ar . length ; countSmallerPrimes ( ar , N ) ; } }
import java . io . * ; class GFG { static int minLength ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return 1 ; } } return N ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 3 , 1 } ; int N = arr . length ; System . out . print ( minLength ( arr , N ) ) ; } }
class GFG { static int numSpecial ( int [ ] [ ] mat ) { int m = mat . length ; int n = mat [ 0 ] . length ; int [ ] rows = new int [ m ] ; int [ ] cols = new int [ n ] ; int i , j ; for ( i = 0 ; i < m ; i ++ ) { rows [ i ] = 0 ; for ( j = 0 ; j < n ; j ++ ) rows [ i ] += mat [ i ] [ j ] ; } for ( i = 0 ; i < n ; i ++ ) { cols [ i ] = 0 ; for ( j = 0 ; j < m ; j ++ ) cols [ i ] += mat [ j ] [ i ] ; } int cnt = 0 ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 && rows [ i ] == 1 && cols [ j ] == 1 ) cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 0 , 0 } , { 0 , 0 , 1 } , { 0 , 0 , 0 } } ; System . out . print ( numSpecial ( mat ) + "NEW_LINE"); } }
import java . util . * ; class GFG { public static Vector < Integer > minmaxNumbers ( int [ ] [ ] matrix , Vector < Integer > res ) { Set < Integer > set = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < matrix . length ; i ++ ) { int minr = Integer . MAX_VALUE ; for ( int j = 0 ; j < matrix [ i ] . length ; j ++ ) { minr = Math . min ( minr , matrix [ i ] [ j ] ) ; } set . add ( minr ) ; } for ( int j = 0 ; j < matrix [ 0 ] . length ; j ++ ) { int maxc = Integer . MIN_VALUE ; for ( int i = 0 ; i < matrix . length ; i ++ ) { maxc = Math . max ( maxc , matrix [ i ] [ j ] ) ; } if ( set . contains ( maxc ) ) { res . add ( maxc ) ; } } return res ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 10 , 4 } , { 9 , 3 , 8 } , { 15 , 16 , 17 } } ; Vector < Integer > ans = new Vector < Integer > ( ) ; ans = minmaxNumbers ( mat , ans ) ; if ( ans . size ( ) == 0 ) System . out . println ( " - 1" ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . println ( ans . get ( i ) ) ; } }
class GFG { static int countPrecedingK ( int a [ ] , int n , int K ) { int [ ] prefix = new int [ n ] ; prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } int ctr = 0 ; if ( prefix [ K - 1 ] < a [ K ] ) ctr ++ ; for ( int i = K + 1 ; i < n ; i ++ ) { if ( prefix [ i - 1 ] - prefix [ i - K - 1 ] < a [ i ] ) ctr ++ ; } return ctr ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 8 , 10 , - 2 , 7 , 5 , 5 , 9 , 15 } ; int N = arr . length ; int K = 2 ; System . out . print ( countPrecedingK ( arr , N , K ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static final int M = 1000 ; static int countNum ( int N , int sum , int K , int st , int dp [ ] [ ] [ ] ) { if ( N == 0 && sum == 0 ) { return 1 ; } if ( N < 0 ) { return 0 ; } if ( dp [ N ] [ sum ] [ st ] != - 1 ) { return dp [ N ] [ sum ] [ st ] ; } int res = 0 ; int start = st == 1 ? 0 : 1 ; for ( int i = start ; i <= 9 ; i ++ ) { res += countNum ( N - 1 , ( sum + i ) % K , K , ( ( st i ) > 0 ) ? 1 : 0 , dp ) ; } return dp [ N ] [ sum ] [ st ] = res ; } public static void main ( String [ ] args ) { int N = 2 , K = 7 ; int [ ] [ ] [ ] dp = new int [ M ] [ M ] [ 2 ] ; for ( int [ ] [ ] i : dp ) for ( int [ ] j : i ) Arrays . fill ( j , - 1 ) ; System . out . print ( countNum ( N , 0 , K , 0 , dp ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static int minDeletion ( String str ) { int n = str . length ( ) ; int firstIdx1 = - 1 ; int lastIdx0 = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '1' ) { firstIdx1 = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '0' ) { lastIdx0 = i ; break ; } } if ( firstIdx1 == - 1 lastIdx0 == - 1 ) return 0 ; int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < lastIdx0 ; i ++ ) { if ( str . charAt ( i ) == '1' ) { count1 ++ ; } } for ( int i = firstIdx1 + 1 ; i < n ; i ++ ) { if ( str . charAt ( i ) == '1' ) { count0 ++ ; } } return Math . min ( count0 , count1 ) ; } public static void main ( String [ ] args ) { String str = "1000101" ; System . out . println ( minDeletion ( str ) ) ; } }
import java . util . * ; class GFG { public static void print_substring ( String s ) { int n = s . length ( ) ; String str = " " ; Vector < Integer > ans = new Vector < Integer > ( ) ; if ( n == 0 ) { System . out . print ( " - 1" ) ; return ; } int [ ] last_pos = new int [ 26 ] ; Arrays . fill ( last_pos , - 1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s . charAt ( i ) - ' a ' ] == - 1 ) { last_pos [ s . charAt ( i ) - ' a ' ] = i ; } } int minp = - 1 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_pos [ s . charAt ( i ) - ' a ' ] ; minp = Math . max ( minp , lp ) ; if ( i == minp ) { str += s . charAt ( i ) ; System . out . print ( str + ' ▁ ' ) ; minp = - 1 ; str = " " ; } else { str += s . charAt ( i ) ; } } } public static void main ( String [ ] args ) { String S = " ababcbacadefegdehijhklij " ; print_substring ( S ) ; } }
import java . util . * ; class GFG { static void partitionString ( String s ) { int n = s . length ( ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; if ( n == 0 ) { System . out . print ( " - 1" ) ; return ; } int [ ] last_pos = new int [ 26 ] ; Arrays . fill ( last_pos , - 1 ) ; for ( int i = n - 1 ; i >= 0 ; -- i ) { if ( last_pos [ s . charAt ( i ) - ' a ' ] == - 1 ) { last_pos [ s . charAt ( i ) - ' a ' ] = i ; } } int minp = - 1 , plen = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int lp = last_pos [ s . charAt ( i ) - ' a ' ] ; minp = Math . max ( minp , lp ) ; ++ plen ; if ( i == minp ) { ans . add ( plen ) ; minp = - 1 ; plen = 0 ; } } for ( int i = 0 ; i < ( int ) ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { String str = " acbbcc " ; partitionString ( str ) ; } }
import java . util . * ; class GFG { static boolean check ( String s , int k ) { int n = s . length ( ) ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i ; j < n ; j += k ) { if ( s . charAt ( i ) != s . charAt ( j ) ) return false ; } } int c = 0 ; for ( int i = 0 ; i < k ; i ++ ) { if ( s . charAt ( i ) == '0' ) c ++ ; else c -- ; } if ( c == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { String s = "101010" ; int k = 2 ; if ( check ( s , k ) ) System . out . print ( " Yes " + "NEW_LINE"); else System . out . print ( " No " + "NEW_LINE"); } }
import java . util . * ; class GFG { static int maxGCD ( int n ) { int maxHcf = Integer . MIN_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i + 1 ; j <= n ; j ++ ) { maxHcf = Math . max ( maxHcf , __gcd ( i , j ) ) ; } } return maxHcf ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( maxGCD ( n ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static final double eps = 1e-6 ; static double func ( double a , double b , double c , double x ) { return a * x * x + b * x + c ; } static double findRoot ( double a , double b , double c , double low , double high ) { double x = - 1 ; while ( Math . abs ( high - low ) > eps ) { x = ( low + high ) / 2 ; if ( func ( a , b , c , low ) * func ( a , b , c , x ) <= 0 ) { high = x ; } else { low = x ; } } return x ; } static void solve ( double a , double b , double c , double A , double B ) { if ( func ( a , b , c , A ) * func ( a , b , c , B ) > 0 ) { System . out . println ( " No ▁ solution " ) ; } else { System . out . format ( " % .4f " , findRoot ( a , b , c , A , B ) ) ; } } public static void main ( String [ ] args ) { double a = 2 , b = - 3 , c = - 2 , A = 0 , B = 3 ; solve ( a , b , c , A , B ) ; } }
class GFG { static int [ ] findSubarrays ( int [ ] a ) { int n = a . length ; int [ ] freq = new int [ n + 1 ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { if ( count == 0 ) continue ; else { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } count = 0 ; } } else count ++ ; } if ( count > 0 ) { int value = count ; for ( int j = 1 ; j <= count ; j ++ ) { freq [ j ] += value ; value -- ; } } return freq ; } static void countRectangles ( int [ ] a , int [ ] b , int K ) { int n = a . length ; int m = b . length ; int [ ] subA = findSubarrays ( a ) ; int [ ] subB = findSubarrays ( b ) ; int total = 0 ; for ( int i = 1 ; i < subA . length ; i ++ ) { if ( K % i == 0 && ( K / i ) <= m ) { total = total + subA [ i ] * subB [ K / i ] ; } } System . out . print ( total ) ; } public static void main ( String [ ] args ) { int [ ] a = { 0 , 0 , 1 , 1 } ; int [ ] b = { 1 , 0 , 1 } ; int K = 2 ; countRectangles ( a , b , K ) ; } }
import java . util . * ; class GFG { static void printRes ( Vector < Integer > res ) { Enumeration enu = res . elements ( ) ; while ( enu . hasMoreElements ( ) ) { System . out . print ( enu . nextElement ( ) + " ▁ " ) ; } } static void printLBS ( int arr [ ] , int N ) { int lis [ ] = new int [ N ] ; int lds [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { lis [ i ] = lds [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { if ( lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; } } } for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = N - 1 ; j > i ; j -- ) { if ( arr [ j ] < arr [ i ] ) { if ( lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; } } } int MaxVal = arr [ 0 ] , inx = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( MaxVal < lis [ i ] + lds [ i ] - 1 ) { MaxVal = lis [ i ] + lds [ i ] - 1 ; inx = i ; } } int ct1 = lis [ inx ] ; Vector < Integer > res = new Vector < Integer > ( ) ; for ( int i = inx ; i >= 0 && ct1 > 0 ; i -- ) { if ( lis [ i ] == ct1 ) { res . add ( arr [ i ] ) ; ct1 -- ; } } Collections . reverse ( res ) ; int ct2 = lds [ inx ] - 1 ; for ( int i = inx ; i < N && ct2 > 0 ; i ++ ) { if ( lds [ i ] == ct2 ) { res . add ( arr [ i ] ) ; ct2 -- ; } } printRes ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 80 , 60 , 30 , 40 , 20 , 10 } ; int N = arr . length ; printLBS ( arr , N ) ; } }
import java . util . * ; class GFG { static void solve ( int n , int arr [ ] ) { int i , ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { int left = Math . max ( i - 1 , 0 ) ; int right = Math . min ( n - 1 , i + 1 ) ; while ( left >= 0 ) { if ( arr [ left ] > arr [ i ] ) { left ++ ; break ; } left -- ; } if ( left < 0 ) left ++ ; while ( right < n ) { if ( arr [ right ] > arr [ i ] ) { right -- ; break ; } right ++ ; } if ( right >= n ) right -- ; ans = 1 + right - left ; System . out . print ( ans + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 1 } ; int n = arr . length ; solve ( n , arr ) ; } }
import java . util . * ; import java . io . * ; class GFG { static int getSum ( int BITree [ ] , int index ) { int ans = 0 ; index += 1 ; while ( index > 0 ) { ans += BITree [ index ] ; index -= index & ( - index ) ; } return ans ; } static void updateBIT ( int BITree [ ] , int n , int index , int val ) { index = index + 1 ; while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } } static int [ ] constructBITree ( int arr [ ] , int n ) { int [ ] BITree = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) BITree [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) updateBIT ( BITree , n , i , arr [ i ] ) ; return BITree ; } static int getLowerBound ( int BITree [ ] , int [ ] arr , int n , int k ) { int lb = - 1 ; int l = 0 , r = n - 1 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( getSum ( BITree , mid ) >= k ) { r = mid - 1 ; lb = mid ; } else l = mid + 1 ; } return lb ; } static void performQueries ( int A [ ] , int n , int q [ ] [ ] ) { int [ ] BITree = constructBITree ( A , n ) ; for ( int i = 0 ; i < q . length ; i ++ ) { int id = q [ i ] [ 0 ] ; if ( id == 1 ) { int idx = q [ i ] [ 1 ] ; int val = q [ i ] [ 2 ] ; A [ idx ] += val ; updateBIT ( BITree , n , idx , val ) ; } else { int k = q [ i ] [ 1 ] ; int lb = getLowerBound ( BITree , A , n , k ) ; System . out . println ( lb ) ; } } } public static void main ( String [ ] args ) { int A [ ] = { 1 , 2 , 3 , 5 , 8 } ; int n = A . length ; int [ ] [ ] q = { { 1 , 0 , 2 } , { 2 , 5 } , { 1 , 3 , 5 } } ; performQueries ( A , n , q ) ; } }
class GFG { static boolean ContinuousElements ( int a [ ] , int n ) { if ( n == 1 ) return false ; int curr = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { if ( curr == 1 ) return false ; else curr = 0 ; } curr ++ ; } if ( curr == 1 ) return false ; return true ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 1 , 2 , 2 , 1 , 3 , 3 } ; int n = a . length ; if ( ContinuousElements ( a , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static void maximumCount ( int A [ ] , int B [ ] , int n ) { Queue < Integer > q = new LinkedList < > ( ) ; HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { s . add ( B [ i ] ) ; q . add ( B [ i ] ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( A [ i ] ) ) continue ; while ( ! q . isEmpty ( ) && q . peek ( ) != A [ i ] ) { s . remove ( q . peek ( ) ) ; q . remove ( ) ; count ++ ; } if ( A [ i ] == q . peek ( ) ) { q . remove ( ) ; s . remove ( A [ i ] ) ; } if ( q . isEmpty ( ) ) break ; } System . out . print ( count + "NEW_LINE"); } public static void main ( String [ ] args ) { int N = 4 ; int A [ ] = { 1 , 2 , 3 , 4 } ; int B [ ] = { 1 , 2 , 4 , 3 } ; maximumCount ( A , B , N ) ; } }
import java . util . * ; class GFG { static int count_elements ( int arr [ ] , int n ) { int count = 1 ; int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { count += 1 ; max = arr [ i ] ; } } return count ; } public static void main ( String s [ ] ) { int arr [ ] = { 2 , 1 , 4 , 6 , 3 } ; int n = arr . length ; System . out . print ( count_elements ( arr , n ) ) ; } }
import java . util . * ; class GFG { public static int findSubset ( int [ ] a , int n ) { int sum = 0 ; int cnt = 0 ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( a [ i - 1 ] - i <= 0 ) { sum += a [ i - 1 ] - i ; cnt += 1 ; } else { v . add ( a [ i - 1 ] - i ) ; } } Collections . sort ( v ) ; int ptr = 0 ; while ( ptr < v . size ( ) && sum + v . get ( ptr ) <= 0 ) { cnt += 1 ; ptr += 1 ; sum += v . get ( ptr ) ; } return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 1 , 6 , 7 , 8 , 2 } ; int n = arr . length ; System . out . println ( findSubset ( arr , n ) ) ; } }
import java . util . * ; class GFG { static void checkArray ( int A [ ] , int B [ ] , int N ) { int start = 0 ; int end = N - 1 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { start = i ; break ; } } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( A [ i ] != B [ i ] ) { end = i ; break ; } } Collections . reverse ( Arrays . asList ( A ) ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] != B [ i ] ) { System . out . println ( " No " ) ; return ; } } System . out . println ( " Yes " ) ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 3 , 2 , 4 } ; int B [ ] = { 1 , 2 , 3 , 4 } ; int N = A . length ; checkArray ( A , B , N ) ; } }
import java . util . * ; class GFG { static int get_subset_count ( int arr [ ] , int K , int N ) { Arrays . sort ( arr ) ; int left , right ; left = 0 ; right = N - 1 ; int ans = 0 ; while ( left <= right ) { if ( arr [ left ] + arr [ right ] < K ) { ans += 1 << ( right - left ) ; left ++ ; } else { right -- ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 5 , 7 } ; int K = 8 ; int N = arr . length ; System . out . print ( get_subset_count ( arr , K , N ) ) ; } }
class GFG { static int binary_searched_find_x ( int k ) { int l = 0 ; int r = k ; int ans = 0 ; while ( l <= r ) { int mid = l + ( r - l ) / 2 ; if ( Math . pow ( ( ( mid * ( mid + 1 ) ) / 2 ) , 2 ) >= k ) { ans = mid ; r = mid - 1 ; } else { l = mid + 1 ; } } return ans ; } public static void main ( String [ ] args ) { int N = 100 ; System . out . println ( binary_searched_find_x ( N ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int lenOfLongZigZagArr ( int a [ ] , int n ) { int max = 1 , len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && ( a [ i ] < a [ i + 1 ] ) ) len ++ ; else if ( i % 2 == 1 && ( a [ i ] > a [ i + 1 ] ) ) len ++ ; else { if ( max < len ) max = len ; len = 1 ; } } if ( max < len ) max = len ; return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( lenOfLongZigZagArr ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int checkPerfectSquare ( long N , long start , long last ) { long mid = ( start + last ) / 2 ; if ( start > last ) { return - 1 ; } if ( mid * mid == N ) { return ( int ) mid ; } else if ( mid * mid > N ) { return checkPerfectSquare ( N , start , mid - 1 ) ; } else { return checkPerfectSquare ( N , mid + 1 , last ) ; } } public static void main ( String [ ] args ) { long N = 65 ; System . out . println ( checkPerfectSquare ( N , 1 , N ) ) ; } }
class GFG { static void findSubArray ( int [ ] a , int n , int k ) { int [ ] pref = new int [ n ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i < n - 1 ; ++ i ) { pref [ i ] = pref [ i - 1 ] ; if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) pref [ i ] ++ ; } int peak = 0 , left = 0 ; for ( int i = 0 ; i + k - 1 < n ; ++ i ) if ( pref [ i + k - 2 ] - pref [ i ] > peak ) { peak = pref [ i + k - 2 ] - pref [ i ] ; left = i ; } System . out . print ( " Left ▁ = ▁ " + ( left + 1 ) + "NEW_LINE"); System . out . print ( " Right ▁ = ▁ " + ( left + k ) + "NEW_LINE"); System . out . print ( " Peak ▁ = ▁ " + peak + "NEW_LINE"); } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 3 , 2 , 1 } ; int n = arr . length ; int k = 3 ; findSubArray ( arr , n , k ) ; } }
import java . util . * ; class GFG { static void FindRank ( int arr [ ] , int length ) { System . out . print ( "1" + " ▁ " ) ; for ( int i = 1 ; i < arr . length ; i ++ ) { int rank = 1 ; for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) rank ++ ; } System . out . print ( rank + " ▁ " ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 88 , 14 , 69 , 30 , 29 , 89 } ; int len = arr . length ; FindRank ( arr , len ) ; } }
import java . util . * ; class GFG { static int MAX = 1000005 ; static int [ ] fibUpto = new int [ MAX + 1 ] ; static void compute ( int sz ) { boolean [ ] isFib = new boolean [ sz + 1 ] ; int prev = 0 , curr = 1 ; isFib [ prev ] = isFib [ curr ] = true ; while ( curr <= sz ) { int temp = curr + prev ; if ( temp <= sz ) isFib [ temp ] = true ; prev = curr ; curr = temp ; } fibUpto [ 0 ] = 1 ; for ( int i = 1 ; i <= sz ; i ++ ) { fibUpto [ i ] = fibUpto [ i - 1 ] ; if ( isFib [ i ] ) fibUpto [ i ] ++ ; } } static int countOfNumbers ( int N , int K ) { compute ( N ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - fibUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans > 0 ? N - ans + 1 : 0 ) ; } public static void main ( String [ ] args ) { int N = 10 , K = 3 ; System . out . print ( countOfNumbers ( N , K ) ) ; } }
import java . util . * ; class GFG { static int MAX = 26 ; static Vector < Integer > findCount ( String a [ ] , String b [ ] , int n , int m ) { int [ ] freq = new int [ MAX ] ; Vector < Integer > smallestFreq = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = a [ i ] ; Arrays . fill ( freq , 0 ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { freq [ s . charAt ( j ) - ' a ' ] ++ ; } for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] > 0 ) { smallestFreq . add ( freq [ j ] ) ; break ; } } } Collections . sort ( smallestFreq ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { String s = b [ i ] ; Arrays . fill ( freq , 0 ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { freq [ s . charAt ( j ) - ' a ' ] ++ ; } int frequency = 0 ; for ( int j = 0 ; j < MAX ; j ++ ) { if ( freq [ j ] > 0 ) { frequency = freq [ j ] ; break ; } } int [ ] array = new int [ smallestFreq . size ( ) ] ; int k = 0 ; for ( Integer val : smallestFreq ) { array [ k ] = val ; k ++ ; } int ind = lower_bound ( array , 0 , smallestFreq . size ( ) , frequency ) ; ans . add ( ind ) ; } return ans ; } static int lower_bound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) low = middle + 1 ; else high = middle ; } return low ; } static void printAnswer ( String a [ ] , String b [ ] , int n , int m ) { Vector < Integer > ans = findCount ( a , b , n , m ) ; for ( Integer it : ans ) { System . out . print ( it + " ▁ " ) ; } } public static void main ( String [ ] args ) { String A [ ] = { " aaa " , " aa " , " bdc " } ; String B [ ] = { " cccch " , " cccd " } ; int n = A . length ; int m = B . length ; printAnswer ( A , B , n , m ) ; } }
import java . util . * ; class GFG { static int countLessThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < key ) { l = m + 1 ; index = m ; } else { r = m - 1 ; } } return ( index + 1 ) ; } static int countGreaterThan ( int arr [ ] , int n , int key ) { int l = 0 , r = n - 1 ; int index = - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] <= key ) { l = m + 1 ; } else { r = m - 1 ; index = m ; } } if ( index == - 1 ) return 0 ; return ( n - index ) ; } static int countTriplets ( int n , int a [ ] , int b [ ] , int c [ ] ) { Arrays . sort ( a ) ; Arrays . sort ( b ) ; Arrays . sort ( c ) ; int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int current = b [ i ] ; int low = countLessThan ( a , n , current ) ; int high = countGreaterThan ( c , n , current ) ; count += ( low * high ) ; } return count ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 5 } ; int b [ ] = { 2 , 4 } ; int c [ ] = { 3 , 6 } ; int size = a . length ; System . out . println ( countTriplets ( size , a , b , c ) ) ; } }
import java . util . * ; class GFG { static int divisorcount ( int elem ) { int ans = 0 ; for ( int i = 1 ; i <= Math . sqrt ( elem ) ; i ++ ) { if ( elem % i == 0 ) { if ( i * i == elem ) ans ++ ; else ans += 2 ; } } return ans ; } static String findwinner ( int A [ ] , int B [ ] , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = divisorcount ( A [ i ] ) ; } for ( int i = 0 ; i < M ; i ++ ) { B [ i ] = divisorcount ( B [ i ] ) ; } Arrays . sort ( A ) ; Arrays . sort ( B ) ; int winA = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int val = A [ i ] ; int start = 0 ; int end = M - 1 ; int index = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( B [ mid ] <= val ) { index = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } winA += ( index + 1 ) ; } int winB = N * M - winA ; if ( winA > winB ) { return " A " ; } else if ( winB > winA ) { return " B " ; } return " Draw " ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 12 , 24 } ; int N = A . length ; int B [ ] = { 25 , 28 , 13 , 45 } ; int M = B . length ; System . out . print ( findwinner ( A , B , N , M ) ) ; } }
class GFG { static boolean isPossible ( int arr [ ] , int n , int dist , int k ) { int req = 0 ; int curr = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) { curr ++ ; } req ++ ; if ( curr == n ) { break ; } prev = curr - 1 ; } if ( curr != n ) { return false ; } if ( req <= k ) { return true ; } return false ; } static int minDistance ( int arr [ ] , int n , int k ) { int l = 0 ; int h = arr [ n - 1 ] ; int ans = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( isPossible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else { l = m + 1 ; } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 15 , 36 , 43 } ; int n = arr . length ; int k = 2 ; System . out . println ( minDistance ( arr , n , k ) ) ; } }
class GFG { static int countFactor ( int P , int X ) { if ( X < P ) return 0 ; return ( X / P + countFactor ( P , X / P ) ) ; } static int findSmallestX ( int Y ) { int low = 0 , high = 5 * Y ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( countFactor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; } public static void main ( String args [ ] ) { int Y = 10 ; System . out . println ( findSmallestX ( Y ) ) ; } }
import java . util . * ; class GfG { static boolean prime [ ] = new boolean [ 1000000 + 5 ] ; static void findPrime ( ) { Arrays . fill ( prime , true ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= 1000000 ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= 1000000 ; i += p ) prime [ i ] = false ; } } } static int lenOfLongSubarr ( int arr [ ] , int n ) { Map < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; int sum = 0 , maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += prime [ arr [ i ] ] == false ? - 1 : 1 ; if ( sum == 1 ) maxLen = i + 1 ; else if ( ! um . containsKey ( sum ) ) um . put ( sum , i ) ; if ( um . containsKey ( sum - 1 ) ) { if ( maxLen < ( i - um . get ( sum - 1 ) ) ) maxLen = i - um . get ( sum - 1 ) ; } } return maxLen ; } public static void main ( String [ ] args ) { findPrime ( ) ; int arr [ ] = { 1 , 9 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = arr . length ; System . out . println ( lenOfLongSubarr ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int value ; static boolean canBeOptimalValue ( int K , int arr [ ] , int N , int B ) { int [ ] tmp = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) tmp [ i ] = ( arr [ i ] + K * ( i + 1 ) ) ; Arrays . sort ( tmp ) ; value = 0 ; for ( int i = 0 ; i < K ; i ++ ) value += tmp [ i ] ; return value <= B ; } static void findNoOfElementsandValue ( int arr [ ] , int N , int B ) { int ans = 0 ; value = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( canBeOptimalValue ( mid , arr , N , B ) ) { ans = mid ; start = mid + 1 ; } else end = mid - 1 ; } canBeOptimalValue ( ans , arr , N , B ) ; System . out . print ( ans + " ▁ " + value + "NEW_LINE"); } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 5 , 6 , 3 } ; int N = arr . length ; int B = 90 ; findNoOfElementsandValue ( arr , N , B ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void lexiMiddleSmallest ( int K , int N ) { if ( K % 2 == 0 ) { System . out . print ( K / 2 + " ▁ " ) ; for ( int i = 0 ; i < N - 1 ; ++ i ) { System . out . print ( K + " ▁ " ) ; } System . out . println ( ) ; return ; } ArrayList < Integer > a = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < N / 2 ; ++ i ) { if ( a . get ( a . size ( ) - 1 ) == 1 ) { a . remove ( a . size ( ) - 1 ) ; } else { int t = a . get ( a . size ( ) - 1 ) - 1 ; a . set ( a . get ( a . size ( ) - 1 ) , t ) ; while ( a . size ( ) < N ) { a . add ( K ) ; } } } for ( int i : a ) { System . out . print ( i + " ▁ " ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int K = 2 , N = 4 ; lexiMiddleSmallest ( K , N ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void findPair ( pair arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int a = arr [ i ] . first , b = arr [ i ] . second ; for ( int j = i + 1 ; j < N ; j ++ ) { int c = arr [ j ] . first , d = arr [ j ] . second ; if ( a < c && b > d ) { System . out . println ( " ( " + a + " ▁ " + b + " ) , ▁ ( " + c + " ▁ " + d + " ) " ) ; return ; } } } System . out . println ( " NO ▁ SUCH ▁ PAIR ▁ EXIST " ) ; } public static void main ( String [ ] args ) { pair arr [ ] = { new pair ( 3 , 7 ) , new pair ( 21 , 23 ) , new pair ( 4 , 13 ) , new pair ( 1 , 2 ) , new pair ( 7 , - 1 ) } ; findPair ( arr , 5 ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int maxCostToRemove ( int arr [ ] , int N , int K ) { int maxCost = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N ; i += K ) { maxCost += arr [ i + 1 ] ; } return maxCost ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 1 , 5 , 1 , 5 , 3 } ; int N = arr . length ; int K = 4 ; System . out . print ( maxCostToRemove ( arr , N , K ) ) ; } }
import java . io . * ; class GFG { static boolean checkIfPossibleMerge ( int [ ] A , int [ ] B , int N ) { int i = 0 ; int j = 0 ; int prev = - 1 ; boolean flag = true ; while ( i < N && j < N ) { if ( A [ i ] < B [ j ] && prev != 0 ) { prev = 0 ; i ++ ; } else if ( B [ j ] < A [ i ] && prev != 1 ) { prev = 1 ; j ++ ; } else if ( A [ i ] == B [ j ] ) { if ( prev != 1 ) { prev = 1 ; j ++ ; } else { prev = 0 ; i ++ ; } } else { flag = false ; break ; } } return flag ; } public static void main ( String [ ] args ) { int [ ] A = { 3 , 5 , 8 } ; int [ ] B = { 2 , 4 , 6 } ; int N = A . length ; if ( checkIfPossibleMerge ( A , B , N ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; class GFG { static int maxSum ( int n , int a [ ] , int [ ] [ ] l , int q ) { Vector < Integer > v = new Vector < > ( ) ; int [ ] d = new int [ n ] ; for ( int i = 0 ; i < q ; i ++ ) { for ( int x = l [ i ] [ 0 ] ; x <= l [ i ] [ 1 ] ; x ++ ) { if ( d [ x ] == 0 ) { d [ x ] = 1 ; } } } HashSet < Integer > st = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] == 0 ) { v . add ( a [ i ] ) ; st . add ( i ) ; } } Collections . sort ( v ) ; Collections . reverse ( v ) ; int c = 0 ; for ( int it : st ) { a [ it ] = v . get ( c ) ; c ++ ; } int pref_sum = 0 ; int temp_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { temp_sum += a [ i ] ; pref_sum += temp_sum ; } return pref_sum ; } public static void main ( String [ ] args ) { int [ ] arr = { - 8 , 4 , - 2 , - 6 , 4 , 7 , 1 } ; int N = arr . length ; int [ ] [ ] q = { { 0 , 0 } , { 4 , 5 } } ; int queries = q . length ; System . out . print ( maxSum ( N , arr , q , queries ) ) ; } }
import java . lang . Math ; import java . util . Arrays ; import java . util . Collections ; class GFG { static int MaxRearrngeSum ( Integer A [ ] , Integer B [ ] , int N ) { Arrays . sort ( A ) ; Arrays . sort ( B , Collections . reverseOrder ( ) ) ; int maxSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { maxSum += Math . abs ( A [ i ] - B [ i ] ) ; } return maxSum ; } public static void main ( String [ ] args ) { Integer A [ ] = { 1 , 2 , 2 , 4 , 5 } ; Integer B [ ] = { 5 , 5 , 5 , 6 , 6 } ; int N = A . length ; System . out . println ( MaxRearrngeSum ( A , B , N ) ) ; } }
import java . util . * ; class GFG { static void minHeapify ( int brr [ ] , int i , int M ) { int left = 2 * i + 1 ; int right = 2 * i + 2 ; int smallest = i ; if ( left < M && brr [ left ] < brr [ smallest ] ) { smallest = left ; } if ( right < M && brr [ right ] < brr [ smallest ] ) { smallest = right ; } if ( smallest != i ) { int temp = brr [ i ] ; brr [ i ] = brr [ smallest ] ; brr [ smallest ] = temp ; minHeapify ( brr , smallest , M ) ; } } static void merge ( int arr [ ] , int brr [ ] , int N , int M ) { for ( int i = 0 ; i < N ; ++ i ) { if ( arr [ i ] > brr [ 0 ] ) { int temp = arr [ i ] ; arr [ i ] = brr [ 0 ] ; brr [ 0 ] = temp ; minHeapify ( brr , 0 , M ) ; } } Arrays . sort ( brr ) ; } static void printArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 23 , 35 , 235 , 2335 } ; int brr [ ] = { 3 , 5 } ; int N = arr . length ; int M = brr . length ; merge ( arr , brr , N , M ) ; printArray ( arr , N ) ; printArray ( brr , M ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void maxArea ( int [ ] point_x , int [ ] point_y , int n , int length , int width ) { Arrays . sort ( point_x ) ; Arrays . sort ( point_y ) ; int dx = point_x [ 0 ] ; int dy = point_y [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { dx = Math . max ( dx , point_x [ i ] - point_x [ i - 1 ] ) ; dy = Math . max ( dy , point_y [ i ] - point_y [ i - 1 ] ) ; } dx = Math . max ( dx , ( length + 1 ) - point_x [ n - 1 ] ) ; dy = Math . max ( dy , ( width + 1 ) - point_y [ n - 1 ] ) ; System . out . println ( ( dx - 1 ) * ( dy - 1 ) ) ; } public static void main ( String [ ] args ) { int length = 15 , width = 8 ; int n = 3 ; int point_x [ ] = { 3 , 11 , 8 } ; int point_y [ ] = { 8 , 2 , 6 } ; maxArea ( point_x , point_y , n , length , width ) ; } }
import java . util . * ; class GFG { static int findMaxValue ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int ans = arr [ n - 1 ] ; int maxPossible = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( maxPossible > 0 ) { if ( arr [ i ] >= maxPossible ) { ans += ( maxPossible - 1 ) ; maxPossible = maxPossible - 1 ; } else { maxPossible = arr [ i ] ; ans += maxPossible ; } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 4 , 1 , 5 } ; int n = arr . length ; System . out . print ( findMaxValue ( arr , n ) ) ; } }
import java . util . * ; class GFG { static void lexNumbers ( int n ) { Vector < String > s = new Vector < String > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { s . add ( String . valueOf ( i ) ) ; } Collections . sort ( s ) ; Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ans . add ( Integer . valueOf ( s . get ( i ) ) ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 15 ; lexNumbers ( n ) ; } }
import java . util . * ; class GFG { static void sortedAdjacentDifferences ( int arr [ ] , int n ) { int [ ] ans = new int [ n ] ; Arrays . sort ( arr ) ; int l = 0 , r = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 == 1 ) { ans [ i ] = arr [ l ] ; l ++ ; } else { ans [ i ] = arr [ r ] ; r -- ; } } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 5 , - 2 , 4 , 8 , 6 , 4 , 5 } ; int n = arr . length ; sortedAdjacentDifferences ( arr , n ) ; } }
import java . util . * ; class GFG { static boolean checkIsAP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; double d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] - arr [ i - 1 ] != d ) { return false ; } } return true ; } static boolean checkIsGP ( double arr [ ] , int n ) { if ( n == 1 ) return true ; Arrays . sort ( arr ) ; double r = arr [ 1 ] / arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] / arr [ i - 1 ] != r ) return false ; } return true ; } static boolean checkIsHP ( double arr [ ] , int n ) { if ( n == 1 ) { return true ; } double [ ] rec = new double [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { rec [ i ] = ( ( 1 / arr [ i ] ) ) ; } if ( checkIsAP ( rec , n ) ) return true ; else return false ; } public static void main ( String [ ] args ) { double arr [ ] = { 1.0 / 5.0 , 1.0 / 10.0 , 1.0 / 15.0 , 1.0 / 20.0 } ; int n = arr . length ; int flag = 0 ; if ( checkIsAP ( arr , n ) ) { System . out . print ( " Yes , ▁ An ▁ AP ▁ can ▁ be ▁ formed " + "NEW_LINE"); flag = 1 ; } if ( checkIsGP ( arr , n ) ) { System . out . print ( " Yes , ▁ A ▁ GP ▁ can ▁ be ▁ formed " + "NEW_LINE"); flag = 1 ; } if ( checkIsHP ( arr , n ) ) { System . out . print ( " Yes , ▁ A ▁ HP ▁ can ▁ be ▁ formed " + "NEW_LINE"); flag = 1 ; } else if ( flag == 0 ) { System . out . print ( " No " ) ; } } }
import java . util . * ; class GFG { static int sortByFreq ( Integer [ ] arr , int n ) { int maxE = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { maxE = Math . max ( maxE , arr [ i ] ) ; } int freq [ ] = new int [ maxE + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i <= maxE ; i ++ ) { if ( freq [ i ] > 0 ) { int value = 100000 - i ; arr [ cnt ] = 100000 * freq [ i ] + value ; cnt ++ ; } } return cnt ; } static void printSortedArray ( Integer [ ] arr , int cnt ) { for ( int i = 0 ; i < cnt ; i ++ ) { int frequency = arr [ i ] / 100000 ; int value = 100000 - ( arr [ i ] % 100000 ) ; for ( int j = 0 ; j < frequency ; j ++ ) { System . out . print ( value + " ▁ " ) ; } } } public static void main ( String [ ] args ) { Integer arr [ ] = { 4 , 4 , 5 , 6 , 4 , 2 , 2 , 8 , 5 } ; int n = arr . length ; int cnt = sortByFreq ( arr , n ) ; Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; printSortedArray ( arr , cnt ) ; } }
class GFG { static int max_element ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < arr [ i ] ) max = arr [ i ] ; } return max ; } static int maxMod ( int arr [ ] , int n ) { int maxVal = max_element ( arr , n ) ; int secondMax = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < maxVal && arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return secondMax ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 1 , 5 , 3 , 6 } ; int n = arr . length ; System . out . println ( maxMod ( arr , n ) ) ; } }
import java . util . * ; class GFG { static boolean isPossible ( int A [ ] , int B [ ] , int n , int m , int x , int y ) { if ( x > n y > m ) return false ; Arrays . sort ( A ) ; Arrays . sort ( B ) ; if ( A [ x - 1 ] < B [ m - y ] ) return true ; else return false ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 1 , 1 , 1 , 1 } ; int B [ ] = { 2 , 2 } ; int n = A . length ; int m = B . length ; ; int x = 3 , y = 1 ; if ( isPossible ( A , B , n , m , x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int getNumber ( int n , int k ) { int [ ] arr = new int [ n ] ; int i = 0 ; int odd = 1 ; while ( odd <= n ) { arr [ i ++ ] = odd ; odd += 2 ; } int even = 2 ; while ( even <= n ) { arr [ i ++ ] = even ; even += 2 ; } return arr [ k - 1 ] ; } public static void main ( String [ ] args ) { int n = 8 , k = 5 ; System . out . println ( getNumber ( n , k ) ) ; } }
import java . util . * ; class GFG { static int MAX = 100005 ; static int Min_Replace ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; Integer [ ] freq = new Integer [ MAX ] ; Arrays . fill ( freq , 0 ) ; int p = 0 ; freq [ p ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) ++ freq [ p ] ; else ++ freq [ ++ p ] ; } Arrays . sort ( freq , Collections . reverseOrder ( ) ) ; int ans = 0 ; for ( int i = k ; i <= p ; i ++ ) ans += freq [ i ] ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 7 , 8 , 2 , 3 , 2 , 3 } ; int n = arr . length ; int k = 2 ; System . out . println ( Min_Replace ( arr , n , k ) ) ; } }
import java . util . * ; class GFG { static int Segment ( int x [ ] , int l [ ] , int n ) { if ( n == 1 ) return 1 ; int ans = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( x [ i ] - l [ i ] > x [ i - 1 ] ) ans ++ ; else if ( x [ i ] + l [ i ] < x [ i + 1 ] ) { x [ i ] = x [ i ] + l [ i ] ; ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int x [ ] = { 1 , 3 , 4 , 5 , 8 } , l [ ] = { 10 , 1 , 2 , 2 , 5 } ; int n = x . length ; System . out . println ( Segment ( x , l , n ) ) ; } }
import java . util . Arrays ; class GFG { static void printArrangement ( int a [ ] , int n ) { Arrays . sort ( a ) ; int b [ ] = new int [ n ] ; int low = 0 , high = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) b [ low ++ ] = a [ i ] ; else b [ high -- ] = a [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { if ( b [ n - 1 ] + b [ 1 ] <= b [ i ] ) { System . out . print ( - 1 ) ; return ; } } else if ( i == ( n - 1 ) ) { if ( b [ n - 2 ] + b [ 0 ] <= b [ i ] ) { System . out . print ( - 1 ) ; return ; } } else { if ( b [ i - 1 ] + b [ i + 1 ] <= b [ i ] ) { System . out . print ( - 1 ) ; return ; } } } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( b [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 4 , 4 , 3 , 2 } ; int n = a . length ; printArrangement ( a , n ) ; } }
import java . io . * ; class GFG { static int N = 2 ; static int M = 2 ; static boolean isMatrixInc ( int a [ ] [ ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( i - 1 >= 0 ) { if ( a [ i ] [ j ] <= a [ i - 1 ] [ j ] ) return false ; } if ( j - 1 >= 0 ) { if ( a [ i ] [ j ] <= a [ i ] [ j - 1 ] ) return false ; } } } return true ; } public static void main ( String [ ] args ) { int a [ ] [ ] = { { 2 , 10 } , { 11 , 20 } } ; if ( isMatrixInc ( a ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class GFG { static int N = 10000005 ; static int [ ] prime = new int [ N ] ; static void seive ( ) { for ( int i = 2 ; i < N ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i + i ; j < N ; j += i ) { prime [ j ] = 1 ; } } } prime [ 1 ] = 1 ; } static int maxSizeArr ( int arr [ ] , int n , int k ) { ArrayList < Integer > v = new ArrayList < Integer > ( ) ; ArrayList < Integer > diff = new ArrayList < Integer > ( ) ; int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 1 ) { v . add ( i ) ; } } num = 0 ; for ( int i = 1 ; i < v . size ( ) ; i ++ ) { diff . add ( v . get ( i ) - v . get ( i - 1 ) - 1 ) ; } Collections . sort ( diff ) ; for ( int i = 1 ; i < diff . size ( ) ; i ++ ) { diff . set ( i , diff . get ( i ) + diff . get ( i - 1 ) ) ; } if ( k > n || ( k == 0 && v . size ( ) > 0 ) ) { return - 1 ; } else if ( v . size ( ) <= k ) { return ( n - k ) ; } else if ( v . size ( ) > k ) { int tt = v . size ( ) - k ; int sum = 0 ; sum += diff . get ( tt - 1 ) ; int res = n - ( v . size ( ) + sum ) ; return res ; } return 1 ; } public static void main ( String [ ] args ) { seive ( ) ; int [ ] arr = { 2 , 4 , 2 , 2 , 4 , 2 , 4 , 2 } ; int n = arr . length ; int k = 2 ; System . out . println ( maxSizeArr ( arr , n , k ) ) ; } }
import java . util . * ; class GFG { static class Node { int data ; Node next ; } ; static Node start ; static void sortList ( Node head ) { int startVal = 1 ; while ( head != null ) { head . data = startVal ; startVal ++ ; head = head . next ; } } static void push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; start = head_ref ; } static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " ▁ " ) ; node = node . next ; } } public static void main ( String [ ] args ) { start = null ; push ( start , 2 ) ; push ( start , 1 ) ; push ( start , 6 ) ; push ( start , 4 ) ; push ( start , 5 ) ; push ( start , 3 ) ; sortList ( start ) ; printList ( start ) ; } }
import java . util . * ; class GFG { public static int countTripletsLessThan ( int [ ] arr , int n , int val ) { Arrays . sort ( arr ) ; int ans = 0 ; int j , k ; int sum ; for ( int i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; } public static int countTriplets ( int arr [ ] , int n , int a , int b ) { int res ; res = countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ; return res ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = arr . length ; int a = 8 , b = 16 ; System . out . println ( " " + countTriplets ( arr , n , a , b ) ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int maxLevel ( int [ ] boxes , int n ) { Arrays . sort ( boxes ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; } static public void main ( String [ ] args ) { int [ ] boxes = { 10 , 20 , 30 , 50 , 60 , 70 } ; int n = boxes . length ; System . out . println ( maxLevel ( boxes , n ) ) ; } }
import java . io . * ; class GFG { static int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; } static int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; } static int countSwaps ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; return _mergeSort ( arr , temp , 0 , n - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = arr . length ; System . out . println ( " Number ▁ of ▁ swaps ▁ is ▁ " + countSwaps ( arr , n ) ) ; } }
class GFG { static int minimumSizeArray ( int S , int P ) { if ( S == P ) { return 1 ; } for ( int i = 2 ; i <= S ; i ++ ) { double d = i ; if ( ( S / d ) >= Math . pow ( P , 1.0 / d ) ) { return i ; } } return - 1 ; } public static void main ( String args [ ] ) { int S = 5 , P = 6 ; System . out . println ( minimumSizeArray ( S , P ) ) ; } }
import java . util . * ; class GFG { static int maxSubseq ( int arr [ ] , int N , int K ) { int sum = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( K == 0 ) break ; if ( arr [ i ] < 0 ) { arr [ i ] = - arr [ i ] ; K -- ; } } for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] > 0 ) sum += arr [ i ] ; return sum ; } public static void main ( String [ ] args ) { int [ ] arr = { 6 , - 10 , - 1 , 0 , - 4 , 2 } ; int K = 2 ; int N = arr . length ; System . out . println ( maxSubseq ( arr , N , K ) ) ; } }
import java . io . * ; class GFG { static void printTheArray ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void rearrange ( int arr [ ] , int N ) { if ( ( N & 1 ) != 0 ) N -- ; int odd_idx = 1 , even_idx = 0 ; int i , max_elem = arr [ N - 1 ] + 1 ; for ( i = 0 ; i < N / 2 ; i ++ ) { arr [ i ] += ( arr [ odd_idx ] % max_elem ) * max_elem ; odd_idx += 2 ; } for ( ; i < N ; i ++ ) { arr [ i ] += ( arr [ even_idx ] % max_elem ) * max_elem ; even_idx += 2 ; } for ( i = 0 ; i < N ; i ++ ) { arr [ i ] = arr [ i ] / max_elem ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 16 , 18 , 19 } ; int N = arr . length ; rearrange ( arr , N ) ; printTheArray ( arr , N ) ; } }
import java . util . * ; class GFG { static boolean check ( int num ) { int sm = 0 ; int num2 = num * num ; while ( num > 0 ) { sm += num % 10 ; num /= 10 ; } int sm2 = 0 ; while ( num2 > 0 ) { sm2 += num2 % 10 ; num2 /= 10 ; } return ( ( sm * sm ) == sm2 ) ; } static int convert ( String s ) { int val = 0 ; s = reverse ( s ) ; int cur = 1 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { val += ( s . charAt ( i ) - '0' ) * cur ; cur *= 10 ; } return val ; } static void generate ( String s , int len , HashSet < Integer > uniq ) { if ( s . length ( ) == len ) { if ( check ( convert ( s ) ) ) { uniq . add ( convert ( s ) ) ; } return ; } for ( int i = 0 ; i <= 3 ; i ++ ) { generate ( s + ( char ) ( i + '0' ) , len , uniq ) ; } } static String reverse ( String input ) { char [ ] a = input . toCharArray ( ) ; int l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . valueOf ( a ) ; } static int totalNumbers ( int L , int R ) { int ans = 0 ; int max_len = ( int ) ( Math . log10 ( R ) + 1 ) ; HashSet < Integer > uniq = new HashSet < Integer > ( ) ; for ( int i = 1 ; i <= max_len ; i ++ ) { generate ( " " , i , uniq ) ; } for ( int x : uniq ) { if ( x >= L && x <= R ) { ans ++ ; } } return ans ; } public static void main ( String [ ] args ) { int L = 22 , R = 22 ; System . out . print ( totalNumbers ( L , R ) ) ; } }
import java . util . * ; class GFG { static int countArrays ( int n , int k ) { Vector < Integer > [ ] divisors = new Vector [ k + 1 ] ; for ( int i = 0 ; i < divisors . length ; i ++ ) divisors [ i ] = new Vector < Integer > ( ) ; for ( int i = 1 ; i <= k ; i ++ ) { for ( int j = 2 * i ; j <= k ; j += i ) { divisors [ j ] . add ( i ) ; } } int [ ] [ ] dp = new int [ n + 1 ] [ k + 1 ] ; for ( int j = 1 ; j <= k ; j ++ ) { dp [ 1 ] [ j ] = 1 ; } for ( int x = 2 ; x <= n ; x ++ ) { int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ x - 1 ] [ j ] ; } for ( int y = 1 ; y <= k ; y ++ ) { dp [ x ] [ y ] = sum ; for ( int d : divisors [ y ] ) { dp [ x ] [ y ] = ( dp [ x ] [ y ] - dp [ x - 1 ] [ d ] ) ; } } } int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum += dp [ n ] [ j ] ; } return sum ; } public static void main ( String [ ] args ) { int N = 2 , K = 3 ; System . out . print ( countArrays ( N , K ) ) ; } }
class GFG { public static int findMaximumPoints ( int N , int X [ ] , int H [ ] ) { int ans = 0 ; int prev = Integer . MIN_VALUE ; for ( int i = 0 ; i < N ; ++ i ) { if ( prev < ( X [ i ] - H [ i ] ) ) { ++ ans ; prev = X [ i ] ; } else if ( i == N - 1 || ( X [ i ] + H [ i ] ) < X [ i + 1 ] ) { ++ ans ; prev = X [ i ] + H [ i ] ; } else { prev = X [ i ] ; } } return ans ; } public static void main ( String args [ ] ) { int X [ ] = { 1 , 2 , 3 } ; int H [ ] = { 2 , 5 , 5 } ; int N = X . length ; System . out . println ( findMaximumPoints ( N , X , H ) ) ; } }
import java . util . * ; public class MyClass { static void possibleNumbers ( Set < Integer > numbers , int N , int M , int A , int B ) { if ( M == 0 ) { numbers . add ( N ) ; return ; } possibleNumbers ( numbers , N + A , M - 1 , A , B ) ; possibleNumbers ( numbers , N + B , M - 1 , A , B ) ; } public static void main ( String args [ ] ) { int N = 5 , M = 3 , A = 4 , B = 6 ; Set < Integer > numbers = new HashSet < Integer > ( ) ; possibleNumbers ( numbers , N , M , A , B ) ; Iterator < Integer > i = numbers . iterator ( ) ; while ( i . hasNext ( ) ) System . out . print ( i . next ( ) + " ▁ " ) ; } }
import java . io . * ; class GFG { static int reduceToOne ( long N ) { int cnt = 0 ; while ( N != 1 ) { if ( N == 2 || ( N % 2 == 1 ) ) { N = N - 1 ; cnt ++ ; } else if ( N % 2 == 0 ) { N = N / ( N / 2 ) ; cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { long N = 35 ; System . out . println ( reduceToOne ( N ) ) ; } }
import java . util . Vector ; class GFG { static void solve ( int S , int K , int N ) { if ( K > N ) { System . out . println ( " - 1" ) ; return ; } int max_sum = 0 , min_sum = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { min_sum += i ; max_sum += N - i + 1 ; } if ( S < min_sum S > max_sum ) { System . out . println ( " - 1" ) ; return ; } int s1 = 0 ; Vector < Integer > nums = new Vector < > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( s1 > S ) break ; s1 += i ; nums . add ( i ) ; } Vector < Integer > answer = new Vector < > ( ) ; int s2 = 0 ; for ( int i = 0 ; i < K - 1 ; i ++ ) { answer . add ( nums . get ( i ) ) ; s2 += nums . get ( i ) ; } answer . add ( S - s2 ) ; int Max = N ; for ( int i = answer . size ( ) - 1 ; i >= 0 ; i -- ) { if ( answer . get ( i ) > Max ) { int extra = answer . get ( i ) - Max ; if ( i - 1 >= 0 ) answer . set ( i - 1 , answer . get ( i - 1 ) + extra ) ; answer . set ( i , Max ) ; Max -- ; } else break ; } for ( int x : answer ) System . out . print ( x + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int S = 15 , K = 4 , N = 8 ; solve ( S , K , N ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void minSizeArr ( int A [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += A [ i ] ; if ( K > sum ) { System . out . print ( - 1 ) ; return ; } if ( K == sum ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( A [ i ] + " ▁ " ) ; } return ; } int tar = sum - K ; HashMap < Integer , Integer > um = new HashMap < Integer , Integer > ( ) ; um . put ( 0 , - 1 ) ; int left = 0 , right = 0 ; int cur = 0 , maxi = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { cur += A [ i ] ; if ( um . containsKey ( cur - tar ) && i - um . get ( cur - tar ) > maxi ) { maxi = i - um . get ( cur - tar ) ; right = i ; left = um . get ( cur - tar ) ; } if ( ! um . containsKey ( cur ) ) um . put ( cur , i ) ; } if ( maxi == - 1 ) System . out . println ( - 1 ) ; else { for ( int i = 0 ; i <= left ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; for ( int i = 0 ; i < right ; i ++ ) System . out . print ( A [ N - i - 1 ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 7 ; int A [ ] = { 3 , 2 , 1 , 1 , 1 , 1 , 3 } ; int K = 10 ; minSizeArr ( A , N , K ) ; } }
import java . util . * ; class GFG { static void findEquation ( int A , int B , int C , int K ) { System . out . print ( A + " ▁ " + K * B + " ▁ " + K * K * C ) ; } public static void main ( String [ ] args ) { int A = 1 , B = 2 , C = 1 , K = 2 ; findEquation ( A , B , C , K ) ; } }
import java . io . * ; class GFG { static void canArrayBeReduced ( int [ ] arr , int N ) { if ( N == 1 ) { System . out . print ( arr [ 0 ] ) ; return ; } if ( arr [ 0 ] < arr [ N - 1 ] ) { System . out . print ( arr [ N - 1 ] ) ; } else System . out . print ( " Not ▁ Possible " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 6 , 5 , 2 , 4 , 1 , 3 , 7 } ; int N = arr . length ; canArrayBeReduced ( arr , N ) ; } }
import java . util . * ; class GFG { static void constructArray ( int arr [ ] , int N ) { int brr [ ] = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { int K = ( int ) ( Math . log ( arr [ i ] ) / Math . log ( 2 ) ) ; int R = ( int ) Math . pow ( 2 , K ) ; brr [ i ] = R ; } for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( brr [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 11 , 5 , 7 , 3 , 2 } ; int N = arr . length ; constructArray ( arr , N ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void minOpsToTurnArrToZero ( int [ ] arr , int N ) { Set < Integer > st = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( st . contains ( arr [ i ] ) arr [ i ] == 0 ) { continue ; } else { st . add ( arr [ i ] ) ; } } System . out . println ( st . size ( ) ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 3 , 7 , 3 } ; int N = arr . length ; minOpsToTurnArrToZero ( arr , N ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean CheckAllEqual ( int arr [ ] , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ 0 ] != arr [ i ] ) { return false ; } } return true ; } static int minCntOperations ( int arr [ ] , int N ) { int Max = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; boolean isPower2 ; if ( ( int ) ( Math . ceil ( ( Math . log ( N ) / Math . log ( N ) ) ) ) == ( int ) ( Math . floor ( ( ( Math . log ( N ) / Math . log ( 2 ) ) ) ) ) ) { isPower2 = true ; } else { isPower2 = false ; } if ( isPower2 && CheckAllEqual ( arr , N ) ) { return ( int ) ( Math . log ( Max ) / Math . log ( 2 ) ) ; } else { return ( int ) Math . ceil ( Math . log ( Max ) / Math . log ( 2 ) ) + 1 ; } } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 2 , 4 } ; int N = arr . length ; System . out . println ( minCntOperations ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int findMaxValByRearrArr ( int arr [ ] , int N ) { Arrays . sort ( arr ) ; int res = 0 ; do { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += __gcd ( i + 1 , arr [ i ] ) ; } res = Math . max ( res , sum ) ; } while ( next_permutation ( arr ) ) ; return res ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static boolean next_permutation ( int [ ] p ) { for ( int a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { int t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 } ; int N = arr . length ; System . out . print ( findMaxValByRearrArr ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int sumzero ( int arr [ ] , int N , int K ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } if ( sum == 0 ) System . out . print ( " Yes " ) ; else if ( sum > 0 ) { if ( sum % K == 0 ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } else System . out . print ( " No " ) ; return 0 ; } public static void main ( String [ ] args ) { int K , N ; int arr1 [ ] = { 1 , - 6 , 2 , 2 } ; K = 1 ; N = arr1 . length ; sumzero ( arr1 , N , K ) ; } }
import java . util . * ; class GFG { static void path_to_root ( int node ) { while ( node >= 1 ) { System . out . print ( node + " ▁ " ) ; node /= 2 ; } } public static void main ( String [ ] args ) { int N = 7 ; path_to_root ( N ) ; } }
import java . io . * ; class GFG { static void findSmallestNumberPossible ( int N , int K ) { if ( N > 45 * K ) { System . out . print ( " - 1" ) ; return ; } StringBuilder res = new StringBuilder ( ) ; int count = 0 ; for ( int i = 9 ; i >= 1 { if ( count == K ) { i -- ; count = 0 ; } if ( N > i ) { N -= i ; res . append ( ( char ) ( '0' + i ) ) ; } else { res . append ( ( char ) ( '0' + N ) ) ; N = 0 ; break ; } count ++ ; } res . reverse ( ) ; System . out . print ( res . toString ( ) ) ; } public static void main ( String [ ] args ) { int N = 25 , K = 3 ; findSmallestNumberPossible ( N , K ) ; } }
import java . util . * ; class GFG { static void result ( int n ) { if ( n > 45 ) { System . out . print ( - 1 ) ; return ; } String res = " " ; int digit = 9 ; while ( n > digit ) { res = ( char ) ( '0' + digit ) + res ; n -= digit ; digit -= 1 ; } if ( n > 0 ) { res = ( char ) ( '0' + n ) + res ; } System . out . print ( res ) ; } public static void main ( String [ ] args ) { int N = 19 ; result ( N ) ; } }
class GFG { static void findNumbers ( int aXORb , int aANDb , int aXORc , int aANDc , int bXORc , int bANDc ) { int a , b , c ; int aSUMb ; int aSUMc ; int bSUMc ; aSUMb = aXORb + aANDb * 2 ; aSUMc = aXORc + aANDc * 2 ; bSUMc = bXORc + bANDc * 2 ; a = ( aSUMb - bSUMc + aSUMc ) / 2 ; b = aSUMb - a ; c = aSUMc - a ; System . out . print ( " a ▁ = ▁ " + a ) ; System . out . print ( " , ▁ b ▁ = ▁ " + b ) ; System . out . print ( " , ▁ c ▁ = ▁ " + c ) ; } public static void main ( String [ ] args ) { int aXORb = 30 , aANDb = 0 , aXORc = 20 , aANDc = 10 , bXORc = 10 , bANDc = 20 ; findNumbers ( aXORb , aANDb , aXORc , aANDc , bXORc , bANDc ) ; } }
import java . util . * ; class GFG { static int findNumber ( int N ) { return N & ( N + 1 ) ; } public static void main ( String [ ] args ) { int N = 39 ; System . out . print ( findNumber ( N ) ) ; } }
class GFG { static int findBitwiseORGivenXORAND ( int X , int Y ) { return X + Y ; } public static void main ( String [ ] args ) { int X = 5 , Y = 2 ; System . out . print ( findBitwiseORGivenXORAND ( X , Y ) ) ; } }
import java . util . * ; class GFG { static void minOperation ( int X [ ] , int Y [ ] , int n ) { int C = 0 ; int count = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; count = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) { if ( X [ i ] != Y [ i ] ) { count ++ ; } else { if ( count != 0 ) C ++ ; count = 0 ; } } if ( count != 0 ) C ++ ; System . out . print ( C ) ; } public static void main ( String [ ] args ) { int X [ ] = { 1 , 0 , 0 , 0 , 0 , 1 } ; int Y [ ] = { 1 , 1 , 0 , 1 , 1 , 1 } ; int N = X . length ; minOperation ( X , Y , N ) ; } }
class GFG { static void Remove_one_element ( int arr [ ] , int n ) { int post_odd = 0 , post_even = 0 ; int curr_odd = 0 , curr_even = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i % 2 != 0 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) post_odd ^= arr [ i ] ; else post_even ^= arr [ i ] ; int X = curr_odd ^ post_even ; int Y = curr_even ^ post_odd ; if ( X == Y ) res ++ ; if ( i % 2 != 0 ) curr_odd ^= arr [ i ] ; else curr_even ^= arr [ i ] ; } System . out . println ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 } ; int N = arr . length ; Remove_one_element ( arr , N ) ; } }
import java . io . * ; class GFG { public void minCost ( int [ ] arr ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } System . out . print ( Math . min ( even , odd ) ) ; } public static void main ( String [ ] args ) { GFG obj = new GFG ( ) ; int arr [ ] = { 1 , 2 , 3 } ; obj . minCost ( arr ) ; } }
import java . util . * ; class solution { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static int findPartition ( int nums [ ] , int N ) { int [ ] prefix = new int [ N ] ; int [ ] suffix = new int [ N ] ; int i , k ; prefix [ 0 ] = nums [ 0 ] ; for ( i = 1 ; i < N ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] * nums [ i ] ; } suffix [ N - 1 ] = nums [ N - 1 ] ; for ( i = N - 2 ; i >= 0 ; i -- ) { suffix [ i ] = suffix [ i + 1 ] * nums [ i ] ; } for ( k = 0 ; k < N - 1 ; k ++ ) { if ( GCD ( prefix [ k ] , suffix [ k + 1 ] ) == 1 ) { return k ; } } return - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int N = arr . length ; System . out . println ( findPartition ( arr , N ) ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void palindromeMatrix ( int N , int M , int [ ] [ ] arr ) { int ans = 0 ; for ( int i = 0 ; i < ( N + 1 ) / 2 ; i ++ ) { for ( int j = 0 ; j < ( M + 1 ) / 2 ; j ++ ) { HashSet < pair > s = new HashSet < > ( ) ; s . add ( new pair ( i , j ) ) ; s . add ( new pair ( i , M - j - 1 ) ) ; s . add ( new pair ( N - i - 1 , j ) ) ; s . add ( new pair ( N - i - 1 , M - j - 1 ) ) ; Vector < Integer > values = new Vector < > ( ) ; for ( pair p : s ) { values . add ( arr [ p . first ] [ p . second ] ) ; } int max = Collections . max ( values ) ; for ( int k = 1 ; k < values . size ( ) ; k ++ ) { ans += max - values . get ( k ) ; } } } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 ; int [ ] [ ] arr = { { 1 , 2 , 1 } , { 3 , 4 , 1 } , { 1 , 2 , 1 } } ; palindromeMatrix ( N , M , arr ) ; } }
import java . io . * ; import java . util . * ; class GFG { static ArrayList < Integer > rearrangeArray ( ArrayList < Integer > A , ArrayList < Integer > B , int N ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; int xor_value = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xor_value ^= A . get ( i ) ; xor_value ^= B . get ( i ) ; m . put ( B . get ( i ) , m . getOrDefault ( B . get ( i ) + 1 , 0 ) ) ; } for ( int i = 0 ; i < N ; i ++ ) { B . set ( i , A . get ( i ) ^ xor_value ) ; if ( m . getOrDefault ( B . get ( i ) , - 1 ) != - 1 ) { m . put ( B . get ( i ) , m . getOrDefault ( B . get ( i ) , 0 ) - 1 ) ; } else return ( new ArrayList < Integer > ( ) ) ; } return B ; } static void rearrangeArrayUtil ( ArrayList < Integer > A , ArrayList < Integer > B , int N ) { ArrayList < Integer > ans = rearrangeArray ( A , B , N ) ; if ( ans . size ( ) != 0 ) { for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { System . out . print ( ans . get ( i ) + " ▁ " ) ; } } else { System . out . println ( " - 1" ) ; } } public static void main ( String [ ] args ) { ArrayList < Integer > A = new ArrayList < Integer > ( Arrays . asList ( 13 , 21 , 33 , 49 , 53 ) ) ; ArrayList < Integer > B = new ArrayList < Integer > ( Arrays . asList ( 54 , 50 , 34 , 22 , 14 ) ) ; int N = ( int ) A . size ( ) ; rearrangeArrayUtil ( A , B , N ) ; } }
import java . util . * ; class GFG { static void countOfSubarray ( int arr [ ] , int N ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; int answer = 0 ; int sum = 0 ; if ( mp . get ( 1 ) != null ) mp . put ( 1 , mp . get ( 1 ) + 1 ) ; else mp . put ( 1 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; if ( mp . get ( sum - i ) != null ) answer += mp . get ( sum - i ) ; if ( mp . get ( sum - i ) != null ) mp . put ( sum - i , mp . get ( sum - i ) + 1 ) ; else mp . put ( sum - i , 1 ) ; } System . out . print ( answer ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 2 , 1 , 2 , - 2 , 2 , 4 } ; int N = arr . length ; countOfSubarray ( arr , N ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void countInverse ( int [ ] arr , int N , int M ) { int XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int gcdOfMandelement = gcd ( M , arr [ i ] ) ; if ( gcdOfMandelement == 1 ) { XOR ^= arr [ i ] ; } } System . out . println ( XOR ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 } ; int M = 4 ; int N = arr . length ; countInverse ( arr , N , M ) ; } }
class GFG { public static int TotalXorPair ( int arr [ ] , int N ) { int totalXOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { totalXOR ^= arr [ i ] ^ arr [ j ] ; } } return totalXOR ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = arr . length ; System . out . print ( TotalXorPair ( arr , N ) ) ; } }
import java . util . * ; class GFG { static void possibleAcyclicGraph ( int N ) { System . out . print ( ( int ) Math . pow ( 2 , N - 1 ) ) ; return ; } public static void main ( String [ ] args ) { int N = 4 ; possibleAcyclicGraph ( N ) ; } }
import java . io . * ; class GFG { static boolean isComposite ( int N ) { for ( int i = 2 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { return true ; } } return false ; } static int compositePair ( int arr [ ] , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { int prod = arr [ i ] * arr [ j ] ; if ( isComposite ( prod ) ) { res ++ ; } } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 2 , 8 } ; int N = arr . length ; System . out . println ( compositePair ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int find_next ( int n , int k ) { int M = n + 1 ; while ( true ) { if ( ( M & ( 1L << k ) ) > 0 ) break ; M ++ ; } return M ; } public static void main ( String [ ] args ) { int N = 15 , K = 2 ; System . out . print ( find_next ( N , K ) ) ; } }
import java . util . * ; class GFG { static int maximumSubarrays ( int arr [ ] , int N , int target ) { int ans = 0 ; int availIdx = - 1 ; int cur_sum = 0 ; HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; mp . put ( 0 , 1 ) ; for ( int i = 0 ; i < N ; i ++ ) { cur_sum += arr [ i ] ; if ( mp . containsKey ( cur_sum - target ) && mp . get ( cur_sum - target ) >= availIdx ) { ans ++ ; availIdx = i ; } mp . put ( cur_sum , i ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , - 1 , 4 , 3 , 6 , 4 , 5 , 1 } ; int N = arr . length ; int target = 6 ; System . out . print ( maximumSubarrays ( arr , N , target ) ) ; } }
import java . util . * ; class GFG { static int getCount ( int N , int M ) { int total_count = 0 ; total_count += ( N / 10 ) ; int x = ( N / 10 ) * 10 ; if ( ( N - x ) >= M ) { total_count = total_count + 1 ; } return total_count ; } public static void main ( String [ ] args ) { int N = 100 , M = 1 ; System . out . print ( getCount ( N , M ) ) ; } }
import java . util . * ; class GFG { static int digitsOf ( int num ) { return Integer . toString ( num ) . length ( ) ; } static int count ( int a , int tn ) { int diff = ( int ) Math . pow ( 10 , digitsOf ( a ) ) ; return ( ( tn - a ) / diff ) + 1 ; } public static void main ( String [ ] args ) { int n = 25 , m = 4500 ; System . out . println ( count ( n , m ) ) ; } }
import java . util . * ; class GFG { static int minOperations ( int a [ ] , int N ) { int num_of_ops1 , num_of_ops2 , sum ; num_of_ops1 = num_of_ops2 = sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 0 && sum >= 0 ) { num_of_ops1 += ( 1 + Math . abs ( sum ) ) ; sum = - 1 ; } else if ( i % 2 == 1 && sum <= 0 ) { num_of_ops1 += ( 1 + Math . abs ( sum ) ) ; sum = 1 ; } } sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; if ( i % 2 == 1 && sum >= 0 ) { num_of_ops2 += ( 1 + Math . abs ( sum ) ) ; sum = - 1 ; } else if ( i % 2 == 0 && sum <= 0 ) { num_of_ops2 += ( 1 + Math . abs ( sum ) ) ; sum = 1 ; } } return Math . min ( num_of_ops1 , num_of_ops2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , - 4 , 5 , 0 , 1 } ; int N = arr . length ; System . out . print ( minOperations ( arr , N ) ) ; } }
class GFG { static int countSetBits ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { count += Integer . bitCount ( i ) ; } return count ; } public static void main ( String [ ] args ) { int L = 3 , R = 5 ; System . out . print ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ " + countSetBits ( L , R ) ) ; } }
import java . util . * ; class GFG { static int countSwaps ( int A [ ] , int n ) { Arrays . sort ( A ) ; int ind = 1 , res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ind < n && A [ ind ] == A [ i ] ) ind ++ ; if ( ind < n && A [ ind ] > A [ i ] ) { res ++ ; ind ++ ; } if ( ind >= n ) break ; } return res ; } public static void main ( String [ ] args ) { int A [ ] = { 4 , 3 , 3 , 2 , 5 } ; System . out . print ( countSwaps ( A , 5 ) ) ; } }
import java . io . * ; class GFG { public static int numberOfPairs ( int n ) { if ( n % 2 == 0 ) return n / 2 - 1 ; else return n / 2 ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( numberOfPairs ( n ) ) ; } }
import java . util . * ; class GFG { static int N = 100000 ; static int canTake ; static int best ; static int [ ] dp = new int [ N ] ; static boolean [ ] vis = new boolean [ N ] ; static boolean dfs ( Vector < Integer > [ ] g , int [ ] cost , int u , int pre ) { vis [ u ] = true ; dp [ u ] = cost [ u ] ; boolean check = true ; int cur = cost [ u ] ; for ( int x : g [ u ] ) { if ( vis [ x ] && x != pre ) { check = false ; } else if ( ! vis [ x ] ) { check = dfs ( g , cost , x , u ) ? false : true ; cur = Math . max ( cur , cost [ u ] + dp [ x ] ) ; } } dp [ u ] = cur ; if ( ! check ) { canTake += cost [ u ] ; } else { best = Math . max ( best , dp [ u ] ) ; } return check ; } static void FindMaxCost ( Vector < Integer > [ ] g , int [ ] cost , int source ) { dfs ( g , cost , source , - 1 ) ; System . out . print ( canTake + best ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 5 ; int cost [ ] = { 2 , 2 , 8 , 6 , 9 } ; @ SuppressWarnings ( " unchecked " ) Vector < Integer > [ ] g = new Vector [ n ] ; for ( int i = 0 ; i < g . length ; i ++ ) g [ i ] = new Vector < Integer > ( ) ; g [ 0 ] . add ( 1 ) ; g [ 1 ] . add ( 0 ) ; g [ 0 ] . add ( 2 ) ; g [ 2 ] . add ( 0 ) ; g [ 0 ] . add ( 3 ) ; g [ 3 ] . add ( 0 ) ; g [ 1 ] . add ( 2 ) ; g [ 2 ] . add ( 1 ) ; g [ 1 ] . add ( 4 ) ; g [ 4 ] . add ( 1 ) ; int source = 1 ; FindMaxCost ( g , cost , source ) ; } }
class GFG { static int minPoints ( int n , int m ) { int ans = 0 ; if ( ( n % 2 != 0 ) && ( m % 2 != 0 ) ) { ans = ( ( n * m ) / 2 ) + 1 ; } else { ans = ( n * m ) / 2 ; } return ans ; } public static void main ( String [ ] args ) { int N = 5 , M = 7 ; System . out . print ( minPoints ( N , M ) ) ; } }
class GFG { static void createArray ( int n , int s ) { if ( 2 * n <= s ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { System . out . print ( 2 + " ▁ " ) ; s -= 2 ; } System . out . println ( s ) ; System . out . println ( 1 ) ; } else System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int N = 1 ; int S = 4 ; createArray ( N , S ) ; } }
import java . util . * ; class GFG { static void maximumSumSubarray ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= 0 ) mp . put ( arr [ i ] , 1 ) ; } int first = 0 ; int last = 0 ; int ans = 0 ; int INF = ( int ) 1e6 ; for ( Map . Entry < Integer , Integer > i : mp . entrySet ( ) ) { int mx = i . getKey ( ) ; int curr = 0 ; int curr_start = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( curr == 0 ) curr_start = j ; int val = arr [ j ] > mx ? - INF : arr [ j ] ; curr += val ; if ( curr < 0 ) curr = 0 ; if ( curr > ans ) { ans = curr ; first = curr_start ; last = j ; } } } System . out . print ( ( first + 1 ) + " ▁ " + ( last + 1 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , - 2 , 10 , - 1 , 4 } ; int size = arr . length ; maximumSumSubarray ( arr , size ) ; } }
import java . util . * ; class GFG { static void minFlip ( String s , int n , int k , char a [ ] , int p ) { boolean allowed [ ] = new boolean [ 26 ] ; for ( int i = 0 ; i < p ; i ++ ) { allowed [ a [ i ] - ' a ' ] = true ; } char [ ] [ ] freq = new char [ k ] [ 26 ] ; for ( int i = 0 ; i < k ; i ++ ) for ( int j = 0 ; j < 26 ; j ++ ) freq [ i ] [ j ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ i % k ] [ s . charAt ( i ) - ' a ' ] += 1 ; } int ans = 0 ; int totalpositions = n / k ; for ( int i = 0 ; i < k ; i ++ ) { int maxfrequency = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( freq [ i ] [ j ] > maxfrequency && allowed [ j ] == true ) maxfrequency = freq [ i ] [ j ] ; } ans += ( totalpositions - maxfrequency + ( ( i % k < n % k ) ? 1 : 0 ) ) ; } System . out . print ( ans + "NEW_LINE"); } public static void main ( String [ ] args ) { String S = " nihsiakyt " ; int n = S . length ( ) ; int K = 3 ; char [ ] A = { ' n ' , ' i ' , ' p ' , ' s ' , ' q ' } ; int p = A . length ; minFlip ( S , n , K , A , p ) ; } }
import java . lang . Math ; class GFG { public static void MinDiff ( int n ) { int val = ( int ) Math . pow ( 2 , n ) ; int sep = n / 2 ; int grp1 = 0 ; int grp2 = 0 ; grp1 = grp1 + val ; for ( int i = 1 ; i < sep ; i ++ ) grp1 = grp1 + ( int ) Math . pow ( 2 , i ) ; for ( int i = sep ; i < n ; i ++ ) grp2 = grp2 + ( int ) Math . pow ( 2 , i ) ; System . out . println ( Math . abs ( grp1 - grp2 ) ) ; } public static void main ( String args [ ] ) { int n = 4 ; MinDiff ( n ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int MinimumValue ( int a [ ] , int n ) { int answer = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { answer = Math . min ( answer , ( ( a [ i ] & a [ j ] ) ^ ( a [ i ] a [ j ] ) ) ) ; } } return answer ; } public static void main ( String [ ] args ) { int N = 6 ; int [ ] A = new int [ ] { 12 , 3 , 14 , 5 , 9 , 8 } ; System . out . print ( MinimumValue ( A , N ) ) ; } }
import java . util . * ; class GFG { static int countOfSubStrings ( String s ) { int n = s . length ( ) ; int [ ] prefix_sum = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) prefix_sum [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] += prefix_sum [ i - 1 ] ; int answer = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int countOfOnes = prefix_sum [ j ] - ( i - 1 >= 0 ? prefix_sum [ i - 1 ] : 0 ) ; int length = j - i + 1 ; if ( countOfOnes > 0 && length % countOfOnes == 0 ) answer ++ ; } } return answer ; } public static void main ( String [ ] args ) { String S = "1111100000" ; System . out . print ( countOfSubStrings ( S ) ) ; } }
import java . util . * ; class GFG { static int digit_xor ( int x ) { int xorr = 0 ; while ( x > 0 ) { xorr ^= x % 10 ; x = x / 10 ; } return xorr ; } static int find_count ( int n ) { HashMap < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( mpp . containsKey ( digit_xor ( i ) ) ) mpp . put ( digit_xor ( i ) , mpp . get ( digit_xor ( i ) ) + 1 ) ; else mpp . put ( digit_xor ( i ) , 1 ) ; } int maxm = 0 ; for ( Map . Entry < Integer , Integer > x : mpp . entrySet ( ) ) { if ( x . getValue ( ) > maxm ) maxm = x . getValue ( ) ; } return maxm ; } public static void main ( String [ ] args ) { int N = 13 ; System . out . print ( find_count ( N ) ) ; } }
import java . util . * ; class GFG { static int min_val = Integer . MAX_VALUE ; static int min_steps = 0 ; static int sumOfDigits ( int n ) { String s = String . valueOf ( n ) ; int sum = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum += ( s . charAt ( i ) - '0' ) ; } return sum ; } static void Transform ( int n , int d , int steps ) { if ( n < min_val ) { min_val = n ; min_steps = steps ; } else if ( n == min_val ) { min_steps = Math . min ( min_steps , steps ) ; } if ( steps < 15 ) { Transform ( sumOfDigits ( n ) , d , steps + 1 ) ; Transform ( n + d , d , steps + 1 ) ; } } public static void main ( String [ ] args ) { int N = 9 , D = 3 ; Transform ( N , D , 0 ) ; System . out . print ( min_val + " ▁ " + min_steps ) ; } }
import java . util . * ; class GFG { static int sumDivisibles ( int A , int B , int M ) { int sum = 0 ; for ( int i = A ; i <= B ; i ++ ) if ( i % M == 0 ) sum += i ; return sum ; } public static void main ( String [ ] args ) { int A = 6 , B = 15 , M = 3 ; System . out . print ( sumDivisibles ( A , B , M ) + "NEW_LINE"); } }
import java . util . * ; class GFG { static int countPairs ( int arr [ ] , int n ) { HashMap < Integer , Integer > frequency = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( frequency . containsKey ( arr [ i ] ) ) { frequency . put ( arr [ i ] , frequency . get ( arr [ i ] ) + 1 ) ; } else { frequency . put ( arr [ i ] , 1 ) ; } } int count = 0 ; for ( Map . Entry < Integer , Integer > x : frequency . entrySet ( ) ) { int f = x . getValue ( ) ; count += f * ( f - 1 ) / 2 ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 } ; int n = arr . length ; System . out . print ( countPairs ( arr , n ) ) ; } }
class GFG { static void decBinary ( int arr [ ] , int n ) { int k = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } static int binaryDec ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } static int maxNum ( int n , int k ) { int l = ( int ) ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; int a [ ] = new int [ l ] ; decBinary ( a , n ) ; int cn = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] == 0 && cn < k ) { a [ i ] = 1 ; cn ++ ; } } return binaryDec ( a , l ) ; } public static void main ( String [ ] args ) { int n = 4 , k = 1 ; System . out . println ( maxNum ( n , k ) ) ; } }
class GFG { static int MAX = 26 ; static char maxAlpha ( String str , int len ) { int [ ] first = new int [ MAX ] ; int [ ] last = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str . charAt ( i ) - ' a ' ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } int ans = - 1 , maxVal = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 ) continue ; if ( ( last [ i ] - first [ i ] ) > maxVal ) { maxVal = last [ i ] - first [ i ] ; ans = i ; } } return ( char ) ( ans + ' a ' ) ; } public static void main ( String [ ] args ) { String str = " abbba " ; int len = str . length ( ) ; System . out . print ( maxAlpha ( str , len ) ) ; } }
class GFG { static boolean isVowel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; default : return false ; } } static int vowelPairs ( String s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) && isVowel ( s . charAt ( i + 1 ) ) ) cnt ++ ; } return cnt ; } public static void main ( String args [ ] ) { String s = " abaebio " ; int n = s . length ( ) ; System . out . print ( vowelPairs ( s , n ) ) ; } }
class GFG { static int min_elimination ( int n , int [ ] arr ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 7 , 9 } ; int n = arr . length ; System . out . println ( min_elimination ( n , arr ) ) ; } }
import java . io . * ; class GFG { static boolean checkIfOverlap ( String str ) { int len = str . length ( ) ; int [ ] visited = new int [ len + 1 ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' . ' ) continue ; for ( int j = Math . max ( 0 , i - str . charAt ( i ) ) ; j <= Math . min ( len , i + str . charAt ( i ) ) ; j ++ ) visited [ j ] ++ ; } for ( int i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; } public static void main ( String [ ] args ) { String str = " . 2 . . 2 . " ; if ( checkIfOverlap ( str ) ) System . out . println ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . io . * ; class GFG { static boolean isCorrectOrder ( int n ) { boolean flag = true ; int prev = - 1 ; int type = - 1 ; while ( n != 0 ) { if ( type == - 1 ) { if ( prev == - 1 ) { prev = n % 10 ; n = n / 10 ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; } public static void main ( String [ ] args ) { int n = 123454321 ; if ( isCorrectOrder ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; class GFG { static int V = 5 ; static int INT_MAX = Integer . MAX_VALUE ; static boolean isValidEdge ( int u , int v , boolean [ ] inMST ) { if ( u == v ) return false ; if ( inMST [ u ] == false && inMST [ v ] == false ) return false ; else if ( inMST [ u ] == true && inMST [ v ] == true ) return false ; return true ; } static void primMST ( int cost [ ] [ ] ) { boolean [ ] inMST = new boolean [ V ] ; inMST [ 0 ] = true ; int edge_count = 0 , mincost = 0 ; while ( edge_count < V - 1 ) { int min = INT_MAX , a = - 1 , b = - 1 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( cost [ i ] [ j ] < min ) { if ( isValidEdge ( i , j , inMST ) ) { min = cost [ i ] [ j ] ; a = i ; b = j ; } } } } if ( a != - 1 && b != - 1 ) { System . out . printf ( "Edge %d:(%d, %d) cost: %d NEW_LINE", edge_count++, a, b, min); mincost = mincost + min ; inMST [ b ] = inMST [ a ] = true ; } } System . out . printf ( " Minimum cost = % d ", mincost); } public static void main ( String [ ] args ) { int cost [ ] [ ] = { { INT_MAX , 2 , INT_MAX , 6 , INT_MAX } , { 2 , INT_MAX , 3 , 8 , 5 } , { INT_MAX , 3 , INT_MAX , INT_MAX , 7 } , { 6 , 8 , INT_MAX , INT_MAX , 9 } , { INT_MAX , 5 , 7 , 9 , INT_MAX } } ; primMST ( cost ) ; } }
import java . util . * ; class GFG { static class pair { double first , second ; public pair ( double first , double second ) { this . first = first ; this . second = second ; } } static void construct ( int n , pair ans_pair ) { if ( ans_pair . first == - 1 ) { System . out . print ( " Not ▁ possible " ) ; return ; } double a1 = ans_pair . first ; double a2 = ans_pair . second ; double r = a2 / a1 ; System . out . print ( "The resultant sequence is:NEW_LINE"); for ( int i = 1 ; i <= n ; i ++ ) { int ai = ( int ) ( a1 * Math . pow ( r , i - 1 ) ) ; System . out . print ( ai + " ▁ " ) ; } } static void findMinimumOperations ( double [ ] a , int n ) { int ans = Integer . MAX_VALUE ; int c [ ] = { - 1 , 0 , 1 } ; int possibilities = 3 ; int pos1 = - 1 , pos2 = - 1 ; for ( int i = 0 ; i < possibilities ; i ++ ) { for ( int j = 0 ; j < possibilities ; j ++ ) { double a1 = a [ 1 ] + c [ i ] ; double a2 = a [ 2 ] + c [ j ] ; int temp = ( int ) ( Math . abs ( a1 - a [ 1 ] ) + Math . abs ( a2 - a [ 2 ] ) ) ; if ( a1 == 0 a2 == 0 ) continue ; double r = a2 / a1 ; for ( int pos = 3 ; pos <= n ; pos ++ ) { double ai = a1 * Math . pow ( r , pos - 1 ) ; if ( a [ pos ] == ai ) { continue ; } else if ( a [ pos ] + 1 == ai a [ pos ] - 1 == ai ) { temp ++ ; } else { temp = Integer . MAX_VALUE ; break ; } } if ( temp < ans ) { ans = temp ; pos1 = ( int ) a1 ; pos2 = ( int ) a2 ; } } } if ( ans == - 1 ) { System . out . print ( " - 1" ) ; return ; } System . out . print ( " Minimum ▁ Number ▁ of ▁ Operations ▁ are ▁ " + ans + "NEW_LINE"); pair ans_pair = new pair ( pos1 , pos2 ) ; construct ( n , ans_pair ) ; } public static void main ( String [ ] args ) { double a [ ] = { 0 , 7 , 20 , 49 , 125 } ; int n = a . length ; findMinimumOperations ( a , n - 1 ) ; } }
import java . util . * ; class solution { static int findMinimumAdjacentSwaps ( int arr [ ] , int N ) { boolean [ ] visited = new boolean [ N + 1 ] ; int minimumSwaps = 0 ; Arrays . fill ( visited , false ) ; for ( int i = 0 ; i < 2 * N ; i ++ ) { if ( visited [ arr [ i ] ] == false ) { visited [ arr [ i ] ] = true ; int count = 0 ; for ( int j = i + 1 ; j < 2 * N ; j ++ ) { if ( visited [ arr [ j ] ] == false ) count ++ ; else if ( arr [ i ] == arr [ j ] ) minimumSwaps += count ; } } } return minimumSwaps ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 3 , 1 , 2 } ; int N = arr . length ; N /= 2 ; System . out . println ( findMinimumAdjacentSwaps ( arr , N ) ) ; } }
import java . io . * ; class GFG { static int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 5 , 6 } ; int n = arr . length ; int k = 5 ; System . out . println ( MinOperation ( arr , n , k ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void printVector ( Vector < Integer > v ) { System . out . println ( v . size ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( v . get ( i ) + " ▁ " ) ; System . out . println ( ) ; } static void findTwoGroup ( int n ) { int sum = n * ( n + 1 ) / 2 ; int group1Sum = sum / 2 ; Vector < Integer > group1 = new Vector < Integer > ( ) ; Vector < Integer > group2 = new Vector < Integer > ( ) ; for ( int i = n ; i > 0 ; i -- ) { if ( group1Sum - i >= 0 ) { group1 . add ( i ) ; group1Sum -= i ; } else { group2 . add ( i ) ; } } printVector ( group1 ) ; printVector ( group2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; findTwoGroup ( n ) ; } }
import java . util . * ; class GFG { public static long swapCount ( String s ) { Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) if ( s . charAt ( i ) == ' [ ' ) pos . add ( i ) ; int count = 0 ; int p = 0 ; long sum = 0 ; char [ ] S = s . toCharArray ( ) ; for ( int i = 0 ; i < s . length ( ) ; ++ i ) { if ( S [ i ] == ' [ ' ) { ++ count ; ++ p ; } else if ( S [ i ] == ' ] ' ) -- count ; if ( count < 0 ) { sum += pos . get ( p ) - i ; char temp = S [ i ] ; S [ i ] = S [ pos . get ( p ) ] ; S [ pos . get ( p ) ] = temp ; ++ p ; count = 1 ; } } return sum ; } public static void main ( String [ ] args ) { String s = " [ ] ] [ ] [ " ; System . out . println ( swapCount ( s ) ) ; s = " [ [ ] [ ] ] " ; System . out . println ( swapCount ( s ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static int mod = 1000000007 ; static void countOfNumbers ( int N ) { int ans = 1 ; for ( int index = 1 ; index <= N ; ++ index ) { int choices = 0 ; for ( int digit = 1 ; digit <= 9 ; ++ digit ) { if ( index % digit == 0 ) { ++ choices ; } } ans = ( ans * choices ) % mod ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int N = 5 ; countOfNumbers ( N ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static int dfs ( int [ ] arr , int left , int K ) { int q = 0 ; if ( left == 0 ) { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; q = Math . max ( q , 1 + dfs ( arr , K - i , K ) ) ; arr [ i ] ++ ; } } } else { for ( int i = 1 ; i < K ; ++ i ) { if ( arr [ i ] > 0 ) { arr [ i ] -- ; int nleft = ( i <= left ? left - i : K + left - i ) ; q = Math . max ( q , dfs ( arr , nleft , K ) ) ; arr [ i ] ++ ; } } } return q ; } public static int maxGroups ( int K , int [ ] arr ) { int V [ ] = new int [ K ] ; for ( int x : arr ) V [ x % K ] ++ ; int ans = V [ 0 ] + dfs ( V , 0 , K ) ; return ans ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 } ; int K = 3 ; System . out . println ( maxGroups ( K , arr ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static void longestSubsequence ( int [ ] arr , int N ) { int dp [ ] [ ] = new int [ N ] [ N + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N + 1 ; ++ j ) { dp [ i ] [ j ] = - 1 ; } } for ( int i = 0 ; i < N ; ++ i ) { dp [ i ] [ 0 ] = 0 ; } dp [ 0 ] [ 1 ] = ( arr [ 0 ] >= 0 ? arr [ 0 ] : - 1 ) ; for ( int i = 1 ; i < N ; ++ i ) { for ( int j = 1 ; j <= ( i + 1 ) ; ++ j ) { if ( dp [ i - 1 ] [ j ] != - 1 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j ] ) ; } if ( dp [ i - 1 ] [ j - 1 ] >= 0 && dp [ i - 1 ] [ j - 1 ] + arr [ i ] >= 0 ) { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i - 1 ] [ j - 1 ] + arr [ i ] ) ; } } } int ans = 0 ; for ( int j = 0 ; j <= N ; ++ j ) { if ( dp [ N - 1 ] [ j ] >= 0 ) { ans = j ; } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , - 4 , 1 , - 3 , 1 , - 3 } ; int N = arr . length ; longestSubsequence ( arr , N ) ; } }
class GFG { static int KvisibleFromLeft ( int N , int K ) { if ( N == K ) return 1 ; if ( K == 1 ) { int ans = 1 ; for ( int i = 1 ; i < N ; i ++ ) ans *= i ; return ans ; } return KvisibleFromLeft ( N - 1 , K - 1 ) + ( N - 1 ) * KvisibleFromLeft ( N - 1 , K ) ; } public static void main ( String [ ] args ) { int N = 5 , K = 2 ; System . out . println ( KvisibleFromLeft ( N , K ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int numOfWays ( int a [ ] [ ] , int n , int i , HashSet < Integer > blue ) { if ( i == n ) return 1 ; int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ i ] [ j ] == 1 && ! blue . contains ( j ) ) { blue . add ( j ) ; count += numOfWays ( a , n , i + 1 , blue ) ; blue . remove ( j ) ; } } return count ; } public static void main ( String [ ] args ) { int n = 3 ; int mat [ ] [ ] = { { 0 , 1 , 1 } , { 1 , 0 , 1 } , { 1 , 1 , 1 } } ; HashSet < Integer > mpp = new HashSet < > ( ) ; System . out . println ( ( numOfWays ( mat , n , 0 , mpp ) ) ) ; } }
import java . util . * ; class GFG { static int totalArrays ( int N , int M ) { int [ ] end_with_one = new int [ N + 1 ] ; int [ ] end_not_with_one = new int [ N + 1 ] ; end_with_one [ 0 ] = 1 ; end_not_with_one [ 0 ] = 0 ; end_with_one [ 1 ] = 0 ; end_not_with_one [ 1 ] = M - 1 ; for ( int i = 2 ; i < N ; i ++ ) { end_with_one [ i ] = end_not_with_one [ i - 1 ] ; end_not_with_one [ i ] = end_with_one [ i - 1 ] * ( M - 1 ) + end_not_with_one [ i - 1 ] * ( M - 2 ) ; } return end_with_one [ N - 1 ] ; } public static void main ( String [ ] args ) { int N = 3 , M = 3 ; int temp = totalArrays ( N , M ) ; int ans = M * temp ; System . out . print ( ans + "NEW_LINE"); } }
import java . util . * ; class GFG { static int M = 1000000007 ; static int power ( int X , int Y ) { int res = 1 ; X = X % M ; if ( X == 0 ) return 0 ; while ( Y > 0 ) { if ( ( Y & 1 ) != 0 ) { res = ( res * X ) % M ; } Y = Y >> 1 ; X = ( X * X ) % M ; } return res ; } static int findValue ( int n ) { int X = 0 ; int pow_10 = 1 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 ) { X += pow_10 ; } pow_10 *= 10 ; n /= 2 ; } X = ( X * 2 ) % M ; int res = power ( 2 , X ) ; return res ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( findValue ( n ) ) ; } }
class GFG { static void countWaysToTileBoard ( int N ) { int dp [ ] = new int [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; } System . out . print ( dp [ N ] ) ; } public static void main ( String [ ] args ) { int N = 2 ; countWaysToTileBoard ( N ) ; } }
import java . util . * ; class GFG { static int removeSmallestSubarray ( int arr [ ] , int S , int n , int k ) { int target_remainder = S % k ; HashMap < Integer , Integer > map1 = new HashMap < > ( ) ; map1 . put ( 0 , - 1 ) ; int curr_remainder = 0 ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { curr_remainder = ( curr_remainder + arr [ i ] + k ) % k ; map1 . put ( curr_remainder , i ) ; int mod = ( curr_remainder - target_remainder + k ) % k ; if ( map1 . containsKey ( mod ) ) { res = Math . min ( res , i - map1 . get ( mod ) ) ; } } if ( res == Integer . MAX_VALUE res == n ) { res = - 1 ; } return res ; } static int smstSubmatDeleted ( int [ ] [ ] mat , int N , int M , int K ) { int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) S += mat [ i ] [ j ] ; } int min_area = N * M ; int left = 0 ; int right = 0 ; int width ; int area ; int [ ] prefixRowSum = new int [ N ] ; for ( left = 0 ; left < M ; left ++ ) { Arrays . fill ( prefixRowSum , 0 ) ; for ( right = left ; right < M ; right ++ ) { for ( int i = 0 ; i < N ; i ++ ) { prefixRowSum [ i ] += mat [ i ] [ right ] ; } width = removeSmallestSubarray ( prefixRowSum , S , N , K ) ; if ( width != - 1 ) { area = ( right - left + 1 ) * ( width ) ; if ( area < min_area ) { min_area = area ; } } } } return min_area ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 6 , 2 , 6 } , { 3 , 2 , 8 } , { 2 , 5 , 3 } } ; int K = 3 ; int N = mat . length ; int M = mat [ 0 ] . length ; System . out . print ( smstSubmatDeleted ( mat , N , M , K ) ) ; } }
import java . util . * ; public class Main { static int countstrings ( int n , int start ) { if ( n == 0 ) { return 1 ; } int cnt = 0 ; for ( int i = start ; i < 5 ; i ++ ) { cnt += countstrings ( n - 1 , i ) ; } return cnt ; } static int countVowelStrings ( int n ) { return countstrings ( n , 0 ) ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . print ( countVowelStrings ( n ) ) ; } }
import java . util . * ; class GFG { static int findNumberOfStrings ( int n ) { return ( n + 1 ) * ( n + 2 ) * ( n + 3 ) * ( n + 4 ) / 24 ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . print ( findNumberOfStrings ( N ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int mod = ( int ) 1e9 + 7 ; static int findTotalPath ( int X , int n , ArrayList < Integer > dp ) { if ( X == 0 ) { return 1 ; } int ans = 0 ; if ( dp . get ( X ) != - 1 ) { return dp . get ( X ) ; } for ( int i = 1 ; i <= Math . min ( X , n ) ; ++ i ) { ans += findTotalPath ( X - i , n , dp ) % mod ; ans %= mod ; } dp . set ( X , ans ) ; return ans ; } public static void main ( String [ ] args ) { int n = 3 , X = 2 ; ArrayList < Integer > dp = new ArrayList < Integer > ( Collections . nCopies ( X + 1 , - 1 ) ) ; System . out . print ( findTotalPath ( X , n , dp ) ) ; } }
import java . util . * ; class GFG { static int MAX = 100005 ; static Vector < Integer > SieveOfEratosthenes ( ) { boolean [ ] seive = new boolean [ MAX ] ; Arrays . fill ( seive , true ) ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( seive [ p ] == true ) { for ( int i = p * p ; i < MAX ; i += p ) { seive [ i ] = false ; } } } Vector < Integer > v = new Vector < Integer > ( ) ; for ( int p = 2 ; p < MAX ; p ++ ) { if ( seive [ p ] ) { v . add ( p ) ; } } return v ; } static void build ( int dp [ ] , int arr [ ] , int N ) { dp [ 0 ] = 0 ; dp [ 1 ] = 0 ; Vector < Integer > prime = SieveOfEratosthenes ( ) ; int [ ] pref = new int [ N + 1 ] ; pref [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { pref [ i ] = pref [ i - 1 ] + arr [ i - 1 ] ; } for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; for ( int j = 0 ; j <= prime . size ( ) ; j ++ ) { int r = i - 1 ; int l = r - prime . get ( j ) + 1 ; if ( l < 0 ) break ; int temp = 0 ; temp = pref [ r + 1 ] - pref [ l ] ; if ( l - 2 >= 0 ) temp += dp [ l - 2 + 1 ] ; dp [ i ] = Math . max ( dp [ i ] , temp ) ; } } } static void maxSumSubseq ( int arr [ ] , int N ) { int [ ] dp = new int [ N + 1 ] ; build ( dp , arr , N ) ; System . out . print ( dp [ N ] ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 10 , 7 , 10 , 10 , 10 } ; int N = arr . length ; maxSumSubseq ( arr , N ) ; } }
import java . io . * ; class GFG { static int binCoff ( int N , int R ) { int res = 1 ; if ( R > ( N - R ) ) { R = ( N - R ) ; } for ( int i = 0 ; i < R ; i ++ ) { res *= ( N - i ) ; res /= ( i + 1 ) ; } return res ; } static int cntPermutation ( int N ) { int cntPerm ; int C_2N_N = binCoff ( 2 * N , N ) ; cntPerm = C_2N_N / ( N + 1 ) ; return cntPerm ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = arr . length ; System . out . println ( cntPermutation ( N / 2 ) ) ; } }
class GFG { static int checkEqualSumUtil ( int arr [ ] , int N , int sm1 , int sm2 , int sm3 , int j ) { if ( j == N ) { if ( sm1 == sm2 && sm2 == sm3 ) return 1 ; else return 0 ; } else { int l = checkEqualSumUtil ( arr , N , sm1 + arr [ j ] , sm2 , sm3 , j + 1 ) ; int m = checkEqualSumUtil ( arr , N , sm1 , sm2 + arr [ j ] , sm3 , j + 1 ) ; int r = checkEqualSumUtil ( arr , N , sm1 , sm2 , sm3 + arr [ j ] , j + 1 ) ; return Math . max ( Math . max ( l , m ) , r ) ; } } static void checkEqualSum ( int arr [ ] , int N ) { int sum1 , sum2 , sum3 ; sum1 = sum2 = sum3 = 0 ; if ( checkEqualSumUtil ( arr , N , sum1 , sum2 , sum3 , 0 ) == 1 ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 17 , 34 , 59 , 23 , 17 , 67 , 57 , 2 , 18 , 59 , 1 } ; int N = arr . length ; checkEqualSum ( arr , N ) ; } }
import java . util . * ; class GFG { static void SubarrayWithMaxSum ( Vector < Integer > nums ) { int endIndex = 0 , currMax = nums . get ( 0 ) ; int globalMax = nums . get ( 0 ) ; for ( int i = 1 ; i < nums . size ( ) ; ++ i ) { currMax = Math . max ( nums . get ( i ) , nums . get ( i ) + currMax ) ; if ( currMax > globalMax ) { globalMax = currMax ; endIndex = i ; } } int startIndex = endIndex ; while ( startIndex >= 0 ) { globalMax -= nums . get ( startIndex ) ; if ( globalMax == 0 ) break ; startIndex -- ; } for ( int i = startIndex ; i <= endIndex ; ++ i ) { System . out . print ( nums . get ( i ) + " ▁ " ) ; } } public static void main ( String [ ] args ) { Vector < Integer > arr = new Vector < Integer > ( ) ; arr . add ( - 2 ) ; arr . add ( - 5 ) ; arr . add ( 6 ) ; arr . add ( - 2 ) ; arr . add ( - 3 ) ; arr . add ( 1 ) ; arr . add ( 5 ) ; arr . add ( - 6 ) ; SubarrayWithMaxSum ( arr ) ; } }
import java . io . * ; class GFG { public static int maximizeSum ( int [ ] arr ) { int n = arr . length ; int sum = 0 ; for ( int i = 0 ; i < n ; i = i + 2 ) sum += arr [ i ] ; int leftDP [ ] = new int [ n / 2 ] ; int rightDP [ ] = new int [ n / 2 ] ; int c = 0 ; for ( int i = 1 ; i < n ; i = i + 2 ) { int leftDiff = arr [ i ] - arr [ i - 1 ] ; if ( c - 1 < 0 ) leftDP = leftDiff ; else { if ( leftDP > 0 ) leftDP = leftDiff + leftDP ; else leftDP [ i ] = leftDiff ; } int rightDiff ; if ( i + 1 >= arr . length ) rightDiff = 0 ; else rightDiff = arr [ i ] - arr [ i + 1 ] ; if ( c - 1 < 0 ) rightDP = rightDiff ; else { if ( rightDP > 0 ) rightDP = rightDiff + rightDP ; else rightDP = rightDiff ; } c ++ ; } int max = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { max = Math . max ( max , Math . max ( leftDP [ i ] , rightDP [ i ] ) ) ; } return max + sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 7 , 8 , 4 , 5 , 7 , 6 , 8 , 9 , 7 , 3 } ; int ans = maximizeSum ( arr ) ; System . out . println ( ans ) ; } }
import java . util . * ; import java . io . * ; class GFG { static int validsubsequences ( int arr [ ] , int n ) { long dp [ ] [ ] = new long [ n + 1 ] [ 2 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ i ] [ 1 ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( arr [ i - 1 ] % 2 != 0 ) { dp [ i ] [ 1 ] += 1 ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; } else { dp [ i ] [ 0 ] += 1 ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] += dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] += dp [ i - 1 ] [ 1 ] ; } } return ( int ) ( dp [ n ] [ 0 ] + dp [ n ] [ 1 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 6 , 9 , 7 } ; int n = arr . length ; System . out . print ( validsubsequences ( arr , n ) ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void OddDivisorsCount ( int n , int q , int a [ ] , pair [ ] Query ) { int DP [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . sqrt ( a [ i ] ) ; if ( x * x == a [ i ] ) DP [ i ] = 1 ; } for ( int i = 1 ; i < n ; i ++ ) { DP [ i ] = DP [ i - 1 ] + DP [ i ] ; } int l , r ; for ( int i = 0 ; i < q ; i ++ ) { l = Query [ i ] . first ; r = Query [ i ] . second ; if ( l == 0 ) { System . out . print ( DP [ r ] + "NEW_LINE"); } else { System . out . print ( DP [ r ] - DP [ l - 1 ] + "NEW_LINE"); } } } public static void main ( String [ ] args ) { int N = 5 ; int Q = 3 ; int arr [ ] = { 2 , 4 , 5 , 6 , 9 } ; pair [ ] Query = { new pair ( 0 , 2 ) , new pair ( 1 , 3 ) , new pair ( 1 , 4 ) } ; OddDivisorsCount ( N , Q , arr , Query ) ; } }
import java . io . * ; class GFG { static int countStableNum ( String str , int N ) { int count1 [ ] [ ] = new int [ N ] [ 10 ] ; int count2 [ ] [ ] = new int [ N ] [ 10 ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) count1 [ i ] [ j ] = count2 [ i ] [ j ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i != 0 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count1 [ i ] [ j ] += count1 [ i - 1 ] [ j ] ; } } count1 [ i ] [ str . charAt ( i ) - '0' ] ++ ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( i != N - 1 ) { for ( int j = 0 ; j < 10 ; j ++ ) { count2 [ i ] [ j ] += count2 [ i + 1 ] [ j ] ; } } count2 [ i ] [ str . charAt ( i ) - '0' ] ++ ; } int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { if ( str . charAt ( i ) == '9' ) continue ; int c1 = count1 [ i - 1 ] [ str . charAt ( i ) - '0' ] ; int c2 = count2 [ i + 1 ] [ str . charAt ( i ) - '0' + 1 ] ; if ( c2 == 0 ) continue ; ans = ( ans + ( c1 * ( ( c2 * ( c2 - 1 ) / 2 ) ) ) ) ; } return ans ; } public static void main ( String [ ] args ) { String str = "224353" ; int N = str . length ( ) ; System . out . println ( countStableNum ( str , N ) ) ; } }
import java . lang . * ; import java . util . * ; class GFG { static final long MAX = ( long ) 1e18 ; static long n , m ; static List < List < Long > > v = new ArrayList < > ( 151 ) ; static long [ ] [ ] dp = new long [ 151 ] [ 151 ] ; static long min_operation ( long i , long j , long val , long x ) { if ( i == n - 1 && j == m - 1 ) { if ( val > v . get ( ( int ) i ) . get ( ( int ) j ) ) { return dp [ ( int ) i ] [ ( int ) j ] = MAX ; } else { return dp [ ( int ) i ] [ ( int ) j ] = v . get ( ( int ) i ) . get ( ( int ) j ) - val ; } } if ( i == n j == m ) { return dp [ ( int ) i ] [ ( int ) j ] = MAX ; } if ( dp [ ( int ) i ] [ ( int ) j ] != - 1 ) { return dp [ ( int ) i ] [ ( int ) j ] ; } if ( val > v . get ( ( int ) i ) . get ( ( int ) j ) ) { return dp [ ( int ) i ] [ ( int ) j ] = MAX ; } long tmp = v . get ( ( int ) i ) . get ( ( int ) j ) - val ; tmp += Math . min ( min_operation ( i + 1 , j , val + x , x ) , min_operation ( i , j + 1 , val + x , x ) ) ; return dp [ ( int ) i ] [ ( int ) j ] = tmp ; } static long solve ( long x ) { long ans = Long . MAX_VALUE ; for ( long i = 0 ; i < n ; i ++ ) { for ( long j = 0 ; j < m ; j ++ ) { long val = v . get ( ( int ) i ) . get ( ( int ) j ) - x * ( i + j ) ; for ( int k = 0 ; k < dp . length ; k ++ ) for ( int l = 0 ; l < dp [ k ] . length ; l ++ ) dp [ k ] [ l ] = - 1 ; val = min_operation ( 0l , 0l , val , x ) ; ans = Math . min ( ans , val ) ; } } return ans ; } public static void main ( String [ ] args ) { n = 2 ; m = 2 ; long x = 3 ; v . add ( Arrays . asList ( 15l , 153l ) ) ; v . add ( Arrays . asList ( 135l , 17l ) ) ; System . out . println ( solve ( x ) ) ; } }
import java . util . * ; class GFG { static int K ; static int N ; static Vector < Integer > v = new Vector < > ( ) ; static int [ ] [ ] [ ] [ ] [ ] dp = new int [ 20 ] [ 1000 ] [ 10 ] [ 2 ] [ 2 ] ; static void init ( int x ) { for ( int i = 0 ; i < 20 ; i ++ ) for ( int j = 0 ; j < 1000 ; j ++ ) for ( int k = 0 ; k < 10 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) for ( int m = 0 ; m < 2 ; m ++ ) dp [ i ] [ j ] [ k ] [ l ] [ m ] = - 1 ; v . clear ( ) ; while ( x > 0 ) { v . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( v ) ; N = v . size ( ) ; } static int fun ( int pos , int sum , int st , int check , int f ) { if ( pos == N ) { return ( sum == 0 && check == 1 ) ? 1 : 0 ; } if ( dp [ pos ] [ sum ] [ st ] [ check ] [ f ] != - 1 ) return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] ; int lmt = 9 ; if ( f == 0 ) lmt = v . get ( pos ) ; int ans = 0 ; for ( int digit = 0 ; digit <= lmt ; digit ++ ) { int nf = f ; int new_sum = ( sum + digit ) % K ; int new_check = check ; int new_st = st ; if ( f == 0 && digit < lmt ) nf = 1 ; if ( check == 0 && digit != 0 ) { new_st = digit ; new_check = 1 ; } if ( pos == N - 1 && new_st == digit ) continue ; ans += fun ( pos + 1 , new_sum , new_st , new_check , nf ) ; } return dp [ pos ] [ sum ] [ st ] [ check ] [ f ] = ans ; } static void findCount ( int L , int R , int K ) { init ( R ) ; int r_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; init ( L - 1 ) ; int l_ans = fun ( 0 , 0 , 0 , 0 , 0 ) ; System . out . print ( r_ans - l_ans ) ; } public static void main ( String [ ] args ) { int L = 10 ; int R = 20 ; K = 2 ; findCount ( L , R , K ) ; } }
import java . util . * ; class GFG { static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static int findSubarraySum ( int arr [ ] , int n , int K ) { Map < Integer , Integer > prevSum = new HashMap < > ( ) ; int res = 0 ; int currsum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { currsum += arr [ i ] ; if ( currsum == K ) { res ++ ; } if ( prevSum . containsKey ( currsum - K ) ) res += ( prevSum . get ( currsum - K ) ) ; prevSum . put ( currsum , prevSum . getOrDefault ( currsum , 0 ) + 1 ) ; } return res ; } static void countSubarray ( int arr [ ] , int n , int K ) { for ( int i = 0 ; i < n ; i ++ ) { if ( isPerfectSquare ( arr [ i ] ) ) { arr [ i ] = 1 ; } else { arr [ i ] = 0 ; } } System . out . println ( findSubarraySum ( arr , n , K ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 9 , 2 } ; int K = 2 ; int N = arr . length ; countSubarray ( arr , N , K ) ; } }
import java . util . * ; class GFG { static final int dim = 5 ; static void createTable ( int mtrx [ ] [ ] , int k , int p , int dp [ ] [ ] ) { dp [ 0 ] [ 0 ] = mtrx [ 0 ] [ 0 ] ; for ( int j = 1 ; j < dim ; j ++ ) { dp [ 0 ] [ j ] = mtrx [ 0 ] [ j ] + dp [ 0 ] [ j - 1 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { dp [ i ] [ 0 ] = mtrx [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; } for ( int i = 1 ; i < dim ; i ++ ) { for ( int j = 1 ; j < dim ; j ++ ) { dp [ i ] [ j ] = mtrx [ i ] [ j ] + dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] - dp [ i - 1 ] [ j - 1 ] ; } } } static int countSubMatrixUtil ( int dp [ ] [ ] , int k , int p ) { int count = 0 ; int subMatSum = 0 ; for ( int i = k - 1 ; i < dim ; i ++ ) { for ( int j = k - 1 ; j < dim ; j ++ ) { if ( i == ( k - 1 ) || j == ( k - 1 ) ) { if ( i == ( k - 1 ) && j == ( k - 1 ) ) { subMatSum = dp [ i ] [ j ] ; } else if ( i == ( k - 1 ) ) { subMatSum = dp [ i ] [ j ] - dp [ i ] [ j - k ] ; } else { subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] ; } } else { subMatSum = dp [ i ] [ j ] - dp [ i - k ] [ j ] - dp [ i ] [ j - k ] + dp [ i - k ] [ j - k ] ; } if ( subMatSum >= p ) { count ++ ; } } } return count ; } static int countSubMatrix ( int mtrx [ ] [ ] , int k , int p ) { int [ ] [ ] dp = new int [ dim ] [ dim ] ; for ( int i = 0 ; i < dim ; i ++ ) { for ( int j = 0 ; j < dim ; j ++ ) { dp [ i ] [ j ] = 0 ; } } createTable ( mtrx , k , p , dp ) ; return countSubMatrixUtil ( dp , k , p ) ; } public static void main ( String [ ] args ) { int mtrx [ ] [ ] = { { 1 , 7 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 , 2 } , { 3 , 9 , 6 , 7 , 3 } , { 4 , 3 , 2 , 4 , 5 } , { 5 , 1 , 5 , 3 , 1 } } ; int k = 3 ; int p = 35 ; System . out . print ( countSubMatrix ( mtrx , k , p ) ) ; } }
import java . util . * ; class GFG { static int countWays ( int n , int m ) { int [ ] [ ] dp = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { dp [ 1 ] [ i ] = 1 ; if ( i != 0 ) { dp [ 1 ] [ i ] += dp [ 1 ] [ i - 1 ] ; } } for ( int i = 2 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( i == m && j == n ) { return dp [ i ] [ j ] ; } dp [ i ] [ j ] += dp [ i ] [ j - 1 ] ; } } } return Integer . MIN_VALUE ; } public static void main ( String [ ] args ) { int N = 2 , K = 3 ; System . out . print ( countWays ( N , K ) ) ; } }
import java . util . * ; class GFG { static boolean check ( Vector < Integer > v ) { HashSet < Integer > digits = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) { HashSet < Integer > d = new HashSet < Integer > ( ) ; while ( v . get ( i ) > 0 ) { d . add ( v . get ( i ) % 10 ) ; v . set ( i , v . get ( i ) / 10 ) ; } for ( int it : d ) { if ( digits . contains ( it ) ) return false ; } for ( int it : d ) digits . add ( it ) ; } return true ; } static int numberOfSubarrays ( int a [ ] , int n ) { int answer = 0 ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { Vector < Integer > temp = new Vector < Integer > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) > 0 ) temp . add ( a [ j ] ) ; } if ( check ( temp ) ) answer ++ ; } return answer ; } public static void main ( String [ ] args ) { int N = 4 ; int A [ ] = { 1 , 12 , 23 , 34 } ; System . out . print ( numberOfSubarrays ( A , N ) ) ; } }
import java . util . * ; class GFG { static int maximumOccurrence ( String s ) { int n = s . length ( ) ; HashMap < String , Integer > freq = new HashMap < String , Integer > ( ) ; int i , j ; for ( i = 0 ; i < n ; i ++ ) { String temp = " " ; temp += s . charAt ( i ) ; if ( freq . containsKey ( temp ) ) { freq . put ( temp , freq . get ( temp ) + 1 ) ; } else { freq . put ( temp , 1 ) ; } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { String temp = " " ; temp += s . charAt ( i ) ; temp += s . charAt ( j ) ; if ( freq . containsKey ( temp ) ) freq . put ( temp , freq . get ( temp ) + 1 ) ; else freq . put ( temp , 1 ) ; } } int answer = Integer . MIN_VALUE ; for ( int it : freq . values ( ) ) answer = Math . max ( answer , it ) ; return answer ; } public static void main ( String [ ] args ) { String s = " xxxyy " ; System . out . print ( maximumOccurrence ( s ) ) ; } }
class GFG { static int maxLength ( int [ ] a , int n ) { int maximum = 1 ; int left [ ] = new int [ n ] ; int right [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = 1 ; right [ i ] = 1 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] > a [ i + 1 ] ) { right [ i ] = right [ i + 1 ] + 1 ; } maximum = Math . max ( maximum , right [ i ] ) ; } for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] < a [ i - 1 ] ) { left [ i ] = left [ i - 1 ] + 1 ; } } if ( n > 2 ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i - 1 ] > a [ i + 1 ] ) { maximum = Math . max ( maximum , left [ i - 1 ] + right [ i + 1 ] ) ; } } } return maximum ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 7 , 3 , 5 , 2 , 9 } ; int n = arr . length ; System . out . println ( maxLength ( arr , n ) ) ; } }
import java . util . * ; class GFG { static Map < String , Integer > dp = new HashMap < > ( ) ; static Integer solve ( char [ ] s , char c ) { if ( s . length == 1 ) return 0 ; if ( s . length == 2 ) { if ( s [ 0 ] == s [ 1 ] && s [ 0 ] == c ) return 1 ; else return 0 ; } if ( dp . containsKey ( String . valueOf ( s ) + " ▁ " + c ) ) return dp . get ( String . valueOf ( s ) + " ▁ " + c ) ; Integer ans = 0 ; if ( s [ 0 ] == s [ s . length - 1 ] && s [ 0 ] == c ) { for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) if ( c1 != c ) ans = Math . max ( ans , 1 + solve ( Arrays . copyOfRange ( s , 1 , s . length - 1 ) , c1 ) ) ; } else { for ( Integer i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == c ) { for ( Integer j = s . length - 1 ; j > i ; j -- ) if ( s [ j ] == c ) { if ( j == i ) break ; ans = solve ( Arrays . copyOfRange ( s , i , j + 1 ) , c ) ; break ; } break ; } } } dp . put ( String . valueOf ( s ) + " ▁ " + c , ans ) ; return dp . get ( String . valueOf ( s ) + " ▁ " + c ) ; } public static void main ( String [ ] args ) { String s = " abscrcdba " ; Integer ma = 0 ; for ( char c1 = ' a ' ; c1 <= ' z ' ; c1 ++ ) ma = Math . max ( ma , solve ( s . toCharArray ( ) , c1 ) * 2 ) ; System . out . print ( ma + "NEW_LINE"); } }
class GFG { static int maxIncSubarr ( int a [ ] , int n ) { int pre [ ] = new int [ n ] ; int pos [ ] = new int [ n ] ; pre [ 0 ] = 1 ; pos [ n - 1 ] = 1 ; int l = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) pre [ i ] = pre [ i - 1 ] + 1 ; else pre [ i ] = 1 ; } l = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] < a [ i + 1 ] ) pos [ i ] = pos [ i + 1 ] + 1 ; else pos [ i ] = 1 ; } int ans = 0 ; l = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] > a [ i - 1 ] ) l ++ ; else l = 1 ; ans = Math . max ( ans , l ) ; } for ( int i = 1 ; i <= n - 2 ; i ++ ) { if ( a [ i - 1 ] < a [ i + 1 ] ) ans = Math . max ( pre [ i - 1 ] + pos [ i + 1 ] , ans ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 } ; int n = arr . length ; System . out . println ( maxIncSubarr ( arr , n ) ) ; } }
class GFG { static int maxN = 20 ; static int maxM = 64 ; static int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; static boolean [ ] [ ] v = new boolean [ maxN ] [ maxM ] ; static int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == m ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , curr arr [ i ] , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 7 , 2 , 3 } ; int n = arr . length ; int m = 3 ; int ans = findLen ( arr , 0 , 0 , n , m ) ; if ( ans == - 1 ) System . out . println ( 0 ) ; else System . out . println ( ans ) ; } }
class GFG { static int maxN = 20 ; static int maxM = 64 ; static int [ ] [ ] dp = new int [ maxN ] [ maxM ] ; static boolean [ ] [ ] v = new boolean [ maxN ] [ maxM ] ; static int findLen ( int [ ] arr , int i , int curr , int n , int m ) { if ( i == n ) { if ( curr == 0 ) return 0 ; else return - 1 ; } if ( v [ i ] [ curr ] ) return dp [ i ] [ curr ] ; v [ i ] [ curr ] = true ; int l = findLen ( arr , i + 1 , curr , n , m ) ; int r = findLen ( arr , i + 1 , ( curr + arr [ i ] ) % m , n , m ) ; dp [ i ] [ curr ] = l ; if ( r != - 1 ) dp [ i ] [ curr ] = Math . max ( dp [ i ] [ curr ] , r + 1 ) ; return dp [ i ] [ curr ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 2 , 1 } ; int n = arr . length ; int m = 3 ; System . out . println ( findLen ( arr , 0 , 0 , n , m ) ) ; } }
class GFG { static int divideArray ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ 500 ] [ 500 ] ; int i , j ; for ( i = 0 ; i < 500 ; i ++ ) for ( j = 0 ; j < 500 ; j ++ ) dp [ i ] [ j ] = 0 ; k -= 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { for ( j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] = Integer . MAX_VALUE ; int max_ = - 1 , sum = 0 ; for ( int l = i ; l < n ; l ++ ) { max_ = Math . max ( max_ , arr [ l ] ) ; sum += arr [ l ] ; int diff = ( l - i + 1 ) * max_ - sum ; if ( j > 0 ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , diff + dp [ l + 1 ] [ j - 1 ] ) ; else dp [ i ] [ j ] = diff ; } } } return dp [ 0 ] [ k ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 9 , 5 , 4 , 8 , 3 , 6 } ; int n = arr . length ; int k = 2 ; System . out . println ( divideArray ( arr , n , k ) ) ; } }
class GFG { static int maxHappiness ( int A , int N , String [ ] v ) { String str ; int [ ] val = new int [ N ] ; int [ ] wt = new int [ N ] ; int c = 0 ; for ( int i = 0 ; i < N ; i ++ ) { str = v [ i ] ; c = 0 ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { if ( str . charAt ( j ) == ' c ' ) c += 4 ; else if ( str . charAt ( j ) == ' w ' ) c += 3 ; else if ( str . charAt ( j ) == ' m ' ) c += 2 ; else c ++ ; } c *= str . length ( ) ; val [ i ] = c ; wt [ i ] = str . length ( ) ; } int [ ] [ ] k = new int [ N + 1 ] [ A + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int w = 0 ; w <= A ; w ++ ) { if ( i == 0 w == 0 ) k [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) { k [ i ] [ w ] = Math . max ( val [ i - 1 ] + k [ i - 1 ] [ w - wt [ i - 1 ] ] , k [ i - 1 ] [ w ] ) ; } else { k [ i ] [ w ] = k [ i - 1 ] [ w ] ; } } } return k [ N ] [ A ] ; } public static void main ( String [ ] args ) { int A = 5 ; String [ ] v = { " mmo " , " oo " , " cmw " , " cc " , " c " } ; int N = v . length ; System . out . println ( maxHappiness ( A , N , v ) ) ; } }
class GFG { static int N = 100005 ; static int LIS ( int a [ ] , int n ) { int dp [ ] = new int [ N ] , d [ ] = new int [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; } public static void main ( String args [ ] ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = a . length ; System . out . print ( LIS ( a , n ) ) ; } }
import java . lang . Math ; class GfG { static boolean checkCombinations ( int a [ ] , int n ) { int pow_set_size = ( int ) Math . pow ( 2 , n ) ; int counter , j ; for ( counter = 0 ; counter < pow_set_size ; counter ++ ) { int sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) else } if ( sum % ( 24 * 60 ) == 0 ) return true ; } return false ; } public static void main ( String [ ] args ) { int a [ ] = { 60 , 60 , 120 } ; int n = a . length ; if ( checkCombinations ( a , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static void makePairs ( Vector < Integer > pairs , int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { int sumOfDigits = 0 , k = i ; while ( k > 0 ) { sumOfDigits += k % 10 ; k /= 10 ; } if ( sumOfDigits <= 162 ) pairs . add ( sumOfDigits ) ; } } static int countCoPrime ( int a , int b ) { Vector < Integer > pairs = new Vector < Integer > ( ) ; makePairs ( pairs , a , b ) ; int count = 0 ; for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) for ( int j = i + 1 ; j < pairs . size ( ) ; j ++ ) if ( GCD ( pairs . get ( i ) , pairs . get ( j ) ) == 1 ) count ++ ; return count ; } public static void main ( String args [ ] ) { int a = 12 , b = 15 ; System . out . println ( countCoPrime ( a , b ) ) ; } }
import java . util . Arrays ; class GFG { static int MAX = 100 ; static int dp [ ] [ ] = new int [ MAX ] [ MAX ] ; static int countRemovals ( int a [ ] , int i , int j , int k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i ] [ j ] = 1 + Math . min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) ; } return dp [ i ] [ j ] ; } static int removals ( int a [ ] , int n , int k ) { Arrays . sort ( a ) ; for ( int [ ] rows : dp ) Arrays . fill ( rows , - 1 ) ; if ( n == 1 ) return 0 ; else return countRemovals ( a , 0 , n - 1 , k ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = a . length ; int k = 4 ; System . out . print ( removals ( a , n , k ) ) ; } }
import java . lang . * ; import java . util . * ; public class GfG { public static int findStep ( int n ) { if ( n == 1 n == 0 ) return 1 ; else if ( n == 2 ) return 2 ; else return findStep ( n - 3 ) + findStep ( n - 2 ) + findStep ( n - 1 ) ; } public static void main ( String argc [ ] ) { int n = 4 ; System . out . println ( findStep ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; } public static void main ( String args [ ] ) { int n = 3 , m = 4 ; System . out . println ( dealnnoy ( n , m ) ) ; } }
import java . util . Arrays ; class GFG { static final int MAX = 100 ; static boolean allones ( String s , int n ) { int co = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s . charAt ( i ) == '1' ) co += 1 ; return ( co == n ) ; } static int findlength ( int arr [ ] , String s , int n , int ind , int st , int dp [ ] [ ] ) { if ( ind >= n ) return 0 ; if ( dp [ ind ] [ st ] != - 1 ) return dp [ ind ] [ st ] ; if ( st == 0 ) return dp [ ind ] [ st ] = Math . max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , findlength ( arr , s , n , ind + 1 , 0 , dp ) ) ; else return dp [ ind ] [ st ] = Math . max ( arr [ ind ] + findlength ( arr , s , n , ind + 1 , 1 , dp ) , 0 ) ; } static int maxLen ( String s , int n ) { if ( allones ( s , n ) ) return - 1 ; int arr [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = ( s . charAt ( i ) == '0' ? 1 : - 1 ) ; int dp [ ] [ ] = new int [ MAX ] [ 3 ] ; for ( int [ ] row : dp ) Arrays . fill ( row , - 1 ) ; return findlength ( arr , s , n , 0 , 0 , dp ) ; } public static void main ( String [ ] args ) { String s = "11000010001" ; int n = 11 ; System . out . println ( maxLen ( s , n ) ) ; } }
class GFG { static boolean isSafe ( int x , int y ) { return ( x < 4 && y < 3 ) ; } static int minJump ( int height [ ] [ ] , int x , int y ) { if ( x == 4 - 1 && y == 3 - 1 ) return 0 ; int diag = Integer . MAX_VALUE ; if ( isSafe ( x + 1 , y + 1 ) ) diag = minJump ( height , x + 1 , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; int down = Integer . MAX_VALUE ; if ( isSafe ( x + 1 , y ) ) down = minJump ( height , x + 1 , y ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ; int right = Integer . MAX_VALUE ; if ( isSafe ( x , y + 1 ) ) right = minJump ( height , x , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ; return Math . min ( down , Math . min ( right , diag ) ) ; } public static void main ( String [ ] args ) { int height [ ] [ ] = { { 5 , 4 , 2 } , { 9 , 2 , 1 } , { 2 , 5 , 9 } , { 1 , 3 , 11 } } ; System . out . println ( minJump ( height , 0 , 0 ) ) ; } }
public class GFG { static long countWays ( int n ) { long dp [ ] [ ] = new long [ 2 ] [ n + 1 ] ; dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . print ( " Total ▁ no ▁ of ▁ ways ▁ with ▁ n ▁ = ▁ " + n + " ▁ are : ▁ " + countWays ( n ) ) ; } }
import java . util . Arrays ; class GFG { static void countWaysToJump ( int arr [ ] , int n ) { int count_jump [ ] = new int [ n ] ; Arrays . fill ( count_jump , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) System . out . print ( count_jump [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 } ; int n = arr . length ; countWaysToJump ( arr , n ) ; } }
class GFG { static final int N = 4 ; static int maxDecimalValue ( int mat [ ] [ ] , int i , int j , int p ) { if ( i >= N j >= N ) { return 0 ; } int result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) { return ( int ) ( Math . pow ( 2 , p ) + result ) ; } else { return result ; } } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; System . out . println ( maxDecimalValue ( mat , 0 , 0 , 0 ) ) ; } }
public class GFG { final static int N = 4 ; static int MaximumDecimalValue ( int mat [ ] [ ] , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; if ( mat [ 0 ] [ 0 ] == 1 ) { } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ 0 ] [ i ] == 1 ) { dp [ 0 ] [ i ] = ( int ) ( dp [ 0 ] [ i - 1 ] + Math . pow ( 2 , i ) ) ; else { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { if ( mat [ i ] [ 0 ] == 1 ) { dp [ i ] [ 0 ] = ( int ) ( dp [ i - 1 ] [ 0 ] + Math . pow ( 2 , i ) ) ; else { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; } } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { dp [ i ] [ j ] = ( int ) ( Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) + Math . pow ( 2 , i + j ) ) ; } else { dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } } return dp [ n - 1 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; System . out . println ( MaximumDecimalValue ( mat , 4 ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int dp [ ] = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = arr . length ; int K = 4 ; System . out . println ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) ; } }
class GFG { static int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = arr . length ; System . out . println ( " Sum ▁ of ▁ maximum ▁ sum ▁ " + " increasing ▁ subsequence ▁ is ▁ " + maxSumIS ( arr , n ) ) ; } }
class MatrixChainMultiplication { static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 3 } ; int n = arr . length ; System . out . println ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " + MatrixChainOrder ( arr , 1 , n - 1 ) ) ; } }
import java . io . * ; class GFG { static void encodeString ( String str ) { String res = " " ; int small [ ] = new int [ 26 ] ; int capital [ ] = new int [ 26 ] ; int num [ ] = new int [ 10 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { small [ i ] = 0 ; capital [ i ] = 0 ; } for ( int i = 0 ; i < 10 ; i ++ ) { num [ i ] = 0 ; } int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { num [ str . charAt ( i ) - 48 ] = i ; } else if ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) { small [ str . charAt ( i ) - 97 ] = i ; } else if ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) { capital [ str . charAt ( i ) - 65 ] = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( ( str . charAt ( i ) >= ' a ' && str . charAt ( i ) <= ' z ' ) && small [ str . charAt ( i ) - 97 ] == i ) { int occ = str . charAt ( i ) - 96 ; while ( occ -- > 0 ) { res += str . charAt ( i ) ; } } else if ( ( str . charAt ( i ) >= ' A ' && str . charAt ( i ) <= ' Z ' ) && capital [ str . charAt ( i ) - 65 ] == i ) { int occ = str . charAt ( i ) - 64 ; while ( occ -- > 0 ) { res = res + str . charAt ( i ) ; } } else if ( ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) && num [ str . charAt ( i ) - 48 ] == i ) { int occ = str . charAt ( i ) - 48 ; while ( occ -- > 0 ) { res = res + str . charAt ( i ) ; } } else { res = res + str . charAt ( i ) ; } } System . out . print ( res ) ; } public static void main ( String [ ] args ) { String str = " Ea2 , ▁ 0 , ▁ E " ; encodeString ( str ) ; } }
import java . io . * ; class GFG { public static void createGrid ( char [ ] [ ] grid , boolean is1 , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( is1 ) { grid [ i ] [ j ] = '0' ; is1 = false ; } else { grid [ i ] [ j ] = '1' ; is1 = true ; } } if ( M % 2 == 0 ) is1 = ! is1 ; } } public static boolean testGrid ( char [ ] [ ] testGrid , char [ ] [ ] Grid , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( Grid [ i ] [ j ] != ' * ' ) { if ( Grid [ i ] [ j ] != testGrid [ i ] [ j ] ) { return false ; } } } } return true ; } public static void printGrid ( char [ ] [ ] grid , int N , int M ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { System . out . print ( grid [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } public static void findPossibleGrid ( int N , int M , char [ ] [ ] grid ) { char [ ] [ ] gridTest1 = new char [ N ] [ 1001 ] ; char [ ] [ ] gridTest2 = new char [ N ] [ 1001 ] ; createGrid ( gridTest1 , true , N , M ) ; createGrid ( gridTest2 , false , N , M ) ; if ( testGrid ( gridTest1 , grid , N , M ) ) { System . out . println ( " Yes " ) ; printGrid ( gridTest1 , N , M ) ; } else if ( testGrid ( gridTest2 , grid , N , M ) ) { System . out . println ( " Yes " ) ; printGrid ( gridTest2 , N , M ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int N = 4 , M = 4 ; char [ ] [ ] grid = { { ' * ' , ' * ' , '1' , '0' } , { ' * ' , ' * ' , ' * ' , ' * ' } , { ' * ' , ' * ' , ' * ' , ' * ' } , { ' * ' , ' * ' , '0' , '1' } } ; findPossibleGrid ( N , M , grid ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int findMinMoves ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum % N != 0 ) return - 1 ; int avg = sum / N ; int total = 0 ; int needCount = 0 ; for ( int i = 0 ; i < N ; i ++ ) { needCount += ( arr [ i ] - avg ) ; total = Math . max ( Math . max ( Math . abs ( needCount ) , arr [ i ] - avg ) , total ) ; } return total ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 5 } ; int N = arr . length ; System . out . println ( findMinMoves ( arr , N ) ) ; } }
import java . util . * ; class GFG { static void getZarr ( String str , int Z [ ] ) { int n = str . length ( ) ; int k ; int L = 0 ; int R = 0 ; for ( int i = 1 ; i < n ; ++ i ) { if ( i > R ) { L = R = i ; while ( R < n && str . charAt ( R - L ) == str . charAt ( R ) ) { R ++ ; } Z [ i ] = R - L ; R -- ; } else { k = i - L ; if ( Z [ k ] < R - i + 1 ) { Z [ i ] = Z [ k ] ; } else { L = i ; while ( R < n && str . charAt ( R - L ) == str . charAt ( R ) ) { R ++ ; } Z [ i ] = R - L ; R -- ; } } } } static String goodStr ( String str , String word ) { String concat = word + " $ " + str ; int l = concat . length ( ) ; int [ ] Z = new int [ l ] ; getZarr ( concat , Z ) ; String res = " " ; int pSize = word . length ( ) ; for ( int i = 0 ; i < l ; ++ i ) { if ( i + pSize < l - 1 && Z [ i + pSize + 1 ] == pSize ) { i += pSize - 1 ; } else if ( i < str . length ( ) ) { res += str . charAt ( i ) ; } } return res ; } public static void main ( String [ ] args ) { String str = " Z - kmalgorithmkmiskmkmkmhelpfulkminkmsearching " ; String word = " km " ; System . out . print ( goodStr ( str , word ) ) ; } }
import java . io . * ; class GFG { static void sumOfSubarrayProd ( int arr [ ] , int n ) { int ans = 0 ; int res = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int incr = arr [ i ] * ( 1 + res ) ; ans += incr ; res = incr ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int N = arr . length ; sumOfSubarrayProd ( arr , N ) ; } }
import java . util . * ; class GFG { static int phi ( int n ) { int result = 1 ; for ( int p = 2 ; p < n ; p ++ ) { if ( __gcd ( p , n ) == 1 ) { result ++ ; } } return result ; } static boolean sameEulerTotient ( int n ) { return phi ( n ) == phi ( 2 * n ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int N = 13 ; if ( sameEulerTotient ( N ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static int printOddFactorNumber ( int n , int m ) { for ( int i = n ; i <= m ; i ++ ) { if ( ( i > 0 ) && ( ( i & ( i - 1 ) ) != 0 ) ) System . out . print ( i + " ▁ " ) ; } return 0 ; } public static void main ( String [ ] args ) { int N = 2 , M = 10 ; printOddFactorNumber ( N , M ) ; } }
class GFG { static void printSeries ( int n ) { int k = 2 ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( k * ( 2 * k - 1 ) + " ▁ " ) ; k += 2 ; } System . out . println ( ) ; } public static void main ( String args [ ] ) { int N = 12 ; printSeries ( N ) ; } }
import java . util . * ; class GFG { static void printSinX ( int N ) { int Xi = 0 ; int num = 1 ; while ( N -- > 0 ) { System . out . print ( " X " + num + " ▁ = ▁ " + Xi ) ; System . out . print ( " ▁ sin ( X " + num + " ) ▁ = ▁ " ) ; System . out . printf ( " % .6f " , Math . sin ( Xi ) ) ; System . out . println ( ) ; num += 1 ; Xi += 710 ; } } public static void main ( String [ ] args ) { int N = 5 ; printSinX ( N ) ; } }
import java . util . * ; class GFG { static void sumBetweenZero ( int arr [ ] , int N ) { int i = 0 ; Vector < Integer > A = new Vector < Integer > ( ) ; int sum = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { i ++ ; break ; } } for ( ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { A . add ( sum ) ; sum = 0 ; } else { sum += arr [ i ] ; } } for ( int j = 0 ; j < A . size ( ) ; j ++ ) { System . out . print ( A . get ( j ) + " ▁ " ) ; } if ( A . size ( ) == 0 ) System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 3 , 4 , 0 , 4 , 4 , 0 , 2 , 1 , 4 , 0 , 3 } ; int N = arr . length ; sumBetweenZero ( arr , N ) ; } }
import java . util . * ; class GFG { static int countCharacters ( List < String > strings , String chars ) { int res = 0 ; Map < Character , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < chars . length ( ) ; i ++ ) { freq . put ( chars . charAt ( i ) , freq . getOrDefault ( chars . charAt ( i ) , 0 ) + 1 ) ; } for ( String st : strings ) { boolean flag = true ; for ( char c : st . toCharArray ( ) ) { if ( ! freq . containsKey ( c ) ) { flag = false ; break ; } } if ( flag ) res += st . length ( ) ; } return res ; } public static void main ( String [ ] args ) { List < String > strings = Arrays . asList ( " hi " , " data " , " geeksforgeeks " ) ; String chars = " tiadhae " ; System . out . println ( countCharacters ( strings , chars ) ) ; } }
class GFG { static void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { System . out . print ( ( 3 * i * ( i - 1 ) + 1 ) + " ▁ " ) ; i ++ ; } } public static void main ( String [ ] args ) { int n = 4 ; findNumbers ( n ) ; } }
class GFG { static int getEndingIndex ( String str , int n , int i ) { i ++ ; while ( i < n ) { char curr = str . charAt ( i ) ; char prev = str . charAt ( i - 1 ) ; if ( ( curr == ' a ' && prev == ' z ' ) || ( curr - prev == 1 ) ) i ++ ; else break ; } return i - 1 ; } static int largestSubStr ( String str , int n ) { int len = 0 ; int i = 0 ; while ( i < n ) { int end = getEndingIndex ( str , n , i ) ; len = Math . max ( end - i + 1 , len ) ; i = end + 1 ; } return len ; } public static void main ( String args [ ] ) { String str = " abcabcdefabc " ; int n = str . length ( ) ; System . out . print ( largestSubStr ( str , n ) ) ; } }
import java . util . HashMap ; class GFG { static String smallestFreq ( String S1 , String S2 ) { HashMap < String , Integer > banned = new HashMap < > ( ) ; for ( int i = 0 ; i < S2 . length ( ) ; i ++ ) { String s = " " ; while ( i < S2 . length ( ) && S2 . charAt ( i ) != ' ▁ ' ) s += S2 . charAt ( i ++ ) ; banned . put ( s , banned . get ( s ) == null ? 1 : banned . get ( s ) + 1 ) ; } HashMap < String , Integer > result = new HashMap < > ( ) ; String ans = " " ; int freq = 0 ; for ( int i = 0 ; i < S1 . length ( ) ; i ++ ) { String s = " " ; while ( i < S1 . length ( ) && S1 . charAt ( i ) != ' ▁ ' ) s += S1 . charAt ( i ++ ) ; if ( banned . get ( s ) == null ) { result . put ( s , result . get ( s ) == null ? 1 : result . get ( s ) + 1 ) ; if ( result . get ( s ) > freq || ( result . get ( s ) == freq && s . compareTo ( ans ) < 0 ) ) { ans = s ; freq = result . get ( s ) ; } } } return ans ; } public static void main ( String [ ] args ) { String S1 = " geeks ▁ for ▁ geeks ▁ is ▁ best ▁ place ▁ to ▁ learn " ; String S2 = " bad ▁ place " ; System . out . println ( smallestFreq ( S1 , S2 ) ) ; } }
class GFG { static int isSubstring ( String s1 , String s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 . charAt ( i + j ) != s1 . charAt ( j ) ) break ; if ( j == M ) return i ; } return - 1 ; } public static void main ( String args [ ] ) { String s1 = " for " ; String s2 = " geeksforgeeks " ; int res = isSubstring ( s1 , s2 ) ; if ( res == - 1 ) System . out . println ( " Not ▁ present " ) ; else System . out . println ( " Present ▁ at ▁ index ▁ " + res ) ; } }
import java . io . * ; class GFG { static int patternCount ( String str ) { char last = str . charAt ( 0 ) ; int i = 1 , counter = 0 ; while ( i < str . length ( ) ) { if ( str . charAt ( i ) == '0' && last == '1' ) { while ( str . charAt ( i ) == '0' ) i ++ ; if ( str . charAt ( i ) == '1' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; } public static void main ( String [ ] args ) { String str = "1001ab010abc01001" ; System . out . println ( patternCount ( str ) ) ; } }
import java . io . * ; import java . util . * ; public class index { static int max = 0 ; static String ans1 = " " ; static void calculate ( String ans ) { int dp [ ] = new int [ 26 ] ; for ( int i = 0 ; i < ans . length ( ) ; ++ i ) { dp [ ans . charAt ( i ) - ' A ' ] ++ ; } for ( int i = 0 ; i < dp . length ; ++ i ) { if ( dp [ i ] % 2 == 1 ) { return ; } } if ( max < ans . length ( ) ) { max = ans . length ( ) ; ans1 = ans ; } } static void longestString ( List < String > arr , int index , String str ) { if ( index == arr . size ( ) ) { return ; } longestString ( arr , index + 1 , str ) ; str += arr . get ( index ) ; calculate ( str ) ; longestString ( arr , index + 1 , str ) ; } public static void main ( String [ ] args ) { ArrayList < String > A = new ArrayList < > ( ) ; A . add ( " ABAB " ) ; A . add ( " ABF " ) ; A . add ( " CDA " ) ; A . add ( " AD " ) ; A . add ( " CCC " ) ; longestString ( A , 0 , " " ) ; System . out . println ( ans1 + " ▁ " + ans1 . length ( ) ) ; } }
class GFG { static void findSubsequence ( String str ) { int n = str . length ( ) ; char [ ] res = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) res [ i ] = 0 ; for ( int pos = 0 ; pos <= 9 ; pos ++ ) { char lst1 = '0' ; boolean flag = true ; char lst2 = ( char ) ( pos + '0' ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( lst2 <= str . charAt ( i ) ) { res [ i ] = '2' ; lst2 = str . charAt ( i ) ; } else if ( lst1 <= str . charAt ( i ) ) { res [ i ] = '1' ; lst1 = str . charAt ( i ) ; } else flag = false ; } if ( lst1 > pos + '0' ) flag = false ; if ( flag ) { String S1 = " " ; String S2 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( res [ i ] == '1' ) { S1 += str . charAt ( i ) ; } else { S2 += str . charAt ( i ) ; } } System . out . print ( S1 + " ▁ " + S2 + "NEW_LINE"); return ; } } System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { String S = "040425524644" ; findSubsequence ( S ) ; S = "123456789" ; findSubsequence ( S ) ; } }
import java . util . * ; class GFG { static String ans , s ; static int K ; static void getString ( int curlen , int N , int [ ] prod ) { if ( curlen == N ) { K -- ; if ( K == 0 ) ans = s ; return ; } char ch ; int ok , t , i ; for ( ch = '2' ; ch <= '9' ; ch ++ ) { s += ch ; ok = 1 ; t = 1 ; for ( i = curlen ; i >= 0 && s . length ( ) > i ; i -- ) { t *= s . charAt ( i ) - 48 ; if ( prod [ t ] != 0 ) ok = 0 ; prod [ t ] ++ ; } if ( ok != 0 ) getString ( curlen + 1 , N , prod ) ; t = 1 ; for ( i = curlen ; i >= 0 && s . length ( ) > i ; i -- ) { t *= s . charAt ( i ) - 48 ; prod [ t ] -- ; } if ( s . length ( ) > 0 ) s = s . substring ( 0 , s . length ( ) - 1 ) ; } } static String kthValidString ( int N ) { if ( N > 10 ) { return " - 1" ; } if ( N == 1 ) { if ( K > 10 ) { return " - 1" ; } String s = " " ; K -- ; s += ( K + '0' ) ; return s ; } ans = " - 1" ; s = " " ; int [ ] prod = new int [ 10005 ] ; getString ( 0 , N , prod ) ; return ans ; } public static void main ( String [ ] args ) { int N = 3 ; K = 4 ; System . out . print ( kthValidString ( N ) ) ; } }
public class GFG { static String checkIfPossible ( int N , String [ ] arr , String T ) { int [ ] freqS = new int [ 256 ] ; int [ ] freqT = new int [ 256 ] ; for ( char ch : T . toCharArray ( ) ) { freqT [ ch - ' a ' ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) { for ( char ch : arr [ i ] . toCharArray ( ) ) { freqS [ ch - ' a ' ] ++ ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( freqT [ i ] == 0 && freqS [ i ] != 0 ) { return " No " ; } else if ( freqS [ i ] == 0 && freqT [ i ] != 0 ) { return " No " ; } else if ( freqT [ i ] != 0 && freqS [ i ] != ( freqT [ i ] * N ) ) { return " No " ; } } return " Yes " ; } public static void main ( String [ ] args ) { String [ ] arr = { " abc " , " abb " , " acc " } ; String T = " abc " ; int N = arr . length ; System . out . println ( checkIfPossible ( N , arr , T ) ) ; } }
import java . util . Stack ; class GFG { static int groupsOfOnes ( String S , int N ) { int count = 0 ; Stack < Integer > st = new Stack < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . charAt ( i ) == '1' ) st . push ( 1 ) ; else { if ( ! st . empty ( ) ) { count ++ ; while ( ! st . empty ( ) ) { st . pop ( ) ; } } } } if ( ! st . empty ( ) ) count ++ ; return count ; } public static void main ( String [ ] args ) { String S = "100110111" ; int N = S . length ( ) ; System . out . println ( groupsOfOnes ( S , N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static void findMinimumCost ( String s , int N ) { int count_1 = 0 , count_0 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == '1' ) count_1 ++ ; else count_0 ++ ; } int k = Math . abs ( count_0 - count_1 ) ; if ( count_1 == N count_0 == N ) System . out . println ( - 1 ) ; else System . out . println ( k / 2 ) ; } public static void main ( String [ ] args ) { String S = "110110" ; int N = S . length ( ) ; findMinimumCost ( S , N ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; public class GFG { static int minLength ( String S ) { Stack < Character > st = new Stack < > ( ) ; for ( char ch : S . toCharArray ( ) ) { if ( st . isEmpty ( ) ) st . push ( ch ) ; else { char top = st . peek ( ) ; if ( Math . abs ( ch - top ) == 1 ) st . pop ( ) ; else { st . push ( ch ) ; } } } return st . size ( ) ; } public static void main ( String [ ] args ) { String S = "12213" ; System . out . println ( minLength ( S ) ) ; } }
import java . util . * ; class GFG { static int minimumDeletions ( String s ) { int right_0 = ( int ) ( s . chars ( ) . filter ( ch -> ch == '0' ) . count ( ) ) ; int left_1 = 0 ; int n = s . length ( ) ; int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) { right_0 -= 1 ; } else { left_1 += 1 ; } res = Math . min ( res , right_0 + left_1 ) ; } return res ; } public static void main ( String [ ] args ) { String s = "001101" ; int count = minimumDeletions ( s ) ; System . out . print ( count ) ; } }
import java . io . * ; class GFG { static void cntBalancedParenthesis ( String s , int N ) { int cntPairs = 0 ; int cntCurly = 0 ; int cntSml = 0 ; int cntSqr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s . charAt ( i ) == ' { ' ) { cntCurly ++ ; } else if ( s . charAt ( i ) == ' ( ' ) { cntSml ++ ; } else if ( s . charAt ( i ) == ' [ ' ) { cntSqr ++ ; } else if ( s . charAt ( i ) == ' } ' && cntCurly > 0 ) { cntCurly -- ; cntPairs ++ ; } else if ( s . charAt ( i ) == ' ) ' && cntSml > 0 ) { cntSml -- ; cntPairs ++ ; } else if ( s . charAt ( i ) == ' ] ' && cntSqr > 0 ) { cntSqr -- ; cntPairs ++ ; } } System . out . println ( cntPairs ) ; } public static void main ( String [ ] args ) { String s = " { ( } ) " ; int N = s . length ( ) ; cntBalancedParenthesis ( s , N ) ; } }
import java . util . * ; class GFG { static boolean canBeBalanced ( String sequence ) { if ( sequence . length ( ) % 2 == 1 ) return false ; Stack < Character > stack_ = new Stack < Character > ( ) ; Stack < Character > stack2_ = new Stack < Character > ( ) ; int countOpen = 0 , countClosed = 0 ; int countSymbol = 0 ; for ( int i = 0 ; i < sequence . length ( ) ; i ++ ) { if ( sequence . charAt ( i ) == ' ) ' ) { countClosed ++ ; if ( stack_ . isEmpty ( ) ) { return false ; } else { stack_ . pop ( ) ; } } else { if ( sequence . charAt ( i ) == ' $ ' ) { countSymbol ++ ; } else { countOpen ++ ; } stack_ . add ( sequence . charAt ( i ) ) ; } } for ( int i = sequence . length ( ) - 1 ; i >= 0 ; i -- ) { if ( sequence . charAt ( i ) == ' ( ' ) { if ( stack2_ . isEmpty ( ) ) { return false ; } else { stack2_ . pop ( ) ; } } else { stack2_ . add ( sequence . charAt ( i ) ) ; } } int extra = Math . abs ( countClosed - countOpen ) ; if ( countSymbol < extra ) { return false ; } else { countSymbol -= extra ; if ( countSymbol % 2 == 0 ) { return true ; } } return false ; } public static void main ( String [ ] args ) { String S = " ( ) ( $ " ; if ( canBeBalanced ( S ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
import java . util . * ; class GFG { static void maxDiffFreq ( int [ ] [ ] queries , String S ) { int N = S . length ( ) ; int Q = queries . length ; for ( int i = 0 ; i < Q ; ++ i ) { int l = queries [ i ] [ 0 ] - 1 ; int r = queries [ i ] [ 1 ] - 1 ; int freq [ ] = new int [ 26 ] ; for ( int j = l ; j <= r ; j ++ ) { freq [ S . charAt ( j ) - ' a ' ] ++ ; } int mx = 0 ; int mn = 99999999 ; for ( int j = 0 ; j < 26 ; j ++ ) { mx = Math . max ( mx , freq [ j ] ) ; if ( freq [ j ] > 0 ) mn = Math . min ( mn , freq [ j ] ) ; } System . out . print ( mx - mn + "NEW_LINE"); } } public static void main ( String [ ] args ) { String S = " abaabac " ; int [ ] [ ] queries = { { 2 , 6 } , { 1 , 7 } } ; maxDiffFreq ( queries , S ) ; } }
class GFG { static boolean isEqualStrings ( String [ ] arr , int N ) { int M = arr [ 0 ] . length ( ) ; int [ ] cntFreq = new int [ 256 ] ; for ( int i = 0 ; i < N ; i ++ ) { cntFreq [ i ] = 0 ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { cntFreq [ arr [ i ] . charAt ( j ) - ' a ' ] += 1 ; } } for ( int i = 0 ; i < 256 ; i ++ ) { if ( cntFreq [ i ] % N != 0 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String [ ] arr = { " aab " , " bbc " , " cca " } ; int N = arr . length ; if ( isEqualStrings ( arr , N ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . util . * ; public class GFG { public static void findFreq ( String str , int N ) { int [ ] freq = new int [ 256 ] ; int max = 0 ; char charMax = '0' ; for ( int i = 0 ; i < N ; i ++ ) { char ch = str . charAt ( i ) ; freq [ ch ] ++ ; if ( freq [ ch ] >= max ) { max = freq [ ch ] ; charMax = ch ; } System . out . println ( charMax + " ▁ - > ▁ " + max ) ; } } public static void main ( String [ ] args ) { String str = " abbc " ; int N = str . length ( ) ; findFreq ( str , N ) ; } }
class GFG { static int countOfSubstringWithOnlyOnes ( String s ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { count = s . charAt ( i ) == '1' ? count + 1 : 0 ; res = ( res + count ) ; } return res ; } public static void main ( String [ ] args ) { String s = "0110111" ; System . out . println ( countOfSubstringWithOnlyOnes ( s ) ) ; } }
import java . util . * ; class GFG { static int N = 1000000 + 5 ; static int [ ] prefix = new int [ N ] ; static int [ ] sum = new int [ N ] ; static int isSpecial ( char c , char [ ] special ) { for ( char i : special ) if ( i == c ) return 1 ; return 0 ; } static double countRatio ( char [ ] s , char [ ] special ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { prefix [ i ] = ( isSpecial ( s [ i ] , special ) ) ; if ( i > 0 ) prefix [ i ] += prefix [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { sum [ i ] = prefix [ i ] ; if ( i > 0 ) sum [ i ] += sum [ i - 1 ] ; } double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int count = sum [ n - 1 ] - ( i > 1 ? sum [ i - 2 ] : 0 ) ; count -= ( i < n ? sum [ n - i - 1 ] : 0 ) ; ans += ( double ) count / ( double ) i ; } return ans ; } public static void main ( String [ ] args ) { String s = " abcd " ; char [ ] special = { ' b ' , ' c ' } ; double ans = countRatio ( s . toCharArray ( ) , special ) ; System . out . format ( " % .6f " , ans ) ; } }
class GFG { public static boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) { if ( str . charAt ( l ) != str . charAt ( h ) ) { return false ; } l ++ ; h -- ; } return true ; } public static String makeOddString ( String str ) { String odd = " " ; for ( int i = 1 ; i < str . length ( ) ; i += 2 ) { odd += str . charAt ( i ) ; } return odd ; } public static void checkOddlyPalindrome ( String str ) { String odd = makeOddString ( str ) ; if ( isPalindrome ( odd ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { String str = " ddwfefwde " ; checkOddlyPalindrome ( str ) ; } }
class GFG { public static boolean checkSuffix ( int A , int B ) { String s1 = String . valueOf ( A ) ; String s2 = String . valueOf ( B ) ; int n1 = s1 . length ( ) ; int n2 = s2 . length ( ) ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 . charAt ( n1 - i - 1 ) != s2 . charAt ( n2 - i - 1 ) ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int A = 12345 , B = 45 ; boolean result = checkSuffix ( A , B ) ; if ( result ) { System . out . print ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static boolean isPossibleSum ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) { return true ; } else { return false ; } } static boolean checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) { ++ cnt ; } return cnt == 2 ; } static void makeCypherString ( int N ) { String semiPrime = " " ; String sumOfPrime = " " ; String str = String . valueOf ( N ) ; if ( checkSemiprime ( N ) ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i % 2 == 1 ) { semiPrime += str . charAt ( i ) ; } else { semiPrime += ( char ) ( str . charAt ( i ) - '0' + 65 ) ; } } } if ( isPossibleSum ( N ) ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( i % 2 == 1 ) { sumOfPrime += ( char ) ( str . charAt ( i ) - '0' + 65 ) ; } else { sumOfPrime += str . charAt ( i ) ; } } } if ( semiPrime + sumOfPrime == " " ) { System . out . print ( " - 1" ) ; } else { System . out . print ( semiPrime + sumOfPrime ) ; } } public static void main ( String [ ] args ) { int N = 1011243 ; makeCypherString ( N ) ; } }
class GFG { static void kth_String ( int n , int k ) { for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( k <= ( n - i - 1 ) ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j == i j == n - k ) System . out . print ( ' Y ' ) ; else System . out . print ( ' X ' ) ; } break ; } k -= ( n - i - 1 ) ; } } public static void main ( String [ ] args ) { int n = 5 , k = 7 ; kth_String ( n , k ) ; } }
import java . util . * ; class GFG { static String removeDuplicates ( String str ) { int n = str . length ( ) ; String res = " " ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = i + 1 ; j < n ; j ++ ) if ( str . charAt ( i ) == str . charAt ( j ) ) break ; if ( j == n ) res = res + str . charAt ( i ) ; } return res ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; System . out . print ( removeDuplicates ( str ) ) ; } }
class GFG { static int value ( char x ) { return ( int ) ( x - ' a ' ) ; } static String maximumProduct ( String str , int n ) { String answer = " " , curr = " " ; long maxProduct = 0 , product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product *= 1L * value ( str . charAt ( i ) ) ; curr += str . charAt ( i ) ; if ( product >= maxProduct ) { maxProduct = product ; answer = curr ; } if ( product == 0 ) { product = 1 ; curr = " " ; } } return answer ; } public static void main ( String [ ] args ) { String str = " sdtfakdhdahdzz " ; int n = str . length ( ) ; System . out . print ( maximumProduct ( str , n ) + "NEW_LINE"); } }
class GFG { static void kthString ( int n , int k ) { int total = 0 ; int i = 1 ; while ( total < k ) { total = total + n - i ; i ++ ; } int first_y_position = i - 1 ; int second_y_position = k - ( total - n + first_y_position ) ; for ( int j = 1 ; j < first_y_position ; j ++ ) System . out . print ( " x " ) ; System . out . print ( " y " ) ; int j = first_y_position + 1 ; while ( second_y_position > 1 ) { System . out . print ( " x " ) ; second_y_position -- ; j ++ ; } System . out . print ( " y " ) ; while ( j < n ) { System . out . print ( " x " ) ; j ++ ; } } public static void main ( String [ ] args ) { int n = 5 ; int k = 7 ; kthString ( n , k ) ; } }
class GFG { static int XorAscii ( String str , int len ) { int ans = ( str . charAt ( 0 ) ) ; for ( int i = 1 ; i < len ; i ++ ) { ans = ( ans ^ ( ( str . charAt ( i ) ) ) ) ; } return ans ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int len = str . length ( ) ; System . out . print ( XorAscii ( str , len ) + "NEW_LINE"); str = " GfG " ; len = str . length ( ) ; System . out . print ( XorAscii ( str , len ) ) ; } }
class GFG { static int i ; static int productAtKthLevel ( String tree , int k , int level ) { if ( tree . charAt ( i ++ ) == ' ( ' ) { if ( tree . charAt ( i ) == ' ) ' ) return 1 ; int product = 1 ; if ( level == k ) product = tree . charAt ( i ) - '0' ; ++ i ; int leftproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; int rightproduct = productAtKthLevel ( tree , k , level + 1 ) ; ++ i ; return product * leftproduct * rightproduct ; } return Integer . MIN_VALUE ; } public static void main ( String [ ] args ) { String tree = " ( 0(5(6 ( ) ( ) ) ( 4 ( ) " + " ( 9 ( ) ( ) ) ) ) ( 7(1 ( ) ( ) ) ( 3 ( ) ( ) ) ) ) " ; int k = 2 ; i = 0 ; System . out . print ( productAtKthLevel ( tree , k , 0 ) ) ; } }
import java . util . * ; class GFG { static String CHARS = " qwertyuiopasdfghjklzxcvbnm " ; static int MAX = 26 ; static String getString ( char [ ] str , int n ) { Map < Character , Character > uMap = new HashMap < > ( ) ; for ( int i = 0 ; i < MAX ; i ++ ) { uMap . put ( CHARS . charAt ( i ) , CHARS . charAt ( ( i + 1 ) % MAX ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { str [ i ] = uMap . get ( str [ i ] ) ; } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = " geeks " ; int n = str . length ( ) ; System . out . println ( getString ( str . toCharArray ( ) , n ) ) ; } }
class GFG { final static int MOD = 1000000007 ; static long countStrings ( int N ) { int i , j ; int dp [ ] [ ] = new int [ N + 1 ] [ 3 ] ; for ( i = 0 ; i < N + 1 ; i ++ ) { for ( j = 9 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ; dp [ 1 ] [ 2 ] = 0 ; for ( i = 2 ; i <= N ; i ++ ) { dp [ i ] [ 0 ] = ( dp [ i - 1 ] [ 0 ] + dp [ i - 1 ] [ 1 ] + dp [ i - 1 ] [ 2 ] ) % MOD ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] % MOD ; dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] % MOD ; } int ans = ( dp [ N ] [ 0 ] + dp [ N ] [ 1 ] + dp [ N ] [ 2 ] ) % MOD ; return ans ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( countStrings ( N ) ) ; } }
import java . util . * ; class GFG { static String maxNumber ( String str , int n ) { int [ ] freq = new int [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' z ' ) freq [ 0 ] ++ ; else if ( str . charAt ( i ) == ' n ' ) freq [ 1 ] ++ ; } String num = " " ; for ( int i = 0 ; i < freq [ 1 ] ; i ++ ) num += '1' ; for ( int i = 0 ; i < freq [ 0 ] ; i ++ ) num += '0' ; return num ; } public static void main ( String [ ] args ) { String str = " roenenzooe " ; int n = str . length ( ) ; System . out . println ( maxNumber ( str , n ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { String string = " { [ ( ) ] } [ ] " ; char [ ] lst1 = { ' { ' , ' ( ' , ' [ ' } ; char [ ] lst2 = { ' } ' , ' ) ' , ' ] ' } ; Vector < Character > lst = new Vector < Character > ( ) ; HashMap < Character , Character > Dict = new HashMap < > ( ) ; Dict . put ( ' ) ' , ' ( ' ) ; Dict . put ( ' } ' , ' { ' ) ; Dict . put ( ' ] ' , ' [ ' ) ; int a = 0 , b = 0 , c = 0 ; if ( Arrays . asList ( lst2 ) . contains ( string . charAt ( 0 ) ) ) { System . out . println ( 1 ) ; } else { int k = 0 ; for ( int i = 0 ; i < string . length ( ) ; i ++ ) { if ( Arrays . asList ( lst1 ) . contains ( string . charAt ( i ) ) ) { lst . add ( string . charAt ( i ) ) ; k = i + 2 ; } else { if ( lst . size ( ) == 0 && Arrays . asList ( lst2 ) . contains ( string . charAt ( i ) ) ) { System . out . println ( ( i + 1 ) ) ; c = 1 ; break ; } else { if ( lst . size ( ) > 0 && Dict . get ( string . charAt ( i ) ) == lst . get ( lst . size ( ) - 1 ) ) { lst . remove ( lst . size ( ) - 1 ) ; } else { a = 1 ; break ; } } } } if ( lst . size ( ) == 0 && c == 0 ) { System . out . println ( 0 ) ; b = 1 ; } if ( a == 0 && b == 0 && c == 0 ) { System . out . println ( k ) ; } } } }
public class GFG { static final int MAX = 26 ; static String encryptStr ( String str , int n , int x ) { x = x % MAX ; char arr [ ] = str . toCharArray ( ) ; int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] - ' a ' ] % 2 == 0 ) { int pos = ( arr [ i ] - ' a ' + x ) % MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; } else { int pos = ( arr [ i ] - ' a ' - x ) ; if ( pos < 0 ) pos += MAX ; arr [ i ] = ( char ) ( pos + ' a ' ) ; } } return String . valueOf ( arr ) ; } public static void main ( String [ ] args ) { String s = " abcda " ; int n = s . length ( ) ; int x = 3 ; System . out . println ( encryptStr ( s , n , x ) ) ; } }
import java . util . * ; class GFG { static int countOccurrence ( String s , int position ) { int [ ] alpha = new int [ 26 ] ; int [ ] b = new int [ s . length ( ) ] ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { b [ i ] = alpha [ ( int ) s . charAt ( i ) - 97 ] ; alpha [ ( int ) s . charAt ( i ) - 97 ] ++ ; } return b [ position - 1 ] ; } public static void main ( String [ ] args ) { String s = " ababababab " ; int p = 9 ; System . out . println ( countOccurrence ( s , p ) ) ; } }
import java . util . * ; class GFG { static boolean isPossible ( char [ ] str ) { Map < Character , Integer > freq = new HashMap < > ( ) ; int max_freq = 0 ; for ( int j = 0 ; j < ( str . length ) ; j ++ ) { if ( freq . containsKey ( str [ j ] ) ) { freq . put ( str [ j ] , freq . get ( str [ j ] ) + 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } else { freq . put ( str [ j ] , 1 ) ; if ( freq . get ( str [ j ] ) > max_freq ) max_freq = freq . get ( str [ j ] ) ; } } if ( max_freq <= ( str . length - max_freq + 1 ) ) return true ; return false ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; if ( isPossible ( str . toCharArray ( ) ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static void printUncommon ( String str1 , String str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = ( str1 . charAt ( i ) ) - ' a ' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = ( str2 . charAt ( i ) ) - ' a ' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { System . out . print ( ( char ) ( ' a ' + i ) ) ; } ans = ans / 2 ; i ++ ; } } public static void main ( String [ ] args ) { String str1 = " geeksforgeeks " ; String str2 = " geeksquiz " ; printUncommon ( str1 , str2 ) ; } }
import java . util . * ; class GFG { static int cnt = 0 ; static Vector < Integer > [ ] graph = new Vector [ 100 ] ; static String [ ] weight = new String [ 100 ] ; static boolean uniqueChars ( char [ ] arr ) { HashMap < Character , Integer > mp = new HashMap < Character , Integer > ( ) ; int n = arr . length ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } if ( mp . size ( ) == arr . length ) return true ; else return false ; } static void dfs ( int node , int parent ) { if ( uniqueChars ( weight [ node ] . toCharArray ( ) ) ) cnt += 1 ; for ( int to : graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } } public static void main ( String [ ] args ) { for ( int i = 0 ; i < 100 ; i ++ ) graph [ i ] = new Vector < Integer > ( ) ; weight [ 1 ] = " abc " ; weight [ 2 ] = " aba " ; weight [ 3 ] = " bcb " ; weight [ 4 ] = " moh " ; weight [ 5 ] = " aa " ; graph [ 1 ] . add ( 2 ) ; graph [ 2 ] . add ( 3 ) ; graph [ 2 ] . add ( 4 ) ; graph [ 1 ] . add ( 5 ) ; dfs ( 1 , 1 ) ; System . out . print ( cnt ) ; } }
import java . util . * ; class GFG { static boolean check ( String s , int l ) { Vector < Integer > pos = new Vector < Integer > ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '1' ) pos . add ( i ) ; } int t = pos . size ( ) ; for ( int i = 1 ; i < t ; i ++ ) { if ( ( pos . get ( i ) - pos . get ( i - 1 ) ) != ( pos . get ( 1 ) - pos . get ( 0 ) ) ) return false ; } return true ; } public static void main ( String args [ ] ) { String s = "100010001000" ; int l = s . length ( ) ; if ( check ( s , l ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static boolean isPrefix ( String str , int len , int i , int k ) { if ( i + k > len ) return false ; for ( int j = 0 ; j < k ; j ++ ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; } return true ; } static boolean isKPeriodic ( String str , int len , int k ) { for ( int i = k ; i < len ; i += k ) if ( ! isPrefix ( str , len , i , k ) ) return false ; return true ; } public static void main ( String [ ] args ) { String str = " geeksgeeks " ; int len = str . length ( ) ; int k = 5 ; if ( isKPeriodic ( str , len , k ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static int pangramCost ( int arr [ ] , String str ) { int cost = 0 ; boolean [ ] occurred = new boolean [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) occurred [ i ] = false ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) occurred [ str . charAt ( i ) - ' a ' ] = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( occurred [ i ] == false ) cost += arr [ i ] ; } return cost ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 } ; String str = " abcdefghijklmopqrstuvwz " ; System . out . println ( pangramCost ( arr , str ) ) ; } }
public class GFG { static int check ( String s ) { int i , j ; int fr [ ] = new int [ 26 ] ; int n = s . length ( ) ; for ( i = 0 ; i < n ; i ++ ) { char x = s . charAt ( i ) ; fr [ x - ' a ' ] += 1 ; } int minimum = Integer . MAX_VALUE ; for ( i = 0 ; i < 26 ; i ++ ) { for ( j = i + 1 ; j < 26 ; j ++ ) { int z = fr [ i ] + fr [ j ] ; minimum = Math . min ( minimum , n - z ) ; } } return minimum ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; System . out . println ( check ( s ) ) ; } }
import java . util . * ; class Solution { static String separateChar ( String str ) { int n = str . length ( ) , digitSum = 0 ; int alphabetSum = 0 , j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) >= '0' && str . charAt ( i ) <= '9' ) { digitSum += ( int ) ( str . charAt ( i ) - '0' ) ; } else { alphabetSum += str . charAt ( i ) - ' a ' + 1 ; alphabetSum %= 26 ; } } String sumStr = " " + ( digitSum ) ; char alphabetStr = ( char ) ( alphabetSum + ' a ' - 1 ) ; sumStr += alphabetStr ; return sumStr ; } public static void main ( String args [ ] ) { String str = "3652adyz3423" ; System . out . println ( separateChar ( str ) ) ; } }
class solution { static int countWords ( String str ) { int count = 1 ; for ( int i = 1 ; i < str . length ( ) - 1 ; i ++ ) { if ( str . charAt ( i ) >= 65 && str . charAt ( i ) <= 90 ) count ++ ; } return count ; } public static void main ( String args [ ] ) { String str = " geeksForGeeks " ; System . out . print ( countWords ( str ) ) ; } }
public class gfg { int find ( String s ) { int max = 0 , i , j = 0 , countk = 0 , countr = 0 ; int table [ ] [ ] = new int [ s . length ( ) ] [ 2 ] ; for ( i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' R ' ) countr ++ ; else table [ j ++ ] [ 0 ] = countr ; } j -- ; for ( i = s . length ( ) - 1 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == ' K ' ) { countk ++ ; table [ j -- ] [ 1 ] = countk ; } if ( Math . min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) > max ) max = Math . min ( table [ j + 1 ] [ 0 ] , table [ j + 1 ] [ 1 ] ) ; } return max ; } public static void main ( String srgs [ ] ) { String s = " RKRRRKKRRKKKKRR " ; gfg ob = new gfg ( ) ; int n = ob . find ( s ) ; System . out . println ( n ) ; } }
import java . util . ArrayList ; public class string_sort { public static int powerOfJump ( String s ) { int count = 1 ; int max_so_far = Integer . MIN_VALUE ; char ch = s . charAt ( s . length ( ) - 1 ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; } public static void main ( String [ ] args ) { String st = "1010101" ; System . out . println ( powerOfJump ( st ) ) ; } }
class GFG { public static String multiply ( String num1 , String num2 ) { int n1 = num1 . length ( ) ; int n2 = num2 . length ( ) ; if ( n1 == 0 n2 == 0 ) return "0" ; int [ ] result = new int [ n1 + n2 ] ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n_1 = num1 . charAt ( i ) - '0' ; i_n2 = 0 ; for ( int j = n2 - 1 ; j >= 0 ; j -- ) { int n_2 = num2 . charAt ( j ) - '0' ; int sum = n_1 * n_2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = " " ; while ( i >= 0 ) s += Integer . toString ( result [ i -- ] ) ; return s ; } public static void main ( String [ ] args ) { String str1 = "454545454545454545" ; System . out . println ( multiply ( str1 , str1 ) ) ; } }
import java . util . * ; class GFG { static boolean match_words ( String dictionary [ ] , String sentence [ ] , int n , int m ) { Map < String , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( dictionary [ i ] ) ) { mp . put ( dictionary [ i ] , mp . get ( dictionary [ i ] ) + 1 ) ; } else { mp . put ( dictionary [ i ] , 1 ) ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( mp . containsKey ( sentence [ i ] ) ) mp . put ( sentence [ i ] , mp . get ( sentence [ i ] ) - 1 ) ; else return false ; } return true ; } public static void main ( String [ ] args ) { String dictionary [ ] = { " find " , " a " , " geeks " , " all " , " for " , " on " , " geeks " , " answers " , " inter " } ; int n = dictionary . length ; String sentence [ ] = { " find " , " all " , " answers " , " on " , " geeks " , " for " , " geeks " } ; int m = sentence . length ; if ( match_words ( dictionary , sentence , n , m ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static int find_sub ( String s , int k ) { int len = s . length ( ) ; int lp = 0 , rp = 0 ; int ans = 0 ; int [ ] hash_char = new int [ 26 ] ; for ( ; rp < len ; rp ++ ) { hash_char [ s . charAt ( rp ) - ' a ' ] ++ ; while ( hash_char [ s . charAt ( rp ) - ' a ' ] > k ) { hash_char [ s . charAt ( lp ) - ' a ' ] -- ; lp ++ ; } ans += rp - lp + 1 ; } return ans ; } public static void main ( String [ ] args ) { String S = " aaabb " ; int k = 2 ; System . out . println ( find_sub ( S , k ) ) ; } }
import java . io . * ; public class GFG { static boolean transformString ( StringBuilder s ) { char ch = ' a ' ; if ( s . length ( ) < 26 ) return false ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( int ) ch > ( int ) ' z ' ) break ; if ( s . charAt ( i ) <= ch ) { s . setCharAt ( i , ch ) ; ch = ( char ) ( ( int ) ch + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; } public static void main ( String args [ ] ) { StringBuilder str = new StringBuilder ( " aaaaaaaaaaaaaaaaaaaaaaaaaa " ) ; if ( transformString ( str ) ) System . out . println ( str . toString ( ) ) ; else System . out . println ( " Not ▁ Possible " ) ; } }
class GFG { static boolean isPalindrome ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ++ ) != str . charAt ( j -- ) ) return false ; } return true ; } static String removePalinWords ( String str ) { String final_str = " " , word = " " ; str = str + " ▁ " ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != ' ▁ ' ) word = word + str . charAt ( i ) ; else { if ( ! ( isPalindrome ( word ) ) ) final_str += word + " ▁ " ; word = " " ; } } return final_str ; } public static void main ( String [ ] args ) { String str = " Text ▁ contains ▁ malayalam ▁ and ▁ level ▁ words " ; System . out . print ( removePalinWords ( str ) ) ; } }
import java . util . * ; import java . lang . * ; class GeeksforGeeks { static void ASCIISentence ( String str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str . charAt ( i ) ; System . out . print ( convert ) ; } } public static void main ( String args [ ] ) { String str = " GeeksforGeeks " ; System . out . println ( " ASCII ▁ Sentence : " ) ; ASCIISentence ( str ) ; } }
import java . io . * ; class GFG { static void convert ( String str ) { int n = str . length ( ) ; String str1 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' ▁ ' ) str1 = str1 + ' _ ' ; else str1 = str1 + Character . toLowerCase ( str . charAt ( i ) ) ; } System . out . print ( str1 ) ; } public static void main ( String args [ ] ) { String str = " I ▁ got ▁ intern ▁ at ▁ geeksforgeeks " ; convert ( str ) ; } }
public class GFG { static void findNextWord ( char [ ] s , int m ) { m += 97 ; int n = s . length ; int i = s . length - 1 ; s [ i ] ++ ; while ( i >= 0 && i <= n - 1 ) { if ( s [ i ] >= m ) { s [ i ] = ' a ' ; s [ -- i ] ++ ; } else if ( s [ i ] == s [ i - 1 ] s [ i ] == s [ i - 2 ] ) { s [ i ] ++ ; } else { i ++ ; } } if ( i <= - 1 ) { System . out . println ( " - 1" ) ; } else { System . out . println ( s ) ; } } public static void main ( String [ ] args ) { char [ ] str = " abcd " . toCharArray ( ) ; int k = 4 ; findNextWord ( str , k ) ; } }
import java . util . * ; class GFG { public static String nextWord ( String str ) { if ( str == " " ) return " a " ; int i = str . length ( ) - 1 ; while ( str . charAt ( i ) == ' z ' && i >= 0 ) i -- ; if ( i == - 1 ) str = str + ' a ' ; else str = str . substring ( 0 , i ) + ( char ) ( ( int ) ( str . charAt ( i ) ) + 1 ) + str . substring ( i + 1 ) ; return str ; } public static void main ( String [ ] args ) { String str = " samez " ; System . out . print ( nextWord ( str ) ) ; } }
import java . io . * ; public class GFG { static int MAX_CHAR = 26 ; static int leastCount ( String s1 , String s2 , int n ) { int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { count1 [ s1 . charAt ( i ) - ' a ' ] += 1 ; count2 [ s2 . charAt ( i ) - ' a ' ] += 1 ; } int res = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( count1 [ i ] != 0 ) { res += Math . abs ( count1 [ i ] - count2 [ i ] ) ; } } return res ; } static public void main ( String [ ] args ) { String s1 = " abc " ; String s2 = " cdd " ; int len = s1 . length ( ) ; int res = leastCount ( s1 , s2 , len ) ; System . out . println ( res ) ; } }
public class Longest_common_substr { static void printLCSubStr ( String X , String Y , int m , int n ) { int [ ] [ ] LCSuff = new int [ m + 1 ] [ n + 1 ] ; int len = 0 ; int row = 0 , col = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; if ( len < LCSuff [ i ] [ j ] ) { len = LCSuff [ i ] [ j ] ; row = i ; col = j ; } } else LCSuff [ i ] [ j ] = 0 ; } } if ( len == 0 ) { System . out . println ( " No ▁ Common ▁ Substring " ) ; return ; } String resultStr = " " ; while ( LCSuff [ row ] [ col ] != 0 ) { -- len ; row -- ; col -- ; } System . out . println ( resultStr ) ; } public static void main ( String args [ ] ) { String X = " OldSite : GeeksforGeeks . org " ; String Y = " NewSite : GeeksQuiz . com " ; int m = X . length ( ) ; int n = Y . length ( ) ; printLCSubStr ( X , Y , m , n ) ; } }
class GFG { static void substringConversions ( String str , int k , int b ) { for ( int i = 0 ; i + k <= str . length ( ) ; i ++ ) { String sub = str . substring ( i , i + k ) ; int sum = 0 , counter = 0 ; for ( int j = sub . length ( ) - 1 ; j >= 0 ; j -- ) { sum = ( int ) ( sum + ( ( sub . charAt ( j ) - '0' ) * Math . pow ( b , counter ) ) ) ; counter ++ ; } System . out . print ( sum + " ▁ " ) ; } } public static void main ( String [ ] args ) { String str = "12212" ; int b = 3 , k = 3 ; substringConversions ( str , b , k ) ; } }
public class GFG { static final int MAX_CHAR = 26 ; static boolean checkCorrectOrNot ( String s ) { int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int n = s . length ( ) ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s . charAt ( i ) - ' a ' ] ++ ; count2 [ s . charAt ( j ) - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; } public static void main ( String args [ ] ) { String s = " abab " ; if ( checkCorrectOrNot ( s ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int remainderWith7 ( String num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 } ; int series_index = 0 ; int result = 0 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { int digit = num . charAt ( i ) - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; } public static void main ( String [ ] args ) { String str = "12345" ; System . out . print ( " Remainder ▁ with ▁ 7 ▁ is ▁ " + remainderWith7 ( str ) ) ; } }
public class GFG { static int CHARS = 26 ; static boolean isValidString ( String str ) { int freq [ ] = new int [ CHARS ] ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } int i , freq1 = 0 , count_freq1 = 0 ; for ( i = 0 ; i < CHARS ; i ++ ) { if ( freq [ i ] != 0 ) { freq1 = freq [ i ] ; count_freq1 = 1 ; break ; } } int j , freq2 = 0 , count_freq2 = 0 ; for ( j = i + 1 ; j < CHARS ; j ++ ) { if ( freq [ j ] != 0 ) { if ( freq [ j ] == freq1 ) { count_freq1 ++ ; } else { count_freq2 = 1 ; freq2 = freq [ j ] ; break ; } } } for ( int k = j + 1 ; k < CHARS ; k ++ ) { if ( freq [ k ] != 0 ) { if ( freq [ k ] == freq1 ) { count_freq1 ++ ; } if ( freq [ k ] == freq2 ) { count_freq2 ++ ; { return false ; } } if ( count_freq1 > 1 && count_freq2 > 1 ) { return false ; } } return true ; } public static void main ( String [ ] args ) { String str = " abcbc " ; if ( isValidString ( str ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . * ; class GFG { static boolean isReversible ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; } public static void main ( String [ ] args ) { String str = " aba " ; if ( isReversible ( str ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static String encodeString ( String str ) { HashMap < Character , Integer > map = new HashMap < > ( ) ; String res = " " ; int i = 0 ; char ch ; for ( int j = 0 ; j < str . length ( ) ; j ++ ) { ch = str . charAt ( j ) ; if ( ! map . containsKey ( ch ) ) map . put ( ch , i ++ ) ; res += map . get ( ch ) ; } return res ; } static void findMatchedWords ( String [ ] dict , String pattern ) { int len = pattern . length ( ) ; String hash = encodeString ( pattern ) ; for ( String word : dict ) { if ( word . length ( ) == len && encodeString ( word ) . equals ( hash ) ) System . out . print ( word + " ▁ " ) ; } } public static void main ( String args [ ] ) { String [ ] dict = { " abb " , " abc " , " xyz " , " xyy " } ; String pattern = " foo " ; findMatchedWords ( dict , pattern ) ; } }
import java . util . * ; class GFG { static boolean check ( String pattern , String word ) { if ( pattern . length ( ) != word . length ( ) ) return false ; int [ ] ch = new int [ 128 ] ; int Len = word . length ( ) ; for ( int i = 0 ; i < Len ; i ++ ) { if ( ch [ ( int ) pattern . charAt ( i ) ] == 0 ) { ch [ ( int ) pattern . charAt ( i ) ] = word . charAt ( i ) ; } else if ( ch [ ( int ) pattern . charAt ( i ) ] != word . charAt ( i ) ) { return false ; } } return true ; } static void findMatchedWords ( HashSet < String > dict , String pattern ) { int Len = pattern . length ( ) ; String result = " ▁ " ; for ( String word : dict ) { if ( check ( pattern , word ) ) { result = word + " ▁ " + result ; } } System . out . print ( result ) ; } public static void main ( String [ ] args ) { HashSet < String > dict = new HashSet < String > ( ) ; dict . add ( " abb " ) ; dict . add ( " abc " ) ; dict . add ( " xyz " ) ; dict . add ( " xyy " ) ; String pattern = " foo " ; findMatchedWords ( dict , pattern ) ; } }
class GFG { static String intToRoman ( int num ) { String m [ ] = { " " , " M " , " MM " , " MMM " } ; String c [ ] = { " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM " } ; String x [ ] = { " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " } ; String i [ ] = { " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " } ; String thousands = m [ num / 1000 ] ; String hundereds = c [ ( num % 1000 ) / 100 ] ; String tens = x [ ( num % 100 ) / 10 ] ; String ones = i [ num % 10 ] ; String ans = thousands + hundereds + tens + ones ; return ans ; } public static void main ( String [ ] args ) { int number = 3549 ; System . out . println ( intToRoman ( number ) ) ; } }
import java . lang . * ; class Solution { private static String zigZagConcat ( String s , int n ) { if ( n <= 1 ) { return s ; } StringBuilder result = new StringBuilder ( ) ; for ( int rowNum = 0 ; rowNum < n ; rowNum ++ ) { int i = rowNum ; boolean up = true ; while ( i < s . length ( ) ) { result = result . append ( s . charAt ( i ) ) ; if ( rowNum == 0 rowNum == n - 1 ) { i += ( 2 * n - 2 ) ; } else { if ( up ) { i += ( 2 * ( n - rowNum ) - 2 ) ; } else { i += rowNum * 2 ; } up ^= true ; } } } return result . toString ( ) ; } public static void main ( String [ ] args ) { String str = " GEEKSFORGEEKS " ; int n = 3 ; System . out . println ( zigZagConcat ( str , n ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int maximumXOR ( int arr [ ] , int n , int K ) { K ++ ; int maxXor = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { if ( Integer . bitCount ( i ) == K ) { int cur_xor = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) cur_xor = cur_xor ^ arr [ j ] ; } maxXor = Math . max ( maxXor , cur_xor ) ; } } return maxXor ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int N = arr . length ; int M = 2 ; System . out . println ( maximumXOR ( arr , N , M ) ) ; } }
class GFG { static void TowerOfHanoi ( int N ) { for ( int x = 1 ; x <= Math . pow ( 2 , N ) - 1 ; x ++ ) { System . out . print ( " Move ▁ from ▁ Rod ▁ " + ( ( x & x - 1 ) % 3 + 1 ) + " ▁ to ▁ Rod ▁ " + ( ( ( x x - 1 ) + 1 ) % 3 + 1 ) + "NEW_LINE"); } } public static void main ( String [ ] args ) { int N = 3 ; TowerOfHanoi ( N ) ; } }
import java . util . * ; class GFG { static boolean isValid ( int [ ] [ ] board , int i , int j , int K ) { if ( board [ i ] [ j ] <= K ) { return true ; } return false ; } static boolean findPath ( int [ ] [ ] board , int X , int Y , int M , int N , int K ) { if ( X < 0 X == M Y < 0 Y == N ) { return true ; } if ( isValid ( board , X , Y , K ) ) { int board_XY = board [ X ] [ Y ] ; board [ X ] [ Y ] = Integer . MAX_VALUE ; if ( findPath ( board , X + 1 , Y , M , N , K - board_XY ) || findPath ( board , X - 1 , Y , M , N , K - board_XY ) || findPath ( board , X , Y + 1 , M , N , K - board_XY ) || findPath ( board , X , Y - 1 , M , N , K - board_XY ) ) { return true ; } board [ X ] [ Y ] = board_XY ; } return false ; } public static void main ( String [ ] args ) { int [ ] [ ] grid = { { 25 , 5 , 25 , 25 , 25 , 25 } , { 25 , 1 , 1 , 5 , 12 , 25 } , { 25 , 1 , 12 , 0 , 15 , 25 } , { 22 , 1 , 11 , 2 , 19 , 15 } , { 25 , 2 , 2 , 1 , 12 , 15 } , { 25 , 9 , 10 , 1 , 11 , 25 } , { 25 , 25 , 25 , 25 , 25 , 25 } } ; int K = 17 ; int M = grid . length ; int N = grid [ 0 ] . length ; int X = 2 , Y = 3 ; if ( findPath ( grid , X , Y , M , N , K ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; import java . lang . * ; public class GFG { static void solve ( int N , int P1 , int P2 , int X , int Move , boolean QuitP1 , boolean QuitP2 ) { if ( N == 0 || ( QuitP1 && QuitP2 ) ) { System . out . println ( " Number ▁ of ▁ pens ▁ remaining " + " ▁ in ▁ the ▁ box : ▁ " + N ) ; System . out . println ( " Number ▁ of ▁ pens ▁ collected " + " ▁ by ▁ P1 : ▁ " + P1 ) ; System . out . println ( " Number ▁ of ▁ pens ▁ collected " + " ▁ by ▁ P2 : ▁ " + P2 ) ; return ; } if ( Move == 0 && QuitP1 == false ) { int req_P1 = ( int ) ( Math . pow ( 2 , X ) ) ; if ( req_P1 <= N ) { P1 += req_P1 ; N -= req_P1 ; } else { QuitP1 = true ; } } else if ( Move == 1 && QuitP2 == false ) { int req_P2 = ( int ) ( Math . pow ( 3 , X ) ) ; if ( req_P2 <= N ) { P2 += req_P2 ; N -= req_P2 ; } else { QuitP2 = true ; } } X ++ ; Move = ( ( Move == 1 ) ? 0 : 1 ) ; solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) ; } static void PenGame ( int N ) { int P1 = 0 ; int P2 = 0 ; int X = 0 ; int Move = 0 ; boolean QuitP1 = false ; boolean QuitP2 = false ; solve ( N , P1 , P2 , X , Move , QuitP1 , QuitP2 ) ; } public static void main ( String [ ] args ) { int N = 22 ; PenGame ( N ) ; } }
import java . util . * ; class GFG { static boolean canPlace ( int a [ ] , int n , int p , int sep ) { int prisoners_placed = 1 ; int last_prisoner_placed = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int current_cell = a [ i ] ; if ( current_cell - last_prisoner_placed >= sep ) { prisoners_placed ++ ; last_prisoner_placed = current_cell ; if ( prisoners_placed == p ) { return true ; } } } return false ; } static int maxDistance ( int cell [ ] , int n , int p ) { Arrays . sort ( cell ) ; int start = 0 ; int end = cell [ n - 1 ] - cell [ 0 ] ; int ans = 0 ; while ( start <= end ) { int mid = start + ( ( end - start ) / 2 ) ; if ( canPlace ( cell , n , p , mid ) ) { ans = mid ; start = mid + 1 ; } else { end = mid - 1 ; } } return ans ; } public static void main ( String [ ] args ) { int cell [ ] = { 1 , 2 , 8 , 4 , 9 } ; int n = cell . length ; int p = 3 ; System . out . println ( maxDistance ( cell , n , p ) ) ; } }
class GFG { static int maxLen = 30 ; static int [ ] seg = new int [ 3 * maxLen ] ; static int build ( int l , int r , int in , int [ ] arr ) { if ( l == r ) return seg [ in ] = arr [ l ] ; int mid = ( l + r ) / 2 ; return seg [ in ] = __gcd ( build ( l , mid , 2 * in + 1 , arr ) , build ( mid + 1 , r , 2 * in + 2 , arr ) ) ; } static int query ( int l , int r , int l1 , int r1 , int in ) { if ( l1 <= l && r <= r1 ) return seg [ in ] ; if ( l > r1 r < l1 ) return 0 ; int mid = ( l + r ) / 2 ; return __gcd ( query ( l , mid , l1 , r1 , 2 * in + 1 ) , query ( mid + 1 , r , l1 , r1 , 2 * in + 2 ) ) ; } static int findLen ( int [ ] arr , int n ) { build ( 0 , n - 1 , 0 , arr ) ; int i = 0 , j = 0 ; int ans = Integer . MAX_VALUE ; while ( i < n ) { while ( j < n && query ( 0 , n - 1 , i , j , 0 ) != 1 ) j ++ ; if ( j == n ) break ; ans = Math . min ( ( j - i + 1 ) , ans ) ; i ++ ; j = Math . max ( j , i ) ; } if ( ans == Integer . MAX_VALUE ) return - 1 ; else return ans ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 2 } ; int n = arr . length ; System . out . println ( findLen ( arr , n ) ) ; } }
import java . util . * ; class GFG { static void findArea ( double a , double b , double c ) { double area = 4 * 3.141592653 * Math . pow ( ( Math . pow ( a * b , 1.6 ) + Math . pow ( a * c , 1.6 ) + Math . pow ( b * c , 1.6 ) ) / 3 , 1 / 1.6 ) ; System . out . print ( String . format ( " % .2f " , area ) ) ; } public static void main ( String [ ] args ) { double A = 11 , B = 12 , C = 13 ; findArea ( A , B , C ) ; } }
import java . io . * ; class GFG { static double findRadius ( double r1 , double r2 , double r3 ) { double r4 = ( r1 * r2 * r3 ) / ( r1 * r2 + r2 * r3 + r1 * r3 + 2.0 * Math . sqrt ( r1 * r2 * r3 * ( r1 + r2 + r3 ) ) ) ; return r4 ; } public static void main ( String [ ] args ) { double r1 = 1 ; double r2 = 1 ; double r3 = 1 ; double r4 = findRadius ( r1 , r2 , r3 ) ; System . out . println ( " The ▁ radius ▁ of ▁ fourth ▁ circle : ▁ " + r4 ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { public static int minimumRectangleArea ( int A [ ] , int N ) { int ans ; Arrays . sort ( A ) ; ans = ( A [ N - 1 ] - A [ 0 ] ) * ( A [ 2 * N - 1 ] - A [ N ] ) ; for ( int i = 1 ; i < N ; i ++ ) ans = Math . min ( ans , ( A [ 2 * N - 1 ] - A [ 0 ] ) * ( A [ i + N - 1 ] - A [ i ] ) ) ; return ans ; } public static void main ( String [ ] args ) { int A [ ] = { 2 , 4 , 1 , 5 , 3 , 6 , 7 , 8 } ; int N = A . length ; N = ( int ) N / 2 ; System . out . println ( minimumRectangleArea ( A , N ) ) ; } }
import java . util . * ; class GFG { static double eccHyperbola ( double A , double B ) { double r = ( double ) B * B / A * A ; r += 1 ; return Math . sqrt ( r ) ; } public static void main ( String [ ] args ) { double A = 3.0 , B = 2.0 ; System . out . print ( eccHyperbola ( A , B ) ) ; } }
import java . io . * ; class GFG { static float calculateArea ( float A , float B , float C , float D ) { float S = ( A + B + C + D ) / 2 ; float area = ( float ) Math . sqrt ( ( S - A ) * ( S - B ) * ( S - C ) * ( S - D ) ) ; return area ; } public static void main ( String [ ] args ) { float A = 10 ; float B = 15 ; float C = 20 ; float D = 25 ; System . out . println ( calculateArea ( A , B , C , D ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int totalCircles ( int L , int B ) { if ( L > B ) { int temp = L ; L = B ; B = temp ; } return B / L ; } public static void main ( String [ ] args ) { int L = 3 ; int B = 8 ; System . out . print ( totalCircles ( L , B ) ) ; } }
import java . util . * ; class GFG { static double findRadius ( double r1 , double r2 ) { double a1 , a2 , a3 , r3 ; a1 = 3.14 * r1 * r1 ; a2 = 3.14 * r2 * r2 ; a3 = a1 + a2 ; r3 = Math . sqrt ( a3 / 3.14 ) ; return r3 ; } public static void main ( String [ ] args ) { double r1 = 8 , r2 = 6 ; System . out . println ( ( int ) findRadius ( r1 , r2 ) ) ; } }
import java . util . * ; class GFG { static int find_lcm ( int a , int b , int c ) { int g = __gcd ( a , b ) ; int LCM1 = ( a * b ) / g ; g = __gcd ( LCM1 , c ) ; int LCM = ( LCM1 * c ) / g ; return LCM ; } static void minimumCuboids ( int L , int B , int H ) { int lcm = find_lcm ( L , B , H ) ; int volume_cube = lcm * lcm * lcm ; int volume_cuboid = L * B * H ; System . out . print ( ( volume_cube / volume_cuboid ) ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int L = 1 , B = 1 , H = 2 ; minimumCuboids ( L , B , H ) ; } }
class GFG { static int CrossProduct ( int A [ ] [ ] ) { int X1 = ( A [ 1 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y1 = ( A [ 1 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; int X2 = ( A [ 2 ] [ 0 ] - A [ 0 ] [ 0 ] ) ; int Y2 = ( A [ 2 ] [ 1 ] - A [ 0 ] [ 1 ] ) ; return ( X1 * Y2 - Y1 * X2 ) ; } static boolean isConvex ( int points [ ] [ ] ) { int N = points . length ; int prev = 0 ; int curr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int temp [ ] [ ] = { points [ i ] , points [ ( i + 1 ) % N ] , points [ ( i + 2 ) % N ] } ; curr = CrossProduct ( temp ) ; if ( curr != 0 ) { if ( curr * prev < 0 ) { return false ; } else { prev = curr ; } } } return true ; } public static void main ( String [ ] args ) { int points [ ] [ ] = { { 0 , 0 } , { 0 , 1 } , { 1 , 1 } , { 1 , 0 } } ; if ( isConvex ( points ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . * ; class GFG { static double distance ( int r , int R ) { double d = Math . sqrt ( Math . pow ( R , 2 ) - ( 2 * r * R ) ) ; return d ; } public static void main ( String [ ] args ) { int r = 2 ; int R = 5 ; System . out . println ( Math . round ( distance ( r , R ) * 100.0 ) / 100.0 ) ; } }
import java . io . * ; class GFG { static double minAnglRot ( int N ) { double res ; res = 360 / ( double ) N ; return res ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( " Angle ▁ of ▁ Rotational ▁ Symmetry : ▁ " + minAnglRot ( N ) ) ; } }
class GFG { static double Area_of_Triangle ( int a , int b , int c ) { int s = ( a + b + c ) / 2 ; int x = s * ( s - a ) ; x = x * ( s - b ) ; x = x * ( s - c ) ; double area = ( 4 / ( double ) 3 ) * Math . sqrt ( x ) ; return area ; } public static void main ( String [ ] args ) { int a = 9 ; int b = 12 ; int c = 15 ; double ans = Area_of_Triangle ( a , b , c ) ; System . out . println ( ans ) ; } }
class GFG { static boolean isTridecagon ( int N ) { float n = ( float ) ( ( 9 + Math . sqrt ( 88 * N + 81 ) ) / 22 ) ; return ( n - ( int ) n ) == 0 ; } public static void main ( String [ ] args ) { int i = 13 ; if ( isTridecagon ( i ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
class GFG { static boolean checkOverlap ( int R , int Xc , int Yc , int X1 , int Y1 , int X2 , int Y2 ) { int Xn = Math . max ( X1 , Math . min ( Xc , X2 ) ) ; int Yn = Math . max ( Y1 , Math . min ( Yc , Y2 ) ) ; int Dx = Xn - Xc ; int Dy = Yn - Yc ; return ( Dx * Dx + Dy * Dy ) <= R * R ; } public static void main ( String [ ] args ) { int R = 1 ; int Xc = 0 , Yc = 0 ; int X1 = 1 , Y1 = - 1 ; int X2 = 3 , Y2 = 1 ; if ( checkOverlap ( R , Xc , Yc , X1 , Y1 , X2 , Y2 ) ) { System . out . print ( " True " + "NEW_LINE"); } else { System . out . print ( " False " ) ; } } }
class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int checkIntersection ( pair p1 , pair p2 , pair p ) { int val ; if ( p1 . second == p2 . second && p1 . second == p . second ) { if ( p . first <= Math . max ( p1 . first , p2 . first ) && ( p . first >= Math . min ( p1 . first , p2 . first ) ) ) return 1 ; } if ( p1 . first == p2 . first && p1 . first == p . first ) { if ( p . second <= Math . max ( p1 . second , p2 . second ) && ( p . second >= Math . min ( p1 . second , p2 . second ) ) ) return 1 ; } else { val = ( p . second - p1 . second ) * ( p2 . first - p1 . first ) - ( p . first - p1 . first ) * ( p2 . second - p1 . second ) ; if ( val == 0 ) if ( ( p . first <= Math . max ( p1 . first , p2 . first ) && ( p . first >= Math . min ( p1 . first , p2 . first ) ) ) && ( p . second <= Math . max ( p1 . second , p2 . second ) && ( p . second >= Math . min ( p1 . second , p2 . second ) ) ) ) return 1 ; } return 0 ; } static void towerOfSight ( pair a , pair b , pair c , pair d ) { int flag = 0 ; if ( checkIntersection ( a , c , b ) == 1 ) flag = 1 ; else if ( checkIntersection ( a , c , d ) == 1 ) flag = 1 ; else if ( checkIntersection ( b , d , a ) == 1 ) flag = 1 ; else if ( checkIntersection ( b , d , c ) == 1 ) flag = 1 ; System . out . print ( flag == 1 ? "Yes " : " No "); } public static void main ( String [ ] args ) { pair a = new pair ( 0 , 0 ) ; pair b = new pair ( 0 , - 2 ) ; pair c = new pair ( 2 , 0 ) ; pair d = new pair ( 0 , 2 ) ; towerOfSight ( a , b , c , d ) ; } }
class GFG { static double area ( int R ) { double base = 1.732 * R ; double height = ( 1.5 ) * R ; double area = 0.5 * base * height ; return area ; } public static void main ( String [ ] args ) { int R = 7 ; System . out . println ( area ( R ) ) ; } }
class GFG { static int countPairs ( int [ ] P , int [ ] Q , int N , int M ) { int [ ] A = new int [ 2 ] , B = new int [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) A [ P [ i ] % 2 ] ++ ; for ( int i = 0 ; i < M ; i ++ ) B [ Q [ i ] % 2 ] ++ ; return ( A [ 0 ] * B [ 0 ] + A [ 1 ] * B [ 1 ] ) ; } public static void main ( String [ ] args ) { int [ ] P = { 1 , 3 , 2 } ; int [ ] Q = { 3 , 0 } ; int N = P . length ; int M = Q . length ; System . out . print ( countPairs ( P , Q , N , M ) ) ; } }
class GFG { static void new_vol ( double x ) { if ( x > 0 ) { System . out . print ( " % ▁ change ▁ in ▁ the ▁ " + " volume ▁ of ▁ the ▁ hemisphere : ▁ " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + " % " + " increaseNEW_LINE"); } else if ( x < 0 ) { System . out . print ( " % ▁ change ▁ in ▁ the ▁ " + " volume ▁ of ▁ the ▁ hemisphere : ▁ " + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + "% decreaseNEW_LINE"); } else { System . out . print ( " Volume ▁ remains ▁ the ▁ same . " ) ; } } public static void main ( String [ ] args ) { double x = - 10.0 ; new_vol ( x ) ; } }
class GFG { static int countIntersections ( int n ) { return n * ( n - 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( countIntersections ( n ) ) ; } }
class GFG { static float Area ( int d , int h1 , int h2 ) { float area ; area = ( float ) 0.5 * d * ( h1 + h2 ) ; return area ; } public static void main ( String [ ] args ) { int d = 6 , h1 = 4 , h2 = 3 ; System . out . println ( " Area ▁ of ▁ Quadrilateral ▁ = ▁ " + Area ( d , h1 , h2 ) ) ; } }
import java . io . * ; class GFG { static void angleextcycquad ( int z ) { System . out . print ( " The ▁ exterior ▁ angle ▁ of ▁ the " + " ▁ cyclic ▁ quadrilateral ▁ is ▁ " + z + " ▁ degrees " ) ; } public static void main ( String [ ] args ) { int z = 48 ; angleextcycquad ( z ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean isPerfect ( int N ) { int sumOfDivisors = 1 ; for ( int i = 2 ; i <= N / 2 ; ++ i ) { if ( N % i == 0 ) { sumOfDivisors += i ; } } if ( sumOfDivisors == N ) { return true ; } else return false ; } static int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += ( N % 10 ) ; N = N / 10 ; } return sum ; } static void countPerfectNumbers ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; ++ i ) { if ( isPerfect ( arr [ i ] ) ) { int sum = sumOfDigits ( arr [ i ] ) ; if ( isPerfect ( sum ) ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } } } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 8 , 12 , 28 , 6 } ; int N = arr . length ; countPerfectNumbers ( arr , N ) ; } }
import java . util . * ; class GFG { static void fizzBuzz ( int N ) { int count3 = 0 ; int count5 = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count3 ++ ; count5 ++ ; boolean flag = false ; if ( count3 == 3 ) { System . out . print ( " Fizz " ) ; count3 = 0 ; flag = true ; } if ( count5 == 5 ) { System . out . print ( " Buzz " ) ; count5 = 0 ; flag = true ; } if ( ! flag ) { System . out . print ( i ) ; } System . out . print ( " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 15 ; fizzBuzz ( N ) ; } }
import java . util . * ; class GFG { static int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] != 0 && a [ i ] % a [ j ] == 0 ) { if ( ( a [ i ] + a [ j ] ) == ( a [ i ] / a [ j ] ) ) count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { - 4 , - 3 , 0 , 2 , 1 } ; int N = arr . length ; System . out . print ( countPairs ( arr , N ) ) ; } }
import java . io . * ; class GFG { static int numberOfTiles ( int n , int m ) { if ( n % 2 == 1 ) { return - 1 ; } return ( m * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 2 , m = 4 ; System . out . println ( numberOfTiles ( n , m ) ) ; } }
import java . util . * ; class GFG { static void checkSamePosition ( int [ ] arr , int n ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int temp = ( ( i + arr [ i ] ) % n + n ) % n ; if ( mp . get ( temp ) == null ) { System . out . println ( " Yes " ) ; return ; } mp . get ( temp + 1 ) ; } System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 4 , 3 } ; int N = arr . length ; checkSamePosition ( arr , N ) ; } }
import java . util . * ; class GFG { static void convertToASCII ( int N ) { String num = Integer . toString ( N ) ; for ( char ch : num . toCharArray ( ) ) { System . out . print ( ch + " ▁ ( " + ( int ) ch + ")NEW_LINE"); } } public static void main ( String [ ] args ) { int N = 36 ; convertToASCII ( N ) ; } }
import java . util . * ; class GFG { static void checkPossible ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { System . out . print ( "NoNEW_LINE"); return ; } else { arr [ i ] -= arr [ i - 1 ] ; arr [ i - 1 ] = 0 ; } } if ( arr [ n - 1 ] == 0 ) { System . out . print ( "YesNEW_LINE"); } else { System . out . print ( "NoNEW_LINE"); } } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 3 , 3 , 4 , 2 } ; int N = arr . length ; checkPossible ( arr , N ) ; } }
class GFG { static void singleDigitSubarrayCount ( int arr [ ] , int N ) { int res = 0 ; int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] <= 9 ) { count ++ ; res += count ; } else { count = 0 ; } } System . out . print ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 14 , 2 , 5 } ; int N = arr . length ; singleDigitSubarrayCount ( arr , N ) ; } }
import java . io . * ; class GFG { static int Fact ( int N ) { int result = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { result = ( result * i ) ; } return result ; } static void numberOfWays ( int M , int [ ] arr , int N ) { int [ ] B = new int [ M ] ; int [ ] counter = new int [ M + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] != 0 ) { if ( B [ i % M ] == 0 ) { B [ i % M ] = arr [ i ] ; counter [ arr [ i ] ] ++ ; if ( counter [ arr [ i ] ] > 1 ) { System . out . println ( 0 ) ; return ; } } else if ( B [ i % M ] != arr [ i ] ) { System . out . println ( 0 ) ; return ; } } } int cnt = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( B [ i ] == 0 ) { cnt ++ ; } } System . out . println ( Fact ( cnt ) ) ; } public static void main ( String [ ] args ) { int M = 4 ; int [ ] arr = new int [ ] { 1 , 0 , 3 , 0 , 0 } ; int N = arr . length ; numberOfWays ( M , arr , N ) ; } }
class GFG { static void noOfArraysPossible ( int N , int M ) { int ans = 1 ; for ( int i = 0 ; i < N ; ++ i ) { ans = ans * ( M - i ) ; } System . out . print ( ans ) ; } public static void main ( String [ ] args ) { int N = 2 , M = 3 ; noOfArraysPossible ( N , M ) ; } }
class GFG { static int MinimumOperationReq ( int N ) { int cntDecr = 0 ; int temp = N ; while ( temp > 0 ) { int X = ( int ) Math . sqrt ( temp ) ; if ( X * X == temp ) { break ; } temp = temp - 2 ; cntDecr += 1 ; } int cntIncr = 0 ; while ( true ) { int X = ( int ) Math . sqrt ( N ) ; if ( X * X == N ) { break ; } N = N + 2 ; cntIncr += 1 ; } return Math . min ( cntIncr , cntDecr ) ; } public static void main ( String args [ ] ) { int N = 15 ; System . out . print ( MinimumOperationReq ( N ) ) ; } }
import java . util . * ; class GFG { static int maxDisconnected ( int N , int E ) { int curr = 1 ; int rem = E ; while ( rem > 0 ) { rem = rem - Math . min ( curr , rem ) ; curr ++ ; } if ( curr > 1 ) { return N - curr ; } else { return N ; } } public static void main ( String [ ] args ) { int N = 5 , E = 1 ; System . out . print ( maxDisconnected ( N , E ) ) ; } }
import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static String deleteIth ( String str , int i ) { str = str . substring ( 0 , i ) + str . substring ( i + 1 ) ; return str ; } static boolean isPrimePossible ( int N ) { String s = String . valueOf ( N ) ; int l = s . length ( ) ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l ; i ++ ) { String str = deleteIth ( s , i ) ; int num = Integer . valueOf ( str ) ; if ( isPrime ( num ) ) return true ; } return false ; } public static void main ( String [ ] args ) { int N = 610 ; if ( isPrimePossible ( N ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
import java . util . * ; class GFG { static int Find_min ( HashSet < Integer > diff_mod , HashMap < Integer , Integer > count_mod , int k ) { int min_oprn = Integer . MAX_VALUE ; int oprn = 0 ; for ( int x = 0 ; x < k ; x ++ ) { oprn = 0 ; for ( int w : diff_mod ) { if ( w != x ) { if ( w == 0 ) { oprn += Math . min ( x , k - x ) * count_mod . get ( w ) ; } else { oprn += Math . min ( Math . abs ( x - w ) , k + x - w ) * count_mod . get ( w ) ; } } } if ( oprn < min_oprn ) min_oprn = oprn ; } return min_oprn ; } static int Cal_min ( int arr [ ] , int n , int k ) { HashSet < Integer > diff_mod = new HashSet < > ( ) ; HashMap < Integer , Integer > count_mod = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { diff_mod . add ( arr [ i ] % k ) ; count_mod . put ( arr [ i ] % k , count_mod . getOrDefault ( arr [ i ] % k , 0 ) + 1 ) ; } return Find_min ( diff_mod , count_mod , k ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 35 , 48 , 23 , 52 } ; int n = arr . length ; int k = 3 ; System . out . print ( Cal_min ( arr , n , k ) ) ; } }
import java . util . * ; class GFG { static void inverseEqual ( int arr [ ] , int n ) { int [ ] brr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int present_index = arr [ i ] - 1 ; brr [ present_index ] = i + 1 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != brr [ i ] ) { System . out . println ( " No " ) ; return ; } } System . out . println ( " Yes " ) ; } public static void main ( String [ ] args ) { int n = 4 ; int [ ] arr = { 1 , 4 , 3 , 2 } ; inverseEqual ( arr , n ) ; } }
class GFG { public static int SquareRoot ( int num ) { int count = 0 ; for ( int n = 1 ; n <= num ; n += 2 ) { num = num - n ; count += 1 ; if ( num == 0 ) break ; } return count ; } public static void main ( String [ ] args ) { int N = 81 ; System . out . println ( SquareRoot ( N ) ) ; } }
import java . util . * ; class GFG { public static void findWinner ( int n , int k ) { int cnt = 0 ; if ( n == 1 ) System . out . println ( " No " ) ; else if ( ( n & 1 ) != 0 n == 2 ) System . out . println ( " Yes " ) ; else { int tmp = n ; int val = 1 ; while ( tmp > k && tmp % 2 == 0 ) { tmp /= 2 ; val *= 2 ; } for ( int i = 3 ; i <= Math . sqrt ( tmp ) ; i ++ ) { while ( tmp % i == 0 ) { cnt ++ ; tmp /= i ; } } if ( tmp > 1 ) cnt ++ ; if ( val == n ) System . out . println ( " No " ) ; else if ( n / tmp == 2 && cnt == 1 ) System . out . println ( " No " ) ; else System . out . println ( " Yes " ) ; } } public static void main ( String [ ] args ) { int n = 1 , k = 1 ; findWinner ( n , k ) ; } }
class GFG { static int count_crazy_primes ( int L , int R ) { int prime [ ] = new int [ R + 1 ] ; int countPrime [ ] = new int [ R + 1 ] ; int freqPrime [ ] = new int [ R + 1 ] ; prime [ 0 ] = 1 ; prime [ 1 ] = 1 ; for ( int p = 2 ; p * p <= R ; p ++ ) { if ( prime [ p ] == 0 ) { for ( int i = p * p ; i <= R ; i += p ) prime [ i ] = 1 ; } } for ( int i = 1 ; i <= R ; i ++ ) { countPrime [ i ] = countPrime [ i - 1 ] ; if ( prime [ i ] != 0 ) { countPrime [ i ] ++ ; } } for ( int i = 1 ; i <= R ; i ++ ) { freqPrime [ i ] = freqPrime [ i - 1 ] ; if ( prime [ countPrime [ i ] ] != 0 ) { freqPrime [ i ] ++ ; } } return ( freqPrime [ R ] - freqPrime [ L - 1 ] ) ; } public static void main ( String [ ] args ) { int L = 4 , R = 12 ; System . out . println ( count_crazy_primes ( L , R ) ) ; } }
import java . util . * ; class GFG { static void compute ( int a [ ] , int N , int K ) { Map < Long , Long > eqVal = new HashMap < Long , Long > ( ) ; long maxX = 0 ; for ( int i = 0 ; i < N ; i ++ ) { long val = a [ i ] % K ; val = ( val == 0 ? 0 : K - val ) ; if ( val == 0 ) continue ; if ( eqVal . containsKey ( val ) ) { long numVal = eqVal . get ( val ) ; maxX = Math . max ( maxX , val + ( K * numVal ) ) ; eqVal . put ( val , eqVal . getOrDefault ( val , 0l ) + 1l ) ; } else { eqVal . put ( val , 1l ) ; maxX = Math . max ( maxX , val ) ; } } System . out . println ( maxX == 0 ? 0 : maxX + 1 ) ; } public static void main ( String [ ] args ) { int K = 3 ; int a [ ] = { 1 , 2 , 2 , 18 } ; int N = a . length ; compute ( a , N , K ) ; } }
class GFG { static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } static boolean isSelfNum ( int n ) { for ( int m = 1 ; m <= n ; m ++ ) { if ( m + getSum ( m ) == n ) return false ; } return true ; } public static void main ( String [ ] args ) { int n = 20 ; if ( isSelfNum ( n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class GFG { static int seriesSumUtil ( int k , int n , int prevSum , int multi , int add ) { if ( k == n + 1 ) { return prevSum ; } multi = multi * k ; add = add + k ; prevSum = prevSum + multi - add ; return seriesSumUtil ( k + 1 , n , prevSum , multi , add ) ; } static int seriesSum ( int n ) { if ( n == 1 ) return 0 ; int prevSum = 0 ; int multi = 1 ; int add = 1 ; return seriesSumUtil ( 2 , n , prevSum , multi , add ) ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( seriesSum ( N ) ) ; } }
class GFG { static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } static void smallestNumber ( int N ) { int i = 1 ; while ( 1 != 0 ) { if ( getSum ( i ) == N ) { System . out . print ( i ) ; break ; } i ++ ; } } public static void main ( String [ ] args ) { int N = 10 ; smallestNumber ( N ) ; } }
class GFG { static boolean iszygodromeNum ( int N ) { String s = Integer . toString ( N ) ; s = ' ▁ ' + s + ' ▁ ' ; for ( int i = 1 ; i < s . length ( ) - 1 ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) && s . charAt ( i ) != s . charAt ( i + 1 ) ) { return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 1122 ; if ( iszygodromeNum ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class geeks { public static int canReplace ( int [ ] array ) { int i = 0 , count = 0 ; while ( i < array . length ) { if ( array [ i ] == 0 && ( i == 0 array [ i - 1 ] == 0 ) && ( i == array . length - 1 array [ i + 1 ] == 0 ) ) { array [ i ] = 1 ; count ++ ; } i ++ ; } return count ; } public static void main ( String [ ] args ) { int [ ] array = { 1 , 0 , 0 , 0 , 1 } ; System . out . println ( canReplace ( array ) ) ; } }
class GFG { static int MegagonNum ( int n ) { return ( 999998 * n * n - 999996 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( MegagonNum ( n ) ) ; } }
class GFG { static int TetracontaoctagonalNum ( int n ) { return ( 46 * n * n - 44 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( TetracontaoctagonalNum ( n ) ) ; } }
class GFG { static double findIndex ( int n ) { double x = Math . sqrt ( 2 * Math . pow ( 10 , ( n - 1 ) ) ) ; return Math . round ( x ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( findIndex ( n ) ) ; } }
import java . util . * ; class GFG { static void smallestNumber ( int N ) { System . out . print ( N * Math . floor ( ( Math . pow ( 10 , N ) - 1 ) / N ) ) ; } public static void main ( String args [ ] ) { int N = 2 ; smallestNumber ( N ) ; } }
class GFG { static int icosikaiheptagonalNum ( int n ) { return ( 25 * n * n - 23 * n ) / 2 ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( "3rd ▁ icosikaiheptagonal ▁ Number ▁ is ▁ " + icosikaiheptagonalNum ( n ) ) ; } }
class GFG { static boolean istriacontagonal ( int N ) { float n = ( float ) ( ( 26 + Math . sqrt ( 224 * N + 676 ) ) / 56 ) ; return ( n - ( int ) n ) == 0 ; } public static void main ( String [ ] args ) { int N = 30 ; if ( istriacontagonal ( N ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
import java . util . * ; class GFG { static void Maxlength ( int arr [ ] , int N ) { Vector < Integer > zeroindex = new Vector < Integer > ( ) ; int maxlen ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) zeroindex . add ( i ) ; } if ( zeroindex . size ( ) == 0 ) { maxlen = N ; } else { maxlen = ( int ) zeroindex . get ( 0 ) ; for ( int i = 0 ; i < zeroindex . size ( ) - 1 ; i ++ ) { if ( ( int ) zeroindex . get ( i + 1 ) - ( int ) zeroindex . get ( i ) - 1 > maxlen ) { maxlen = ( int ) zeroindex . get ( i + 1 ) - ( int ) zeroindex . get ( i ) - 1 ; } } if ( N - ( int ) zeroindex . get ( zeroindex . size ( ) - 1 ) - 1 > maxlen ) { maxlen = N - ( int ) zeroindex . get ( zeroindex . size ( ) - 1 ) - 1 ; } } System . out . println ( maxlen ) ; } public static void main ( String args [ ] ) { int N = 9 ; int arr [ ] = { 7 , 1 , 0 , 1 , 2 , 0 , 9 , 2 , 1 } ; Maxlength ( arr , N ) ; } }
import java . util . * ; class GFG { static void solve ( int n ) { for ( int x = 1 ; x <= Math . sqrt ( n ) ; x ++ ) { if ( n % x == 0 ) { int small = x ; int big = n / x ; if ( small % 2 == big % 2 ) { int a = ( small + big ) / 2 ; int b = ( big - small ) / 2 ; System . out . print ( a + " ▁ " + b ) ; return ; } } } System . out . print ( - 1 ) ; } public static void main ( String args [ ] ) { int n = 7 ; solve ( n ) ; } }
import java . util . * ; class GFG { static int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } static int derivative ( int x ) { return 3 * x * x ; } static int Image ( int x , int k ) { return x * x * x - k ; } static int next_power ( int a_t , int t , int a1 , int prime , int k ) { int power_p = ( int ) Math . pow ( prime , t + 1 ) ; int next_a = ( a_t - Image ( a_t , k ) * inv ( derivative ( a1 ) , prime ) ) % power_p ; if ( next_a < 0 ) return next_a += power_p ; return next_a ; } static int powerOfPrime ( int prime , int power , int k , int a1 ) { if ( derivative ( a1 ) != 0 ) { int a_t = a1 ; for ( int p = 1 ; p < power ; p ++ ) { a_t = next_power ( a_t , p , a1 , prime , k ) ; } return a_t ; } return - 1 ; } public static void main ( String [ ] args ) { int prime = 7 , a1 = 3 ; int power = 2 , k = 3 ; System . out . print ( powerOfPrime ( prime , power , k , a1 ) ) ; } }
import java . util . * ; class GFG { static final int mod = 1000000007 ; static int productPairs ( int arr [ ] , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { product *= ( arr [ i ] % mod * arr [ j ] % mod ) % mod ; product = product % mod ; } } return product % mod ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . print ( productPairs ( arr , n ) ) ; } }
class GFG { static int getMinSteps ( int n , int jump ) { int quotient = n / jump ; int remainder = n % jump ; int steps = quotient + remainder ; return steps ; } public static void main ( String [ ] args ) { int N = 6 , K = 3 ; System . out . print ( getMinSteps ( N , K ) ) ; } }
class GFG { static boolean isCenterednonadecagonal ( int N ) { float n = ( float ) ( ( 19 + Math . sqrt ( 152 * N + 209 ) ) / 38 ) ; return ( n - ( int ) n ) == 0 ; } public static void main ( String [ ] args ) { int n = 20 ; if ( isCenterednonadecagonal ( n ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
public class Main { public static void cntArray ( int A [ ] , int N ) { int result = 0 ; int [ ] frequency = new int [ N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { frequency [ A [ i ] ] ++ ; } for ( int i = 1 ; i <= N ; i ++ ) { int frequency_of_i = frequency [ i ] ; result += ( ( frequency_of_i ) * ( frequency_of_i + 1 ) ) / 2 ; } System . out . println ( result ) ; } public static void main ( String [ ] args ) { int [ ] A = { 1 , 5 , 6 , 1 , 9 , 5 , 8 , 10 , 8 , 9 } ; int N = A . length ; cntArray ( A , N ) ; } }
import java . util . * ; class GFG { static int subarray ( int arr [ ] , int n ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 1 , 2 , 2 , 2 , 3 , 3 } ; int n = arr . length ; System . out . print ( subarray ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void findMaxMinSubArray ( int arr [ ] , int K , int n ) { int min = n ; int max = 0 ; int left ; int right ; int tmp ; for ( int i = 0 ; i < n ; i ++ ) { tmp = 1 ; left = i ; while ( left - 1 >= 0 && Math . abs ( arr [ left ] - arr [ left - 1 ] ) <= K ) { left -- ; tmp ++ ; } right = i ; while ( right + 1 <= n - 1 && Math . abs ( arr [ right ] - arr [ right + 1 ] ) <= K ) { right ++ ; tmp ++ ; } if ( min > tmp ) min = tmp ; if ( max < tmp ) max = tmp ; } System . out . print ( min ) ; System . out . print ( " , ▁ " ) ; System . out . print ( max ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 5 , 6 , 7 } ; int K = 2 ; int n = arr . length ; findMaxMinSubArray ( arr , K , n ) ; } }
class GFG { static int minimumSteps ( int a , int b , int c ) { if ( a < 1 b < 1 ) return - 1 ; if ( a == 1 && b == 1 ) return c ; if ( a < b ) { a = a + b ; b = a - b ; a = a - b ; } return minimumSteps ( a - b , b , c + 1 ) ; } public static void main ( String [ ] args ) { int a = 75 ; int b = 17 ; System . out . println ( minimumSteps ( a , b , 0 ) ) ; } }
class GFG { static boolean isPerfectSquare ( double x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static int countSquares ( int n ) { int cnt = 0 ; for ( int i = ( int ) Math . pow ( 10 , ( n - 1 ) ) ; i < Math . pow ( 10 , n ) ; i ++ ) { if ( i != 0 && isPerfectSquare ( i ) ) cnt ++ ; } return cnt ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . print ( countSquares ( n ) ) ; } }
import java . util . * ; class GFG { static void printArr ( int n ) { if ( n % 4 == 0 ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) System . out . print ( i * 2 + " ▁ " ) ; for ( int i = 1 ; i < n / 2 ; i ++ ) System . out . print ( i * 2 - 1 + " ▁ " ) ; System . out . println ( n + n / 2 - 1 ) ; } else System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int n = 22 ; printArr ( n ) ; } }
import java . util . Scanner ; class CGPA { public static double CgpaCalc ( double [ ] marks , int n ) { double grade [ ] = new double [ n ] ; double cgpa , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { grade [ i ] = ( marks [ i ] / 10 ) ; } for ( int i = 0 ; i < n ; i ++ ) { sum += grade [ i ] ; } cgpa = sum / n ; return cgpa ; } public static void main ( String args [ ] ) { int n = 5 ; double [ ] marks = { 90 , 80 , 70 , 80 , 90 } ; double cgpa = CgpaCalc ( marks , n ) ; System . out . println ( " CGPA ▁ = ▁ " + cgpa ) ; System . out . println ( " CGPA ▁ Percentage ▁ = ▁ " + String . format ( " % .2f " , cgpa * 9.5 ) ) ; } }
class GFG { public static Boolean checkGoldenRatio ( float a , float b ) { if ( a <= b ) { float temp = a ; a = b ; b = temp ; } String ratio1 = String . format ( " % .3f " , a / b ) ; String ratio2 = String . format ( " % .3f " , ( a + b ) / a ) ; if ( ratio1 . equals ( ratio2 ) && ratio1 . equals ( "1.618" ) ) { System . out . println ( " Yes " ) ; return true ; } else { System . out . println ( " No " ) ; return false ; } } public static void main ( String [ ] args ) { float a = ( float ) 0.618 ; float b = 1 ; checkGoldenRatio ( a , b ) ; } }
class GFG { static int minNum ( int n , int k ) { int x = ( int ) ( Math . log ( n ) / Math . log ( k ) ) + 1 ; int mn = ( int ) ( Math . pow ( k , x ) - n ) ; return mn ; } public static void main ( String [ ] args ) { int n = 20 , k = 5 ; System . out . print ( minNum ( n , k ) ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int CntcontSubs ( int a [ ] , int n ) { int prod = 1 ; Vector < pair > vect = new Vector < pair > ( ) ; vect . add ( new pair ( 0 , 2 ) ) ; Vector < Integer > two = new Vector < Integer > ( ) ; Vector < Integer > zero = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = a [ i ] % 4 ; if ( a [ i ] < 0 ) a [ i ] = a [ i ] + 4 ; if ( a [ i ] == 2 ) two . add ( i + 1 ) ; if ( a [ i ] == 0 ) zero . add ( i + 1 ) ; if ( a [ i ] == 0 a [ i ] == 2 ) vect . add ( new pair ( i + 1 , a [ i ] ) ) ; } vect . add ( new pair ( n + 1 , 2 ) ) ; int total = ( n * ( n + 1 ) ) / 2 ; if ( two . isEmpty ( ) ) return total ; else { int sum = 0 ; int pos1 = - 1 , pos2 = - 1 , pos3 = - 1 ; int sz = vect . size ( ) ; for ( int i = 1 ; i + 1 < sz ; i ++ ) { if ( vect . get ( i ) . second == 2 ) { sum += ( vect . get ( i ) . first - vect . get ( i - 1 ) . first ) * ( vect . get ( i + 1 ) . first - vect . get ( i ) . first ) - 1 ; } } return total - sum - two . size ( ) ; } } public static void main ( String [ ] args ) { int a [ ] = { 5 , 4 , 2 , 9 , 8 } ; int n = a . length ; System . out . print ( CntcontSubs ( a , n ) ) ; } }
import java . util . * ; class GFG { static int mod = 1000000007 ; static int countSubsets ( int a [ ] , int n ) { int answer = 0 ; int [ ] powerOfTwo = new int [ 100005 ] ; powerOfTwo [ 0 ] = 1 ; for ( int i = 1 ; i < 100005 ; i ++ ) powerOfTwo [ i ] = ( powerOfTwo [ i - 1 ] * 2 ) % mod ; HashMap < Integer , Integer > frequency = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( frequency . containsKey ( a [ i ] ) ) { frequency . put ( a [ i ] , frequency . get ( a [ i ] ) + 1 ) ; } else { frequency . put ( a [ i ] , 1 ) ; } for ( Map . Entry < Integer , Integer > el : frequency . entrySet ( ) ) { if ( el . getKey ( ) != 0 ) answer = ( answer % mod + powerOfTwo [ el . getValue ( ) - 1 ] ) % mod ; else answer = ( answer % mod + powerOfTwo [ el . getValue ( ) ] - 1 + mod ) % mod ; } return answer ; } public static void main ( String [ ] args ) { int N = 6 ; int A [ ] = { 1 , 3 , 2 , 1 , 2 , 1 } ; System . out . print ( countSubsets ( A , N ) ) ; } }
class GFG { static long product ( int [ ] [ ] mat , int n ) { long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1L * d1 * d2 ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 5 , 8 , 1 } , { 5 , 10 , 3 } , { - 6 , 17 , - 9 } } ; int n = mat . length ; System . out . print ( product ( mat , n ) ) ; } }
class GFG { static int findSum ( int [ ] arr , int n , int left , int right ) { int k = right - left ; int d = arr [ 1 ] - arr [ 0 ] ; int ans = arr [ left - 1 ] * ( k + 1 ) ; ans = ans + ( d * ( k * ( k + 1 ) ) ) / 2 ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 14 , 16 } ; int queries = 3 ; int q [ ] [ ] = { { 2 , 4 } , { 2 , 6 } , { 5 , 6 } } ; int n = arr . length ; for ( int i = 0 ; i < queries ; i ++ ) System . out . print ( findSum ( arr , n , q [ i ] [ 0 ] , q [ i ] [ 1 ] ) + "NEW_LINE"); } }
import java . util . * ; class GFG { static boolean subarrayPossible ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; if ( sum <= 0 ) return true ; } return false ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 5 , - 12 , 7 , - 10 , 20 , 30 , - 10 , 50 , 60 } ; int size = arr . length ; if ( subarrayPossible ( arr , size ) ) System . out . print ( " Yes " + "NEW_LINE"); else System . out . print ( " No " + "NEW_LINE"); } }
class GFG { static final int limit = 10000000 ; static int [ ] position = new int [ limit + 1 ] ; static void sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } } public static void main ( String [ ] args ) { sieve ( ) ; int n = 11 ; System . out . print ( position [ n ] ) ; } }
class GFG { static double maxSubArraySum ( double a [ ] , int size ) { double max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } static void minPossibleSum ( double a [ ] , int n , double x ) { double mxSum = maxSubArraySum ( a , n ) ; double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } sum = sum - mxSum + mxSum / x ; System . out . print ( sum + "NEW_LINE"); } public static void main ( String [ ] args ) { int N = 3 ; double X = 2 ; double A [ ] = { 1 , - 2 , 3 } ; minPossibleSum ( A , N , X ) ; } }
import java . util . * ; class GFG { public static int reverse ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } public static int countReverse ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . replace ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . replace ( arr [ i ] , freq . get ( arr [ i ] ) - 1 ) ; } else { freq . put ( arr [ i ] , - 1 ) ; } if ( freq . containsKey ( reverse ( arr [ i ] ) ) ) { res += freq . get ( reverse ( arr [ i ] ) ) ; } } return res ; } public static void main ( String [ ] args ) { int a [ ] = { 16 , 61 , 12 , 21 , 25 } ; int n = a . length ; System . out . println ( countReverse ( a , n ) ) ; } }
import java . util . * ; class GFG { static void isPossible ( int [ ] A , int n , int k ) { int countOfTwo = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] % 2 == 0 ) { countOfTwo ++ ; } } if ( k == 0 && countOfTwo == n ) System . out . print ( " NO " ) ; else if ( countOfTwo >= k ) { System . out . print ( " YES " ) ; } else System . out . print ( " No " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 5 } ; int K = 2 ; int n = arr . length ; isPossible ( arr , n , K ) ; } }
public class GFG { final static int size = 10001 ; static int prime [ ] = new int [ size ] ; static int freq [ ] = new int [ size ] ; static void sieve ( int a , int b ) { prime [ 1 ] = 1 ; for ( int i = 2 ; i * i < size ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = i * 2 ; j < size ; j += i ) prime [ j ] = 1 ; } } for ( int p = 1 ; p < size ; p ++ ) { for ( int q = 1 ; q < size ; q ++ ) { if ( prime [ p ] == 0 && prime [ q ] == 0 && a * p + b * q < size ) { freq [ a * p + b * q ] ++ ; } } } } public static void main ( String [ ] args ) { int queries = 2 , a = 1 , b = 2 ; sieve ( a , b ) ; int arr [ ] = { 15 , 25 } ; for ( int i = 0 ; i < queries ; i ++ ) { System . out . print ( freq [ arr [ i ] ] + " ▁ " ) ; } } }
class GFG { static void printModulus ( int X , int Y ) { int n = Math . max ( X , Y ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( X % i == Y % i ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int X , Y ; X = 10 ; Y = 20 ; printModulus ( X , Y ) ; } }
import java . util . * ; class GFG { static String check ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) != 0 ) count ++ ; } if ( ( count & 1 ) != 0 ) return " Odd " ; else return " Even " ; } public static void main ( String args [ ] ) { int [ ] arr = { 3 , 9 , 12 , 13 , 15 } ; int n = arr . length ; System . out . println ( check ( arr , n ) ) ; } }
import java . util . * ; class GFG { static boolean isDivisible ( int n ) { int d ; while ( ( n / 100 ) > 0 ) { d = n % 10 ; n /= 10 ; n = Math . abs ( n - ( d * 14 ) ) ; } return ( n % 47 == 0 ) ; } public static void main ( String [ ] args ) { int N = 59173 ; if ( isDivisible ( N ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { static int properDivisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } sum = sum - i ; } return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( properDivisorSum ( n ) ) ; n = 5 ; System . out . println ( properDivisorSum ( n ) ) ; } }
class GFG { static int properDivisorSum ( int n ) { int sum = 0 ; int i ; for ( i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( properDivisorSum ( n ) ) ; n = 5 ; System . out . println ( properDivisorSum ( n ) ) ; } }
class GFG { static int sz = ( int ) 1e5 ; static boolean [ ] isPrime = new boolean [ sz + 1 ] ; static void generatePrime ( ) { int i , j ; for ( i = 2 ; i <= sz ; i ++ ) isPrime [ i ] = true ; for ( i = 2 ; i * i <= sz ; i ++ ) { if ( isPrime [ i ] ) { for ( j = i * i ; j < sz ; j += i ) { isPrime [ j ] = false ; } } } } static void Pair_of_PrimeXor ( int A [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime [ ( A [ i ] ^ A [ j ] ) ] ) { System . out . print ( " ( " + A [ i ] + " , ▁ " + A [ j ] + " ) ▁ " ) ; } } } } public static void main ( String [ ] args ) { int A [ ] = { 1 , 3 , 6 , 11 } ; int n = A . length ; generatePrime ( ) ; Pair_of_PrimeXor ( A , n ) ; } }
class GFG { static boolean isPrime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return false ; } } return true ; } static void printMinCountPrime ( int N ) { int minCount ; if ( isPrime ( N ) ) { minCount = 1 ; } else if ( N % 2 == 0 ) { minCount = 2 ; } else { if ( isPrime ( N - 2 ) ) { minCount = 2 ; } else { minCount = 3 ; } } System . out . print ( minCount + "NEW_LINE"); } public static void main ( String [ ] args ) { int N = 100 ; printMinCountPrime ( N ) ; } }
class GFG { static int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . cbrt ( n ) ; n -= ( largest * largest * largest ) ; steps ++ ; } return steps ; } public static void main ( String [ ] args ) { int n = 150 ; System . out . print ( countSteps ( n ) ) ; } }
class GFG { static void rad ( double d , double h ) { System . out . println ( " The ▁ radius ▁ of ▁ the ▁ circle ▁ is ▁ " + ( ( d * d ) / ( 8 * h ) + h / 2 ) ) ; } public static void main ( String [ ] args ) { double d = 4 , h = 1 ; rad ( d , h ) ; } }
import java . lang . Math ; class GFG { static float Area ( float r ) { if ( r < 0 ) return - 1 ; float x = ( 2 * r ) / ( float ) ( Math . sqrt ( 5 ) ) ; float A = 0.70477f * ( float ) ( Math . pow ( x , 2 ) ) ; return A ; } public static void main ( String [ ] args ) { float r = 5 ; System . out . println ( Area ( r ) ) ; } }
class GFG { static float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( float ) ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; } public static void main ( String [ ] args ) { float a = 9 , n = 10 ; System . out . printf ( " % .3f " , polydiagonal ( n , a ) ) ; } }
import java . lang . * ; class GFG { static double PI = 3.14159265 ; public static double area_cicumscribed ( double c ) { return ( c * c * ( PI / 4 ) ) ; } public static void main ( String [ ] args ) { double c = 8.0 ; System . out . println ( area_cicumscribed ( c ) ) ; } }
import java . io . * ; class GFG { static int maxArea ( float perimeter ) { int length = ( int ) Math . ceil ( perimeter / 4 ) ; int breadth = ( int ) Math . floor ( perimeter / 4 ) ; return length * breadth ; } public static void main ( String [ ] args ) { float n = 38 ; System . out . println ( " Maximum ▁ Area ▁ = ▁ " + maxArea ( n ) ) ; } }
class GFG { static double Perimeter ( double s , int n ) { double perimeter = 1 ; perimeter = n * s ; return perimeter ; } public static void main ( String [ ] args ) { int n = 5 ; double s = 2.5 , peri ; peri = Perimeter ( s , n ) ; System . out . println ( " Perimeter ▁ of ▁ Regular ▁ Polygon " + " ▁ with ▁ " + n + " ▁ sides ▁ of ▁ length ▁ " + s + " ▁ = ▁ " + peri ) ; } }
import java . io . * ; class GFG { static float hexadiagonal ( float a ) { if ( a < 0 ) return - 1 ; return 2 * a ; } public static void main ( String [ ] args ) { float a = 4 ; System . out . print ( hexadiagonal ( a ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float radius = ( float ) Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; } public static void main ( String args [ ] ) { float l = 4 , b = 3 ; System . out . println ( findRadiusOfcircumcircle ( l , b ) ) ; } }
import java . io . * ; class GFG { static void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) System . out . println ( " NO " ) ; else System . out . println ( " YES " ) ; } public static void main ( String [ ] args ) { int n = 100 ; int x = 51 , y = 100 ; halfsquare ( n , x , y ) ; } }
class GFG { static boolean FindPoint ( int x1 , int y1 , int x2 , int y2 , int x , int y ) { if ( x > x1 && x < x2 && y > y1 && y < y2 ) return true ; return false ; } public static void main ( String [ ] args ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x = 1 , y = 5 ; if ( FindPoint ( x1 , y1 , x2 , y2 , x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static void shortest_distance ( float x1 , float y1 , float z1 , float a , float b , float c , float d ) { d = Math . abs ( ( a * x1 + b * y1 + c * z1 + d ) ) ; float e = ( float ) Math . sqrt ( a * a + b * b + c * c ) ; System . out . println ( " Perpendicular ▁ distance ▁ " + " is ▁ " + d / e ) ; } public static void main ( String [ ] args ) { float x1 = 4 ; float y1 = - 4 ; float z1 = 3 ; float a = 2 ; float b = - 2 ; float c = 5 ; float d = 8 ; shortest_distance ( x1 , y1 , z1 , a , b , c , d ) ; } }
import java . io . * ; class GFG { static int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( pentagon_pyramidal ( n ) ) ; } }
class GFG { static boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; } public static void main ( String [ ] args ) { double a = 1 , b = 2 , c = 1 , d = 2 ; System . out . println ( maxArea ( a , b , c , d ) ) ; } }
import java . io . * ; class GFG { static void checkCollision ( int a , int b , int c , int x , int y , int radius ) { double dist = ( Math . abs ( a * x + b * y + c ) ) / Math . sqrt ( a * a + b * b ) ; if ( radius == dist ) System . out . println ( " Touch " ) ; else if ( radius > dist ) System . out . println ( " Intersect " ) ; else System . out . println ( " Outside " ) ; } public static void main ( String [ ] args ) { int radius = 5 ; int x = 0 , y = 0 ; int a = 3 , b = 4 , c = 25 ; checkCollision ( a , b , c , x , y , radius ) ; } }
import java . io . * ; class GFG { static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; } public static void main ( String [ ] args ) { int x1 = - 10 , y1 = 8 ; int x2 = 14 , y2 = - 24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) System . out . println ( " Circle ▁ touch ▁ to " + " ▁ each ▁ other . " ) ; else if ( t < 0 ) System . out . println ( " Circle ▁ not ▁ touch " + " ▁ to ▁ each ▁ other . " ) ; else System . out . println ( " Circle ▁ intersect " + " ▁ to ▁ each ▁ other . " ) ; } }
class GFG { public static int minimumCost ( int arr [ ] , int N , int X , int Y ) { int even_count = 0 , odd_count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) > 0 && ( i % 2 == 0 ) ) { odd_count ++ ; } if ( ( arr [ i ] % 2 ) == 0 && ( i & 1 ) > 0 ) { even_count ++ ; } } int cost1 = X * Math . min ( odd_count , even_count ) ; int cost2 = Y * ( Math . max ( odd_count , even_count ) - Math . min ( odd_count , even_count ) ) ; int cost3 = ( odd_count + even_count ) * Y ; return Math . min ( cost1 + cost2 , cost3 ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 } , X = 10 , Y = 2 ; int N = arr . length ; System . out . println ( minimumCost ( arr , N , X , Y ) ) ; } }
import java . util . * ; class GFG { static int maximizeSubset ( int N , int [ ] arr , int M , int x ) { if ( x == M ) { return 0 ; } int ans = 0 ; for ( int i = x ; i < M ; i ++ ) { if ( N % arr [ i ] == 0 ) { ans = Math . max ( ans , maximizeSubset ( N / arr [ i ] , arr , M , x + 1 ) + 1 ) ; } } return ans ; } public static void main ( String [ ] args ) { int N = 64 ; int [ ] arr = { 1 , 2 , 4 , 8 , 16 , 32 } ; int M = arr . length ; System . out . println ( maximizeSubset ( N , arr , M , 0 ) ) ; } }
class GFG { public static int getProduct ( int n ) { int product = 1 ; while ( n != 0 ) { product = product * ( n % 10 ) ; n = n / 10 ; } return product ; } public static int countPairs ( int L , int R ) { int cntPair = 0 ; for ( int a = L ; a <= R ; a ++ ) { for ( int b = a + 1 ; b <= R ; b ++ ) { int x = getProduct ( a ) ; int y = getProduct ( b ) ; if ( x != 0 && y != 0 && ( a * y ) == ( b * x ) ) { cntPair ++ ; } } } return cntPair ; } public static void main ( String args [ ] ) { int L = 1 ; int R = 100 ; System . out . println ( countPairs ( L , R ) ) ; } }
import java . util . * ; class GFG { static int maxSum ( int [ ] [ ] matrix ) { int r = matrix . length ; int c = matrix [ 0 ] . length ; int sum = 0 ; int mini = Integer . MAX_VALUE ; int count = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { int k = matrix [ i ] [ j ] ; mini = Math . min ( mini , Math . abs ( k ) ) ; if ( k < 0 ) count ++ ; sum += Math . abs ( k ) ; } } if ( count % 2 == 0 ) { return sum ; } else { return ( sum - 2 * mini ) ; } } public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 2 , - 2 } , { - 2 , 2 } } ; System . out . print ( maxSum ( matrix ) ) ; } }
import java . io . * ; class GFG { static int countSubsequences ( int arr [ ] , int N ) { int odd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] & 1 ) % 2 == 1 ) odd ++ ; } return ( 1 << odd ) - 1 ; } public static void main ( String [ ] args ) { int N = 3 ; int arr [ ] = { 1 , 3 , 3 } ; System . out . println ( countSubsequences ( arr , N ) ) ; } }
import java . util . * ; class GFG { static void updateArray ( int [ ] arr , int K ) { int sum = 0 ; ArrayList < Integer > res = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < K ) { sum += arr [ i ] ; } else { if ( sum != 0 ) { res . add ( sum ) ; } sum = 0 ; res . add ( arr [ i ] ) ; } } if ( sum != 0 ) res . add ( sum ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 200 , 6 , 36 , 612 , 121 , 66 , 63 , 39 , 668 , 108 } ; int K = 100 ; updateArray ( arr , K ) ; } }
import java . util . * ; class GFG { static int countQuadruples ( int A [ ] , int N ) { int ans = 0 ; HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( freq . containsKey ( A [ i ] ) ) ans += freq . get ( A [ i ] ) ; for ( int j = 0 ; j < i ; j ++ ) { for ( int k = 0 ; k < j ; k ++ ) { if ( freq . containsKey ( A [ i ] * A [ j ] * A [ k ] ) ) { freq . put ( A [ i ] * A [ j ] * A [ k ] , freq . get ( A [ i ] * A [ j ] * A [ k ] ) + 1 ) ; } else { freq . put ( A [ i ] * A [ j ] * A [ k ] , 1 ) ; } } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 2 , 2 , 7 , 40 , 160 } ; int N = arr . length ; System . out . print ( countQuadruples ( arr , N ) ) ; } }
class GFG { public static long countCells ( int n , int m , int s ) { int mx1 = - 1 ; int cont1 = 0 ; for ( int i = 0 ; i < s && i < n ; ++ i ) { int aux = ( n - ( i + 1 ) ) / s + 1 ; if ( aux > mx1 ) { mx1 = cont1 = aux ; } else if ( aux == mx1 ) cont1 += aux ; } int mx2 = - 1 ; int cont2 = 0 ; for ( int i = 0 ; i < s && i < m ; ++ i ) { int aux = ( m - ( i + 1 ) ) / s + 1 ; if ( aux > mx2 ) mx2 = cont2 = aux ; else if ( aux == mx2 ) cont2 += aux ; } return ( long ) ( cont1 * cont2 ) ; } public static void main ( String args [ ] ) { int N = 5 , M = 5 , K = 2 ; System . out . println ( countCells ( N , M , K ) ) ; } }
import java . util . Arrays ; class GFG { public static int minimumSubarray ( int [ ] arr , int n , int m ) { int [ ] mapu = new int [ m + 1 ] ; Arrays . fill ( mapu , 0 ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { mapu [ arr [ i ] ] ++ ; if ( mapu [ arr [ i ] ] == ( n / m ) + 1 ) c ++ ; } if ( c == 0 ) return 0 ; int ans = n ; int l = 0 , r = 0 ; while ( r < n ) { if ( -- mapu [ arr [ r ] ] == ( n / m ) ) c -- ; if ( c == 0 ) { while ( l <= r && c == 0 ) { ans = Math . min ( ans , r - l + 1 ) ; if ( ++ mapu [ arr [ l ] ] > ( n / m ) ) c ++ ; l ++ ; } } r ++ ; } return ans ; } public static void main ( String args [ ] ) { int [ ] arr = { 1 , 1 , 2 , 1 , 1 , 2 } ; int M = 2 ; int N = arr . length ; System . out . println ( minimumSubarray ( arr , N , M ) ) ; } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ; import java . util . Map ; class GFG { static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res = res * i ; } return res ; } static int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } static void countWays ( String s , String t ) { int n = s . length ( ) ; int sum1 = 0 , sum2 = 0 , K = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '1' ) { sum1 ++ ; } else sum1 -- ; } int m = t . length ( ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( t . charAt ( i ) == '1' ) { sum2 ++ ; } else if ( t . charAt ( i ) == '0' ) { sum2 -- ; } else K ++ ; } int P = Math . abs ( sum1 - sum2 ) ; if ( ( P > K ) || ( K - P ) % 2 == 1 ) { System . out . println ( 0 ) ; return ; } System . out . println ( nCr ( K , ( P + K ) / 2 ) ) ; } public static void main ( String [ ] args ) { String S1 = "1010" ; String S2 = "10 ? ? " ; countWays ( S1 , S2 ) ; } }
import java . io . * ; class GFG { static long ABS ( long x ) { return Math . max ( x , - x ) ; } static void findFraction ( long x , long y , long n ) { long A = - 1 , B = - 1 ; for ( long i = 1 ; i <= n ; i ++ ) { long d = ( i * x ) / y ; if ( d >= 0 && ( A == - 1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; d ++ ; if ( d >= 0 && ( A == - 1 || ABS ( B * x - y * A ) * ABS ( i * y ) > ABS ( i * x - y * d ) * ABS ( B * y ) ) ) A = d ; B = i ; } A -- ; B -- ; System . out . println ( A + " / " + B ) ; } public static void main ( String [ ] args ) { long x = 3 ; long y = 7 ; long n = 6 ; findFraction ( x , y , n ) ; } }
import java . util . Vector ; public class GFG { static Vector < String > FractionSplit ( long n , long d ) { Vector < String > UnitFactions = new Vector < > ( ) ; while ( n > 0 ) { long x = ( d + n - 1 ) / n ; String s = "1 / " + String . valueOf ( x ) ; UnitFactions . add ( s ) ; n = n * x - d ; d = d * x ; } return UnitFactions ; } public static void main ( String [ ] args ) { long n = 13 , d = 18 ; Vector < String > res = FractionSplit ( n , d ) ; for ( String s : res ) System . out . print ( s + " , ▁ " ) ; } }
import java . io . * ; class GFG { public static void minimumDistance ( int arr [ ] , int N ) { int ind = 0 ; int prev = arr [ ind ] ; int s = arr . length ; for ( int i = 0 ; i < N ; i ++ ) { int distance = Integer . MAX_VALUE ; if ( i < arr [ 0 ] ) { distance = arr [ 0 ] - i ; } else if ( i >= prev && ind + 1 < s && i <= arr [ ind + 1 ] ) { distance = Math . min ( i - prev , arr [ ind + 1 ] - i ) ; if ( i == arr [ ind + 1 ] ) { distance = 0 ; prev = arr [ ind + 1 ] ; ind ++ ; } } else { distance = i - prev ; } System . out . print ( distance + " ▁ " ) ; } } public static void main ( String [ ] args ) { int N = 5 ; int arr [ ] = { 0 , 4 } ; minimumDistance ( arr , N ) ; } }
import java . util . * ; class GFG { static int countOfPairs ( int [ ] arr , int N , int X ) { int count = 0 ; HashMap < Integer , Integer > M = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( M . containsKey ( arr [ i ] & X ) ) M . put ( ( arr [ i ] & X ) , M . get ( arr [ i ] & X ) + 1 ) ; else M . put ( arr [ i ] & X , 1 ) ; } for ( Integer entry : M . keySet ( ) ) { int p = M . get ( entry ) ; count += p * ( p - 1 ) / 2 ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 5 , 4 , 6 , 7 } ; int X = 6 ; int N = arr . length ; System . out . print ( countOfPairs ( arr , N , X ) ) ; } }
import java . util . * ; import java . util . HashMap ; class GFG { static void primeFactorization ( int N ) { int [ ] sieve = new int [ N / 2 + 1 ] ; for ( int i = 0 ; i <= N / 2 ; i ++ ) { sieve [ i ] = 0 ; } for ( int i = 2 ; i <= N / 2 ; i ++ ) { if ( sieve [ i ] == 0 ) { for ( int j = i * i ; j <= N / 2 ; j += i ) { sieve [ j ] = 1 ; } } } ArrayList < Integer > prime = new ArrayList < Integer > ( ) ; for ( int i = 3 ; i <= N / 2 ; i ++ ) if ( sieve [ i ] == 0 ) prime . add ( i ) ; int x = prime . size ( ) ; System . out . println ( "2 - > " + x ) ; for ( int i : prime ) System . out . println ( i + " - > 1" ) ; } public static void main ( String args [ ] ) { int N = 18 ; primeFactorization ( N ) ; } }
import java . util . * ; class GFG { static int noOfWays ( int N , int K ) { String S = String . valueOf ( N ) ; int ans = 1 ; for ( int i = 1 ; i < S . length ( ) ; i ++ ) { int count = 1 ; while ( i < S . length ( ) && ( int ) S . charAt ( i ) - 48 + ( int ) S . charAt ( i - 1 ) - 48 == K ) { count ++ ; i ++ ; } if ( count % 2 == 1 ) ans *= ( count + 1 ) / 2 ; } return ans ; } public static void main ( String [ ] args ) { int N = 1454781 ; int K = 9 ; System . out . print ( noOfWays ( N , K ) ) ; } }
import java . util . * ; class GFG { static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } static void printUnitaryDivisors ( int n ) { for ( int i = 1 ; i <= ( int ) Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i && gcd ( i , n / i ) == 1 ) { System . out . print ( i + " ▁ " ) ; } else { if ( gcd ( i , n / i ) == 1 ) { System . out . print ( i + " ▁ " + n / i + " ▁ " ) ; } } } } } public static void main ( String [ ] args ) { int N = 12 ; printUnitaryDivisors ( N ) ; } }
import java . util . * ; class GFG { static void getPermutation ( int N ) { if ( N <= 3 ) { System . out . print ( - 1 ) ; return ; } int i = N ; if ( N % 2 == 0 ) i -- ; while ( i >= 1 ) { System . out . print ( i + " ▁ " ) ; i -= 2 ; } System . out . print ( 4 + " ▁ " + 2 + " ▁ " ) ; i = 6 ; while ( i <= N ) { System . out . print ( i + " ▁ " ) ; i += 2 ; } } public static void main ( String [ ] args ) { int N = 9 ; getPermutation ( N ) ; } }
import java . io . * ; class GFG { static void maxScoreSubArray ( int [ ] a , int [ ] b , int n ) { int res = 0 ; for ( int mid = 0 ; mid < n ; mid ++ ) { int straightScore = a [ mid ] * b [ mid ] , reverseScore = a [ mid ] * a [ mid ] ; int prev = mid - 1 , next = mid + 1 ; res = Math . max ( res , Math . max ( straightScore , reverseScore ) ) ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = Math . max ( res , Math . max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } straightScore = 0 ; reverseScore = 0 ; prev = mid - 1 ; next = mid ; while ( prev >= 0 && next < n ) { straightScore += ( a [ prev ] * b [ prev ] + a [ next ] * b [ next ] ) ; reverseScore += ( a [ prev ] * b [ next ] + a [ next ] * b [ prev ] ) ; res = Math . max ( res , Math . max ( straightScore , reverseScore ) ) ; prev -- ; next ++ ; } } System . out . println ( res ) ; } public static void main ( String [ ] args ) { int A [ ] = { 13 , 4 , 5 } ; int B [ ] = { 10 , 22 , 2 } ; int N = A . length ; maxScoreSubArray ( A , B , N ) ; } }
public class MyClass { static void countValues ( int A , int B , int C ) { if ( B >= A ) { System . out . println ( 0 ) ; return ; } if ( B == 0 ) { System . out . println ( C / A ) ; return ; } int ans = C / A ; if ( ans * A + B <= C ) { ans ++ ; } System . out . println ( ans ) ; } public static void main ( String args [ ] ) { int A = 6 , B = 3 , N = 15 ; countValues ( A , B , N ) ; } }
import java . util . Arrays ; class GFG { static void maxFrequency ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int start = 0 , end = 0 ; int sum = 0 , res = 0 ; for ( end = 0 ; end < N ; end ++ ) { sum += arr [ end ] ; while ( ( end - start + 1 ) * arr [ end ] - sum > K ) { sum -= arr [ start ] ; start ++ ; } res = Math . max ( res , end - start + 1 ) ; } System . out . println ( res ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 8 , 13 } ; int N = 4 ; int K = 5 ; maxFrequency ( arr , N , K ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static void countPairs ( int arr [ ] , int n , int x ) { int count = 0 ; HashMap < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { mp . put ( arr [ i ] - x * i , mp . getOrDefault ( arr [ i ] - x * i , 0 ) + 1 ) ; } for ( int v : mp . values ( ) ) { count += ( v * ( v - 1 ) ) / 2 ; } System . out . println ( count ) ; } public static void main ( String [ ] args ) { int n = 6 , x = 3 ; int arr [ ] = { 5 , 4 , 8 , 11 , 13 , 16 } ; countPairs ( arr , n , x ) ; } }
public class GFG { static int sumOfDivisors ( int N ) { return N ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . println ( sumOfDivisors ( N ) ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static int findXORS ( int arr1 [ ] , int arr2 [ ] , int N , int M ) { int XORS1 = 0 ; int XORS2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { XORS1 ^= arr1 [ i ] ; } for ( int i = 0 ; i < M ; i ++ ) { XORS2 ^= arr2 [ i ] ; } return ( XORS1 & XORS2 ) ; } public static void main ( String [ ] args ) { int arr1 [ ] = { 1 , 2 , 3 } ; int arr2 [ ] = { 6 , 5 } ; int N = arr1 . length ; int M = arr2 . length ; System . out . println ( findXORS ( arr1 , arr2 , N , M ) ) ; } }
public class GFG { static int ceilDifference ( int arr [ ] , int n , int x ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { totalSum += arr [ i ] ; perElementSum += Math . ceil ( ( double ) ( arr [ i ] ) / ( double ) ( x ) ) ; } int totalCeilSum = ( int ) Math . ceil ( ( double ) ( totalSum ) / ( double ) ( x ) ) ; return Math . abs ( perElementSum - totalCeilSum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int K = 4 ; int N = arr . length ; System . out . println ( ceilDifference ( arr , N , K ) ) ; } }
import java . util . * ; class GFG { static int countTriplets ( int N ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= N ; j ++ ) { if ( i * j > N ) break ; ans += N / ( i * j ) ; } } return ans ; } public static void main ( String [ ] args ) { int N = 10 ; System . out . print ( countTriplets ( N ) ) ; } }
import java . util . * ; class GFG { static int minStepK ( int arr [ ] , int N , int K ) { int E = 0 ; int S = 0 ; for ( int i = 0 ; i < N ; i ++ ) { S += arr [ i ] ; if ( arr [ i ] % 2 == 0 ) E += 1 ; } if ( S >= K ) return 0 ; else if ( S + E < K ) return - 1 ; else return K - S ; } public static void main ( String [ ] args ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 } ; int N = arr . length ; int K = 4 ; System . out . println ( minStepK ( arr , N , K ) ) ; } }
class GFG { static void SieveOfEratosthenes ( int n , boolean prime [ ] ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) { prime [ i ] = false ; } } } } static void countPrime ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } SieveOfEratosthenes ( n , prime ) ; int dp [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = 0 ; } dp [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] += dp [ i - 1 ] ; if ( prime [ i ] == true && prime [ i - 2 ] == true ) { dp [ i ] ++ ; } } System . out . print ( dp [ n ] ) ; } public static void main ( String [ ] args ) { int N = 6 ; countPrime ( N ) ; } }
class GFG { static void sumOfSquaredDifferences ( int arr [ ] , int N ) { int ans = 0 ; int sumA = 0 , sumB = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sumA += ( arr [ i ] * arr [ i ] ) ; sumB += arr [ i ] ; } sumA = N * sumA ; sumB = ( sumB * sumB ) ; ans = sumA - sumB ; System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 8 , 4 } ; int N = arr . length ; sumOfSquaredDifferences ( arr , N ) ; } }
import java . io . * ; class GFG { static int countAPs ( int S , int D ) { S = S * 2 ; int answer = 0 ; for ( int i = 1 ; i <= Math . sqrt ( S ) ; i ++ ) { if ( S % i == 0 ) { if ( ( ( S / i ) - D * i + D ) % 2 == 0 ) answer ++ ; if ( ( D * i - ( S / i ) + D ) % 2 == 0 ) answer ++ ; } } return answer ; } public static void main ( String [ ] args ) { int S = 12 , D = 1 ; System . out . println ( countAPs ( S , D ) ) ; } }
import java . util . * ; class GFG { static int distinct ( int arr [ ] , int N ) { Set < Integer > set = new HashSet < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { set . add ( arr [ i ] ) ; } return set . size ( ) ; } static int maxSubarraySumUtil ( int arr [ ] , int N , int K , int totalDistinct ) { if ( K > N ) return 0 ; int max = 0 ; int sum = 0 ; Map < Integer , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { map . put ( arr [ i ] , map . getOrDefault ( arr [ i ] , 0 ) + 1 ) ; sum += arr [ i ] ; if ( i >= K ) { map . put ( arr [ i - K ] , map . get ( arr [ i - K ] ) - 1 ) ; sum -= arr [ i - K ] ; if ( map . get ( arr [ i - K ] ) == 0 ) map . remove ( arr [ i - K ] ) ; } if ( map . size ( ) == totalDistinct ) max = Math . max ( max , sum ) ; } return max ; } static void maxSubarraySum ( int arr [ ] , int K ) { int N = arr . length ; int totalDistinct = distinct ( arr , N ) ; System . out . println ( maxSubarraySumUtil ( arr , N , K , totalDistinct ) ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 7 , 7 , 2 , 4 , 2 , 7 , 4 , 6 , 6 , 6 } ; int K = 6 ; maxSubarraySum ( arr , K ) ; } }
import java . util . * ; class GFG { static int processDiagonal ( ArrayList < Integer > arr ) { int ans = 0 ; int getBit = 1 ; for ( int i = 0 ; i < 32 ; i ++ ) { int S = 0 ; int NS = 0 ; for ( int j : arr ) { if ( ( getBit & j ) != 0 ) S += 1 ; else NS += 1 ; } if ( S > NS ) ans += Math . pow ( 2 , i ) ; getBit <<= 1 ; } return ans ; } static int findSum ( int [ ] [ ] mat ) { int i = 0 ; int j = 0 ; ArrayList < Integer > priDiag = new ArrayList < Integer > ( ) ; while ( i < mat . length ) { priDiag . add ( mat [ i ] [ j ] ) ; i += 1 ; j += 1 ; } i = 0 ; j = mat . length - 1 ; ArrayList < Integer > secDiag = new ArrayList < Integer > ( ) ; while ( i < mat . length ) { secDiag . add ( mat [ i ] [ j ] ) ; i += 1 ; j -= 1 ; } return ( processDiagonal ( priDiag ) + processDiagonal ( secDiag ) ) ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; System . out . print ( findSum ( mat ) ) ; } }
class GFG { static boolean ispalin ( int num ) { String s = Integer . toString ( num ) ; int st = 0 , ed = s . length ( ) - 1 ; while ( st <= ed ) { if ( s . charAt ( st ) != s . charAt ( ed ) ) return false ; st ++ ; ed -- ; } return true ; } static void CalculateXORandOR ( int n ) { int CalculateXOR = 0 ; int CalculateOR = 0 ; int start = ( int ) Math . pow ( 10 , n - 1 ) ; int end = ( int ) Math . pow ( 10 , n ) - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( ispalin ( i ) ) { CalculateXOR = CalculateXOR ^ i ; CalculateOR = CalculateOR | i ; } } System . out . print ( " XOR ▁ = ▁ " + CalculateXOR ) ; System . out . println ( " ▁ OR ▁ = ▁ " + CalculateOR ) ; } public static void main ( String [ ] args ) { int n = 4 ; CalculateXORandOR ( n ) ; } }
class GFG { static int powOfPositive ( int n ) { int pos = ( int ) Math . floor ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; return ( int ) Math . pow ( 2 , pos ) ; } static int powOfNegative ( int n ) { int pos = ( int ) Math . ceil ( ( Math . log ( n ) / Math . log ( 2 ) ) ) ; return ( int ) ( - 1 * Math . pow ( 2 , pos ) ) ; } static void highestPowerOf2 ( int n ) { if ( n > 0 ) { System . out . println ( powOfPositive ( n ) ) ; } else { n = - n ; System . out . println ( powOfNegative ( n ) ) ; } } public static void main ( String [ ] args ) { int n = - 24 ; highestPowerOf2 ( n ) ; } }
class GFG { static int summation ( int n ) { int abs_sum = n * ( n + 1 ) / 2 ; int sign = n + 1 % 2 == 0 ? 1 : - 1 ; int result_sum = sign * abs_sum ; return result_sum ; } public static void main ( String [ ] args ) { int N = 2 ; System . out . println ( summation ( N ) ) ; } }
class GFG { static boolean isPower ( int x , int y ) { int res1 = ( int ) ( Math . log ( y ) / Math . log ( x ) ) ; double res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; } static int countPower ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isPower ( arr [ i ] , arr [ j ] ) || isPower ( arr [ j ] , arr [ i ] ) ) res ++ ; return res ; } public static void main ( String [ ] args ) { int a [ ] = { 16 , 2 , 3 , 9 } ; int n = a . length ; System . out . println ( countPower ( a , n ) ) ; } }
import java . lang . * ; class GFG { public static int noOfCards ( int n ) { return n * ( 3 * n + 1 ) / 2 ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . print ( noOfCards ( n ) ) ; } }
class GFG { static int pairCount ( int n , int m ) { int cnt = 0 , b , a ; for ( b = 0 ; b <= Math . sqrt ( m ) ; b ++ ) { a = m - b * b ; if ( a * a + b == n ) { cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { int n = 9 , m = 3 ; System . out . print ( pairCount ( n , m ) + "NEW_LINE"); } }
class GFG { static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int count_of_subarrays ( int N ) { int count = binomialCoeff ( 2 * N - 1 , N ) ; return count ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . print ( count_of_subarrays ( N ) + "NEW_LINE"); } }
import java . io . * ; import java . lang . Math ; class GFG { static int maxGCD ( int N , int K ) { int minSum = ( K * ( K + 1 ) ) / 2 ; if ( N < minSum ) return - 1 ; int i = ( int ) Math . sqrt ( N ) ; int res = 1 ; while ( i >= 1 ) { if ( N % i == 0 ) { if ( i >= minSum ) res = Math . max ( res , N / i ) ; if ( N / i >= minSum ) res = Math . max ( res , i ) ; } i -- ; } return res ; } public static void main ( String [ ] args ) { int N = 18 , K = 3 ; System . out . println ( maxGCD ( N , K ) ) ; } }
class GFG { static double getSum ( int n ) { double sum = 0 ; if ( n == 1 ) { sum = 45.0 ; } else { sum = ( 99.0 / 2.0 ) * Math . pow ( 10 , n - 1 ) * Math . pow ( 10 , ( n - 1 ) / 2 ) ; } return sum ; } public static void main ( String [ ] args ) { int n = 3 ; double ans = getSum ( n ) ; System . out . print ( ans ) ; } }
class GFG { static int findMin ( int arr [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = Math . max ( m , arr [ i ] ) ; int freq [ ] = new int [ m + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; for ( int i = 1 ; i <= m + 1 ; i ++ ) { int j = i ; int cnt = 0 ; while ( j <= m ) { cnt += freq [ j ] ; j += i ; } if ( cnt == 0 ) return i ; } return m + 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 12 , 6 } ; int n = arr . length ; System . out . println ( findMin ( arr , n ) ) ; } }
class GFG { static int findMinDel ( int [ ] arr , int n ) { int min_num = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) min_num = Math . min ( arr [ i ] , min_num ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == min_num ) cnt ++ ; return n - cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 2 } ; int n = arr . length ; System . out . print ( findMinDel ( arr , n ) ) ; } }
class GFG { static int countDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } static int digitPowSum ( int n ) { int sum = 0 ; int pw = countDigits ( n ) ; while ( n > 0 ) { int d = n % 10 ; sum += Math . pow ( d , pw ) ; pw -- ; n /= 10 ; } return sum ; } static int countNum ( int n ) { int count = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i == digitPowSum ( i ) ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 200 ; System . out . println ( countNum ( n ) ) ; } }
import java . io . * ; class GFG { static void perfectSquares ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( Math . sqrt ( i ) == ( int ) Math . sqrt ( i ) ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int l = 2 , r = 24 ; perfectSquares ( l , r ) ; } }
class GFG { static void findWinner ( int n ) { if ( ( n - 1 ) % 6 == 0 ) { System . out . println ( " Second ▁ Player ▁ wins ▁ the ▁ game " ) ; } else { System . out . println ( " First ▁ Player ▁ wins ▁ the ▁ game " ) ; } } public static void main ( String [ ] args ) { int n = 7 ; findWinner ( n ) ; } }
class GFG { static int lcm ( int a , int b ) { int GCD = __gcd ( a , b ) ; return ( a * b ) / GCD ; } static int MinLCM ( int a [ ] , int n ) { int [ ] Prefix = new int [ n + 2 ] ; int [ ] Suffix = new int [ n + 2 ] ; Prefix [ 1 ] = a [ 0 ] ; for ( int i = 2 ; i <= n ; i += 1 ) { Prefix [ i ] = lcm ( Prefix [ i - 1 ] , a [ i - 1 ] ) ; } Suffix [ n ] = a [ n - 1 ] ; for ( int i = n - 1 ; i >= 1 ; i -= 1 ) { Suffix [ i ] = lcm ( Suffix [ i + 1 ] , a [ i - 1 ] ) ; } int ans = Math . min ( Suffix [ 2 ] , Prefix [ n - 1 ] ) ; for ( int i = 2 ; i < n ; i += 1 ) { ans = Math . min ( ans , lcm ( Prefix [ i - 1 ] , Suffix [ i + 1 ] ) ) ; } return ans ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int a [ ] = { 5 , 15 , 9 , 36 } ; int n = a . length ; System . out . println ( MinLCM ( a , n ) ) ; } }
import java . util . * ; class GFG { static int MOD = 1000000007 ; static int factMod ( int n ) { long fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact *= ( i % MOD ) ; fact %= MOD ; } return ( int ) fact ; } static int countWays ( int n , int m ) { return factMod ( m ) ; } public static void main ( String args [ ] ) { int n = 2 , m = 2 ; System . out . print ( countWays ( n , m ) ) ; } }
class GFG { static boolean isComposite ( int n ) { for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return true ; } return false ; } static int Power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } static boolean isEulerPseudoprime ( int N , int A ) { if ( A <= 0 ) return false ; if ( N % 2 == 0 || ! isComposite ( N ) ) return false ; if ( __gcd ( A , N ) != 1 ) return false ; int mod = Power ( A , ( N - 1 ) / 2 , N ) ; if ( mod != 1 && mod != N - 1 ) return false ; return true ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int N = 121 , A = 3 ; if ( isEulerPseudoprime ( N , A ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int geometricMean ( int n ) { return ( int ) Math . sqrt ( n ) ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( geometricMean ( n ) ) ; } }
class GFG { static int find_k ( int a , int b ) { if ( ( a + b ) % 2 == 0 ) return ( ( a + b ) / 2 ) ; return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 16 ; System . out . println ( find_k ( a , b ) ) ; } }
import java . util . * ; class GFG { static int cntSubSets ( int arr [ ] , int n ) { int maxVal = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == maxVal ) cnt ++ ; } return ( int ) ( Math . pow ( 2 , cnt ) - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 1 , 2 } ; int n = arr . length ; System . out . println ( cntSubSets ( arr , n ) ) ; } }
class GFG { static int getSum ( int n ) { return ( ( n - 1 ) + ( int ) Math . pow ( n , 2 ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( getSum ( n ) ) ; } }
class GFG { static int cntEdges ( int n ) { int edges = ( int ) Math . pow ( 2 , n ) - 2 ; return edges ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( cntEdges ( n ) ) ; } }
class GFG { static int count ( int n ) { return ( int ) ( 15 * Math . pow ( 16 , n - 1 ) ) ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( count ( n ) ) ; } }
import java . util . * ; class GFG { static float findProb ( int arr [ ] , int n ) { long maxSum = Integer . MIN_VALUE , maxCount = 0 , totalPairs = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int sum = arr [ i ] + arr [ j ] ; if ( sum == maxSum ) { maxCount ++ ; } else if ( sum > maxSum ) { maxSum = sum ; maxCount = 1 ; } totalPairs ++ ; } } float prob = ( float ) maxCount / ( float ) totalPairs ; return prob ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = arr . length ; System . out . println ( findProb ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int previousFibonacci ( int n ) { double a = n / ( ( 1 + Math . sqrt ( 5 ) ) / 2.0 ) ; return ( int ) Math . round ( a ) ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( previousFibonacci ( n ) ) ; } }
class GFG { static int count ( int n ) { return 3 * n * ( n - 1 ) + 1 ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . println ( count ( n ) ) ; } }
class GFG { static int ways ( int n ) { return n / 2 ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( ways ( n ) ) ; } }
class GFG { static int findMinValue ( int arr [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return ( ( int ) ( sum / n ) + 1 ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; int n = arr . length ; System . out . print ( findMinValue ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int sumPairs ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( arr [ i ] * ( 2 * n ) ) ; } return sum ; } static public void main ( String [ ] arg ) { int arr [ ] = { 1 , 2 , 3 } ; int n = arr . length ; System . out . println ( sumPairs ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int minSum ( Integer arr [ ] , int n ) { int sum = 0 ; Arrays . sort ( arr , Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 4 < 2 ) sum = sum + arr [ i ] ; } return sum ; } public static void main ( String [ ] args ) { Integer [ ] arr = { 1 , 1 , 10 , 2 , 2 , 2 , 1 } ; int n = arr . length ; System . out . println ( minSum ( arr , n ) ) ; } }
import java . util . * ; class GFG { static long getCount ( int A , int B2 , int C ) { long count = 0 ; for ( int i = 1 ; i <= A ; i ++ ) { long j = ( B2 / i ) + 1 ; if ( C >= j ) count = ( count + C - j + 1 ) ; if ( A >= j && C >= i ) count = ( count + ( C - i + 1 ) * ( A - j + 1 ) ) ; if ( A >= j ) A = ( int ) ( j - 1 ) ; } return count ; } static long countTriplets ( int A , int B , int C ) { long ans = 0 ; for ( int i = 1 ; i <= B ; i ++ ) { ans = ( ans + getCount ( A , i * i , C ) ) ; } return ans ; } public static void main ( String [ ] args ) { int A , B , C ; A = 3 ; B = 2 ; C = 2 ; System . out . println ( countTriplets ( A , B , C ) ) ; } }
class GFG { static int sum ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; } static int repeatedSum ( int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { n = sum ( n ) ; } return n ; } public static void main ( String [ ] args ) { int n = 2 , k = 2 ; System . out . println ( repeatedSum ( n , k ) ) ; } }
import java . util . * ; class GFG { static int MAX = 100000 ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static int smallestPrime ( int d ) { int l = ( int ) Math . pow ( 10 , d - 1 ) ; int r = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( prime [ i ] ) { return i ; } } return - 1 ; } static int largestPrime ( int d ) { int l = ( int ) Math . pow ( 10 , d - 1 ) ; int r = ( int ) Math . pow ( 10 , d ) - 1 ; for ( int i = r ; i >= l ; i -- ) { if ( prime [ i ] ) { return i ; } } return - 1 ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int queries [ ] = { 2 , 5 } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) { System . out . println ( smallestPrime ( queries [ i ] ) + " ▁ " + largestPrime ( queries [ i ] ) ) ; } } }
import java . math . * ; class GFG { public static boolean possible ( int n ) { if ( n > 3 ) { int sum = ( n * ( n + 1 ) ) / 2 ; if ( sum % 3 == 0 ) { return true ; } } return false ; } public static void main ( String [ ] args ) { int n = 5 ; if ( possible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . math . * ; class GFG { public static void checkType ( int arr [ ] , int n ) { if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] <= arr [ n - 1 ] ) System . out . println ( " Increasing " ) ; else if ( arr [ 0 ] >= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Decreasing " ) ; else if ( arr [ 0 ] <= arr [ 1 ] && arr [ n - 2 ] >= arr [ n - 1 ] ) System . out . println ( " Increasing ▁ then ▁ decreasing " ) ; else System . out . println ( " Decreasing ▁ then ▁ increasing " ) ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 } ; int n = arr . length ; checkType ( arr , n ) ; } }
class GFG { static double sum ( double a , double b , double c , double d , double x ) { double ans = ( x * ( a + b ) * ( c - d ) ) / ( ( a * d ) - ( b * c ) ) ; return ans ; } public static void main ( String [ ] args ) { double a = 1 , b = 2 , c = 9 , d = 13 , x = 5 ; System . out . println ( sum ( a , b , c , d , x ) ) ; } }
class GFG { static void printRoots ( long a , long b , long c ) { System . out . println ( 1 + " , ▁ " + c / ( a * 1.0 ) ) ; } public static void main ( String [ ] args ) { long a = 2 ; long b = 3 ; long c = - 5 ; printRoots ( a , b , c ) ; } }
import java . io . * ; class GFG { static int Max_sum ( int a [ ] , int n ) { int pos = 0 , neg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > 0 ) pos = 1 ; else if ( a [ i ] < 0 ) neg = 1 ; if ( ( pos == 1 ) && ( neg == 1 ) ) break ; } int sum = 0 ; if ( ( pos == 1 ) && ( neg == 1 ) ) { for ( int i = 0 ; i < n ; i ++ ) sum += Math . abs ( a [ i ] ) ; } else if ( pos == 1 ) { int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } else if ( neg == 1 ) { for ( int i = 0 ; i < n ; i ++ ) a [ i ] = Math . abs ( a [ i ] ) ; int mini = a [ 0 ] ; sum = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { mini = Math . min ( mini , a [ i ] ) ; sum += a [ i ] ; } sum -= 2 * mini ; } return sum ; } public static void main ( String [ ] args ) { int [ ] a = { 1 , 3 , 5 , - 2 , - 6 } ; int n = a . length ; System . out . println ( Max_sum ( a , n ) ) ; } }
import java . io . * ; class GFG { static void decimalToBinary ( int n ) { if ( n == 0 ) { System . out . print ( "0" ) ; return ; } decimalToBinary ( n / 2 ) ; System . out . print ( n % 2 ) ; } public static void main ( String [ ] args ) { int n = 13 ; decimalToBinary ( n ) ; } }
class GFG { static void Vertices ( int x , int y ) { int val = Math . abs ( x ) + Math . abs ( y ) ; System . out . print ( val * ( x < 0 ? - 1 : 1 ) + " ▁ 0 ▁ " ) ; System . out . print ( "0 ▁ " + val * ( y < 0 ? - 1 : 1 ) ) ; } public static void main ( String [ ] args ) { int x = 3 , y = 3 ; Vertices ( x , y ) ; } }
import java . util . * ; class GFG { static int MAX = 32 ; static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static int pairs ( int arr [ ] , int n , int k ) { int count = 0 ; int [ ] f = new int [ MAX + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) f [ countSetBits ( arr [ i ] ) ] ++ ; for ( int i = 0 ; i <= MAX ; i ++ ) { for ( int j = i ; j <= MAX ; j ++ ) { if ( i + j == k ) { if ( i == j ) count += ( ( f [ i ] * ( f [ i ] - 1 ) ) / 2 ) ; else count += ( f [ i ] * f [ j ] ) ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; int k = 4 ; System . out . println ( pairs ( arr , n , k ) ) ; } }
import java . io . * ; class GFG { static int cnt_neg ; static boolean exists_zero ; static void preProcess ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) cnt_neg ++ ; if ( arr [ i ] == 0 ) exists_zero = true ; } } static boolean isPossible ( int k ) { if ( ! exists_zero ) { if ( k >= cnt_neg && ( k - cnt_neg ) % 2 == 0 ) return true ; else return false ; } else { if ( k >= cnt_neg ) return true ; else return false ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , - 3 , 4 , 5 } ; int n = arr . length ; preProcess ( arr , n ) ; int queries [ ] = { 1 , 2 , 3 , 4 } ; int q = arr . length ; for ( int i = 0 ; i < q ; i ++ ) { if ( isPossible ( queries [ i ] ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } } }
import java . io . * ; class GFG { static int MAX = 1000000 ; static int [ ] prime = new int [ MAX + 1 ] ; static void updatePrimes ( ) { for ( int i = 2 ; i <= MAX ; i ++ ) { prime [ i ] = 1 ; } prime [ 0 ] = prime [ 1 ] = 0 ; for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( prime [ i ] == 1 ) { for ( int j = i * i ; j <= MAX ; j += i ) { prime [ j ] = 0 ; } } } for ( int i = 1 ; i <= MAX ; i ++ ) { prime [ i ] += prime [ i - 1 ] ; } } static int getDifference ( int l , int r ) { int total = r - l + 1 ; int primes = prime [ r ] - prime [ l - 1 ] ; int composites = total - primes ; return ( Math . abs ( primes - composites ) ) ; } public static void main ( String [ ] args ) { int queries [ ] [ ] = { { 1 , 10 } , { 5 , 30 } } ; int q = queries . length ; updatePrimes ( ) ; for ( int i = 0 ; i < q ; i ++ ) System . out . println ( getDifference ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; } }
import java . io . * ; class GFG { static int findIndex ( int [ ] a , int n , int k ) { int index = - 1 , max_ceil = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] + k - 1 ) / k ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] >= max_ceil ) { max_ceil = a [ i ] ; index = i ; } } return index ; } static public void main ( String [ ] args ) { int [ ] arr = { 31 , 12 , 25 , 27 , 32 , 19 } ; int K = 5 ; int N = arr . length ; System . out . print ( findIndex ( arr , N , K ) ) ; } }
import java . util . * ; class GFG { static int Count_Segment ( int p [ ] , int n ) { int count = 0 ; int [ ] upto = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) upto [ i ] = 0 ; int j = 0 , curr = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( p [ i ] > p [ i - 1 ] && p [ i ] > p [ i + 1 ] ) { curr = p [ i ] ; j = i - 1 ; while ( j >= 0 && p [ j ] < curr ) { upto [ p [ j ] ] = curr ; j -= 1 ; } j = i + 1 ; while ( j < n && p [ j ] < curr ) { if ( upto [ curr - p [ j ] ] == curr ) count += 1 ; j += 1 ; } } } return count ; } public static void main ( String [ ] args ) { int p [ ] = { 3 , 4 , 1 , 5 , 2 } ; int n = p . length ; System . out . println ( Count_Segment ( p , n ) ) ; } }
class GFG { static int validPosition ( int arr [ ] , int N , int K ) { int count = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 6 , 7 } , K = 4 ; int N = arr . length ; System . out . println ( validPosition ( arr , N , K ) ) ; } }
class GFG { static int N = 1000 ; static int countPairs ( int arr [ ] , int n ) { int size = ( 2 * N ) + 1 ; int freq [ ] = new int [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 , 5 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
class GFG { static int highestPower ( String str , int len ) { int ans = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == '0' ) ans ++ ; else break ; } return ans ; } public static void main ( String [ ] args ) { String str = "100100" ; int len = str . length ( ) ; System . out . println ( highestPower ( str , len ) ) ; } }
class GFG { static boolean isPossible ( int n ) { int fac [ ] = new int [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 19 ; if ( isPossible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static boolean isPerfectSquare ( int [ ] arr , int n ) { HashMap < Integer , Integer > umap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( umap . containsKey ( arr [ i ] ) ) umap . put ( arr [ i ] , umap . get ( arr [ i ] ) + 1 ) ; else umap . put ( arr [ i ] , 1 ) ; } Iterator < Map . Entry < Integer , Integer > > iterator = umap . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = iterator . next ( ) ; if ( entry . getValue ( ) % 2 == 1 ) return false ; } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 7 , 7 } ; int n = arr . length ; if ( isPerfectSquare ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static void printMaxValPair ( Vector < Long > v , int n ) { Collections . sort ( v ) ; long N = v . get ( ( int ) n - 1 ) ; if ( N % 2 == 1 ) { long first_maxima = N / 2 ; long second_maxima = first_maxima + 1 ; long ans1 = ( long ) 3e18 , ans2 = ( long ) 3e18 ; long from_left = - 1 , from_right = - 1 ; long from = - 1 ; for ( long i = 0 ; i < n ; ++ i ) { if ( v . get ( ( int ) i ) > first_maxima ) { from = i ; break ; } else { long diff = first_maxima - v . get ( ( int ) i ) ; if ( diff < ans1 ) { ans1 = diff ; from_left = v . get ( ( int ) i ) ; } } } from_right = v . get ( ( int ) from ) ; long diff1 = first_maxima - from_left ; long diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) System . out . println ( N + " ▁ " + from_left ) ; else System . out . println ( N + " ▁ " + from_right ) ; } else { long maxima = N / 2 ; long ans1 = ( int ) 3e18 ; long R = - 1 ; for ( long i = 0 ; i < n - 1 ; ++ i ) { long diff = Math . abs ( v . get ( ( int ) i ) - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v . get ( ( int ) i ) ; } } System . out . println ( N + " ▁ " + R ) ; } } public static void main ( String args [ ] ) { long arr [ ] = { 1 , 1 , 2 , 3 , 6 , 1 } ; Vector < Long > v = new Vector < Long > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) v . add ( arr [ i ] ) ; int n = v . size ( ) ; printMaxValPair ( v , n ) ; } }
import java . util . * ; class GFG { static int countQuadruples ( int a [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( mp . containsKey ( a [ i ] ) ) { mp . put ( a [ i ] , mp . get ( a [ i ] ) + 1 ) ; } else { mp . put ( a [ i ] , 1 ) ; } int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) continue ; mp . put ( a [ j ] , mp . get ( a [ j ] ) - 1 ) ; mp . put ( a [ k ] , mp . get ( a [ k ] ) - 1 ) ; int first = a [ j ] - ( a [ k ] - a [ j ] ) ; int fourth = ( a [ k ] * a [ k ] ) / a [ j ] ; if ( ( a [ k ] * a [ k ] ) % a [ j ] == 0 ) { if ( a [ j ] != a [ k ] ) { if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * mp . get ( fourth ) ; } else if ( mp . containsKey ( first ) && mp . containsKey ( fourth ) ) count += mp . get ( first ) * ( mp . get ( fourth ) - 1 ) ; } if ( mp . containsKey ( a [ j ] ) ) { mp . put ( a [ j ] , mp . get ( a [ j ] ) + 1 ) ; } else { mp . put ( a [ j ] , 1 ) ; } if ( mp . containsKey ( a [ k ] ) ) { mp . put ( a [ k ] , mp . get ( a [ k ] ) + 1 ) ; } else { mp . put ( a [ k ] , 1 ) ; } } } return count ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 6 , 4 , 9 , 2 } ; int n = a . length ; System . out . print ( countQuadruples ( a , n ) ) ; } }
class Sol { static int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; } public static void main ( String args [ ] ) { int n = 8 , m = 5 ; System . out . println ( getPosition ( n , m ) ) ; } }
class GFG { static int parity ( int a ) { return a % 3 ; } static int solve ( int [ ] array , int size ) { int operations = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { int pari1 = parity ( array [ i ] ) ; int pari2 = parity ( array [ i + 2 ] ) ; if ( pari1 == pari2 ) { if ( pari1 == 0 ) array [ i + 1 ] = 1 ; else if ( pari1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( pari1 == 0 && pari2 == 1 ) || ( pari1 == 1 && pari2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( pari1 == 1 && pari2 == 2 ) || ( pari1 == 2 && pari2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( pari1 == 2 && pari2 == 0 ) || ( pari1 == 0 && pari2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; } public static void main ( String arg [ ] ) { int [ ] array = { 2 , 1 , 3 , 0 } ; int size = array . length ; System . out . println ( solve ( array , size ) ) ; } }
class GFG { static int checkArray ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( checkArray ( arr , n ) ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int countTriplets ( int n , Vector < pair > points ) { Set < pair > pts = new HashSet < pair > ( ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) pts . add ( points . get ( i ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points . get ( i ) . first + points . get ( j ) . first ; int y = points . get ( i ) . second + points . get ( j ) . second ; if ( x % 2 == 0 && y % 2 == 0 ) if ( ! pts . contains ( new pair ( x / 2 , y / 2 ) ) ) ct ++ ; } return ct ; } public static void main ( String args [ ] ) { Vector < pair > points = new Vector < > ( ) ; points . add ( new pair ( 1 , 1 ) ) ; points . add ( new pair ( 2 , 2 ) ) ; points . add ( new pair ( 3 , 3 ) ) ; int n = points . size ( ) ; System . out . println ( countTriplets ( n , points ) ) ; } }
import java . util . * ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int lcmOfArray ( int arr [ ] , int n ) { if ( n < 1 ) return 0 ; int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) lcm = ( lcm * arr [ i ] ) / gcd ( lcm , arr [ i ] ) ; return lcm ; } static int minPerfectCube ( int arr [ ] , int n ) { int minPerfectCube ; int lcm = lcmOfArray ( arr , n ) ; minPerfectCube = lcm ; int cnt = 0 ; while ( lcm > 1 && lcm % 2 == 0 ) { cnt ++ ; lcm /= 2 ; } if ( cnt % 3 == 2 ) minPerfectCube *= 2 ; else if ( cnt % 3 == 1 ) minPerfectCube *= 4 ; int i = 3 ; while ( lcm > 1 ) { cnt = 0 ; while ( lcm % i == 0 ) { cnt ++ ; lcm /= i ; } if ( cnt % 3 == 1 ) minPerfectCube *= i * i ; else if ( cnt % 3 == 2 ) minPerfectCube *= i ; i += 2 ; } return minPerfectCube ; } public static void main ( String args [ ] ) { int arr [ ] = { 10 , 125 , 14 , 42 , 100 } ; int n = arr . length ; System . out . println ( minPerfectCube ( arr , n ) ) ; } }
import java . util . * ; class Solution { static int maxGCD ( int N , int P ) { int ans = 1 ; Map < Integer , Integer > prime_factors = new HashMap < Integer , Integer > ( ) ; for ( int i = 2 ; i * i <= P ; i ++ ) { while ( P % i == 0 ) { if ( prime_factors . get ( i ) == null ) prime_factors . put ( i , 1 ) ; else prime_factors . put ( i , ( prime_factors . get ( i ) + 1 ) ) ; P /= i ; } } if ( P != 1 ) if ( prime_factors . get ( P ) == null ) prime_factors . put ( P , 1 ) ; else prime_factors . put ( P , ( prime_factors . get ( P ) + 1 ) ) ; Set < Map . Entry < Integer , Integer > > st = prime_factors . entrySet ( ) ; for ( Map . Entry < Integer , Integer > me : st ) { ans *= Math . pow ( me . getKey ( ) , me . getValue ( ) / N ) ; } return ans ; } public static void main ( String args [ ] ) { int N = 3 , P = 24 ; System . out . println ( maxGCD ( N , P ) ) ; } }
import java . util . * ; public class GFG { public static ArrayList < Integer > getPerfectSquares ( int n ) { ArrayList < Integer > perfectSquares = new ArrayList < > ( ) ; int current = 1 , i = 1 ; while ( current <= n ) { perfectSquares . add ( current ) ; current = ( int ) Math . pow ( ++ i , 2 ) ; } return perfectSquares ; } public static int countTriplets ( int n ) { ArrayList < Integer > perfectSquares = getPerfectSquares ( ( int ) Math . pow ( n , 2 ) ) ; int count = 0 ; for ( int a = 1 ; a <= n ; a ++ ) { int aSquare = ( int ) Math . pow ( a , 2 ) ; for ( int i = 0 ; i < perfectSquares . size ( ) ; i ++ ) { int cSquare = perfectSquares . get ( i ) ; int bSquare = cSquare - aSquare ; int b = ( int ) Math . sqrt ( bSquare ) ; int c = ( int ) Math . sqrt ( cSquare ) ; if ( c < a || ! perfectSquares . contains ( bSquare ) ) continue ; if ( ( b >= a ) && ( b <= c ) && ( aSquare + bSquare == cSquare ) ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( countTriplets ( n ) ) ; } }
import java . io . * ; class GFG { static void MinSteps ( int SourceX , int SourceY , int DestX , int DestY ) { System . out . println ( Math . max ( Math . abs ( SourceX - DestX ) , Math . abs ( SourceY - DestY ) ) ) ; while ( ( SourceX != DestX ) || ( SourceY != DestY ) ) { if ( SourceX < DestX ) { System . out . print ( ' U ' ) ; SourceX ++ ; } if ( SourceX > DestX ) { System . out . println ( ' D ' ) ; SourceX -- ; } if ( SourceY > DestY ) { System . out . print ( ' L ' ) ; SourceY -- ; } if ( SourceY < DestY ) { System . out . print ( ' R ' ) ; SourceY ++ ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int sourceX = 4 , sourceY = 4 ; int destinationX = 7 , destinationY = 0 ; MinSteps ( sourceX , sourceY , destinationX , destinationY ) ; } }
class GFG { static boolean isPalindrome ( int num ) { int reverse_num = 0 , remainder , temp ; temp = num ; while ( temp != 0 ) { remainder = temp % 10 ; reverse_num = reverse_num * 10 + remainder ; temp /= 10 ; } if ( reverse_num == num ) { return true ; } return false ; } static boolean isOddLength ( int num ) { int count = 0 ; while ( num > 0 ) { num /= 10 ; count ++ ; } if ( count % 2 != 0 ) { return true ; } return false ; } static long sumOfAllPalindrome ( int L , int R ) { long sum = 0 ; if ( L <= R ) for ( int i = L ; i <= R ; i ++ ) { if ( isPalindrome ( i ) && isOddLength ( i ) ) { sum += i ; } } return sum ; } public static void main ( String [ ] args ) { int L = 110 , R = 1130 ; System . out . println ( sumOfAllPalindrome ( L , R ) ) ; } }
class GFG { static boolean productSumDivisible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int n = 1234 ; int len = 4 ; if ( productSumDivisible ( n , len ) ) { System . out . println ( " TRUE " ) ; } else { System . out . println ( " FALSE " ) ; } } }
import java . lang . * ; import java . util . * ; class GFG { static void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } System . out . print ( " Sum ▁ = ▁ " + sum ) ; System . out . print ( " Product = " + product); } public static void main ( String args [ ] ) { int n = 1012 ; countDigit ( n ) ; } }
class GFG { static int MAX = 1000000 ; static boolean [ ] prime = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { prime [ 1 ] = true ; prime [ 0 ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } } static void productOfKthPrimes ( int arr [ ] , int n , int k ) { int c = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { product *= arr [ i ] ; c = 0 ; } } } System . out . println ( product ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 5 , k = 2 ; int [ ] arr = new int [ ] { 2 , 3 , 5 , 7 , 11 } ; productOfKthPrimes ( arr , n , k ) ; } }
class GFG { static long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( nthKyneaNumber ( n ) ) ; } }
import java . io . * ; class GFG { static int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . print ( fnMod ( n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static int modExp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b == 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; } static int check ( int num ) { if ( num == 1 num < 3 ) return - 1 ; else if ( num % 4 == 0 ) return modExp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return - 1 ; } public static void main ( String [ ] args ) { int num = 10 ; System . out . print ( check ( num ) ) ; } }
public class GFG { static int Race ( int B , int C ) { int result = 0 ; result = ( ( C * 100 ) / B ) ; return 100 - result ; } public static void main ( String [ ] args ) { int B = 10 ; int C = 28 ; B = 100 - B ; C = 100 - C ; System . out . println ( Race ( B , C ) + " ▁ meters " ) ; } }
import java . io . * ; class GFG { static long binomialCoeff ( long n , long k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( long n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( catalan ( n ) ) ; } }
import java . io . * ; import java . lang . Math ; class GFG { static void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { double d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; System . out . println ( " Distance ▁ is ▁ " + d ) ; return ; } public static void main ( String [ ] args ) { float x1 = 2 ; float y1 = - 5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ; distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; } }
import java . io . * ; class GFG { static void findGreater ( int a , int b , int n ) { if ( ! ( ( n & 1 ) > 0 ) ) { a = Math . abs ( a ) ; b = Math . abs ( b ) ; } if ( a == b ) System . out . println ( " a ^ n ▁ is ▁ " + " equal ▁ to ▁ b ^ n " ) ; else if ( a > b ) System . out . println ( " a ^ n ▁ is ▁ greater ▁ " + " than ▁ b ^ n " ) ; else System . out . println ( " b ^ n ▁ is ▁ greater ▁ " + " than ▁ a ^ n " ) ; } public static void main ( String [ ] args ) { int a = 12 , b = 24 , n = 5 ; findGreater ( a , b , n ) ; } }
import java . io . * ; class GFG { static int subtractOne ( int x ) { int m = 1 ; while ( ! ( ( x & m ) > 0 ) ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } public static void main ( String [ ] args ) { System . out . println ( subtractOne ( 13 ) ) ; } }
import java . lang . Math . * ; class GFG { static final double PI = 3.142 ; static double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; } public static void main ( String [ ] args ) { float x = 50 ; int n = 5 ; System . out . println ( ( float ) ( cosXSertiesSum ( x , 5 ) * 1000000 ) / 1000000.00 ) ; } }
import java . lang . System . * ; class GFG { static int findBucketNo ( int p ) { return ( int ) Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int p = 10 ; System . out . println ( findBucketNo ( p ) ) ; } }
import java . util . * ; class GFG { static int MAX = 50002 ; static ArrayList < Integer > primes = new ArrayList < Integer > ( ) ; public static void sieve ( ) { boolean isPrime [ ] = new boolean [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) isPrime [ i ] = false ; } } for ( int p = 2 ; p < MAX ; p ++ ) if ( isPrime [ p ] == true ) primes . add ( p ) ; } public static int power ( int x , int y ) { int count = 0 ; int z = y ; while ( x >= z ) { count += ( x / z ) ; z *= y ; } return count ; } public static int modMult ( int a , int b , int mod ) { int res = 0 ; a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } public static int countWays ( int n , int m ) { int ans = 1 ; for ( int i = 1 ; i < primes . size ( ) ; i ++ ) { int powers = power ( n , primes . get ( i ) ) ; if ( powers == 0 ) break ; ans = modMult ( ans , powers + 1 , m ) % m ; } if ( ( ( ans - 1 ) % m ) < 0 ) return ( ans - 1 + m ) % m ; else return ( ans - 1 ) % m ; } public static void main ( String [ ] args ) { sieve ( ) ; int n = 4 , m = 7 ; System . out . println ( countWays ( n , m ) ) ; } }
class GFG { static void pythagoreanTriplet ( int n ) { for ( int i = 1 ; i <= n / 3 ; i ++ ) { for ( int j = i + 1 ; j <= n / 2 ; j ++ ) { int k = n - i - j ; if ( i * i + j * j == k * k ) { System . out . print ( i + " , ▁ " + j + " , ▁ " + k ) ; return ; } } } System . out . print ( " No ▁ Triplet " ) ; } public static void main ( String arg [ ] ) { int n = 12 ; pythagoreanTriplet ( n ) ; } }
class GFG { static int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } static int repeatedNumberSum ( int n , int x ) { int sum = x * digSum ( n ) ; return digSum ( sum ) ; } public static void main ( String [ ] args ) { int n = 24 , x = 3 ; System . out . println ( repeatedNumberSum ( n , x ) ) ; } }
class GFG { static final int MAX = 100000 ; static int multiply ( int x , int res [ ] , int res_size ) { int carry = 0 ; for ( int i = 0 ; i < res_size ; i ++ ) { int prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry > 0 ) { res [ res_size ] = carry % 10 ; carry = carry / 10 ; res_size ++ ; } return res_size ; } static void power ( int x , int n ) { if ( n == 0 ) { System . out . print ( "1" ) ; return ; } int res [ ] = new int [ MAX ] ; int res_size = 0 ; int temp = x ; while ( temp != 0 ) { res [ res_size ++ ] = temp % 10 ; temp = temp / 10 ; } for ( int i = 2 ; i <= n ; i ++ ) res_size = multiply ( x , res , res_size ) ; System . out . print ( x + " ^ " + n + " ▁ = ▁ " ) ; for ( int i = res_size - 1 ; i >= 0 ; i -- ) System . out . print ( res [ i ] ) ; } public static void main ( String [ ] args ) { int exponent = 100 ; int base = 2 ; power ( base , exponent ) ; } }
class GFG { static double findArea ( double d ) { return ( d * d ) / 2 ; } public static void main ( String [ ] args ) { double d = 10 ; System . out . println ( findArea ( d ) ) ; } }
import java . io . * ; class GFG { static void findNumbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) System . out . print ( "1" + " ▁ " ) ; System . out . print ( "2" + " ▁ " ) ; System . out . println ( n + d ) ; } public static void main ( String args [ ] ) { int N = 3 , D = 5 ; findNumbers ( N , D ) ; } }
import java . io . * ; public class GFG { static float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } static public void main ( String [ ] args ) { int n = 2 ; System . out . println ( AvgofSquareN ( n ) ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int LCM ( int a , int b ) { return ( a * b ) / ( __gcd ( a , b ) ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static int lcmOfNumerator ( Vector < pair > vect ) { int lcm = vect . get ( 0 ) . first ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) lcm = LCM ( vect . get ( i ) . first , lcm ) ; return lcm ; } static int gcdOfDemoninators ( Vector < pair > vect ) { int gcd = vect . get ( 0 ) . second ; for ( int i = 1 ; i < vect . size ( ) ; i ++ ) gcd = __gcd ( vect . get ( i ) . second , gcd ) ; return gcd ; } static void lcmOfRationals ( Vector < pair > vect ) { System . out . print ( lcmOfNumerator ( vect ) + " / " + gcdOfDemoninators ( vect ) ) ; } public static void main ( String [ ] args ) { Vector < pair > vect = new Vector < pair > ( ) ; vect . add ( new pair ( 2 , 7 ) ) ; vect . add ( new pair ( 3 , 14 ) ) ; vect . add ( new pair ( 5 , 3 ) ) ; lcmOfRationals ( vect ) ; } }
import java . io . * ; class GFG { static int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; } public static void main ( String args [ ] ) { int a = 1 , d = 1 , b = 2 , r = 2 , n = 3 ; System . out . println ( sumofNterm ( a , d , b , r , n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; } public static void main ( String argc [ ] ) { int a = 1 , b = 4 , c = 5 ; System . out . println ( first ( a , b , c ) ) ; } }
import java . util . * ; class GFG { static boolean isPrime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; } static int minimumSum ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( minimumSum ( n ) ) ; } }
import java . io . * ; class GFG { static int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( term ( n ) ) ; } }
class GFG { static double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; } public static void main ( String [ ] args ) { int x = 2 ; int n = 5 ; System . out . printf ( " % .2f " , sum ( x , n ) ) ; } }
import java . io . * ; class GFG { static double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; } public static void main ( String args [ ] ) { double a = 1.20 , b = 22.5 ; System . out . printf ( " % .1f " , gcd ( a , b ) ) ; } }
class GFG { static void gcdMax ( int [ ] a , int [ ] b , int n , int N ) { int [ ] cnt = new int [ N ] ; int [ ] first = new int [ N ] ; int [ ] second = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; int x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; System . out . println ( first [ x ] + " ▁ " + second [ x ] ) ; } public static void main ( String [ ] args ) { int [ ] a = { 3 , 1 , 4 , 2 , 8 } ; int [ ] b = { 5 , 2 , 12 , 8 , 3 } ; int n = a . length ; int N = 20 ; gcdMax ( a , b , n , N ) ; } }
class Subarray { static int calculate ( int a [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + 1 ; for ( int j = r ; j < n ; j ++ ) { if ( a [ i ] == a [ j ] ) r += 1 ; else break ; } int d = r - i ; ans += ( d * ( d + 1 ) / 2 ) ; i = r - 1 ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { 2 , 4 , 5 , 3 , 3 , 3 } ; System . out . println ( calculate ( a , a . length ) ) ; } }
import java . io . * ; class GFG { static int sum ( int n ) { int rem = 0 ; int sum_of_digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_of_digits += rem ; n = n / 10 ; } return sum_of_digits ; } static int count ( int n ) { int c = 0 ; for ( int i = n - 97 ; i <= n ; i ++ ) { int a = sum ( i ) ; int b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; } public static void main ( String [ ] args ) { int n = 9939 ; System . out . println ( count ( n ) ) ; } }
import java . util . * ; import java . lang . Math ; class GFG { static ArrayList < Integer > SieveOfEratosthenes ( int n ) { boolean [ ] prime = new boolean [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = true ; } ArrayList < Integer > lis = new ArrayList < Integer > ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) lis . add ( p ) ; return lis ; } static int setBits ( int n ) { return Integer . bitCount ( n ) ; } public static int log2 ( int x ) { return ( int ) ( Math . log ( x ) / Math . log ( 2 ) + 1e-10 ) ; } public static void main ( String [ ] args ) { int x = 4 , y = 8 ; int count = 0 ; ArrayList < Integer > primeArr = new ArrayList < Integer > ( ) ; primeArr = SieveOfEratosthenes ( ( int ) Math . ceil ( log2 ( y ) ) ) ; for ( int i = x ; i < y + 1 ; i ++ ) { int temp = setBits ( i ) ; if ( primeArr . contains ( temp ) ) count += 1 ; } System . out . println ( count ) ; } }
import java . io . * ; class GFG { public static int countTrailingZeroes ( int N ) { int res = N ^ ( N - 1 ) ; return ( int ) ( Math . log ( temp ) / Math . log ( 2 ) ) ; } public static void main ( String [ ] args ) { int N = 12 ; System . out . println ( countTrailingZeroes ( N ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static int formed_no ( int N , int K ) { if ( K == 1 ) { return N ; } int answer = N ; while ( K != 0 ) { int a_current = prod_of_max_min ( answer ) ; if ( a_current == 0 ) break ; answer += a_current ; } return answer ; } static int prod_of_max_min ( int n ) { int largest = 0 ; int smallest = 10 ; while ( n != 0 ) { int r = n % 10 ; largest = Math . max ( r , largest ) ; smallest = Math . min ( r , smallest ) ; n = n / 10 ; } return largest * smallest ; } public static void main ( String [ ] args ) { int N = 487 , K = 100000000 ; System . out . println ( formed_no ( N , K ) ) ; } }
import java . util . * ; class GFG { static int subsetSum ( int arr [ ] , int n , int sum , int s , int count ) { if ( n == 0 ) { if ( sum == s ) { count ++ ; } return count ; } count = subsetSum ( arr , n - 1 , sum , s , count ) ; count = subsetSum ( arr , n - 1 , sum , s + arr [ n - 1 ] , count ) ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int sum = 10 ; int n = arr . length ; System . out . print ( subsetSum ( arr , n , sum , s , 0 ) ) ; } }
class GFG { static boolean doesContainB ( int a , int b , int c ) { if ( a == b ) { return true ; } if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) { return true ; } return false ; } public static void main ( String [ ] args ) { int a = 1 , b = 7 , c = 3 ; if ( doesContainB ( a , b , c ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class GFG { static int subtractOne ( int x ) { return ( ( x << 1 ) + ( ~ x ) ) ; } public static void main ( String [ ] args ) { System . out . printf ( " % d " , subtractOne ( 13 ) ) ; } }
import java . io . * ; class GFG { static int digitSum ( long n ) { int digSum = 0 ; while ( n > 0 ) { digSum += n % 10 ; n /= 10 ; } return digSum ; } public static long countInteger ( long n , long s ) { if ( n < s ) return 0 ; for ( long i = s ; i <= Math . min ( n , s + 163 ) ; i ++ ) if ( ( i - digitSum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; } public static void main ( String args [ ] ) { long n = 1000 , s = 100 ; System . out . println ( countInteger ( n , s ) ) ; } }
import java . util . * ; class GFG { static double sumOfSeries ( int n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( sumOfSeries ( n ) ) ; } }
import java . io . * ; class GFG { static void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { System . out . println ( " - 1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) System . out . print ( r * i + " ▁ " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( res ) ; } } public static void main ( String [ ] args ) { int n = 24 ; int k = 4 ; print_sequence ( n , k ) ; n = 24 ; k = 5 ; print_sequence ( n , k ) ; n = 6 ; k = 4 ; print_sequence ( n , k ) ; } }
import java . util . * ; class GFG { static int countDigit ( long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; } public static void main ( String [ ] args ) { long n = 345289467 ; System . out . print ( " Number ▁ of ▁ digits ▁ : ▁ " + countDigit ( n ) ) ; } }
import java . io . * ; class GFG { static String decToBin ( int n ) { if ( n == 0 ) return "0" ; String bin = " " ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; } public static void main ( String [ ] args ) { int n = 38 ; System . out . println ( decToBin ( n ) ) ; } }
class GFG { static boolean findNoIsDivisibleOrNot ( int a [ ] , int n ) { for ( int i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; } public static void main ( String [ ] args ) { int a [ ] = { 14 , 12 , 4 , 18 } ; int n = 2 ; if ( findNoIsDivisibleOrNot ( a , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . length ; System . out . println ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int findNthEvenDigitNumber ( int n ) { if ( n == 1 ) { return 0 ; } Vector < Integer > v = new Vector < > ( ) ; n = n - 1 ; while ( n > 0 ) { v . add ( n % 5 ) ; n = n / 5 ; } int result = 0 ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v . get ( i ) ; } return 2 * result ; } public static void main ( String [ ] args ) { System . out . println ( findNthEvenDigitNumber ( 2 ) ) ; System . out . println ( findNthEvenDigitNumber ( 10 ) ) ; } }
class GFG { static long moduloMultiplication ( long a , long b , long mod ) { long res = 0 ; a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; } public static void main ( String [ ] args ) { long a = 10123465234878998L ; long b = 65746311545646431L ; long m = 10005412336548794L ; System . out . print ( moduloMultiplication ( a , b , m ) ) ; } }
import java . util . * ; class GFG { static void kFactors ( int n , int k ) { ArrayList < Integer > P = new ArrayList < Integer > ( ) ; while ( n % 2 == 0 ) { P . add ( 2 ) ; n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . add ( i ) ; } } if ( n > 2 ) P . add ( n ) ; if ( P . size ( ) < k ) { System . out . println ( " - 1" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) System . out . print ( P . get ( i ) + " , ▁ " ) ; int product = 1 ; for ( int i = k - 1 ; i < P . size ( ) ; i ++ ) product = product * P . get ( i ) ; System . out . println ( product ) ; } public static void main ( String [ ] args ) { int n = 54 , k = 3 ; kFactors ( n , k ) ; } }
class GFG { static int MAX = 100001 ; static int [ ] perfectDiv = new int [ MAX ] ; static void precomputeCounts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) { for ( int j = i * i ; j < MAX ; j += i * i ) ++ perfectDiv [ j ] ; } } static int countPerfectDivisors ( int n ) { return perfectDiv [ n ] ; } public static void main ( String [ ] args ) { precomputeCounts ( ) ; int n = 16 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; n = 12 ; System . out . println ( " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; } }
class GFG { static int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; } public static void main ( String [ ] args ) { int n = 72 ; System . out . println ( findMinNumber ( n ) ) ; } }
import java . io . * ; class GFG { static void SieveOfEratosthenes ( int n , boolean prime [ ] ) { for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } static void mersennePrimes ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; SieveOfEratosthenes ( n , prime ) ; for ( int k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { long num = ( 1 << k ) - 1 ; if ( prime [ ( int ) ( num ) ] ) System . out . print ( num + " ▁ " ) ; } } public static void main ( String args [ ] ) { int n = 31 ; System . out . println ( " Mersenne ▁ prime " + " numbers ▁ smaller ▁ than " + " or ▁ equal ▁ to ▁ " + n ) ; mersennePrimes ( n ) ; } }
import java . io . * ; import java . math . * ; class GFG { static boolean isPerfect ( int n ) { int s = ( int ) ( Math . sqrt ( n ) ) ; return ( s * s == n ) ; } static int divisorsCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count += 1 ; else count += 2 ; } } return count ; } static int kDivisors ( int a , int b , int k ) { int count = 0 ; for ( int i = a ; i <= b ; i ++ ) { if ( isPerfect ( i ) ) if ( divisorsCount ( i ) == k ) count ++ ; } return count ; } public static void main ( String args [ ] ) { int a = 21 , b = 149 , k = 333 ; System . out . println ( kDivisors ( a , b , k ) ) ; } }
import java . io . * ; class GFG { static int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; } public static void main ( String [ ] args ) { int n = 10 ; int p = 5 ; System . out . println ( findCountOfSolutions ( n , p ) ) ; } }
import java . util . Arrays ; class GFG { static int kaprekarRec ( int n , int prev ) { if ( n == 0 ) return 0 ; prev = n ; int [ ] digits = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { digits [ i ] = n % 10 ; n = n / 10 ; } Arrays . sort ( digits ) ; int asc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) asc = asc * 10 + digits [ i ] ; Arrays . sort ( digits ) ; int desc = 0 ; for ( int i = 3 ; i >= 0 ; i -- ) desc = desc * 10 + digits [ i ] ; int diff = Math . abs ( asc - desc ) ; if ( diff == prev ) return diff ; return kaprekarRec ( diff , prev ) ; } static int kaprekar ( int n ) { int prev = 0 ; return kaprekarRec ( n , prev ) ; } public static void main ( String [ ] args ) { System . out . println ( kaprekar ( 1000 ) ) ; System . out . println ( kaprekar ( 1112 ) ) ; System . out . println ( kaprekar ( 9812 ) ) ; } }
import java . io . * ; class code_conversion { char xor_c ( char a , char b ) { return ( a == b ) ? '0' : '1' ; } char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; } String binarytoGray ( String binary ) { String gray = " " ; gray += binary . charAt ( 0 ) ; for ( int i = 1 ; i < binary . length ( ) ; i ++ ) { gray += xor_c ( binary . charAt ( i - 1 ) , binary . charAt ( i ) ) ; } return gray ; } String graytoBinary ( String gray ) { String binary = " " ; binary += gray . charAt ( 0 ) ; for ( int i = 1 ; i < gray . length ( ) ; i ++ ) { if ( gray . charAt ( i ) == '0' ) binary += binary . charAt ( i - 1 ) ; else binary += flip ( binary . charAt ( i - 1 ) ) ; } return binary ; } public static void main ( String args [ ] ) throws IOException { code_conversion ob = new code_conversion ( ) ; String binary = "01001" ; System . out . println ( " Gray ▁ code ▁ of ▁ " + binary + " ▁ is ▁ " + ob . binarytoGray ( binary ) ) ; String gray = "01101" ; System . out . println ( " Binary ▁ code ▁ of ▁ " + gray + " ▁ is ▁ " + ob . graytoBinary ( gray ) ) ; } }
import java . util . * ; class GFG { static int getSum ( int BITree [ ] , int index ) { int sum = 0 ; while ( index > 0 ) { sum += BITree [ index ] ; index -= index & ( - index ) ; } return sum ; } static void updateBIT ( int BITree [ ] , int n , int index , int val ) { while ( index <= n ) { BITree [ index ] += val ; index += index & ( - index ) ; } } static void convert ( int arr [ ] , int n ) { int [ ] temp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ; Arrays . sort ( temp ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = lower_bound ( temp , 0 , n , arr [ i ] ) + 1 ; } } static int lower_bound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) low = middle + 1 ; else high = middle ; } return low ; } static int getInvCount ( int arr [ ] , int n ) { int invcount = 0 ; convert ( arr , n ) ; int [ ] BIT = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) BIT [ i ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { invcount += getSum ( BIT , arr [ i ] - 1 ) ; updateBIT ( BIT , n , arr [ i ] , 1 ) ; } return invcount ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 4 , 2 , 1 } ; int n = arr . length ; System . out . print ( " Number ▁ of ▁ inversions ▁ are ▁ : ▁ " + getInvCount ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num . charAt ( i ) - '0' ) % a ; return res ; } public static void main ( String [ ] args ) { String num = "12316767678678" ; System . out . println ( mod ( num , 10 ) ) ; } }
import java . io . * ; class GFG { static int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; } public static void main ( String args [ ] ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) System . out . println ( " phi ( " + n + " ) ▁ = ▁ " + phi ( n ) ) ; } }
import java . io . * ; class GFG { static int Largestpower ( int n , int p ) { int ans = 0 ; while ( n > 0 ) { n /= p ; ans += n ; } return ans ; } public static void main ( String [ ] args ) { int n = 10 ; int p = 3 ; System . out . println ( " ▁ The ▁ largest ▁ power ▁ of ▁ " + p + " ▁ that ▁ divides ▁ " + n + " ! ▁ is ▁ " + Largestpower ( n , p ) ) ; } }
import java . io . * ; class GFG { static void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " ▁ " ) ; square = square + odd ; odd = odd + 2 ; } } public static void main ( String [ ] args ) { int n = 5 ; printSquares ( n ) ; } }
class Factorial { int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } public static void main ( String args [ ] ) { Factorial obj = new Factorial ( ) ; int num = 5 ; System . out . println ( " Factorial ▁ of ▁ " + num + " ▁ is ▁ " + obj . factorial ( num ) ) ; } }
import java . util . * ; class GFG { static void Or_of_Ands_for_each_query ( int arr [ ] , int n , int queries [ ] [ ] , int q ) { int bits [ ] = new int [ 32 ] ; Arrays . fill ( bits , 0 ) ; for ( int i = 0 ; i < 32 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( 1 << i ) & arr [ j ] ) != 0 ) { bits [ i ] ++ ; } } } for ( int p = 0 ; p < q ; p ++ ) { for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & arr [ queries [ p ] [ 0 ] ] ) != 0 ) { bits [ i ] -- ; } if ( ( queries [ p ] [ 1 ] & ( 1 << i ) ) != 0 ) { bits [ i ] ++ ; } } arr [ queries [ p ] [ 0 ] ] = queries [ p ] [ 1 ] ; int ans = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( bits [ i ] != 0 ) { ans |= ( 1 << i ) ; } } System . out . println ( ans ) ; } } public static void main ( String [ ] args ) { int n = 3 , q = 2 ; int arr [ ] = { 3 , 5 , 7 } ; int queries [ ] [ ] = { { 1 , 2 } , { 2 , 1 } } ; Or_of_Ands_for_each_query ( arr , n , queries , q ) ; } }
import java . util . * ; class GFG { static int findmax ( int arr [ ] , int n , int k ) { int trav , i ; int c = 0 , maximum = 0 ; for ( i = 0 ; i < n - k + 1 ; i ++ ) { trav = i - 1 ; c = 0 ; while ( trav >= 0 && arr [ trav ] == 1 ) { trav -- ; c ++ ; } trav = i + k ; while ( trav < n && arr [ trav ] == 1 ) { trav ++ ; c ++ ; } c += k ; if ( c > maximum ) maximum = c ; } return maximum ; } public static void main ( String args [ ] ) { int k = 3 ; int arr [ ] = { 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 } ; int n = arr . length ; int ans = findmax ( arr , n , k ) ; System . out . println ( ans ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int maxAndXor ( int arr [ ] , int n ) { int ans = Integer . MAX_VALUE ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans = Math . min ( ans , arr [ i ] ^ arr [ i + 1 ] ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 5 } ; int N = arr . length ; System . out . println ( maxAndXor ( arr , N ) ) ; } }
import java . util . * ; class GFG { static int countSubarray ( int [ ] arr , int K , int N ) { if ( K % 2 != 0 ) return 0 ; if ( N < K ) return 0 ; int start = 0 ; int i = 0 ; int count = 0 ; int currXor = arr [ i ++ ] ; while ( i < K ) { currXor ^= arr [ i ] ; i ++ ; } if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ++ ] ; while ( i < N ) { currXor ^= arr [ i ] ; i ++ ; if ( currXor == 0 ) count ++ ; currXor ^= arr [ start ++ ] ; } return count ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 4 , 4 , 2 , 2 , 4 } ; int K = 4 ; int N = arr . length ; System . out . println ( countSubarray ( arr , K , N ) ) ; } }
import java . util . * ; class GFG { static int minimumFlips ( int X , int Y , int Z ) { int res = 0 ; while ( X > 0 Y > 0 Z > 0 ) { if ( ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) && ( Z % 2 == 1 ) ) { X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; continue ; } else if ( ! ( X % 2 == 1 ) && ! ( Y % 2 == 1 ) && ( Z % 2 == 1 ) ) { res ++ ; } else if ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) { if ( ( X % 2 == 1 ) && ( Y % 2 == 1 ) && ! ( Z % 2 == 1 ) ) { res += 2 ; } else if ( ( ( X % 2 == 1 ) || ( Y % 2 == 1 ) ) && ! ( Z % 2 == 1 ) ) { res ++ ; } } X = X >> 1 ; Y = Y >> 1 ; Z = Z >> 1 ; } return res ; } public static void main ( String [ ] args ) { int X = 5 , Y = 8 , Z = 6 ; System . out . print ( minimumFlips ( X , Y , Z ) ) ; } }
import java . util . * ; class GFG { static void FlipBits ( int n ) { for ( int bit = 0 ; bit < 32 ; bit ++ ) { if ( ( n >> bit ) % 2 > 0 ) { n = n ^ ( 1 << bit ) ; break ; } } System . out . print ( " The ▁ number ▁ after ▁ unsetting ▁ the " ) ; System . out . print ( " ▁ rightmost ▁ set ▁ bit ▁ " + n ) ; } public static void main ( String [ ] args ) { int N = 12 ; FlipBits ( N ) ; } }
class GFG { static int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( bitwiseAndOdd ( n ) ) ; } }
class GFG { static long multiplyByFifteen ( long n ) { long prod = ( n << 3 ) ; prod += ( n << 2 ) ; prod += ( n << 1 ) ; prod += n ; return prod ; } public static void main ( String [ ] args ) { long n = 7 ; System . out . print ( multiplyByFifteen ( n ) ) ; } }
public class GFG { static int countX ( int n ) { String binary = Integer . toBinaryString ( n ) ; int count = 0 ; for ( int i = 0 ; i < binary . length ( ) ; i ++ ) { if ( binary . charAt ( i ) == '1' ) count ++ ; } int answer = ( int ) Math . pow ( 2 , count ) ; return answer ; } public static void main ( String args [ ] ) { int n = 5 ; int answer = countX ( n ) ; System . out . println ( answer ) ; } }
class GFG { static int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; } public static void main ( String [ ] args ) { int a = - 10 ; int b = 15 ; int x = a ; System . out . print ( " x ▁ is ▁ : ▁ " + x ) ; x = alternate ( a , b , x ) ; System . out . print ( " After exchange "); System . out . print ( " x is : " + x); } }
import java . io . * ; class GFG { static void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } System . out . println ( " Number ▁ of ▁ different ▁ bits ▁ : ▁ " + count ) ; } public static void main ( String [ ] args ) { int A = 12 , B = 15 ; solve ( A , B ) ; } }
import java . util . * ; class GFG { static class Node { int data ; Node left , right ; } ; static Node newNode ( int data ) { Node node = new Node ( ) ; node . data = data ; node . left = node . right = null ; return ( node ) ; } static void printSetBit ( Node root ) { if ( root == null ) return ; System . out . print ( " Set ▁ bits ▁ in ▁ Node ▁ " + root . data + " ▁ = ▁ " + Integer . bitCount ( root . data ) + "NEW_LINE"); printSetBit ( root . left ) ; printSetBit ( root . right ) ; } public static void main ( String [ ] args ) { Node root = newNode ( 16 ) ; root . left = newNode ( 13 ) ; root . left . left = newNode ( 14 ) ; root . left . right = newNode ( 12 ) ; root . right = newNode ( 11 ) ; root . right . left = newNode ( 10 ) ; root . right . right = newNode ( 16 ) ; printSetBit ( root ) ; } }
import java . util . * ; class solution { static void MakePreSum ( int [ ] arr , int [ ] presum , int n ) { presum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) presum [ i ] = presum [ i - 1 ] + arr [ i ] ; } static int BinaryLifting ( int [ ] presum , int n , int x ) { int pos = 0 ; int LOGN = ( int ) Math . log ( n ) ; if ( x <= presum [ 0 ] ) return 0 ; for ( int i = LOGN ; i >= 0 ; i -- ) { if ( pos + ( 1 << i ) < n && presum [ pos + ( 1 << i ) ] < x ) { pos += ( 1 << i ) ; } } return pos + 1 ; } public static void main ( String args [ ] ) { int [ ] arr = { 2 , 5 , 7 , 1 , 6 , 9 , 12 , 4 , 6 } ; int x = 8 ; int n = arr . length ; int [ ] presum = new int [ n ] ; Arrays . fill ( presum , 0 ) ; MakePreSum ( arr , presum , n ) ; System . out . println ( BinaryLifting ( presum , n , x ) ) ; } }
class GFG { static boolean allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 17 ; int l = 2 , r = 4 ; if ( allBitsSetInTheGivenRange ( n , l , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; } public static void main ( String [ ] args ) { int n = 9 ; if ( onlyFirstAndLastAreSet ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { public static int _popcnt32 ( long number ) { int count = 0 ; while ( number > 0 ) { count += number & 1L ; number >>= 1L ; } return count ; } static long minimize ( long a ) { int n = _popcnt32 ( a ) ; return ( ( long ) Math . pow ( 2 , n ) - 1 ) ; } public static void main ( String args [ ] ) { long a = 11 ; System . out . print ( minimize ( a ) ) ; } }
class GFG { static int getMid ( int s , int e ) { return s + ( e - s ) / 2 ; } static void constructSTUtil ( int arr [ ] , int ss , int se , int st [ ] , int si , boolean operation ) { if ( ss == se ) { st [ si ] = arr [ ss ] ; return ; } int mid = getMid ( ss , se ) ; constructSTUtil ( arr , ss , mid , st , si * 2 + 1 , ! operation ) ; constructSTUtil ( arr , mid + 1 , se , st , si * 2 + 2 , ! operation ) ; if ( operation ) { st [ si ] = ( st [ 2 * si + 1 ] st [ 2 * si + 2 ] ) ; } else { st [ si ] = ( st [ 2 * si + 1 ] ^ st [ 2 * si + 2 ] ) ; } } static int [ ] constructST ( int arr [ ] , int n ) { int x = ( int ) ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) ) ; int max_size = 2 * ( int ) Math . pow ( 2 , x ) - 1 ; int [ ] st = new int [ max_size ] ; boolean operationAtRoot = ! ( x % 2 == 0 ) ; constructSTUtil ( arr , 0 , n - 1 , st , 0 , operationAtRoot ) ; return st ; } public static void main ( String [ ] args ) { int leaves [ ] = { 1 , 6 , 3 , 7 , 5 , 9 , 10 , 4 } ; int n = leaves . length ; int [ ] segmentTree = constructST ( leaves , n ) ; int rootIndex = 0 ; System . out . println ( " Value ▁ at ▁ Root ▁ Node ▁ = ▁ " + segmentTree [ rootIndex ] ) ; } }
class GFG { static boolean isFibbinaryNum ( int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; } public static void main ( String [ ] args ) { int n = 10 ; if ( isFibbinaryNum ( n ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static long divide ( long dividend , long divisor ) { long sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1L << i ; } } if ( sign == - 1 ) quotient = - quotient ; return quotient ; } public static void main ( String args [ ] ) { int a = 10 , b = 3 ; System . out . println ( divide ( a , b ) ) ; int a1 = 43 , b1 = - 8 ; System . out . println ( divide ( a1 , b1 ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { static int maxAND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = res > ( arr [ i ] & arr [ j ] ) ? res : ( arr [ i ] & arr [ j ] ) ; return res ; } public static void main ( String argc [ ] ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = arr . length ; System . out . println ( " Maximum ▁ AND ▁ Value ▁ = ▁ " + maxAND ( arr , n ) ) ; } }
class GFG { static int setAllBitsAfterMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; } static int toggle ( int n ) { n = n ^ setAllBitsAfterMSB ( n ) ; return n ; } public static void main ( String arg [ ] ) { int n = 10 ; n = toggle ( n ) ; System . out . print ( n ) ; } }
class GFG { static int INT_SIZE = 32 ; static int constructNthNumber ( int group_no , int aux_num , int op ) { int a [ ] = new int [ INT_SIZE ] ; int num = 0 , len_f ; int i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num > 0 ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; } static int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 == 1 ) else aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . printf ( " % d " , getNthNumber ( n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; } public static void main ( String argc [ ] ) { int n = 107 ; int m = 4 ; n = toggleLastMBits ( n , m ) ; System . out . println ( n ) ; } }
import java . util . * ; class GFG { static int xorPairCount ( int arr [ ] , int n , int x ) { Map < Integer , Integer > m = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = x ^ arr [ i ] ; if ( m . containsKey ( curr_xor ) ) result += m . get ( curr_xor ) ; if ( m . containsKey ( arr [ i ] ) ) { m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; } else { m . put ( arr [ i ] , 1 ) ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 5 , 2 } ; int n = arr . length ; int x = 0 ; System . out . println ( " Count ▁ of ▁ pairs ▁ with ▁ given ▁ XOR ▁ = ▁ " + xorPairCount ( arr , n , x ) ) ; } }
class GFG { static int maxLength ( int arr [ ] , int n ) { int maxLen = 0 ; int i = 0 ; int j = i + 1 ; while ( j < n ) { if ( arr [ i ] != arr [ j ] ) { maxLen = Math . max ( maxLen , 2 ) ; int l = i - 1 ; int r = j + 1 ; while ( l >= 0 && r < n && arr [ l ] == arr [ i ] && arr [ r ] == arr [ j ] ) { l -- ; r ++ ; } maxLen = Math . max ( maxLen , 2 * ( r - j ) ) ; } i ++ ; j = i + 1 ; } return maxLen ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 1 } ; int n = arr . length ; System . out . println ( maxLength ( arr , n ) ) ; } }
import java . util . * ; import java . io . * ; class GFG { static int minDigits ( int N , int K ) { int digits_num = ( int ) Math . floor ( Math . log ( N ) + 1 ) ; int temp_sum = 0 ; int temp = digits_num ; int result = 0 ; int X , var ; int sum = 0 ; int num2 = N ; while ( num2 != 0 ) { sum += num2 % 10 ; num2 /= 10 ; } if ( sum <= K ) { X = 0 ; } else { while ( temp > 0 ) { var = ( N / ( ( int ) Math . pow ( 10 , temp - 1 ) ) ) ; temp_sum += var % 10 ; if ( temp_sum >= K ) { var /= 10 ; var ++ ; result = var * ( int ) Math . pow ( 10 , temp ) ; break ; } temp -- ; } X = result - N ; return X ; } return - 1 ; } public static void main ( String args [ ] ) { int N = 11 ; int K = 1 ; System . out . println ( minDigits ( N , K ) ) ; } }
import java . util . * ; class GFG { static int upperBound ( int arr [ ] , int N , int K ) { int l = 0 ; int r = N ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] <= K ) { l = mid + 1 ; } else { r = mid ; } } return l ; } static void NDivKWithFreq ( int arr [ ] , int N , int K ) { Arrays . sort ( arr ) ; int i = 0 ; while ( i < N ) { int X = upperBound ( arr , N , arr [ i ] ) ; if ( ( X - i ) > N / 4 ) { System . out . print ( arr [ i ] + " ▁ " ) ; } i = X ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 2 , 6 , 6 , 6 , 6 , 7 , 10 } ; int N = arr . length ; int K = 4 ; NDivKWithFreq ( arr , N , K ) ; } }
import java . util . * ; class GFG { static double getMaxMedian ( int [ ] arr , int n , int k ) { int size = n + k ; Arrays . sort ( arr ) ; if ( size % 2 == 0 ) { double median = ( double ) ( arr [ ( size / 2 ) - 1 ] + arr [ size / 2 ] ) / 2 ; return median ; } double median1 = arr [ size / 2 ] ; return median1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 3 , 4 , 2 } ; int n = arr . length ; int k = 2 ; System . out . print ( ( int ) getMaxMedian ( arr , n , k ) ) ; } }
import java . util . * ; import java . lang . * ; class GeeksforGeeks { final static int MAX = 26 ; static boolean function ( String str ) { int l = str . length ( ) ; int counter [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) counter [ i ] = 0 ; for ( int i = 0 ; i < l / 2 ; i ++ ) counter [ str . charAt ( i ) - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter [ str . charAt ( i ) - ' a ' ] -- ; for ( int i = 0 ; i < MAX ; i ++ ) if ( counter [ i ] != 0 ) return true ; return false ; } public static void main ( String args [ ] ) { String str = " abcasdsabcae " ; if ( function ( str ) ) System . out . print ( " Yes , ▁ both ▁ halves " + " ▁ differ ▁ by ▁ at ▁ least ▁ one ▁ character " ) ; else System . out . print ( " No , ▁ both ▁ halves " + " ▁ do ▁ not ▁ differ ▁ at ▁ all " ) ; } }
class GFG { static void printSorted ( int a , int b , int c ) { int get_max = Math . max ( a , Math . max ( b , c ) ) ; int get_min = - Math . max ( - a , Math . max ( - b , - c ) ) ; int get_mid = ( a + b + c ) - ( get_max + get_min ) ; System . out . print ( get_min + " ▁ " + get_mid + " ▁ " + get_max ) ; } public static void main ( String [ ] args ) { int a = 4 , b = 1 , c = 9 ; printSorted ( a , b , c ) ; } }
class InsertionSort { void sort ( int arr [ ] ) { int n = arr . length ; for ( int i = 1 ; i < n ; ++ i ) { int key = arr [ i ] ; int j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; } arr [ j + 1 ] = key ; } } static void printArray ( int arr [ ] ) { int n = arr . length ; for ( int i = 0 ; i < n ; ++ i ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 } ; InsertionSort ob = new InsertionSort ( ) ; ob . sort ( arr ) ; printArray ( arr ) ; } }
import java . util . * ; class GFG { public static void main ( String [ ] args ) { String S = " geeksforg " ; System . out . println ( maxNumPalindrome ( S ) ) ; } static int maxNumPalindrome ( String S ) { int i = 0 ; int [ ] freq = new int [ 26 ] ; int freqPair = 0 ; int len = S . length ( ) / 3 ; while ( i < S . length ( ) ) { freq [ S . charAt ( i ) - ' a ' ] ++ ; i ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { freqPair += ( freq [ i ] / 2 ) ; } return Math . min ( freqPair , len ) ; } }
import java . util . * ; class GFG { static int height ( int s , Vector < Integer > adj [ ] , int [ ] visited ) { visited [ s ] = 1 ; int h = 0 ; for ( int child : adj [ s ] ) { if ( visited [ child ] == 0 ) { h = Math . max ( h , 1 + height ( child , adj , visited ) ) ; } } return h ; } static int minimumGroups ( Vector < Integer > adj [ ] , int N ) { int [ ] visited = new int [ N + 1 ] ; int groups = Integer . MIN_VALUE ; for ( int i = 1 ; i <= N ; i ++ ) { if ( visited [ i ] == 0 ) { int comHeight ; comHeight = height ( i , adj , visited ) ; groups = Math . max ( groups , comHeight ) ; } } return groups ; } static void addEdge ( Vector < Integer > adj [ ] , int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } public static void main ( String [ ] args ) { int N = 5 ; Vector < Integer > [ ] adj = new Vector [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; addEdge ( adj , 1 , 2 ) ; addEdge ( adj , 3 , 2 ) ; addEdge ( adj , 4 , 3 ) ; System . out . print ( minimumGroups ( adj , N ) ) ; } }
import java . io . * ; class GFG { static int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; } public static void main ( String [ ] args ) { int n = 11 , k = 2 ; System . out . println ( find_sum ( n , k ) ) ; } }
public class GFG { static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } static int minCost ( int cost [ ] [ ] , int m , int n ) { if ( n < 0 m < 0 ) return Integer . MAX_VALUE ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } public static void main ( String args [ ] ) { int cost [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; System . out . print ( minCost ( cost , 2 , 2 ) ) ; } }
class GFG { static void countSmaller ( String str ) { int n = str . length ( ) ; int arr [ ] = new int [ 26 ] ; int ans [ ] = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { arr [ str . charAt ( i ) - ' a ' ] ++ ; int ct = 0 ; for ( int j = 0 ; j < str . charAt ( i ) - ' a ' ; j ++ ) { ct += arr [ j ] ; } ans [ i ] = ct ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ans [ i ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { String str = " edcbaa " ; countSmaller ( str ) ; } }
class GFG { private static StringBuilder charBuffer = new StringBuilder ( ) ; public static String processWords ( String input ) { String s [ ] = input . split ( " ( \\ s ) + " ) ; for ( String values : s ) { charBuffer . append ( values . charAt ( 0 ) ) ; } return charBuffer . toString ( ) ; } public static void main ( String [ ] args ) { String input = " geeks ▁ for TABSYMBOL geeks ▁ geeks TABSYMBOL for ▁ geeks " ; System . out . println ( processWords ( input ) ) ; } }
import java . util . * ; class GfG { static void generateGrayarr ( int n ) { if ( n <= 0 ) return ; ArrayList < String > arr = new ArrayList < String > ( ) ; arr . add ( "0" ) ; arr . add ( "1" ) ; int i , j ; for ( i = 2 ; i < ( 1 << n ) ; i = i << 1 ) { for ( j = i - 1 ; j >= 0 ; j -- ) arr . add ( arr . get ( j ) ) ; for ( j = 0 ; j < i ; j ++ ) arr . set ( j , "0" + arr . get ( j ) ) ; for ( j = i ; j < 2 * i ; j ++ ) arr . set ( j , "1" + arr . get ( j ) ) ; } for ( i = 0 ; i < arr . size ( ) ; i ++ ) System . out . println ( arr . get ( i ) ) ; } public static void main ( String [ ] args ) { generateGrayarr ( 3 ) ; } }
import java . util . * ; class GFG { static Vector < String > possiblePaths = new Vector < > ( ) ; static String path = " " ; static final int MAX = 5 ; static boolean isSafe ( int row , int col , int m [ ] [ ] , int n , boolean visited [ ] [ ] ) { if ( row == - 1 row == n col == - 1 col == n visited [ row ] [ col ] m [ row ] [ col ] == 0 ) return false ; return true ; } static void printPathUtil ( int row , int col , int m [ ] [ ] , int n , boolean visited [ ] [ ] ) { if ( row == - 1 row == n col == - 1 col == n visited [ row ] [ col ] m [ row ] [ col ] == 0 ) return ; if ( row == n - 1 && col == n - 1 ) { possiblePaths . add ( path ) ; return ; } visited [ row ] [ col ] = true ; if ( isSafe ( row + 1 , col , m , n , visited ) ) { path += ' D ' ; printPathUtil ( row + 1 , col , m , n , visited ) ; path = path . substring ( 0 , path . length ( ) - 1 ) ; } if ( isSafe ( row , col - 1 , m , n , visited ) ) { path += ' L ' ; printPathUtil ( row , col - 1 , m , n , visited ) ; path = path . substring ( 0 , path . length ( ) - 1 ) ; } if ( isSafe ( row , col + 1 , m , n , visited ) ) { path += ' R ' ; printPathUtil ( row , col + 1 , m , n , visited ) ; path = path . substring ( 0 , path . length ( ) - 1 ) ; } if ( isSafe ( row - 1 , col , m , n , visited ) ) { path += ' U ' ; printPathUtil ( row - 1 , col , m , n , visited ) ; path = path . substring ( 0 , path . length ( ) - 1 ) ; } visited [ row ] [ col ] = false ; } static void printPath ( int m [ ] [ ] , int n ) { boolean [ ] [ ] visited = new boolean [ n ] [ MAX ] ; printPathUtil ( 0 , 0 , m , n , visited ) ; for ( int i = 0 ; i < possiblePaths . size ( ) ; i ++ ) System . out . print ( possiblePaths . get ( i ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int m [ ] [ ] = { { 1 , 0 , 0 , 0 , 0 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 } } ; int n = m . length ; printPath ( m , n ) ; } }
import java . io . * ; class GFG { static int countDirectPath ( int N ) { return N + ( N * ( N - 3 ) ) / 2 ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . print ( countDirectPath ( N ) ) ; } }
import java . util . * ; class solution { static int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( ( int ) Math . pow ( ( x - h ) , 2 ) / ( int ) Math . pow ( a , 2 ) ) + ( ( int ) Math . pow ( ( y - k ) , 2 ) / ( int ) Math . pow ( b , 2 ) ) ; return p ; } public static void main ( String arr [ ] ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 , b = 5 ; if ( checkpoint ( h , k , x , y , a , b ) > 1 ) System . out . println ( " Outside " ) ; else if ( checkpoint ( h , k , x , y , a , b ) == 1 ) System . out . println ( " On ▁ the ▁ ellipse " ) ; else System . out . println ( " Inside " ) ; } }
class GFG { static void center ( int x1 , int x2 , int y1 , int y2 ) { System . out . print ( ( float ) ( x1 + x2 ) / 2 + " , ▁ " + ( float ) ( y1 + y2 ) / 2 ) ; } public static void main ( String arg [ ] ) { int x1 = - 9 , y1 = 3 , x2 = 5 , y2 = - 7 ; center ( x1 , x2 , y1 , y2 ) ; } }
import java . io . * ; class GFG { static double Area ( int b1 , int b2 , int h ) { return ( ( b1 + b2 ) / 2 ) * h ; } public static void main ( String [ ] args ) { int base1 = 8 , base2 = 10 , height = 6 ; double area = Area ( base1 , base2 , height ) ; System . out . println ( " Area ▁ is : ▁ " + area ) ; } }
class GFG { static double areaCube ( double a ) { return ( a * a * a ) ; } static double surfaceCube ( double a ) { return ( 6 * a * a ) ; } public static void main ( String [ ] args ) { double a = 5 ; System . out . println ( " Area ▁ = ▁ " + areaCube ( a ) ) ; System . out . println ( " Total ▁ surface ▁ area ▁ = ▁ " + surfaceCube ( a ) ) ; } }
class GFG { static class pair { double first , second ; public pair ( double first , double second ) { this . first = first ; this . second = second ; } } static pair mirrorImage ( double a , double b , double c , double x1 , double y1 ) { double temp = - 2 * ( a * x1 + b * y1 + c ) / ( a * a + b * b ) ; double x = temp * a + x1 ; double y = temp * b + y1 ; return new pair ( x , y ) ; } public static void main ( String [ ] args ) { double a = - 1.0 ; double b = 1.0 ; double c = 0.0 ; double x1 = 1.0 ; double y1 = 0.0 ; pair image = mirrorImage ( a , b , c , x1 , y1 ) ; System . out . print ( " Image ▁ of ▁ point ▁ ( " + x1 + " , ▁ " + y1 + " ) ▁ " ) ; System . out . print ( " by ▁ mirror ▁ ( " + a + " ) x ▁ + ▁ ( " + b + " ) y ▁ + ▁ ( " + c + " ) ▁ = ▁ 0 , ▁ is ▁ : " ) ; System . out . println ( " ( " + image . first + " , ▁ " + image . second + " ) " ) ; } }
import java . util . * ; class GFG { static int fact ( int n ) { if ( n == 1 n == 0 ) return 1 ; else return n * fact ( n - 1 ) ; } static int findValue ( int n , int r , int a ) { int k = ( a - 1 ) / fact ( n ) ; int answer = k ; for ( int i = 1 ; i < n + 1 ; i ++ ) answer = answer * ( n + r - i ) ; answer = answer + 1 ; return answer ; } public static void main ( String args [ ] ) { int N = 1 ; int A = 2 ; int R = 3 ; System . out . print ( findValue ( N , R , A ) ) ; } }
import java . io . * ; class GFG { static void countNo ( int A , int N , int L , int R ) { int ans = L - 1 + N + ( int ) Math . floor ( ( N - 1 ) / ( A - 1 ) ) ; if ( ans % A == 0 ) { ans = ans + 1 ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int A = 5 , N = 10 , L = 4 , R = 20 ; countNo ( A , N , L , R ) ; } }
import java . util . * ; class GFG { static int MAX = 1000000 ; static boolean [ ] prime = new boolean [ MAX ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i < MAX ; i += p ) prime [ i ] = false ; } } } static int sumPrime ( int k ) { SieveOfEratosthenes ( ) ; Vector < Integer > v = new Vector < > ( ) ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) v . add ( i ) ; } int sum = 0 ; int skip = ( k * ( k - 1 ) ) / 2 ; while ( k > 0 ) { sum += v . get ( skip ) ; skip ++ ; k -- ; } return sum ; } public static void main ( String [ ] args ) { int k = 3 ; System . out . println ( sumPrime ( k ) ) ; } }
import java . util . * ; class GFG { static int nextOccurrence ( String str , int n , int start , char ch ) { for ( int i = start ; i < n ; i ++ ) { if ( str . charAt ( i ) == ch ) return i ; } return - 1 ; } static int countSubStr ( String str , int n , char ch ) { int cnt = 0 ; int j = nextOccurrence ( str , n , 0 , ch ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j != - 1 && j < i ) { j = nextOccurrence ( str , n , j + 1 , ch ) ; } if ( j == - 1 ) break ; cnt += ( n - j ) ; } return cnt ; } static public void main ( String [ ] arg ) { String str = " geeksforgeeks " ; int n = str . length ( ) ; char ch = ' k ' ; System . out . println ( countSubStr ( str , n , ch ) ) ; } }
class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } public static void main ( String [ ] args ) { int L = 2 ; int P = ( int ) Math . pow ( 10 , 9 ) ; int ans = power ( 325 , L , P ) ; System . out . println ( ans ) ; } }
import java . util . * ; class GFG { public static void revereseArray ( int [ ] arr , int n ) { int [ ] rev = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) rev [ n - i - 1 ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = rev [ i ] ; } public static void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; printArray ( arr , n ) ; revereseArray ( arr , n ) ; System . out . println ( " Reversed ▁ array ▁ is " ) ; printArray ( arr , n ) ; } }
import java . io . * ; import static java . lang . Math . min ; import java . lang . * ; class GFG { public static void findString ( String str , int M ) { int N = str . length ( ) ; M = Math . min ( M , N ) ; String s1 = " " ; while ( M != 0 ) { s1 = " " ; for ( int i = 0 ; i < N ; i ++ ) { if ( str . charAt ( i ) == '0' ) { if ( ( str . charAt ( i ) == '1' && str . charAt ( i ) != '1' ) || ( str . charAt ( i ) == '1' && str . charAt ( i ) == '1' ) ) s1 += '1' ; else s1 += '0' ; } else s1 += '1' ; } if ( str == s1 ) break ; str = s1 ; M -- ; } System . out . print ( s1 ) ; } public static void main ( String [ ] args ) { String str = "0110100" ; int M = 3 ; findString ( str , M ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void indivisibleDigits ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { System . out . print ( arr [ i ] + " : ▁ " ) ; for ( int j = 2 ; j < 10 ; j ++ ) { int temp = arr [ i ] ; boolean flag = true ; while ( temp > 0 ) { if ( ( temp % 10 ) != 0 && ( temp % 10 ) % j == 0 ) { flag = false ; break ; } temp /= 10 ; } if ( flag ) { System . out . print ( j + " ▁ " ) ; } } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 4162 , 1152 , 99842 } ; int N = arr . length ; indivisibleDigits ( arr , N ) ; } }
import java . util . * ; class GFG { static void check ( String s1 , String s2 ) { int s1_0 = 0 , s2_0 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( s1 . charAt ( i ) == '0' ) { s1_0 ++ ; } if ( s2 . charAt ( i ) == '0' ) { s2_0 ++ ; } } if ( s1_0 != s2_0 ) { System . out . println ( " NO " ) ; return ; } else { int Count1 = 0 , Count2 = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) { if ( s1 . charAt ( i ) == '0' ) { Count1 ++ ; } if ( s2 . charAt ( i ) == '0' ) { Count2 ++ ; } if ( Count1 < Count2 ) { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; } } public static void main ( String [ ] args ) { String s1 = "100111" ; String s2 = "111010" ; check ( s1 , s2 ) ; s1 = "110100" ; s2 = "010101" ; check ( s1 , s2 ) ; } }
import java . util . * ; class GFG { static int maxEvenIntegers ( int arr [ ] , int N , int M ) { int ans = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < M ; j ++ ) { if ( arr [ i + j ] % 2 == 0 ) cnt ++ ; } ans = Math . max ( ans , cnt ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 4 , 7 , 6 } ; int K = 3 ; int N = arr . length ; System . out . print ( maxEvenIntegers ( arr , N , K ) + "NEW_LINE"); } }
import java . util . * ; import java . lang . * ; class GFG { static String check ( int arr [ ] , int n ) { Map < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hm . put ( arr [ i ] , 1 ) ; for ( int j = i + 1 ; j < n ; j ++ ) { hm . put ( arr [ j ] , hm . getOrDefault ( arr [ j ] , 0 ) + 1 ) ; boolean flag = false ; for ( Integer k : hm . values ( ) ) { if ( k == 1 ) { flag = true ; break ; } } if ( ! flag ) return " No " ; } hm . clear ( ) ; } return " Yes " ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 1 } ; int N = arr . length ; System . out . println ( check ( arr , N ) ) ; } }
import java . io . * ; class GFG { static int find_index ( int [ ] arr , int n , int K ) { int start = 0 ; int end = n - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] == K ) return mid ; else if ( arr [ mid ] < K ) start = mid + 1 ; else end = mid - 1 ; } return end + 1 ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 5 , 6 } ; int n = arr . length ; int K = 2 ; System . out . println ( find_index ( arr , n , K ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static boolean isPalindrome ( String str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; } static void formPalindrome ( String a , String b , int n ) { char aa [ ] = new char [ n + 2 ] ; char bb [ ] = new char [ n + 2 ] ; Arrays . fill ( aa , ' ▁ ' ) ; Arrays . fill ( bb , ' ▁ ' ) ; for ( int i = 1 ; i <= n ; i ++ ) { aa [ i ] = a . charAt ( i - 1 ) ; bb [ i ] = b . charAt ( i - 1 ) ; } boolean ok = false ; for ( int i = 0 ; i <= n + 1 ; i ++ ) { StringBuilder la = new StringBuilder ( ) ; StringBuilder ra = new StringBuilder ( ) ; StringBuilder lb = new StringBuilder ( ) ; StringBuilder rb = new StringBuilder ( ) ; for ( int j = 1 ; j <= i - 1 ; j ++ ) { la . append ( ( aa [ j ] == ' ▁ ' ) ? " " : aa [ j ] ) ; lb . append ( ( bb [ j ] == ' ▁ ' ) ? " " : bb [ j ] ) ; } for ( int j = i ; j <= n + 1 ; j ++ ) { ra . append ( ( aa [ j ] == ' ▁ ' ) ? " " : aa [ j ] ) ; rb . append ( ( bb [ j ] == ' ▁ ' ) ? " " : bb [ j ] ) ; } if ( isPalindrome ( la . toString ( ) + rb . toString ( ) ) || isPalindrome ( lb . toString ( ) + ra . toString ( ) ) ) { ok = true ; break ; } } if ( ok ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } public static void main ( String [ ] args ) { String A = " bdea " ; String B = " abbb " ; int N = 4 ; formPalindrome ( A , B , N ) ; } }
import java . awt . Point ; import java . util . HashSet ; class GFG { static void isCrossed ( String path ) { if ( path . length ( ) == 0 ) return ; boolean ans = false ; HashSet < Point > set = new HashSet < Point > ( ) ; int x = 0 , y = 0 ; set . add ( new Point ( x , y ) ) ; for ( int i = 0 ; i < path . length ( ) ; i ++ ) { if ( path . charAt ( i ) == ' N ' ) set . add ( new Point ( x , y ++ ) ) ; if ( path . charAt ( i ) == ' S ' ) set . add ( new Point ( x , y -- ) ) ; if ( path . charAt ( i ) == ' E ' ) set . add ( new Point ( x ++ , y ) ) ; if ( path . charAt ( i ) == ' W ' ) set . add ( new Point ( x -- , y ) ) ; if ( set . contains ( new Point ( x , y ) ) ) { ans = true ; break ; } } if ( ans ) System . out . print ( " Crossed " ) ; else System . out . print ( " Not ▁ Crossed " ) ; } public static void main ( String [ ] args ) { String path = " NESW " ; isCrossed ( path ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int lenghtOfLongestAP ( int A [ ] , int n ) { Map < Integer , Map < Integer , Integer > > dp = new HashMap < Integer , Map < Integer , Integer > > ( ) ; int res = 2 ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int d = A [ j ] - A [ i ] ; Map < Integer , Integer > temp ; if ( dp . containsKey ( d ) ) { temp = dp . get ( d ) ; if ( temp . containsKey ( i ) ) temp . put ( j , temp . get ( i ) + 1 ) ; else temp . put ( j , 2 ) ; } else { temp = new HashMap < Integer , Integer > ( ) ; temp . put ( j , 2 ) ; } dp . put ( d , temp ) ; res = Math . max ( res , temp . get ( j ) ) ; } } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 1 , 15 , 3 , 10 , 5 , 8 } ; int N = arr . length ; System . out . println ( lenghtOfLongestAP ( arr , N ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { static void checkSumOfNatural ( int n ) { int i = 1 ; boolean flag = false ; while ( i * ( i + 1 ) < n * 2 ) { int X = i * ( i + 1 ) ; int t = n * 2 - X ; int k = ( int ) Math . sqrt ( t ) ; if ( k * ( k + 1 ) == t ) { flag = true ; break ; } i += 1 ; } if ( flag ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String [ ] args ) { int n = 25 ; checkSumOfNatural ( n ) ; } }
class GFG { static class pair { int first , second ; } static boolean isPerfectSquare ( int n ) { double sr = Math . sqrt ( n ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } static void SubarrayHavingPerfectSquare ( int [ ] arr , int k ) { pair ans = new pair ( ) ; int sum = 0 , i ; for ( i = 0 ; i < k ; i ++ ) { sum += arr [ i ] ; } boolean found = false ; if ( isPerfectSquare ( sum ) ) { ans . first = 0 ; ans . second = i - 1 ; } else { for ( int j = i ; j < arr . length ; j ++ ) { sum = sum + arr [ j ] - arr [ j - k ] ; if ( isPerfectSquare ( sum ) ) { found = true ; ans . first = j - k + 1 ; ans . second = j ; } } for ( int k1 = ans . first ; k1 <= ans . second ; k1 ++ ) { System . out . print ( arr [ k1 ] + " ▁ " ) ; } } if ( found == false ) { System . out . print ( " - 1" ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 20 , 34 , 51 , 10 , 99 , 87 , 23 , 45 } ; int K = 3 ; SubarrayHavingPerfectSquare ( arr , K ) ; } }
import java . util . * ; class GFG { static void mirrorMatrix ( int mat1 [ ] [ ] , int mat2 [ ] [ ] , int N ) { int row = 0 ; int col = 0 ; boolean isMirrorImage = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat2 [ row ] [ col ] != mat1 [ i ] [ j ] ) { isMirrorImage = false ; } col ++ ; } col = 0 ; row ++ ; } if ( isMirrorImage ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } public static void main ( String [ ] args ) { int N = 4 ; int mat1 [ ] [ ] = { { 1 , 2 , 3 , 4 } , { 0 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int mat2 [ ] [ ] = { { 4 , 3 , 2 , 1 } , { 8 , 7 , 6 , 0 } , { 12 , 11 , 10 , 9 } , { 16 , 15 , 14 , 13 } } ; mirrorMatrix ( mat1 , mat2 , N ) ; } }
import java . util . * ; class GFG { static int splitstring ( String s ) { int n = s . length ( ) ; int zeros = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( s . charAt ( i ) == '0' ) zeros ++ ; if ( zeros % 3 != 0 ) return 0 ; if ( zeros == 0 ) return ( ( n - 1 ) * ( n - 2 ) ) / 2 ; int zerosInEachSubstring = zeros / 3 ; int waysOfFirstCut = 0 ; int waysOfSecondCut = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == '0' ) count ++ ; if ( count == zerosInEachSubstring ) waysOfFirstCut ++ ; else if ( count == 2 * zerosInEachSubstring ) waysOfSecondCut ++ ; } return waysOfFirstCut * waysOfSecondCut ; } public static void main ( String args [ ] ) { String s = "01010" ; System . out . println ( " The ▁ number ▁ of ▁ " + " ways ▁ to ▁ split ▁ is ▁ " + splitstring ( s ) ) ; } }
import java . util . * ; class GFG { static boolean canTransform ( String str1 , String str2 ) { String s1 = " " ; String s2 = " " ; for ( char c : str1 . toCharArray ( ) ) { if ( c != ' C ' ) { s1 += c ; } } for ( char c : str2 . toCharArray ( ) ) { if ( c != ' C ' ) { s2 += c ; } } if ( ! s1 . equals ( s2 ) ) return false ; int i = 0 ; int j = 0 ; int n = str1 . length ( ) ; while ( i < n && j < n ) { if ( str1 . charAt ( i ) == ' C ' ) { i ++ ; } else if ( str2 . charAt ( j ) == ' C ' ) { j ++ ; } else { if ( ( str1 . charAt ( i ) == ' A ' && i < j ) || ( str1 . charAt ( i ) == ' B ' && i > j ) ) { return false ; } i ++ ; j ++ ; } } return true ; } public static void main ( String [ ] args ) { String str1 = " BCCABCBCA " ; String str2 = " CBACCBBAC " ; if ( canTransform ( str1 , str2 ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
import java . util . * ; class GFG { static int X = 1 ; static int diameter = 0 ; static HashMap < Integer , Boolean > mp = new HashMap < > ( ) ; static void dfs ( int current_node , int prev_node , int len , boolean add_to_map , Vector < Integer > [ ] adj ) { if ( len > diameter ) { diameter = len ; X = current_node ; } if ( add_to_map && len == diameter ) { mp . put ( current_node , true ) ; } for ( int it : adj [ current_node ] ) { if ( it != prev_node ) dfs ( it , current_node , len + 1 , add_to_map , adj ) ; } } static void dfsUtility ( Vector < Integer > [ ] adj ) { dfs ( 1 , - 1 , 0 , false , adj ) ; int farthest_node = X ; dfs ( farthest_node , - 1 , 0 , false , adj ) ; dfs ( farthest_node , - 1 , 0 , true , adj ) ; dfs ( X , - 1 , 0 , true , adj ) ; } static void printDiameters ( Vector < Integer > [ ] adj ) { dfsUtility ( adj ) ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( mp . containsKey ( i ) && mp . get ( i ) == true ) System . out . print ( diameter + 1 + " , ▁ " ) ; else System . out . print ( diameter + " , ▁ " ) ; } } public static void main ( String [ ] args ) { Vector < Integer > [ ] adj = new Vector [ 7 ] ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; adj [ 1 ] . add ( 2 ) ; adj [ 2 ] . add ( 1 ) ; adj [ 1 ] . add ( 3 ) ; adj [ 3 ] . add ( 1 ) ; adj [ 2 ] . add ( 4 ) ; adj [ 4 ] . add ( 2 ) ; adj [ 2 ] . add ( 5 ) ; adj [ 5 ] . add ( 2 ) ; adj [ 2 ] . add ( 6 ) ; adj [ 6 ] . add ( 2 ) ; printDiameters ( adj ) ; } }
import java . io . * ; class GFG { static int knapSack ( int [ ] nums , int S ) { int sum = 0 ; for ( int i : nums ) sum += i ; if ( sum < S || - sum > - S || ( S + sum ) % 2 == 1 ) return 0 ; int [ ] dp = new int [ ( S + sum ) / 2 + 1 ] ; dp [ 0 ] = 1 ; for ( int num : nums ) { for ( int i = dp . length - 1 ; i >= num ; i -- ) { dp [ i ] += dp [ i - num ] ; } } return dp [ dp . length - 1 ] ; } public static void main ( String [ ] args ) { int S = 3 ; int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 , 5 } ; int answer = knapSack ( arr , S ) ; System . out . println ( answer ) ; } }
import java . util . * ; class GFG { static int no_of_subString ( String s , int N ) { int fre [ ] = new int [ 26 ] ; int str_len ; str_len = ( int ) s . length ( ) ; int count = 0 ; for ( int i = 0 ; i < str_len ; i ++ ) { Arrays . fill ( fre , 0 ) ; int max_index = 0 ; int dist = 0 ; for ( int j = i ; j < str_len ; j ++ ) { int x = s . charAt ( j ) - ' a ' ; if ( fre [ x ] == 0 ) dist ++ ; fre [ x ] ++ ; max_index = Math . max ( max_index , fre [ x ] ) ; if ( dist >= N && ( ( max_index * dist ) == ( j - i + 1 ) ) ) count ++ ; } } return count ; } public static void main ( String [ ] args ) { String s = " abhay " ; int N = 3 ; System . out . print ( no_of_subString ( s , N ) ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int [ ] [ ] mat = new int [ 1001 ] [ 1001 ] ; static int r , c , x , y ; static int dx [ ] = { 0 , - 1 , - 1 , - 1 , 0 , 1 , 1 , 1 } ; static int dy [ ] = { 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 } ; static void FindMinimumDistance ( ) { Queue < pair > q = new LinkedList < > ( ) ; q . add ( new pair ( x , y ) ) ; mat [ x ] [ y ] = 0 ; while ( ! q . isEmpty ( ) ) { x = q . peek ( ) . first ; y = q . peek ( ) . second ; q . remove ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) { int a = x + dx [ i ] ; int b = y + dy [ i ] ; if ( a < 0 a >= r b >= c b < 0 ) continue ; if ( mat [ a ] [ b ] == 0 ) { mat [ a ] [ b ] = mat [ x ] [ y ] + 1 ; q . add ( new pair ( a , b ) ) ; } } } } public static void main ( String [ ] args ) { r = 5 ; c = 5 ; x = 1 ; y = 1 ; int t = x ; int l = y ; mat [ x ] [ y ] = 0 ; FindMinimumDistance ( ) ; mat [ t ] [ l ] = 0 ; for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { System . out . print ( mat [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } }
class GFG { static boolean isVowel ( char c ) { if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) return true ; return false ; } static void countSubstrings ( String s , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i ; j < n ; j ++ ) { if ( isVowel ( s . charAt ( j ) ) ) { count ++ ; } if ( count % 2 == 0 ) result ++ ; } } System . out . println ( result ) ; } public static void main ( String [ ] args ) { int n = 5 ; String s = " abcde " ; countSubstrings ( s , n ) ; } }
public class Main { public static void checkPalindrome ( String S ) { int N = S . length ( ) ; boolean first_half = true ; boolean second_half = true ; int cnt = ( N / 2 ) - 1 ; for ( int i = 0 ; i < ( N / 2 ) ; i ++ ) { if ( S . charAt ( i ) != S . charAt ( cnt ) ) { first_half = false ; break ; } if ( S . charAt ( N / 2 + i ) != S . charAt ( N / 2 + cnt ) ) { second_half = false ; break ; } cnt -- ; } if ( first_half && second_half ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { String S = " momdad " ; checkPalindrome ( S ) ; } }
import java . util . * ; class GFG { static int longestSubarray ( int arr [ ] , int n , int k ) { int i , j , Max = 1 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { s . add ( arr [ i ] ) ; for ( j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] - arr [ j ] ) == 0 || Math . abs ( arr [ i ] - arr [ j ] ) == k ) { if ( ! s . contains ( arr [ j ] ) ) { if ( s . size ( ) == 2 ) break ; else s . add ( arr [ j ] ) ; } } else break ; } if ( s . size ( ) == 2 ) { Max = Math . max ( Max , j - i ) ; s . clear ( ) ; } else s . clear ( ) ; } return Max ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 2 , 2 , 5 , 5 , 5 } ; int N = arr . length ; int K = 1 ; int length = longestSubarray ( arr , N , K ) ; if ( length == 1 ) System . out . print ( - 1 ) ; else System . out . print ( length ) ; } }
class GFG { static int [ ] [ ] prefix_2D = new int [ 2005 ] [ 2005 ] ; static int subMatrixSum ( int i , int j , int len ) { return prefix_2D [ i ] [ j ] - prefix_2D [ i ] [ j - len ] - prefix_2D [ i - len ] [ j ] + prefix_2D [ i - len ] [ j - len ] ; } static int numberOfWays ( int a [ ] , int b [ ] , int n , int m , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) prefix_2D [ i ] [ j ] = 1 ; else prefix_2D [ i ] [ j ] = 0 ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_2D [ i ] [ j ] += prefix_2D [ i ] [ j - 1 ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { prefix_2D [ i ] [ j ] += prefix_2D [ i - 1 ] [ j ] ; } } int answer = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { int low = 1 ; int high = Math . min ( i , j ) ; while ( low < high ) { int mid = ( low + high ) >> 1 ; if ( subMatrixSum ( i , j , mid ) >= k ) { high = mid ; } else { low = mid + 1 ; } } if ( subMatrixSum ( i , j , low ) >= k ) { answer += ( Math . min ( i , j ) - low + 1 ) ; } } } return answer ; } public static void main ( String [ ] args ) { int N = 2 , M = 3 ; int A [ ] = { 1 , 2 } ; int B [ ] = { 1 , 2 , 3 } ; int K = 1 ; System . out . print ( numberOfWays ( A , B , N , M , K ) ) ; } }
import java . util . * ; class GFG { static int NO_OF_CHARS = 256 ; static int firstRepeating ( String str ) { boolean [ ] visited = new boolean [ NO_OF_CHARS ] ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) visited [ i ] = false ; int res = - 1 ; for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { if ( visited [ str . charAt ( i ) ] == false ) visited [ str . charAt ( i ) ] = true ; else res = i ; } return res ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int index = firstRepeating ( str ) ; if ( index == - 1 ) System . out . printf ( " Either ▁ all ▁ characters ▁ are ▁ " + " distinct ▁ or ▁ string ▁ is ▁ empty " ) ; else System . out . printf ( " First ▁ Repeating ▁ character " + " ▁ is ▁ % c " , str . charAt ( index ) ) ; } }
import java . util . * ; class GFG { static void findSumPairs ( int a [ ] , int n ) { Map < Integer , Integer > mpp = new HashMap < > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { mpp . put ( a [ i ] + a [ j ] , mpp . get ( a [ i ] + a [ j ] ) == null ? 1 : mpp . get ( a [ i ] + a [ j ] ) + 1 ) ; } } int occur = 0 ; for ( Map . Entry < Integer , Integer > entry : mpp . entrySet ( ) ) { if ( entry . getValue ( ) > occur ) { occur = entry . getValue ( ) ; } } for ( Map . Entry < Integer , Integer > entry : mpp . entrySet ( ) ) { if ( entry . getValue ( ) == occur ) System . out . println ( entry . getKey ( ) ) ; } } public static void main ( String args [ ] ) { int a [ ] = { 1 , 8 , 3 , 11 , 4 , 9 , 2 , 7 } ; int n = a . length ; findSumPairs ( a , n ) ; } }
import java . util . * ; class GFG { static int findSmallestAfterDel ( int arr [ ] , int m , int del [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . containsKey ( del [ i ] ) ) { mp . put ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . put ( del [ i ] , 1 ) ; } } int smallestElement = Integer . MAX_VALUE ; for ( int i = 0 ; i < m ; ++ i ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . remove ( arr [ i ] ) ; } else smallestElement = Math . min ( smallestElement , arr [ i ] ) ; } return smallestElement ; } public static void main ( String [ ] args ) { int array [ ] = { 5 , 12 , 33 , 4 , 56 , 12 , 20 } ; int m = array . length ; int del [ ] = { 12 , 4 , 56 , 5 } ; int n = del . length ; System . out . println ( findSmallestAfterDel ( array , m , del , n ) ) ; } }
import java . util . * ; class GFG { static int findlargestAfterDel ( int arr [ ] , int m , int del [ ] , int n ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( mp . containsKey ( del [ i ] ) ) { mp . put ( del [ i ] , mp . get ( del [ i ] ) + 1 ) ; } else { mp . put ( del [ i ] , 1 ) ; } } int largestElement = Integer . MIN_VALUE ; for ( int i = 0 ; i < m ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) - 1 ) ; if ( mp . get ( arr [ i ] ) == 0 ) mp . remove ( arr [ i ] ) ; } else largestElement = Math . max ( largestElement , arr [ i ] ) ; } return largestElement ; } public static void main ( String [ ] args ) { int array [ ] = { 5 , 12 , 33 , 4 , 56 , 12 , 20 } ; int m = array . length ; int del [ ] = { 12 , 33 , 56 , 5 } ; int n = del . length ; System . out . println ( findlargestAfterDel ( array , m , del , n ) ) ; } }
import java . io . * ; class GFG { static int solve ( int a [ ] , int n ) { int min1 = a [ 0 ] ; int max1 = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max1 ) max1 = a [ i ] ; if ( a [ i ] < min1 ) min1 = a [ i ] ; } return Math . abs ( min1 - max1 ) ; } public static void main ( String [ ] args ) { int [ ] arr = { - 1 , 2 , 3 , 4 , - 10 } ; int size = arr . length ; System . out . println ( " Largest ▁ gap ▁ is ▁ : ▁ " + solve ( arr , size ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void getMinimumSum ( int arr [ ] , int n ) { ArrayList < Integer > res = new ArrayList < Integer > ( ) ; ArrayList < Integer > pos = new ArrayList < Integer > ( ) ; ArrayList < Integer > neg = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) pos . add ( i ) ; else if ( arr [ i ] < 0 ) neg . add ( i ) ; } if ( pos . size ( ) >= 2 && neg . size ( ) >= 2 ) { int posMax = Integer . MIN_VALUE , posMaxIdx = - 1 ; int posMin = Integer . MAX_VALUE , posMinIdx = - 1 ; int negMax = Integer . MIN_VALUE , negMaxIdx = - 1 ; int negMin = Integer . MAX_VALUE , negMinIdx = - 1 ; for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos . get ( i ) ] > posMax ) { posMaxIdx = pos . get ( i ) ; posMax = arr [ posMaxIdx ] ; } } for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos . get ( i ) ] < posMin && pos . get ( i ) != posMaxIdx ) { posMinIdx = pos . get ( i ) ; posMin = arr [ posMinIdx ] ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( Math . abs ( arr [ neg . get ( i ) ] ) > negMax ) { negMaxIdx = neg . get ( i ) ; negMax = Math . abs ( arr [ negMaxIdx ] ) ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( Math . abs ( arr [ neg . get ( i ) ] ) < negMin && neg . get ( i ) != negMaxIdx ) { negMinIdx = neg . get ( i ) ; negMin = Math . abs ( arr [ negMinIdx ] ) ; } } double posVal = - 1.0 * ( double ) posMax / ( double ) posMin ; double negVal = - 1.0 * ( double ) negMax / ( double ) negMin ; if ( posVal < negVal ) { res . add ( arr [ posMinIdx ] ) ; res . add ( arr [ posMaxIdx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != posMinIdx && i != posMaxIdx ) { res . add ( arr [ i ] ) ; } } } else { res . add ( arr [ negMinIdx ] ) ; res . add ( arr [ negMaxIdx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != negMinIdx && i != negMaxIdx ) { res . add ( arr [ i ] ) ; } } } for ( int i = 0 ; i < res . size ( ) ; i ++ ) { System . out . print ( res . get ( i ) + " ▁ " ) ; } System . out . println ( ) ; } else if ( pos . size ( ) >= 2 ) { int posMax = Integer . MIN_VALUE , posMaxIdx = - 1 ; int posMin = Integer . MAX_VALUE , posMinIdx = - 1 ; for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos . get ( i ) ] > posMax ) { posMaxIdx = pos . get ( i ) ; posMax = arr [ posMaxIdx ] ; } } for ( int i = 0 ; i < pos . size ( ) ; i ++ ) { if ( arr [ pos . get ( i ) ] < posMin && pos . get ( i ) != posMaxIdx ) { posMinIdx = pos . get ( i ) ; posMin = arr [ posMinIdx ] ; } } res . add ( arr [ posMinIdx ] ) ; res . add ( arr [ posMaxIdx ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != posMinIdx && i != posMaxIdx ) { res . add ( arr [ i ] ) ; } } for ( int i = 0 ; i < res . size ( ) ; i ++ ) { System . out . print ( res . get ( i ) + " ▁ " ) ; } System . out . println ( ) ; } else if ( neg . size ( ) >= 2 ) { int negMax = Integer . MIN_VALUE , negMaxIdx = - 1 ; int negMin = Integer . MAX_VALUE , negMinIdx = - 1 ; for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( Math . abs ( arr [ neg . get ( i ) ] ) > negMax ) { negMaxIdx = neg . get ( i ) ; negMax = Math . abs ( arr [ negMaxIdx ] ) ; } } for ( int i = 0 ; i < neg . size ( ) ; i ++ ) { if ( Math . abs ( arr [ neg . get ( i ) ] ) < negMin && neg . get ( i ) != negMaxIdx ) { negMinIdx = neg . get ( i ) ; negMin = Math . abs ( arr [ negMinIdx ] ) ; } } res . add ( arr [ negMinIdx ] ) ; res . add ( arr [ negMaxIdx ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( i != negMinIdx && i != negMaxIdx ) res . add ( arr [ i ] ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . println ( res . get ( i ) + " ▁ " ) ; System . out . println ( ) ; } else { System . out . println ( " No ▁ swap ▁ required " ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { - 4 , 1 , 6 , - 3 , - 2 , - 1 } ; int n = arr . length ; getMinimumSum ( arr , n ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int missingNum ( int arr [ ] , int n ) { List < Integer > list = new ArrayList < > ( arr . length ) ; for ( int i : arr ) { list . add ( Integer . valueOf ( i ) ) ; } int minvalue = Collections . min ( list ) ; ; int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 12 , 11 , 15 } ; int n = arr . length ; System . out . println ( missingNum ( arr , n ) ) ; } }
import java . util . Arrays ; class GFG { static void maximumMex ( int arr [ ] , int N ) { int ans [ ] = new int [ 2 * N ] ; Arrays . sort ( ans ) ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i == 0 arr [ i ] != arr [ i - 1 ] ) { j += 1 ; ans [ j ] = arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { if ( i > 0 && arr [ i ] == arr [ i - 1 ] ) { j += 1 ; ans [ j ] = arr [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( ans [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 0 , 0 } ; int N = arr . length ; maximumMex ( arr , N ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ; class GFG { static ArrayList < Integer > bubble_sort ( ArrayList < Integer > ar ) { if ( ar . size ( ) <= 1 ) return ar ; if ( ar . size ( ) == 2 ) { if ( ar . get ( 0 ) < ar . get ( 1 ) ) return ar ; else return new ArrayList < Integer > ( Arrays . asList ( ar . get ( 1 ) , ar . get ( 0 ) ) ) ; } int a = ar . get ( 0 ) ; int b = ar . get ( 1 ) ; ArrayList < Integer > bs = new ArrayList < > ( ) ; for ( int i = 2 ; i < ar . size ( ) ; i ++ ) bs . add ( ar . get ( i ) ) ; ArrayList < Integer > res = new ArrayList < > ( ) ; if ( a < b ) { ArrayList < Integer > temp1 = new ArrayList < > ( ) ; temp1 . add ( b ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . add ( bs . get ( i ) ) ; ArrayList < Integer > v = bubble_sort ( temp1 ) ; v . add ( 0 , a ) ; res = v ; } else { ArrayList < Integer > temp1 = new ArrayList < > ( ) ; temp1 . add ( a ) ; for ( int i = 0 ; i < bs . size ( ) ; i ++ ) temp1 . add ( bs . get ( i ) ) ; ArrayList < Integer > v = bubble_sort ( temp1 ) ; v . add ( 0 , b ) ; res = v ; } ArrayList < Integer > pass = new ArrayList < > ( ) ; for ( int i = 0 ; i < res . size ( ) - 1 ; i ++ ) pass . add ( res . get ( i ) ) ; ArrayList < Integer > ans = bubble_sort ( pass ) ; ans . add ( res . get ( res . size ( ) - 1 ) ) ; return ans ; } public static void main ( String [ ] args ) { ArrayList < Integer > arr = new ArrayList < Integer > ( Arrays . asList ( 1 , 3 , 4 , 5 , 6 , 2 ) ) ; ArrayList < Integer > res = bubble_sort ( arr ) ; for ( int i = 0 ; i < res . size ( ) ; i ++ ) System . out . print ( res . get ( i ) + " ▁ " ) ; } }
import java . util . * ; class GFG { public static int solution ( int A , int B , int C ) { int arr [ ] = new int [ 3 ] ; arr [ 0 ] = A ; arr [ 1 ] = B ; arr [ 2 ] = C ; Arrays . sort ( arr ) ; if ( arr [ 2 ] < arr [ 0 ] + arr [ 1 ] ) return ( ( arr [ 0 ] + arr [ 1 ] + arr [ 2 ] ) / 2 ) ; else return ( arr [ 0 ] + arr [ 1 ] ) ; } public static void main ( String [ ] args ) { int A = 8 , B = 1 , C = 5 ; System . out . println ( solution ( A , B , C ) ) ; } }
import java . util . * ; class GFG { static int max_length = 0 ; static Vector < Integer > store = new Vector < Integer > ( ) ; static Vector < Integer > ans = new Vector < Integer > ( ) ; static void find_max_length ( int [ ] arr , int index , int sum , int k ) { sum = sum + arr [ index ] ; store . add ( arr [ index ] ) ; if ( sum == k ) { if ( max_length < store . size ( ) ) { max_length = store . size ( ) ; ans = store ; } } for ( int i = index + 1 ; i < arr . length ; i ++ ) { if ( sum + arr [ i ] <= k ) { find_max_length ( arr , i , sum , k ) ; store . remove ( store . size ( ) - 1 ) ; } else return ; } return ; } static int longestSubsequence ( int [ ] arr , int n , int k ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_length >= n - i ) break ; store . clear ( ) ; find_max_length ( arr , i , 0 , k ) ; } return max_length ; } public static void main ( String [ ] args ) { int [ ] arr = { - 3 , 0 , 1 , 1 , 2 } ; int n = arr . length ; int k = 1 ; System . out . print ( longestSubsequence ( arr , n , k ) ) ; } }
import java . io . * ; class GFG { static int getNumber ( int n , int k ) { int pos ; if ( ( n % 2 ) == 0 ) { pos = n / 2 ; } else { pos = ( n / 2 ) + 1 ; } if ( k <= pos ) { return ( k * 2 - 1 ) ; } else return ( ( k - pos ) * 2 ) ; } public static void main ( String [ ] args ) { int n = 8 , k = 5 ; System . out . println ( getNumber ( n , k ) ) ; } }
import java . util . Arrays ; import java . io . * ; class GFG { static int countSequences ( int arr [ ] , int n ) { int count = 1 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 7 , 3 , 5 , 10 } ; int n = arr . length ; System . out . println ( countSequences ( arr , n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static boolean checkFittingArrays ( int [ ] A , int [ ] B , int N ) { Arrays . sort ( A ) ; Arrays . sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; } public static void main ( String [ ] args ) { int A [ ] = { 7 , 5 , 3 , 2 } ; int B [ ] = { 5 , 4 , 8 , 7 } ; int N = A . length ; if ( checkFittingArrays ( A , B , N ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
class GFG { static void stableSelectionSort ( int [ ] a , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { int min = i ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ min ] > a [ j ] ) min = j ; int key = a [ min ] ; while ( min > i ) { a [ min ] = a [ min - 1 ] ; min -- ; } a [ i ] = key ; } } static void printArray ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String [ ] args ) { int [ ] a = { 4 , 5 , 3 , 2 , 4 , 1 } ; int n = a . length ; stableSelectionSort ( a , n ) ; printArray ( a , n ) ; } }
import java . io . * ; class PancakeSort { static void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } } static int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; } static int pancakeSort ( int arr [ ] , int n ) { for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { int mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } return 0 ; } static void printArray ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = arr . length ; pancakeSort ( arr , n ) ; System . out . println ( " Sorted ▁ Array : ▁ " ) ; printArray ( arr , n ) ; } }
import java . io . * ; class GFG { static void findArrayWithMaxProduct ( int arr [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) if ( arr [ i ] >= 0 ) { arr [ i ] = - arr [ i ] - 1 ; } if ( N % 2 == 1 ) { int max_element = - 1 ; int index = - 1 ; for ( int i = 0 ; i < N ; i ++ ) if ( Math . abs ( arr [ i ] ) > max_element ) { max_element = Math . abs ( arr [ i ] ) ; index = i ; } arr [ index ] = - arr [ index ] - 1 ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 3 , 0 , 1 } ; int N = arr . length ; findArrayWithMaxProduct ( arr , N ) ; } }
import java . lang . * ; import java . io . * ; import java . util . * ; class GFG { static int N = 100000 + 5 ; static int visited [ ] = new int [ N ] ; static void construct_tree ( int weights [ ] , int n ) { int minimum = Arrays . stream ( weights ) . min ( ) . getAsInt ( ) ; int maximum = Arrays . stream ( weights ) . max ( ) . getAsInt ( ) ; if ( minimum == maximum ) { System . out . println ( " No " ) ; return ; } else { System . out . println ( " Yes " ) ; } int root = weights [ 0 ] ; visited [ 1 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root && visited [ i + 1 ] == 0 ) { System . out . println ( 1 + " ▁ " + ( i + 1 ) + " ▁ " ) ; visited [ i + 1 ] = 1 ; } } int notroot = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] != root ) { notroot = i + 1 ; break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( weights [ i ] == root && visited [ i + 1 ] == 0 ) { System . out . println ( notroot + " ▁ " + ( i + 1 ) ) ; visited [ i + 1 ] = 1 ; } } } public static void main ( String [ ] args ) { int weights [ ] = { 1 , 2 , 1 , 2 , 5 } ; int N = weights . length ; construct_tree ( weights , N ) ; } }
import java . util . * ; class GFG { static void addEdge ( Vector < Integer > adj [ ] , int u , int v ) { adj [ u ] . add ( v ) ; adj [ v ] . add ( u ) ; } static int cnt = 0 ; static boolean [ ] visited ; static void DFS ( int u , Vector < Integer > adj [ ] , int fre [ ] , String S ) { visited [ u ] = true ; cnt ++ ; fre [ S . charAt ( u ) - ' a ' ] ++ ; for ( int i = 0 ; i < adj [ u ] . size ( ) ; i ++ ) { if ( ! visited [ adj [ u ] . get ( i ) ] ) { DFS ( adj [ u ] . get ( i ) , adj , fre , S ) ; } } } static void minimumOperations ( String S , int m ) { int V = 100 ; @ SuppressWarnings ( " unchecked " ) Vector < Integer > [ ] adj = new Vector [ V ] ; int total = 0 , N = S . length ( ) ; for ( int i = 0 ; i < adj . length ; i ++ ) adj [ i ] = new Vector < Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { addEdge ( adj , i , N - i - 1 ) ; addEdge ( adj , N - i - 1 , i ) ; } for ( int i = 0 ; i < N - m ; i ++ ) { addEdge ( adj , i , i + m ) ; addEdge ( adj , i + m , i ) ; } visited = new boolean [ V ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( ! visited [ i ] ) { int fre [ ] = new int [ 26 ] ; cnt = 0 ; int maxx = - 1 ; DFS ( i , adj , fre , S ) ; for ( int j = 0 ; j < 26 ; j ++ ) maxx = Math . max ( maxx , fre [ j ] ) ; total += cnt - maxx ; } } System . out . print ( total ) ; } public static void main ( String [ ] args ) { String S = " abaaba " ; int K = 2 ; minimumOperations ( S , K ) ; } }
import java . util . * ; class GFG { static int clearLastBit ( int N , int K ) { int mask = ( - 1 << K + 1 ) ; return N = N & mask ; } public static void main ( String [ ] args ) { int N = 730 , K = 3 ; System . out . print ( clearLastBit ( N , K ) ) ; } }
import java . util . * ; class GFG { static boolean isPossible ( int r , int b , int g ) { r = r % 3 ; b = b % 3 ; g = g % 3 ; if ( r == b b == g g == r ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { int R = 1 , B = 3 , G = 6 ; if ( isPossible ( R , B , G ) ) { System . out . print ( " Yes " + "NEW_LINE"); } else { System . out . print ( " No " + "NEW_LINE"); } } }
class GFG { static int countSetBitsUtil ( int x ) { if ( x <= 0 ) return 0 ; return ( ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ) ; } static int countSetBits ( int L , int R ) { int bitCount = 0 ; for ( int i = L ; i <= R ; i ++ ) { bitCount += countSetBitsUtil ( i ) ; } return bitCount ; } public static void main ( String [ ] args ) { int L = 3 , R = 5 ; System . out . printf ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ % d " , countSetBits ( L , R ) ) ; } }
class GFG { static int getMinCost ( int [ ] A , int [ ] B , int N ) { int mini = Integer . MAX_VALUE ; for ( int i = 0 ; i < N ; i ++ ) { mini = Math . min ( mini , Math . min ( A [ i ] , B [ i ] ) ) ; } return mini * ( 2 * N - 1 ) ; } public static void main ( String [ ] args ) { int N = 3 ; int [ ] A = { 1 , 4 , 2 } ; int [ ] B = { 10 , 6 , 12 } ; System . out . print ( getMinCost ( A , B , N ) ) ; } }
class GFG { static int findM ( int N ) { int M = 0 ; int MSB = ( int ) Math . log ( N ) ; for ( int i = 0 ; i < MSB ; i ++ ) { if ( ( N & ( 1 << i ) ) == 0 ) M += ( 1 << i ) ; } return M ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . print ( findM ( N ) ) ; } }
import java . io . * ; class GFG { static int maxModulosum ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } return sum - n ; } public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 3 , 4 , 6 } ; int n = a . length ; System . out . println ( maxModulosum ( a , n ) ) ; } }
import java . util . * ; class GFG { static void makeZero ( int x , int y , int a , int b ) { if ( x > y ) { int temp = x ; x = y ; y = temp ; } int tot_cost = ( y - x ) * a ; int cost1 = 2 * x * a ; int cost2 = x * b ; tot_cost += Math . min ( cost1 , cost2 ) ; System . out . print ( tot_cost ) ; } public static void main ( String args [ ] ) { int X = 1 , Y = 3 ; int cost1 = 391 , cost2 = 555 ; makeZero ( X , Y , cost1 , cost2 ) ; } }
import java . util . Scanner ; class Solution { public static void splitFraction ( int n , int d ) { long ar [ ] = new long [ n ] ; long first = d + n - 1 ; ar [ 0 ] = first ; for ( int i = 1 ; i < n ; i ++ ) { ar [ i ] = first * ( -- first ) ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ar [ i ] % n == 0 ) { System . out . print ( "1 / " + ar [ i ] / n + " , ▁ " ) ; } else { System . out . print ( n + " / " + ar [ i ] + " , ▁ " ) ; } } } public static void main ( String [ ] args ) throws Exception { int N = 4 ; int D = 2 ; splitFraction ( N , D ) ; } }
class GFG { static int findMinimumSubsequences ( String A , String B ) { int numberOfSubsequences = 1 ; int sizeOfB = B . length ( ) ; int sizeOfA = A . length ( ) ; int inf = 1000000 ; int [ ] [ ] next = new int [ 26 ] [ sizeOfB ] ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < sizeOfB ; j ++ ) { next [ i ] [ j ] = inf ; } } for ( int i = 0 ; i < sizeOfB ; i ++ ) { next [ B . charAt ( i ) - ' a ' ] [ i ] = i ; } for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = sizeOfB - 2 ; j >= 0 ; j -- ) { if ( next [ i ] [ j ] == inf ) { next [ i ] [ j ] = next [ i ] [ j + 1 ] ; } } } int pos = 0 ; int i = 0 ; while ( i < sizeOfA ) { if ( pos == 0 && next [ A . charAt ( i ) - ' a ' ] [ pos ] == inf ) { numberOfSubsequences = - 1 ; break ; } else if ( pos < sizeOfB && next [ A . charAt ( i ) - ' a ' ] [ pos ] < inf ) { int nextIndex = next [ A . charAt ( i ) - ' a ' ] [ pos ] + 1 ; pos = nextIndex ; i ++ ; } else { numberOfSubsequences ++ ; pos = 0 ; } } return numberOfSubsequences ; } public static void main ( String [ ] args ) { String A = " aacbe " ; String B = " aceab " ; System . out . print ( findMinimumSubsequences ( A , B ) ) ; } }
import java . util . * ; class GFG { public static int count_minimum_operations ( int n ) { if ( n == 2 ) { return 1 ; } else if ( n == 1 ) { return 0 ; } if ( n % 3 == 0 ) { return 1 + count_minimum_operations ( n / 3 ) ; } else if ( n % 3 == 1 ) { return 1 + count_minimum_operations ( n - 1 ) ; } else { return 1 + count_minimum_operations ( n + 1 ) ; } } public static void main ( String [ ] args ) { int n = 4 ; int ans = count_minimum_operations ( n ) ; System . out . println ( ans ) ; } }
class Gfg { public static int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( ( K - P ) * N ) ; } public static void main ( String args [ ] ) { int K , P , N ; K = 4 ; P = 1 ; N = 10 ; System . out . println ( problemsLeft ( K , P , N ) ) ; } }
import java . util . * ; class GFG { static int V = 5 ; static int [ ] parent = new int [ V ] ; static int INF = Integer . MAX_VALUE ; static int find ( int i ) { while ( parent [ i ] != i ) i = parent [ i ] ; return i ; } static void union1 ( int i , int j ) { int a = find ( i ) ; int b = find ( j ) ; parent [ a ] = b ; } static void kruskalMST ( int cost [ ] [ ] ) { for ( int i = 0 ; i < V ; i ++ ) parent [ i ] = i ; int edge_count = 0 ; while ( edge_count < V - 1 ) { int min = INF , a = - 1 , b = - 1 ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( find ( i ) != find ( j ) && cost [ i ] [ j ] < min ) { min = cost [ i ] [ j ] ; a = i ; b = j ; } } } union1 ( a , b ) ; System . out . printf ( "Edge %d:(%d, %d) cost:%d NEW_LINE", edge_count++, a, b, min); mincost += min ; } System . out . printf ( " Minimum cost = % d ", mincost); } public static void main ( String [ ] args ) { int cost [ ] [ ] = { { INF , 2 , INF , 6 , INF } , { 2 , INF , 3 , 8 , 5 } , { INF , 3 , INF , INF , 7 } , { 6 , 8 , INF , INF , 9 } , { INF , 5 , 7 , 9 , INF } , } ; kruskalMST ( cost ) ; } }
class GFG { static int findMinCost ( int [ ] [ ] arr , int X , int n , int i ) { if ( X <= 0 ) return 0 ; if ( i >= n ) return Integer . MAX_VALUE ; int inc = findMinCost ( arr , X - arr [ i ] [ 0 ] , n , i + 1 ) ; if ( inc != Integer . MAX_VALUE ) inc += arr [ i ] [ 1 ] ; int exc = findMinCost ( arr , X , n , i + 1 ) ; return Math . min ( inc , exc ) ; } public static void main ( String [ ] args ) { int [ ] [ ] arr = { { 4 , 3 } , { 3 , 2 } , { 2 , 4 } , { 1 , 3 } , { 4 , 2 } } ; int X = 7 ; int n = arr . length ; int ans = findMinCost ( arr , X , n , 0 ) ; if ( ans != Integer . MAX_VALUE ) System . out . println ( ans ) ; else System . out . println ( - 1 ) ; } }
import java . util . * ; class GFG { static Map < String , Integer > dp = new HashMap < > ( ) ; static int maxScore ( String s , int [ ] a ) { if ( dp . containsKey ( s ) ) return dp . get ( s ) ; int n = s . length ( ) ; if ( n == 0 ) return 0 ; if ( n == 1 ) return a [ 0 ] ; int head = 0 ; int mx = - 1 ; while ( head < n ) { int tail = head ; while ( tail < n ) { if ( s . charAt ( tail ) != s . charAt ( head ) ) { head = tail ; break ; } String sub = s . substring ( head , tail + 1 ) ; mx = Math . max ( mx , a [ sub . length ( ) - 1 ] + maxScore ( s . substring ( 0 , head ) + s . substring ( tail + 1 , s . length ( ) ) , a ) ) ; tail += 1 ; } if ( tail == n ) break ; } dp . put ( s , mx ) ; return mx ; } public static void main ( String [ ] args ) { String s = " abb " ; int [ ] a = { 1 , 3 , 1 } ; System . out . println ( ( maxScore ( s , a ) ) ) ; } }
import java . util . * ; class GFG { static int kadane ( Vector < Integer > v ) { int currSum = 0 ; int maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( int ) v . size ( ) ; i ++ ) { currSum += v . get ( i ) ; if ( currSum > maxSum ) { maxSum = currSum ; } if ( currSum < 0 ) { currSum = 0 ; } } return maxSum ; } static void maxSubmatrixSum ( int [ ] [ ] A ) { int r = A . length ; int c = A [ 0 ] . length ; int [ ] [ ] prefix = new int [ r ] [ ] ; for ( int i = 0 ; i < r ; i ++ ) { prefix [ i ] = new int ; for ( int j = 0 ; j < c ; j ++ ) { prefix [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) { if ( j == 0 ) prefix [ i ] [ j ] = A [ i ] [ j ] ; else prefix [ i ] [ j ] = A [ i ] [ j ] + prefix [ i ] [ j - 1 ] ; } } int maxSum = Integer . MIN_VALUE ; for ( int i = 0 ; i < c ; i ++ ) { for ( int j = i ; j < c ; j ++ ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int k = 0 ; k < r ; k ++ ) { int el = 0 ; if ( i == 0 ) el = prefix [ k ] [ j ] ; else el = prefix [ k ] [ j ] - prefix [ k ] [ i - 1 ] ; v . add ( el ) ; } maxSum = Math . max ( maxSum , kadane ( v ) ) ; } } System . out . print ( maxSum + "NEW_LINE"); } public static void main ( String [ ] args ) { int [ ] [ ] matrix = { { 0 , - 2 , - 7 , 0 } , { 9 , 2 , - 6 , 2 } , { - 4 , 1 , - 4 , 1 } , { - 1 , 8 , 0 , - 2 } } ; maxSubmatrixSum ( matrix ) ; } }
import java . io . * ; class GFG { static void numberofpairs ( int [ ] [ ] v , int k ) { int n = v . length ; if ( n % 2 == 1 ) { System . out . println ( 0 ) ; return ; } int ans = 0 ; int dp [ ] [ ] = new int [ k ] [ 2 ] ; for ( int i = 0 ; i < k ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( i + j ) % 2 == 0 ) dp [ v [ i ] [ j ] - 1 ] [ 0 ] ++ ; else dp [ v [ i ] [ j ] - 1 ] [ 1 ] ++ ; } } for ( int i = 0 ; i < k ; i ++ ) { for ( int j = i + 1 ; j < k ; j ++ ) { ans += dp [ i ] [ 0 ] * dp [ j ] [ 1 ] ; ans += dp [ i ] [ 1 ] * dp [ j ] [ 0 ] ; } } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 1 , 2 } , { 3 , 4 } } ; int K = 4 ; numberofpairs ( mat , K ) ; } }
import java . util . * ; class GFG { static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static int findMaxGCD ( int arr [ ] , int N ) { int high = 0 ; for ( int i = 0 ; i < N ; i ++ ) { high = Math . max ( high , arr [ i ] ) ; } int [ ] count = new int [ high + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { count [ arr [ i ] ] += 1 ; } int counter = 0 ; for ( int i = high ; i > 0 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 0 ; } static int maxlen ( int i , int j , int arr [ ] , int arr1 [ ] , int N , int maxgcd ) { int a = 1 ; if ( i >= N j >= N ) return 0 ; if ( __gcd ( arr [ i ] , arr1 [ j ] ) == maxgcd && arr [ i ] != arr1 [ j ] ) { a = Math . max ( a , 1 + maxlen ( i , j + 1 , arr , arr1 , N , maxgcd ) ) ; return a ; } return Math . max ( maxlen ( i + 1 , j , arr , arr1 , N , maxgcd ) , maxlen ( i , j + 1 , arr , arr1 , N , maxgcd ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 8 , 5 , 6 } ; int arr1 [ ] = { 1 , 2 , 8 , 5 , 6 } ; int n = arr . length ; Arrays . sort ( arr ) ; int maxgcd = findMaxGCD ( arr , n ) ; System . out . print ( maxlen ( 0 , 0 , arr , arr1 , n , maxgcd ) ) ; } }
import java . util . * ; class GFG { static int findWays ( int N , int dp [ ] ) { if ( N == 0 ) { return 1 ; } if ( dp [ N ] != - 1 ) { return dp [ N ] ; } int cnt = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { if ( N - i >= 0 ) { cnt = cnt + findWays ( N - i , dp ) ; } } return dp [ N ] = cnt ; } public static void main ( String [ ] args ) { int N = 4 ; int [ ] dp = new int [ N + 1 ] ; for ( int i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; System . out . print ( findWays ( N , dp ) ) ; } }
class GFG { static int minDays ( int n ) { if ( n < 1 ) return n ; int cnt = 1 + Math . min ( n % 2 + minDays ( n / 2 ) , n % 3 + minDays ( n / 3 ) ) ; return cnt ; } public static void main ( String [ ] args ) { int N = 6 ; System . out . print ( minDays ( N ) ) ; } }
class GFG { public static void countNums ( int N ) { int dp [ ] [ ] = new int [ N ] [ 16 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { for ( int k = 0 ; k < 16 ; k ++ ) { int xor = j ^ k ; dp [ i ] [ xor ] += dp [ i - 1 ] [ k ] ; } } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ N - 1 ] [ i ] ; System . out . println ( count ) ; } public static void main ( String [ ] args ) { int N = 1 ; countNums ( N ) ; } }
class GFG { static int count ( int a [ ] , int M , int N ) { int cnt = 0 ; for ( int i = 1 ; i <= M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i % a [ j ] == 0 ) { cnt ++ ; break ; } } } return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 7 } ; int m = 100 ; int n = arr . length ; System . out . print ( count ( arr , m , n ) ) ; } }
